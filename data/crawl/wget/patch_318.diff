diff --git a/GNUmakefile b/GNUmakefile
index 35c8869..0c1bc38 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -1,21 +1,22 @@
 # Having a separate GNUmakefile lets me `include' the dynamically
-# generated rules created via Makefile.maint as well as Makefile.maint itself.
+# generated rules created via cfg.mk (package-local configuration)
+# as well as maint.mk (generic maintainer rules).
 # This makefile is used only if you run GNU Make.
 # It is necessary if you want to build targets usually of interest
 # only to the maintainer.
 
-# Copyright (C) 2001, 2003, 2006, 2007 Free Software Foundation, Inc.
-#
-# This program is free software; you can redistribute it and/or modify
+# Copyright (C) 2001, 2003, 2006-2008 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License,
-# or (at your option) any later version.
-#
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
-#
+
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
@@ -29,24 +30,55 @@ else
 SHELL = sh
 endif
 
+# If the user runs GNU make but has not yet run ./configure,
+# give them a diagnostic.
+_have-Makefile := $(shell test -f Makefile && echo yes)
+ifeq ($(_have-Makefile),yes)
+
 # Make tar archive easier to reproduce.
 export TAR_OPTIONS = --owner=0 --group=0 --numeric-owner
 
-# Ran autoreconf and configure or not?
-have-Makefile := $(shell test -f Makefile && echo yes)
-ifeq ($(have-Makefile),yes)
-
 include Makefile
--include $(srcdir)/maint-cfg.mk
+
+# Some projects override e.g., _autoreconf here.
+-include $(srcdir)/cfg.mk
 include $(srcdir)/maint.mk
 
+# Allow cfg.mk to override these.
+_build-aux ?= build-aux
+_autoreconf ?= autoreconf
+
+# Ensure that $(VERSION) is up to date for dist-related targets, but not
+# for others: rerunning autoreconf and recompiling everything isn't cheap.
+_have-git-version-gen := \
+  $(shell test -f $(srcdir)/$(_build-aux)/git-version-gen && echo yes)
+ifeq ($(_have-git-version-gen)0,yes$(MAKELEVEL))
+  _is-dist-target = $(filter-out %clean, \
+    $(filter maintainer-% dist% alpha beta major,$(MAKECMDGOALS)))
+  ifneq (,$(_is-dist-target))
+    _curr-ver := $(shell cd $(srcdir) && ./$(_build-aux)/git-version-gen \
+                   $(srcdir)/.tarball-version)
+    ifneq ($(_curr-ver),$(VERSION))
+      $(info INFO: running autoreconf for new version string: $(_curr-ver))
+      _dummy := $(shell cd $(srcdir) && rm -rf autom4te.cache .version \
+        && $(_autoreconf))
+    endif
+  endif
+endif
+
 else
 
 .DEFAULT_GOAL := abort-due-to-no-makefile
+srcdir = .
 
--include ./maint-cfg.mk
+# The package can override .DEFAULT_GOAL to run actions like autoreconf.
+-include ./cfg.mk
 include ./maint.mk
 
+ifeq ($(.DEFAULT_GOAL),abort-due-to-no-makefile)
+$(MAKECMDGOALS): abort-due-to-no-makefile
+endif
+
 abort-due-to-no-makefile:
 	@echo There seems to be no Makefile in this directory.   1>&2
 	@echo "You must run ./configure before running \`make'." 1>&2
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 6a63184..f7381d8 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -1,6 +1,6 @@
 ## DO NOT EDIT! GENERATED AUTOMATICALLY!
 ## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -9,7 +9,7 @@
 # the same distribution terms as the rest of that program.
 #
 # Generated by gnulib-tool.
-# Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl c-ctype getopt maintainer-makefile
+# Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl c-ctype getopt maintainer-makefile quote
 
 AUTOMAKE_OPTIONS = 1.5 gnits
 
@@ -40,6 +40,24 @@ libgnu_a_SOURCES += c-ctype.h c-ctype.c
 
 ## end   gnulib module c-ctype
 
+## begin gnulib module error
+
+
+EXTRA_DIST += error.c error.h
+
+EXTRA_libgnu_a_SOURCES += error.c
+
+## end   gnulib module error
+
+## begin gnulib module exitfail
+
+
+EXTRA_DIST += exitfail.c exitfail.h
+
+EXTRA_libgnu_a_SOURCES += exitfail.c
+
+## end   gnulib module exitfail
+
 ## begin gnulib module getopt
 
 BUILT_SOURCES += $(GETOPT_H)
@@ -65,6 +83,23 @@ libgnu_a_SOURCES += gettext.h
 
 ## end   gnulib module gettext-h
 
+## begin gnulib module gnumakefile
+
+distclean-local: clean-GNUmakefile
+clean-GNUmakefile:
+	test x'$(VPATH)' != x && rm -f $(top_builddir)/GNUmakefile || :
+
+EXTRA_DIST += $(top_srcdir)/GNUmakefile
+
+## end   gnulib module gnumakefile
+
+## begin gnulib module intprops
+
+
+EXTRA_DIST += intprops.h
+
+## end   gnulib module intprops
+
 ## begin gnulib module link-warning
 
 LINK_WARNING_H=$(top_srcdir)/./link-warning.h
@@ -75,10 +110,28 @@ EXTRA_DIST += $(top_srcdir)/./link-warning.h
 
 ## begin gnulib module maintainer-makefile
 
-EXTRA_DIST += $(top_srcdir)/./GNUmakefile $(top_srcdir)/./maint.mk
+EXTRA_DIST += $(top_srcdir)/maint.mk
 
 ## end   gnulib module maintainer-makefile
 
+## begin gnulib module quote
+
+
+EXTRA_DIST += quote.c quote.h
+
+EXTRA_libgnu_a_SOURCES += quote.c
+
+## end   gnulib module quote
+
+## begin gnulib module quotearg
+
+
+EXTRA_DIST += quotearg.c quotearg.h
+
+EXTRA_libgnu_a_SOURCES += quotearg.c
+
+## end   gnulib module quotearg
+
 ## begin gnulib module stdbool
 
 BUILT_SOURCES += $(STDBOOL_H)
@@ -97,6 +150,130 @@ EXTRA_DIST += stdbool.in.h
 
 ## end   gnulib module stdbool
 
+## begin gnulib module stdlib
+
+BUILT_SOURCES += stdlib.h
+
+# We need the following in order to create <stdlib.h> when the system
+# doesn't have one that works with the given compiler.
+stdlib.h: stdlib.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_STDLIB_H''@|$(NEXT_STDLIB_H)|g' \
+	      -e 's|@''GNULIB_MALLOC_POSIX''@|$(GNULIB_MALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_REALLOC_POSIX''@|$(GNULIB_REALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_CALLOC_POSIX''@|$(GNULIB_CALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_GETSUBOPT''@|$(GNULIB_GETSUBOPT)|g' \
+	      -e 's|@''GNULIB_MKDTEMP''@|$(GNULIB_MKDTEMP)|g' \
+	      -e 's|@''GNULIB_MKSTEMP''@|$(GNULIB_MKSTEMP)|g' \
+	      -e 's|@''GNULIB_PUTENV''@|$(GNULIB_PUTENV)|g' \
+	      -e 's|@''GNULIB_SETENV''@|$(GNULIB_SETENV)|g' \
+	      -e 's|@''GNULIB_STRTOD''@|$(GNULIB_STRTOD)|g' \
+	      -e 's|@''GNULIB_UNSETENV''@|$(GNULIB_UNSETENV)|g' \
+	      -e 's|@''HAVE_CALLOC_POSIX''@|$(HAVE_CALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_GETSUBOPT''@|$(HAVE_GETSUBOPT)|g' \
+	      -e 's|@''HAVE_MALLOC_POSIX''@|$(HAVE_MALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_MKDTEMP''@|$(HAVE_MKDTEMP)|g' \
+	      -e 's|@''HAVE_REALLOC_POSIX''@|$(HAVE_REALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_SETENV''@|$(HAVE_SETENV)|g' \
+	      -e 's|@''HAVE_STRTOD''@|$(HAVE_STRTOD)|g' \
+	      -e 's|@''HAVE_UNSETENV''@|$(HAVE_UNSETENV)|g' \
+	      -e 's|@''REPLACE_MKSTEMP''@|$(REPLACE_MKSTEMP)|g' \
+	      -e 's|@''REPLACE_PUTENV''@|$(REPLACE_PUTENV)|g' \
+	      -e 's|@''REPLACE_STRTOD''@|$(REPLACE_STRTOD)|g' \
+	      -e 's|@''VOID_UNSETENV''@|$(VOID_UNSETENV)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/stdlib.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += stdlib.h stdlib.h-t
+
+EXTRA_DIST += stdlib.in.h
+
+## end   gnulib module stdlib
+
+## begin gnulib module strerror
+
+
+EXTRA_DIST += strerror.c
+
+EXTRA_libgnu_a_SOURCES += strerror.c
+
+## end   gnulib module strerror
+
+## begin gnulib module string
+
+BUILT_SOURCES += string.h
+
+# We need the following in order to create <string.h> when the system
+# doesn't have one that works with the given compiler.
+string.h: string.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_STRING_H''@|$(NEXT_STRING_H)|g' \
+	      -e 's|@''GNULIB_MBSLEN''@|$(GNULIB_MBSLEN)|g' \
+	      -e 's|@''GNULIB_MBSNLEN''@|$(GNULIB_MBSNLEN)|g' \
+	      -e 's|@''GNULIB_MBSCHR''@|$(GNULIB_MBSCHR)|g' \
+	      -e 's|@''GNULIB_MBSRCHR''@|$(GNULIB_MBSRCHR)|g' \
+	      -e 's|@''GNULIB_MBSSTR''@|$(GNULIB_MBSSTR)|g' \
+	      -e 's|@''GNULIB_MBSCASECMP''@|$(GNULIB_MBSCASECMP)|g' \
+	      -e 's|@''GNULIB_MBSNCASECMP''@|$(GNULIB_MBSNCASECMP)|g' \
+	      -e 's|@''GNULIB_MBSPCASECMP''@|$(GNULIB_MBSPCASECMP)|g' \
+	      -e 's|@''GNULIB_MBSCASESTR''@|$(GNULIB_MBSCASESTR)|g' \
+	      -e 's|@''GNULIB_MBSCSPN''@|$(GNULIB_MBSCSPN)|g' \
+	      -e 's|@''GNULIB_MBSPBRK''@|$(GNULIB_MBSPBRK)|g' \
+	      -e 's|@''GNULIB_MBSSPN''@|$(GNULIB_MBSSPN)|g' \
+	      -e 's|@''GNULIB_MBSSEP''@|$(GNULIB_MBSSEP)|g' \
+	      -e 's|@''GNULIB_MBSTOK_R''@|$(GNULIB_MBSTOK_R)|g' \
+	      -e 's|@''GNULIB_MEMMEM''@|$(GNULIB_MEMMEM)|g' \
+	      -e 's|@''GNULIB_MEMPCPY''@|$(GNULIB_MEMPCPY)|g' \
+	      -e 's|@''GNULIB_MEMRCHR''@|$(GNULIB_MEMRCHR)|g' \
+	      -e 's|@''GNULIB_STPCPY''@|$(GNULIB_STPCPY)|g' \
+	      -e 's|@''GNULIB_STPNCPY''@|$(GNULIB_STPNCPY)|g' \
+	      -e 's|@''GNULIB_STRCHRNUL''@|$(GNULIB_STRCHRNUL)|g' \
+	      -e 's|@''GNULIB_STRDUP''@|$(GNULIB_STRDUP)|g' \
+	      -e 's|@''GNULIB_STRNDUP''@|$(GNULIB_STRNDUP)|g' \
+	      -e 's|@''GNULIB_STRNLEN''@|$(GNULIB_STRNLEN)|g' \
+	      -e 's|@''GNULIB_STRPBRK''@|$(GNULIB_STRPBRK)|g' \
+	      -e 's|@''GNULIB_STRSEP''@|$(GNULIB_STRSEP)|g' \
+	      -e 's|@''GNULIB_STRSTR''@|$(GNULIB_STRSTR)|g' \
+	      -e 's|@''GNULIB_STRCASESTR''@|$(GNULIB_STRCASESTR)|g' \
+	      -e 's|@''GNULIB_STRTOK_R''@|$(GNULIB_STRTOK_R)|g' \
+	      -e 's|@''GNULIB_STRERROR''@|$(GNULIB_STRERROR)|g' \
+	      -e 's|@''GNULIB_STRSIGNAL''@|$(GNULIB_STRSIGNAL)|g' \
+	      -e 's|@''HAVE_DECL_MEMMEM''@|$(HAVE_DECL_MEMMEM)|g' \
+	      -e 's|@''HAVE_MEMPCPY''@|$(HAVE_MEMPCPY)|g' \
+	      -e 's|@''HAVE_DECL_MEMRCHR''@|$(HAVE_DECL_MEMRCHR)|g' \
+	      -e 's|@''HAVE_STPCPY''@|$(HAVE_STPCPY)|g' \
+	      -e 's|@''HAVE_STPNCPY''@|$(HAVE_STPNCPY)|g' \
+	      -e 's|@''HAVE_STRCHRNUL''@|$(HAVE_STRCHRNUL)|g' \
+	      -e 's|@''HAVE_DECL_STRDUP''@|$(HAVE_DECL_STRDUP)|g' \
+	      -e 's|@''HAVE_STRNDUP''@|$(HAVE_STRNDUP)|g' \
+	      -e 's|@''HAVE_DECL_STRNDUP''@|$(HAVE_DECL_STRNDUP)|g' \
+	      -e 's|@''HAVE_DECL_STRNLEN''@|$(HAVE_DECL_STRNLEN)|g' \
+	      -e 's|@''HAVE_STRPBRK''@|$(HAVE_STRPBRK)|g' \
+	      -e 's|@''HAVE_STRSEP''@|$(HAVE_STRSEP)|g' \
+	      -e 's|@''HAVE_STRCASESTR''@|$(HAVE_STRCASESTR)|g' \
+	      -e 's|@''HAVE_DECL_STRTOK_R''@|$(HAVE_DECL_STRTOK_R)|g' \
+	      -e 's|@''HAVE_DECL_STRERROR''@|$(HAVE_DECL_STRERROR)|g' \
+	      -e 's|@''HAVE_DECL_STRSIGNAL''@|$(HAVE_DECL_STRSIGNAL)|g' \
+	      -e 's|@''REPLACE_MEMMEM''@|$(REPLACE_MEMMEM)|g' \
+	      -e 's|@''REPLACE_STRCASESTR''@|$(REPLACE_STRCASESTR)|g' \
+	      -e 's|@''REPLACE_STRSTR''@|$(REPLACE_STRSTR)|g' \
+	      -e 's|@''REPLACE_STRERROR''@|$(REPLACE_STRERROR)|g' \
+	      -e 's|@''REPLACE_STRSIGNAL''@|$(REPLACE_STRSIGNAL)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/string.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += string.h string.h-t
+
+EXTRA_DIST += string.in.h
+
+## end   gnulib module string
+
 ## begin gnulib module unistd
 
 BUILT_SOURCES += unistd.h
@@ -111,6 +288,7 @@ unistd.h: unistd.in.h
 	      -e 's|@''NEXT_UNISTD_H''@|$(NEXT_UNISTD_H)|g' \
 	      -e 's|@''GNULIB_CHOWN''@|$(GNULIB_CHOWN)|g' \
 	      -e 's|@''GNULIB_DUP2''@|$(GNULIB_DUP2)|g' \
+	      -e 's|@''GNULIB_ENVIRON''@|$(GNULIB_ENVIRON)|g' \
 	      -e 's|@''GNULIB_FCHDIR''@|$(GNULIB_FCHDIR)|g' \
 	      -e 's|@''GNULIB_FTRUNCATE''@|$(GNULIB_FTRUNCATE)|g' \
 	      -e 's|@''GNULIB_GETCWD''@|$(GNULIB_GETCWD)|g' \
@@ -125,12 +303,14 @@ unistd.h: unistd.in.h
 	      -e 's|@''HAVE_GETPAGESIZE''@|$(HAVE_GETPAGESIZE)|g' \
 	      -e 's|@''HAVE_READLINK''@|$(HAVE_READLINK)|g' \
 	      -e 's|@''HAVE_SLEEP''@|$(HAVE_SLEEP)|g' \
+	      -e 's|@''HAVE_DECL_ENVIRON''@|$(HAVE_DECL_ENVIRON)|g' \
 	      -e 's|@''HAVE_DECL_GETLOGIN_R''@|$(HAVE_DECL_GETLOGIN_R)|g' \
 	      -e 's|@''HAVE_OS_H''@|$(HAVE_OS_H)|g' \
 	      -e 's|@''HAVE_SYS_PARAM_H''@|$(HAVE_SYS_PARAM_H)|g' \
 	      -e 's|@''REPLACE_CHOWN''@|$(REPLACE_CHOWN)|g' \
 	      -e 's|@''REPLACE_FCHDIR''@|$(REPLACE_FCHDIR)|g' \
 	      -e 's|@''REPLACE_GETCWD''@|$(REPLACE_GETCWD)|g' \
+	      -e 's|@''REPLACE_GETPAGESIZE''@|$(REPLACE_GETPAGESIZE)|g' \
 	      -e 's|@''REPLACE_LCHOWN''@|$(REPLACE_LCHOWN)|g' \
 	      -e 's|@''REPLACE_LSEEK''@|$(REPLACE_LSEEK)|g' \
 	      < $(srcdir)/unistd.in.h; \
@@ -142,6 +322,69 @@ EXTRA_DIST += unistd.in.h
 
 ## end   gnulib module unistd
 
+## begin gnulib module wchar
+
+BUILT_SOURCES += $(WCHAR_H)
+
+# We need the following in order to create <wchar.h> when the system
+# version does not work standalone.
+wchar.h: wchar.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_WCHAR_H''@|$(NEXT_WCHAR_H)|g' \
+	      -e 's/@''HAVE_WCHAR_H''@/$(HAVE_WCHAR_H)/g' \
+	      -e 's|@''GNULIB_WCWIDTH''@|$(GNULIB_WCWIDTH)|g' \
+	      -e 's|@''HAVE_DECL_WCWIDTH''@|$(HAVE_DECL_WCWIDTH)|g' \
+	      -e 's|@''REPLACE_WCWIDTH''@|$(REPLACE_WCWIDTH)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	    < $(srcdir)/wchar.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += wchar.h wchar.h-t
+
+EXTRA_DIST += wchar.in.h
+
+## end   gnulib module wchar
+
+## begin gnulib module wctype
+
+BUILT_SOURCES += $(WCTYPE_H)
+
+# We need the following in order to create <wctype.h> when the system
+# doesn't have one that works with the given compiler.
+wctype.h: wctype.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''HAVE_WCTYPE_H''@/$(HAVE_WCTYPE_H)/g' \
+	      -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_WCTYPE_H''@|$(NEXT_WCTYPE_H)|g' \
+	      -e 's/@''HAVE_ISWCNTRL''@/$(HAVE_ISWCNTRL)/g' \
+	      -e 's/@''HAVE_WINT_T''@/$(HAVE_WINT_T)/g' \
+	      < $(srcdir)/wctype.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += wctype.h wctype.h-t
+
+EXTRA_DIST += wctype.in.h
+
+## end   gnulib module wctype
+
+## begin gnulib module xalloc
+
+
+EXTRA_DIST += xalloc.h xmalloc.c
+
+EXTRA_libgnu_a_SOURCES += xmalloc.c
+
+## end   gnulib module xalloc
+
+## begin gnulib module xalloc-die
+
+libgnu_a_SOURCES += xalloc-die.c
+
+## end   gnulib module xalloc-die
+
 
 mostlyclean-local: mostlyclean-generic
 	@for dir in '' $(MOSTLYCLEANDIRS); do \
diff --git a/lib/error.c b/lib/error.c
new file mode 100644
index 0000000..3177bd5
--- /dev/null
+++ b/lib/error.c
@@ -0,0 +1,338 @@
+/* Error handler for noninteractive utilities
+   Copyright (C) 1990-1998, 2000-2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */
+
+#if !_LIBC
+# include <config.h>
+#endif
+
+#include "error.h"
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if !_LIBC && ENABLE_NLS
+# include "gettext.h"
+# define _(msgid) gettext (msgid)
+#endif
+
+#ifdef _LIBC
+# include <libintl.h>
+# include <stdbool.h>
+# include <stdint.h>
+# include <wchar.h>
+# define mbsrtowcs __mbsrtowcs
+#endif
+
+#if USE_UNLOCKED_IO
+# include "unlocked-io.h"
+#endif
+
+#ifndef _
+# define _(String) String
+#endif
+
+/* If NULL, error will flush stdout, then print on stderr the program
+   name, a colon and a space.  Otherwise, error will call this
+   function without parameters instead.  */
+void (*error_print_progname) (void);
+
+/* This variable is incremented each time `error' is called.  */
+unsigned int error_message_count;
+
+#ifdef _LIBC
+/* In the GNU C library, there is a predefined variable for this.  */
+
+# define program_name program_invocation_name
+# include <errno.h>
+# include <limits.h>
+# include <libio/libioP.h>
+
+/* In GNU libc we want do not want to use the common name `error' directly.
+   Instead make it a weak alias.  */
+extern void __error (int status, int errnum, const char *message, ...)
+     __attribute__ ((__format__ (__printf__, 3, 4)));
+extern void __error_at_line (int status, int errnum, const char *file_name,
+			     unsigned int line_number, const char *message,
+			     ...)
+     __attribute__ ((__format__ (__printf__, 5, 6)));;
+# define error __error
+# define error_at_line __error_at_line
+
+# include <libio/iolibio.h>
+# define fflush(s) INTUSE(_IO_fflush) (s)
+# undef putc
+# define putc(c, fp) INTUSE(_IO_putc) (c, fp)
+
+# include <bits/libc-lock.h>
+
+#else /* not _LIBC */
+
+# if !HAVE_DECL_STRERROR_R && STRERROR_R_CHAR_P
+#  ifndef HAVE_DECL_STRERROR_R
+"this configure-time declaration test was not run"
+#  endif
+char *strerror_r ();
+# endif
+
+/* The calling program should define program_name and set it to the
+   name of the executing program.  */
+extern char *program_name;
+
+# if HAVE_STRERROR_R || defined strerror_r
+#  define __strerror_r strerror_r
+# endif	/* HAVE_STRERROR_R || defined strerror_r */
+#endif	/* not _LIBC */
+
+static void
+print_errno_message (int errnum)
+{
+  char const *s;
+
+#if defined HAVE_STRERROR_R || _LIBC
+  char errbuf[1024];
+# if STRERROR_R_CHAR_P || _LIBC
+  s = __strerror_r (errnum, errbuf, sizeof errbuf);
+# else
+  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)
+    s = errbuf;
+  else
+    s = 0;
+# endif
+#else
+  s = strerror (errnum);
+#endif
+
+#if !_LIBC
+  if (! s)
+    s = _("Unknown system error");
+#endif
+
+#if _LIBC
+  __fxprintf (NULL, ": %s", s);
+#else
+  fprintf (stderr, ": %s", s);
+#endif
+}
+
+static void
+error_tail (int status, int errnum, const char *message, va_list args)
+{
+#if _LIBC
+  if (_IO_fwide (stderr, 0) > 0)
+    {
+# define ALLOCA_LIMIT 2000
+      size_t len = strlen (message) + 1;
+      wchar_t *wmessage = NULL;
+      mbstate_t st;
+      size_t res;
+      const char *tmp;
+      bool use_malloc = false;
+
+      while (1)
+	{
+	  if (__libc_use_alloca (len * sizeof (wchar_t)))
+	    wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));
+	  else
+	    {
+	      if (!use_malloc)
+		wmessage = NULL;
+
+	      wchar_t *p = (wchar_t *) realloc (wmessage,
+						len * sizeof (wchar_t));
+	      if (p == NULL)
+		{
+		  free (wmessage);
+		  fputws_unlocked (L"out of memory\n", stderr);
+		  return;
+		}
+	      wmessage = p;
+	      use_malloc = true;
+	    }
+
+	  memset (&st, '\0', sizeof (st));
+	  tmp = message;
+
+	  res = mbsrtowcs (wmessage, &tmp, len, &st);
+	  if (res != len)
+	    break;
+
+	  if (__builtin_expect (len >= SIZE_MAX / 2, 0))
+	    {
+	      /* This really should not happen if everything is fine.  */
+	      res = (size_t) -1;
+	      break;
+	    }
+
+	  len *= 2;
+	}
+
+      if (res == (size_t) -1)
+	{
+	  /* The string cannot be converted.  */
+	  if (use_malloc)
+	    {
+	      free (wmessage);
+	      use_malloc = false;
+	    }
+	  wmessage = (wchar_t *) L"???";
+	}
+
+      __vfwprintf (stderr, wmessage, args);
+
+      if (use_malloc)
+	free (wmessage);
+    }
+  else
+#endif
+    vfprintf (stderr, message, args);
+  va_end (args);
+
+  ++error_message_count;
+  if (errnum)
+    print_errno_message (errnum);
+#if _LIBC
+  __fxprintf (NULL, "\n");
+#else
+  putc ('\n', stderr);
+#endif
+  fflush (stderr);
+  if (status)
+    exit (status);
+}
+
+
+/* Print the program name and error message MESSAGE, which is a printf-style
+   format string with optional args.
+   If ERRNUM is nonzero, print its corresponding system error message.
+   Exit with status STATUS if it is nonzero.  */
+void
+error (int status, int errnum, const char *message, ...)
+{
+  va_list args;
+
+#if defined _LIBC && defined __libc_ptf_call
+  /* We do not want this call to be cut short by a thread
+     cancellation.  Therefore disable cancellation for now.  */
+  int state = PTHREAD_CANCEL_ENABLE;
+  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),
+		   0);
+#endif
+
+  fflush (stdout);
+#ifdef _LIBC
+  _IO_flockfile (stderr);
+#endif
+  if (error_print_progname)
+    (*error_print_progname) ();
+  else
+    {
+#if _LIBC
+      __fxprintf (NULL, "%s: ", program_name);
+#else
+      fprintf (stderr, "%s: ", program_name);
+#endif
+    }
+
+  va_start (args, message);
+  error_tail (status, errnum, message, args);
+
+#ifdef _LIBC
+  _IO_funlockfile (stderr);
+# ifdef __libc_ptf_call
+  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);
+# endif
+#endif
+}
+
+/* Sometimes we want to have at most one error per line.  This
+   variable controls whether this mode is selected or not.  */
+int error_one_per_line;
+
+void
+error_at_line (int status, int errnum, const char *file_name,
+	       unsigned int line_number, const char *message, ...)
+{
+  va_list args;
+
+  if (error_one_per_line)
+    {
+      static const char *old_file_name;
+      static unsigned int old_line_number;
+
+      if (old_line_number == line_number
+	  && (file_name == old_file_name
+	      || strcmp (old_file_name, file_name) == 0))
+	/* Simply return and print nothing.  */
+	return;
+
+      old_file_name = file_name;
+      old_line_number = line_number;
+    }
+
+#if defined _LIBC && defined __libc_ptf_call
+  /* We do not want this call to be cut short by a thread
+     cancellation.  Therefore disable cancellation for now.  */
+  int state = PTHREAD_CANCEL_ENABLE;
+  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),
+		   0);
+#endif
+
+  fflush (stdout);
+#ifdef _LIBC
+  _IO_flockfile (stderr);
+#endif
+  if (error_print_progname)
+    (*error_print_progname) ();
+  else
+    {
+#if _LIBC
+      __fxprintf (NULL, "%s:", program_name);
+#else
+      fprintf (stderr, "%s:", program_name);
+#endif
+    }
+
+#if _LIBC
+  __fxprintf (NULL, file_name != NULL ? "%s:%d: " : " ",
+	      file_name, line_number);
+#else
+  fprintf (stderr, file_name != NULL ? "%s:%d: " : " ",
+	   file_name, line_number);
+#endif
+
+  va_start (args, message);
+  error_tail (status, errnum, message, args);
+
+#ifdef _LIBC
+  _IO_funlockfile (stderr);
+# ifdef __libc_ptf_call
+  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);
+# endif
+#endif
+}
+
+#ifdef _LIBC
+/* Make the weak alias.  */
+# undef error
+# undef error_at_line
+weak_alias (__error, error)
+weak_alias (__error_at_line, error_at_line)
+#endif
diff --git a/lib/error.h b/lib/error.h
new file mode 100644
index 0000000..6d49681
--- /dev/null
+++ b/lib/error.h
@@ -0,0 +1,65 @@
+/* Declaration for error-reporting function
+   Copyright (C) 1995, 1996, 1997, 2003, 2006, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ERROR_H
+#define _ERROR_H 1
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The __-protected variants of `format' and `printf' attributes
+   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#  define __format__ format
+#  define __printf__ printf
+# endif
+#endif
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* Print a message with `fprintf (stderr, FORMAT, ...)';
+   if ERRNUM is nonzero, follow it with ": " and strerror (ERRNUM).
+   If STATUS is nonzero, terminate the program with `exit (STATUS)'.  */
+
+extern void error (int __status, int __errnum, const char *__format, ...)
+     __attribute__ ((__format__ (__printf__, 3, 4)));
+
+extern void error_at_line (int __status, int __errnum, const char *__fname,
+			   unsigned int __lineno, const char *__format, ...)
+     __attribute__ ((__format__ (__printf__, 5, 6)));
+
+/* If NULL, error will flush stdout, then print on stderr the program
+   name, a colon and a space.  Otherwise, error will call this
+   function without parameters instead.  */
+extern void (*error_print_progname) (void);
+
+/* This variable is incremented each time `error' is called.  */
+extern unsigned int error_message_count;
+
+/* Sometimes we want to have at most one error per line.  This
+   variable controls whether this mode is selected or not.  */
+extern int error_one_per_line;
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* error.h */
diff --git a/lib/exitfail.c b/lib/exitfail.c
new file mode 100644
index 0000000..6d1fe4a
--- /dev/null
+++ b/lib/exitfail.c
@@ -0,0 +1,24 @@
+/* Failure exit status
+
+   Copyright (C) 2002, 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include "exitfail.h"
+
+#include <stdlib.h>
+
+int volatile exit_failure = EXIT_FAILURE;
diff --git a/lib/exitfail.h b/lib/exitfail.h
new file mode 100644
index 0000000..713f259
--- /dev/null
+++ b/lib/exitfail.h
@@ -0,0 +1,18 @@
+/* Failure exit status
+
+   Copyright (C) 2002 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+extern int volatile exit_failure;
diff --git a/lib/getopt.c b/lib/getopt.c
index 3c23601..f1e6d1f 100644
--- a/lib/getopt.c
+++ b/lib/getopt.c
@@ -2,7 +2,7 @@
    NOTE: getopt is now part of the C library, so if you don't know what
    "Keep this file name-space clean" means, talk to drepper@gnu.org
    before changing it!
-   Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001,2002,2003,2004,2006
+   Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001,2002,2003,2004,2006,2008
 	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -30,10 +30,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#ifdef __VMS
-# include <unixlib.h>
-#endif
-
 #ifdef _LIBC
 # include <libintl.h>
 #else
diff --git a/lib/intprops.h b/lib/intprops.h
new file mode 100644
index 0000000..002161e
--- /dev/null
+++ b/lib/intprops.h
@@ -0,0 +1,77 @@
+/* intprops.h -- properties of integer types
+
+   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert.  */
+
+#include <limits.h>
+
+/* The extra casts in the following macros work around compiler bugs,
+   e.g., in Cray C 5.0.3.0.  */
+
+/* True if the arithmetic type T is an integer type.  bool counts as
+   an integer.  */
+#define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
+
+/* True if negative values of the signed integer type T use two's
+   complement, ones' complement, or signed magnitude representation,
+   respectively.  Much GNU code assumes two's complement, but some
+   people like to be portable to all possible C hosts.  */
+#define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
+#define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
+#define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
+
+/* True if the arithmetic type T is signed.  */
+#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
+
+/* The maximum and minimum values for the integer type T.  These
+   macros have undefined behavior if T is signed and has padding bits.
+   If this is a problem for you, please let us know how to fix it for
+   your host.  */
+#define TYPE_MINIMUM(t) \
+  ((t) (! TYPE_SIGNED (t) \
+	? (t) 0 \
+	: TYPE_SIGNED_MAGNITUDE (t) \
+	? ~ (t) 0 \
+	: ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+#define TYPE_MAXIMUM(t) \
+  ((t) (! TYPE_SIGNED (t) \
+	? (t) -1 \
+	: ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+
+/* Return zero if T can be determined to be an unsigned type.
+   Otherwise, return 1.
+   When compiling with GCC, INT_STRLEN_BOUND uses this macro to obtain a
+   tighter bound.  Otherwise, it overestimates the true bound by one byte
+   when applied to unsigned types of size 2, 4, 16, ... bytes.
+   The symbol signed_type_or_expr__ is private to this header file.  */
+#if __GNUC__ >= 2
+# define signed_type_or_expr__(t) TYPE_SIGNED (__typeof__ (t))
+#else
+# define signed_type_or_expr__(t) 1
+#endif
+
+/* Bound on length of the string representing an integer type or expression T.
+   Subtract 1 for the sign bit if T is signed; log10 (2.0) < 146/485;
+   add 1 for integer division truncation; add 1 more for a minus sign
+   if needed.  */
+#define INT_STRLEN_BOUND(t) \
+  ((sizeof (t) * CHAR_BIT - signed_type_or_expr__ (t)) * 146 / 485 \
+   + signed_type_or_expr__ (t) + 1)
+
+/* Bound on buffer size needed to represent an integer type or expression T,
+   including the terminating null.  */
+#define INT_BUFSIZE_BOUND(t) (INT_STRLEN_BOUND (t) + 1)
diff --git a/lib/quote.c b/lib/quote.c
new file mode 100644
index 0000000..5e8b764
--- /dev/null
+++ b/lib/quote.c
@@ -0,0 +1,40 @@
+/* quote.c - quote arguments for output
+
+   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2005, 2006 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert <eggert@twinsun.com> */
+
+#include <config.h>
+
+#include "quotearg.h"
+#include "quote.h"
+
+/* Return an unambiguous printable representation of NAME,
+   allocated in slot N, suitable for diagnostics.  */
+char const *
+quote_n (int n, char const *name)
+{
+  return quotearg_n_style (n, locale_quoting_style, name);
+}
+
+/* Return an unambiguous printable representation of NAME,
+   suitable for diagnostics.  */
+char const *
+quote (char const *name)
+{
+  return quote_n (0, name);
+}
diff --git a/lib/quote.h b/lib/quote.h
new file mode 100644
index 0000000..c3660b1
--- /dev/null
+++ b/lib/quote.h
@@ -0,0 +1,21 @@
+/* quote.h - prototypes for quote.c
+
+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software
+   Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+char const *quote_n (int n, char const *name);
+char const *quote (char const *name);
diff --git a/lib/quotearg.c b/lib/quotearg.c
new file mode 100644
index 0000000..75fbc72
--- /dev/null
+++ b/lib/quotearg.c
@@ -0,0 +1,816 @@
+/* quotearg.c - quote arguments for output
+
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007,
+   2008 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert <eggert@twinsun.com> */
+
+#include <config.h>
+
+#include "quotearg.h"
+
+#include "xalloc.h"
+
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <wchar.h>
+#include <wctype.h>
+
+#include "gettext.h"
+#define _(msgid) gettext (msgid)
+#define N_(msgid) msgid
+
+#if !HAVE_MBRTOWC
+/* Disable multibyte processing entirely.  Since MB_CUR_MAX is 1, the
+   other macros are defined only for documentation and to satisfy C
+   syntax.  */
+# undef MB_CUR_MAX
+# define MB_CUR_MAX 1
+# undef mbstate_t
+# define mbstate_t int
+# define mbrtowc(pwc, s, n, ps) ((*(pwc) = *(s)) != 0)
+# define iswprint(wc) isprint ((unsigned char) (wc))
+# undef HAVE_MBSINIT
+#endif
+
+#if !defined mbsinit && !HAVE_MBSINIT
+# define mbsinit(ps) 1
+#endif
+
+#ifndef SIZE_MAX
+# define SIZE_MAX ((size_t) -1)
+#endif
+
+#define INT_BITS (sizeof (int) * CHAR_BIT)
+
+struct quoting_options
+{
+  /* Basic quoting style.  */
+  enum quoting_style style;
+
+  /* Additional flags.  Bitwise combination of enum quoting_flags.  */
+  int flags;
+
+  /* Quote the characters indicated by this bit vector even if the
+     quoting style would not normally require them to be quoted.  */
+  unsigned int quote_these_too[(UCHAR_MAX / INT_BITS) + 1];
+};
+
+/* Names of quoting styles.  */
+char const *const quoting_style_args[] =
+{
+  "literal",
+  "shell",
+  "shell-always",
+  "c",
+  "c-maybe",
+  "escape",
+  "locale",
+  "clocale",
+  0
+};
+
+/* Correspondences to quoting style names.  */
+enum quoting_style const quoting_style_vals[] =
+{
+  literal_quoting_style,
+  shell_quoting_style,
+  shell_always_quoting_style,
+  c_quoting_style,
+  c_maybe_quoting_style,
+  escape_quoting_style,
+  locale_quoting_style,
+  clocale_quoting_style
+};
+
+/* The default quoting options.  */
+static struct quoting_options default_quoting_options;
+
+/* Allocate a new set of quoting options, with contents initially identical
+   to O if O is not null, or to the default if O is null.
+   It is the caller's responsibility to free the result.  */
+struct quoting_options *
+clone_quoting_options (struct quoting_options *o)
+{
+  int e = errno;
+  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,
+				       sizeof *o);
+  errno = e;
+  return p;
+}
+
+/* Get the value of O's quoting style.  If O is null, use the default.  */
+enum quoting_style
+get_quoting_style (struct quoting_options *o)
+{
+  return (o ? o : &default_quoting_options)->style;
+}
+
+/* In O (or in the default if O is null),
+   set the value of the quoting style to S.  */
+void
+set_quoting_style (struct quoting_options *o, enum quoting_style s)
+{
+  (o ? o : &default_quoting_options)->style = s;
+}
+
+/* In O (or in the default if O is null),
+   set the value of the quoting options for character C to I.
+   Return the old value.  Currently, the only values defined for I are
+   0 (the default) and 1 (which means to quote the character even if
+   it would not otherwise be quoted).  */
+int
+set_char_quoting (struct quoting_options *o, char c, int i)
+{
+  unsigned char uc = c;
+  unsigned int *p =
+    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;
+  int shift = uc % INT_BITS;
+  int r = (*p >> shift) & 1;
+  *p ^= ((i & 1) ^ r) << shift;
+  return r;
+}
+
+/* In O (or in the default if O is null),
+   set the value of the quoting options flag to I, which can be a
+   bitwise combination of enum quoting_flags, or 0 for default
+   behavior.  Return the old value.  */
+int
+set_quoting_flags (struct quoting_options *o, int i)
+{
+  int r;
+  if (!o)
+    o = &default_quoting_options;
+  r = o->flags;
+  o->flags = i;
+  return r;
+}
+
+/* Return quoting options for STYLE, with no extra quoting.  */
+static struct quoting_options
+quoting_options_from_style (enum quoting_style style)
+{
+  struct quoting_options o;
+  o.style = style;
+  o.flags = 0;
+  memset (o.quote_these_too, 0, sizeof o.quote_these_too);
+  return o;
+}
+
+/* MSGID approximates a quotation mark.  Return its translation if it
+   has one; otherwise, return either it or "\"", depending on S.  */
+static char const *
+gettext_quote (char const *msgid, enum quoting_style s)
+{
+  char const *translation = _(msgid);
+  if (translation == msgid && s == clocale_quoting_style)
+    translation = "\"";
+  return translation;
+}
+
+/* Place into buffer BUFFER (of size BUFFERSIZE) a quoted version of
+   argument ARG (of size ARGSIZE), using QUOTING_STYLE, FLAGS, and
+   QUOTE_THESE_TOO to control quoting.
+   Terminate the output with a null character, and return the written
+   size of the output, not counting the terminating null.
+   If BUFFERSIZE is too small to store the output string, return the
+   value that would have been returned had BUFFERSIZE been large enough.
+   If ARGSIZE is SIZE_MAX, use the string length of the argument for ARGSIZE.
+
+   This function acts like quotearg_buffer (BUFFER, BUFFERSIZE, ARG,
+   ARGSIZE, O), except it breaks O into its component pieces and is
+   not careful about errno.  */
+
+static size_t
+quotearg_buffer_restyled (char *buffer, size_t buffersize,
+			  char const *arg, size_t argsize,
+			  enum quoting_style quoting_style, int flags,
+			  unsigned int const *quote_these_too)
+{
+  size_t i;
+  size_t len = 0;
+  char const *quote_string = 0;
+  size_t quote_string_len = 0;
+  bool backslash_escapes = false;
+  bool unibyte_locale = MB_CUR_MAX == 1;
+  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;
+
+#define STORE(c) \
+    do \
+      { \
+	if (len < buffersize) \
+	  buffer[len] = (c); \
+	len++; \
+      } \
+    while (0)
+
+  switch (quoting_style)
+    {
+    case c_maybe_quoting_style:
+      quoting_style = c_quoting_style;
+      elide_outer_quotes = true;
+      /* Fall through.  */
+    case c_quoting_style:
+      if (!elide_outer_quotes)
+	STORE ('"');
+      backslash_escapes = true;
+      quote_string = "\"";
+      quote_string_len = 1;
+      break;
+
+    case escape_quoting_style:
+      backslash_escapes = true;
+      elide_outer_quotes = false;
+      break;
+
+    case locale_quoting_style:
+    case clocale_quoting_style:
+      {
+	/* TRANSLATORS:
+	   Get translations for open and closing quotation marks.
+
+	   The message catalog should translate "`" to a left
+	   quotation mark suitable for the locale, and similarly for
+	   "'".  If the catalog has no translation,
+	   locale_quoting_style quotes `like this', and
+	   clocale_quoting_style quotes "like this".
+
+	   For example, an American English Unicode locale should
+	   translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and
+	   should translate "'" to U+201D (RIGHT DOUBLE QUOTATION
+	   MARK).  A British English Unicode locale should instead
+	   translate these to U+2018 (LEFT SINGLE QUOTATION MARK) and
+	   U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.
+
+	   If you don't know what to put here, please see
+	   <http://en.wikipedia.org/wiki/Quotation_mark#Glyphs>
+	   and use glyphs suitable for your language.  */
+
+	char const *left = gettext_quote (N_("`"), quoting_style);
+	char const *right = gettext_quote (N_("'"), quoting_style);
+	if (!elide_outer_quotes)
+	  for (quote_string = left; *quote_string; quote_string++)
+	    STORE (*quote_string);
+	backslash_escapes = true;
+	quote_string = right;
+	quote_string_len = strlen (quote_string);
+      }
+      break;
+
+    case shell_quoting_style:
+      quoting_style = shell_always_quoting_style;
+      elide_outer_quotes = true;
+      /* Fall through.  */
+    case shell_always_quoting_style:
+      if (!elide_outer_quotes)
+	STORE ('\'');
+      quote_string = "'";
+      quote_string_len = 1;
+      break;
+
+    case literal_quoting_style:
+      elide_outer_quotes = false;
+      break;
+
+    default:
+      abort ();
+    }
+
+  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)
+    {
+      unsigned char c;
+      unsigned char esc;
+
+      if (backslash_escapes
+	  && quote_string_len
+	  && i + quote_string_len <= argsize
+	  && memcmp (arg + i, quote_string, quote_string_len) == 0)
+	{
+	  if (elide_outer_quotes)
+	    goto force_outer_quoting_style;
+	  STORE ('\\');
+	}
+
+      c = arg[i];
+      switch (c)
+	{
+	case '\0':
+	  if (backslash_escapes)
+	    {
+	      if (elide_outer_quotes)
+		goto force_outer_quoting_style;
+	      STORE ('\\');
+	      if (i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')
+		{
+		  STORE ('0');
+		  STORE ('0');
+		}
+	      c = '0';
+	    }
+	  else if (flags & QA_ELIDE_NULL_BYTES)
+	    continue;
+	  break;
+
+	case '?':
+	  switch (quoting_style)
+	    {
+	    case shell_always_quoting_style:
+	      if (elide_outer_quotes)
+		goto force_outer_quoting_style;
+	      break;
+
+	    case c_quoting_style:
+	      if ((flags & QA_SPLIT_TRIGRAPHS)
+		  && i + 2 < argsize && arg[i + 1] == '?')
+		switch (arg[i + 2])
+		  {
+		  case '!': case '\'':
+		  case '(': case ')': case '-': case '/':
+		  case '<': case '=': case '>':
+		    /* Escape the second '?' in what would otherwise be
+		       a trigraph.  */
+		    if (elide_outer_quotes)
+		      goto force_outer_quoting_style;
+		    c = arg[i + 2];
+		    i += 2;
+		    STORE ('?');
+		    STORE ('"');
+		    STORE ('"');
+		    STORE ('?');
+		    break;
+
+		  default:
+		    break;
+		  }
+	      break;
+
+	    default:
+	      break;
+	    }
+	  break;
+
+	case '\a': esc = 'a'; goto c_escape;
+	case '\b': esc = 'b'; goto c_escape;
+	case '\f': esc = 'f'; goto c_escape;
+	case '\n': esc = 'n'; goto c_and_shell_escape;
+	case '\r': esc = 'r'; goto c_and_shell_escape;
+	case '\t': esc = 't'; goto c_and_shell_escape;
+	case '\v': esc = 'v'; goto c_escape;
+	case '\\': esc = c;
+	  /* No need to escape the escape if we are trying to elide
+	     outer quotes and nothing else is problematic.  */
+	  if (backslash_escapes && elide_outer_quotes && quote_string_len)
+	    goto store_c;
+
+	c_and_shell_escape:
+	  if (quoting_style == shell_always_quoting_style
+	      && elide_outer_quotes)
+	    goto force_outer_quoting_style;
+	  /* Fall through.  */
+	c_escape:
+	  if (backslash_escapes)
+	    {
+	      c = esc;
+	      goto store_escape;
+	    }
+	  break;
+
+	case '{': case '}': /* sometimes special if isolated */
+	  if (! (argsize == SIZE_MAX ? arg[1] == '\0' : argsize == 1))
+	    break;
+	  /* Fall through.  */
+	case '#': case '~':
+	  if (i != 0)
+	    break;
+	  /* Fall through.  */
+	case ' ':
+	case '!': /* special in bash */
+	case '"': case '$': case '&':
+	case '(': case ')': case '*': case ';':
+	case '<':
+	case '=': /* sometimes special in 0th or (with "set -k") later args */
+	case '>': case '[':
+	case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */
+	case '`': case '|':
+	  /* A shell special character.  In theory, '$' and '`' could
+	     be the first bytes of multibyte characters, which means
+	     we should check them with mbrtowc, but in practice this
+	     doesn't happen so it's not worth worrying about.  */
+	  if (quoting_style == shell_always_quoting_style
+	      && elide_outer_quotes)
+	    goto force_outer_quoting_style;
+	  break;
+
+	case '\'':
+	  if (quoting_style == shell_always_quoting_style)
+	    {
+	      if (elide_outer_quotes)
+		goto force_outer_quoting_style;
+	      STORE ('\'');
+	      STORE ('\\');
+	      STORE ('\'');
+	    }
+	  break;
+
+	case '%': case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4': case '5':
+	case '6': case '7': case '8': case '9': case ':':
+	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+	case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
+	case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
+	case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
+	case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':
+	case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':
+	case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':
+	case 'o': case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
+	  /* These characters don't cause problems, no matter what the
+	     quoting style is.  They cannot start multibyte sequences.  */
+	  break;
+
+	default:
+	  /* If we have a multibyte sequence, copy it until we reach
+	     its end, find an error, or come back to the initial shift
+	     state.  For C-like styles, if the sequence has
+	     unprintable characters, escape the whole sequence, since
+	     we can't easily escape single characters within it.  */
+	  {
+	    /* Length of multibyte sequence found so far.  */
+	    size_t m;
+
+	    bool printable;
+
+	    if (unibyte_locale)
+	      {
+		m = 1;
+		printable = isprint (c) != 0;
+	      }
+	    else
+	      {
+		mbstate_t mbstate;
+		memset (&mbstate, 0, sizeof mbstate);
+
+		m = 0;
+		printable = true;
+		if (argsize == SIZE_MAX)
+		  argsize = strlen (arg);
+
+		do
+		  {
+		    wchar_t w;
+		    size_t bytes = mbrtowc (&w, &arg[i + m],
+					    argsize - (i + m), &mbstate);
+		    if (bytes == 0)
+		      break;
+		    else if (bytes == (size_t) -1)
+		      {
+			printable = false;
+			break;
+		      }
+		    else if (bytes == (size_t) -2)
+		      {
+			printable = false;
+			while (i + m < argsize && arg[i + m])
+			  m++;
+			break;
+		      }
+		    else
+		      {
+			/* Work around a bug with older shells that "see" a '\'
+			   that is really the 2nd byte of a multibyte character.
+			   In practice the problem is limited to ASCII
+			   chars >= '@' that are shell special chars.  */
+			if ('[' == 0x5b && elide_outer_quotes
+			    && quoting_style == shell_always_quoting_style)
+			  {
+			    size_t j;
+			    for (j = 1; j < bytes; j++)
+			      switch (arg[i + m + j])
+				{
+				case '[': case '\\': case '^':
+				case '`': case '|':
+				  goto force_outer_quoting_style;
+
+				default:
+				  break;
+				}
+			  }
+
+			if (! iswprint (w))
+			  printable = false;
+			m += bytes;
+		      }
+		  }
+		while (! mbsinit (&mbstate));
+	      }
+
+	    if (1 < m || (backslash_escapes && ! printable))
+	      {
+		/* Output a multibyte sequence, or an escaped
+		   unprintable unibyte character.  */
+		size_t ilim = i + m;
+
+		for (;;)
+		  {
+		    if (backslash_escapes && ! printable)
+		      {
+			if (elide_outer_quotes)
+			  goto force_outer_quoting_style;
+			STORE ('\\');
+			STORE ('0' + (c >> 6));
+			STORE ('0' + ((c >> 3) & 7));
+			c = '0' + (c & 7);
+		      }
+		    if (ilim <= i + 1)
+		      break;
+		    STORE (c);
+		    c = arg[++i];
+		  }
+
+		goto store_c;
+	      }
+	  }
+	}
+
+      if (! ((backslash_escapes || elide_outer_quotes)
+	     && quote_these_too
+	     && quote_these_too[c / INT_BITS] & (1 << (c % INT_BITS))))
+	goto store_c;
+
+    store_escape:
+      if (elide_outer_quotes)
+	goto force_outer_quoting_style;
+      STORE ('\\');
+
+    store_c:
+      STORE (c);
+    }
+
+  if (len == 0 && quoting_style == shell_always_quoting_style
+      && elide_outer_quotes)
+    goto force_outer_quoting_style;
+
+  if (quote_string && !elide_outer_quotes)
+    for (; *quote_string; quote_string++)
+      STORE (*quote_string);
+
+  if (len < buffersize)
+    buffer[len] = '\0';
+  return len;
+
+ force_outer_quoting_style:
+  /* Don't reuse quote_these_too, since the addition of outer quotes
+     sufficiently quotes the specified characters.  */
+  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
+				   quoting_style,
+				   flags & ~QA_ELIDE_OUTER_QUOTES, NULL);
+}
+
+/* Place into buffer BUFFER (of size BUFFERSIZE) a quoted version of
+   argument ARG (of size ARGSIZE), using O to control quoting.
+   If O is null, use the default.
+   Terminate the output with a null character, and return the written
+   size of the output, not counting the terminating null.
+   If BUFFERSIZE is too small to store the output string, return the
+   value that would have been returned had BUFFERSIZE been large enough.
+   If ARGSIZE is SIZE_MAX, use the string length of the argument for
+   ARGSIZE.  */
+size_t
+quotearg_buffer (char *buffer, size_t buffersize,
+		 char const *arg, size_t argsize,
+		 struct quoting_options const *o)
+{
+  struct quoting_options const *p = o ? o : &default_quoting_options;
+  int e = errno;
+  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
+				       p->style, p->flags, p->quote_these_too);
+  errno = e;
+  return r;
+}
+
+/* Equivalent to quotearg_alloc (ARG, ARGSIZE, NULL, O).  */
+char *
+quotearg_alloc (char const *arg, size_t argsize,
+		struct quoting_options const *o)
+{
+  return quotearg_alloc_mem (arg, argsize, NULL, o);
+}
+
+/* Like quotearg_buffer (..., ARG, ARGSIZE, O), except return newly
+   allocated storage containing the quoted string, and store the
+   resulting size into *SIZE, if non-NULL.  The result can contain
+   embedded null bytes only if ARGSIZE is not SIZE_MAX, SIZE is not
+   NULL, and set_quoting_flags has not set the null byte elision
+   flag.  */
+char *
+quotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,
+		    struct quoting_options const *o)
+{
+  struct quoting_options const *p = o ? o : &default_quoting_options;
+  int e = errno;
+  /* Elide embedded null bytes if we can't return a size.  */
+  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);
+  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,
+					     flags, p->quote_these_too) + 1;
+  char *buf = xcharalloc (bufsize);
+  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,
+			    p->quote_these_too);
+  errno = e;
+  if (size)
+    *size = bufsize - 1;
+  return buf;
+}
+
+/* A storage slot with size and pointer to a value.  */
+struct slotvec
+{
+  size_t size;
+  char *val;
+};
+
+/* Preallocate a slot 0 buffer, so that the caller can always quote
+   one small component of a "memory exhausted" message in slot 0.  */
+static char slot0[256];
+static unsigned int nslots = 1;
+static struct slotvec slotvec0 = {sizeof slot0, slot0};
+static struct slotvec *slotvec = &slotvec0;
+
+void
+quotearg_free (void)
+{
+  struct slotvec *sv = slotvec;
+  unsigned int i;
+  for (i = 1; i < nslots; i++)
+    free (sv[i].val);
+  if (sv[0].val != slot0)
+    {
+      free (sv[0].val);
+      slotvec0.size = sizeof slot0;
+      slotvec0.val = slot0;
+    }
+  if (sv != &slotvec0)
+    {
+      free (sv);
+      slotvec = &slotvec0;
+    }
+  nslots = 1;
+}
+
+/* Use storage slot N to return a quoted version of argument ARG.
+   ARG is of size ARGSIZE, but if that is SIZE_MAX, ARG is a
+   null-terminated string.
+   OPTIONS specifies the quoting options.
+   The returned value points to static storage that can be
+   reused by the next call to this function with the same value of N.
+   N must be nonnegative.  N is deliberately declared with type "int"
+   to allow for future extensions (using negative values).  */
+static char *
+quotearg_n_options (int n, char const *arg, size_t argsize,
+		    struct quoting_options const *options)
+{
+  int e = errno;
+
+  unsigned int n0 = n;
+  struct slotvec *sv = slotvec;
+
+  if (n < 0)
+    abort ();
+
+  if (nslots <= n0)
+    {
+      /* FIXME: technically, the type of n1 should be `unsigned int',
+	 but that evokes an unsuppressible warning from gcc-4.0.1 and
+	 older.  If gcc ever provides an option to suppress that warning,
+	 revert to the original type, so that the test in xalloc_oversized
+	 is once again performed only at compile time.  */
+      size_t n1 = n0 + 1;
+      bool preallocated = (sv == &slotvec0);
+
+      if (xalloc_oversized (n1, sizeof *sv))
+	xalloc_die ();
+
+      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);
+      if (preallocated)
+	*sv = slotvec0;
+      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);
+      nslots = n1;
+    }
+
+  {
+    size_t size = sv[n].size;
+    char *val = sv[n].val;
+    /* Elide embedded null bytes since we don't return a size.  */
+    int flags = options->flags | QA_ELIDE_NULL_BYTES;
+    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,
+					     options->style, flags,
+					     options->quote_these_too);
+
+    if (size <= qsize)
+      {
+	sv[n].size = size = qsize + 1;
+	if (val != slot0)
+	  free (val);
+	sv[n].val = val = xcharalloc (size);
+	quotearg_buffer_restyled (val, size, arg, argsize, options->style,
+				  flags, options->quote_these_too);
+      }
+
+    errno = e;
+    return val;
+  }
+}
+
+char *
+quotearg_n (int n, char const *arg)
+{
+  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);
+}
+
+char *
+quotearg_n_mem (int n, char const *arg, size_t argsize)
+{
+  return quotearg_n_options (n, arg, argsize, &default_quoting_options);
+}
+
+char *
+quotearg (char const *arg)
+{
+  return quotearg_n (0, arg);
+}
+
+char *
+quotearg_mem (char const *arg, size_t argsize)
+{
+  return quotearg_n_mem (0, arg, argsize);
+}
+
+char *
+quotearg_n_style (int n, enum quoting_style s, char const *arg)
+{
+  struct quoting_options const o = quoting_options_from_style (s);
+  return quotearg_n_options (n, arg, SIZE_MAX, &o);
+}
+
+char *
+quotearg_n_style_mem (int n, enum quoting_style s,
+		      char const *arg, size_t argsize)
+{
+  struct quoting_options const o = quoting_options_from_style (s);
+  return quotearg_n_options (n, arg, argsize, &o);
+}
+
+char *
+quotearg_style (enum quoting_style s, char const *arg)
+{
+  return quotearg_n_style (0, s, arg);
+}
+
+char *
+quotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)
+{
+  return quotearg_n_style_mem (0, s, arg, argsize);
+}
+
+char *
+quotearg_char_mem (char const *arg, size_t argsize, char ch)
+{
+  struct quoting_options options;
+  options = default_quoting_options;
+  set_char_quoting (&options, ch, 1);
+  return quotearg_n_options (0, arg, argsize, &options);
+}
+
+char *
+quotearg_char (char const *arg, char ch)
+{
+  return quotearg_char_mem (arg, SIZE_MAX, ch);
+}
+
+char *
+quotearg_colon (char const *arg)
+{
+  return quotearg_char (arg, ':');
+}
+
+char *
+quotearg_colon_mem (char const *arg, size_t argsize)
+{
+  return quotearg_char_mem (arg, argsize, ':');
+}
diff --git a/lib/quotearg.h b/lib/quotearg.h
new file mode 100644
index 0000000..7700107
--- /dev/null
+++ b/lib/quotearg.h
@@ -0,0 +1,305 @@
+/* quotearg.h - quote arguments for output
+
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2006, 2008 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert <eggert@twinsun.com> */
+
+#ifndef QUOTEARG_H_
+# define QUOTEARG_H_ 1
+
+# include <stddef.h>
+
+/* Basic quoting styles.  For each style, an example is given on the
+   input strings "simple", "\0 \t\n'\"\033?""?/\\", and "a:b", using
+   quotearg_buffer, quotearg_mem, and quotearg_colon_mem with that
+   style and the default flags and quoted characters.  Note that the
+   examples are shown here as valid C strings rather than what
+   displays on a terminal (with "??/" as a trigraph for "\\").  */
+enum quoting_style
+  {
+    /* Output names as-is (ls --quoting-style=literal).  Can result in
+       embedded null bytes if QA_ELIDE_NULL_BYTES is not in
+       effect.
+
+       quotearg_buffer:
+       "simple", "\0 \t\n'\"\033??/\\", "a:b"
+       quotearg:
+       "simple", " \t\n'\"\033??/\\", "a:b"
+       quotearg_colon:
+       "simple", " \t\n'\"\033??/\\", "a:b"
+    */
+    literal_quoting_style,
+
+    /* Quote names for the shell if they contain shell metacharacters
+       or would cause ambiguous output (ls --quoting-style=shell).
+       Can result in embedded null bytes if QA_ELIDE_NULL_BYTES is not
+       in effect.
+
+       quotearg_buffer:
+       "simple", "'\0 \t\n'\\''\"\033??/\\'", "a:b"
+       quotearg:
+       "simple", "' \t\n'\\''\"\033??/\\'", "a:b"
+       quotearg_colon:
+       "simple", "' \t\n'\\''\"\033??/\\'", "'a:b'"
+    */
+    shell_quoting_style,
+
+    /* Quote names for the shell, even if they would normally not
+       require quoting (ls --quoting-style=shell-always).  Can result
+       in embedded null bytes if QA_ELIDE_NULL_BYTES is not in effect.
+       Behaves like shell_quoting_style if QA_ELIDE_OUTER_QUOTES is in
+       effect.
+
+       quotearg_buffer:
+       "'simple'", "'\0 \t\n'\\''\"\033??/\\'", "'a:b'"
+       quotearg:
+       "'simple'", "' \t\n'\\''\"\033??/\\'", "'a:b'"
+       quotearg_colon:
+       "'simple'", "' \t\n'\\''\"\033??/\\'", "'a:b'"
+    */
+    shell_always_quoting_style,
+
+    /* Quote names as for a C language string (ls --quoting-style=c).
+       Behaves like c_maybe_quoting_style if QA_ELIDE_OUTER_QUOTES is
+       in effect.  Split into consecutive strings if
+       QA_SPLIT_TRIGRAPHS.
+
+       quotearg_buffer:
+       "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
+       quotearg:
+       "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
+       quotearg_colon:
+       "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a\\:b\""
+    */
+    c_quoting_style,
+
+    /* Like c_quoting_style except omit the surrounding double-quote
+       characters if no quoted characters are encountered.
+
+       quotearg_buffer:
+       "simple", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "a:b"
+       quotearg:
+       "simple", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "a:b"
+       quotearg_colon:
+       "simple", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
+    */
+    c_maybe_quoting_style,
+
+    /* Like c_quoting_style except always omit the surrounding
+       double-quote characters (ls --quoting-style=escape).
+
+       quotearg_buffer:
+       "simple", "\\0 \\t\\n'\"\\033??/\\\\", "a:b"
+       quotearg:
+       "simple", "\\0 \\t\\n'\"\\033??/\\\\", "a:b"
+       quotearg_colon:
+       "simple", "\\0 \\t\\n'\"\\033??/\\\\", "a\\:b"
+    */
+    escape_quoting_style,
+
+    /* Like clocale_quoting_style, but quote `like this' instead of
+       "like this" in the default C locale (ls --quoting-style=locale).
+
+       LC_MESSAGES=C
+       quotearg_buffer:
+       "`simple'", "`\\0 \\t\\n\\'\"\\033??/\\\\'", "`a:b'"
+       quotearg:
+       "`simple'", "`\\0 \\t\\n\\'\"\\033??/\\\\'", "`a:b'"
+       quotearg_colon:
+       "`simple'", "`\\0 \\t\\n\\'\"\\033??/\\\\'", "`a\\:b'"
+
+       LC_MESSAGES=pt_PT.utf8
+       quotearg_buffer:
+       "\302\253simple\302\273",
+       "\302\253\\0 \\t\\n'\"\\033??/\\\\\302\253", "\302\253a:b\302\273"
+       quotearg:
+       "\302\253simple\302\273",
+       "\302\253\\0 \\t\\n'\"\\033??/\\\\\302\253", "\302\253a:b\302\273"
+       quotearg_colon:
+       "\302\253simple\302\273",
+       "\302\253\\0 \\t\\n'\"\\033??/\\\\\302\253", "\302\253a\\:b\302\273"
+    */
+    locale_quoting_style,
+
+    /* Like c_quoting_style except use quotation marks appropriate for
+       the locale (ls --quoting-style=clocale).
+
+       LC_MESSAGES=C
+       quotearg_buffer:
+       "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
+       quotearg:
+       "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a:b\""
+       quotearg_colon:
+       "\"simple\"", "\"\\0 \\t\\n'\\\"\\033??/\\\\\"", "\"a\\:b\""
+
+       LC_MESSAGES=pt_PT.utf8
+       quotearg_buffer:
+       "\302\253simple\302\273",
+       "\302\253\\0 \\t\\n'\"\\033??/\\\\\302\253", "\302\253a:b\302\273"
+       quotearg:
+       "\302\253simple\302\273",
+       "\302\253\\0 \\t\\n'\"\\033??/\\\\\302\253", "\302\253a:b\302\273"
+       quotearg_colon:
+       "\302\253simple\302\273",
+       "\302\253\\0 \\t\\n'\"\\033??/\\\\\302\253", "\302\253a\\:b\302\273"
+    */
+    clocale_quoting_style
+  };
+
+/* Flags for use in set_quoting_flags.  */
+enum quoting_flags
+  {
+    /* Always elide null bytes from styles that do not quote them,
+       even when the length of the result is available to the
+       caller.  */
+    QA_ELIDE_NULL_BYTES = 0x01,
+
+    /* Omit the surrounding quote characters if no escaped characters
+       are encountered.  Note that if no other character needs
+       escaping, then neither does the escape character.  */
+    QA_ELIDE_OUTER_QUOTES = 0x02,
+
+    /* In the c_quoting_style and c_maybe_quoting_style, split ANSI
+       trigraph sequences into concatenated strings (for example,
+       "?""?/" rather than "??/", which could be confused with
+       "\\").  */
+    QA_SPLIT_TRIGRAPHS = 0x04
+  };
+
+/* For now, --quoting-style=literal is the default, but this may change.  */
+# ifndef DEFAULT_QUOTING_STYLE
+#  define DEFAULT_QUOTING_STYLE literal_quoting_style
+# endif
+
+/* Names of quoting styles and their corresponding values.  */
+extern char const *const quoting_style_args[];
+extern enum quoting_style const quoting_style_vals[];
+
+struct quoting_options;
+
+/* The functions listed below set and use a hidden variable
+   that contains the default quoting style options.  */
+
+/* Allocate a new set of quoting options, with contents initially identical
+   to O if O is not null, or to the default if O is null.
+   It is the caller's responsibility to free the result.  */
+struct quoting_options *clone_quoting_options (struct quoting_options *o);
+
+/* Get the value of O's quoting style.  If O is null, use the default.  */
+enum quoting_style get_quoting_style (struct quoting_options *o);
+
+/* In O (or in the default if O is null),
+   set the value of the quoting style to S.  */
+void set_quoting_style (struct quoting_options *o, enum quoting_style s);
+
+/* In O (or in the default if O is null),
+   set the value of the quoting options for character C to I.
+   Return the old value.  Currently, the only values defined for I are
+   0 (the default) and 1 (which means to quote the character even if
+   it would not otherwise be quoted).  */
+int set_char_quoting (struct quoting_options *o, char c, int i);
+
+/* In O (or in the default if O is null),
+   set the value of the quoting options flag to I, which can be a
+   bitwise combination of enum quoting_flags, or 0 for default
+   behavior.  Return the old value.  */
+int set_quoting_flags (struct quoting_options *o, int i);
+
+/* Place into buffer BUFFER (of size BUFFERSIZE) a quoted version of
+   argument ARG (of size ARGSIZE), using O to control quoting.
+   If O is null, use the default.
+   Terminate the output with a null character, and return the written
+   size of the output, not counting the terminating null.
+   If BUFFERSIZE is too small to store the output string, return the
+   value that would have been returned had BUFFERSIZE been large enough.
+   If ARGSIZE is -1, use the string length of the argument for ARGSIZE.
+   On output, BUFFER might contain embedded null bytes if ARGSIZE was
+   not -1, the style of O does not use backslash escapes, and the
+   flags of O do not request elision of null bytes.*/
+size_t quotearg_buffer (char *buffer, size_t buffersize,
+			char const *arg, size_t argsize,
+			struct quoting_options const *o);
+
+/* Like quotearg_buffer, except return the result in a newly allocated
+   buffer.  It is the caller's responsibility to free the result.  The
+   result will not contain embedded null bytes.  */
+char *quotearg_alloc (char const *arg, size_t argsize,
+		      struct quoting_options const *o);
+
+/* Like quotearg_alloc, except that the length of the result,
+   excluding the terminating null byte, is stored into SIZE if it is
+   non-NULL.  The result might contain embedded null bytes if ARGSIZE
+   was not -1, SIZE was not NULL, the style of O does not use
+   backslash escapes, and the flags of O do not request elision of
+   null bytes.*/
+char *quotearg_alloc_mem (char const *arg, size_t argsize,
+			  size_t *size, struct quoting_options const *o);
+
+/* Use storage slot N to return a quoted version of the string ARG.
+   Use the default quoting options.
+   The returned value points to static storage that can be
+   reused by the next call to this function with the same value of N.
+   N must be nonnegative.  The output of all functions in the
+   quotearg_n family are guaranteed to not contain embedded null
+   bytes.*/
+char *quotearg_n (int n, char const *arg);
+
+/* Equivalent to quotearg_n (0, ARG).  */
+char *quotearg (char const *arg);
+
+/* Use storage slot N to return a quoted version of the argument ARG
+   of size ARGSIZE.  This is like quotearg_n (N, ARG), except it can
+   quote null bytes.  */
+char *quotearg_n_mem (int n, char const *arg, size_t argsize);
+
+/* Equivalent to quotearg_n_mem (0, ARG, ARGSIZE).  */
+char *quotearg_mem (char const *arg, size_t argsize);
+
+/* Use style S and storage slot N to return a quoted version of the string ARG.
+   This is like quotearg_n (N, ARG), except that it uses S with no other
+   options to specify the quoting method.  */
+char *quotearg_n_style (int n, enum quoting_style s, char const *arg);
+
+/* Use style S and storage slot N to return a quoted version of the
+   argument ARG of size ARGSIZE.  This is like quotearg_n_style
+   (N, S, ARG), except it can quote null bytes.  */
+char *quotearg_n_style_mem (int n, enum quoting_style s,
+			    char const *arg, size_t argsize);
+
+/* Equivalent to quotearg_n_style (0, S, ARG).  */
+char *quotearg_style (enum quoting_style s, char const *arg);
+
+/* Equivalent to quotearg_n_style_mem (0, S, ARG, ARGSIZE).  */
+char *quotearg_style_mem (enum quoting_style s,
+			  char const *arg, size_t argsize);
+
+/* Like quotearg (ARG), except also quote any instances of CH.  */
+char *quotearg_char (char const *arg, char ch);
+
+/* Like quotearg_char (ARG, CH), except it can quote null bytes.  */
+char *quotearg_char_mem (char const *arg, size_t argsize, char ch);
+
+/* Equivalent to quotearg_char (ARG, ':').  */
+char *quotearg_colon (char const *arg);
+
+/* Like quotearg_colon (ARG), except it can quote null bytes.  */
+char *quotearg_colon_mem (char const *arg, size_t argsize);
+
+/* Free any dynamically allocated memory.  */
+void quotearg_free (void);
+
+#endif /* !QUOTEARG_H_ */
diff --git a/lib/stdlib.in.h b/lib/stdlib.in.h
new file mode 100644
index 0000000..0181dd2
--- /dev/null
+++ b/lib/stdlib.in.h
@@ -0,0 +1,225 @@
+/* A GNU-like <stdlib.h>.
+
+   Copyright (C) 1995, 2001-2004, 2006-2008 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#if defined __need_malloc_and_calloc
+/* Special invocation convention inside glibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDLIB_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@
+
+#ifndef _GL_STDLIB_H
+#define _GL_STDLIB_H
+
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+/* Some systems do not define EXIT_*, despite otherwise supporting C89.  */
+#ifndef EXIT_SUCCESS
+# define EXIT_SUCCESS 0
+#endif
+/* Tandem/NSK and other platforms that define EXIT_FAILURE as -1 interfere
+   with proper operation of xargs.  */
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#elif EXIT_FAILURE != 1
+# undef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if @GNULIB_MALLOC_POSIX@
+# if !@HAVE_MALLOC_POSIX@
+#  undef malloc
+#  define malloc rpl_malloc
+extern void * malloc (size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef malloc
+# define malloc(s) \
+    (GL_LINK_WARNING ("malloc is not POSIX compliant everywhere - " \
+                      "use gnulib module malloc-posix for portability"), \
+     malloc (s))
+#endif
+
+
+#if @GNULIB_REALLOC_POSIX@
+# if !@HAVE_REALLOC_POSIX@
+#  undef realloc
+#  define realloc rpl_realloc
+extern void * realloc (void *ptr, size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef realloc
+# define realloc(p,s) \
+    (GL_LINK_WARNING ("realloc is not POSIX compliant everywhere - " \
+                      "use gnulib module realloc-posix for portability"), \
+     realloc (p, s))
+#endif
+
+
+#if @GNULIB_CALLOC_POSIX@
+# if !@HAVE_CALLOC_POSIX@
+#  undef calloc
+#  define calloc rpl_calloc
+extern void * calloc (size_t nmemb, size_t size);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef calloc
+# define calloc(n,s) \
+    (GL_LINK_WARNING ("calloc is not POSIX compliant everywhere - " \
+                      "use gnulib module calloc-posix for portability"), \
+     calloc (n, s))
+#endif
+
+
+#if @GNULIB_GETSUBOPT@
+/* Assuming *OPTIONP is a comma separated list of elements of the form
+   "token" or "token=value", getsubopt parses the first of these elements.
+   If the first element refers to a "token" that is member of the given
+   NULL-terminated array of tokens:
+     - It replaces the comma with a NUL byte, updates *OPTIONP to point past
+       the first option and the comma, sets *VALUEP to the value of the
+       element (or NULL if it doesn't contain an "=" sign),
+     - It returns the index of the "token" in the given array of tokens.
+   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.
+   For more details see the POSIX:2001 specification.
+   http://www.opengroup.org/susv3xsh/getsubopt.html */
+# if !@HAVE_GETSUBOPT@
+extern int getsubopt (char **optionp, char *const *tokens, char **valuep);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getsubopt
+# define getsubopt(o,t,v) \
+    (GL_LINK_WARNING ("getsubopt is unportable - " \
+                      "use gnulib module getsubopt for portability"), \
+     getsubopt (o, t, v))
+#endif
+
+
+#if @GNULIB_MKDTEMP@
+# if !@HAVE_MKDTEMP@
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+extern char * mkdtemp (char * /*template*/);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mkdtemp
+# define mkdtemp(t) \
+    (GL_LINK_WARNING ("mkdtemp is unportable - " \
+                      "use gnulib module mkdtemp for portability"), \
+     mkdtemp (t))
+#endif
+
+
+#if @GNULIB_MKSTEMP@
+# if @REPLACE_MKSTEMP@
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+#  define mkstemp rpl_mkstemp
+extern int mkstemp (char * /*template*/);
+# else
+/* On MacOS X 10.3, only <unistd.h> declares mkstemp.  */
+#  include <unistd.h>
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemp
+# define mkstemp(t) \
+    (GL_LINK_WARNING ("mkstemp is unportable - " \
+                      "use gnulib module mkstemp for portability"), \
+     mkstemp (t))
+#endif
+
+
+#if @GNULIB_PUTENV@
+# if @REPLACE_PUTENV@
+#  undef putenv
+#  define putenv rpl_putenv
+extern int putenv (char *string);
+# endif
+#endif
+
+
+#if @GNULIB_SETENV@
+# if !@HAVE_SETENV@
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+extern int setenv (const char *name, const char *value, int replace);
+# endif
+#endif
+
+
+#if @GNULIB_UNSETENV@
+# if @HAVE_UNSETENV@
+#  if @VOID_UNSETENV@
+/* On some systems, unsetenv() returns void.
+   This is the case for MacOS X 10.3, FreeBSD 4.8, NetBSD 1.6, OpenBSD 3.4.  */
+#   define unsetenv(name) ((unsetenv)(name), 0)
+#  endif
+# else
+/* Remove the variable NAME from the environment.  */
+extern int unsetenv (const char *name);
+# endif
+#endif
+
+
+#if @GNULIB_STRTOD@
+# if @REPLACE_STRTOD@
+#  define strtod rpl_strtod
+# endif
+# if !@HAVE_STRTOD@ || @REPLACE_STRTOD@
+ /* Parse a double from STRING, updating ENDP if appropriate.  */
+extern double strtod (const char *str, char **endp);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtod
+# define strtod(s, e)                           \
+    (GL_LINK_WARNING ("strtod is unportable - " \
+                      "use gnulib module strtod for portability"), \
+     strtod (s, e))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_STDLIB_H */
+#endif /* _GL_STDLIB_H */
+#endif
diff --git a/lib/strerror.c b/lib/strerror.c
new file mode 100644
index 0000000..9fe437d
--- /dev/null
+++ b/lib/strerror.c
@@ -0,0 +1,49 @@
+/* strerror.c --- POSIX compatible system error routine
+
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include <string.h>
+
+#if REPLACE_STRERROR
+
+# include <stdio.h>
+
+# include "intprops.h"
+
+# undef strerror
+# if ! HAVE_DECL_STRERROR
+#  define strerror(n) NULL
+# endif
+
+char *
+rpl_strerror (int n)
+{
+  char *result = strerror (n);
+
+  if (result == NULL || result[0] == '\0')
+    {
+      static char const fmt[] = "Unknown error (%d)";
+      static char mesg[sizeof fmt + INT_STRLEN_BOUND (n)];
+      sprintf (mesg, fmt, n);
+      return mesg;
+    }
+
+  return result;
+}
+
+#endif
diff --git a/lib/string.in.h b/lib/string.in.h
new file mode 100644
index 0000000..5c7597c
--- /dev/null
+++ b/lib/string.in.h
@@ -0,0 +1,569 @@
+/* A GNU-like <string.h>.
+
+   Copyright (C) 1995-1996, 2001-2008 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _GL_STRING_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_STRING_H@
+
+#ifndef _GL_STRING_H
+#define _GL_STRING_H
+
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The attribute __pure__ was added in gcc 2.96.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
+#  define __pure__ /* empty */
+# endif
+#endif
+
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Return the first occurrence of NEEDLE in HAYSTACK.  */
+#if @GNULIB_MEMMEM@
+# if @REPLACE_MEMMEM@
+#  define memmem rpl_memmem
+# endif
+# if ! @HAVE_DECL_MEMMEM@ || @REPLACE_MEMMEM@
+extern void *memmem (void const *__haystack, size_t __haystack_len,
+		     void const *__needle, size_t __needle_len)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memmem
+# define memmem(a,al,b,bl) \
+    (GL_LINK_WARNING ("memmem is unportable and often quadratic - " \
+                      "use gnulib module memmem-simple for portability, " \
+                      "and module memmem for speed" ), \
+     memmem (a, al, b, bl))
+#endif
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+#if @GNULIB_MEMPCPY@
+# if ! @HAVE_MEMPCPY@
+extern void *mempcpy (void *restrict __dest, void const *restrict __src,
+		      size_t __n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mempcpy
+# define mempcpy(a,b,n) \
+    (GL_LINK_WARNING ("mempcpy is unportable - " \
+                      "use gnulib module mempcpy for portability"), \
+     mempcpy (a, b, n))
+#endif
+
+/* Search backwards through a block for a byte (specified as an int).  */
+#if @GNULIB_MEMRCHR@
+# if ! @HAVE_DECL_MEMRCHR@
+extern void *memrchr (void const *, int, size_t)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memrchr
+# define memrchr(a,b,c) \
+    (GL_LINK_WARNING ("memrchr is unportable - " \
+                      "use gnulib module memrchr for portability"), \
+     memrchr (a, b, c))
+#endif
+
+/* Copy SRC to DST, returning the address of the terminating '\0' in DST.  */
+#if @GNULIB_STPCPY@
+# if ! @HAVE_STPCPY@
+extern char *stpcpy (char *restrict __dst, char const *restrict __src);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef stpcpy
+# define stpcpy(a,b) \
+    (GL_LINK_WARNING ("stpcpy is unportable - " \
+                      "use gnulib module stpcpy for portability"), \
+     stpcpy (a, b))
+#endif
+
+/* Copy no more than N bytes of SRC to DST, returning a pointer past the
+   last non-NUL byte written into DST.  */
+#if @GNULIB_STPNCPY@
+# if ! @HAVE_STPNCPY@
+#  define stpncpy gnu_stpncpy
+extern char *stpncpy (char *restrict __dst, char const *restrict __src,
+		      size_t __n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef stpncpy
+# define stpncpy(a,b,n) \
+    (GL_LINK_WARNING ("stpncpy is unportable - " \
+                      "use gnulib module stpncpy for portability"), \
+     stpncpy (a, b, n))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strchr
+# define strchr(s,c) \
+    (GL_LINK_WARNING ("strchr cannot work correctly on character strings " \
+                      "in some multibyte locales - " \
+                      "use mbschr if you care about internationalization"), \
+     strchr (s, c))
+#endif
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+#if @GNULIB_STRCHRNUL@
+# if ! @HAVE_STRCHRNUL@
+extern char *strchrnul (char const *__s, int __c_in)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strchrnul
+# define strchrnul(a,b) \
+    (GL_LINK_WARNING ("strchrnul is unportable - " \
+                      "use gnulib module strchrnul for portability"), \
+     strchrnul (a, b))
+#endif
+
+/* Duplicate S, returning an identical malloc'd string.  */
+#if @GNULIB_STRDUP@
+# if ! @HAVE_DECL_STRDUP@ && ! defined strdup
+extern char *strdup (char const *__s);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strdup
+# define strdup(a) \
+    (GL_LINK_WARNING ("strdup is unportable - " \
+                      "use gnulib module strdup for portability"), \
+     strdup (a))
+#endif
+
+/* Return a newly allocated copy of at most N bytes of STRING.  */
+#if @GNULIB_STRNDUP@
+# if ! @HAVE_STRNDUP@
+#  undef strndup
+#  define strndup rpl_strndup
+# endif
+# if ! @HAVE_STRNDUP@ || ! @HAVE_DECL_STRNDUP@
+extern char *strndup (char const *__string, size_t __n);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strndup
+# define strndup(a,n) \
+    (GL_LINK_WARNING ("strndup is unportable - " \
+                      "use gnulib module strndup for portability"), \
+     strndup (a, n))
+#endif
+
+/* Find the length (number of bytes) of STRING, but scan at most
+   MAXLEN bytes.  If no '\0' terminator is found in that many bytes,
+   return MAXLEN.  */
+#if @GNULIB_STRNLEN@
+# if ! @HAVE_DECL_STRNLEN@
+extern size_t strnlen (char const *__string, size_t __maxlen)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strnlen
+# define strnlen(a,n) \
+    (GL_LINK_WARNING ("strnlen is unportable - " \
+                      "use gnulib module strnlen for portability"), \
+     strnlen (a, n))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strcspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+# undef strcspn
+# define strcspn(s,a) \
+    (GL_LINK_WARNING ("strcspn cannot work correctly on character strings " \
+                      "in multibyte locales - " \
+                      "use mbscspn if you care about internationalization"), \
+     strcspn (s, a))
+#endif
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#if @GNULIB_STRPBRK@
+# if ! @HAVE_STRPBRK@
+extern char *strpbrk (char const *__s, char const *__accept)
+  __attribute__ ((__pure__));
+# endif
+# if defined GNULIB_POSIXCHECK
+/* strpbrk() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+#  undef strpbrk
+#  define strpbrk(s,a) \
+     (GL_LINK_WARNING ("strpbrk cannot work correctly on character strings " \
+                       "in multibyte locales - " \
+                       "use mbspbrk if you care about internationalization"), \
+      strpbrk (s, a))
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strpbrk
+# define strpbrk(s,a) \
+    (GL_LINK_WARNING ("strpbrk is unportable - " \
+                      "use gnulib module strpbrk for portability"), \
+     strpbrk (s, a))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it cannot work with multibyte strings.  */
+# undef strspn
+# define strspn(s,a) \
+    (GL_LINK_WARNING ("strspn cannot work correctly on character strings " \
+                      "in multibyte locales - " \
+                      "use mbsspn if you care about internationalization"), \
+     strspn (s, a))
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strrchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strrchr
+# define strrchr(s,c) \
+    (GL_LINK_WARNING ("strrchr cannot work correctly on character strings " \
+                      "in some multibyte locales - " \
+                      "use mbsrchr if you care about internationalization"), \
+     strrchr (s, c))
+#endif
+
+/* Search the next delimiter (char listed in DELIM) starting at *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP
+   to point to the next char after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of strtok() that is multithread-safe and supports
+   empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strtok_r().  */
+#if @GNULIB_STRSEP@
+# if ! @HAVE_STRSEP@
+extern char *strsep (char **restrict __stringp, char const *restrict __delim);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef strsep
+#  define strsep(s,d) \
+     (GL_LINK_WARNING ("strsep cannot work correctly on character strings " \
+                       "in multibyte locales - " \
+                       "use mbssep if you care about internationalization"), \
+      strsep (s, d))
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strsep
+# define strsep(s,d) \
+    (GL_LINK_WARNING ("strsep is unportable - " \
+                      "use gnulib module strsep for portability"), \
+     strsep (s, d))
+#endif
+
+#if @GNULIB_STRSTR@
+# if @REPLACE_STRSTR@
+#  define strstr rpl_strstr
+char *strstr (const char *haystack, const char *needle)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strstr() does not work with multibyte strings if the locale encoding is
+   different from UTF-8:
+   POSIX says that it operates on "strings", and "string" in POSIX is defined
+   as a sequence of bytes, not of characters.  */
+# undef strstr
+# define strstr(a,b) \
+    (GL_LINK_WARNING ("strstr is quadratic on many systems, and cannot " \
+                      "work correctly on character strings in most "    \
+                      "multibyte locales - " \
+                      "use mbsstr if you care about internationalization, " \
+                      "or use strstr if you care about speed"), \
+     strstr (a, b))
+#endif
+
+/* Find the first occurrence of NEEDLE in HAYSTACK, using case-insensitive
+   comparison.  */
+#if @GNULIB_STRCASESTR@
+# if @REPLACE_STRCASESTR@
+#  define strcasestr rpl_strcasestr
+# endif
+# if ! @HAVE_STRCASESTR@ || @REPLACE_STRCASESTR@
+extern char *strcasestr (const char *haystack, const char *needle)
+  __attribute__ ((__pure__));
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strcasestr() does not work with multibyte strings:
+   It is a glibc extension, and glibc implements it only for unibyte
+   locales.  */
+# undef strcasestr
+# define strcasestr(a,b) \
+    (GL_LINK_WARNING ("strcasestr does work correctly on character strings " \
+                      "in multibyte locales - " \
+                      "use mbscasestr if you care about " \
+                      "internationalization, or use c-strcasestr if you want " \
+                      "a locale independent function"), \
+     strcasestr (a, b))
+#endif
+
+/* Parse S into tokens separated by characters in DELIM.
+   If S is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+	char s[] = "-abc-=-def";
+	char *sp;
+	x = strtok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
+	x = strtok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
+	x = strtok_r(NULL, "=", &sp);	// x = NULL
+		// s = "abc\0-def\0"
+
+   This is a variant of strtok() that is multithread-safe.
+
+   For the POSIX documentation for this function, see:
+   http://www.opengroup.org/susv3xsh/strtok.html
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strsep().  */
+#if @GNULIB_STRTOK_R@
+# if ! @HAVE_DECL_STRTOK_R@
+extern char *strtok_r (char *restrict s, char const *restrict delim,
+		       char **restrict save_ptr);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef strtok_r
+#  define strtok_r(s,d,p) \
+     (GL_LINK_WARNING ("strtok_r cannot work correctly on character strings " \
+                       "in multibyte locales - " \
+                       "use mbstok_r if you care about internationalization"), \
+      strtok_r (s, d, p))
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtok_r
+# define strtok_r(s,d,p) \
+    (GL_LINK_WARNING ("strtok_r is unportable - " \
+                      "use gnulib module strtok_r for portability"), \
+     strtok_r (s, d, p))
+#endif
+
+
+/* The following functions are not specified by POSIX.  They are gnulib
+   extensions.  */
+
+#if @GNULIB_MBSLEN@
+/* Return the number of multibyte characters in the character string STRING.
+   This considers multibyte characters, unlike strlen, which counts bytes.  */
+extern size_t mbslen (const char *string);
+#endif
+
+#if @GNULIB_MBSNLEN@
+/* Return the number of multibyte characters in the character string starting
+   at STRING and ending at STRING + LEN.  */
+extern size_t mbsnlen (const char *string, size_t len);
+#endif
+
+#if @GNULIB_MBSCHR@
+/* Locate the first single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# define mbschr rpl_mbschr /* avoid collision with HP-UX function */
+extern char * mbschr (const char *string, int c);
+#endif
+
+#if @GNULIB_MBSRCHR@
+/* Locate the last single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strrchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# define mbsrchr rpl_mbsrchr /* avoid collision with HP-UX function */
+extern char * mbsrchr (const char *string, int c);
+#endif
+
+#if @GNULIB_MBSSTR@
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK.  Return NULL if NEEDLE is not found in HAYSTACK.
+   Unlike strstr(), this function works correctly in multibyte locales with
+   encodings different from UTF-8.  */
+extern char * mbsstr (const char *haystack, const char *needle);
+#endif
+
+#if @GNULIB_MBSCASECMP@
+/* Compare the character strings S1 and S2, ignoring case, returning less than,
+   equal to or greater than zero if S1 is lexicographically less than, equal to
+   or greater than S2.
+   Note: This function may, in multibyte locales, return 0 for strings of
+   different lengths!
+   Unlike strcasecmp(), this function works correctly in multibyte locales.  */
+extern int mbscasecmp (const char *s1, const char *s2);
+#endif
+
+#if @GNULIB_MBSNCASECMP@
+/* Compare the initial segment of the character string S1 consisting of at most
+   N characters with the initial segment of the character string S2 consisting
+   of at most N characters, ignoring case, returning less than, equal to or
+   greater than zero if the initial segment of S1 is lexicographically less
+   than, equal to or greater than the initial segment of S2.
+   Note: This function may, in multibyte locales, return 0 for initial segments
+   of different lengths!
+   Unlike strncasecmp(), this function works correctly in multibyte locales.
+   But beware that N is not a byte count but a character count!  */
+extern int mbsncasecmp (const char *s1, const char *s2, size_t n);
+#endif
+
+#if @GNULIB_MBSPCASECMP@
+/* Compare the initial segment of the character string STRING consisting of
+   at most mbslen (PREFIX) characters with the character string PREFIX,
+   ignoring case, returning less than, equal to or greater than zero if this
+   initial segment is lexicographically less than, equal to or greater than
+   PREFIX.
+   Note: This function may, in multibyte locales, return 0 if STRING is of
+   smaller length than PREFIX!
+   Unlike strncasecmp(), this function works correctly in multibyte
+   locales.  */
+extern char * mbspcasecmp (const char *string, const char *prefix);
+#endif
+
+#if @GNULIB_MBSCASESTR@
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK, using case-insensitive comparison.
+   Note: This function may, in multibyte locales, return success even if
+   strlen (haystack) < strlen (needle) !
+   Unlike strcasestr(), this function works correctly in multibyte locales.  */
+extern char * mbscasestr (const char *haystack, const char *needle);
+#endif
+
+#if @GNULIB_MBSCSPN@
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strcspn(), this function works correctly in multibyte locales.  */
+extern size_t mbscspn (const char *string, const char *accept);
+#endif
+
+#if @GNULIB_MBSPBRK@
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the pointer to it, or NULL if none
+   exists.
+   Unlike strpbrk(), this function works correctly in multibyte locales.  */
+# define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
+extern char * mbspbrk (const char *string, const char *accept);
+#endif
+
+#if @GNULIB_MBSSPN@
+/* Find the first occurrence in the character string STRING of any character
+   not in the character string REJECT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strspn(), this function works correctly in multibyte locales.  */
+extern size_t mbsspn (const char *string, const char *reject);
+#endif
+
+#if @GNULIB_MBSSEP@
+/* Search the next delimiter (multibyte character listed in the character
+   string DELIM) starting at the character string *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP to point
+   to the next multibyte character after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of mbstok_r() that supports empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbstok_r().  */
+extern char * mbssep (char **stringp, const char *delim);
+#endif
+
+#if @GNULIB_MBSTOK_R@
+/* Parse the character string STRING into tokens separated by characters in
+   the character string DELIM.
+   If STRING is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+	char s[] = "-abc-=-def";
+	char *sp;
+	x = mbstok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
+	x = mbstok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
+	x = mbstok_r(NULL, "=", &sp);	// x = NULL
+		// s = "abc\0-def\0"
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbssep().  */
+extern char * mbstok_r (char *string, const char *delim, char **save_ptr);
+#endif
+
+/* Map any int, typically from errno, into an error message.  */
+#if @GNULIB_STRERROR@
+# if @REPLACE_STRERROR@
+#  undef strerror
+#  define strerror rpl_strerror
+extern char *strerror (int);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strerror
+# define strerror(e) \
+    (GL_LINK_WARNING ("strerror is unportable - " \
+                      "use gnulib module strerror to guarantee non-NULL result"), \
+     strerror (e))
+#endif
+
+#if @GNULIB_STRSIGNAL@
+# if @REPLACE_STRSIGNAL@
+#  define strsignal rpl_strsignal
+# endif
+# if ! @HAVE_DECL_STRSIGNAL@ || @REPLACE_STRSIGNAL@
+extern char *strsignal (int __sig);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strsignal
+# define strsignal(a) \
+    (GL_LINK_WARNING ("strsignal is unportable - " \
+                      "use gnulib module strsignal for portability"), \
+     strsignal (a))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_STRING_H */
+#endif /* _GL_STRING_H */
diff --git a/lib/unistd.in.h b/lib/unistd.in.h
index a224889..17b29af 100644
--- a/lib/unistd.in.h
+++ b/lib/unistd.in.h
@@ -1,5 +1,5 @@
 /* Substitute for and wrapper around <unistd.h>.
-   Copyright (C) 2004-2007 Free Software Foundation, Inc.
+   Copyright (C) 2004-2008 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -86,6 +86,26 @@ extern int dup2 (int oldfd, int newfd);
 #endif
 
 
+#if @GNULIB_ENVIRON@
+# if !@HAVE_DECL_ENVIRON@
+/* Set of environment variables and values.  An array of strings of the form
+   "VARIABLE=VALUE", terminated with a NULL.  */
+#  if defined __APPLE__ && defined __MACH__
+#   include <crt_externs.h>
+#   define environ (*_NSGetEnviron ())
+#  else
+extern char **environ;
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef environ
+# define environ \
+    (GL_LINK_WARNING ("environ is unportable - " \
+                      "use gnulib module environ for portability"), \
+     environ)
+#endif
+
+
 #if @GNULIB_FCHDIR@
 # if @REPLACE_FCHDIR@
 
@@ -181,7 +201,10 @@ extern int getlogin_r (char *name, size_t size);
 
 
 #if @GNULIB_GETPAGESIZE@
-# if !@HAVE_GETPAGESIZE@
+# if @REPLACE_GETPAGESIZE@
+#  define getpagesize rpl_getpagesize
+extern int getpagesize (void);
+# elif !@HAVE_GETPAGESIZE@
 /* This is for POSIX systems.  */
 #  if !defined getpagesize && defined _SC_PAGESIZE
 #   if ! (defined __VMS && __VMS_VER < 70000000)
diff --git a/lib/wchar.in.h b/lib/wchar.in.h
new file mode 100644
index 0000000..8dfead2
--- /dev/null
+++ b/lib/wchar.in.h
@@ -0,0 +1,91 @@
+/* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
+
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * ISO C 99 <wchar.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/wchar.h.html>
+ *
+ * For now, this just ensures proper prerequisite inclusion order and
+ * the declaration of wcwidth().
+ */
+
+#ifdef __need_mbstate_t
+/* Special invocation convention inside glibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_WCHAR_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCHAR_H
+
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+
+/* Include the original <wchar.h> if it exists.
+   Some builds of uClibc lack it.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_WCHAR_H@
+# @INCLUDE_NEXT@ @NEXT_WCHAR_H@
+#endif
+
+#ifndef _GL_WCHAR_H
+#define _GL_WCHAR_H
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Return the number of screen columns needed for WC.  */
+#if @GNULIB_WCWIDTH@
+# if @REPLACE_WCWIDTH@
+#  undef wcwidth
+#  define wcwidth rpl_wcwidth
+extern int wcwidth (wchar_t);
+# else
+#  if !defined wcwidth && !@HAVE_DECL_WCWIDTH@
+/* wcwidth exists but is not declared.  */
+extern int wcwidth (int /* actually wchar_t */);
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcwidth
+# define wcwidth(w) \
+    (GL_LINK_WARNING ("wcwidth is unportable - " \
+                      "use gnulib module wcwidth for portability"), \
+     wcwidth (w))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_WCHAR_H */
+#endif /* _GL_WCHAR_H */
+#endif
diff --git a/lib/wctype.in.h b/lib/wctype.in.h
new file mode 100644
index 0000000..a86b5ad
--- /dev/null
+++ b/lib/wctype.in.h
@@ -0,0 +1,161 @@
+/* A substitute for ISO C99 <wctype.h>, for platforms that lack it.
+
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Bruno Haible and Paul Eggert.  */
+
+/*
+ * ISO C 99 <wctype.h> for platforms that lack it.
+ * <http://www.opengroup.org/susv3xbd/wctype.h.html>
+ *
+ * iswctype, towctrans, towlower, towupper, wctrans, wctype,
+ * wctrans_t, and wctype_t are not yet implemented.
+ */
+
+#ifndef _GL_WCTYPE_H
+
+#if @HAVE_WINT_T@
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.
+   Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.  */
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+# include <wchar.h>
+#endif
+
+/* Include the original <wctype.h> if it exists.
+   BeOS 5 has the functions but no <wctype.h>.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_WCTYPE_H@
+# @INCLUDE_NEXT@ @NEXT_WCTYPE_H@
+#endif
+
+#ifndef _GL_WCTYPE_H
+#define _GL_WCTYPE_H
+
+#if @HAVE_WINT_T@
+typedef wint_t __wctype_wint_t;
+#else
+typedef int __wctype_wint_t;
+#endif
+
+/* FreeBSD 4.4 to 4.11 has <wctype.h> but lacks the functions.
+   Assume all 12 functions are implemented the same way, or not at all.  */
+#if ! @HAVE_ISWCNTRL@
+
+/* IRIX 5.3 has macros but no functions, its isw* macros refer to an
+   undefined variable _ctmp_ and to <ctype.h> macros like _P, and they
+   refer to system functions like _iswctype that are not in the
+   standard C library.  Rather than try to get ancient buggy
+   implementations like this to work, just disable them.  */
+#  undef iswalnum
+#  undef iswalpha
+#  undef iswblank
+#  undef iswcntrl
+#  undef iswdigit
+#  undef iswgraph
+#  undef iswlower
+#  undef iswprint
+#  undef iswpunct
+#  undef iswspace
+#  undef iswupper
+#  undef iswxdigit
+
+static inline int
+iswalnum (__wctype_wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+	  || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z'));
+}
+
+static inline int
+iswalpha (__wctype_wint_t wc)
+{
+  return (wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z';
+}
+
+static inline int
+iswblank (__wctype_wint_t wc)
+{
+  return wc == ' ' || wc == '\t';
+}
+
+static inline int
+iswcntrl (__wctype_wint_t wc)
+{
+  return (wc & ~0x1f) == 0 || wc == 0x7f;
+}
+
+static inline int
+iswdigit (__wctype_wint_t wc)
+{
+  return wc >= '0' && wc <= '9';
+}
+
+static inline int
+iswgraph (__wctype_wint_t wc)
+{
+  return wc >= '!' && wc <= '~';
+}
+
+static inline int
+iswlower (__wctype_wint_t wc)
+{
+  return wc >= 'a' && wc <= 'z';
+}
+
+static inline int
+iswprint (__wctype_wint_t wc)
+{
+  return wc >= ' ' && wc <= '~';
+}
+
+static inline int
+iswpunct (__wctype_wint_t wc)
+{
+  return (wc >= '!' && wc <= '~'
+	  && !((wc >= '0' && wc <= '9')
+	       || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z')));
+}
+
+static inline int
+iswspace (__wctype_wint_t wc)
+{
+  return (wc == ' ' || wc == '\t'
+	  || wc == '\n' || wc == '\v' || wc == '\f' || wc == '\r');
+}
+
+static inline int
+iswupper (__wctype_wint_t wc)
+{
+  return wc >= 'A' && wc <= 'Z';
+}
+
+static inline int
+iswxdigit (__wctype_wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+	  || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'F'));
+}
+
+# endif /* ! HAVE_ISWCNTRL */
+
+#endif /* _GL_WCTYPE_H */
+#endif /* _GL_WCTYPE_H */
diff --git a/lib/xalloc-die.c b/lib/xalloc-die.c
new file mode 100644
index 0000000..0a0694f
--- /dev/null
+++ b/lib/xalloc-die.c
@@ -0,0 +1,41 @@
+/* Report a memory allocation failure and exit.
+
+   Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2006 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include "xalloc.h"
+
+#include <stdlib.h>
+
+#include "error.h"
+#include "exitfail.h"
+
+#include "gettext.h"
+#define _(msgid) gettext (msgid)
+
+void
+xalloc_die (void)
+{
+  error (exit_failure, 0, "%s", _("memory exhausted"));
+
+  /* The `noreturn' cannot be given to error, since it may return if
+     its first argument is 0.  To help compilers understand the
+     xalloc_die does not return, call abort.  Also, the abort is a
+     safety feature if exit_failure is 0 (which shouldn't happen).  */
+  abort ();
+}
diff --git a/lib/xalloc.h b/lib/xalloc.h
new file mode 100644
index 0000000..40dcf4b
--- /dev/null
+++ b/lib/xalloc.h
@@ -0,0 +1,270 @@
+/* xalloc.h -- malloc with out-of-memory checking
+
+   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2003, 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef XALLOC_H_
+# define XALLOC_H_
+
+# include <stddef.h>
+
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+
+# ifndef __attribute__
+#  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
+#   define __attribute__(x)
+#  endif
+# endif
+
+# ifndef ATTRIBUTE_NORETURN
+#  define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
+# endif
+
+/* This function is always triggered when memory is exhausted.
+   It must be defined by the application, either explicitly
+   or by using gnulib's xalloc-die module.  This is the
+   function to call when one wants the program to die because of a
+   memory allocation failure.  */
+extern void xalloc_die (void) ATTRIBUTE_NORETURN;
+
+void *xmalloc (size_t s);
+void *xzalloc (size_t s);
+void *xcalloc (size_t n, size_t s);
+void *xrealloc (void *p, size_t s);
+void *x2realloc (void *p, size_t *pn);
+void *xmemdup (void const *p, size_t s);
+char *xstrdup (char const *str);
+
+/* Return 1 if an array of N objects, each of size S, cannot exist due
+   to size arithmetic overflow.  S must be positive and N must be
+   nonnegative.  This is a macro, not an inline function, so that it
+   works correctly even when SIZE_MAX < N.
+
+   By gnulib convention, SIZE_MAX represents overflow in size
+   calculations, so the conservative dividend to use here is
+   SIZE_MAX - 1, since SIZE_MAX might represent an overflowed value.
+   However, malloc (SIZE_MAX) fails on all known hosts where
+   sizeof (ptrdiff_t) <= sizeof (size_t), so do not bother to test for
+   exactly-SIZE_MAX allocations on such hosts; this avoids a test and
+   branch when S is known to be 1.  */
+# define xalloc_oversized(n, s) \
+    ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n))
+
+
+/* In the following macros, T must be an elementary or structure/union or
+   typedef'ed type, or a pointer to such a type.  To apply one of the
+   following macros to a function pointer or array type, you need to typedef
+   it first and use the typedef name.  */
+
+/* Allocate an object of type T dynamically, with error checking.  */
+/* extern t *XMALLOC (typename t); */
+# define XMALLOC(t) ((t *) xmalloc (sizeof (t)))
+
+/* Allocate memory for N elements of type T, with error checking.  */
+/* extern t *XNMALLOC (size_t n, typename t); */
+# define XNMALLOC(n, t) \
+    ((t *) (sizeof (t) == 1 ? xmalloc (n) : xnmalloc (n, sizeof (t))))
+
+/* Allocate an object of type T dynamically, with error checking,
+   and zero it.  */
+/* extern t *XZALLOC (typename t); */
+# define XZALLOC(t) ((t *) xzalloc (sizeof (t)))
+
+/* Allocate memory for N elements of type T, with error checking,
+   and zero it.  */
+/* extern t *XCALLOC (size_t n, typename t); */
+# define XCALLOC(n, t) \
+    ((t *) (sizeof (t) == 1 ? xzalloc (n) : xcalloc (n, sizeof (t))))
+
+
+# if HAVE_INLINE
+#  define static_inline static inline
+# else
+   void *xnmalloc (size_t n, size_t s);
+   void *xnrealloc (void *p, size_t n, size_t s);
+   void *x2nrealloc (void *p, size_t *pn, size_t s);
+   char *xcharalloc (size_t n);
+# endif
+
+# ifdef static_inline
+
+/* Allocate an array of N objects, each with S bytes of memory,
+   dynamically, with error checking.  S must be nonzero.  */
+
+static_inline void *
+xnmalloc (size_t n, size_t s)
+{
+  if (xalloc_oversized (n, s))
+    xalloc_die ();
+  return xmalloc (n * s);
+}
+
+/* Change the size of an allocated block of memory P to an array of N
+   objects each of S bytes, with error checking.  S must be nonzero.  */
+
+static_inline void *
+xnrealloc (void *p, size_t n, size_t s)
+{
+  if (xalloc_oversized (n, s))
+    xalloc_die ();
+  return xrealloc (p, n * s);
+}
+
+/* If P is null, allocate a block of at least *PN such objects;
+   otherwise, reallocate P so that it contains more than *PN objects
+   each of S bytes.  *PN must be nonzero unless P is null, and S must
+   be nonzero.  Set *PN to the new number of objects, and return the
+   pointer to the new block.  *PN is never set to zero, and the
+   returned pointer is never null.
+
+   Repeated reallocations are guaranteed to make progress, either by
+   allocating an initial block with a nonzero size, or by allocating a
+   larger block.
+
+   In the following implementation, nonzero sizes are increased by a
+   factor of approximately 1.5 so that repeated reallocations have
+   O(N) overall cost rather than O(N**2) cost, but the
+   specification for this function does not guarantee that rate.
+
+   Here is an example of use:
+
+     int *p = NULL;
+     size_t used = 0;
+     size_t allocated = 0;
+
+     void
+     append_int (int value)
+       {
+	 if (used == allocated)
+	   p = x2nrealloc (p, &allocated, sizeof *p);
+	 p[used++] = value;
+       }
+
+   This causes x2nrealloc to allocate a block of some nonzero size the
+   first time it is called.
+
+   To have finer-grained control over the initial size, set *PN to a
+   nonzero value before calling this function with P == NULL.  For
+   example:
+
+     int *p = NULL;
+     size_t used = 0;
+     size_t allocated = 0;
+     size_t allocated1 = 1000;
+
+     void
+     append_int (int value)
+       {
+	 if (used == allocated)
+	   {
+	     p = x2nrealloc (p, &allocated1, sizeof *p);
+	     allocated = allocated1;
+	   }
+	 p[used++] = value;
+       }
+
+   */
+
+static_inline void *
+x2nrealloc (void *p, size_t *pn, size_t s)
+{
+  size_t n = *pn;
+
+  if (! p)
+    {
+      if (! n)
+	{
+	  /* The approximate size to use for initial small allocation
+	     requests, when the invoking code specifies an old size of
+	     zero.  64 bytes is the largest "small" request for the
+	     GNU C library malloc.  */
+	  enum { DEFAULT_MXFAST = 64 };
+
+	  n = DEFAULT_MXFAST / s;
+	  n += !n;
+	}
+    }
+  else
+    {
+      /* Set N = ceil (1.5 * N) so that progress is made if N == 1.
+	 Check for overflow, so that N * S stays in size_t range.
+	 The check is slightly conservative, but an exact check isn't
+	 worth the trouble.  */
+      if ((size_t) -1 / 3 * 2 / s <= n)
+	xalloc_die ();
+      n += (n + 1) / 2;
+    }
+
+  *pn = n;
+  return xrealloc (p, n * s);
+}
+
+/* Return a pointer to a new buffer of N bytes.  This is like xmalloc,
+   except it returns char *.  */
+
+static_inline char *
+xcharalloc (size_t n)
+{
+  return XNMALLOC (n, char);
+}
+
+# endif
+
+# ifdef __cplusplus
+}
+
+/* C++ does not allow conversions from void * to other pointer types
+   without a cast.  Use templates to work around the problem when
+   possible.  */
+
+template <typename T> inline T *
+xrealloc (T *p, size_t s)
+{
+  return (T *) xrealloc ((void *) p, s);
+}
+
+template <typename T> inline T *
+xnrealloc (T *p, size_t n, size_t s)
+{
+  return (T *) xnrealloc ((void *) p, n, s);
+}
+
+template <typename T> inline T *
+x2realloc (T *p, size_t *pn)
+{
+  return (T *) x2realloc ((void *) p, pn);
+}
+
+template <typename T> inline T *
+x2nrealloc (T *p, size_t *pn, size_t s)
+{
+  return (T *) x2nrealloc ((void *) p, pn, s);
+}
+
+template <typename T> inline T *
+xmemdup (T const *p, size_t s)
+{
+  return (T *) xmemdup ((void const *) p, s);
+}
+
+# endif
+
+
+#endif /* !XALLOC_H_ */
diff --git a/lib/xmalloc.c b/lib/xmalloc.c
new file mode 100644
index 0000000..3a12345
--- /dev/null
+++ b/lib/xmalloc.c
@@ -0,0 +1,122 @@
+/* xmalloc.c -- malloc with out of memory checking
+
+   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,
+   Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#if ! HAVE_INLINE
+# define static_inline
+#endif
+#include "xalloc.h"
+#undef static_inline
+
+#include <stdlib.h>
+#include <string.h>
+
+#ifndef SIZE_MAX
+# define SIZE_MAX ((size_t) -1)
+#endif
+
+/* 1 if calloc is known to be compatible with GNU calloc.  This
+   matters if we are not also using the calloc module, which defines
+   HAVE_CALLOC and supports the GNU API even on non-GNU platforms.  */
+#if defined HAVE_CALLOC || defined __GLIBC__
+enum { HAVE_GNU_CALLOC = 1 };
+#else
+enum { HAVE_GNU_CALLOC = 0 };
+#endif
+
+/* Allocate N bytes of memory dynamically, with error checking.  */
+
+void *
+xmalloc (size_t n)
+{
+  void *p = malloc (n);
+  if (!p && n != 0)
+    xalloc_die ();
+  return p;
+}
+
+/* Change the size of an allocated block of memory P to N bytes,
+   with error checking.  */
+
+void *
+xrealloc (void *p, size_t n)
+{
+  p = realloc (p, n);
+  if (!p && n != 0)
+    xalloc_die ();
+  return p;
+}
+
+/* If P is null, allocate a block of at least *PN bytes; otherwise,
+   reallocate P so that it contains more than *PN bytes.  *PN must be
+   nonzero unless P is null.  Set *PN to the new block's size, and
+   return the pointer to the new block.  *PN is never set to zero, and
+   the returned pointer is never null.  */
+
+void *
+x2realloc (void *p, size_t *pn)
+{
+  return x2nrealloc (p, pn, 1);
+}
+
+/* Allocate S bytes of zeroed memory dynamically, with error checking.
+   There's no need for xnzalloc (N, S), since it would be equivalent
+   to xcalloc (N, S).  */
+
+void *
+xzalloc (size_t s)
+{
+  return memset (xmalloc (s), 0, s);
+}
+
+/* Allocate zeroed memory for N elements of S bytes, with error
+   checking.  S must be nonzero.  */
+
+void *
+xcalloc (size_t n, size_t s)
+{
+  void *p;
+  /* Test for overflow, since some calloc implementations don't have
+     proper overflow checks.  But omit overflow and size-zero tests if
+     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never
+     returns NULL if successful.  */
+  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))
+      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
+    xalloc_die ();
+  return p;
+}
+
+/* Clone an object P of size S, with error checking.  There's no need
+   for xnmemdup (P, N, S), since xmemdup (P, N * S) works without any
+   need for an arithmetic overflow check.  */
+
+void *
+xmemdup (void const *p, size_t s)
+{
+  return memcpy (xmalloc (s), p, s);
+}
+
+/* Clone STRING.  */
+
+char *
+xstrdup (char const *string)
+{
+  return xmemdup (string, strlen (string) + 1);
+}
diff --git a/m4/error.m4 b/m4/error.m4
new file mode 100644
index 0000000..7c7746e
--- /dev/null
+++ b/m4/error.m4
@@ -0,0 +1,22 @@
+#serial 11
+
+# Copyright (C) 1996, 1997, 1998, 2001, 2002, 2003, 2004 Free Software
+# Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_ERROR],
+[
+  AC_FUNC_ERROR_AT_LINE
+  dnl Note: AC_FUNC_ERROR_AT_LINE does AC_LIBSOURCES([error.h, error.c]).
+  gl_PREREQ_ERROR
+])
+
+# Prerequisites of lib/error.c.
+AC_DEFUN([gl_PREREQ_ERROR],
+[
+  AC_REQUIRE([AC_FUNC_STRERROR_R])
+  :
+])
diff --git a/m4/exitfail.m4 b/m4/exitfail.m4
new file mode 100644
index 0000000..b7a691e
--- /dev/null
+++ b/m4/exitfail.m4
@@ -0,0 +1,13 @@
+# exitfail.m4 serial 6
+dnl Copyright (C) 2002, 2003, 2005, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_EXITFAIL],
+[
+  AC_LIBOBJ([exitfail])
+
+  dnl No prerequisites of lib/exitfail.c.
+  :
+])
diff --git a/m4/extensions.m4 b/m4/extensions.m4
new file mode 100644
index 0000000..bcbb3ce
--- /dev/null
+++ b/m4/extensions.m4
@@ -0,0 +1,82 @@
+# serial 5  -*- Autoconf -*-
+# Enable extensions on systems that normally disable them.
+
+# Copyright (C) 2003, 2006, 2007 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This definition of AC_USE_SYSTEM_EXTENSIONS is stolen from CVS
+# Autoconf.  Perhaps we can remove this once we can assume Autoconf
+# 2.62 or later everywhere, but since CVS Autoconf mutates rapidly
+# enough in this area it's likely we'll need to redefine
+# AC_USE_SYSTEM_EXTENSIONS for quite some time.
+
+# AC_USE_SYSTEM_EXTENSIONS
+# ------------------------
+# Enable extensions on systems that normally disable them,
+# typically due to standards-conformance issues.
+# Remember that #undef in AH_VERBATIM gets replaced with #define by
+# AC_DEFINE.  The goal here is to define all known feature-enabling
+# macros, then, if reports of conflicts are made, disable macros that
+# cause problems on some platforms (such as __EXTENSIONS__).
+AC_DEFUN([AC_USE_SYSTEM_EXTENSIONS],
+[AC_BEFORE([$0], [AC_COMPILE_IFELSE])dnl
+AC_BEFORE([$0], [AC_RUN_IFELSE])dnl
+
+  AC_CHECK_HEADER([minix/config.h], [MINIX=yes], [MINIX=])
+  if test "$MINIX" = yes; then
+    AC_DEFINE([_POSIX_SOURCE], [1],
+      [Define to 1 if you need to in order for `stat' and other
+       things to work.])
+    AC_DEFINE([_POSIX_1_SOURCE], [2],
+      [Define to 2 if the system does not provide POSIX.1 features
+       except with this defined.])
+    AC_DEFINE([_MINIX], [1],
+      [Define to 1 if on MINIX.])
+  fi
+
+  AH_VERBATIM([__EXTENSIONS__],
+[/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+])
+  AC_CACHE_CHECK([whether it is safe to define __EXTENSIONS__],
+    [ac_cv_safe_to_define___extensions__],
+    [AC_COMPILE_IFELSE(
+       [AC_LANG_PROGRAM([
+#	  define __EXTENSIONS__ 1
+	  AC_INCLUDES_DEFAULT])],
+       [ac_cv_safe_to_define___extensions__=yes],
+       [ac_cv_safe_to_define___extensions__=no])])
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    AC_DEFINE([__EXTENSIONS__])
+  AC_DEFINE([_ALL_SOURCE])
+  AC_DEFINE([_GNU_SOURCE])
+  AC_DEFINE([_POSIX_PTHREAD_SEMANTICS])
+  AC_DEFINE([_TANDEM_SOURCE])
+])# AC_USE_SYSTEM_EXTENSIONS
+
+# gl_USE_SYSTEM_EXTENSIONS
+# ------------------------
+# Enable extensions on systems that normally disable them,
+# typically due to standards-conformance issues.
+AC_DEFUN([gl_USE_SYSTEM_EXTENSIONS],
+  [AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])])
diff --git a/m4/gnulib-cache.m4 b/m4/gnulib-cache.m4
index 489a3c9..7e17421 100644
--- a/m4/gnulib-cache.m4
+++ b/m4/gnulib-cache.m4
@@ -1,4 +1,4 @@
-# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -15,11 +15,11 @@
 
 
 # Specification in the form of a command-line invocation:
-#   gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl c-ctype getopt maintainer-makefile
+#   gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl c-ctype getopt maintainer-makefile quote
 
 # Specification in the form of a few gnulib-tool.m4 macro invocations:
 gl_LOCAL_DIR([])
-gl_MODULES([c-ctype getopt maintainer-makefile])
+gl_MODULES([c-ctype getopt maintainer-makefile quote])
 gl_AVOID([])
 gl_SOURCE_BASE([lib])
 gl_M4_BASE([m4])
diff --git a/m4/gnulib-comp.m4 b/m4/gnulib-comp.m4
index 5d074c9..47ce7dc 100644
--- a/m4/gnulib-comp.m4
+++ b/m4/gnulib-comp.m4
@@ -1,5 +1,5 @@
 # DO NOT EDIT! GENERATED AUTOMATICALLY!
-# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -25,29 +25,51 @@ AC_DEFUN([gl_EARLY],
   m4_pattern_allow([^gl_LIBOBJS$])dnl a variable
   m4_pattern_allow([^gl_LTLIBOBJS$])dnl a variable
   AC_REQUIRE([AC_PROG_RANLIB])
+  AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
 ])
 
 # This macro should be invoked from ./configure.ac, in the section
 # "Check for header files, types and library functions".
 AC_DEFUN([gl_INIT],
 [
-  m4_pushdef([AC_LIBOBJ], m4_defn([gl_LIBOBJ]))
-  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gl_REPLACE_FUNCS]))
-  m4_pushdef([AC_LIBSOURCES], m4_defn([gl_LIBSOURCES]))
   AM_CONDITIONAL([GL_COND_LIBTOOL], [false])
   gl_cond_libtool=false
   gl_libdeps=
   gl_ltlibdeps=
+  m4_pushdef([AC_LIBOBJ], m4_defn([gl_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gl_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([gl_LIBSOURCES]))
   gl_source_base='lib'
+  gl_ERROR
+  m4_ifdef([AM_XGETTEXT_OPTION],
+    [AM_XGETTEXT_OPTION([--flag=error:3:c-format])
+     AM_XGETTEXT_OPTION([--flag=error_at_line:5:c-format])])
+  gl_EXITFAIL
   gl_GETOPT
   AC_SUBST([LIBINTL])
   AC_SUBST([LTLIBINTL])
+  # Autoconf 2.61a.99 and earlier don't support linking a file only
+  # in VPATH builds.  But since GNUmakefile is for maintainer use
+  # only, it does not matter if we skip the link with older autoconf.
+  # Automake 1.10.1 and earlier try to remove GNUmakefile in non-VPATH
+  # builds, so use a shell variable to bypass this.
+  GNUmakefile=GNUmakefile
+  m4_if(m4_version_compare([2.61a.100],
+  	m4_defn([m4_PACKAGE_VERSION])), [1], [],
+        [AC_CONFIG_LINKS([$GNUmakefile:$GNUmakefile], [],
+  	[GNUmakefile=$GNUmakefile])])
+  gl_INLINE
+  gl_QUOTE
+  gl_QUOTEARG
   AM_STDBOOL_H
+  gl_STDLIB_H
+  gl_FUNC_STRERROR
+  gl_STRING_MODULE_INDICATOR([strerror])
+  gl_HEADER_STRING_H
   gl_UNISTD_H
-  LIBGNU_LIBDEPS="$gl_libdeps"
-  AC_SUBST([LIBGNU_LIBDEPS])
-  LIBGNU_LTLIBDEPS="$gl_ltlibdeps"
-  AC_SUBST([LIBGNU_LTLIBDEPS])
+  gl_WCHAR_H
+  gl_WCTYPE_H
+  gl_XALLOC
   m4_popdef([AC_LIBSOURCES])
   m4_popdef([AC_REPLACE_FUNCS])
   m4_popdef([AC_LIBOBJ])
@@ -65,6 +87,33 @@ AC_DEFUN([gl_INIT],
     AC_SUBST([gl_LIBOBJS], [$gl_libobjs])
     AC_SUBST([gl_LTLIBOBJS], [$gl_ltlibobjs])
   ])
+  gltests_libdeps=
+  gltests_ltlibdeps=
+  m4_pushdef([AC_LIBOBJ], m4_defn([gltests_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gltests_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([gltests_LIBSOURCES]))
+  gl_source_base='tests'
+  m4_popdef([AC_LIBSOURCES])
+  m4_popdef([AC_REPLACE_FUNCS])
+  m4_popdef([AC_LIBOBJ])
+  AC_CONFIG_COMMANDS_PRE([
+    gltests_libobjs=
+    gltests_ltlibobjs=
+    if test -n "$gltests_LIBOBJS"; then
+      # Remove the extension.
+      sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $gltests_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+        gltests_libobjs="$gltests_libobjs $i.$ac_objext"
+        gltests_ltlibobjs="$gltests_ltlibobjs $i.lo"
+      done
+    fi
+    AC_SUBST([gltests_LIBOBJS], [$gltests_libobjs])
+    AC_SUBST([gltests_LTLIBOBJS], [$gltests_ltlibobjs])
+  ])
+  LIBGNU_LIBDEPS="$gl_libdeps"
+  AC_SUBST([LIBGNU_LIBDEPS])
+  LIBGNU_LTLIBDEPS="$gl_ltlibdeps"
+  AC_SUBST([LIBGNU_LTLIBDEPS])
 ])
 
 # Like AC_LIBOBJ, except that the module name goes
@@ -74,6 +123,13 @@ AC_DEFUN([gl_LIBOBJ], [
   gl_LIBOBJS="$gl_LIBOBJS $1.$ac_objext"
 ])
 
+# m4_foreach_w is provided by autoconf-2.59c and later.
+# This definition is to accommodate developers using versions
+# of autoconf older than that.
+m4_ifndef([m4_foreach_w],
+  [m4_define([m4_foreach_w],
+    [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
+
 # Like AC_REPLACE_FUNCS, except that the module name goes
 # into gl_LIBOBJS instead of into LIBOBJS.
 AC_DEFUN([gl_REPLACE_FUNCS], [
@@ -95,24 +151,91 @@ AC_DEFUN([gl_LIBSOURCES], [
   ])
 ])
 
+# Like AC_LIBOBJ, except that the module name goes
+# into gltests_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gltests_LIBOBJ], [
+  AS_LITERAL_IF([$1], [gltests_LIBSOURCES([$1.c])])dnl
+  gltests_LIBOBJS="$gltests_LIBOBJS $1.$ac_objext"
+])
+
+# m4_foreach_w is provided by autoconf-2.59c and later.
+# This definition is to accommodate developers using versions
+# of autoconf older than that.
+m4_ifndef([m4_foreach_w],
+  [m4_define([m4_foreach_w],
+    [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
+
+# Like AC_REPLACE_FUNCS, except that the module name goes
+# into gltests_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gltests_REPLACE_FUNCS], [
+  m4_foreach_w([gl_NAME], [$1], [AC_LIBSOURCES(gl_NAME[.c])])dnl
+  AC_CHECK_FUNCS([$1], , [gltests_LIBOBJ($ac_func)])
+])
+
+# Like AC_LIBSOURCES, except the directory where the source file is
+# expected is derived from the gnulib-tool parametrization,
+# and alloca is special cased (for the alloca-opt module).
+# We could also entirely rely on EXTRA_lib..._SOURCES.
+AC_DEFUN([gltests_LIBSOURCES], [
+  m4_foreach([_gl_NAME], [$1], [
+    m4_if(_gl_NAME, [alloca.c], [], [
+      m4_syscmd([test -r tests/]_gl_NAME[ || test ! -d tests])dnl
+      m4_if(m4_sysval, [0], [],
+        [AC_FATAL([missing tests/]_gl_NAME)])
+    ])
+  ])
+])
+
 # This macro records the list of files which have been installed by
 # gnulib-tool and may be removed by future gnulib-tool invocations.
 AC_DEFUN([gl_FILE_LIST], [
-  build-aux/GNUmakefile
   build-aux/link-warning.h
-  build-aux/maint.mk
   lib/c-ctype.c
   lib/c-ctype.h
+  lib/error.c
+  lib/error.h
+  lib/exitfail.c
+  lib/exitfail.h
   lib/getopt.c
   lib/getopt.in.h
   lib/getopt1.c
   lib/getopt_int.h
   lib/gettext.h
+  lib/intprops.h
+  lib/quote.c
+  lib/quote.h
+  lib/quotearg.c
+  lib/quotearg.h
   lib/stdbool.in.h
+  lib/stdlib.in.h
+  lib/strerror.c
+  lib/string.in.h
   lib/unistd.in.h
+  lib/wchar.in.h
+  lib/wctype.in.h
+  lib/xalloc-die.c
+  lib/xalloc.h
+  lib/xmalloc.c
+  m4/error.m4
+  m4/exitfail.m4
+  m4/extensions.m4
   m4/getopt.m4
   m4/gnulib-common.m4
   m4/include_next.m4
+  m4/inline.m4
+  m4/mbrtowc.m4
+  m4/mbstate_t.m4
+  m4/quote.m4
+  m4/quotearg.m4
   m4/stdbool.m4
+  m4/stdlib_h.m4
+  m4/strerror.m4
+  m4/string_h.m4
   m4/unistd_h.m4
+  m4/wchar.m4
+  m4/wctype.m4
+  m4/wint_t.m4
+  m4/xalloc.m4
+  top/GNUmakefile
+  top/maint.mk
 ])
diff --git a/m4/include_next.m4 b/m4/include_next.m4
index 7ce472b..a842e2a 100644
--- a/m4/include_next.m4
+++ b/m4/include_next.m4
@@ -1,5 +1,5 @@
-# include_next.m4 serial 4
-dnl Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+# include_next.m4 serial 6
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -63,12 +63,15 @@ EOF
 # The three "///" are to pacify Sun C 5.8, which otherwise would say
 # "warning: #include of /usr/include/... may be non-portable".
 # Use `""', not `<>', so that the /// cannot be confused with a C99 comment.
+# Note: This macro assumes that the header file is not empty after
+# preprocessing, i.e. it does not only define preprocessor macros but also
+# provides some type/enum definitions or function/variable declarations.
 AC_DEFUN([gl_CHECK_NEXT_HEADERS],
 [
   AC_REQUIRE([gl_INCLUDE_NEXT])
   AC_CHECK_HEADERS_ONCE([$1])
 
-  AC_FOREACH([gl_HEADER_NAME], [$1],
+  m4_foreach_w([gl_HEADER_NAME], [$1],
     [AS_VAR_PUSHDEF([gl_next_header],
 		    [gl_cv_next_]m4_quote(m4_defn([gl_HEADER_NAME])))
      if test $gl_cv_have_include_next = yes; then
diff --git a/m4/inline.m4 b/m4/inline.m4
new file mode 100644
index 0000000..a07076c
--- /dev/null
+++ b/m4/inline.m4
@@ -0,0 +1,40 @@
+# inline.m4 serial 3
+dnl Copyright (C) 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Test for the 'inline' keyword or equivalent.
+dnl Define 'inline' to a supported equivalent, or to nothing if not supported,
+dnl like AC_C_INLINE does.  Also, define HAVE_INLINE if 'inline' or an
+dnl equivalent is effectively supported, i.e. if the compiler is likely to
+dnl drop unused 'static inline' functions.
+AC_DEFUN([gl_INLINE],
+[
+  AC_REQUIRE([AC_C_INLINE])
+  AC_CACHE_CHECK([whether the compiler generally respects inline],
+    [gl_cv_c_inline_effective],
+    [if test $ac_cv_c_inline = no; then
+       gl_cv_c_inline_effective=no
+     else
+       dnl GCC defines __NO_INLINE__ if not optimizing or if -fno-inline is
+       dnl specified.
+       dnl Use AC_COMPILE_IFELSE here, not AC_EGREP_CPP, because the result
+       dnl depends on optimization flags, which can be in CFLAGS.
+       dnl (AC_EGREP_CPP looks only at the CPPFLAGS.)
+       AC_COMPILE_IFELSE(
+         [AC_LANG_PROGRAM([[]],
+           [[#ifdef __NO_INLINE__
+               #error "inline is not effective"
+             #endif]])],
+         [gl_cv_c_inline_effective=yes],
+         [gl_cv_c_inline_effective=no])
+     fi
+    ])
+  if test $gl_cv_c_inline_effective = yes; then
+    AC_DEFINE([HAVE_INLINE], 1,
+      [Define to 1 if the compiler supports one of the keywords
+       'inline', '__inline__', '__inline' and effectively inlines
+       functions marked as such.])
+  fi
+])
diff --git a/m4/mbrtowc.m4 b/m4/mbrtowc.m4
new file mode 100644
index 0000000..a3bd911
--- /dev/null
+++ b/m4/mbrtowc.m4
@@ -0,0 +1,31 @@
+# mbrtowc.m4 serial 8
+dnl Copyright (C) 2001-2002, 2004-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert
+
+dnl This file can be removed, and gl_FUNC_MBRTOWC replaced with
+dnl AC_FUNC_MBRTOWC, when autoconf 2.60 can be assumed everywhere.
+
+AC_DEFUN([gl_FUNC_MBRTOWC],
+[
+  dnl Same as AC_FUNC_MBRTOWC in autoconf-2.60.
+  AC_CACHE_CHECK([whether mbrtowc and mbstate_t are properly declared],
+    gl_cv_func_mbrtowc,
+    [AC_LINK_IFELSE(
+       [AC_LANG_PROGRAM(
+            [[#include <wchar.h>]],
+            [[wchar_t wc;
+              char const s[] = "";
+              size_t n = 1;
+              mbstate_t state;
+              return ! (sizeof state && (mbrtowc) (&wc, s, n, &state));]])],
+       gl_cv_func_mbrtowc=yes,
+       gl_cv_func_mbrtowc=no)])
+  if test $gl_cv_func_mbrtowc = yes; then
+    AC_DEFINE([HAVE_MBRTOWC], 1,
+      [Define to 1 if mbrtowc and mbstate_t are properly declared.])
+  fi
+])
diff --git a/m4/mbstate_t.m4 b/m4/mbstate_t.m4
new file mode 100644
index 0000000..df2a275
--- /dev/null
+++ b/m4/mbstate_t.m4
@@ -0,0 +1,30 @@
+# mbstate_t.m4 serial 9
+dnl Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# From Paul Eggert.
+
+# BeOS 5 has <wchar.h> but does not define mbstate_t,
+# so you can't declare an object of that type.
+# Check for this incompatibility with Standard C.
+
+# AC_TYPE_MBSTATE_T
+# -----------------
+AC_DEFUN([AC_TYPE_MBSTATE_T],
+  [AC_CACHE_CHECK([for mbstate_t], ac_cv_type_mbstate_t,
+     [AC_COMPILE_IFELSE(
+	[AC_LANG_PROGRAM(
+	   [AC_INCLUDES_DEFAULT
+#	    include <wchar.h>],
+	   [mbstate_t x; return sizeof x;])],
+	[ac_cv_type_mbstate_t=yes],
+	[ac_cv_type_mbstate_t=no])])
+   if test $ac_cv_type_mbstate_t = yes; then
+     AC_DEFINE([HAVE_MBSTATE_T], 1,
+	       [Define to 1 if <wchar.h> declares mbstate_t.])
+   else
+     AC_DEFINE([mbstate_t], int,
+	       [Define to a type if <wchar.h> does not define.])
+   fi])
diff --git a/m4/quote.m4 b/m4/quote.m4
new file mode 100644
index 0000000..0f08791
--- /dev/null
+++ b/m4/quote.m4
@@ -0,0 +1,13 @@
+# quote.m4 serial 5
+dnl Copyright (C) 2002, 2003, 2005, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_QUOTE],
+[
+  AC_LIBOBJ([quote])
+
+  dnl Prerequisites of lib/quote.c.
+  dnl (none)
+])
diff --git a/m4/quotearg.m4 b/m4/quotearg.m4
new file mode 100644
index 0000000..db635d0
--- /dev/null
+++ b/m4/quotearg.m4
@@ -0,0 +1,15 @@
+# quotearg.m4 serial 6
+dnl Copyright (C) 2002, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_QUOTEARG],
+[
+  AC_LIBOBJ([quotearg])
+
+  dnl Prerequisites of lib/quotearg.c.
+  AC_CHECK_FUNCS_ONCE([mbsinit])
+  AC_TYPE_MBSTATE_T
+  gl_FUNC_MBRTOWC
+])
diff --git a/m4/stdlib_h.m4 b/m4/stdlib_h.m4
new file mode 100644
index 0000000..d9240b4
--- /dev/null
+++ b/m4/stdlib_h.m4
@@ -0,0 +1,45 @@
+# stdlib_h.m4 serial 6
+dnl Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_STDLIB_H],
+[
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([stdlib.h])
+])
+
+AC_DEFUN([gl_STDLIB_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_STDLIB_H_DEFAULTS],
+[
+  GNULIB_MALLOC_POSIX=0;  AC_SUBST([GNULIB_MALLOC_POSIX])
+  GNULIB_REALLOC_POSIX=0; AC_SUBST([GNULIB_REALLOC_POSIX])
+  GNULIB_CALLOC_POSIX=0;  AC_SUBST([GNULIB_CALLOC_POSIX])
+  GNULIB_GETSUBOPT=0;     AC_SUBST([GNULIB_GETSUBOPT])
+  GNULIB_MKDTEMP=0;       AC_SUBST([GNULIB_MKDTEMP])
+  GNULIB_MKSTEMP=0;       AC_SUBST([GNULIB_MKSTEMP])
+  GNULIB_PUTENV=0;        AC_SUBST([GNULIB_PUTENV])
+  GNULIB_SETENV=0;        AC_SUBST([GNULIB_SETENV])
+  GNULIB_STRTOD=0;        AC_SUBST([GNULIB_STRTOD])
+  GNULIB_UNSETENV=0;      AC_SUBST([GNULIB_UNSETENV])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_CALLOC_POSIX=1;    AC_SUBST([HAVE_CALLOC_POSIX])
+  HAVE_GETSUBOPT=1;       AC_SUBST([HAVE_GETSUBOPT])
+  HAVE_MALLOC_POSIX=1;    AC_SUBST([HAVE_MALLOC_POSIX])
+  HAVE_MKDTEMP=1;         AC_SUBST([HAVE_MKDTEMP])
+  HAVE_REALLOC_POSIX=1;   AC_SUBST([HAVE_REALLOC_POSIX])
+  HAVE_SETENV=1;          AC_SUBST([HAVE_SETENV])
+  HAVE_STRTOD=1;          AC_SUBST([HAVE_STRTOD])
+  HAVE_UNSETENV=1;        AC_SUBST([HAVE_UNSETENV])
+  REPLACE_MKSTEMP=0;      AC_SUBST([REPLACE_MKSTEMP])
+  REPLACE_PUTENV=0;       AC_SUBST([REPLACE_PUTENV])
+  REPLACE_STRTOD=0;       AC_SUBST([REPLACE_STRTOD])
+  VOID_UNSETENV=0;        AC_SUBST([VOID_UNSETENV])
+])
diff --git a/m4/strerror.m4 b/m4/strerror.m4
new file mode 100644
index 0000000..eb7d45a
--- /dev/null
+++ b/m4/strerror.m4
@@ -0,0 +1,47 @@
+# strerror.m4 serial 7
+dnl Copyright (C) 2002, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_STRERROR],
+[
+  AC_REQUIRE([gl_FUNC_STRERROR_SEPARATE])
+  if test $gl_cv_func_working_strerror = no; then
+    AC_LIBOBJ([strerror])
+    AC_DEFINE_UNQUOTED([REPLACE_STRERROR], [$REPLACE_STRERROR],
+      [Define this to 1 if strerror is broken.])
+  fi
+])
+
+# Like gl_FUNC_STRERROR, except prepare for separate compilation (no AC_LIBOBJ).
+AC_DEFUN([gl_FUNC_STRERROR_SEPARATE],
+[
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  AC_CACHE_CHECK([for working strerror function],
+   [gl_cv_func_working_strerror],
+   [AC_RUN_IFELSE(
+      [AC_LANG_PROGRAM(
+	 [#include <string.h>
+	 ],
+	 [return !*strerror (-2);])],
+      [gl_cv_func_working_strerror=yes],
+      [gl_cv_func_working_strerror=no],
+      [dnl Assume crossbuild works if it compiles.
+       AC_COMPILE_IFELSE(
+	 [AC_LANG_PROGRAM(
+	    [#include <string.h>
+	    ],
+	    [return !*strerror (-2);])],
+	 [gl_cv_func_working_strerror=yes],
+	 [gl_cv_func_working_strerror=no])])])
+  if test $gl_cv_func_working_strerror = no ; then
+    REPLACE_STRERROR=1
+    gl_PREREQ_STRERROR
+  fi
+])
+
+# Prerequisites of lib/strerror.c.
+AC_DEFUN([gl_PREREQ_STRERROR], [
+  AC_CHECK_DECLS([strerror])
+])
diff --git a/m4/string_h.m4 b/m4/string_h.m4
new file mode 100644
index 0000000..766d7e9
--- /dev/null
+++ b/m4/string_h.m4
@@ -0,0 +1,87 @@
+# Configure a GNU-like replacement for <string.h>.
+
+# Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# Written by Paul Eggert.
+
+AC_DEFUN([gl_HEADER_STRING_H],
+[
+  dnl Use AC_REQUIRE here, so that the default behavior below is expanded
+  dnl once only, before all statements that occur in other macros.
+  AC_REQUIRE([gl_HEADER_STRING_H_BODY])
+])
+
+AC_DEFUN([gl_HEADER_STRING_H_BODY],
+[
+  AC_REQUIRE([AC_C_RESTRICT])
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([string.h])
+])
+
+AC_DEFUN([gl_STRING_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_HEADER_STRING_H_DEFAULTS],
+[
+  GNULIB_MEMMEM=0;      AC_SUBST([GNULIB_MEMMEM])
+  GNULIB_MEMPCPY=0;     AC_SUBST([GNULIB_MEMPCPY])
+  GNULIB_MEMRCHR=0;     AC_SUBST([GNULIB_MEMRCHR])
+  GNULIB_STPCPY=0;      AC_SUBST([GNULIB_STPCPY])
+  GNULIB_STPNCPY=0;     AC_SUBST([GNULIB_STPNCPY])
+  GNULIB_STRCHRNUL=0;   AC_SUBST([GNULIB_STRCHRNUL])
+  GNULIB_STRDUP=0;      AC_SUBST([GNULIB_STRDUP])
+  GNULIB_STRNDUP=0;     AC_SUBST([GNULIB_STRNDUP])
+  GNULIB_STRNLEN=0;     AC_SUBST([GNULIB_STRNLEN])
+  GNULIB_STRPBRK=0;     AC_SUBST([GNULIB_STRPBRK])
+  GNULIB_STRSEP=0;      AC_SUBST([GNULIB_STRSEP])
+  GNULIB_STRSTR=0;      AC_SUBST([GNULIB_STRSTR])
+  GNULIB_STRCASESTR=0;  AC_SUBST([GNULIB_STRCASESTR])
+  GNULIB_STRTOK_R=0;    AC_SUBST([GNULIB_STRTOK_R])
+  GNULIB_MBSLEN=0;      AC_SUBST([GNULIB_MBSLEN])
+  GNULIB_MBSNLEN=0;     AC_SUBST([GNULIB_MBSNLEN])
+  GNULIB_MBSCHR=0;      AC_SUBST([GNULIB_MBSCHR])
+  GNULIB_MBSRCHR=0;     AC_SUBST([GNULIB_MBSRCHR])
+  GNULIB_MBSSTR=0;      AC_SUBST([GNULIB_MBSSTR])
+  GNULIB_MBSCASECMP=0;  AC_SUBST([GNULIB_MBSCASECMP])
+  GNULIB_MBSNCASECMP=0; AC_SUBST([GNULIB_MBSNCASECMP])
+  GNULIB_MBSPCASECMP=0; AC_SUBST([GNULIB_MBSPCASECMP])
+  GNULIB_MBSCASESTR=0;  AC_SUBST([GNULIB_MBSCASESTR])
+  GNULIB_MBSCSPN=0;     AC_SUBST([GNULIB_MBSCSPN])
+  GNULIB_MBSPBRK=0;     AC_SUBST([GNULIB_MBSPBRK])
+  GNULIB_MBSSPN=0;      AC_SUBST([GNULIB_MBSSPN])
+  GNULIB_MBSSEP=0;      AC_SUBST([GNULIB_MBSSEP])
+  GNULIB_MBSTOK_R=0;    AC_SUBST([GNULIB_MBSTOK_R])
+  GNULIB_STRERROR=0;    AC_SUBST([GNULIB_STRERROR])
+  GNULIB_STRSIGNAL=0;   AC_SUBST([GNULIB_STRSIGNAL])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DECL_MEMMEM=1;		AC_SUBST([HAVE_DECL_MEMMEM])
+  HAVE_MEMPCPY=1;		AC_SUBST([HAVE_MEMPCPY])
+  HAVE_DECL_MEMRCHR=1;		AC_SUBST([HAVE_DECL_MEMRCHR])
+  HAVE_STPCPY=1;		AC_SUBST([HAVE_STPCPY])
+  HAVE_STPNCPY=1;		AC_SUBST([HAVE_STPNCPY])
+  HAVE_STRCHRNUL=1;		AC_SUBST([HAVE_STRCHRNUL])
+  HAVE_DECL_STRDUP=1;		AC_SUBST([HAVE_DECL_STRDUP])
+  HAVE_STRNDUP=1;		AC_SUBST([HAVE_STRNDUP])
+  HAVE_DECL_STRNDUP=1;		AC_SUBST([HAVE_DECL_STRNDUP])
+  HAVE_DECL_STRNLEN=1;		AC_SUBST([HAVE_DECL_STRNLEN])
+  HAVE_STRPBRK=1;		AC_SUBST([HAVE_STRPBRK])
+  HAVE_STRSEP=1;		AC_SUBST([HAVE_STRSEP])
+  HAVE_STRCASESTR=1;		AC_SUBST([HAVE_STRCASESTR])
+  HAVE_DECL_STRTOK_R=1;		AC_SUBST([HAVE_DECL_STRTOK_R])
+  HAVE_DECL_STRERROR=1;		AC_SUBST([HAVE_DECL_STRERROR])
+  HAVE_DECL_STRSIGNAL=1;	AC_SUBST([HAVE_DECL_STRSIGNAL])
+  REPLACE_STRERROR=0;		AC_SUBST([REPLACE_STRERROR])
+  REPLACE_STRSIGNAL=0;		AC_SUBST([REPLACE_STRSIGNAL])
+  REPLACE_MEMMEM=0;		AC_SUBST([REPLACE_MEMMEM])
+  REPLACE_STRCASESTR=0;		AC_SUBST([REPLACE_STRCASESTR])
+  REPLACE_STRSTR=0;		AC_SUBST([REPLACE_STRSTR])
+])
diff --git a/m4/unistd_h.m4 b/m4/unistd_h.m4
index 91c02e7..e8ccab1 100644
--- a/m4/unistd_h.m4
+++ b/m4/unistd_h.m4
@@ -1,5 +1,5 @@
-# unistd_h.m4 serial 10
-dnl Copyright (C) 2006-2007 Free Software Foundation, Inc.
+# unistd_h.m4 serial 11
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -34,6 +34,7 @@ AC_DEFUN([gl_UNISTD_H_DEFAULTS],
 [
   GNULIB_CHOWN=0;         AC_SUBST([GNULIB_CHOWN])
   GNULIB_DUP2=0;          AC_SUBST([GNULIB_DUP2])
+  GNULIB_ENVIRON=0;       AC_SUBST([GNULIB_ENVIRON])
   GNULIB_FCHDIR=0;        AC_SUBST([GNULIB_FCHDIR])
   GNULIB_FTRUNCATE=0;     AC_SUBST([GNULIB_FTRUNCATE])
   GNULIB_GETCWD=0;        AC_SUBST([GNULIB_GETCWD])
@@ -49,12 +50,14 @@ AC_DEFUN([gl_UNISTD_H_DEFAULTS],
   HAVE_GETPAGESIZE=1;     AC_SUBST([HAVE_GETPAGESIZE])
   HAVE_READLINK=1;        AC_SUBST([HAVE_READLINK])
   HAVE_SLEEP=1;           AC_SUBST([HAVE_SLEEP])
+  HAVE_DECL_ENVIRON=1;    AC_SUBST([HAVE_DECL_ENVIRON])
   HAVE_DECL_GETLOGIN_R=1; AC_SUBST([HAVE_DECL_GETLOGIN_R])
   HAVE_OS_H=0;            AC_SUBST([HAVE_OS_H])
   HAVE_SYS_PARAM_H=0;     AC_SUBST([HAVE_SYS_PARAM_H])
   REPLACE_CHOWN=0;        AC_SUBST([REPLACE_CHOWN])
   REPLACE_FCHDIR=0;       AC_SUBST([REPLACE_FCHDIR])
   REPLACE_GETCWD=0;       AC_SUBST([REPLACE_GETCWD])
+  REPLACE_GETPAGESIZE=0;  AC_SUBST([REPLACE_GETPAGESIZE])
   REPLACE_LCHOWN=0;       AC_SUBST([REPLACE_LCHOWN])
   REPLACE_LSEEK=0;        AC_SUBST([REPLACE_LSEEK])
 ])
diff --git a/m4/wchar.m4 b/m4/wchar.m4
new file mode 100644
index 0000000..70b1248
--- /dev/null
+++ b/m4/wchar.m4
@@ -0,0 +1,54 @@
+dnl A placeholder for ISO C99 <wchar.h>, for platforms that have issues.
+
+dnl Copyright (C) 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Eric Blake.
+
+# wchar.m4 serial 4
+
+AC_DEFUN([gl_WCHAR_H],
+[
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  AC_CACHE_CHECK([whether <wchar.h> is standalone],
+    [gl_cv_header_wchar_h_standalone],
+    [AC_COMPILE_IFELSE([[#include <wchar.h>
+wchar_t w;]],
+      [gl_cv_header_wchar_h_standalone=yes],
+      [gl_cv_header_wchar_h_standalone=no])])
+  if test $gl_cv_header_wchar_h_standalone != yes; then
+    WCHAR_H=wchar.h
+  fi
+
+  dnl Prepare for creating substitute <wchar.h>.
+  dnl Do it always: WCHAR_H may be empty here but can be set later.
+  dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+  dnl character support).
+  AC_CHECK_HEADERS_ONCE([wchar.h])
+  if test $ac_cv_header_wchar_h = yes; then
+    HAVE_WCHAR_H=1
+  else
+    HAVE_WCHAR_H=0
+  fi
+  AC_SUBST([HAVE_WCHAR_H])
+  gl_CHECK_NEXT_HEADERS([wchar.h])
+])
+
+AC_DEFUN([gl_WCHAR_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_WCHAR_H_DEFAULTS],
+[
+  GNULIB_WCWIDTH=0; AC_SUBST([GNULIB_WCWIDTH])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DECL_WCWIDTH=1; AC_SUBST([HAVE_DECL_WCWIDTH])
+  REPLACE_WCWIDTH=0;   AC_SUBST([REPLACE_WCWIDTH])
+  WCHAR_H=
+  AC_SUBST([WCHAR_H])
+])
diff --git a/m4/wctype.m4 b/m4/wctype.m4
new file mode 100644
index 0000000..7483c4f
--- /dev/null
+++ b/m4/wctype.m4
@@ -0,0 +1,44 @@
+dnl A placeholder for ISO C99 <wctype.h>, for platforms that lack it.
+
+dnl Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Paul Eggert.
+
+AC_DEFUN([gl_WCTYPE_H],
+[
+  AC_CHECK_FUNCS_ONCE([iswcntrl])
+  if test $ac_cv_func_iswcntrl = yes; then
+    HAVE_ISWCNTRL=1
+  else
+    HAVE_ISWCNTRL=0
+  fi
+  AC_SUBST([HAVE_ISWCNTRL])
+  AC_CHECK_HEADERS_ONCE([wctype.h])
+  AC_REQUIRE([AC_C_INLINE])
+
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  if test $gt_cv_c_wint_t = yes; then
+    HAVE_WINT_T=1
+  else
+    HAVE_WINT_T=0
+  fi
+  AC_SUBST([HAVE_WINT_T])
+
+  WCTYPE_H=wctype.h
+  if test $ac_cv_header_wctype_h = yes; then
+    if test $ac_cv_func_iswcntrl = yes; then
+      WCTYPE_H=
+    fi
+    dnl Compute NEXT_WCTYPE_H even if WCTYPE_H is empty,
+    dnl for the benefit of builds from non-distclean directories.
+    gl_CHECK_NEXT_HEADERS([wctype.h])
+    HAVE_WCTYPE_H=1
+  else
+    HAVE_WCTYPE_H=0
+  fi
+  AC_SUBST([HAVE_WCTYPE_H])
+  AC_SUBST([WCTYPE_H])
+])
diff --git a/m4/wint_t.m4 b/m4/wint_t.m4
new file mode 100644
index 0000000..af5ed93
--- /dev/null
+++ b/m4/wint_t.m4
@@ -0,0 +1,28 @@
+# wint_t.m4 serial 2 (gettext-0.17)
+dnl Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <wchar.h> has the 'wint_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WINT_T],
+[
+  AC_CACHE_CHECK([for wint_t], gt_cv_c_wint_t,
+    [AC_TRY_COMPILE([
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be included
+   before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+#include <wchar.h>
+       wint_t foo = (wchar_t)'\0';], ,
+       gt_cv_c_wint_t=yes, gt_cv_c_wint_t=no)])
+  if test $gt_cv_c_wint_t = yes; then
+    AC_DEFINE(HAVE_WINT_T, 1, [Define if you have the 'wint_t' type.])
+  fi
+])
diff --git a/m4/xalloc.m4 b/m4/xalloc.m4
new file mode 100644
index 0000000..837a948
--- /dev/null
+++ b/m4/xalloc.m4
@@ -0,0 +1,24 @@
+# xalloc.m4 serial 16
+dnl Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_XALLOC],
+[
+  AC_LIBOBJ([xmalloc])
+
+  gl_PREREQ_XALLOC
+  gl_PREREQ_XMALLOC
+])
+
+# Prerequisites of lib/xalloc.h.
+AC_DEFUN([gl_PREREQ_XALLOC], [
+  AC_REQUIRE([gl_INLINE])
+  :
+])
+
+# Prerequisites of lib/xmalloc.c.
+AC_DEFUN([gl_PREREQ_XMALLOC], [
+  :
+])
diff --git a/md5/Makefile.am b/md5/Makefile.am
index 1032a6c..8c87f94 100644
--- a/md5/Makefile.am
+++ b/md5/Makefile.am
@@ -1,6 +1,6 @@
 ## DO NOT EDIT! GENERATED AUTOMATICALLY!
 ## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
diff --git a/md5/m4/gnulib-cache.m4 b/md5/m4/gnulib-cache.m4
index 6ca94a7..a33aea4 100644
--- a/md5/m4/gnulib-cache.m4
+++ b/md5/m4/gnulib-cache.m4
@@ -1,4 +1,4 @@
-# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
diff --git a/md5/m4/gnulib-comp.m4 b/md5/m4/gnulib-comp.m4
index 923b7b1..dd5050c 100644
--- a/md5/m4/gnulib-comp.m4
+++ b/md5/m4/gnulib-comp.m4
@@ -1,5 +1,5 @@
 # DO NOT EDIT! GENERATED AUTOMATICALLY!
-# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+# Copyright (C) 2002-2008 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -31,21 +31,17 @@ AC_DEFUN([md5_EARLY],
 # "Check for header files, types and library functions".
 AC_DEFUN([md5_INIT],
 [
-  m4_pushdef([AC_LIBOBJ], m4_defn([md5_LIBOBJ]))
-  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([md5_REPLACE_FUNCS]))
-  m4_pushdef([AC_LIBSOURCES], m4_defn([md5_LIBSOURCES]))
   AM_CONDITIONAL([GL_COND_LIBTOOL], [false])
   gl_cond_libtool=false
   gl_libdeps=
   gl_ltlibdeps=
+  m4_pushdef([AC_LIBOBJ], m4_defn([md5_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([md5_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([md5_LIBSOURCES]))
   gl_source_base='md5'
   gl_MD5
   gl_STDINT_H
   gl_WCHAR_H
-  LIBMD5_LIBDEPS="$gl_libdeps"
-  AC_SUBST([LIBMD5_LIBDEPS])
-  LIBMD5_LTLIBDEPS="$gl_ltlibdeps"
-  AC_SUBST([LIBMD5_LTLIBDEPS])
   m4_popdef([AC_LIBSOURCES])
   m4_popdef([AC_REPLACE_FUNCS])
   m4_popdef([AC_LIBOBJ])
@@ -63,6 +59,33 @@ AC_DEFUN([md5_INIT],
     AC_SUBST([md5_LIBOBJS], [$md5_libobjs])
     AC_SUBST([md5_LTLIBOBJS], [$md5_ltlibobjs])
   ])
+  gltests_libdeps=
+  gltests_ltlibdeps=
+  m4_pushdef([AC_LIBOBJ], m4_defn([md5tests_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([md5tests_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([md5tests_LIBSOURCES]))
+  gl_source_base='tests'
+  m4_popdef([AC_LIBSOURCES])
+  m4_popdef([AC_REPLACE_FUNCS])
+  m4_popdef([AC_LIBOBJ])
+  AC_CONFIG_COMMANDS_PRE([
+    md5tests_libobjs=
+    md5tests_ltlibobjs=
+    if test -n "$md5tests_LIBOBJS"; then
+      # Remove the extension.
+      sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $md5tests_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+        md5tests_libobjs="$md5tests_libobjs $i.$ac_objext"
+        md5tests_ltlibobjs="$md5tests_ltlibobjs $i.lo"
+      done
+    fi
+    AC_SUBST([md5tests_LIBOBJS], [$md5tests_libobjs])
+    AC_SUBST([md5tests_LTLIBOBJS], [$md5tests_ltlibobjs])
+  ])
+  LIBMD5_LIBDEPS="$gl_libdeps"
+  AC_SUBST([LIBMD5_LIBDEPS])
+  LIBMD5_LTLIBDEPS="$gl_ltlibdeps"
+  AC_SUBST([LIBMD5_LTLIBDEPS])
 ])
 
 # Like AC_LIBOBJ, except that the module name goes
@@ -72,6 +95,13 @@ AC_DEFUN([md5_LIBOBJ], [
   md5_LIBOBJS="$md5_LIBOBJS $1.$ac_objext"
 ])
 
+# m4_foreach_w is provided by autoconf-2.59c and later.
+# This definition is to accommodate developers using versions
+# of autoconf older than that.
+m4_ifndef([m4_foreach_w],
+  [m4_define([m4_foreach_w],
+    [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
+
 # Like AC_REPLACE_FUNCS, except that the module name goes
 # into md5_LIBOBJS instead of into LIBOBJS.
 AC_DEFUN([md5_REPLACE_FUNCS], [
@@ -93,6 +123,41 @@ AC_DEFUN([md5_LIBSOURCES], [
   ])
 ])
 
+# Like AC_LIBOBJ, except that the module name goes
+# into md5tests_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([md5tests_LIBOBJ], [
+  AS_LITERAL_IF([$1], [md5tests_LIBSOURCES([$1.c])])dnl
+  md5tests_LIBOBJS="$md5tests_LIBOBJS $1.$ac_objext"
+])
+
+# m4_foreach_w is provided by autoconf-2.59c and later.
+# This definition is to accommodate developers using versions
+# of autoconf older than that.
+m4_ifndef([m4_foreach_w],
+  [m4_define([m4_foreach_w],
+    [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
+
+# Like AC_REPLACE_FUNCS, except that the module name goes
+# into md5tests_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([md5tests_REPLACE_FUNCS], [
+  m4_foreach_w([gl_NAME], [$1], [AC_LIBSOURCES(gl_NAME[.c])])dnl
+  AC_CHECK_FUNCS([$1], , [md5tests_LIBOBJ($ac_func)])
+])
+
+# Like AC_LIBSOURCES, except the directory where the source file is
+# expected is derived from the gnulib-tool parametrization,
+# and alloca is special cased (for the alloca-opt module).
+# We could also entirely rely on EXTRA_lib..._SOURCES.
+AC_DEFUN([md5tests_LIBSOURCES], [
+  m4_foreach([_gl_NAME], [$1], [
+    m4_if(_gl_NAME, [alloca.c], [], [
+      m4_syscmd([test -r tests/]_gl_NAME[ || test ! -d tests])dnl
+      m4_if(m4_sysval, [0], [],
+        [AC_FATAL([missing tests/]_gl_NAME)])
+    ])
+  ])
+])
+
 # This macro records the list of files which have been installed by
 # gnulib-tool and may be removed by future gnulib-tool invocations.
 AC_DEFUN([md5_FILE_LIST], [
diff --git a/md5/m4/include_next.m4 b/md5/m4/include_next.m4
index 7ce472b..a842e2a 100644
--- a/md5/m4/include_next.m4
+++ b/md5/m4/include_next.m4
@@ -1,5 +1,5 @@
-# include_next.m4 serial 4
-dnl Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+# include_next.m4 serial 6
+dnl Copyright (C) 2006-2008 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -63,12 +63,15 @@ EOF
 # The three "///" are to pacify Sun C 5.8, which otherwise would say
 # "warning: #include of /usr/include/... may be non-portable".
 # Use `""', not `<>', so that the /// cannot be confused with a C99 comment.
+# Note: This macro assumes that the header file is not empty after
+# preprocessing, i.e. it does not only define preprocessor macros but also
+# provides some type/enum definitions or function/variable declarations.
 AC_DEFUN([gl_CHECK_NEXT_HEADERS],
 [
   AC_REQUIRE([gl_INCLUDE_NEXT])
   AC_CHECK_HEADERS_ONCE([$1])
 
-  AC_FOREACH([gl_HEADER_NAME], [$1],
+  m4_foreach_w([gl_HEADER_NAME], [$1],
     [AS_VAR_PUSHDEF([gl_next_header],
 		    [gl_cv_next_]m4_quote(m4_defn([gl_HEADER_NAME])))
      if test $gl_cv_have_include_next = yes; then
diff --git a/md5/m4/md5.m4 b/md5/m4/md5.m4
index 5a1f875..e4d00f3 100644
--- a/md5/m4/md5.m4
+++ b/md5/m4/md5.m4
@@ -1,5 +1,5 @@
-# md5.m4 serial 9
-dnl Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+# md5.m4 serial 10
+dnl Copyright (C) 2002, 2003, 2004, 2005, 2006, 2008 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -10,5 +10,6 @@ AC_DEFUN([gl_MD5],
 
   dnl Prerequisites of lib/md5.c.
   AC_REQUIRE([AC_C_BIGENDIAN])
+  AC_REQUIRE([AC_C_INLINE])
   :
 ])
diff --git a/md5/m4/stdint.m4 b/md5/m4/stdint.m4
index bb6c34f..9b5001a 100644
--- a/md5/m4/stdint.m4
+++ b/md5/m4/stdint.m4
@@ -1,5 +1,5 @@
-# stdint.m4 serial 29
-dnl Copyright (C) 2001-2007 Free Software Foundation, Inc.
+# stdint.m4 serial 30
+dnl Copyright (C) 2001-2008 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -240,7 +240,7 @@ AC_DEFUN([gl_STDINT_BITSIZEOF],
   dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
   dnl   config.h.in,
   dnl - extra AC_SUBST calls, so that the right substitutions are made.
-  AC_FOREACH([gltype], [$1],
+  m4_foreach_w([gltype], [$1],
     [AH_TEMPLATE([BITSIZEOF_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
        [Define to the number of bits in type ']gltype['.])])
   for gltype in $1 ; do
@@ -265,7 +265,7 @@ AC_DEFUN([gl_STDINT_BITSIZEOF],
     AC_DEFINE_UNQUOTED([BITSIZEOF_${GLTYPE}], [$result])
     eval BITSIZEOF_${GLTYPE}=\$result
   done
-  AC_FOREACH([gltype], [$1],
+  m4_foreach_w([gltype], [$1],
     [AC_SUBST([BITSIZEOF_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
 ])
 
@@ -278,7 +278,7 @@ AC_DEFUN([gl_CHECK_TYPES_SIGNED],
   dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
   dnl   config.h.in,
   dnl - extra AC_SUBST calls, so that the right substitutions are made.
-  AC_FOREACH([gltype], [$1],
+  m4_foreach_w([gltype], [$1],
     [AH_TEMPLATE([HAVE_SIGNED_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
        [Define to 1 if ']gltype[' is a signed integer type.])])
   for gltype in $1 ; do
@@ -298,7 +298,7 @@ AC_DEFUN([gl_CHECK_TYPES_SIGNED],
       eval HAVE_SIGNED_${GLTYPE}=0
     fi
   done
-  AC_FOREACH([gltype], [$1],
+  m4_foreach_w([gltype], [$1],
     [AC_SUBST([HAVE_SIGNED_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
 ])
 
@@ -311,7 +311,7 @@ AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
   dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
   dnl   config.h.in,
   dnl - extra AC_SUBST calls, so that the right substitutions are made.
-  AC_FOREACH([gltype], [$1],
+  m4_foreach_w([gltype], [$1],
     [AH_TEMPLATE(translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX],
        [Define to l, ll, u, ul, ull, etc., as suitable for
         constants of type ']gltype['.])])
@@ -350,7 +350,7 @@ AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
     eval ${GLTYPE}_SUFFIX=\$result
     AC_DEFINE_UNQUOTED([${GLTYPE}_SUFFIX], $result)
   done
-  AC_FOREACH([gltype], [$1],
+  m4_foreach_w([gltype], [$1],
     [AC_SUBST(translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX])])
 ])
 
diff --git a/md5/md5.c b/md5/md5.c
index 5b3d3a4..2e03bb9 100644
--- a/md5/md5.c
+++ b/md5/md5.c
@@ -1,6 +1,6 @@
 /* Functions to compute MD5 message digest of files or memory blocks.
    according to the definition of MD5 in RFC 1321 from April 1992.
-   Copyright (C) 1995,1996,1997,1999,2000,2001,2005,2006
+   Copyright (C) 1995,1996,1997,1999,2000,2001,2005,2006,2008
 	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -80,27 +80,31 @@ md5_init_ctx (struct md5_ctx *ctx)
   ctx->buflen = 0;
 }
 
-/* Put result from CTX in first 16 bytes following RESBUF.  The result
-   must be in little endian byte order.
+/* Copy the 4 byte value from v into the memory location pointed to by *cp,
+   If your architecture allows unaligned access this is equivalent to
+   * (uint32_t *) cp = v  */
+static inline void
+set_uint32 (char *cp, uint32_t v)
+{
+  memcpy (cp, &v, sizeof v);
+}
 
-   IMPORTANT: On some systems it is required that RESBUF is correctly
-   aligned for a 32-bit value.  */
+/* Put result from CTX in first 16 bytes following RESBUF.  The result
+   must be in little endian byte order.  */
 void *
 md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)
 {
-  ((uint32_t *) resbuf)[0] = SWAP (ctx->A);
-  ((uint32_t *) resbuf)[1] = SWAP (ctx->B);
-  ((uint32_t *) resbuf)[2] = SWAP (ctx->C);
-  ((uint32_t *) resbuf)[3] = SWAP (ctx->D);
+  char *r = resbuf;
+  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));
+  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));
+  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));
+  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));
 
   return resbuf;
 }
 
 /* Process the remaining bytes in the internal buffer and the usual
-   prolog according to the standard and write the result to RESBUF.
-
-   IMPORTANT: On some systems it is required that RESBUF is correctly
-   aligned for a 32-bit value.  */
+   prolog according to the standard and write the result to RESBUF.  */
 void *
 md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)
 {
diff --git a/md5/md5.h b/md5/md5.h
index b69735e..ffee3e8 100644
--- a/md5/md5.h
+++ b/md5/md5.h
@@ -1,6 +1,6 @@
 /* Declaration of functions and data types used for MD5 sum computing
    library functions.
-   Copyright (C) 1995-1997,1999,2000,2001,2004,2005,2006
+   Copyright (C) 1995-1997,1999,2000,2001,2004,2005,2006,2008
       Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -93,19 +93,13 @@ extern void __md5_process_bytes (const void *buffer, size_t len,
 /* Process the remaining bytes in the buffer and put result from CTX
    in first 16 bytes following RESBUF.  The result is always in little
    endian byte order, so that a byte-wise output yields to the wanted
-   ASCII representation of the message digest.
-
-   IMPORTANT: On some systems, RESBUF must be aligned to a 32-bit
-   boundary. */
+   ASCII representation of the message digest.  */
 extern void *__md5_finish_ctx (struct md5_ctx *ctx, void *resbuf) __THROW;
 
 
 /* Put result from CTX in first 16 bytes following RESBUF.  The result is
    always in little endian byte order, so that a byte-wise output yields
-   to the wanted ASCII representation of the message digest.
-
-   IMPORTANT: On some systems, RESBUF must be aligned to a 32-bit
-   boundary. */
+   to the wanted ASCII representation of the message digest.  */
 extern void *__md5_read_ctx (const struct md5_ctx *ctx, void *resbuf) __THROW;
 
 
diff --git a/md5/stdint.in.h b/md5/stdint.in.h
index 8aee868..67baceb 100644
--- a/md5/stdint.in.h
+++ b/md5/stdint.in.h
@@ -23,6 +23,12 @@
 
 #ifndef _GL_STDINT_H
 
+/* When including a system file that in turn includes <inttypes.h>,
+   use the system <inttypes.h>, not our substitute.  This avoids
+   problems with (for example) VMS, whose <sys/bitypes.h> includes
+   <inttypes.h>.  */
+#define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+
 /* Get those types that are already defined in other system include
    files, so that we can "#define int8_t signed char" below without
    worrying about a later system include file containing a "typedef
@@ -66,9 +72,7 @@
   /* In OpenBSD 3.8, <inttypes.h> includes <machine/types.h>, which defines
      int{8,16,32,64}_t, uint{8,16,32,64}_t and __BIT_TYPES_DEFINED__.
      <inttypes.h> also defines intptr_t and uintptr_t.  */
-# define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
 # include <inttypes.h>
-# undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
 #elif @HAVE_SYS_INTTYPES_H@
   /* Solaris 7 <sys/inttypes.h> has the types except the *_fast*_t types, and
      the macros except for *_FAST*_*, INTPTR_MIN, PTRDIFF_MIN, PTRDIFF_MAX.  */
@@ -91,6 +95,8 @@
 
 #endif
 
+#undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+
 /* Minimum and maximum values for a integer type under the usual assumption.
    Return an unspecified value if BITS == 0, adding a check to pacify
    picky compilers.  */
diff --git a/md5/wchar.in.h b/md5/wchar.in.h
index b721572..8dfead2 100644
--- a/md5/wchar.in.h
+++ b/md5/wchar.in.h
@@ -26,6 +26,14 @@
  * the declaration of wcwidth().
  */
 
+#ifdef __need_mbstate_t
+/* Special invocation convention inside glibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_WCHAR_H@
+
+#else
+/* Normal invocation convention.  */
+
 #ifndef _GL_WCHAR_H
 
 /* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
@@ -80,3 +88,4 @@ extern int wcwidth (int /* actually wchar_t */);
 
 #endif /* _GL_WCHAR_H */
 #endif /* _GL_WCHAR_H */
+#endif
-- 
cgit v1.0-41-gc330


From bbe13a5b6870892fef2d12af3f80d0afc955511a Mon Sep 17 00:00:00 2001
From: Micah Cowan <micah@cowan.name>
Date: Mon, 14 Apr 2008 15:40:13 -0700
Subject: ChangeLog entry for Gnulib updates.

---
 ChangeLog | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/ChangeLog b/ChangeLog
index 059157f..f5b5d37 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,21 @@
+2008-04-14  Micah Cowan  <micah@cowan.name>
+
+	* GNUmakefile, lib/Makefile.am, lib/error.c, lib/error.h,
+	lib/exitfail.c, lib/exitfail.h, lib/getopt.c, lib/intprops.h,
+	lib/quote.c, lib/quote.h, lib/quotearg.c, lib/quotearg.h,
+	lib/stdlib.in.h, lib/strerror.c, lib/string.in.h,
+	lib/unistd.in.h, lib/wchar.in.h, lib/wctype.in.h,
+	lib/xalloc-die.c, lib/xalloc.h, lib/xmalloc.c, m4/error.m4,
+	m4/exitfail.m4, m4/extensions.m4, m4/gnulib-cache.m4,
+	m4/gnulib-comp.m4, m4/include_next.m4, m4/inline.m4,
+	m4/mbrtowc.m4, m4/mbstate_t.m4, m4/quote.m4, m4/quotearg.m4,
+	m4/stdlib_h.m4, m4/strerror.m4, m4/string_h.m4, m4/unistd_h.m4,
+	m4/wchar.m4, m4/wctype.m4, m4/wint_t.m4, m4/xalloc.m4,
+	md5/Makefile.am, md5/m4/gnulib-cache.m4, md5/m4/gnulib-comp.m4,
+	md5/m4/include_next.m4, md5/m4/md5.m4, md5/m4/stdint.m4,
+	md5/md5.c, md5/md5.h, md5/stdint.in.h, md5/wchar.in.h: Update
+	from Gnulib, and add the "quote" module.
+
 2008-03-20  Micah Cowan  <micah@cowan.name>
 
 	* ABOUT-NLS: Reinstated, but with a message mentioning that
-- 
cgit v1.0-41-gc330


From 92956183a703d7232a12151a8ea4623149891c7a Mon Sep 17 00:00:00 2001
From: Micah Cowan <micah@cowan.name>
Date: Mon, 14 Apr 2008 15:45:40 -0700
Subject: Applied Steven Schubiger's patch to use Gnulib's quote function in
 http.c.

---
 src/ChangeLog |  6 ++++++
 src/http.c    | 42 +++++++++++++++++++++---------------------
 src/wget.h    |  5 ++++-
 3 files changed, 31 insertions(+), 22 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 871a82e..6ca006d 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,9 @@
+2008-04-14  Steven Schubiger  <schubiger@gmail.com>
+
+	* http.c: Use Gnulib's quote function for printing filenames and
+	such.
+	* wget.h: #include "quote.h".
+
 2008-04-12  Rabin Vincent  <rabin@rab.in>
 
 	* mswindows.c (fake_fork_child): Don't create a logfile for
diff --git a/src/http.c b/src/http.c
index ec815c8..c1049d8 100644
--- a/src/http.c
+++ b/src/http.c
@@ -403,13 +403,13 @@ maybe_send_basic_creds (const char *hostname, const char *user,
   else if (basic_authed_hosts
       && hash_table_contains(basic_authed_hosts, hostname))
     {
-      DEBUGP(("Found `%s' in basic_authed_hosts.\n", hostname));
+      DEBUGP(("Found %s in basic_authed_hosts.\n", quote (hostname)));
       do_challenge = true;
     }
   else
     {
-      DEBUGP(("Host `%s' has not issued a general basic challenge.\n",
-              hostname));
+      DEBUGP(("Host %s has not issued a general basic challenge.\n",
+              quote (hostname)));
     }
   if (do_challenge)
     {
@@ -430,7 +430,7 @@ register_basic_auth_host (const char *hostname)
   if (!hash_table_contains(basic_authed_hosts, hostname))
     {
       hash_table_put (basic_authed_hosts, xstrdup(hostname), NULL);
-      DEBUGP(("Inserted `%s' into basic_authed_hosts\n", hostname));
+      DEBUGP(("Inserted %s into basic_authed_hosts\n", quote (hostname)));
     }
 }
 
@@ -1579,8 +1579,8 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
           post_data_size = file_size (opt.post_file_name);
           if (post_data_size == -1)
             {
-              logprintf (LOG_NOTQUIET, _("POST data file `%s' missing: %s\n"),
-                         opt.post_file_name, strerror (errno));
+              logprintf (LOG_NOTQUIET, _("POST data file %s missing: %s\n"),
+                         quote (opt.post_file_name), strerror (errno));
               post_data_size = 0;
             }
         }
@@ -1641,8 +1641,8 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
         {
           request_free (req);
           logprintf(LOG_NOTQUIET,
-                    _("%s: unable to resolve host address `%s'\n"),
-                    exec_name, relevant->host);
+                    _("%s: unable to resolve host address %s\n"),
+                    exec_name, quote (relevant->host));
           return HOSTERR;
         }
     }
@@ -1826,7 +1826,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
           /* If opt.noclobber is turned on and file already exists, do not
              retrieve the file */
           logprintf (LOG_VERBOSE, _("\
-File `%s' already there; not retrieving.\n\n"), hs->local_file);
+File %s already there; not retrieving.\n\n"), quote (hs->local_file));
           /* If the file is there, we suppose it's retrieved OK.  */
           *dt |= RETROKF;
 
@@ -2274,8 +2274,8 @@ File `%s' already there; not retrieving.\n\n"), hs->local_file);
   /* Print fetch message, if opt.verbose.  */
   if (opt.verbose)
     {
-      logprintf (LOG_NOTQUIET, _("Saving to: `%s'\n"), 
-                 HYPHENP (hs->local_file) ? "STDOUT" : hs->local_file);
+      logprintf (LOG_NOTQUIET, _("Saving to: %s\n"), 
+                 HYPHENP (hs->local_file) ? quote ("STDOUT") : quote (hs->local_file));
     }
     
   /* This confuses the timestamping code that checks for file size.
@@ -2379,8 +2379,8 @@ http_loop (struct url *u, char **newloc, char **local_file, const char *referer,
       /* If opt.noclobber is turned on and file already exists, do not
          retrieve the file */
       logprintf (LOG_VERBOSE, _("\
-File `%s' already there; not retrieving.\n\n"), 
-                 hstat.local_file);
+File %s already there; not retrieving.\n\n"), 
+                 quote (hstat.local_file));
       /* If the file is there, we suppose it's retrieved OK.  */
       *dt |= RETROKF;
 
@@ -2507,8 +2507,8 @@ Spider mode enabled. Check if remote file exists.\n"));
         case FWRITEERR: case FOPENERR:
           /* Another fatal error.  */
           logputs (LOG_VERBOSE, "\n");
-          logprintf (LOG_NOTQUIET, _("Cannot write to `%s' (%s).\n"),
-                     hstat.local_file, strerror (errno));
+          logprintf (LOG_NOTQUIET, _("Cannot write to %s (%s).\n"),
+                     quote (hstat.local_file), strerror (errno));
         case HOSTERR: case CONIMPOSSIBLE: case PROXERR: case AUTHFAILED: 
         case SSLINITFAILED: case CONTNOTSUPPORTED:
           /* Fatal errors just return from the function.  */
@@ -2630,8 +2630,8 @@ Last-modified header invalid -- time-stamp ignored.\n"));
                                   || hstat.orig_file_size == hstat.contlen)
                                 {
                                   logprintf (LOG_VERBOSE, _("\
-Server file no newer than local file `%s' -- not retrieving.\n\n"),
-                                             hstat.orig_file_name);
+Server file no newer than local file %s -- not retrieving.\n\n"),
+                                             quote (hstat.orig_file_name));
                                   ret = RETROK;
                                   goto exit;
                                 }
@@ -2734,8 +2734,8 @@ Remote file exists.\n\n"));
           if (*dt & RETROKF)
             {
               logprintf (LOG_VERBOSE,
-                         _("%s (%s) - `%s' saved [%s/%s]\n\n"),
-                         tms, tmrate, hstat.local_file,
+                         _("%s (%s) - %s saved [%s/%s]\n\n"),
+                         tms, tmrate, quote (hstat.local_file),
                          number_to_static_string (hstat.len),
                          number_to_static_string (hstat.contlen));
               logprintf (LOG_NONVERBOSE,
@@ -2765,8 +2765,8 @@ Remote file exists.\n\n"));
               if (*dt & RETROKF)
                 {
                   logprintf (LOG_VERBOSE,
-                             _("%s (%s) - `%s' saved [%s]\n\n"),
-                             tms, tmrate, hstat.local_file,
+                             _("%s (%s) - %s saved [%s]\n\n"),
+                             tms, tmrate, quote (hstat.local_file),
                              number_to_static_string (hstat.len));
                   logprintf (LOG_NONVERBOSE,
                              "%s URL:%s [%s] -> \"%s\" [%d]\n",
diff --git a/src/wget.h b/src/wget.h
index 08d8d83..d8ab0c9 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -212,7 +212,10 @@ typedef double SUM_SIZE_INT;
 
 /* Likewise for logging functions.  */
 #include "log.h"
-
+
+/* Likewise for quoting functions.  */
+#include "quote.h"
+
 /* Useful macros used across the code: */
 
 /* The number of elements in an array.  For example:
-- 
cgit v1.0-41-gc330


From 19aed3ee56642184d48f541646cd950fa22a164c Mon Sep 17 00:00:00 2001
From: Micah Cowan <micah@cowan.name>
Date: Mon, 14 Apr 2008 16:21:37 -0700
Subject: Ignore some new generated .h files in lib/.

---
 .hgignore | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/.hgignore b/.hgignore
index 666c5c3..92437a1 100644
--- a/.hgignore
+++ b/.hgignore
@@ -16,6 +16,8 @@ lib/libgnu.a
 lib/unistd.h
 lib/stdbool.h
 lib/stdint.h
+lib/stdlib.h
+lib/string.h
 lib/wchar.h
 md5/.deps
 md5/*.o
-- 
cgit v1.0-41-gc330


From 3b3c7db8df9fef1712922883133bc552d90ebd70 Mon Sep 17 00:00:00 2001
From: sts <sts@kronos>
Date: Wed, 16 Apr 2008 10:57:12 +0200
Subject: Avoid redefined warnings caused by clashing defines.

---
 src/ChangeLog | 5 +++++
 src/sysdep.h  | 4 ++--
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 6ca006d..d62ebcb 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,8 @@
+2008-04-16  Steven Schubiger  <schubiger@gmail.com>
+
+	* sysdep.h: Comment the defines __EXTENSIONS__ and _GNU_SOURCE 
+	out, because they're now defined independently by config.h.
+
 2008-04-14  Steven Schubiger  <schubiger@gmail.com>
 
 	* http.c: Use Gnulib's quote function for printing filenames and
diff --git a/src/sysdep.h b/src/sysdep.h
index ec50e04..84301b7 100644
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -68,7 +68,7 @@ as that of the covered work.  */
 
 /* For Solaris: request everything else that is available and doesn't
    conflict with the above.  */
-#define __EXTENSIONS__
+/* #define __EXTENSIONS__ */ /* XXX clashes with config.h */
 
 /* For Linux: request features of 4.3BSD and SVID (System V Interface
    Definition). */
@@ -78,7 +78,7 @@ as that of the covered work.  */
 /* Under glibc-based systems we want all GNU extensions as well.  This
    declares some unnecessary cruft, but also useful functions such as
    timegm, FNM_CASEFOLD extension to fnmatch, memrchr, etc.  */
-#define _GNU_SOURCE
+/* #define _GNU_SOURCE */ /* XXX clashes with config.h */
 
 #endif /* NAMESPACE_TWEAKS */
 
-- 
cgit v1.0-41-gc330


From 6aec825b936986e74763b3e635874903ae0b3065 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 11:36:12 +0200
Subject: Use Gnulib's quote function in ftp.c.

---
 src/ChangeLog |  5 +++++
 src/ftp.c     | 64 +++++++++++++++++++++++++++++------------------------------
 2 files changed, 37 insertions(+), 32 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index d62ebcb..a4ce89c 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,5 +1,10 @@
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
+	* ftp.c: Use Gnulib's quote function for printing filenames and
+	such.
+
+2008-04-16  Steven Schubiger  <schubiger@gmail.com>
+
 	* sysdep.h: Comment the defines __EXTENSIONS__ and _GNU_SOURCE 
 	out, because they're now defined independently by config.h.
 
diff --git a/src/ftp.c b/src/ftp.c
index 0321032..645e565 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -566,8 +566,8 @@ Error in server response, closing control connection.\n"));
               return err;
             case FTPNSFOD:
               logputs (LOG_VERBOSE, "\n");
-              logprintf (LOG_NOTQUIET, _("No such directory `%s'.\n\n"),
-                         escnonprint (u->dir));
+              logprintf (LOG_NOTQUIET, _("No such directory %s.\n\n"),
+                         quote (escnonprint (u->dir)));
               fd_close (csock);
               con->csock = -1;
               return err;
@@ -823,8 +823,8 @@ Error in server response, closing control connection.\n"));
           return err;
         case FTPNSFOD:
           logputs (LOG_VERBOSE, "\n");
-          logprintf (LOG_NOTQUIET, _("No such file `%s'.\n\n"),
-                     escnonprint (u->file));
+          logprintf (LOG_NOTQUIET, _("No such file %s.\n\n"),
+                     quote (escnonprint (u->file)));
           fd_close (dtsock);
           fd_close (local_sock);
           return err;
@@ -870,8 +870,8 @@ Error in server response, closing control connection.\n"));
           return err;
         case FTPNSFOD:
           logputs (LOG_VERBOSE, "\n");
-          logprintf (LOG_NOTQUIET, _("No such file or directory `%s'.\n\n"),
-                     ".");
+          logprintf (LOG_NOTQUIET, _("No such file or directory %s.\n\n"),
+                     quote ("."));
           fd_close (dtsock);
           fd_close (local_sock);
           return err;
@@ -1094,7 +1094,7 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
   if (opt.noclobber && file_exists_p (con->target))
     {
       logprintf (LOG_VERBOSE,
-                 _("File `%s' already there; not retrieving.\n"), con->target);
+                 _("File %s already there; not retrieving.\n"), quote (con->target));
       /* If the file is there, we suppose it's retrieved OK.  */
       return RETROK;
     }
@@ -1165,8 +1165,8 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
           strcpy (tmp, "        ");
           if (count > 1)
             sprintf (tmp, _("(try:%2d)"), count);
-          logprintf (LOG_VERBOSE, "--%s--  %s\n  %s => `%s'\n",
-                     tms, hurl, tmp, locf);
+          logprintf (LOG_VERBOSE, "--%s--  %s\n  %s => %s\n",
+                     tms, hurl, tmp, quote (locf));
 #ifdef WINDOWS
           ws_changetitle (hurl);
 #endif
@@ -1234,8 +1234,8 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
           con->csock = -1;
         }
       if (!opt.spider)
-        logprintf (LOG_VERBOSE, _("%s (%s) - `%s' saved [%s]\n\n"),
-                   tms, tmrate, locf, number_to_static_string (len));
+        logprintf (LOG_VERBOSE, _("%s (%s) - %s saved [%s]\n\n"),
+                   tms, tmrate, quote (locf), number_to_static_string (len));
       if (!opt.verbose && !opt.quiet)
         {
           /* Need to hide the password from the URL.  The `if' is here
@@ -1318,7 +1318,7 @@ ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
   uf = url_file_name (u);
   lf = file_merge (uf, LIST_FILENAME);
   xfree (uf);
-  DEBUGP ((_("Using `%s' as listing tmp file.\n"), lf));
+  DEBUGP ((_("Using %s as listing tmp file.\n"), quote (lf)));
 
   con->target = lf;
   err = ftp_loop_internal (u, NULL, con);
@@ -1333,7 +1333,7 @@ ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)
       if (unlink (lf))
         logprintf (LOG_NOTQUIET, "unlink: %s\n", strerror (errno));
       else
-        logprintf (LOG_VERBOSE, _("Removed `%s'.\n"), lf);
+        logprintf (LOG_VERBOSE, _("Removed %s.\n"), quote (lf));
     }
   xfree (lf);
   con->cmd &= ~DO_LIST;
@@ -1437,15 +1437,15 @@ ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
                   /* Remote file is older, file sizes can be compared and
                      are both equal. */
                   logprintf (LOG_VERBOSE, _("\
-Remote file no newer than local file `%s' -- not retrieving.\n"), con->target);
+Remote file no newer than local file %s -- not retrieving.\n"), quote (con->target));
                   dlthis = false;
                 }
               else if (eq_size)
                 {
                   /* Remote file is newer or sizes cannot be matched */
                   logprintf (LOG_VERBOSE, _("\
-Remote file is newer than local file `%s' -- retrieving.\n\n"),
-                             con->target);
+Remote file is newer than local file %s -- retrieving.\n\n"),
+                             quote (con->target));
                 }
               else
                 {
@@ -1503,8 +1503,8 @@ Already have correct symlink %s -> %s\n\n"),
                 } /* have f->linkto */
 #else  /* not HAVE_SYMLINK */
               logprintf (LOG_NOTQUIET,
-                         _("Symlinks not supported, skipping symlink `%s'.\n"),
-                         con->target);
+                         _("Symlinks not supported, skipping symlink %s.\n"),
+                         quote (con->target));
 #endif /* not HAVE_SYMLINK */
             }
           else                /* opt.retr_symlinks */
@@ -1515,8 +1515,8 @@ Already have correct symlink %s -> %s\n\n"),
           break;
         case FT_DIRECTORY:
           if (!opt.recursive)
-            logprintf (LOG_NOTQUIET, _("Skipping directory `%s'.\n"),
-                       escnonprint (f->name));
+            logprintf (LOG_NOTQUIET, _("Skipping directory %s.\n"),
+                       quote (escnonprint (f->name)));
           break;
         case FT_PLAINFILE:
           /* Call the retrieve loop.  */
@@ -1630,8 +1630,8 @@ ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)
       if (!accdir (newdir))
         {
           logprintf (LOG_VERBOSE, _("\
-Not descending to `%s' as it is excluded/not-included.\n"),
-                     escnonprint (newdir));
+Not descending to %s as it is excluded/not-included.\n"),
+                     quote (escnonprint (newdir)));
           continue;
         }
 
@@ -1695,8 +1695,8 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
         {
           if (f->type != FT_DIRECTORY && !acceptable (f->name))
             {
-              logprintf (LOG_VERBOSE, _("Rejecting `%s'.\n"),
-                         escnonprint (f->name));
+              logprintf (LOG_VERBOSE, _("Rejecting %s.\n"),
+                         quote (escnonprint (f->name)));
               f = delelement (f, &start);
             }
           else
@@ -1709,8 +1709,8 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
     {
       if (has_insecure_name_p (f->name))
         {
-          logprintf (LOG_VERBOSE, _("Rejecting `%s'.\n"),
-                     escnonprint (f->name));
+          logprintf (LOG_VERBOSE, _("Rejecting %s.\n"),
+                     quote (escnonprint (f->name)));
           f = delelement (f, &start);
         }
       else
@@ -1773,8 +1773,8 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
           /* No luck.  */
           /* #### This message SUCKS.  We should see what was the
              reason that nothing was retrieved.  */
-          logprintf (LOG_VERBOSE, _("No matches on pattern `%s'.\n"),
-                     escnonprint (u->file));
+          logprintf (LOG_VERBOSE, _("No matches on pattern %s.\n"),
+                     quote (escnonprint (u->file)));
         }
       else /* GLOB_GETONE or GLOB_GETALL */
         {
@@ -1839,13 +1839,13 @@ ftp_loop (struct url *u, int *dt, struct url *proxy, bool recursive, bool glob)
                       else
                         sz = -1;
                       logprintf (LOG_NOTQUIET,
-                                 _("Wrote HTML-ized index to `%s' [%s].\n"),
-                                 filename, number_to_static_string (sz));
+                                 _("Wrote HTML-ized index to %s [%s].\n"),
+                                 quote (filename), number_to_static_string (sz));
                     }
                   else
                     logprintf (LOG_NOTQUIET,
-                               _("Wrote HTML-ized index to `%s'.\n"),
-                               filename);
+                               _("Wrote HTML-ized index to %s.\n"),
+                               quote (filename));
                 }
               xfree (filename);
             }
-- 
cgit v1.0-41-gc330


From cb2b31f0527d25d56a87eae791df3a10c25918af Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 11:45:14 +0200
Subject: Use Gnulib's quote function in connect.c.

---
 src/ChangeLog | 1 +
 src/connect.c | 8 ++++----
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index a4ce89c..c99218f 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -2,6 +2,7 @@
 
 	* ftp.c: Use Gnulib's quote function for printing filenames and
 	such.
+	* connect.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/connect.c b/src/connect.c
index 2be764d..2626ef3 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -195,8 +195,8 @@ resolve_bind_address (struct sockaddr *sa)
     {
       /* #### We should be able to print the error message here. */
       logprintf (LOG_NOTQUIET,
-                 _("%s: unable to resolve bind address `%s'; disabling bind.\n"),
-                 exec_name, opt.bind_address);
+                 _("%s: unable to resolve bind address %s; disabling bind.\n"),
+                 exec_name, quote (opt.bind_address));
       should_bind = false;
       return false;
     }
@@ -366,8 +366,8 @@ connect_to_host (const char *host, int port)
   if (!al)
     {
       logprintf (LOG_NOTQUIET,
-                 _("%s: unable to resolve host address `%s'\n"),
-                 exec_name, host);
+                 _("%s: unable to resolve host address %s\n"),
+                 exec_name, quote (host));
       return E_HOST;
     }
 
-- 
cgit v1.0-41-gc330


From 5116620aa8d65ba7771ef6515973f0f2d6cd3de6 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 11:50:36 +0200
Subject: Use Gnulib's quote function in convert.c.

---
 src/ChangeLog | 1 +
 src/convert.c | 4 ++--
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index c99218f..0dfd14d 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -3,6 +3,7 @@
 	* ftp.c: Use Gnulib's quote function for printing filenames and
 	such.
 	* connect.c: Likewise.
+	* convert.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/convert.c b/src/convert.c
index 2811bff..69d713f 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -230,8 +230,8 @@ convert_links (const char *file, struct urlpos *links)
      zeroes from the mmaped region.  */
   if (unlink (file) < 0 && errno != ENOENT)
     {
-      logprintf (LOG_NOTQUIET, _("Unable to delete `%s': %s\n"),
-                 file, strerror (errno));
+      logprintf (LOG_NOTQUIET, _("Unable to delete %s: %s\n"),
+                 quote (file), strerror (errno));
       read_file_free (fm);
       return;
     }
-- 
cgit v1.0-41-gc330


From 0edf98a6d9962bb9a9af2c25623e63ab70870ce1 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 11:57:19 +0200
Subject: Use Gnulib's quote function in cookies.c.

---
 src/ChangeLog |  1 +
 src/cookies.c | 16 ++++++++--------
 2 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 0dfd14d..248a896 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -4,6 +4,7 @@
 	such.
 	* connect.c: Likewise.
 	* convert.c: Likewise.
+	* cookies.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/cookies.c b/src/cookies.c
index 6c30f06..bdc3274 100644
--- a/src/cookies.c
+++ b/src/cookies.c
@@ -1129,8 +1129,8 @@ cookie_jar_load (struct cookie_jar *jar, const char *file)
   FILE *fp = fopen (file, "r");
   if (!fp)
     {
-      logprintf (LOG_NOTQUIET, _("Cannot open cookies file `%s': %s\n"),
-                 file, strerror (errno));
+      logprintf (LOG_NOTQUIET, _("Cannot open cookies file %s: %s\n"),
+                 quote (file), strerror (errno));
       return;
     }
   cookies_now = time (NULL);
@@ -1247,8 +1247,8 @@ cookie_jar_save (struct cookie_jar *jar, const char *file)
   fp = fopen (file, "w");
   if (!fp)
     {
-      logprintf (LOG_NOTQUIET, _("Cannot open cookies file `%s': %s\n"),
-                 file, strerror (errno));
+      logprintf (LOG_NOTQUIET, _("Cannot open cookies file %s: %s\n"),
+                 quote (file), strerror (errno));
       return;
     }
 
@@ -1284,11 +1284,11 @@ cookie_jar_save (struct cookie_jar *jar, const char *file)
     }
  out:
   if (ferror (fp))
-    logprintf (LOG_NOTQUIET, _("Error writing to `%s': %s\n"),
-               file, strerror (errno));
+    logprintf (LOG_NOTQUIET, _("Error writing to %s: %s\n"),
+               quote (file), strerror (errno));
   if (fclose (fp) < 0)
-    logprintf (LOG_NOTQUIET, _("Error closing `%s': %s\n"),
-               file, strerror (errno));
+    logprintf (LOG_NOTQUIET, _("Error closing %s: %s\n"),
+               quote (file), strerror (errno));
 
   DEBUGP (("Done saving cookies.\n"));
 }
-- 
cgit v1.0-41-gc330


From bb1813ebb1de176dd1bd00424f7c66470abd3bbd Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:01:00 +0200
Subject: Use Gnulib's quote function in ftp-opie.c.

---
 src/ChangeLog  | 1 +
 src/ftp-opie.c | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 248a896..5c8b12a 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -5,6 +5,7 @@
 	* connect.c: Likewise.
 	* convert.c: Likewise.
 	* cookies.c: Likewise.
+	* ftp-opie.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/ftp-opie.c b/src/ftp-opie.c
index 8af58f9..546e210 100644
--- a/src/ftp-opie.c
+++ b/src/ftp-opie.c
@@ -2157,7 +2157,7 @@ btoe (char *store, const unsigned char *c)
   memcpy (store, &Wp[extract (cp, 55, 11)][0], 4);
   store[4] = '\0';              /* make sure the string is terminated */
 
-  DEBUGP (("wrote `%s' to STORE\n", store_beg));
+  DEBUGP (("wrote %s to STORE\n", quote (store_beg)));
   return store_beg;
 }
 
-- 
cgit v1.0-41-gc330


From 1daacbb296aa045fbf50ec04494a071f3a702487 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:04:53 +0200
Subject: Use Gnulib's quote function in gnutls.c.

---
 src/ChangeLog |  1 +
 src/gnutls.c  | 12 ++++++------
 2 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 5c8b12a..45aa11e 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -6,6 +6,7 @@
 	* convert.c: Likewise.
 	* cookies.c: Likewise.
 	* ftp-opie.c: Likewise.
+	* gnutls.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/gnutls.c b/src/gnutls.c
index 6f40d39..57d4ad5 100644
--- a/src/gnutls.c
+++ b/src/gnutls.c
@@ -230,20 +230,20 @@ ssl_check_certificate (int fd, const char *host)
 
   if (status & GNUTLS_CERT_INVALID)
     {
-      logprintf (LOG_NOTQUIET, _("%s: The certificate of `%s' is not trusted.\n"),
-                 severity, escnonprint (host));
+      logprintf (LOG_NOTQUIET, _("%s: The certificate of %s is not trusted.\n"),
+                 severity, quote (escnonprint (host)));
       success = false;
     }
   if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
     {
-      logprintf (LOG_NOTQUIET, _("%s: The certificate of `%s' hasn't got a known issuer.\n"),
-                 severity, escnonprint (host));
+      logprintf (LOG_NOTQUIET, _("%s: The certificate of %s hasn't got a known issuer.\n"),
+                 severity, quote (escnonprint (host)));
       success = false;
     }
   if (status & GNUTLS_CERT_REVOKED)
     {
-      logprintf (LOG_NOTQUIET, _("%s: The certificate of `%s' has been revoked.\n"),
-                 severity, escnonprint (host));
+      logprintf (LOG_NOTQUIET, _("%s: The certificate of %s has been revoked.\n"),
+                 severity, quote (escnonprint (host)));
       success = false;
     }
 
-- 
cgit v1.0-41-gc330


From f468a6eb80383b22001f6b605cc38790353684aa Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:13:19 +0200
Subject: Use Gnulib's quote function in init.c.

---
 src/ChangeLog |  1 +
 src/init.c    | 54 +++++++++++++++++++++++++++---------------------------
 2 files changed, 28 insertions(+), 27 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 45aa11e..3945b84 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -7,6 +7,7 @@
 	* cookies.c: Likewise.
 	* ftp-opie.c: Likewise.
 	* gnutls.c: Likewise.
+	* init.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/init.c b/src/init.c
index e957e52..e079df9 100644
--- a/src/init.c
+++ b/src/init.c
@@ -478,8 +478,8 @@ run_wgetrc (const char *file)
           ++errcnt;
           break;
         case line_unknown_command:
-          fprintf (stderr, _("%s: Unknown command `%s' in %s at line %d.\n"),
-                   exec_name, com, file, ln);
+          fprintf (stderr, _("%s: Unknown command %s in %s at line %d.\n"),
+                   exec_name, quote (com), file, ln);
           ++errcnt;
           break;
         case line_empty:
@@ -524,8 +524,8 @@ initialize (void)
   if (!strcmp (file, SYSTEM_WGETRC))
     {
       fprintf (stderr, _("\
-%s: Warning: Both system and user wgetrc point to `%s'.\n"),
-               exec_name, file);
+%s: Warning: Both system and user wgetrc point to %s.\n"),
+               exec_name, quote (file));
     }
   else
 #endif
@@ -676,8 +676,8 @@ run_command (const char *opt)
       xfree (val);
       break;
     default:
-      fprintf (stderr, _("%s: Invalid --execute command `%s'\n"),
-               exec_name, opt);
+      fprintf (stderr, _("%s: Invalid --execute command %s\n"),
+               exec_name, quote (opt));
       exit (2);
     }
 }
@@ -721,8 +721,8 @@ cmd_boolean (const char *com, const char *val, void *place)
   else
     {
       fprintf (stderr,
-               _("%s: %s: Invalid boolean `%s'; use `on' or `off'.\n"),
-               exec_name, com, val);
+               _("%s: %s: Invalid boolean %s; use `on' or `off'.\n"),
+               exec_name, com, quote (val));
       return false;
     }
 
@@ -738,8 +738,8 @@ cmd_number (const char *com, const char *val, void *place)
   if (!simple_atoi (val, val + strlen (val), place)
       || *(int *) place < 0)
     {
-      fprintf (stderr, _("%s: %s: Invalid number `%s'.\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid number %s.\n"),
+               exec_name, com, quote (val));
       return false;
     }
   return true;
@@ -969,8 +969,8 @@ cmd_bytes (const char *com, const char *val, void *place)
   double byte_value;
   if (!parse_bytes_helper (val, &byte_value))
     {
-      fprintf (stderr, _("%s: %s: Invalid byte value `%s'\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid byte value %s\n"),
+               exec_name, com, quote (val));
       return false;
     }
   *(wgint *)place = (wgint)byte_value;
@@ -988,8 +988,8 @@ cmd_bytes_sum (const char *com, const char *val, void *place)
   double byte_value;
   if (!parse_bytes_helper (val, &byte_value))
     {
-      fprintf (stderr, _("%s: %s: Invalid byte value `%s'\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid byte value %s\n"),
+               exec_name, com, quote (val));
       return false;
     }
   *(SUM_SIZE_INT *) place = (SUM_SIZE_INT) byte_value;
@@ -1013,8 +1013,8 @@ cmd_time (const char *com, const char *val, void *place)
   if (val == end)
     {
     err:
-      fprintf (stderr, _("%s: %s: Invalid time period `%s'\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid time period %s\n"),
+               exec_name, com, quote (val));
       return false;
     }
 
@@ -1067,7 +1067,7 @@ cmd_cert_type (const char *com, const char *val, void *place)
   };
   int ok = decode_string (val, choices, countof (choices), place);
   if (!ok)
-    fprintf (stderr, _("%s: %s: Invalid value `%s'.\n"), exec_name, com, val);
+    fprintf (stderr, _("%s: %s: Invalid value %s.\n"), exec_name, com, quote (val));
   return ok;
 }
 #endif
@@ -1104,8 +1104,8 @@ cmd_spec_header (const char *com, const char *val, void *place_ignored)
 
   if (!check_user_specified_header (val))
     {
-      fprintf (stderr, _("%s: %s: Invalid header `%s'.\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid header %s.\n"),
+               exec_name, com, quote (val));
       return false;
     }
   opt.user_headers = vec_append (opt.user_headers, val);
@@ -1157,7 +1157,7 @@ cmd_spec_prefer_family (const char *com, const char *val, void *place_ignored)
   int prefer_family = prefer_ipv4;
   int ok = decode_string (val, choices, countof (choices), &prefer_family);
   if (!ok)
-    fprintf (stderr, _("%s: %s: Invalid value `%s'.\n"), exec_name, com, val);
+    fprintf (stderr, _("%s: %s: Invalid value %s.\n"), exec_name, com, quote (val));
   opt.prefer_family = prefer_family;
   return ok;
 }
@@ -1170,8 +1170,8 @@ cmd_spec_progress (const char *com, const char *val, void *place_ignored)
 {
   if (!valid_progress_implementation_p (val))
     {
-      fprintf (stderr, _("%s: %s: Invalid progress type `%s'.\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid progress type %s.\n"),
+               exec_name, com, quote (val));
       return false;
     }
   xfree_null (opt.progress_type);
@@ -1229,8 +1229,8 @@ cmd_spec_restrict_file_names (const char *com, const char *val, void *place_igno
       else
         {
           fprintf (stderr,
-                   _("%s: %s: Invalid restriction `%s', use [unix|windows],[lowercase|uppercase],[nocontrol].\n"),
-                   exec_name, com, val);
+                   _("%s: %s: Invalid restriction %s, use [unix|windows],[lowercase|uppercase],[nocontrol].\n"),
+                   exec_name, com, quote (val));
           return false;
         }
 
@@ -1260,7 +1260,7 @@ cmd_spec_secure_protocol (const char *com, const char *val, void *place)
   };
   int ok = decode_string (val, choices, countof (choices), place);
   if (!ok)
-    fprintf (stderr, _("%s: %s: Invalid value `%s'.\n"), exec_name, com, val);
+    fprintf (stderr, _("%s: %s: Invalid value %s.\n"), exec_name, com, quote (val));
   return ok;
 }
 #endif
@@ -1285,8 +1285,8 @@ cmd_spec_useragent (const char *com, const char *val, void *place_ignored)
   /* Disallow embedded newlines.  */
   if (strchr (val, '\n'))
     {
-      fprintf (stderr, _("%s: %s: Invalid value `%s'.\n"),
-               exec_name, com, val);
+      fprintf (stderr, _("%s: %s: Invalid value %s.\n"),
+               exec_name, com, quote (val));
       return false;
     }
   xfree_null (opt.useragent);
-- 
cgit v1.0-41-gc330


From b53c77dfc06f4013a6ffea3e45bbbaace231b75f Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:16:37 +0200
Subject: Use Gnulib's quote function in log.c.

---
 src/ChangeLog | 1 +
 src/log.c     | 4 ++--
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 3945b84..698fdb5 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -8,6 +8,7 @@
 	* ftp-opie.c: Likewise.
 	* gnutls.c: Likewise.
 	* init.c: Likewise.
+	* log.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/log.c b/src/log.c
index 078a7ac..f7b3dca 100644
--- a/src/log.c
+++ b/src/log.c
@@ -781,8 +781,8 @@ redirect_output (void)
   logfp = unique_create (DEFAULT_LOGFILE, false, &logfile);
   if (logfp)
     {
-      fprintf (stderr, _("\n%s received, redirecting output to `%s'.\n"),
-               redirect_request_signal_name, logfile);
+      fprintf (stderr, _("\n%s received, redirecting output to %s.\n"),
+               redirect_request_signal_name, quote (logfile));
       xfree (logfile);
       /* Dump the context output to the newly opened log.  */
       log_dump_context ();
-- 
cgit v1.0-41-gc330


From 4a465612b3082f22f5eca1721639463d283a1ced Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:20:06 +0200
Subject: Use Gnulib's quote function in mswindows.c.

---
 src/ChangeLog   | 1 +
 src/mswindows.c | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 698fdb5..7292f47 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -9,6 +9,7 @@
 	* gnutls.c: Likewise.
 	* init.c: Likewise.
 	* log.c: Likewise.
+	* mswindows.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/mswindows.c b/src/mswindows.c
index 2a14696..cdfea2d 100644
--- a/src/mswindows.c
+++ b/src/mswindows.c
@@ -291,7 +291,7 @@ fake_fork (void)
 
   printf (_("Continuing in background, pid %lu.\n"), pi.dwProcessId);
   if (info->logfile_changed)
-    printf (_("Output will be written to `%s'.\n"), info->lfilename);
+    printf (_("Output will be written to %s.\n"), quote (info->lfilename));
 
   UnmapViewOfFile (info);
 
-- 
cgit v1.0-41-gc330


From 29b8cb566171fc9f062838543bc270ace267fa18 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:23:31 +0200
Subject: Use Gnulib's quote function in openssl.c.

---
 src/ChangeLog | 1 +
 src/openssl.c | 8 ++++----
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 7292f47..f2ab88e 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -10,6 +10,7 @@
 	* init.c: Likewise.
 	* log.c: Likewise.
 	* mswindows.c: Likewise.
+	* openssl.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/openssl.c b/src/openssl.c
index c33b4ad..03fb181 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -515,8 +515,8 @@ ssl_check_certificate (int fd, const char *host)
     {
       char *issuer = X509_NAME_oneline (X509_get_issuer_name (cert), 0, 0);
       logprintf (LOG_NOTQUIET,
-                 _("%s: cannot verify %s's certificate, issued by `%s':\n"),
-                 severity, escnonprint (host), escnonprint (issuer));
+                 _("%s: cannot verify %s's certificate, issued by %s:\n"),
+                 severity, escnonprint (host), quote (escnonprint (issuer)));
       /* Try to print more user-friendly (and translated) messages for
          the frequent verification errors.  */
       switch (vresult)
@@ -566,8 +566,8 @@ ssl_check_certificate (int fd, const char *host)
   if (!pattern_match (common_name, host))
     {
       logprintf (LOG_NOTQUIET, _("\
-%s: certificate common name `%s' doesn't match requested host name `%s'.\n"),
-                 severity, escnonprint (common_name), escnonprint (host));
+%s: certificate common name %s doesn't match requested host name %s.\n"),
+                 severity, quote (escnonprint (common_name)), quote (escnonprint (host)));
       success = false;
     }
 
-- 
cgit v1.0-41-gc330


From 9d519d49f0fe3f0049c60f867de9a198f07f57f9 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:25:45 +0200
Subject: Use Gnulib's quote function in progress.c.

---
 src/ChangeLog  | 1 +
 src/progress.c | 4 ++--
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index f2ab88e..a1d6465 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -11,6 +11,7 @@
 	* log.c: Likewise.
 	* mswindows.c: Likewise.
 	* openssl.c: Likewise.
+	* progress.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/progress.c b/src/progress.c
index 9ea74b0..8b9b101 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -453,8 +453,8 @@ dot_set_params (const char *params)
     }
   else
     fprintf (stderr,
-             _("Invalid dot style specification `%s'; leaving unchanged.\n"),
-             params);
+             _("Invalid dot style specification %s; leaving unchanged.\n"),
+             quote (params));
 }
 
 /* "Thermometer" (bar) progress. */
-- 
cgit v1.0-41-gc330


From 87f85de75befc0914039d2d03adbd8df1077411a Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:28:19 +0200
Subject: Use Gnulib's quote function in recur.c.

---
 src/ChangeLog | 1 +
 src/recur.c   | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index a1d6465..8d9b6ac 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -12,6 +12,7 @@
 	* mswindows.c: Likewise.
 	* openssl.c: Likewise.
 	* progress.c: Likewise.
+	* recur.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/recur.c b/src/recur.c
index c11cfda..d1d0f18 100644
--- a/src/recur.c
+++ b/src/recur.c
@@ -439,7 +439,7 @@ download_child_p (const struct urlpos *upos, struct url *parent, int depth,
       if (opt.spider) 
         {
           char *referrer = url_string (parent, URL_AUTH_HIDE_PASSWD);
-          DEBUGP (("download_child_p: parent->url is: `%s'\n", parent->url));
+          DEBUGP (("download_child_p: parent->url is: %s\n", quote (parent->url)));
           visited_url (url, referrer);
           xfree (referrer);
         }
-- 
cgit v1.0-41-gc330


From a358b3b69a4c4c1d311366d2205b9a69d414d49a Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:31:17 +0200
Subject: Use Gnulib's quote function in res.c.

---
 src/ChangeLog | 1 +
 src/res.c     | 4 ++--
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 8d9b6ac..5be9647 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -13,6 +13,7 @@
 	* openssl.c: Likewise.
 	* progress.c: Likewise.
 	* recur.c: Likewise.
+	* res.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/res.c b/src/res.c
index 0be3f76..8c35f0e 100644
--- a/src/res.c
+++ b/src/res.c
@@ -463,9 +463,9 @@ res_match_path (const struct robot_specs *specs, const char *path)
     if (matches (specs->paths[i].path, path))
       {
         bool allowedp = specs->paths[i].allowedp;
-        DEBUGP (("%s path %s because of rule `%s'.\n",
+        DEBUGP (("%s path %s because of rule %s.\n",
                  allowedp ? "Allowing" : "Rejecting",
-                 path, specs->paths[i].path));
+                 path, quote (specs->paths[i].path)));
         return allowedp;
       }
   return true;
-- 
cgit v1.0-41-gc330


From 3e34be1c4b963ac120e3758c12a0317c5364fc16 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Wed, 16 Apr 2008 12:35:03 +0200
Subject: Use Gnulib's quote function in utils.c.

---
 src/ChangeLog | 1 +
 src/utils.c   | 6 +++---
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 5be9647..8bdd95c 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -14,6 +14,7 @@
 	* progress.c: Likewise.
 	* recur.c: Likewise.
 	* res.c: Likewise.
+	* utils.c: Likewise.
 
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
diff --git a/src/utils.c b/src/utils.c
index a4928da..f3b4a60 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -348,7 +348,7 @@ fork_to_background (void)
       /* parent, no error */
       printf (_("Continuing in background, pid %d.\n"), (int) pid);
       if (logfile_changed)
-        printf (_("Output will be written to `%s'.\n"), opt.lfilename);
+        printf (_("Output will be written to %s.\n"), quote (opt.lfilename));
       exit (0);                 /* #### should we use _exit()? */
     }
 
@@ -394,8 +394,8 @@ remove_link (const char *file)
       DEBUGP (("Unlinking %s (symlink).\n", file));
       err = unlink (file);
       if (err != 0)
-        logprintf (LOG_VERBOSE, _("Failed to unlink symlink `%s': %s\n"),
-                   file, strerror (errno));
+        logprintf (LOG_VERBOSE, _("Failed to unlink symlink %s: %s\n"),
+                   quote (file), strerror (errno));
     }
   return err;
 }
-- 
cgit v1.0-41-gc330


From 8aefedc7daa02d2035c521e559add2a3a74ab3b7 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Thu, 17 Apr 2008 00:35:34 +0200
Subject: Use Gnulib's xalloc module in convert.c (and include according
 header).

---
 src/convert.c | 28 +++++++++++++++-------------
 src/wget.h    |  6 +++++-
 2 files changed, 20 insertions(+), 14 deletions(-)

diff --git a/src/convert.c b/src/convert.c
index 69d713f..bf65f53 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
@@ -87,7 +89,7 @@ convert_all_links (void)
     cnt = hash_table_count (downloaded_html_set);
   if (cnt == 0)
     goto cleanup;
-  file_array = alloca_array (char *, cnt);
+  file_array = xcalloc (cnt, sizeof (char *));
   string_set_to_array (downloaded_html_set, file_array);
 
   for (i = 0; i < cnt; i++)
@@ -285,8 +287,8 @@ convert_links (const char *file, struct urlpos *links)
 
             DEBUGP (("TO_RELATIVE: %s to %s at position %d in %s.\n",
                      link->url->url, newname, link->pos, file));
-            xfree (newname);
-            xfree (quoted_newname);
+            free (newname);
+            free (quoted_newname);
             ++to_file_count;
             break;
           }
@@ -304,7 +306,7 @@ convert_links (const char *file, struct urlpos *links)
 
             DEBUGP (("TO_COMPLETE: <something> to %s at position %d in %s.\n",
                      newlink, link->pos, file));
-            xfree (quoted_newlink);
+            free (quoted_newlink);
             ++to_url_count;
             break;
           }
@@ -688,8 +690,8 @@ dissociate_urls_from_file_mapper (void *key, void *value, void *arg)
   if (0 == strcmp (mapping_file, file))
     {
       hash_table_remove (dl_url_file_map, mapping_url);
-      xfree (mapping_url);
-      xfree (mapping_file);
+      free (mapping_url);
+      free (mapping_file);
     }
 
   /* Continue mapping. */
@@ -739,8 +741,8 @@ register_download (const char *url, const char *file)
         goto url_only;
 
       hash_table_remove (dl_file_url_map, file);
-      xfree (old_file);
-      xfree (old_url);
+      free (old_file);
+      free (old_url);
 
       /* Remove all the URLs that point to this file.  Yes, there can
          be more than one such URL, because we store redirections as
@@ -780,8 +782,8 @@ register_download (const char *url, const char *file)
   if (hash_table_get_pair (dl_url_file_map, url, &old_url, &old_file))
     {
       hash_table_remove (dl_url_file_map, url);
-      xfree (old_url);
-      xfree (old_file);
+      free (old_url);
+      free (old_file);
     }
 
   hash_table_put (dl_url_file_map, xstrdup (url), xstrdup (file));
@@ -817,8 +819,8 @@ register_delete_file (const char *file)
     return;
 
   hash_table_remove (dl_file_url_map, file);
-  xfree (old_file);
-  xfree (old_url);
+  free (old_file);
+  free (old_url);
   dissociate_urls_from_file (file);
 }
 
@@ -948,7 +950,7 @@ downloaded_files_free (void)
       for (hash_table_iterate (downloaded_files_hash, &iter);
            hash_table_iter_next (&iter);
            )
-        xfree (iter.key);
+        free (iter.key);
       hash_table_destroy (downloaded_files_hash);
       downloaded_files_hash = NULL;
     }
diff --git a/src/wget.h b/src/wget.h
index d8ab0c9..409c71c 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -208,7 +208,11 @@ typedef double SUM_SIZE_INT;
 #include "options.h"
 
 /* Everything uses this, so include them here directly.  */
-#include "xmalloc.h"
+#ifdef USE_GNULIB_ALLOC
+# include "xalloc.h"
+#else
+# include "xmalloc.h"
+#endif
 
 /* Likewise for logging functions.  */
 #include "log.h"
-- 
cgit v1.0-41-gc330


From d9131151afa99a50a994e6d6b7268be8f6d4540a Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 18 Apr 2008 20:11:06 +0200
Subject: Revert the alloca_array() -> xcalloc() transition.

---
 src/convert.c | 28 +++++++++++++---------------
 src/wget.h    |  6 +-----
 2 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/src/convert.c b/src/convert.c
index bf65f53..69d713f 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
@@ -89,7 +87,7 @@ convert_all_links (void)
     cnt = hash_table_count (downloaded_html_set);
   if (cnt == 0)
     goto cleanup;
-  file_array = xcalloc (cnt, sizeof (char *));
+  file_array = alloca_array (char *, cnt);
   string_set_to_array (downloaded_html_set, file_array);
 
   for (i = 0; i < cnt; i++)
@@ -287,8 +285,8 @@ convert_links (const char *file, struct urlpos *links)
 
             DEBUGP (("TO_RELATIVE: %s to %s at position %d in %s.\n",
                      link->url->url, newname, link->pos, file));
-            free (newname);
-            free (quoted_newname);
+            xfree (newname);
+            xfree (quoted_newname);
             ++to_file_count;
             break;
           }
@@ -306,7 +304,7 @@ convert_links (const char *file, struct urlpos *links)
 
             DEBUGP (("TO_COMPLETE: <something> to %s at position %d in %s.\n",
                      newlink, link->pos, file));
-            free (quoted_newlink);
+            xfree (quoted_newlink);
             ++to_url_count;
             break;
           }
@@ -690,8 +688,8 @@ dissociate_urls_from_file_mapper (void *key, void *value, void *arg)
   if (0 == strcmp (mapping_file, file))
     {
       hash_table_remove (dl_url_file_map, mapping_url);
-      free (mapping_url);
-      free (mapping_file);
+      xfree (mapping_url);
+      xfree (mapping_file);
     }
 
   /* Continue mapping. */
@@ -741,8 +739,8 @@ register_download (const char *url, const char *file)
         goto url_only;
 
       hash_table_remove (dl_file_url_map, file);
-      free (old_file);
-      free (old_url);
+      xfree (old_file);
+      xfree (old_url);
 
       /* Remove all the URLs that point to this file.  Yes, there can
          be more than one such URL, because we store redirections as
@@ -782,8 +780,8 @@ register_download (const char *url, const char *file)
   if (hash_table_get_pair (dl_url_file_map, url, &old_url, &old_file))
     {
       hash_table_remove (dl_url_file_map, url);
-      free (old_url);
-      free (old_file);
+      xfree (old_url);
+      xfree (old_file);
     }
 
   hash_table_put (dl_url_file_map, xstrdup (url), xstrdup (file));
@@ -819,8 +817,8 @@ register_delete_file (const char *file)
     return;
 
   hash_table_remove (dl_file_url_map, file);
-  free (old_file);
-  free (old_url);
+  xfree (old_file);
+  xfree (old_url);
   dissociate_urls_from_file (file);
 }
 
@@ -950,7 +948,7 @@ downloaded_files_free (void)
       for (hash_table_iterate (downloaded_files_hash, &iter);
            hash_table_iter_next (&iter);
            )
-        free (iter.key);
+        xfree (iter.key);
       hash_table_destroy (downloaded_files_hash);
       downloaded_files_hash = NULL;
     }
diff --git a/src/wget.h b/src/wget.h
index 409c71c..d8ab0c9 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -208,11 +208,7 @@ typedef double SUM_SIZE_INT;
 #include "options.h"
 
 /* Everything uses this, so include them here directly.  */
-#ifdef USE_GNULIB_ALLOC
-# include "xalloc.h"
-#else
-# include "xmalloc.h"
-#endif
+#include "xmalloc.h"
 
 /* Likewise for logging functions.  */
 #include "log.h"
-- 
cgit v1.0-41-gc330


From 53ba46d62850c65545ef85102be9fa91b3888238 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 18 Apr 2008 21:12:43 +0200
Subject: Import Gnulib's alloca module.

---
 lib/Makefile.am     |  30 +++-
 lib/alloca.c        | 489 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/alloca.in.h     |  56 ++++++
 lib/wchar.in.h      |   4 +-
 m4/alloca.m4        |  46 +++++
 m4/gnulib-cache.m4  |   4 +-
 m4/gnulib-common.m4 |  23 ++-
 m4/gnulib-comp.m4   |   6 +
 8 files changed, 651 insertions(+), 7 deletions(-)
 create mode 100644 lib/alloca.c
 create mode 100644 lib/alloca.in.h
 create mode 100644 m4/alloca.m4

diff --git a/lib/Makefile.am b/lib/Makefile.am
index f7381d8..4e1c276 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -9,7 +9,7 @@
 # the same distribution terms as the rest of that program.
 #
 # Generated by gnulib-tool.
-# Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl c-ctype getopt maintainer-makefile quote
+# Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl alloca c-ctype getopt maintainer-makefile quote
 
 AUTOMAKE_OPTIONS = 1.5 gnits
 
@@ -34,6 +34,34 @@ libgnu_a_LIBADD = $(gl_LIBOBJS)
 libgnu_a_DEPENDENCIES = $(gl_LIBOBJS)
 EXTRA_libgnu_a_SOURCES =
 
+## begin gnulib module alloca
+
+
+EXTRA_DIST += alloca.c
+
+EXTRA_libgnu_a_SOURCES += alloca.c
+
+libgnu_a_LIBADD += @ALLOCA@
+libgnu_a_DEPENDENCIES += @ALLOCA@
+## end   gnulib module alloca
+
+## begin gnulib module alloca-opt
+
+BUILT_SOURCES += $(ALLOCA_H)
+
+# We need the following in order to create <alloca.h> when the system
+# doesn't have one that works with the given compiler.
+alloca.h: alloca.in.h
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/alloca.in.h; \
+	} > $@-t
+	mv -f $@-t $@
+MOSTLYCLEANFILES += alloca.h alloca.h-t
+
+EXTRA_DIST += alloca.in.h
+
+## end   gnulib module alloca-opt
+
 ## begin gnulib module c-ctype
 
 libgnu_a_SOURCES += c-ctype.h c-ctype.c
diff --git a/lib/alloca.c b/lib/alloca.c
new file mode 100644
index 0000000..ff1cb7e
--- /dev/null
+++ b/lib/alloca.c
@@ -0,0 +1,489 @@
+/* alloca.c -- allocate automatically reclaimed memory
+   (Mostly) portable public-domain implementation -- D A Gwyn
+
+   This implementation of the PWB library alloca function,
+   which is used to allocate space off the run-time stack so
+   that it is automatically reclaimed upon procedure exit,
+   was inspired by discussions with J. Q. Johnson of Cornell.
+   J.Otto Tennant <jot@cray.com> contributed the Cray support.
+
+   There are some preprocessor constants that can
+   be defined when compiling for your specific system, for
+   improved efficiency; however, the defaults should be okay.
+
+   The general concept of this implementation is to keep
+   track of all alloca-allocated blocks, and reclaim any
+   that are found to be deeper in the stack than the current
+   invocation.  This heuristic does not reclaim storage as
+   soon as it becomes invalid, but it will do so eventually.
+
+   As a special case, alloca(0) reclaims storage without
+   allocating any.  It is a good idea to use alloca(0) in
+   your main control loop, etc. to force garbage collection.  */
+
+#include <config.h>
+
+#include <alloca.h>
+
+#include <string.h>
+#include <stdlib.h>
+
+#ifdef emacs
+# include "lisp.h"
+# include "blockinput.h"
+# ifdef EMACS_FREE
+#  undef free
+#  define free EMACS_FREE
+# endif
+#else
+# define memory_full() abort ()
+#endif
+
+/* If compiling with GCC 2, this file's not needed.  */
+#if !defined (__GNUC__) || __GNUC__ < 2
+
+/* If someone has defined alloca as a macro,
+   there must be some other way alloca is supposed to work.  */
+# ifndef alloca
+
+#  ifdef emacs
+#   ifdef static
+/* actually, only want this if static is defined as ""
+   -- this is for usg, in which emacs must undefine static
+   in order to make unexec workable
+   */
+#    ifndef STACK_DIRECTION
+you
+lose
+-- must know STACK_DIRECTION at compile-time
+/* Using #error here is not wise since this file should work for
+   old and obscure compilers.  */
+#    endif /* STACK_DIRECTION undefined */
+#   endif /* static */
+#  endif /* emacs */
+
+/* If your stack is a linked list of frames, you have to
+   provide an "address metric" ADDRESS_FUNCTION macro.  */
+
+#  if defined (CRAY) && defined (CRAY_STACKSEG_END)
+long i00afunc ();
+#   define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
+#  else
+#   define ADDRESS_FUNCTION(arg) &(arg)
+#  endif
+
+/* Define STACK_DIRECTION if you know the direction of stack
+   growth for your system; otherwise it will be automatically
+   deduced at run-time.
+
+   STACK_DIRECTION > 0 => grows toward higher addresses
+   STACK_DIRECTION < 0 => grows toward lower addresses
+   STACK_DIRECTION = 0 => direction of growth unknown  */
+
+#  ifndef STACK_DIRECTION
+#   define STACK_DIRECTION	0	/* Direction unknown.  */
+#  endif
+
+#  if STACK_DIRECTION != 0
+
+#   define STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */
+
+#  else /* STACK_DIRECTION == 0; need run-time code.  */
+
+static int stack_dir;		/* 1 or -1 once known.  */
+#   define STACK_DIR	stack_dir
+
+static void
+find_stack_direction (void)
+{
+  static char *addr = NULL;	/* Address of first `dummy', once known.  */
+  auto char dummy;		/* To get stack address.  */
+
+  if (addr == NULL)
+    {				/* Initial entry.  */
+      addr = ADDRESS_FUNCTION (dummy);
+
+      find_stack_direction ();	/* Recurse once.  */
+    }
+  else
+    {
+      /* Second entry.  */
+      if (ADDRESS_FUNCTION (dummy) > addr)
+	stack_dir = 1;		/* Stack grew upward.  */
+      else
+	stack_dir = -1;		/* Stack grew downward.  */
+    }
+}
+
+#  endif /* STACK_DIRECTION == 0 */
+
+/* An "alloca header" is used to:
+   (a) chain together all alloca'ed blocks;
+   (b) keep track of stack depth.
+
+   It is very important that sizeof(header) agree with malloc
+   alignment chunk size.  The following default should work okay.  */
+
+#  ifndef	ALIGN_SIZE
+#   define ALIGN_SIZE	sizeof(double)
+#  endif
+
+typedef union hdr
+{
+  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
+  struct
+    {
+      union hdr *next;		/* For chaining headers.  */
+      char *deep;		/* For stack depth measure.  */
+    } h;
+} header;
+
+static header *last_alloca_header = NULL;	/* -> last alloca header.  */
+
+/* Return a pointer to at least SIZE bytes of storage,
+   which will be automatically reclaimed upon exit from
+   the procedure that called alloca.  Originally, this space
+   was supposed to be taken from the current stack frame of the
+   caller, but that method cannot be made to work for some
+   implementations of C, for example under Gould's UTX/32.  */
+
+void *
+alloca (size_t size)
+{
+  auto char probe;		/* Probes stack depth: */
+  register char *depth = ADDRESS_FUNCTION (probe);
+
+#  if STACK_DIRECTION == 0
+  if (STACK_DIR == 0)		/* Unknown growth direction.  */
+    find_stack_direction ();
+#  endif
+
+  /* Reclaim garbage, defined as all alloca'd storage that
+     was allocated from deeper in the stack than currently.  */
+
+  {
+    register header *hp;	/* Traverses linked list.  */
+
+#  ifdef emacs
+    BLOCK_INPUT;
+#  endif
+
+    for (hp = last_alloca_header; hp != NULL;)
+      if ((STACK_DIR > 0 && hp->h.deep > depth)
+	  || (STACK_DIR < 0 && hp->h.deep < depth))
+	{
+	  register header *np = hp->h.next;
+
+	  free (hp);		/* Collect garbage.  */
+
+	  hp = np;		/* -> next header.  */
+	}
+      else
+	break;			/* Rest are not deeper.  */
+
+    last_alloca_header = hp;	/* -> last valid storage.  */
+
+#  ifdef emacs
+    UNBLOCK_INPUT;
+#  endif
+  }
+
+  if (size == 0)
+    return NULL;		/* No allocation required.  */
+
+  /* Allocate combined header + user data storage.  */
+
+  {
+    /* Address of header.  */
+    register header *new;
+
+    size_t combined_size = sizeof (header) + size;
+    if (combined_size < sizeof (header))
+      memory_full ();
+
+    new = malloc (combined_size);
+
+    if (! new)
+      memory_full ();
+
+    new->h.next = last_alloca_header;
+    new->h.deep = depth;
+
+    last_alloca_header = new;
+
+    /* User storage begins just after header.  */
+
+    return (void *) (new + 1);
+  }
+}
+
+#  if defined (CRAY) && defined (CRAY_STACKSEG_END)
+
+#   ifdef DEBUG_I00AFUNC
+#    include <stdio.h>
+#   endif
+
+#   ifndef CRAY_STACK
+#    define CRAY_STACK
+#    ifndef CRAY2
+/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
+struct stack_control_header
+  {
+    long shgrow:32;		/* Number of times stack has grown.  */
+    long shaseg:32;		/* Size of increments to stack.  */
+    long shhwm:32;		/* High water mark of stack.  */
+    long shsize:32;		/* Current size of stack (all segments).  */
+  };
+
+/* The stack segment linkage control information occurs at
+   the high-address end of a stack segment.  (The stack
+   grows from low addresses to high addresses.)  The initial
+   part of the stack segment linkage control information is
+   0200 (octal) words.  This provides for register storage
+   for the routine which overflows the stack.  */
+
+struct stack_segment_linkage
+  {
+    long ss[0200];		/* 0200 overflow words.  */
+    long sssize:32;		/* Number of words in this segment.  */
+    long ssbase:32;		/* Offset to stack base.  */
+    long:32;
+    long sspseg:32;		/* Offset to linkage control of previous
+				   segment of stack.  */
+    long:32;
+    long sstcpt:32;		/* Pointer to task common address block.  */
+    long sscsnm;		/* Private control structure number for
+				   microtasking.  */
+    long ssusr1;		/* Reserved for user.  */
+    long ssusr2;		/* Reserved for user.  */
+    long sstpid;		/* Process ID for pid based multi-tasking.  */
+    long ssgvup;		/* Pointer to multitasking thread giveup.  */
+    long sscray[7];		/* Reserved for Cray Research.  */
+    long ssa0;
+    long ssa1;
+    long ssa2;
+    long ssa3;
+    long ssa4;
+    long ssa5;
+    long ssa6;
+    long ssa7;
+    long sss0;
+    long sss1;
+    long sss2;
+    long sss3;
+    long sss4;
+    long sss5;
+    long sss6;
+    long sss7;
+  };
+
+#    else /* CRAY2 */
+/* The following structure defines the vector of words
+   returned by the STKSTAT library routine.  */
+struct stk_stat
+  {
+    long now;			/* Current total stack size.  */
+    long maxc;			/* Amount of contiguous space which would
+				   be required to satisfy the maximum
+				   stack demand to date.  */
+    long high_water;		/* Stack high-water mark.  */
+    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
+    long hits;			/* Number of internal buffer hits.  */
+    long extends;		/* Number of block extensions.  */
+    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
+    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
+    long stko_free;		/* Number of deallocations by $STKRETN.  */
+    long stkm_free;		/* Number of deallocations by $STKMRET.  */
+    long segments;		/* Current number of stack segments.  */
+    long maxs;			/* Maximum number of stack segments so far.  */
+    long pad_size;		/* Stack pad size.  */
+    long current_address;	/* Current stack segment address.  */
+    long current_size;		/* Current stack segment size.  This
+				   number is actually corrupted by STKSTAT to
+				   include the fifteen word trailer area.  */
+    long initial_address;	/* Address of initial segment.  */
+    long initial_size;		/* Size of initial segment.  */
+  };
+
+/* The following structure describes the data structure which trails
+   any stack segment.  I think that the description in 'asdef' is
+   out of date.  I only describe the parts that I am sure about.  */
+
+struct stk_trailer
+  {
+    long this_address;		/* Address of this block.  */
+    long this_size;		/* Size of this block (does not include
+				   this trailer).  */
+    long unknown2;
+    long unknown3;
+    long link;			/* Address of trailer block of previous
+				   segment.  */
+    long unknown5;
+    long unknown6;
+    long unknown7;
+    long unknown8;
+    long unknown9;
+    long unknown10;
+    long unknown11;
+    long unknown12;
+    long unknown13;
+    long unknown14;
+  };
+
+#    endif /* CRAY2 */
+#   endif /* not CRAY_STACK */
+
+#   ifdef CRAY2
+/* Determine a "stack measure" for an arbitrary ADDRESS.
+   I doubt that "lint" will like this much.  */
+
+static long
+i00afunc (long *address)
+{
+  struct stk_stat status;
+  struct stk_trailer *trailer;
+  long *block, size;
+  long result = 0;
+
+  /* We want to iterate through all of the segments.  The first
+     step is to get the stack status structure.  We could do this
+     more quickly and more directly, perhaps, by referencing the
+     $LM00 common block, but I know that this works.  */
+
+  STKSTAT (&status);
+
+  /* Set up the iteration.  */
+
+  trailer = (struct stk_trailer *) (status.current_address
+				    + status.current_size
+				    - 15);
+
+  /* There must be at least one stack segment.  Therefore it is
+     a fatal error if "trailer" is null.  */
+
+  if (trailer == 0)
+    abort ();
+
+  /* Discard segments that do not contain our argument address.  */
+
+  while (trailer != 0)
+    {
+      block = (long *) trailer->this_address;
+      size = trailer->this_size;
+      if (block == 0 || size == 0)
+	abort ();
+      trailer = (struct stk_trailer *) trailer->link;
+      if ((block <= address) && (address < (block + size)))
+	break;
+    }
+
+  /* Set the result to the offset in this segment and add the sizes
+     of all predecessor segments.  */
+
+  result = address - block;
+
+  if (trailer == 0)
+    {
+      return result;
+    }
+
+  do
+    {
+      if (trailer->this_size <= 0)
+	abort ();
+      result += trailer->this_size;
+      trailer = (struct stk_trailer *) trailer->link;
+    }
+  while (trailer != 0);
+
+  /* We are done.  Note that if you present a bogus address (one
+     not in any segment), you will get a different number back, formed
+     from subtracting the address of the first block.  This is probably
+     not what you want.  */
+
+  return (result);
+}
+
+#   else /* not CRAY2 */
+/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
+   Determine the number of the cell within the stack,
+   given the address of the cell.  The purpose of this
+   routine is to linearize, in some sense, stack addresses
+   for alloca.  */
+
+static long
+i00afunc (long address)
+{
+  long stkl = 0;
+
+  long size, pseg, this_segment, stack;
+  long result = 0;
+
+  struct stack_segment_linkage *ssptr;
+
+  /* Register B67 contains the address of the end of the
+     current stack segment.  If you (as a subprogram) store
+     your registers on the stack and find that you are past
+     the contents of B67, you have overflowed the segment.
+
+     B67 also points to the stack segment linkage control
+     area, which is what we are really interested in.  */
+
+  stkl = CRAY_STACKSEG_END ();
+  ssptr = (struct stack_segment_linkage *) stkl;
+
+  /* If one subtracts 'size' from the end of the segment,
+     one has the address of the first word of the segment.
+
+     If this is not the first segment, 'pseg' will be
+     nonzero.  */
+
+  pseg = ssptr->sspseg;
+  size = ssptr->sssize;
+
+  this_segment = stkl - size;
+
+  /* It is possible that calling this routine itself caused
+     a stack overflow.  Discard stack segments which do not
+     contain the target address.  */
+
+  while (!(this_segment <= address && address <= stkl))
+    {
+#    ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
+#    endif
+      if (pseg == 0)
+	break;
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      this_segment = stkl - size;
+    }
+
+  result = address - this_segment;
+
+  /* If you subtract pseg from the current end of the stack,
+     you get the address of the previous stack segment's end.
+     This seems a little convoluted to me, but I'll bet you save
+     a cycle somewhere.  */
+
+  while (pseg != 0)
+    {
+#    ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o\n", pseg, size);
+#    endif
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      result += size;
+    }
+  return (result);
+}
+
+#   endif /* not CRAY2 */
+#  endif /* CRAY */
+
+# endif /* no alloca */
+#endif /* not GCC version 3 */
diff --git a/lib/alloca.in.h b/lib/alloca.in.h
new file mode 100644
index 0000000..6269607
--- /dev/null
+++ b/lib/alloca.in.h
@@ -0,0 +1,56 @@
+/* Memory allocation on the stack.
+
+   Copyright (C) 1995, 1999, 2001-2004, 2006-2008 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+   USA.  */
+
+/* Avoid using the symbol _ALLOCA_H here, as Bison assumes _ALLOCA_H
+   means there is a real alloca function.  */
+#ifndef _GL_ALLOCA_H
+#define _GL_ALLOCA_H
+
+/* alloca (N) returns a pointer to N bytes of memory
+   allocated on the stack, which will last until the function returns.
+   Use of alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns,
+     - for huge N (say, N >= 65536) - you never know how large (or small)
+       the stack is, and when the stack cannot fulfill the memory allocation
+       request, the program just crashes.
+ */
+
+#ifndef alloca
+# ifdef __GNUC__
+#  define alloca __builtin_alloca
+# elif defined _AIX
+#  define alloca __alloca
+# elif defined _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# elif defined __DECC && defined __VMS
+#  define alloca __ALLOCA
+# else
+#  include <stddef.h>
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *alloca (size_t);
+# endif
+#endif
+
+#endif /* _GL_ALLOCA_H */
diff --git a/lib/wchar.in.h b/lib/wchar.in.h
index 8dfead2..f796167 100644
--- a/lib/wchar.in.h
+++ b/lib/wchar.in.h
@@ -1,6 +1,6 @@
 /* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
 
-   Copyright (C) 2007 Free Software Foundation, Inc.
+   Copyright (C) 2007-2008 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -27,7 +27,7 @@
  */
 
 #ifdef __need_mbstate_t
-/* Special invocation convention inside glibc header files.  */
+/* Special invocation convention inside uClibc header files.  */
 
 #@INCLUDE_NEXT@ @NEXT_WCHAR_H@
 
diff --git a/m4/alloca.m4 b/m4/alloca.m4
new file mode 100644
index 0000000..95f54a6
--- /dev/null
+++ b/m4/alloca.m4
@@ -0,0 +1,46 @@
+# alloca.m4 serial 8
+dnl Copyright (C) 2002-2004, 2006, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_ALLOCA],
+[
+  dnl Work around a bug of AC_EGREP_CPP in autoconf-2.57.
+  AC_REQUIRE([AC_PROG_CPP])
+  AC_REQUIRE([AC_PROG_EGREP])
+
+  AC_REQUIRE([AC_FUNC_ALLOCA])
+  if test $ac_cv_func_alloca_works = no; then
+    gl_PREREQ_ALLOCA
+  fi
+
+  # Define an additional variable used in the Makefile substitution.
+  if test $ac_cv_working_alloca_h = yes; then
+    AC_CACHE_CHECK([for alloca as a compiler built-in], [gl_cv_rpl_alloca], [
+      AC_EGREP_CPP([Need own alloca], [
+#if defined __GNUC__ || defined _AIX || defined _MSC_VER
+        Need own alloca
+#endif
+        ], [gl_cv_rpl_alloca=yes], [gl_cv_rpl_alloca=no])
+    ])
+    if test $gl_cv_rpl_alloca = yes; then
+      dnl OK, alloca can be implemented through a compiler built-in.
+      AC_DEFINE([HAVE_ALLOCA], 1,
+        [Define to 1 if you have 'alloca' after including <alloca.h>,
+         a header that may be supplied by this distribution.])
+      ALLOCA_H=alloca.h
+    else
+      dnl alloca exists as a library function, i.e. it is slow and probably
+      dnl a memory leak. Don't define HAVE_ALLOCA in this case.
+      ALLOCA_H=
+    fi
+  else
+    ALLOCA_H=alloca.h
+  fi
+  AC_SUBST([ALLOCA_H])
+])
+
+# Prerequisites of lib/alloca.c.
+# STACK_DIRECTION is already handled by AC_FUNC_ALLOCA.
+AC_DEFUN([gl_PREREQ_ALLOCA], [:])
diff --git a/m4/gnulib-cache.m4 b/m4/gnulib-cache.m4
index 7e17421..540607b 100644
--- a/m4/gnulib-cache.m4
+++ b/m4/gnulib-cache.m4
@@ -15,11 +15,11 @@
 
 
 # Specification in the form of a command-line invocation:
-#   gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl c-ctype getopt maintainer-makefile quote
+#   gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --no-libtool --macro-prefix=gl alloca c-ctype getopt maintainer-makefile quote
 
 # Specification in the form of a few gnulib-tool.m4 macro invocations:
 gl_LOCAL_DIR([])
-gl_MODULES([c-ctype getopt maintainer-makefile quote])
+gl_MODULES([alloca c-ctype getopt maintainer-makefile quote])
 gl_AVOID([])
 gl_SOURCE_BASE([lib])
 gl_M4_BASE([m4])
diff --git a/m4/gnulib-common.m4 b/m4/gnulib-common.m4
index 9336d72..3edfc12 100644
--- a/m4/gnulib-common.m4
+++ b/m4/gnulib-common.m4
@@ -1,9 +1,28 @@
-# gnulib-common.m4 serial 3
-dnl Copyright (C) 2007 Free Software Foundation, Inc.
+# gnulib-common.m4 serial 4
+dnl Copyright (C) 2007-2008 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
 
+# gl_COMMON
+# is expanded unconditionally through gnulib-tool magic.
+AC_DEFUN([gl_COMMON], [
+  dnl Use AC_REQUIRE here, so that the code is expanded once only.
+  AC_REQUIRE([gl_COMMON_BODY])
+])
+AC_DEFUN([gl_COMMON_BODY], [
+  AH_VERBATIM([isoc99_inline],
+[/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
+   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
+   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
+   __APPLE__ && __MACH__ test for MacOS X.
+   __APPLE_CC__ tests for the Apple compiler and its version.
+   __STDC_VERSION__ tests for the C99 mode.  */
+#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
+# define __GNUC_STDC_INLINE__ 1
+#endif])
+])
+
 # gl_MODULE_INDICATOR([modulename])
 # defines a C macro indicating the presence of the given module.
 AC_DEFUN([gl_MODULE_INDICATOR],
diff --git a/m4/gnulib-comp.m4 b/m4/gnulib-comp.m4
index 47ce7dc..7ea55d9 100644
--- a/m4/gnulib-comp.m4
+++ b/m4/gnulib-comp.m4
@@ -39,7 +39,9 @@ AC_DEFUN([gl_INIT],
   m4_pushdef([AC_LIBOBJ], m4_defn([gl_LIBOBJ]))
   m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gl_REPLACE_FUNCS]))
   m4_pushdef([AC_LIBSOURCES], m4_defn([gl_LIBSOURCES]))
+  gl_COMMON
   gl_source_base='lib'
+  gl_FUNC_ALLOCA
   gl_ERROR
   m4_ifdef([AM_XGETTEXT_OPTION],
     [AM_XGETTEXT_OPTION([--flag=error:3:c-format])
@@ -92,6 +94,7 @@ AC_DEFUN([gl_INIT],
   m4_pushdef([AC_LIBOBJ], m4_defn([gltests_LIBOBJ]))
   m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gltests_REPLACE_FUNCS]))
   m4_pushdef([AC_LIBSOURCES], m4_defn([gltests_LIBSOURCES]))
+  gl_COMMON
   gl_source_base='tests'
   m4_popdef([AC_LIBSOURCES])
   m4_popdef([AC_REPLACE_FUNCS])
@@ -190,6 +193,8 @@ AC_DEFUN([gltests_LIBSOURCES], [
 # gnulib-tool and may be removed by future gnulib-tool invocations.
 AC_DEFUN([gl_FILE_LIST], [
   build-aux/link-warning.h
+  lib/alloca.c
+  lib/alloca.in.h
   lib/c-ctype.c
   lib/c-ctype.h
   lib/error.c
@@ -216,6 +221,7 @@ AC_DEFUN([gl_FILE_LIST], [
   lib/xalloc-die.c
   lib/xalloc.h
   lib/xmalloc.c
+  m4/alloca.m4
   m4/error.m4
   m4/exitfail.m4
   m4/extensions.m4
-- 
cgit v1.0-41-gc330


From 34747d72eb01960c81273d195e44100b1bf18efc Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 18 Apr 2008 21:42:02 +0200
Subject: Conditional inclusion of Gnulib alloc headers.

---
 src/wget.h | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/wget.h b/src/wget.h
index d8ab0c9..a0122db 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -208,7 +208,12 @@ typedef double SUM_SIZE_INT;
 #include "options.h"
 
 /* Everything uses this, so include them here directly.  */
-#include "xmalloc.h"
+#ifdef USE_GNULIB_ALLOC
+# include <alloca.h>
+# include "xalloc.h"
+#else
+# include "xmalloc.h"
+#endif
 
 /* Likewise for logging functions.  */
 #include "log.h"
-- 
cgit v1.0-41-gc330


From d8e970f4940975bde07b64a5f01303ec379b838a Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 18 Apr 2008 22:04:37 +0200
Subject: Use Gnulib's alloc functions in connect.c.

---
 src/connect.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/connect.c b/src/connect.c
index 2626ef3..d8e2036 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
@@ -766,7 +768,7 @@ fd_register_transport (int fd, struct transport_implementation *imp, void *ctx)
      hash key.  */
   assert (fd >= 0);
 
-  info = xnew (struct transport_info);
+  info = xmalloc (sizeof (struct transport_info));
   info->imp = imp;
   info->ctx = ctx;
   if (!transport_map)
@@ -958,7 +960,7 @@ fd_close (int fd)
   if (info)
     {
       hash_table_remove (transport_map, (void *)(intptr_t) fd);
-      xfree (info);
+      free (info);
       ++transport_map_modified_tick;
     }
 }
-- 
cgit v1.0-41-gc330


From b06220f359c293311bab7d4c1a282cb5945716ed Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 18 Apr 2008 23:18:34 +0200
Subject: Revert using Gnulib's alloc functions in connect.c.

---
 src/connect.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/connect.c b/src/connect.c
index d8e2036..2626ef3 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
@@ -768,7 +766,7 @@ fd_register_transport (int fd, struct transport_implementation *imp, void *ctx)
      hash key.  */
   assert (fd >= 0);
 
-  info = xmalloc (sizeof (struct transport_info));
+  info = xnew (struct transport_info);
   info->imp = imp;
   info->ctx = ctx;
   if (!transport_map)
@@ -960,7 +958,7 @@ fd_close (int fd)
   if (info)
     {
       hash_table_remove (transport_map, (void *)(intptr_t) fd);
-      free (info);
+      xfree (info);
       ++transport_map_modified_tick;
     }
 }
-- 
cgit v1.0-41-gc330


From 76780021d822779f839bbf85883292e15eb3f587 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 19 Apr 2008 01:21:24 +0200
Subject: Use Gnulib's alloc functions throughout the source.

---
 src/cmpt.c       |  2 ++
 src/connect.c    |  2 ++
 src/convert.c    |  2 ++
 src/cookies.c    |  2 ++
 src/ftp-basic.c  |  2 ++
 src/ftp-ls.c     |  2 ++
 src/ftp-opie.c   |  2 ++
 src/ftp.c        |  2 ++
 src/gen-md5.c    |  2 ++
 src/gnutls.c     |  2 ++
 src/hash.c       |  2 ++
 src/host.c       |  2 ++
 src/html-parse.c |  3 +++
 src/html-url.c   |  2 ++
 src/http-ntlm.c  |  2 ++
 src/http.c       |  2 ++
 src/init.c       |  2 ++
 src/log.c        |  2 ++
 src/main.c       |  2 ++
 src/mswindows.c  |  2 ++
 src/netrc.c      |  2 ++
 src/openssl.c    |  2 ++
 src/progress.c   |  2 ++
 src/ptimer.c     |  3 +++
 src/recur.c      |  2 ++
 src/res.c        |  2 ++
 src/retr.c       |  2 ++
 src/snprintf.c   |  2 ++
 src/spider.c     |  2 ++
 src/test.c       |  2 ++
 src/url.c        |  2 ++
 src/utils.c      |  2 ++
 src/utils.h      | 26 ++++++++++++++++++++++++++
 33 files changed, 92 insertions(+)

diff --git a/src/cmpt.c b/src/cmpt.c
index 499a0fe..6726b7f 100644
--- a/src/cmpt.c
+++ b/src/cmpt.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/connect.c b/src/connect.c
index 2626ef3..361eb56 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/convert.c b/src/convert.c
index 69d713f..9f60ae3 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/cookies.c b/src/cookies.c
index bdc3274..1258472 100644
--- a/src/cookies.c
+++ b/src/cookies.c
@@ -43,6 +43,8 @@ as that of the covered work.  */
    sites that do send Set-Cookie2 also emit Set-Cookie for
    compatibility.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ftp-basic.c b/src/ftp-basic.c
index 38f0069..9145fe7 100644
--- a/src/ftp-basic.c
+++ b/src/ftp-basic.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <assert.h>
diff --git a/src/ftp-ls.c b/src/ftp-ls.c
index e050c5a..67e9bc5 100644
--- a/src/ftp-ls.c
+++ b/src/ftp-ls.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ftp-opie.c b/src/ftp-opie.c
index 546e210..5d740a1 100644
--- a/src/ftp-opie.c
+++ b/src/ftp-opie.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ftp.c b/src/ftp.c
index 645e565..134c925 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/gen-md5.c b/src/gen-md5.c
index 833f3f2..d4d5f5c 100644
--- a/src/gen-md5.c
+++ b/src/gen-md5.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include "gen-md5.h"
diff --git a/src/gnutls.c b/src/gnutls.c
index 57d4ad5..258c015 100644
--- a/src/gnutls.c
+++ b/src/gnutls.c
@@ -27,6 +27,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <assert.h>
diff --git a/src/hash.c b/src/hash.c
index 4697b77..f8b3c11 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -31,6 +31,8 @@ as that of the covered work.  */
 /* With -DSTANDALONE, this file can be compiled outside Wget source
    tree.  To test, also use -DTEST.  */
 
+#define USE_GNULIB_ALLOC
+
 #ifndef STANDALONE
 # include "wget.h"
 #endif
diff --git a/src/host.c b/src/host.c
index 5a53022..1b418ce 100644
--- a/src/host.c
+++ b/src/host.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/html-parse.c b/src/html-parse.c
index ade82f2..623b7fd 100644
--- a/src/html-parse.c
+++ b/src/html-parse.c
@@ -89,6 +89,8 @@ as that of the covered work.  */
 /* To test as standalone, compile with `-DSTANDALONE -I.'.  You'll
    still need Wget headers to compile.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #ifdef STANDALONE
@@ -100,6 +102,7 @@ as that of the covered work.  */
 #include <string.h>
 #include <assert.h>
 
+#include "utils.h"
 #include "html-parse.h"
 
 #ifdef STANDALONE
diff --git a/src/html-url.c b/src/html-url.c
index e9f2773..717fe8c 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/http-ntlm.c b/src/http-ntlm.c
index def832b..321d70d 100644
--- a/src/http-ntlm.c
+++ b/src/http-ntlm.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 /* NTLM details:
diff --git a/src/http.c b/src/http.c
index c1049d8..84bbe2e 100644
--- a/src/http.c
+++ b/src/http.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/init.c b/src/init.c
index e079df9..1a5171c 100644
--- a/src/init.c
+++ b/src/init.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/log.c b/src/log.c
index f7b3dca..077ebeb 100644
--- a/src/log.c
+++ b/src/log.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/main.c b/src/main.c
index b1e9969..04ff76f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/mswindows.c b/src/mswindows.c
index cdfea2d..c64da02 100644
--- a/src/mswindows.c
+++ b/src/mswindows.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #define INHIBIT_WRAP /* avoid wrapping of socket, bind, ... */
 
 #include "wget.h"
diff --git a/src/netrc.c b/src/netrc.c
index fea440d..35163a6 100644
--- a/src/netrc.c
+++ b/src/netrc.c
@@ -30,6 +30,8 @@ as that of the covered work.  */
 /* This file used to be kept in synch with the code in Fetchmail, but
    the latter has diverged since.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/openssl.c b/src/openssl.c
index 03fb181..d35aba3 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -29,6 +29,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <assert.h>
diff --git a/src/progress.c b/src/progress.c
index 8b9b101..62e8d87 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ptimer.c b/src/ptimer.c
index 9edddd8..0f5b5db 100644
--- a/src/ptimer.c
+++ b/src/ptimer.c
@@ -50,6 +50,8 @@ as that of the covered work.  */
      double secs = ptimer_measure ();
      printf ("The loop took %.2fs\n", secs);  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
@@ -71,6 +73,7 @@ as that of the covered work.  */
 # include <windows.h>
 #endif
 
+#include "utils.h"
 #include "ptimer.h"
 
 /* Depending on the OS, one and only one of PTIMER_POSIX,
diff --git a/src/recur.c b/src/recur.c
index d1d0f18..a992230 100644
--- a/src/recur.c
+++ b/src/recur.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/res.c b/src/res.c
index 8c35f0e..94d9769 100644
--- a/src/res.c
+++ b/src/res.c
@@ -67,6 +67,8 @@ as that of the covered work.  */
    res_match_path, res_register_specs, res_get_specs, and
    res_retrieve_file.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/retr.c b/src/retr.c
index 179430a..60d4c62 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/snprintf.c b/src/snprintf.c
index f458981..2a8fc6e 100644
--- a/src/snprintf.c
+++ b/src/snprintf.c
@@ -87,6 +87,8 @@
  *
  **************************************************************/
 
+#define USE_GNULIB_ALLOC
+
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
diff --git a/src/spider.c b/src/spider.c
index 08fefc9..7025409 100644
--- a/src/spider.c
+++ b/src/spider.c
@@ -27,6 +27,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/test.c b/src/test.c
index 04658bc..d6a8659 100644
--- a/src/test.c
+++ b/src/test.c
@@ -27,6 +27,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include <stdio.h>
 
 #include "test.h"
diff --git a/src/url.c b/src/url.c
index a561725..997b105 100644
--- a/src/url.c
+++ b/src/url.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/utils.c b/src/utils.c
index f3b4a60..d1366ef 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -28,6 +28,8 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
+#define USE_GNULIB_ALLOC
+
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/utils.h b/src/utils.h
index 7d41b31..bac112e 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -31,6 +31,32 @@ as that of the covered work.  */
 #ifndef UTILS_H
 #define UTILS_H
 
+#ifdef USE_GNULIB_ALLOC
+
+/* Constant is using when we don`t know attempted size exactly */
+#define UNKNOWN_ATTEMPTED_SIZE -3
+
+/* Macros that interface to malloc, but know about type sizes, and
+   cast the result to the appropriate type.  The casts are not
+   necessary in standard C, but Wget performs them anyway for the sake
+   of pre-standard environments and possibly C++.  */
+
+#define xnew(type) (xmalloc (sizeof (type)))
+#define xnew0(type) (xcalloc (1, sizeof (type)))
+#define xnew_array(type, len) (xmalloc ((len) * sizeof (type)))
+#define xnew0_array(type, len) (xcalloc ((len), sizeof (type)))
+
+#define alloca_array(type, size) ((type *) alloca ((size) * sizeof (type)))
+
+#define xfree free
+/* Free P if it is non-NULL.  C requires free() to behaves this way by
+   default, but Wget's code is historically careful not to pass NULL
+   to free.  This allows us to assert p!=NULL in xfree to check
+   additional errors.  (But we currently don't do that!)  */
+#define xfree_null(p) if (!(p)) ; else xfree (p)
+
+#endif /* USE_GNULIB_ALLOC */
+
 struct hash_table;
 
 struct file_memory {
-- 
cgit v1.0-41-gc330


From d79719be09571cb14400909f187befebb309d62d Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 19 Apr 2008 21:13:38 +0200
Subject: Move memfatal() to utils.c.

---
 src/utils.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/src/utils.c b/src/utils.c
index d1366ef..3459be9 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -90,6 +90,32 @@ as that of the covered work.  */
 #include "test.h"
 #endif 
 
+static void
+memfatal (const char *context, long attempted_size)
+{
+  /* Make sure we don't try to store part of the log line, and thus
+     call malloc.  */
+  log_set_save_context (false);
+
+  /* We have different log outputs in different situations:
+     1) output without bytes information
+     2) output with bytes information  */
+  if (attempted_size == UNKNOWN_ATTEMPTED_SIZE)
+    {
+      logprintf (LOG_ALWAYS,
+                 _("%s: %s: Failed to allocate enough memory; memory exhausted.\n"),
+                 exec_name, context);
+    }
+  else
+    {
+      logprintf (LOG_ALWAYS,
+                 _("%s: %s: Failed to allocate %ld bytes; memory exhausted.\n"),
+                 exec_name, context, attempted_size);
+    }
+
+  exit (1);
+}
+
 /* Utility function: like xstrdup(), but also lowercases S.  */
 
 char *
-- 
cgit v1.0-41-gc330


From 021b9acf53b7764cedba004c4a6a258d95562090 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 19 Apr 2008 21:37:17 +0200
Subject: Remove own xmalloc from build-process.

---
 src/Makefile.am | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/Makefile.am b/src/Makefile.am
index f598d90..69fa7ec 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -39,12 +39,12 @@ wget_SOURCES = cmpt.c connect.c convert.c cookies.c ftp.c ftp-basic.c	\
 	       ftp-ls.c hash.c host.c html-parse.c html-url.c http.c	\
 	       init.c log.c main.c netrc.c progress.c ptimer.c recur.c	\
 	       res.c retr.c snprintf.c spider.c url.c	\
-	       utils.c xmalloc.c				\
+	       utils.c 				\
 	       connect.h convert.h cookies.h 		\
 	       ftp.h gen-md5.h hash.h host.h html-parse.h \
 	       http.h http-ntlm.h init.h log.h mswindows.h netrc.h \
 	       options.h progress.h ptimer.h recur.h res.h retr.h \
-	       spider.h ssl.h sysdep.h url.h utils.h wget.h xmalloc.h
+	       spider.h ssl.h sysdep.h url.h utils.h wget.h
 nodist_wget_SOURCES = version.c
 EXTRA_wget_SOURCES = mswindows.c
 LDADD = $(ALLOCA) $(LIBOBJS) ../lib/libgnu.a @MD5_LDADD@
-- 
cgit v1.0-41-gc330


From ad1b42f4f1e8f56b310072a8a069343354208041 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 19 Apr 2008 21:48:47 +0200
Subject: Remove own alloca from build-process.

---
 configure.ac    | 1 -
 src/Makefile.am | 4 ++--
 2 files changed, 2 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index a49de3c..a994896 100644
--- a/configure.ac
+++ b/configure.ac
@@ -193,7 +193,6 @@ gl_INIT
 dnl
 dnl Checks for library functions.
 dnl
-AC_FUNC_ALLOCA
 AC_FUNC_MMAP
 AC_FUNC_FSEEKO
 AC_CHECK_FUNCS(strptime timegm snprintf vsnprintf vasprintf drand48)
diff --git a/src/Makefile.am b/src/Makefile.am
index 69fa7ec..4b35120 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -47,7 +47,7 @@ wget_SOURCES = cmpt.c connect.c convert.c cookies.c ftp.c ftp-basic.c	\
 	       spider.h ssl.h sysdep.h url.h utils.h wget.h
 nodist_wget_SOURCES = version.c
 EXTRA_wget_SOURCES = mswindows.c
-LDADD = $(ALLOCA) $(LIBOBJS) ../lib/libgnu.a @MD5_LDADD@
+LDADD = $(LIBOBJS) ../lib/libgnu.a @MD5_LDADD@
 AM_CPPFLAGS = -I $(top_srcdir)/lib @MD5_CPPFLAGS@
 
 version.c:  $(wget_SOURCES) $(LDADD) $(srcdir)/Makefile.am
@@ -59,6 +59,6 @@ check_LIBRARIES = libunittest.a
 libunittest_a_SOURCES = $(wget_SOURCES) test.c test.h
 nodist_libunittest_a_SOURCES = version.c
 libunittest_a_CPPFLAGS = -DTESTING -I$(top_srcdir)/lib
-libunittest_a_LIBADD = $(ALLOCA) $(LIBOBJS)
+libunittest_a_LIBADD = $(LIBOBJS)
 
 CLEANFILES = *~ *.bak core core.[0-9]* version.c
-- 
cgit v1.0-41-gc330


From b29fd927e76def6377a9ca124c7e72e238a7cd8f Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 19 Apr 2008 21:57:31 +0200
Subject: Remove alloca files from source directory.

---
 src/alloca.c | 507 -----------------------------------------------------------
 1 file changed, 507 deletions(-)
 delete mode 100644 src/alloca.c

diff --git a/src/alloca.c b/src/alloca.c
deleted file mode 100644
index fd08295..0000000
--- a/src/alloca.c
+++ /dev/null
@@ -1,507 +0,0 @@
-/* alloca.c -- allocate automatically reclaimed memory
-   (Mostly) portable public-domain implementation -- D A Gwyn
-
-   This implementation of the PWB library alloca function,
-   which is used to allocate space off the run-time stack so
-   that it is automatically reclaimed upon procedure exit,
-   was inspired by discussions with J. Q. Johnson of Cornell.
-   J.Otto Tennant <jot@cray.com> contributed the Cray support.
-
-   There are some preprocessor constants that can
-   be defined when compiling for your specific system, for
-   improved efficiency; however, the defaults should be okay.
-
-   The general concept of this implementation is to keep
-   track of all alloca-allocated blocks, and reclaim any
-   that are found to be deeper in the stack than the current
-   invocation.  This heuristic does not reclaim storage as
-   soon as it becomes invalid, but it will do so eventually.
-
-   As a special case, alloca(0) reclaims storage without
-   allocating any.  It is a good idea to use alloca(0) in
-   your main control loop, etc. to force garbage collection.  */
-
-#include "wget.h"
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#ifdef HAVE_STRING_H
-#include <string.h>
-#endif
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-
-#ifdef emacs
-#include "blockinput.h"
-#endif
-
-/* If compiling with GCC 2, this file's not needed.  */
-#if !defined (__GNUC__) || __GNUC__ < 2
-
-/* If someone has defined alloca as a macro,
-   there must be some other way alloca is supposed to work.  */
-#ifndef alloca
-
-#ifdef emacs
-#ifdef static
-/* actually, only want this if static is defined as ""
-   -- this is for usg, in which emacs must undefine static
-   in order to make unexec workable
-   */
-#ifndef STACK_DIRECTION
-you
-lose
--- must know STACK_DIRECTION at compile-time
-#endif /* STACK_DIRECTION undefined */
-#endif /* static */
-#endif /* emacs */
-
-/* If your stack is a linked list of frames, you have to
-   provide an "address metric" ADDRESS_FUNCTION macro.  */
-
-#if defined (CRAY) && defined (CRAY_STACKSEG_END)
-long i00afunc ();
-#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
-#else
-#define ADDRESS_FUNCTION(arg) &(arg)
-#endif
-
-#if __STDC__
-typedef void *pointer;
-#else
-typedef char *pointer;
-#endif
-
-#ifndef NULL
-#define NULL    0
-#endif
-
-/* Different portions of Emacs need to call different versions of
-   malloc.  The Emacs executable needs alloca to call xmalloc, because
-   ordinary malloc isn't protected from input signals.  On the other
-   hand, the utilities in lib-src need alloca to call malloc; some of
-   them are very simple, and don't have an xmalloc routine.
-
-   Non-Emacs programs expect this to call xmalloc.
-
-   Callers below should use malloc.  */
-
-#ifndef emacs
-#define malloc xmalloc
-#define free xfree
-#endif
-extern pointer malloc ();
-
-/* Define STACK_DIRECTION if you know the direction of stack
-   growth for your system; otherwise it will be automatically
-   deduced at run-time.
-
-   STACK_DIRECTION > 0 => grows toward higher addresses
-   STACK_DIRECTION < 0 => grows toward lower addresses
-   STACK_DIRECTION = 0 => direction of growth unknown  */
-
-#ifndef STACK_DIRECTION
-#define STACK_DIRECTION 0       /* Direction unknown.  */
-#endif
-
-#if STACK_DIRECTION != 0
-
-#define STACK_DIR       STACK_DIRECTION /* Known at compile-time.  */
-
-#else /* STACK_DIRECTION == 0; need run-time code.  */
-
-static int stack_dir;           /* 1 or -1 once known.  */
-#define STACK_DIR       stack_dir
-
-static void
-find_stack_direction ()
-{
-  static char *addr = NULL;     /* Address of first `dummy', once known.  */
-  auto char dummy;              /* To get stack address.  */
-
-  if (addr == NULL)
-    {                           /* Initial entry.  */
-      addr = ADDRESS_FUNCTION (dummy);
-
-      find_stack_direction ();  /* Recurse once.  */
-    }
-  else
-    {
-      /* Second entry.  */
-      if (ADDRESS_FUNCTION (dummy) > addr)
-        stack_dir = 1;          /* Stack grew upward.  */
-      else
-        stack_dir = -1;         /* Stack grew downward.  */
-    }
-}
-
-#endif /* STACK_DIRECTION == 0 */
-
-/* An "alloca header" is used to:
-   (a) chain together all alloca'ed blocks;
-   (b) keep track of stack depth.
-
-   It is very important that sizeof(header) agree with malloc
-   alignment chunk size.  The following default should work okay.  */
-
-#ifndef ALIGN_SIZE
-#define ALIGN_SIZE      sizeof(double)
-#endif
-
-typedef union hdr
-{
-  char align[ALIGN_SIZE];       /* To force sizeof(header).  */
-  struct
-    {
-      union hdr *next;          /* For chaining headers.  */
-      char *deep;               /* For stack depth measure.  */
-    } h;
-} header;
-
-static header *last_alloca_header = NULL;       /* -> last alloca header.  */
-
-/* Return a pointer to at least SIZE bytes of storage,
-   which will be automatically reclaimed upon exit from
-   the procedure that called alloca.  Originally, this space
-   was supposed to be taken from the current stack frame of the
-   caller, but that method cannot be made to work for some
-   implementations of C, for example under Gould's UTX/32.  */
-
-pointer
-alloca (size)
-     unsigned size;
-{
-  auto char probe;              /* Probes stack depth: */
-  register char *depth = ADDRESS_FUNCTION (probe);
-
-#if STACK_DIRECTION == 0
-  if (STACK_DIR == 0)           /* Unknown growth direction.  */
-    find_stack_direction ();
-#endif
-
-  /* Reclaim garbage, defined as all alloca'd storage that
-     was allocated from deeper in the stack than currently.  */
-
-  {
-    register header *hp;        /* Traverses linked list.  */
-
-#ifdef emacs
-    BLOCK_INPUT;
-#endif
-
-    for (hp = last_alloca_header; hp != NULL;)
-      if ((STACK_DIR > 0 && hp->h.deep > depth)
-          || (STACK_DIR < 0 && hp->h.deep < depth))
-        {
-          register header *np = hp->h.next;
-
-          free ((pointer) hp);  /* Collect garbage.  */
-
-          hp = np;              /* -> next header.  */
-        }
-      else
-        break;                  /* Rest are not deeper.  */
-
-    last_alloca_header = hp;    /* -> last valid storage.  */
-
-#ifdef emacs
-    UNBLOCK_INPUT;
-#endif
-  }
-
-  if (size == 0)
-    return NULL;                /* No allocation required.  */
-
-  /* Allocate combined header + user data storage.  */
-
-  {
-    register pointer new = malloc (sizeof (header) + size);
-    /* Address of header.  */
-
-    if (new == 0)
-      abort();
-
-    ((header *) new)->h.next = last_alloca_header;
-    ((header *) new)->h.deep = depth;
-
-    last_alloca_header = (header *) new;
-
-    /* User storage begins just after header.  */
-
-    return (pointer) ((char *) new + sizeof (header));
-  }
-}
-
-#if defined (CRAY) && defined (CRAY_STACKSEG_END)
-
-#ifdef DEBUG_I00AFUNC
-#include <stdio.h>
-#endif
-
-#ifndef CRAY_STACK
-#define CRAY_STACK
-#ifndef CRAY2
-/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
-struct stack_control_header
-  {
-    long shgrow:32;             /* Number of times stack has grown.  */
-    long shaseg:32;             /* Size of increments to stack.  */
-    long shhwm:32;              /* High water mark of stack.  */
-    long shsize:32;             /* Current size of stack (all segments).  */
-  };
-
-/* The stack segment linkage control information occurs at
-   the high-address end of a stack segment.  (The stack
-   grows from low addresses to high addresses.)  The initial
-   part of the stack segment linkage control information is
-   0200 (octal) words.  This provides for register storage
-   for the routine which overflows the stack.  */
-
-struct stack_segment_linkage
-  {
-    long ss[0200];              /* 0200 overflow words.  */
-    long sssize:32;             /* Number of words in this segment.  */
-    long ssbase:32;             /* Offset to stack base.  */
-    long:32;
-    long sspseg:32;             /* Offset to linkage control of previous
-                                   segment of stack.  */
-    long:32;
-    long sstcpt:32;             /* Pointer to task common address block.  */
-    long sscsnm;                /* Private control structure number for
-                                   microtasking.  */
-    long ssusr1;                /* Reserved for user.  */
-    long ssusr2;                /* Reserved for user.  */
-    long sstpid;                /* Process ID for pid based multi-tasking.  */
-    long ssgvup;                /* Pointer to multitasking thread giveup.  */
-    long sscray[7];             /* Reserved for Cray Research.  */
-    long ssa0;
-    long ssa1;
-    long ssa2;
-    long ssa3;
-    long ssa4;
-    long ssa5;
-    long ssa6;
-    long ssa7;
-    long sss0;
-    long sss1;
-    long sss2;
-    long sss3;
-    long sss4;
-    long sss5;
-    long sss6;
-    long sss7;
-  };
-
-#else /* CRAY2 */
-/* The following structure defines the vector of words
-   returned by the STKSTAT library routine.  */
-struct stk_stat
-  {
-    long now;                   /* Current total stack size.  */
-    long maxc;                  /* Amount of contiguous space which would
-                                   be required to satisfy the maximum
-                                   stack demand to date.  */
-    long high_water;            /* Stack high-water mark.  */
-    long overflows;             /* Number of stack overflow ($STKOFEN) calls.  */
-    long hits;                  /* Number of internal buffer hits.  */
-    long extends;               /* Number of block extensions.  */
-    long stko_mallocs;          /* Block allocations by $STKOFEN.  */
-    long underflows;            /* Number of stack underflow calls ($STKRETN).  */
-    long stko_free;             /* Number of deallocations by $STKRETN.  */
-    long stkm_free;             /* Number of deallocations by $STKMRET.  */
-    long segments;              /* Current number of stack segments.  */
-    long maxs;                  /* Maximum number of stack segments so far.  */
-    long pad_size;              /* Stack pad size.  */
-    long current_address;       /* Current stack segment address.  */
-    long current_size;          /* Current stack segment size.  This
-                                   number is actually corrupted by STKSTAT to
-                                   include the fifteen word trailer area.  */
-    long initial_address;       /* Address of initial segment.  */
-    long initial_size;          /* Size of initial segment.  */
-  };
-
-/* The following structure describes the data structure which trails
-   any stack segment.  I think that the description in 'asdef' is
-   out of date.  I only describe the parts that I am sure about.  */
-
-struct stk_trailer
-  {
-    long this_address;          /* Address of this block.  */
-    long this_size;             /* Size of this block (does not include
-                                   this trailer).  */
-    long unknown2;
-    long unknown3;
-    long link;                  /* Address of trailer block of previous
-                                   segment.  */
-    long unknown5;
-    long unknown6;
-    long unknown7;
-    long unknown8;
-    long unknown9;
-    long unknown10;
-    long unknown11;
-    long unknown12;
-    long unknown13;
-    long unknown14;
-  };
-
-#endif /* CRAY2 */
-#endif /* not CRAY_STACK */
-
-#ifdef CRAY2
-/* Determine a "stack measure" for an arbitrary ADDRESS.
-   I doubt that "lint" will like this much.  */
-
-static long
-i00afunc (long *address)
-{
-  struct stk_stat status;
-  struct stk_trailer *trailer;
-  long *block, size;
-  long result = 0;
-
-  /* We want to iterate through all of the segments.  The first
-     step is to get the stack status structure.  We could do this
-     more quickly and more directly, perhaps, by referencing the
-     $LM00 common block, but I know that this works.  */
-
-  STKSTAT (&status);
-
-  /* Set up the iteration.  */
-
-  trailer = (struct stk_trailer *) (status.current_address
-                                    + status.current_size
-                                    - 15);
-
-  /* There must be at least one stack segment.  Therefore it is
-     a fatal error if "trailer" is null.  */
-
-  if (trailer == 0)
-    abort ();
-
-  /* Discard segments that do not contain our argument address.  */
-
-  while (trailer != 0)
-    {
-      block = (long *) trailer->this_address;
-      size = trailer->this_size;
-      if (block == 0 || size == 0)
-        abort ();
-      trailer = (struct stk_trailer *) trailer->link;
-      if ((block <= address) && (address < (block + size)))
-        break;
-    }
-
-  /* Set the result to the offset in this segment and add the sizes
-     of all predecessor segments.  */
-
-  result = address - block;
-
-  if (trailer == 0)
-    {
-      return result;
-    }
-
-  do
-    {
-      if (trailer->this_size <= 0)
-        abort ();
-      result += trailer->this_size;
-      trailer = (struct stk_trailer *) trailer->link;
-    }
-  while (trailer != 0);
-
-  /* We are done.  Note that if you present a bogus address (one
-     not in any segment), you will get a different number back, formed
-     from subtracting the address of the first block.  This is probably
-     not what you want.  */
-
-  return (result);
-}
-
-#else /* not CRAY2 */
-/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
-   Determine the number of the cell within the stack,
-   given the address of the cell.  The purpose of this
-   routine is to linearize, in some sense, stack addresses
-   for alloca.  */
-
-static long
-i00afunc (long address)
-{
-  long stkl = 0;
-
-  long size, pseg, this_segment, stack;
-  long result = 0;
-
-  struct stack_segment_linkage *ssptr;
-
-  /* Register B67 contains the address of the end of the
-     current stack segment.  If you (as a subprogram) store
-     your registers on the stack and find that you are past
-     the contents of B67, you have overflowed the segment.
-
-     B67 also points to the stack segment linkage control
-     area, which is what we are really interested in.  */
-
-  stkl = CRAY_STACKSEG_END ();
-  ssptr = (struct stack_segment_linkage *) stkl;
-
-  /* If one subtracts 'size' from the end of the segment,
-     one has the address of the first word of the segment.
-
-     If this is not the first segment, 'pseg' will be
-     nonzero.  */
-
-  pseg = ssptr->sspseg;
-  size = ssptr->sssize;
-
-  this_segment = stkl - size;
-
-  /* It is possible that calling this routine itself caused
-     a stack overflow.  Discard stack segments which do not
-     contain the target address.  */
-
-  while (!(this_segment <= address && address <= stkl))
-    {
-#ifdef DEBUG_I00AFUNC
-      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
-#endif
-      if (pseg == 0)
-        break;
-      stkl = stkl - pseg;
-      ssptr = (struct stack_segment_linkage *) stkl;
-      size = ssptr->sssize;
-      pseg = ssptr->sspseg;
-      this_segment = stkl - size;
-    }
-
-  result = address - this_segment;
-
-  /* If you subtract pseg from the current end of the stack,
-     you get the address of the previous stack segment's end.
-     This seems a little convoluted to me, but I'll bet you save
-     a cycle somewhere.  */
-
-  while (pseg != 0)
-    {
-#ifdef DEBUG_I00AFUNC
-      fprintf (stderr, "%011o %011o\n", pseg, size);
-#endif
-      stkl = stkl - pseg;
-      ssptr = (struct stack_segment_linkage *) stkl;
-      size = ssptr->sssize;
-      pseg = ssptr->sspseg;
-      result += size;
-    }
-  return (result);
-}
-
-#endif /* not CRAY2 */
-#endif /* CRAY */
-
-#endif /* no alloca */
-#endif /* not GCC version 2 */
-- 
cgit v1.0-41-gc330


From 2957ce1cbc36a89d09bc3f8dd3c29c0a5aae2a92 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 19 Apr 2008 21:59:54 +0200
Subject: Remove xmalloc files from source directory.

---
 src/xmalloc.c | 383 ----------------------------------------------------------
 src/xmalloc.h | 107 ----------------
 2 files changed, 490 deletions(-)
 delete mode 100644 src/xmalloc.c
 delete mode 100644 src/xmalloc.h

diff --git a/src/xmalloc.c b/src/xmalloc.c
deleted file mode 100644
index aaf743d..0000000
--- a/src/xmalloc.c
+++ /dev/null
@@ -1,383 +0,0 @@
-/* Wrappers around malloc and memory debugging support.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation,
-   Inc.
-
-This file is part of GNU Wget.
-
-GNU Wget is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3 of the License, or
-(at your option) any later version.
-
-GNU Wget is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Wget.  If not, see <http://www.gnu.org/licenses/>.
-
-Additional permission under GNU GPL version 3 section 7
-
-If you modify this program, or any covered work, by linking or
-combining it with the OpenSSL project's OpenSSL library (or a
-modified version of that library), containing parts covered by the
-terms of the OpenSSL or SSLeay licenses, the Free Software Foundation
-grants you additional permission to convey the resulting work.
-Corresponding Source for a non-source form of such a combination
-shall include the source code for the parts of OpenSSL used as well
-as that of the covered work.  */
-
-#include "wget.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <assert.h>
-
-#include "xmalloc.h"
-#include "hash.h"               /* for hash_pointer */
-
-/* This file implements several wrappers around the basic allocation
-   routines.  This is done for two reasons: first, so that the callers
-   of these functions need not check for errors, which is easy to
-   forget.  If there is not enough virtual memory for running Wget,
-   something is seriously wrong, and Wget exits with an appropriate
-   error message.
-
-   The second reason why these are useful is that, if DEBUG_MALLOC is
-   defined, they also provide a handy (if crude) malloc debugging
-   interface that checks for memory leaks.  */
-
-/* Croak the fatal memory error and bail out with non-zero exit
-   status.  */
-
-void
-memfatal (const char *context, long attempted_size)
-{
-  /* Make sure we don't try to store part of the log line, and thus
-     call malloc.  */
-  log_set_save_context (false);
-
-  /* We have different log outputs in different situations:
-     1) output without bytes information
-     2) output with bytes information  */
-  if (attempted_size == UNKNOWN_ATTEMPTED_SIZE)
-    {
-      logprintf (LOG_ALWAYS,
-                 _("%s: %s: Failed to allocate enough memory; memory exhausted.\n"),
-                 exec_name, context);
-    }
-  else
-    {
-      logprintf (LOG_ALWAYS,
-                 _("%s: %s: Failed to allocate %ld bytes; memory exhausted.\n"),
-                 exec_name, context, attempted_size);
-    }
-
-  exit (1);
-}
-
-/* These functions end with _real because they need to be
-   distinguished from the debugging functions, and from the macros.
-   Explanation follows:
-
-   If memory debugging is not turned on, xmalloc.h defines these:
-
-     #define xmalloc checking_malloc
-     #define xmalloc0 checking_malloc0
-     #define xrealloc checking_realloc
-     #define xstrdup checking_strdup
-     #define xfree checking_free
-
-   In case of memory debugging, the definitions are a bit more
-   complex, because we want to provide more information, *and* we want
-   to call the debugging code.  (The former is the reason why xmalloc
-   and friends need to be macros in the first place.)  Then it looks
-   like this:
-
-     #define xmalloc(a) debugging_malloc (a, __FILE__, __LINE__)
-     #define xmalloc0(a) debugging_malloc0 (a, __FILE__, __LINE__)
-     #define xrealloc(a, b) debugging_realloc (a, b, __FILE__, __LINE__)
-     #define xstrdup(a) debugging_strdup (a, __FILE__, __LINE__)
-     #define xfree(a) debugging_free (a, __FILE__, __LINE__)
-
-   Each of the debugging_* functions does its magic and calls the
-   corresponding checking_* one.  */
-
-#ifdef DEBUG_MALLOC
-# define STATIC_IF_DEBUG static
-#else
-# define STATIC_IF_DEBUG
-#endif
-
-STATIC_IF_DEBUG void *
-checking_malloc (size_t size)
-{
-  void *ptr = malloc (size);
-  if (!ptr)
-    memfatal ("malloc", size);
-  return ptr;
-}
-
-STATIC_IF_DEBUG void *
-checking_malloc0 (size_t size)
-{
-  /* Using calloc can be faster than malloc+memset because some calloc
-     implementations know when they're dealing with zeroed-out memory
-     from the system and can avoid unnecessary memset.  */
-  void *ptr = calloc (1, size);
-  if (!ptr)
-    memfatal ("calloc", size);
-  return ptr;
-}
-
-STATIC_IF_DEBUG void *
-checking_realloc (void *ptr, size_t newsize)
-{
-  void *newptr;
-
-  /* Not all Un*xes have the feature of realloc() that calling it with
-     a NULL-pointer is the same as malloc(), but it is easy to
-     simulate.  */
-  if (ptr)
-    newptr = realloc (ptr, newsize);
-  else
-    newptr = malloc (newsize);
-  if (!newptr)
-    memfatal ("realloc", newsize);
-  return newptr;
-}
-
-STATIC_IF_DEBUG char *
-checking_strdup (const char *s)
-{
-  char *copy;
-
-#ifndef HAVE_STRDUP
-  int l = strlen (s);
-  copy = malloc (l + 1);
-  if (!copy)
-    memfatal ("strdup", l + 1);
-  memcpy (copy, s, l + 1);
-#else  /* HAVE_STRDUP */
-  copy = strdup (s);
-  if (!copy)
-    memfatal ("strdup", 1 + strlen (s));
-#endif /* HAVE_STRDUP */
-
-  return copy;
-}
-
-STATIC_IF_DEBUG void
-checking_free (void *ptr)
-{
-  /* Wget's xfree() must not be passed a NULL pointer.  This is for
-     historical reasons: pre-C89 systems were reported to bomb at
-     free(NULL), and Wget was careful to not call xfree when there was
-     a possibility of PTR being NULL.  (It might have been better to
-     simply have xfree() do nothing if ptr==NULL.)
-
-     Since the code is already written that way, this assert simply
-     enforces the existing constraint.  The benefit is double-checking
-     the logic: code that thinks it can't be passed a NULL pointer,
-     while it in fact can, aborts here.  If you trip on this, either
-     the code has a pointer handling bug or should have called
-     xfree_null instead of xfree.  Correctly written code should never
-     trigger this assertion.
-
-     The downside is that the uninitiated might not expect xfree(NULL)
-     to abort.  If the assertion proves to be too much of a hassle, it
-     can be removed and a check that makes NULL a no-op placed in its
-     stead.  If that is done, xfree_null is no longer needed and
-     should be removed.  */
-  assert (ptr != NULL);
-
-  free (ptr);
-}
-
-#ifdef DEBUG_MALLOC
-
-/* Crude home-grown routines for debugging some malloc-related
-   problems.  Featured:
-
-   * Counting the number of malloc and free invocations, and reporting
-     the "balance", i.e. how many times more malloc was called than it
-     was the case with free.
-
-   * Making malloc store its entry into a simple array and free remove
-     stuff from that array.  At the end, print the pointers which have
-     not been freed, along with the source file and the line number.
-
-   * Checking for "invalid frees", where free is called on a pointer
-     not obtained with malloc, or where the same pointer is freed
-     twice.
-
-   Note that this kind of memory leak checking strongly depends on
-   every malloc() being followed by a free(), even if the program is
-   about to finish.  Wget is careful to free the data structure it
-   allocated in init.c.  */
-
-static int malloc_count, free_count;
-
-/* Home-grown hash table of mallocs: */
-
-#define SZ 100003               /* Prime just over 100,000.  Increase
-                                   it to debug larger Wget runs.  */
-
-static struct {
-  const void *ptr;
-  const char *file;
-  int line;
-} malloc_table[SZ];
-
-/* Find PTR's position in malloc_table.  If PTR is not found, return
-   the next available position.  */
-
-static inline int
-ptr_position (const void *ptr)
-{
-  int i = hash_pointer (ptr) % SZ;
-  for (; malloc_table[i].ptr != NULL; i = (i + 1) % SZ)
-    if (malloc_table[i].ptr == ptr)
-      return i;
-  return i;
-}
-
-/* Register PTR in malloc_table.  Abort if this is not possible
-   (presumably due to the number of current allocations exceeding the
-   size of malloc_table.)  */
-
-static void
-register_ptr (const void *ptr, const char *file, int line)
-{
-  int i;
-  if (malloc_count - free_count > SZ)
-    {
-      fprintf (stderr, "Increase SZ to a larger value and recompile.\n");
-      fflush (stderr);
-      abort ();
-    }
-
-  i = ptr_position (ptr);
-  malloc_table[i].ptr = ptr;
-  malloc_table[i].file = file;
-  malloc_table[i].line = line;
-}
-
-/* Unregister PTR from malloc_table.  Return false if PTR is not
-   present in malloc_table.  */
-
-static bool
-unregister_ptr (void *ptr)
-{
-  int i = ptr_position (ptr);
-  if (malloc_table[i].ptr == NULL)
-    return false;
-  malloc_table[i].ptr = NULL;
-
-  /* Relocate malloc_table entries immediately following PTR. */
-  for (i = (i + 1) % SZ; malloc_table[i].ptr != NULL; i = (i + 1) % SZ)
-    {
-      const void *ptr2 = malloc_table[i].ptr;
-      /* Find the new location for the key. */
-      int j = hash_pointer (ptr2) % SZ;
-      for (; malloc_table[j].ptr != NULL; j = (j + 1) % SZ)
-        if (ptr2 == malloc_table[j].ptr)
-          /* No need to relocate entry at [i]; it's already at or near
-             its hash position. */
-          goto cont_outer;
-      malloc_table[j] = malloc_table[i];
-      malloc_table[i].ptr = NULL;
-    cont_outer:
-      ;
-    }
-  return true;
-}
-
-/* Print the malloc debug stats gathered from the above information.
-   Currently this is the count of mallocs, frees, the difference
-   between the two, and the dump of the contents of malloc_table.  The
-   last part are the memory leaks.  */
-
-void
-print_malloc_debug_stats (void)
-{
-  int i;
-  printf ("\nMalloc:  %d\nFree:    %d\nBalance: %d\n\n",
-          malloc_count, free_count, malloc_count - free_count);
-  for (i = 0; i < SZ; i++)
-    if (malloc_table[i].ptr != NULL)
-      printf ("0x%0*lx: %s:%d\n", PTR_FORMAT (malloc_table[i].ptr),
-              malloc_table[i].file, malloc_table[i].line);
-}
-
-void *
-debugging_malloc (size_t size, const char *source_file, int source_line)
-{
-  void *ptr = checking_malloc (size);
-  ++malloc_count;
-  register_ptr (ptr, source_file, source_line);
-  return ptr;
-}
-
-void *
-debugging_malloc0 (size_t size, const char *source_file, int source_line)
-{
-  void *ptr = checking_malloc0 (size);
-  ++malloc_count;
-  register_ptr (ptr, source_file, source_line);
-  return ptr;
-}
-
-void *
-debugging_realloc (void *ptr, size_t newsize, const char *source_file, int source_line)
-{
-  void *newptr = checking_realloc (ptr, newsize);
-  if (!ptr)
-    {
-      ++malloc_count;
-      register_ptr (newptr, source_file, source_line);
-    }
-  else if (newptr != ptr)
-    {
-      unregister_ptr (ptr);
-      register_ptr (newptr, source_file, source_line);
-    }
-  return newptr;
-}
-
-char *
-debugging_strdup (const char *s, const char *source_file, int source_line)
-{
-  char *copy = checking_strdup (s);
-  ++malloc_count;
-  register_ptr (copy, source_file, source_line);
-  return copy;
-}
-
-void
-debugging_free (void *ptr, const char *source_file, int source_line)
-{
-  /* See checking_free for rationale of this abort.  We repeat it here
-     because we can print the file and the line where the offending
-     free occurred.  */
-  if (ptr == NULL)
-    {
-      fprintf (stderr, "%s: xfree(NULL) at %s:%d\n",
-               exec_name, source_file, source_line);
-      abort ();
-    }
-  if (!unregister_ptr (ptr))
-    {
-      fprintf (stderr, "%s: bad xfree(0x%0*lx) at %s:%d\n",
-               exec_name, PTR_FORMAT (ptr), source_file, source_line);
-      abort ();
-    }
-  ++free_count;
-
-  checking_free (ptr);
-}
-
-#endif /* DEBUG_MALLOC */
diff --git a/src/xmalloc.h b/src/xmalloc.h
deleted file mode 100644
index ce326b1..0000000
--- a/src/xmalloc.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* xmalloc.c declarations.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation,
-   Inc.
-
-This file is part of GNU Wget.
-
-GNU Wget is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3 of the License, or
-(at your option) any later version.
-
-GNU Wget is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Wget.  If not, see <http://www.gnu.org/licenses/>.
-
-Additional permission under GNU GPL version 3 section 7
-
-If you modify this program, or any covered work, by linking or
-combining it with the OpenSSL project's OpenSSL library (or a
-modified version of that library), containing parts covered by the
-terms of the OpenSSL or SSLeay licenses, the Free Software Foundation
-grants you additional permission to convey the resulting work.
-Corresponding Source for a non-source form of such a combination
-shall include the source code for the parts of OpenSSL used as well
-as that of the covered work.  */
-
-#ifndef XMALLOC_H
-#define XMALLOC_H
-
-/* Croak the fatal memory error and bail out with non-zero exit
-   status.  */
-void memfatal (const char *context, long attempted_size);
-
-/* Constant is using when we don`t know attempted size exactly */
-#define UNKNOWN_ATTEMPTED_SIZE -3
-
-/* Define this to use Wget's builtin malloc debugging, which is crude
-   but occasionally useful.  It will make Wget a lot slower and
-   larger, and susceptible to aborting if malloc_table overflows, so
-   it should be used by developers only.  */
-#undef DEBUG_MALLOC
-
-/* When DEBUG_MALLOC is not defined (which is normally the case), the
-   allocator identifiers are mapped to checking_* wrappers, which exit
-   Wget if malloc/realloc/strdup return NULL
-
-   In DEBUG_MALLOC mode, the allocators are mapped to debugging_*
-   wrappers, which also record the file and line from which the
-   allocation was attempted.  At the end of the program, a detailed
-   summary of unfreed allocations is displayed.
-
-   *Note*: xfree(NULL) aborts in both modes.  If the pointer you're
-   freeing can be NULL, use xfree_null instead.  */
-
-#ifndef DEBUG_MALLOC
-
-#define xmalloc  checking_malloc
-#define xmalloc0 checking_malloc0
-#define xrealloc checking_realloc
-#define xstrdup  checking_strdup
-#define xfree    checking_free
-
-void *checking_malloc (size_t);
-void *checking_malloc0 (size_t);
-void *checking_realloc (void *, size_t);
-char *checking_strdup (const char *);
-void checking_free (void *);
-
-#else  /* DEBUG_MALLOC */
-
-#define xmalloc(s)     debugging_malloc (s, __FILE__, __LINE__)
-#define xmalloc0(s)    debugging_malloc0 (s, __FILE__, __LINE__)
-#define xrealloc(p, s) debugging_realloc (p, s, __FILE__, __LINE__)
-#define xstrdup(p)     debugging_strdup (p, __FILE__, __LINE__)
-#define xfree(p)       debugging_free (p, __FILE__, __LINE__)
-
-void *debugging_malloc (size_t, const char *, int);
-void *debugging_malloc0 (size_t, const char *, int);
-void *debugging_realloc (void *, size_t, const char *, int);
-char *debugging_strdup (const char *, const char *, int);
-void debugging_free (void *, const char *, int);
-
-#endif /* DEBUG_MALLOC */
-
-/* Macros that interface to malloc, but know about type sizes, and
-   cast the result to the appropriate type.  The casts are not
-   necessary in standard C, but Wget performs them anyway for the sake
-   of pre-standard environments and possibly C++.  */
-
-#define xnew(type) (xmalloc (sizeof (type)))
-#define xnew0(type) (xmalloc0 (sizeof (type)))
-#define xnew_array(type, len) (xmalloc ((len) * sizeof (type)))
-#define xnew0_array(type, len) (xmalloc0 ((len) * sizeof (type)))
-
-#define alloca_array(type, size) ((type *) alloca ((size) * sizeof (type)))
-
-/* Free P if it is non-NULL.  C requires free() to behaves this way by
-   default, but Wget's code is historically careful not to pass NULL
-   to free.  This allows us to assert p!=NULL in xfree to check
-   additional errors.  (But we currently don't do that!)  */
-#define xfree_null(p) if (!(p)) ; else xfree (p)
-
-#endif /* XMALLOC_H */
-- 
cgit v1.0-41-gc330


From 2c772204111e678b7715937052c3e7217a42e1ad Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sun, 20 Apr 2008 11:46:52 +0200
Subject: Undo the USE_GNULIB_ALLOC defines.

---
 src/cmpt.c       | 2 --
 src/connect.c    | 2 --
 src/convert.c    | 2 --
 src/cookies.c    | 2 --
 src/ftp-basic.c  | 2 --
 src/ftp-ls.c     | 2 --
 src/ftp-opie.c   | 2 --
 src/ftp.c        | 2 --
 src/gen-md5.c    | 2 --
 src/gnutls.c     | 2 --
 src/hash.c       | 2 --
 src/host.c       | 2 --
 src/html-parse.c | 2 --
 src/html-url.c   | 2 --
 src/http-ntlm.c  | 2 --
 src/http.c       | 2 --
 src/init.c       | 2 --
 src/log.c        | 2 --
 src/main.c       | 2 --
 src/mswindows.c  | 2 --
 src/netrc.c      | 2 --
 src/openssl.c    | 2 --
 src/progress.c   | 2 --
 src/ptimer.c     | 2 --
 src/recur.c      | 2 --
 src/res.c        | 2 --
 src/retr.c       | 2 --
 src/snprintf.c   | 2 --
 src/spider.c     | 2 --
 src/test.c       | 2 --
 src/url.c        | 2 --
 src/utils.c      | 2 --
 src/utils.h      | 4 ----
 src/wget.h       | 8 ++------
 34 files changed, 2 insertions(+), 74 deletions(-)

diff --git a/src/cmpt.c b/src/cmpt.c
index 6726b7f..499a0fe 100644
--- a/src/cmpt.c
+++ b/src/cmpt.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/connect.c b/src/connect.c
index 361eb56..2626ef3 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/convert.c b/src/convert.c
index 9f60ae3..69d713f 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/cookies.c b/src/cookies.c
index 1258472..bdc3274 100644
--- a/src/cookies.c
+++ b/src/cookies.c
@@ -43,8 +43,6 @@ as that of the covered work.  */
    sites that do send Set-Cookie2 also emit Set-Cookie for
    compatibility.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ftp-basic.c b/src/ftp-basic.c
index 9145fe7..38f0069 100644
--- a/src/ftp-basic.c
+++ b/src/ftp-basic.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <assert.h>
diff --git a/src/ftp-ls.c b/src/ftp-ls.c
index 67e9bc5..e050c5a 100644
--- a/src/ftp-ls.c
+++ b/src/ftp-ls.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ftp-opie.c b/src/ftp-opie.c
index 5d740a1..546e210 100644
--- a/src/ftp-opie.c
+++ b/src/ftp-opie.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ftp.c b/src/ftp.c
index 134c925..645e565 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/gen-md5.c b/src/gen-md5.c
index d4d5f5c..833f3f2 100644
--- a/src/gen-md5.c
+++ b/src/gen-md5.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include "gen-md5.h"
diff --git a/src/gnutls.c b/src/gnutls.c
index 258c015..57d4ad5 100644
--- a/src/gnutls.c
+++ b/src/gnutls.c
@@ -27,8 +27,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <assert.h>
diff --git a/src/hash.c b/src/hash.c
index f8b3c11..4697b77 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -31,8 +31,6 @@ as that of the covered work.  */
 /* With -DSTANDALONE, this file can be compiled outside Wget source
    tree.  To test, also use -DTEST.  */
 
-#define USE_GNULIB_ALLOC
-
 #ifndef STANDALONE
 # include "wget.h"
 #endif
diff --git a/src/host.c b/src/host.c
index 1b418ce..5a53022 100644
--- a/src/host.c
+++ b/src/host.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/html-parse.c b/src/html-parse.c
index 623b7fd..fdf5b99 100644
--- a/src/html-parse.c
+++ b/src/html-parse.c
@@ -89,8 +89,6 @@ as that of the covered work.  */
 /* To test as standalone, compile with `-DSTANDALONE -I.'.  You'll
    still need Wget headers to compile.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #ifdef STANDALONE
diff --git a/src/html-url.c b/src/html-url.c
index 717fe8c..e9f2773 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/http-ntlm.c b/src/http-ntlm.c
index 321d70d..def832b 100644
--- a/src/http-ntlm.c
+++ b/src/http-ntlm.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 /* NTLM details:
diff --git a/src/http.c b/src/http.c
index 84bbe2e..c1049d8 100644
--- a/src/http.c
+++ b/src/http.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/init.c b/src/init.c
index 1a5171c..e079df9 100644
--- a/src/init.c
+++ b/src/init.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/log.c b/src/log.c
index 077ebeb..f7b3dca 100644
--- a/src/log.c
+++ b/src/log.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/main.c b/src/main.c
index 04ff76f..b1e9969 100644
--- a/src/main.c
+++ b/src/main.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/mswindows.c b/src/mswindows.c
index c64da02..cdfea2d 100644
--- a/src/mswindows.c
+++ b/src/mswindows.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #define INHIBIT_WRAP /* avoid wrapping of socket, bind, ... */
 
 #include "wget.h"
diff --git a/src/netrc.c b/src/netrc.c
index 35163a6..fea440d 100644
--- a/src/netrc.c
+++ b/src/netrc.c
@@ -30,8 +30,6 @@ as that of the covered work.  */
 /* This file used to be kept in synch with the code in Fetchmail, but
    the latter has diverged since.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/openssl.c b/src/openssl.c
index d35aba3..03fb181 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -29,8 +29,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <assert.h>
diff --git a/src/progress.c b/src/progress.c
index 62e8d87..8b9b101 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/ptimer.c b/src/ptimer.c
index 0f5b5db..1e8c43c 100644
--- a/src/ptimer.c
+++ b/src/ptimer.c
@@ -50,8 +50,6 @@ as that of the covered work.  */
      double secs = ptimer_measure ();
      printf ("The loop took %.2fs\n", secs);  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/recur.c b/src/recur.c
index a992230..d1d0f18 100644
--- a/src/recur.c
+++ b/src/recur.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/res.c b/src/res.c
index 94d9769..8c35f0e 100644
--- a/src/res.c
+++ b/src/res.c
@@ -67,8 +67,6 @@ as that of the covered work.  */
    res_match_path, res_register_specs, res_get_specs, and
    res_retrieve_file.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/retr.c b/src/retr.c
index 60d4c62..179430a 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/snprintf.c b/src/snprintf.c
index 2a8fc6e..f458981 100644
--- a/src/snprintf.c
+++ b/src/snprintf.c
@@ -87,8 +87,6 @@
  *
  **************************************************************/
 
-#define USE_GNULIB_ALLOC
-
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
diff --git a/src/spider.c b/src/spider.c
index 7025409..08fefc9 100644
--- a/src/spider.c
+++ b/src/spider.c
@@ -27,8 +27,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/test.c b/src/test.c
index d6a8659..04658bc 100644
--- a/src/test.c
+++ b/src/test.c
@@ -27,8 +27,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include <stdio.h>
 
 #include "test.h"
diff --git a/src/url.c b/src/url.c
index 997b105..a561725 100644
--- a/src/url.c
+++ b/src/url.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/utils.c b/src/utils.c
index 3459be9..c4f78fe 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -28,8 +28,6 @@ Corresponding Source for a non-source form of such a combination
 shall include the source code for the parts of OpenSSL used as well
 as that of the covered work.  */
 
-#define USE_GNULIB_ALLOC
-
 #include "wget.h"
 
 #include <stdio.h>
diff --git a/src/utils.h b/src/utils.h
index bac112e..d3ae9b3 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -31,8 +31,6 @@ as that of the covered work.  */
 #ifndef UTILS_H
 #define UTILS_H
 
-#ifdef USE_GNULIB_ALLOC
-
 /* Constant is using when we don`t know attempted size exactly */
 #define UNKNOWN_ATTEMPTED_SIZE -3
 
@@ -55,8 +53,6 @@ as that of the covered work.  */
    additional errors.  (But we currently don't do that!)  */
 #define xfree_null(p) if (!(p)) ; else xfree (p)
 
-#endif /* USE_GNULIB_ALLOC */
-
 struct hash_table;
 
 struct file_memory {
diff --git a/src/wget.h b/src/wget.h
index a0122db..561e9cf 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -208,12 +208,8 @@ typedef double SUM_SIZE_INT;
 #include "options.h"
 
 /* Everything uses this, so include them here directly.  */
-#ifdef USE_GNULIB_ALLOC
-# include <alloca.h>
-# include "xalloc.h"
-#else
-# include "xmalloc.h"
-#endif
+#include <alloca.h>
+#include "xalloc.h"
 
 /* Likewise for logging functions.  */
 #include "log.h"
-- 
cgit v1.0-41-gc330


From 1897176633a207f4e84b90d954c426eb7cfb205f Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Thu, 24 Apr 2008 21:43:09 +0200
Subject: Further quote*()-related integrations in connect.c.

---
 src/connect.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/connect.c b/src/connect.c
index 2626ef3..1e8f07e 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -268,7 +268,7 @@ connect_to_ip (const ip_address *ip, int port, const char *print)
       const char *txt_addr = print_address (ip);
       if (print && 0 != strcmp (print, txt_addr))
         logprintf (LOG_VERBOSE, _("Connecting to %s|%s|:%d... "),
-                   escnonprint (print), txt_addr, port);
+                   escnonprint_uri (print), txt_addr, port);
       else
         logprintf (LOG_VERBOSE, _("Connecting to %s:%d... "), txt_addr, port);
     }
-- 
cgit v1.0-41-gc330


From a52fa6056bb7c66803d7448765159359deaeea63 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 25 Apr 2008 21:18:07 +0200
Subject: Include Gnulib quotearg header.

---
 src/wget.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/wget.h b/src/wget.h
index 561e9cf..8e2d387 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -216,6 +216,7 @@ typedef double SUM_SIZE_INT;
 
 /* Likewise for quoting functions.  */
 #include "quote.h"
+#include "quotearg.h"
 
 /* Useful macros used across the code: */
 
-- 
cgit v1.0-41-gc330


From 0d41823272337b34c01f547d0cfee06983f5e1f3 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 25 Apr 2008 22:31:08 +0200
Subject: Further quote*()-related integrations in cookies.c.

---
 src/cookies.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/cookies.c b/src/cookies.c
index bdc3274..147695c 100644
--- a/src/cookies.c
+++ b/src/cookies.c
@@ -441,7 +441,8 @@ parse_set_cookie (const char *set_cookie, bool silent)
   if (!silent)
     logprintf (LOG_NOTQUIET,
                _("Syntax error in Set-Cookie: %s at position %d.\n"),
-               escnonprint (set_cookie), (int) (ptr - set_cookie));
+               quotearg_style (escape_quoting_style, set_cookie), 
+               (int) (ptr - set_cookie));
   delete_cookie (cookie);
   return NULL;
 }
@@ -683,7 +684,8 @@ cookie_handle_set_cookie (struct cookie_jar *jar,
         {
           logprintf (LOG_NOTQUIET,
                      _("Cookie coming from %s attempted to set domain to %s\n"),
-                     escnonprint (host), escnonprint (cookie->domain));
+                     quotearg_style (escape_quoting_style, host), 
+                     quotearg_style (escape_quoting_style, cookie->domain));
           xfree (cookie->domain);
           goto copy_domain;
         }
-- 
cgit v1.0-41-gc330


From b23251aac217c8f367820a817712eb5fa5b56228 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 25 Apr 2008 22:38:51 +0200
Subject: Further quote*()-related integrations in ftp-basic.c.

---
 src/ftp-basic.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/ftp-basic.c b/src/ftp-basic.c
index 38f0069..36b11bc 100644
--- a/src/ftp-basic.c
+++ b/src/ftp-basic.c
@@ -76,9 +76,10 @@ ftp_response (int fd, char **ret_line)
         *--p = '\0';
 
       if (opt.server_response)
-        logprintf (LOG_NOTQUIET, "%s\n", escnonprint (line));
+        logprintf (LOG_NOTQUIET, "%s\n", 
+                   quotearg_style (escape_quoting_style, line));
       else
-        DEBUGP (("%s\n", escnonprint (line)));
+        DEBUGP (("%s\n", quotearg_style (escape_quoting_style, line)));
 
       /* The last line of output is the one that begins with "ddd ". */
       if (c_isdigit (line[0]) && c_isdigit (line[1]) && c_isdigit (line[2])
@@ -116,7 +117,8 @@ ftp_request (const char *command, const char *value)
             if (*p == '\r' || *p == '\n')
               *p = ' ';
           DEBUGP (("\nDetected newlines in %s \"%s\"; changing to %s \"%s\"\n",
-                   command, escnonprint (value), command, escnonprint (defanged)));
+                   command, quotearg_style (escape_quoting_style, value), 
+                   command, quotearg_style (escape_quoting_style, defanged)));
           /* Make VALUE point to the defanged copy of the string. */
           value = defanged;
         }
-- 
cgit v1.0-41-gc330


From 1fea56d6b64b9a47374ff33ea218cadadf04526c Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 25 Apr 2008 22:55:06 +0200
Subject: Further quote*()-related integrations in ftp.c.

---
 src/ftp.c | 39 +++++++++++++++++++++++----------------
 1 file changed, 23 insertions(+), 16 deletions(-)

diff --git a/src/ftp.c b/src/ftp.c
index 645e565..06e4493 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -300,7 +300,8 @@ getftp (struct url *u, wgint *len, wgint restval, ccon *con)
         con->csock = -1;
 
       /* Second: Login with proper USER/PASS sequence.  */
-      logprintf (LOG_VERBOSE, _("Logging in as %s ... "), escnonprint (user));
+      logprintf (LOG_VERBOSE, _("Logging in as %s ... "), 
+                 quotearg_style (escape_quoting_style, user));
       if (opt.server_response)
         logputs (LOG_ALWAYS, "\n");
       err = ftp_login (csock, logname, passwd);
@@ -545,7 +546,8 @@ Error in server response, closing control connection.\n"));
             }
 
           if (!opt.server_response)
-            logprintf (LOG_VERBOSE, "==> CWD %s ... ", escnonprint (target));
+            logprintf (LOG_VERBOSE, "==> CWD %s ... ", 
+                       quotearg_style (escape_quoting_style, target));
           err = ftp_cwd (csock, target);
           /* FTPRERR, WRITEFAILED, FTPNSFOD */
           switch (err)
@@ -567,7 +569,7 @@ Error in server response, closing control connection.\n"));
             case FTPNSFOD:
               logputs (LOG_VERBOSE, "\n");
               logprintf (LOG_NOTQUIET, _("No such directory %s.\n\n"),
-                         quote (escnonprint (u->dir)));
+                         quote (u->dir));
               fd_close (csock);
               con->csock = -1;
               return err;
@@ -588,7 +590,8 @@ Error in server response, closing control connection.\n"));
       if (opt.verbose)
         {
           if (!opt.server_response)
-            logprintf (LOG_VERBOSE, "==> SIZE %s ... ", escnonprint (u->file));
+            logprintf (LOG_VERBOSE, "==> SIZE %s ... ", 
+                       quotearg_style (escape_quoting_style, u->file));
         }
 
       err = ftp_size (csock, u->file, len);
@@ -795,7 +798,8 @@ Error in server response, closing control connection.\n"));
             {
               if (restval)
                 logputs (LOG_VERBOSE, "\n");
-              logprintf (LOG_VERBOSE, "==> RETR %s ... ", escnonprint (u->file));
+              logprintf (LOG_VERBOSE, "==> RETR %s ... ", 
+                         quotearg_style (escape_quoting_style, u->file));
             }
         }
 
@@ -824,7 +828,7 @@ Error in server response, closing control connection.\n"));
         case FTPNSFOD:
           logputs (LOG_VERBOSE, "\n");
           logprintf (LOG_NOTQUIET, _("No such file %s.\n\n"),
-                     quote (escnonprint (u->file)));
+                     quote (u->file));
           fd_close (dtsock);
           fd_close (local_sock);
           return err;
@@ -1063,7 +1067,8 @@ Error in server response, closing control connection.\n"));
               char *p = strchr (line, '\0');
               while (p > line && (p[-1] == '\n' || p[-1] == '\r'))
                 *--p = '\0';
-              logprintf (LOG_ALWAYS, "%s\n", escnonprint (line));
+              logprintf (LOG_ALWAYS, "%s\n", 
+                         quotearg_style (escape_quoting_style, line));
               xfree (line);
             }
           fclose (fp);
@@ -1487,14 +1492,15 @@ The sizes do not match (local %s) -- retrieving.\n\n"),
                             {
                               logprintf (LOG_VERBOSE, _("\
 Already have correct symlink %s -> %s\n\n"),
-                                         con->target, escnonprint (f->linkto));
+                                         con->target, 
+                                         quotearg_style (escape_quoting_style, f->linkto));
                               dlthis = false;
                               break;
                             }
                         }
                     }
                   logprintf (LOG_VERBOSE, _("Creating symlink %s -> %s\n"),
-                             con->target, escnonprint (f->linkto));
+                             con->target, quotearg_style (escape_quoting_style, f->linkto));
                   /* Unlink before creating symlink!  */
                   unlink (con->target);
                   if (symlink (f->linkto, con->target) == -1)
@@ -1516,7 +1522,7 @@ Already have correct symlink %s -> %s\n\n"),
         case FT_DIRECTORY:
           if (!opt.recursive)
             logprintf (LOG_NOTQUIET, _("Skipping directory %s.\n"),
-                       quote (escnonprint (f->name)));
+                       quote (f->name));
           break;
         case FT_PLAINFILE:
           /* Call the retrieve loop.  */
@@ -1525,7 +1531,7 @@ Already have correct symlink %s -> %s\n\n"),
           break;
         case FT_UNKNOWN:
           logprintf (LOG_NOTQUIET, _("%s: unknown/unsupported file type.\n"),
-                     escnonprint (f->name));
+                     quotearg_style (escape_quoting_style, f->name));
           break;
         }       /* switch */
 
@@ -1631,7 +1637,7 @@ ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)
         {
           logprintf (LOG_VERBOSE, _("\
 Not descending to %s as it is excluded/not-included.\n"),
-                     quote (escnonprint (newdir)));
+                     quote (newdir));
           continue;
         }
 
@@ -1696,7 +1702,7 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
           if (f->type != FT_DIRECTORY && !acceptable (f->name))
             {
               logprintf (LOG_VERBOSE, _("Rejecting %s.\n"),
-                         quote (escnonprint (f->name)));
+                         quote (f->name));
               f = delelement (f, &start);
             }
           else
@@ -1710,7 +1716,7 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
       if (has_insecure_name_p (f->name))
         {
           logprintf (LOG_VERBOSE, _("Rejecting %s.\n"),
-                     quote (escnonprint (f->name)));
+                     quote (f->name));
           f = delelement (f, &start);
         }
       else
@@ -1733,7 +1739,8 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
               if (matchres == -1)
                 {
                   logprintf (LOG_NOTQUIET, _("Error matching %s against %s: %s\n"),
-                             u->file, escnonprint (f->name), strerror (errno));
+                             u->file, quotearg_style (escape_quoting_style, f->name), 
+                             strerror (errno));
                   break;
                 }
               if (matchres == FNM_NOMATCH)
@@ -1774,7 +1781,7 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
           /* #### This message SUCKS.  We should see what was the
              reason that nothing was retrieved.  */
           logprintf (LOG_VERBOSE, _("No matches on pattern %s.\n"),
-                     quote (escnonprint (u->file)));
+                     quote (u->file));
         }
       else /* GLOB_GETONE or GLOB_GETALL */
         {
-- 
cgit v1.0-41-gc330


From 070cf12e40400156ee5483ae341c2fe0418b3b20 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 25 Apr 2008 23:01:33 +0200
Subject: Further quote*()-related integrations in gnutls.c.

---
 src/gnutls.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/gnutls.c b/src/gnutls.c
index 57d4ad5..5480cde 100644
--- a/src/gnutls.c
+++ b/src/gnutls.c
@@ -223,7 +223,7 @@ ssl_check_certificate (int fd, const char *host)
   if (err < 0)
     {
       logprintf (LOG_NOTQUIET, _("%s: No certificate presented by %s.\n"),
-                 severity, escnonprint (host));
+                 severity, quotearg_style (escape_quoting_style, host));
       success = false;
       goto out;
     }
@@ -231,19 +231,19 @@ ssl_check_certificate (int fd, const char *host)
   if (status & GNUTLS_CERT_INVALID)
     {
       logprintf (LOG_NOTQUIET, _("%s: The certificate of %s is not trusted.\n"),
-                 severity, quote (escnonprint (host)));
+                 severity, quote (host));
       success = false;
     }
   if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
     {
       logprintf (LOG_NOTQUIET, _("%s: The certificate of %s hasn't got a known issuer.\n"),
-                 severity, quote (escnonprint (host)));
+                 severity, quote (host));
       success = false;
     }
   if (status & GNUTLS_CERT_REVOKED)
     {
       logprintf (LOG_NOTQUIET, _("%s: The certificate of %s has been revoked.\n"),
-                 severity, quote (escnonprint (host)));
+                 severity, quote (host));
       success = false;
     }
 
-- 
cgit v1.0-41-gc330


From 12db0ebf11ef0d991792112c87bfe447904ea37c Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Fri, 25 Apr 2008 23:05:54 +0200
Subject: Further quote*()-related integrations in host.c.

---
 src/host.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/host.c b/src/host.c
index 5a53022..fdb35b1 100644
--- a/src/host.c
+++ b/src/host.c
@@ -712,7 +712,8 @@ lookup_host (const char *host, int flags)
   /* No luck with the cache; resolve HOST. */
 
   if (!silent && !numeric_address)
-    logprintf (LOG_VERBOSE, _("Resolving %s... "), escnonprint (host));
+    logprintf (LOG_VERBOSE, _("Resolving %s... "), 
+               quotearg_style (escape_quoting_style, host));
 
 #ifdef ENABLE_IPV6
   {
-- 
cgit v1.0-41-gc330


From 883ff345374e2223f7badbafbd2010516bc35c49 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 26 Apr 2008 14:25:50 +0200
Subject: Further quote*()-related integrations in http.c.

---
 src/http.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/src/http.c b/src/http.c
index c1049d8..5b04fe4 100644
--- a/src/http.c
+++ b/src/http.c
@@ -810,7 +810,8 @@ print_response_line(const char *prefix, const char *b, const char *e)
 {
   char *copy;
   BOUNDED_TO_ALLOCA(b, e, copy);
-  logprintf (LOG_VERBOSE, "%s%s\n", prefix, escnonprint(copy));
+  logprintf (LOG_VERBOSE, "%s%s\n", prefix, 
+             quotearg_style (escape_quoting_style, copy));
 }
 
 /* Print the server response, line by line, omitting the trailing CRLF
@@ -1629,7 +1630,8 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
           sock = pconn.socket;
           using_ssl = pconn.ssl;
           logprintf (LOG_VERBOSE, _("Reusing existing connection to %s:%d.\n"),
-                     escnonprint (pconn.host), pconn.port);
+                     quotearg_style (escape_quoting_style, pconn.host), 
+                     pconn.port);
           DEBUGP (("Reusing fd %d.\n", sock));
           if (pconn.authorized)
             /* If the connection is already authorized, the "Basic"
@@ -1717,7 +1719,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
             {
             failed_tunnel:
               logprintf (LOG_NOTQUIET, _("Proxy tunneling failed: %s"),
-                         message ? escnonprint (message) : "?");
+                         message ? quotearg_style (escape_quoting_style, message) : "?");
               xfree_null (message);
               return CONSSLERR;
             }
@@ -1795,7 +1797,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
   statcode = resp_status (resp, &message);
   if (!opt.server_response)
     logprintf (LOG_VERBOSE, "%2d %s\n", statcode,
-               message ? escnonprint (message) : "");
+               message ? quotearg_style (escape_quoting_style, message) : "");
   else
     {
       logprintf (LOG_VERBOSE, "\n");
@@ -2205,7 +2207,7 @@ File %s already there; not retrieving.\n\n"), quote (hs->local_file));
             logputs (LOG_VERBOSE,
                      opt.ignore_length ? _("ignored") : _("unspecified"));
           if (type)
-            logprintf (LOG_VERBOSE, " [%s]\n", escnonprint (type));
+            logprintf (LOG_VERBOSE, " [%s]\n", quotearg_style (escape_quoting_style, type));
           else
             logputs (LOG_VERBOSE, "\n");
         }
@@ -2576,7 +2578,8 @@ Remote file does not exist -- broken link!!!\n"));
           else
             {
               logprintf (LOG_NOTQUIET, _("%s ERROR %d: %s.\n"),
-                         tms, hstat.statcode, escnonprint (hstat.error));
+                         tms, hstat.statcode, 
+                         quotearg_style (escape_quoting_style, hstat.error));
             }
           logputs (LOG_VERBOSE, "\n");
           ret = WRONGCODE;
-- 
cgit v1.0-41-gc330


From aeced96fae69afd450d8d9e243a66e6ae4c988c0 Mon Sep 17 00:00:00 2001
From: Steven Schubiger <schubiger@gmail.com>
Date: Sat, 26 Apr 2008 14:34:30 +0200
Subject: Further quote*()-related integrations in openssl.c.

---
 src/openssl.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/src/openssl.c b/src/openssl.c
index 03fb181..8a5cc0e 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -495,7 +495,7 @@ ssl_check_certificate (int fd, const char *host)
   if (!cert)
     {
       logprintf (LOG_NOTQUIET, _("%s: No certificate presented by %s.\n"),
-                 severity, escnonprint (host));
+                 severity, quotearg_style (escape_quoting_style, host));
       success = false;
       goto no_cert;             /* must bail out since CERT is NULL */
     }
@@ -505,7 +505,8 @@ ssl_check_certificate (int fd, const char *host)
       char *subject = X509_NAME_oneline (X509_get_subject_name (cert), 0, 0);
       char *issuer = X509_NAME_oneline (X509_get_issuer_name (cert), 0, 0);
       DEBUGP (("certificate:\n  subject: %s\n  issuer:  %s\n",
-               escnonprint (subject), escnonprint (issuer)));
+               quotearg_style (escape_quoting_style, subject), 
+               quotearg_style (escape_quoting_style, issuer)));
       OPENSSL_free (subject);
       OPENSSL_free (issuer);
     }
@@ -516,7 +517,8 @@ ssl_check_certificate (int fd, const char *host)
       char *issuer = X509_NAME_oneline (X509_get_issuer_name (cert), 0, 0);
       logprintf (LOG_NOTQUIET,
                  _("%s: cannot verify %s's certificate, issued by %s:\n"),
-                 severity, escnonprint (host), quote (escnonprint (issuer)));
+                 severity, quotearg_style (escape_quoting_style, host), 
+                 quote (issuer));
       /* Try to print more user-friendly (and translated) messages for
          the frequent verification errors.  */
       switch (vresult)
@@ -567,20 +569,20 @@ ssl_check_certificate (int fd, const char *host)
     {
       logprintf (LOG_NOTQUIET, _("\
 %s: certificate common name %s doesn't match requested host name %s.\n"),
-                 severity, quote (escnonprint (common_name)), quote (escnonprint (host)));
+                 severity, quote (common_name), quote (host));
       success = false;
     }
 
   if (success)
     DEBUGP (("X509 certificate successfully verified and matches host %s\n",
-             escnonprint (host)));
+             quotearg_style (escape_quoting_style, host)));
   X509_free (cert);
 
  no_cert:
   if (opt.check_cert && !success)
     logprintf (LOG_NOTQUIET, _("\
 To connect to %s insecurely, use `--no-check-certificate'.\n"),
-               escnonprint (host));
+               quotearg_style (escape_quoting_style, host));
 
   /* Allow --no-check-cert to disable certificate checking. */
   return opt.check_cert ? success : true;
-- 
cgit v1.0-41-gc330


From 3323b84c30b9d7fa16a6065225cb7135e7a6bcd7 Mon Sep 17 00:00:00 2001
From: Micah Cowan <micah@cowan.name>
Date: Wed, 14 May 2008 22:26:15 -0700
Subject: Quoting tweaks.

---
 src/ChangeLog | 5 +++++
 src/ftp.c     | 8 ++++----
 2 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index 8bdd95c..c2db9da 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,8 @@
+2008-05-14  Micah Cowan  <micah@cowan.name>
+
+	* ftp.c (ftp_retrieve_list): Symlinks and other filenames
+	should be fully quoted.
+
 2008-04-16  Steven Schubiger  <schubiger@gmail.com>
 
 	* ftp.c: Use Gnulib's quote function for printing filenames and
diff --git a/src/ftp.c b/src/ftp.c
index 06e4493..59ba1c1 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -1492,15 +1492,15 @@ The sizes do not match (local %s) -- retrieving.\n\n"),
                             {
                               logprintf (LOG_VERBOSE, _("\
 Already have correct symlink %s -> %s\n\n"),
-                                         con->target, 
-                                         quotearg_style (escape_quoting_style, f->linkto));
+                                         quote (con->target),
+                                         quote (f->linkto));
                               dlthis = false;
                               break;
                             }
                         }
                     }
                   logprintf (LOG_VERBOSE, _("Creating symlink %s -> %s\n"),
-                             con->target, quotearg_style (escape_quoting_style, f->linkto));
+                             quote (con->target), quote (f->linkto));
                   /* Unlink before creating symlink!  */
                   unlink (con->target);
                   if (symlink (f->linkto, con->target) == -1)
@@ -1531,7 +1531,7 @@ Already have correct symlink %s -> %s\n\n"),
           break;
         case FT_UNKNOWN:
           logprintf (LOG_NOTQUIET, _("%s: unknown/unsupported file type.\n"),
-                     quotearg_style (escape_quoting_style, f->name));
+                     quote (f->name));
           break;
         }       /* switch */
 
-- 
cgit v1.0-41-gc330

