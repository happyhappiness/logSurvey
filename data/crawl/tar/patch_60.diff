diff --git a/src/buffer.c b/src/buffer.c
index dfc8456..239d3f1 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -54,7 +54,7 @@ enum access_mode access_mode;   /* how do we handle the archive */
 off_t records_read;             /* number of records read from this archive */
 off_t records_written;          /* likewise, for records written */
 extern off_t records_skipped;   /* number of records skipped at the start
-                                   of the archive, defined in delete.c */   
+                                   of the archive, defined in delete.c */
 
 static off_t record_start_block; /* block ordinal at record_start */
 
@@ -175,8 +175,8 @@ set_start_time ()
   last_stat_time = start_time;
 }
 
-void
-set_volume_start_time ()
+static void
+set_volume_start_time (void)
 {
   gettime (&volume_start_time);
   last_stat_time = volume_start_time;
@@ -211,9 +211,9 @@ struct zip_magic
 {
   enum compress_type type;
   size_t length;
-  char *magic;
-  char *program;
-  char *option;
+  char const *magic;
+  char const *program;
+  char const *option;
 };
 
 static struct zip_magic const magic[] = {
@@ -234,7 +234,7 @@ static struct zip_magic const magic[] = {
 #define compress_program(t) magic[t].program
 
 /* Check if the file ARCHIVE is a compressed archive. */
-enum compress_type
+static enum compress_type
 check_compressed_archive (bool *pshort)
 {
   struct zip_magic const *p;
@@ -243,14 +243,14 @@ check_compressed_archive (bool *pshort)
 
   if (!pshort)
     pshort = &temp;
-  
+
   /* Prepare global data needed for find_next_block: */
   record_end = record_start; /* set up for 1st record = # 0 */
   sfr = read_full_records;
   read_full_records = true; /* Suppress fatal error on reading a partial
                                record */
   *pshort = find_next_block () == 0;
-  
+
   /* Restore global values */
   read_full_records = sfr;
 
@@ -267,7 +267,7 @@ check_compressed_archive (bool *pshort)
 
 /* Guess if the archive is seekable. */
 static void
-guess_seekable_archive ()
+guess_seekable_archive (void)
 {
   struct stat st;
 
@@ -288,7 +288,7 @@ guess_seekable_archive ()
       seekable_archive = !!seek_option;
       return;
     }
-  
+
   if (!multi_volume_option && !use_compress_program_option
       && fstat (archive, &st) == 0)
     seekable_archive = S_ISREG (st.st_mode);
@@ -299,8 +299,8 @@ guess_seekable_archive ()
 /* Open an archive named archive_name_array[0]. Detect if it is
    a compressed archive of known type and use corresponding decompression
    program if so */
-int
-open_compressed_archive ()
+static int
+open_compressed_archive (void)
 {
   archive = rmtopen (archive_name_array[0], O_RDONLY | O_BINARY,
                      MODE_RW, rsh_command_option);
@@ -320,7 +320,7 @@ open_compressed_archive ()
               if (shortfile)
                 ERROR ((0, 0, _("This does not look like a tar archive")));
               return archive;
-      
+
             case ct_none:
               if (shortfile)
                 ERROR ((0, 0, _("This does not look like a tar archive")));
@@ -334,10 +334,10 @@ open_compressed_archive ()
               break;
             }
         }
-      
+
       /* FD is not needed any more */
       rmtclose (archive);
-      
+
       hit_eof = false; /* It might have been set by find_next_block in
                           check_compressed_archive */
 
@@ -486,7 +486,7 @@ xclose (int fd)
 }
 
 static void
-init_buffer ()
+init_buffer (void)
 {
   if (! record_buffer_aligned[record_index])
     record_buffer_aligned[record_index] =
@@ -657,7 +657,7 @@ _open_archive (enum access_mode wanted_access)
 }
 
 /* Perform a write to flush the buffer.  */
-ssize_t
+static ssize_t
 _flush_write (void)
 {
   ssize_t status;
@@ -672,7 +672,7 @@ _flush_write (void)
     status = record_size;
   else
     status = sys_write_archive_buffer ();
-  
+
   return status;
 }
 
@@ -713,7 +713,7 @@ archive_read_error (void)
 }
 
 static bool
-archive_is_dev ()
+archive_is_dev (void)
 {
   struct stat st;
 
@@ -861,7 +861,7 @@ seek_archive (off_t size)
 
   if (size <= skipped)
     return 0;
-  
+
   /* Compute number of records to skip */
   nrec = (size - skipped) / record_size;
   if (nrec == 0)
@@ -956,7 +956,7 @@ closeout_volume_number (void)
 
 
 static void
-increase_volume_number ()
+increase_volume_number (void)
 {
   global_volno++;
   if (global_volno < 0)
@@ -964,13 +964,13 @@ increase_volume_number ()
   volno++;
 }
 
-void
+static void
 change_tape_menu (FILE *read_file)
 {
   char *input_buffer = NULL;
   size_t size = 0;
   bool stop = false;
-  
+
   while (!stop)
     {
       fputc ('\007', stderr);
@@ -1088,7 +1088,7 @@ new_volume (enum access_mode mode)
   assign_string (&continued_file_name, NULL);
   continued_file_size = continued_file_offset = 0;
   current_block = record_start;
-  
+
   if (rmtclose (archive) != 0)
     close_error (*archive_name_cursor);
 
@@ -1177,13 +1177,13 @@ read_header0 (struct tar_stat_info *info)
   return false;
 }
 
-bool
-try_new_volume ()
+static bool
+try_new_volume (void)
 {
   size_t status;
   union block *header;
   enum access_mode acc;
-  
+
   switch (subcommand_option)
     {
     case APPEND_SUBCOMMAND:
@@ -1199,7 +1199,7 @@ try_new_volume ()
 
   if (!new_volume (acc))
     return true;
-  
+
   while ((status = rmtread (archive, record_start->buffer, record_size))
          == SAFE_READ_ERROR)
     archive_read_error ();
@@ -1222,10 +1222,10 @@ try_new_volume ()
 	    ERROR ((0, 0, _("This does not look like a tar archive")));
 	    return false;
 	  }
-	
+
         xheader_decode (&dummy); /* decodes values from the global header */
         tar_stat_destroy (&dummy);
-	
+
 	/* The initial global header must be immediately followed by
 	   an extended PAX header for the first member in this volume.
 	   However, in some cases tar may split volumes in the middle
@@ -1237,7 +1237,7 @@ try_new_volume ()
 	   HEADER_FAILURE, which is ignored.
 
 	   See also tests/multiv07.at */
-	       
+
 	switch (read_header (&header, &dummy, read_header_auto))
 	  {
 	  case HEADER_SUCCESS:
@@ -1327,7 +1327,7 @@ try_new_volume ()
                  STRINGIFY_BIGINT (real_s_totsize, totsizebuf),
                  STRINGIFY_BIGINT (real_s_sizeleft, s1buf),
                  STRINGIFY_BIGINT (continued_file_offset, s2buf)));
-         
+
           return false;
         }
     }
@@ -1348,7 +1348,7 @@ drop_volume_label_suffix (const char *label)
 
   if (len < 1)
     return NULL;
-  
+
   for (p = label + len - 1; p > label && isdigit ((unsigned char) *p); p--)
     ;
   if (p > label && p - (VOLUME_TEXT_LEN - 1) > label)
@@ -1365,7 +1365,7 @@ drop_volume_label_suffix (const char *label)
 
   return NULL;
 }
-      
+
 /* Check LABEL against the volume label, seen as a globbing
    pattern.  Return true if the pattern matches.  In case of failure,
    retry matching a volume sequence number before giving up in
@@ -1399,7 +1399,7 @@ match_volume_label (void)
   if (!volume_label)
     {
       union block *label = find_next_block ();
-  
+
       if (!label)
 	FATAL_ERROR ((0, 0, _("Archive not labeled to match %s"),
 		      quote (volume_label_option)));
@@ -1425,11 +1425,11 @@ match_volume_label (void)
 	  tar_stat_destroy (&st);
 	}
     }
-  
+
   if (!volume_label)
     FATAL_ERROR ((0, 0, _("Archive not labeled to match %s"),
                   quote (volume_label_option)));
-  
+
   if (!check_label_pattern (volume_label))
     FATAL_ERROR ((0, 0, _("Volume %s does not match %s"),
                   quote_n (0, volume_label),
@@ -1477,7 +1477,7 @@ add_volume_label (void)
 }
 
 static void
-add_chunk_header ()
+add_chunk_header (void)
 {
   if (archive_format == POSIX_FORMAT)
     {
@@ -1568,7 +1568,7 @@ add_multi_volume_header (void)
 
 /* Synchronize multi-volume globals */
 static void
-multi_volume_sync ()
+multi_volume_sync (void)
 {
   if (multi_volume_option)
     {
@@ -1599,7 +1599,7 @@ simple_flush_read (void)
   size_t status;                /* result from system call */
 
   checkpoint_run (false);
-  
+
   /* Clear the count of errors.  This only applies to a single call to
      flush_read.  */
 
@@ -1658,7 +1658,7 @@ _gnu_flush_read (void)
   size_t status;                /* result from system call */
 
   checkpoint_run (false);
-  
+
   /* Clear the count of errors.  This only applies to a single call to
      flush_read.  */
 
@@ -1727,14 +1727,14 @@ _gnu_flush_write (size_t buffer_level)
   size_t copy_size;
   size_t bufsize;
   tarlong wrt;
-  
+
   status = _flush_write ();
   if (status != record_size && !multi_volume_option)
     archive_write_error (status);
   else
     {
       if (status)
-        records_written++; 
+        records_written++;
       bytes_written += status;
     }
 
@@ -1749,7 +1749,7 @@ _gnu_flush_write (size_t buffer_level)
       ERROR ((0, 0, _("write did not end on a block boundary")));
       archive_write_error (status);
     }
-  
+
   /* In multi-volume mode. */
   /* ENXIO is for the UNIX PC.  */
   if (status < 0 && errno != ENOSPC && errno != EIO && errno != ENXIO)
@@ -1767,7 +1767,7 @@ _gnu_flush_write (size_t buffer_level)
 
   copy_ptr = record_start->buffer + status;
   copy_size = buffer_level - status;
-                   
+
   /* Switch to the next buffer */
   record_index = !record_index;
   init_buffer ();
@@ -1780,7 +1780,7 @@ _gnu_flush_write (size_t buffer_level)
 
   write_extended (true, &dummy, find_next_block ());
   tar_stat_destroy (&dummy);
-  
+
   if (real_s_name)
     add_chunk_header ();
   wrt = bytes_written;
diff --git a/src/checkpoint.c b/src/checkpoint.c
index 9f031f7..a2896ab 100644
--- a/src/checkpoint.c
+++ b/src/checkpoint.c
@@ -77,7 +77,7 @@ void
 checkpoint_compile_action (const char *str)
 {
   struct checkpoint_action *act;
-  
+
   if (strcmp (str, ".") == 0 || strcmp (str, "dot") == 0)
     alloc_action (cop_dot);
   else if (strcmp (str, "bell") == 0)
@@ -119,14 +119,14 @@ checkpoint_finish_compile ()
     {
       if (!checkpoint_action)
 	/* Provide a historical default */
-	checkpoint_compile_action ("echo"); 
+	checkpoint_compile_action ("echo");
     }
   else if (checkpoint_action)
     /* Otherwise, set default checkpoint rate */
     checkpoint_option = DEFAULT_CHECKPOINT;
 }
 
-char *
+static char *
 expand_checkpoint_string (const char *input, bool do_write, unsigned cpn)
 {
   const char *opstr = do_write ? gettext ("write") : gettext ("read");
@@ -147,7 +147,7 @@ expand_checkpoint_string (const char *input, bool do_write, unsigned cpn)
 	case 'u':
 	  outlen += cpslen - 2;
 	  break;
-	  
+
 	case 's':
 	  outlen += opstrlen - 2;
 	}
@@ -164,11 +164,11 @@ expand_checkpoint_string (const char *input, bool do_write, unsigned cpn)
 	    case 'u':
 	      op = stpcpy (op, cps);
 	      break;
-	      
+
 	    case 's':
 	      op = stpcpy (op, opstr);
 	      break;
-	      
+
 	    default:
 	      *op++ = '%';
 	      *op++ = *ip;
@@ -188,7 +188,7 @@ run_checkpoint_actions (bool do_write)
 {
   struct checkpoint_action *p;
   FILE *tty = NULL;
-  
+
   for (p = checkpoint_action; p; p = p->next)
     {
       switch (p->opcode)
@@ -207,7 +207,7 @@ run_checkpoint_actions (bool do_write)
 	      fflush (tty);
 	    }
 	  break;
-	  
+
 	case cop_echo:
 	  {
 	    char *tmp;
@@ -232,7 +232,7 @@ run_checkpoint_actions (bool do_write)
 	    free (tmp);
 	  }
 	  break;
-	  
+
 	case cop_ttyout:
 	  if (!tty)
 	    tty = fopen ("/dev/tty", "w");
@@ -245,11 +245,11 @@ run_checkpoint_actions (bool do_write)
 	      free (tmp);
 	    }
 	  break;
-	  
+
 	case cop_sleep:
 	  sleep (p->v.time);
 	  break;
-	  
+
 	case cop_exec:
 	  sys_exec_checkpoint_script (p->v.command,
 				      archive_name_cursor[0],
@@ -266,5 +266,4 @@ checkpoint_run (bool do_write)
 {
   if (checkpoint_option && !(++checkpoint % checkpoint_option))
     run_checkpoint_actions (do_write);
-}  
-
+}
diff --git a/src/common.h b/src/common.h
index 3b91f46..9e42eec 100644
--- a/src/common.h
+++ b/src/common.h
@@ -1,7 +1,7 @@
 /* Common declarations for the tar program.
 
    Copyright (C) 1988, 1992, 1993, 1994, 1996, 1997, 1999, 2000, 2001,
-   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, 
+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
    Inc.
 
    This program is free software; you can redistribute it and/or modify it
@@ -337,12 +337,12 @@ struct name
     int matching_flags;         /* wildcard flags if name is a pattern */
     bool cmdline;               /* true if this name was given in the
 				   command line */
-    
+
     int change_dir;		/* Number of the directory to change to.
 				   Set with the -C option. */
     uintmax_t found_count;	/* number of times a matching file has
 				   been found */
-    
+
     /* The following members are used for incremental dumps only,
        if this struct name represents a directory;
        see incremen.c */
@@ -465,7 +465,7 @@ void exclusion_tag_warning (const char *dirname, const char *tagname,
 			    const char *message);
 enum exclusion_tag_type check_exclusion_tags (const char *dirname,
 					      const char **tag_file_name);
-     
+
 #define GID_TO_CHARS(val, where) gid_to_chars (val, where, sizeof (where))
 #define MAJOR_TO_CHARS(val, where) major_to_chars (val, where, sizeof (where))
 #define MINOR_TO_CHARS(val, where) minor_to_chars (val, where, sizeof (where))
@@ -692,6 +692,7 @@ struct name *addname (char const *string, int change_dir,
 void remname (struct name *name);
 bool name_match (const char *name);
 void names_notfound (void);
+void label_notfound (void);
 void collect_and_sort_names (void);
 struct name *name_scan (const char *name);
 struct name const *name_from_list (void);
@@ -858,4 +859,3 @@ void finish_deferred_unlinks (void);
 
 /* Module exit.c */
 extern void (*fatal_exit_hook) (void);
-
diff --git a/src/extract.c b/src/extract.c
index 531654a..c3a99e0 100644
--- a/src/extract.c
+++ b/src/extract.c
@@ -146,7 +146,7 @@ set_mode (char const *file_name,
 {
   mode_t mode;
   bool failed;
-  
+
   if (0 < same_permissions_option
       && permstatus != INTERDIR_PERMSTATUS)
     {
@@ -893,10 +893,10 @@ create_placeholder_file (char *file_name, bool is_symlink, int *interdir_made)
 	{
 	case RECOVER_OK:
 	  continue;
-	  
+
 	case RECOVER_SKIP:
 	  return 0;
-	  
+
 	case RECOVER_NO:
 	  open_error (file_name);
 	  return -1;
@@ -967,9 +967,9 @@ extract_link (char *file_name, int typeflag)
   int interdir_made = 0;
   char const *link_name;
   int rc;
-  
+
   link_name = current_stat_info.link_name;
-  
+
   if (! absolute_names_option && contains_dot_dot (link_name))
     return create_placeholder_file (file_name, false, &interdir_made);
 
@@ -1035,15 +1035,15 @@ extract_symlink (char *file_name, int typeflag)
       {
       case RECOVER_OK:
 	continue;
-	
+
       case RECOVER_SKIP:
 	return 0;
-	
+
       case RECOVER_NO:
 	symlink_error (current_stat_info.link_name, file_name);
 	return -1;
       }
-  
+
   set_stat (file_name, &current_stat_info, NULL, 0, 0, SYMTYPE);
   return 0;
 
@@ -1065,7 +1065,6 @@ extract_symlink (char *file_name, int typeflag)
 static int
 extract_node (char *file_name, int typeflag)
 {
-  int status;
   int interdir_made = 0;
   mode_t mode = current_stat_info.stat.st_mode & ~ current_umask;
   mode_t invert_permissions =
@@ -1077,10 +1076,10 @@ extract_node (char *file_name, int typeflag)
       {
       case RECOVER_OK:
 	continue;
-	
+
       case RECOVER_SKIP:
 	return 0;
-	
+
       case RECOVER_NO:
 	mknod_error (file_name);
 	return -1;
@@ -1088,7 +1087,7 @@ extract_node (char *file_name, int typeflag)
 
   set_stat (file_name, &current_stat_info, NULL, invert_permissions,
 	    ARCHIVED_PERMSTATUS, typeflag);
-  return status;
+  return 0;
 }
 #endif
 
@@ -1107,10 +1106,10 @@ extract_fifo (char *file_name, int typeflag)
       {
       case RECOVER_OK:
 	continue;
-	
+
       case RECOVER_SKIP:
 	return 0;
-	
+
       case RECOVER_NO:
 	mkfifo_error (file_name);
 	return -1;
@@ -1274,7 +1273,7 @@ extract_archive (void)
   tar_extractor_t fun;
 
   fatal_exit_hook = extract_finish;
-  
+
   /* Try to disable the ability to unlink a directory.  */
   priv_set_remove_linkdir ();
 
diff --git a/src/incremen.c b/src/incremen.c
index 0d0b4ff..e61eb79 100644
--- a/src/incremen.c
+++ b/src/incremen.c
@@ -84,7 +84,7 @@ dumpdir_create0 (const char *contents, const char *cmask)
   size_t i, total, ctsize, len;
   char *p;
   const char *q;
-  
+
   for (i = 0, total = 0, ctsize = 1, q = contents; *q; total++, q += len)
     {
       len = strlen (q) + 1;
@@ -146,7 +146,7 @@ dumpdir_locate (struct dumpdir *dump, const char *name)
 struct dumpdir_iter
 {
   struct dumpdir *dump; /* Dumpdir being iterated */
-  int all;              /* Iterate over all entries, not only D/N/Y */ 
+  int all;              /* Iterate over all entries, not only D/N/Y */
   size_t next;          /* Index of the next element */
 };
 
@@ -155,7 +155,7 @@ dumpdir_next (struct dumpdir_iter *itr)
 {
   size_t cur = itr->next;
   char *ret = NULL;
-  
+
   if (itr->all)
     {
       ret = itr->dump->contents + cur;
@@ -288,9 +288,9 @@ attach_directory (const char *name)
   dirtail = dir;
   return dir;
 }
-		 
+
 
-void
+static void
 dirlist_replace_prefix (const char *pref, const char *repl)
 {
   struct directory *dp;
@@ -414,7 +414,7 @@ update_parent_directory (const char *name)
       struct stat st;
       if (deref_stat (dereference_option, p, &st) != 0)
 	{
-	  if (errno != ENOENT) 
+	  if (errno != ENOENT)
 	    stat_diag (directory->name);
 	  /* else: should have been already reported */
 	}
@@ -457,14 +457,14 @@ procdir (const char *name_buffer, struct stat *stat_data,
 	  *entry = 'N';
 	  return directory;
 	}
-      
+
       /* With NFS, the same file can have two different devices
 	 if an NFS directory is mounted in multiple locations,
 	 which is relatively common when automounting.
 	 To avoid spurious incremental redumping of
 	 directories, consider all NFS devices as equal,
 	 relying on the i-node to establish differences.  */
-      
+
       if (! ((!check_device_option
 	      || (DIR_IS_NFS (directory) && nfs)
 	      || directory->device_number == stat_data->st_dev)
@@ -502,14 +502,14 @@ procdir (const char *name_buffer, struct stat *stat_data,
 	}
       else
 	directory->children = CHANGED_CHILDREN;
-      
+
       DIR_SET_FLAG (directory, DIRF_FOUND);
     }
   else
     {
       struct directory *d = find_directory_meta (stat_data->st_dev,
 						 stat_data->st_ino);
-      
+
       directory = note_directory (name_buffer,
 				  get_stat_mtime(stat_data),
 				  stat_data->st_dev,
@@ -553,7 +553,7 @@ procdir (const char *name_buffer, struct stat *stat_data,
   if (one_file_system_option && device != stat_data->st_dev
       /* ... except if it was explicitely given in the command line */
       && !is_individual_file (name_buffer))
-    /* FIXME: 
+    /* FIXME:
 	WARNOPT (WARN_XDEV,
 		 (0, 0,
 		  _("%s: directory is on a different filesystem; not dumped"),
@@ -566,7 +566,7 @@ procdir (const char *name_buffer, struct stat *stat_data,
       if (directory->children == NO_CHILDREN)
 	*entry = 'N';
     }
-	  
+
   DIR_SET_FLAG (directory, DIRF_INIT);
 
   if (directory->children != NO_CHILDREN)
@@ -590,13 +590,13 @@ procdir (const char *name_buffer, struct stat *stat_data,
 				 _("contents not dumped"));
 	  directory->children = NO_CHILDREN;
 	  break;
-	  
+
 	case exclusion_tag_under:
 	  exclusion_tag_warning (name_buffer, tag_file_name,
 				 _("contents not dumped"));
 	  directory->tagfile = tag_file_name;
 	  break;
-	  
+
 	case exclusion_tag_none:
 	  break;
 	}
@@ -616,7 +616,7 @@ procdir (const char *name_buffer, struct stat *stat_data,
    DIRECTORY->dump is replaced with the created template. Each entry is
    prefixed with ' ' if it was present in DUMP and with 'Y' otherwise. */
 
-void
+static void
 makedumpdir (struct directory *directory, const char *dir)
 {
   size_t i,
@@ -697,13 +697,13 @@ scan_directory (char *dir, dev_t device, bool cmdline)
   struct stat stat_data;
   struct directory *directory;
   char ch;
-  
+
   if (! dirp)
     savedir_error (dir);
 
   tmp = xstrdup (dir);
   zap_slashes (tmp);
-  
+
   if (deref_stat (dereference_option, tmp, &stat_data))
     {
       dir_removed_diag (tmp, cmdline, stat_diag);
@@ -715,7 +715,7 @@ scan_directory (char *dir, dev_t device, bool cmdline)
   directory = procdir (tmp, &stat_data, device,
 		       (cmdline ? PD_FORCE_INIT : 0),
 		       &ch);
-  
+
   free (tmp);
 
   nbuf = namebuf_create (dir);
@@ -809,9 +809,9 @@ name_fill_directory (struct name *name, dev_t device, bool cmdline)
 
 
 static void
-obstack_code_rename (struct obstack *stk, char *from, char *to)
+obstack_code_rename (struct obstack *stk, char const *from, char const *to)
 {
-  char *s;
+  char const *s;
 
   s = from[0] == 0 ? from :
                      safer_name_suffix (from, false, absolute_names_option);
@@ -874,7 +874,7 @@ append_incremental_renames (struct directory *dir)
   size_t size;
   struct directory *dp;
   const char *dump;
-  
+
   if (dirhead == NULL)
     return;
 
@@ -1217,7 +1217,7 @@ read_timespec (FILE *fp, struct timespec *pval)
 
 /* Read incremental snapshot format 2 */
 static void
-read_incr_db_2 ()
+read_incr_db_2 (void)
 {
   uintmax_t u;
   struct obstack stk;
@@ -1312,7 +1312,7 @@ read_directory_file (void)
      which is necessary to recreate absolute file names. */
   name_from_list ();
   blank_name_list ();
-  
+
   if (0 < getline (&buf, &bufsize, listed_incremental_stream))
     {
       char *ebuf;
@@ -1367,7 +1367,7 @@ write_directory_file_entry (void *entry, void *data)
   if (DIR_IS_FOUND (directory))
     {
       char buf[UINTMAX_STRSIZE_BOUND];
-      char *s;
+      char const *s;
 
       s = DIR_IS_NFS (directory) ? "1" : "0";
       fwrite (s, 2, 1, fp);
@@ -1707,7 +1707,7 @@ try_purge_directory (char const *directory_name)
     }
   free (p);
   dumpdir_free (dump);
-  
+
   free (current_dir);
   return true;
 }
diff --git a/src/list.c b/src/list.c
index ac7c8fb..dad725a 100644
--- a/src/list.c
+++ b/src/list.c
@@ -78,7 +78,7 @@ read_and (void (*do_something) (void))
       prev_status = status;
       tar_stat_destroy (&current_stat_info);
 
-      status = read_header (&current_header, &current_stat_info, 
+      status = read_header (&current_header, &current_stat_info,
                             read_header_auto);
       switch (status)
 	{
@@ -140,7 +140,7 @@ read_and (void (*do_something) (void))
 	    {
 	      char buf[UINTMAX_STRSIZE_BOUND];
 
-	      status = read_header (&current_header, &current_stat_info, 
+	      status = read_header (&current_header, &current_stat_info,
 	                            read_header_auto);
 	      if (status == HEADER_ZERO_BLOCK)
 		break;
@@ -210,7 +210,7 @@ list_archive (void)
   off_t block_ordinal = current_block_ordinal ();
 
   /* Print the header block.  */
-  
+
   decode_header (current_header, &current_stat_info, &current_format, 0);
   if (verbose_option)
     print_header (&current_stat_info, current_header, block_ordinal);
@@ -496,18 +496,18 @@ decode_xform (char *file_name, void *data)
 	 links subject to filename transformation.  In the absence of another
 	 solution, symbolic links are exempt from component stripping and
 	 name suffix normalization, but subject to filename transformation
-	 proper. */ 
+	 proper. */
       return file_name;
-      
+
     case XFORM_LINK:
       file_name = safer_name_suffix (file_name, true, absolute_names_option);
       break;
-      
+
     case XFORM_REGFILE:
       file_name = safer_name_suffix (file_name, false, absolute_names_option);
       break;
     }
-  
+
   if (strip_name_components)
     {
       size_t prefix_len = stripped_prefix_len (file_name,
@@ -547,7 +547,7 @@ decode_header (union block *header, struct tar_stat_info *stat_info,
   enum archive_format format;
   unsigned hbits; /* high bits of the file mode. */
   mode_t mode = MODE_FROM_HEADER (header->header.mode, &hbits);
-  
+
   if (strcmp (header->header.magic, TMAGIC) == 0)
     {
       if (header->star_header.prefix[130] == 0
@@ -651,7 +651,7 @@ decode_header (union block *header, struct tar_stat_info *stat_info,
     case SYMTYPE:
       transform_member_name (&stat_info->link_name, XFORM_SYMLINK);
       break;
-      
+
     case LNKTYPE:
       transform_member_name (&stat_info->link_name, XFORM_LINK);
     }
@@ -1292,8 +1292,8 @@ simple_print_header (struct tar_stat_info *st, union block *blk,
 }
 
 
-void
-print_volume_label ()
+static void
+print_volume_label (void)
 {
   struct tar_stat_info vstat;
   union block vblk;
@@ -1416,7 +1416,7 @@ test_archive_label ()
 		     &current_stat_info, &current_format, 0);
       if (current_header->header.typeflag == GNUTYPE_VOLHDR)
 	assign_string (&volume_label, current_header->header.name);
-      
+
       if (volume_label)
 	{
 	  if (verbose_option)
diff --git a/src/misc.c b/src/misc.c
index ff7e4b2..3e7941d 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -234,8 +234,8 @@ zap_slashes (char *name)
 }
 
 /* Normalize NAME by resolving any relative references and
-   removing trailing slashes.  Destructive version: modifies its argument. */ 
-int
+   removing trailing slashes.  Destructive version: modifies its argument. */
+static int
 normalize_filename_x (char *name)
 {
   char *p, *q;
@@ -296,7 +296,7 @@ normalize_filename_x (char *name)
   /* Remove trailing slashes */
   while (p - 1 > name && ISSLASH (p[-1]))
     p--;
-  
+
   *p = 0;
   return 0;
 }
@@ -393,7 +393,7 @@ code_timespec (struct timespec t, char sbuf[TIMESPEC_STRSIZE_BOUND])
   /* ignore invalid values of ns */
   if (BILLION <= ns || ns < 0)
     ns = 0;
-  
+
   if (negative && ns != 0)
     {
       s++;
@@ -851,7 +851,7 @@ file_removed_diag (const char *name, bool top_level,
 	       (0, 0, _("%s: File removed before we read it"),
 		quotearg_colon (name)));
       set_exit_status (TAREXIT_DIFFERS);
-    }      
+    }
   else
     diagfn (name);
 }
@@ -961,4 +961,3 @@ namebuf_name (namebuf_t buf, const char *name)
   strcpy (buf->buffer + buf->dir_length, name);
   return buf->buffer;
 }
-
diff --git a/src/names.c b/src/names.c
index a3c6f58..f1e5ab1 100644
--- a/src/names.c
+++ b/src/names.c
@@ -27,15 +27,6 @@
 
 /* User and group names.  */
 
-struct group *getgrnam ();
-struct passwd *getpwnam ();
-#if ! HAVE_DECL_GETPWUID
-struct passwd *getpwuid ();
-#endif
-#if ! HAVE_DECL_GETGRGID
-struct group *getgrgid ();
-#endif
-
 /* Make sure you link with the proper libraries if you are running the
    Yellow Peril (thanks for the good laugh, Ian J.!), or, euh... NIS.
    This code should also be modified for non-UNIX systems to do something
@@ -179,7 +170,7 @@ gname_to_gid (char const *gname, gid_t *gidp)
 }
 
 
-struct name *
+static struct name *
 make_name (const char *file_name)
 {
   struct name *p = xzalloc (sizeof (*p));
@@ -190,7 +181,7 @@ make_name (const char *file_name)
   return p;
 }
 
-void
+static void
 free_name (struct name *p)
 {
   if (p)
@@ -207,7 +198,7 @@ free_name (struct name *p)
 static struct name *namelist;	/* first name in list, if any */
 static struct name *nametail;	/* end of name list */
 
-/* File name arguments are processed in two stages: first a 
+/* File name arguments are processed in two stages: first a
    name_array (see below) is filled, then the names from it
    are moved into the namelist.
 
@@ -215,7 +206,7 @@ static struct name *nametail;	/* end of name list */
    which is meant to help process large archives on machines with
    limited memory.  With this option on, namelist contains at most one
    entry, which diminishes the memory consumption.
-   
+
    However, I very much doubt if we still need this -- Sergey */
 
 /* A name_array element contains entries of three types: */
@@ -230,7 +221,7 @@ struct name_elt        /* A name_array element. */
   union
   {
     const char *name;  /* File or directory name */
-    int matching_flags;/* fnmatch options if type == NELT_FMASK */ 
+    int matching_flags;/* fnmatch options if type == NELT_FMASK */
   } v;
 };
 
@@ -241,7 +232,7 @@ static size_t name_index;	 /* how many of the entries have we scanned? */
 
 /* Check the size of name_array, reallocating it as necessary.  */
 static void
-check_name_alloc ()
+check_name_alloc (void)
 {
   if (names == allocated_names)
     {
@@ -282,7 +273,7 @@ name_add_dir (const char *name)
   ep = &name_array[names++];
   ep->type = NELT_CHDIR;
   ep->v.name = name;
-}  
+}
 
 
 /* Names from external name file.  */
@@ -313,10 +304,10 @@ static int matching_flags; /* exclude_fnmatch options */
 
    If CHANGE_DIRS is true, treat any entries of type NELT_CHDIR as
    the request to change to the given directory.
-   
+
    Entries of type NELT_FMASK cause updates of the matching_flags
    value. */
-struct name_elt *
+static struct name_elt *
 name_next_elt (int change_dirs)
 {
   static struct name_elt entry;
@@ -327,14 +318,14 @@ name_next_elt (int change_dirs)
     {
       struct name_elt *ep;
       size_t source_len;
-      
+
       ep = &name_array[name_index++];
       if (ep->type == NELT_FMASK)
 	{
 	  matching_flags = ep->v.matching_flags;
 	  continue;
 	}
-      
+
       source = ep->v.name;
       source_len = strlen (source);
       if (name_buffer_length < source_len)
@@ -421,7 +412,7 @@ name_gather (void)
 	  buffer->directory = NULL;
 	  buffer->parent = NULL;
 	  buffer->cmdline = true;
-	  
+
 	  namelist = nametail = buffer;
 	}
       else if (change_dir)
@@ -519,7 +510,7 @@ name_match (const char *file_name)
 
       if (!cursor)
 	return true;
-      
+
       if (cursor->name[0] == 0)
 	{
 	  chdir_do (cursor->change_dir);
@@ -616,7 +607,7 @@ names_notfound (void)
     if (!WASFOUND (cursor) && cursor->name[0])
       {
 	regex_usage_warning (cursor->name);
-	ERROR ((0, 0, 
+	ERROR ((0, 0,
 		(cursor->found_count == 0) ?
 		     _("%s: Not found in archive") :
 		     _("%s: Required occurrence not found in archive"),
@@ -647,7 +638,7 @@ label_notfound (void)
 
   if (!namelist)
     return;
-  
+
   for (cursor = namelist; cursor; cursor = cursor->next)
     if (WASFOUND (cursor))
       return;
@@ -681,7 +672,7 @@ label_notfound (void)
 /* Sort *singly* linked LIST of names, of given LENGTH, using COMPARE
    to order names.  Return the sorted list.  Note that after calling
    this function, the `prev' links in list elements are messed up.
-   
+
    Apart from the type `struct name' and the definition of SUCCESSOR,
    this is a generic list-sorting function, but it's too painful to
    make it both generic and portable
@@ -797,7 +788,7 @@ static void
 add_hierarchy_to_namelist (struct name *name, dev_t device, bool cmdline)
 {
   const char *buffer;
-  
+
   name_fill_directory (name, device, cmdline);
   buffer = directory_contents (name->directory);
   if (buffer)
@@ -882,7 +873,7 @@ rebase_child_list (struct name *child, struct name *parent)
   size_t old_prefix_len = child->parent->length;
   size_t new_prefix_len = parent->length;
   char *new_prefix = parent->name;
-  
+
   for (; child; child = child->sibling)
     {
       size_t size = child->length - old_prefix_len + new_prefix_len;
@@ -894,7 +885,7 @@ rebase_child_list (struct name *child, struct name *parent)
       child->length = size;
 
       rebase_directory (child->directory,
-			child->parent->name, old_prefix_len, 
+			child->parent->name, old_prefix_len,
 			new_prefix, new_prefix_len);
     }
 }
@@ -911,7 +902,7 @@ collect_and_sort_names (void)
   int num_names;
   struct stat statbuf;
   Hash_table *nametab;
-  
+
   name_gather ();
 
   if (!namelist)
@@ -939,7 +930,7 @@ collect_and_sort_names (void)
 
       read_directory_file ();
     }
-  
+
   num_names = 0;
   for (name = namelist; name; name = name->next, num_names++)
     {
@@ -1115,12 +1106,12 @@ static void
 register_individual_file (char const *name)
 {
   struct stat st;
-  
+
   if (deref_stat (dereference_option, name, &st) != 0)
     return; /* Will be complained about later */
   if (S_ISDIR (st.st_mode))
     return;
-  
+
   hash_string_insert (&individual_file_table, name);
 }
 
diff --git a/src/sparse.c b/src/sparse.c
index 9fde508..4a391a9 100644
--- a/src/sparse.c
+++ b/src/sparse.c
@@ -224,7 +224,7 @@ sparse_scan_file (struct tar_sparse_file *file)
     return false;
 
   st->archive_file_size = 0;
-  
+
   if (!tar_sparse_scan (file, scan_begin, NULL))
     return false;
 
@@ -514,7 +514,7 @@ check_data_region (struct tar_sparse_file *file, size_t i)
     return false;
   size_left = file->stat_info->sparse_map[i].numbytes;
   mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
-      
+
   while (size_left > 0)
     {
       size_t bytes_read;
@@ -564,7 +564,7 @@ sparse_diff_file (int fd, struct tar_stat_info *st)
   file.stat_info = st;
   file.fd = fd;
   file.seekable = true; /* File *must* be seekable for compare to work */
-  
+
   rc = tar_sparse_decode_header (&file);
   mv_begin (st);
   for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)
@@ -579,7 +579,7 @@ sparse_diff_file (int fd, struct tar_stat_info *st)
   if (!rc)
     skip_file (file.stat_info->archive_file_size - file.dumped_size);
   mv_end ();
-  
+
   tar_sparse_done (&file);
   return rc;
 }
@@ -851,13 +851,13 @@ static struct tar_sparse_optab const star_optab = {
    instances of GNU.sparse.offset/GNU.sparse.numbytes variables, whereas
    POSIX requires the latest occurrence of the variable to override all
    previous occurrences.
-   
+
    To avoid this incompatibility two following versions were introduced.
 
    * 0.1
 
    Used by tar 1.15.2 -- 1.15.91 (alpha releases).
-   
+
    The sparse file map is stored in
    x header:
 
@@ -875,18 +875,18 @@ static struct tar_sparse_optab const star_optab = {
    Starting from this version, the exact sparse format version is specified
    explicitely in the header using the following variables:
 
-   GNU.sparse.major     Major version 
+   GNU.sparse.major     Major version
    GNU.sparse.minor     Minor version
 
    X header keeps the following variables:
-   
+
    GNU.sparse.name      Real file name of the sparse file
    GNU.sparse.realsize  Real size of the stored file (corresponds to the old
                         GNU.sparse.size variable)
 
    The name field of the ustar header is constructed using the pattern
    "%d/GNUSparseFile.%p/%f".
-   
+
    The sparse map itself is stored in the file data block, preceding the actual
    file data. It consists of a series of octal numbers of arbitrary length,
    delimited by newlines. The map is padded with nulls to the nearest block
@@ -924,11 +924,11 @@ pax_dump_header_0 (struct tar_sparse_file *file)
   char nbuf[UINTMAX_STRSIZE_BOUND];
   struct sp_array *map = file->stat_info->sparse_map;
   char *save_file_name = NULL;
-  
+
   /* Store the real file size */
   xheader_store ("GNU.sparse.size", file->stat_info, NULL);
   xheader_store ("GNU.sparse.numblocks", file->stat_info, NULL);
-  
+
   if (xheader_keyword_deleted_p ("GNU.sparse.map")
       || tar_sparse_minor == 0)
     {
@@ -991,7 +991,7 @@ pax_dump_header_1 (struct tar_sparse_file *file)
 #define COPY_STRING(b,dst,src) do                \
  {                                               \
    char *endp = b->buffer + BLOCKSIZE;           \
-   char *srcp = src;                             \
+   char const *srcp = src;                       \
    while (*srcp)                                 \
      {                                           \
        if (dst == endp)                          \
@@ -1003,7 +1003,7 @@ pax_dump_header_1 (struct tar_sparse_file *file)
 	 }                                       \
        *dst++ = *srcp++;                         \
      }                                           \
-   } while (0)                       
+   } while (0)
 
   /* Compute stored file size */
   p = umaxtostr (file->stat_info->sparse_map_avail, nbuf);
@@ -1018,13 +1018,13 @@ pax_dump_header_1 (struct tar_sparse_file *file)
   size = (size + BLOCKSIZE - 1) / BLOCKSIZE;
   file->stat_info->archive_file_size += size * BLOCKSIZE;
   file->dumped_size += size * BLOCKSIZE;
-  
+
   /* Store sparse file identification */
   xheader_store ("GNU.sparse.major", file->stat_info, NULL);
   xheader_store ("GNU.sparse.minor", file->stat_info, NULL);
   xheader_store ("GNU.sparse.name", file->stat_info, NULL);
   xheader_store ("GNU.sparse.realsize", file->stat_info, NULL);
-  
+
   file->stat_info->file_name = xheader_format_name (file->stat_info,
 					    "%d/GNUSparseFile.%p/%f", 0);
 
@@ -1072,12 +1072,12 @@ decode_num (uintmax_t *num, char const *arg, uintmax_t maxval)
 
   if (!ISDIGIT (*arg))
     return false;
-  
+
   u = strtoumax (arg, &arg_lim, 10);
 
   if (! (u <= maxval && errno != ERANGE) || *arg_lim)
     return false;
-  
+
   *num = u;
   return true;
 }
@@ -1117,7 +1117,7 @@ pax_decode_header (struct tar_sparse_file *file)
      }                                                             \
    while (*dst++ != '\n');                                         \
    dst[-1] = 0;                                                    \
- } while (0)                       
+ } while (0)
 
       set_next_block_after (current_header);
       file->dumped_size += BLOCKSIZE;
@@ -1126,7 +1126,7 @@ pax_decode_header (struct tar_sparse_file *file)
       COPY_BUF (blk,nbuf,p);
       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))
 	{
-	  ERROR ((0, 0, _("%s: malformed sparse archive member"), 
+	  ERROR ((0, 0, _("%s: malformed sparse archive member"),
 		  file->stat_info->orig_file_name));
 	  return false;
 	}
@@ -1137,11 +1137,11 @@ pax_decode_header (struct tar_sparse_file *file)
       for (i = 0; i < file->stat_info->sparse_map_size; i++)
 	{
 	  struct sp_array sp;
-	  
+
 	  COPY_BUF (blk,nbuf,p);
 	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
 	    {
-	      ERROR ((0, 0, _("%s: malformed sparse archive member"), 
+	      ERROR ((0, 0, _("%s: malformed sparse archive member"),
 		      file->stat_info->orig_file_name));
 	      return false;
 	    }
@@ -1149,7 +1149,7 @@ pax_decode_header (struct tar_sparse_file *file)
 	  COPY_BUF (blk,nbuf,p);
 	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))
 	    {
-	      ERROR ((0, 0, _("%s: malformed sparse archive member"), 
+	      ERROR ((0, 0, _("%s: malformed sparse archive member"),
 		      file->stat_info->orig_file_name));
 	      return false;
 	    }
@@ -1158,7 +1158,7 @@ pax_decode_header (struct tar_sparse_file *file)
 	}
       set_next_block_after (blk);
     }
-  
+
   return true;
 }
 
@@ -1168,7 +1168,7 @@ static struct tar_sparse_optab const pax_optab = {
   pax_sparse_member_p,
   pax_dump_header,
   NULL,
-  pax_decode_header,  
+  pax_decode_header,
   NULL,  /* No scan_block function */
   sparse_dump_region,
   sparse_extract_region,
diff --git a/src/system.c b/src/system.c
index d646822..345cc07 100644
--- a/src/system.c
+++ b/src/system.c
@@ -291,7 +291,7 @@ wait_for_grandchild (pid_t pid)
 {
   int wait_status;
   int exit_code = 0;
-  
+
   while (waitpid (pid, &wait_status, 0) == -1)
     if (errno != EINTR)
       {
@@ -303,7 +303,7 @@ wait_for_grandchild (pid_t pid)
     raise (WTERMSIG (wait_status));
   else if (WEXITSTATUS (wait_status) != 0)
     exit_code = WEXITSTATUS (wait_status);
-  
+
   exit (exit_code);
 }
 
@@ -332,7 +332,7 @@ sys_child_open_for_compress (void)
 
   set_program_name (_("tar (child)"));
   signal (SIGPIPE, SIG_DFL);
-  
+
   xdup2 (parent_pipe[PREAD], STDIN_FILENO);
   xclose (parent_pipe[PWRITE]);
 
@@ -476,7 +476,7 @@ sys_child_open_for_uncompress (void)
 
   set_program_name (_("tar (child)"));
   signal (SIGPIPE, SIG_DFL);
-  
+
   xdup2 (parent_pipe[PWRITE], STDOUT_FILENO);
   xclose (parent_pipe[PREAD]);
 
@@ -575,7 +575,7 @@ sys_child_open_for_uncompress (void)
 
 
 static void
-dec_to_env (char *envar, uintmax_t num)
+dec_to_env (char const *envar, uintmax_t num)
 {
   char buf[UINTMAX_STRSIZE_BOUND];
   char *numstr;
@@ -586,7 +586,7 @@ dec_to_env (char *envar, uintmax_t num)
 }
 
 static void
-time_to_env (char *envar, struct timespec t)
+time_to_env (char const *envar, struct timespec t)
 {
   char buf[TIMESPEC_STRSIZE_BOUND];
   if (setenv (envar, code_timespec (t, buf), 1) != 0)
@@ -594,7 +594,7 @@ time_to_env (char *envar, struct timespec t)
 }
 
 static void
-oct_to_env (char *envar, unsigned long num)
+oct_to_env (char const *envar, unsigned long num)
 {
   char buf[1+1+(sizeof(unsigned long)*CHAR_BIT+2)/3];
 
@@ -604,7 +604,7 @@ oct_to_env (char *envar, unsigned long num)
 }
 
 static void
-str_to_env (char *envar, char const *str)
+str_to_env (char const *envar, char const *str)
 {
   if (str)
     {
@@ -616,7 +616,7 @@ str_to_env (char *envar, char const *str)
 }
 
 static void
-chr_to_env (char *envar, char c)
+chr_to_env (char const *envar, char c)
 {
   char buf[2];
   buf[0] = c;
@@ -750,7 +750,7 @@ sys_exec_info_script (const char **archive_name, int volume_number)
   char uintbuf[UINTMAX_STRSIZE_BOUND];
   int p[2];
   static RETSIGTYPE (*saved_handler) (int sig);
-  
+
   xpipe (p);
   saved_handler = signal (SIGPIPE, SIG_IGN);
 
@@ -783,7 +783,7 @@ sys_exec_info_script (const char **archive_name, int volume_number)
 	  }
 
       signal (SIGPIPE, saved_handler);
-      
+
       if (WIFEXITED (status))
 	{
 	  if (WEXITSTATUS (status) == 0 && rc > 0)
@@ -813,7 +813,7 @@ sys_exec_info_script (const char **archive_name, int volume_number)
 
   argv[0] = "/bin/sh";
   argv[1] = "-c";
-  argv[2] = (char*) info_script_option;
+  argv[2] = (char *) info_script_option;
   argv[3] = NULL;
 
   execv (argv[0], argv);
@@ -860,7 +860,7 @@ sys_exec_checkpoint_script (const char *script_name,
 				 archive_format : current_format), 1);
   argv[0] = "/bin/sh";
   argv[1] = "-c";
-  argv[2] = (char*) script_name;
+  argv[2] = (char *) script_name;
   argv[3] = NULL;
 
   execv (argv[0], argv);
diff --git a/src/tar.c b/src/tar.c
index 21c396d..5b61144 100644
--- a/src/tar.c
+++ b/src/tar.c
@@ -220,12 +220,12 @@ subcommand_string (enum subcommand c)
   abort ();
 }
 
-void
-tar_list_quoting_styles (struct obstack *stk, char *prefix)
+static void
+tar_list_quoting_styles (struct obstack *stk, char const *prefix)
 {
   int i;
   size_t prefixlen = strlen (prefix);
-  
+
   for (i = 0; quoting_style_args[i]; i++)
     {
       obstack_grow (stk, prefix, prefixlen);
@@ -235,7 +235,7 @@ tar_list_quoting_styles (struct obstack *stk, char *prefix)
     }
 }
 
-void
+static void
 tar_set_quoting_style (char *arg)
 {
   int i;
@@ -338,7 +338,7 @@ enum
   UNQUOTE_OPTION,
   UTC_OPTION,
   VOLNO_FILE_OPTION,
-  WARNING_OPTION, 
+  WARNING_OPTION,
   WILDCARDS_MATCH_SLASH_OPTION,
   WILDCARDS_OPTION
 };
@@ -631,7 +631,7 @@ static struct argp_option options[] = {
   {"lzop", LZOP_OPTION, 0, 0, NULL, GRID+1 },
   {"xz", 'J', 0, 0, NULL, GRID+1 },
 #undef GRID
-  
+
 #define GRID 100
   {NULL, 0, NULL, 0,
    N_("Local file selection:"), GRID },
@@ -891,7 +891,7 @@ static char const * const backup_file_table[] = {
   NULL
 };
 
-void
+static void
 add_exclude_array (char const * const * fv)
 {
   int i;
@@ -910,8 +910,8 @@ format_default_settings (void)
 	    " --rsh-command=%s"
 #endif
 	    ,
-	    archive_format_string (DEFAULT_ARCHIVE_FORMAT), 
-	    DEFAULT_ARCHIVE, DEFAULT_BLOCKING,              
+	    archive_format_string (DEFAULT_ARCHIVE_FORMAT),
+	    DEFAULT_ARCHIVE, DEFAULT_BLOCKING,
 	    quoting_style_args[DEFAULT_QUOTING_STYLE],
 	    DEFAULT_RMT_COMMAND
 #ifdef REMOTE_SHELL
@@ -928,7 +928,7 @@ set_subcommand_option (enum subcommand subcommand)
       && subcommand_option != subcommand)
     USAGE_ERROR ((0, 0,
 		  _("You may not specify more than one `-Acdtrux' or `--test-label' option")));
-  
+
   subcommand_option = subcommand;
 }
 
@@ -938,7 +938,7 @@ set_use_compress_program_option (const char *string)
   if (use_compress_program_option
       && strcmp (use_compress_program_option, string) != 0)
     USAGE_ERROR ((0, 0, _("Conflicting compression options")));
-  
+
   use_compress_program_option = string;
 }
 
@@ -966,14 +966,14 @@ stat_on_signal (int signo)
 #endif
 }
 
-void
+static void
 set_stat_signal (const char *name)
 {
   static struct sigtab
   {
-    char *name;
+    char const *name;
     int signo;
-  } sigtab[] = {
+  } const sigtab[] = {
     { "SIGUSR1", SIGUSR1 },
     { "USR1", SIGUSR1 },
     { "SIGUSR2", SIGUSR2 },
@@ -985,7 +985,7 @@ set_stat_signal (const char *name)
     { "SIGQUIT", SIGQUIT },
     { "QUIT", SIGQUIT }
   };
-  struct sigtab *p;
+  struct sigtab const *p;
 
   for (p = sigtab; p < sigtab + sizeof (sigtab) / sizeof (sigtab[0]); p++)
     if (strcmp (p->name, name) == 0)
@@ -1096,7 +1096,7 @@ read_name_from_file (FILE *fp, struct obstack *stk, int term)
       obstack_1grow (stk, c);
       counter++;
     }
-  
+
   if (counter == 0 && c != EOF)
     return file_list_skip;
 
@@ -1167,7 +1167,7 @@ update_argv (const char *filename, struct argp_state *state)
   bool is_stdin = false;
   enum read_file_list_state read_state;
   int term = filename_terminator;
-  
+
   if (!strcmp (filename, "-"))
     {
       is_stdin = true;
@@ -1180,7 +1180,7 @@ update_argv (const char *filename, struct argp_state *state)
       if ((fp = fopen (filename, "r")) == NULL)
 	open_fatal (filename);
     }
-  
+
   while ((read_state = read_name_from_file (fp, &argv_stk, term))
 	 != file_list_end)
     {
@@ -1189,18 +1189,18 @@ update_argv (const char *filename, struct argp_state *state)
 	case file_list_success:
 	  count++;
 	  break;
-	  
+
 	case file_list_end: /* won't happen, just to pacify gcc */
 	  break;
-	  
+
 	case file_list_zero:
 	  {
 	    size_t size;
-	    
+
 	    WARNOPT (WARN_FILENAME_WITH_NULS,
 		     (0, 0, N_("%s: file name read contains nul character"),
 		      quotearg_colon (filename)));
-	    
+
 	    /* Prepare new stack contents */
 	    size = obstack_object_size (&argv_stk);
 	    p = obstack_finish (&argv_stk);
@@ -1215,34 +1215,34 @@ update_argv (const char *filename, struct argp_state *state)
 	    term = 0;
 	    break;
 	  }
-	  
+
 	case file_list_skip:
 	  break;
 	}
     }
-  
+
   if (!is_stdin)
     fclose (fp);
-  
+
   if (count == 0)
     return;
-  
+
   start = obstack_finish (&argv_stk);
-  
+
   if (term == 0)
     for (p = start; *p; p += strlen (p) + 1)
       if (p[0] == '-')
 	count++;
-  
+
   new_argc = state->argc + count;
   new_argv = xmalloc (sizeof (state->argv[0]) * (new_argc + 1));
   memcpy (new_argv, state->argv, sizeof (state->argv[0]) * (state->argc + 1));
   state->argv = new_argv;
   memmove (&state->argv[state->next + count], &state->argv[state->next],
 	   (state->argc - state->next + 1) * sizeof (state->argv[0]));
-  
+
   state->argc = new_argc;
-  
+
   for (i = state->next, p = start; *p; p += strlen (p) + 1, i++)
     {
       if (term == 0 && p[0] == '-')
@@ -1257,21 +1257,21 @@ tar_help_filter (int key, const char *text, void *input)
 {
   struct obstack stk;
   char *s;
-  
+
   switch (key)
     {
     default:
       s = (char*) text;
       break;
-      
+
     case 'j':
       s = xasprintf (_("filter the archive through %s"), BZIP2_PROGRAM);
       break;
-      
+
     case 'z':
       s = xasprintf (_("filter the archive through %s"), GZIP_PROGRAM);
       break;
-      
+
     case 'Z':
       s = xasprintf (_("filter the archive through %s"), COMPRESS_PROGRAM);
       break;
@@ -1279,15 +1279,15 @@ tar_help_filter (int key, const char *text, void *input)
     case LZIP_OPTION:
       s = xasprintf (_("filter the archive through %s"), LZIP_PROGRAM);
       break;
-      
+
     case LZMA_OPTION:
       s = xasprintf (_("filter the archive through %s"), LZMA_PROGRAM);
       break;
-      
+
     case 'J':
       s = xasprintf (_("filter the archive through %s"), XZ_PROGRAM);
       break;
-      
+
     case ARGP_KEY_HELP_EXTRA:
       {
 	const char *tstr;
@@ -1315,7 +1315,7 @@ expand_pax_option (struct tar_args *targs, const char *arg)
 {
   struct obstack stk;
   char *res;
-  
+
   obstack_init (&stk);
   while (*arg)
     {
@@ -1376,19 +1376,19 @@ parse_opt (int key, char *arg, struct argp_state *state)
       name_add_name (arg, MAKE_INCL_OPTIONS (args));
       args->input_files = true;
       break;
-      
+
     case 'A':
       set_subcommand_option (CAT_SUBCOMMAND);
       break;
-      
+
     case 'a':
       args->compress_autodetect = true;
       break;
-      
+
     case NO_AUTO_COMPRESS_OPTION:
       args->compress_autodetect = false;
       break;
-      
+
     case 'b':
       {
 	uintmax_t u;
@@ -1400,43 +1400,43 @@ parse_opt (int key, char *arg, struct argp_state *state)
 			_("Invalid blocking factor")));
       }
       break;
-      
+
     case 'B':
       /* Try to reblock input records.  For reading 4.2BSD pipes.  */
-      
+
       /* It would surely make sense to exchange -B and -R, but it seems
 	 that -B has been used for a long while in Sun tar and most
 	 BSD-derived systems.  This is a consequence of the block/record
 	 terminology confusion.  */
-      
+
       read_full_records_option = true;
       break;
-      
+
     case 'c':
       set_subcommand_option (CREATE_SUBCOMMAND);
       break;
-      
+
     case 'C':
       name_add_dir (arg);
       break;
-      
+
     case 'd':
       set_subcommand_option (DIFF_SUBCOMMAND);
       break;
-      
+
     case 'f':
       if (archive_names == allocated_archive_names)
 	archive_name_array = x2nrealloc (archive_name_array,
 					 &allocated_archive_names,
 					 sizeof (archive_name_array[0]));
-      
+
       archive_name_array[archive_names++] = arg;
       break;
-      
+
     case 'F':
       /* Since -F is only useful with -M, make it implied.  Run this
 	 script at the end of each tape.  */
-      
+
       info_script_option = arg;
       multi_volume_option = true;
       break;
@@ -1444,65 +1444,65 @@ parse_opt (int key, char *arg, struct argp_state *state)
     case FULL_TIME_OPTION:
       full_time_option = true;
       break;
-      
+
     case 'g':
       listed_incremental_option = arg;
       after_date_option = true;
       /* Fall through.  */
-      
+
     case 'G':
       /* We are making an incremental dump (FIXME: are we?); save
 	 directories at the beginning of the archive, and include in each
 	 directory its contents.  */
-      
+
       incremental_option = true;
       break;
-      
+
     case 'h':
       /* Follow symbolic links.  */
       dereference_option = true;
       break;
-      
+
     case HARD_DEREFERENCE_OPTION:
       hard_dereference_option = true;
       break;
-      
+
     case 'i':
       /* Ignore zero blocks (eofs).  This can't be the default,
 	 because Unix tar writes two blocks of zeros, then pads out
 	 the record with garbage.  */
-      
+
       ignore_zeros_option = true;
       break;
-      
+
     case 'j':
       set_use_compress_program_option (BZIP2_PROGRAM);
       break;
-      
+
     case 'J':
       set_use_compress_program_option (XZ_PROGRAM);
       break;
-      
+
     case 'k':
       /* Don't replace existing files.  */
       old_files_option = KEEP_OLD_FILES;
       break;
-      
+
     case 'K':
       starting_file_option = true;
       addname (arg, 0, true, NULL);
       break;
-      
+
     case ONE_FILE_SYSTEM_OPTION:
       /* When dumping directories, don't dump files/subdirectories
 	 that are on other filesystems. */
       one_file_system_option = true;
       break;
-      
+
     case 'l':
       check_links_option = 1;
       break;
-      
+
     case 'L':
       {
 	uintmax_t u;
@@ -1513,7 +1513,7 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	multi_volume_option = true;
       }
       break;
-      
+
     case LEVEL_OPTION:
       {
 	char *p;
@@ -1522,47 +1522,47 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	  USAGE_ERROR ((0, 0, _("Invalid incremental level value")));
       }
       break;
-      
+
     case LZIP_OPTION:
       set_use_compress_program_option (LZIP_PROGRAM);
       break;
-      
+
     case LZMA_OPTION:
       set_use_compress_program_option (LZMA_PROGRAM);
       break;
-      
+
     case LZOP_OPTION:
       set_use_compress_program_option (LZOP_PROGRAM);
       break;
-      
+
     case 'm':
       touch_option = true;
       break;
-      
+
     case 'M':
       /* Make multivolume archive: when we can't write any more into
 	 the archive, re-open it, and continue writing.  */
-      
+
       multi_volume_option = true;
       break;
-      
+
     case MTIME_OPTION:
       get_date_or_file (args, "--mtime", arg, &mtime_option);
       set_mtime_option = true;
       break;
-      
+
     case 'n':
       seek_option = 1;
       break;
-      
+
     case NO_SEEK_OPTION:
       seek_option = 0;
       break;
-      
+
     case 'N':
       after_date_option = true;
       /* Fall through.  */
-      
+
     case NEWER_MTIME_OPTION:
       if (NEWER_OPTION_INITIALIZED (newer_mtime_option))
 	USAGE_ERROR ((0, 0, _("More than one threshold date")));
@@ -1570,48 +1570,48 @@ parse_opt (int key, char *arg, struct argp_state *state)
 			key == NEWER_MTIME_OPTION ? "--newer-mtime"
 			: "--after-date", arg, &newer_mtime_option);
       break;
-      
+
     case 'o':
       args->o_option = true;
       break;
-      
+
     case 'O':
       to_stdout_option = true;
       break;
-      
+
     case 'p':
       same_permissions_option = true;
       break;
-      
+
     case 'P':
       absolute_names_option = true;
       break;
-      
+
     case 'r':
       set_subcommand_option (APPEND_SUBCOMMAND);
       break;
-      
+
     case 'R':
       /* Print block numbers for debugging bad tar archives.  */
-      
+
       /* It would surely make sense to exchange -B and -R, but it seems
 	 that -B has been used for a long while in Sun tar and most
 	 BSD-derived systems.  This is a consequence of the block/record
 	 terminology confusion.  */
-      
+
       block_number_option = true;
       break;
-      
+
     case 's':
       /* Names to extract are sorted.  */
-      
+
       same_order_option = true;
       break;
-      
+
     case 'S':
       sparse_option = true;
       break;
-      
+
     case SPARSE_VERSION_OPTION:
       sparse_option = true;
       {
@@ -1627,16 +1627,16 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	  }
       }
       break;
-      
+
     case 't':
       set_subcommand_option (LIST_SUBCOMMAND);
       verbose_option++;
       break;
-      
+
     case TEST_LABEL_OPTION:
       set_subcommand_option (TEST_LABEL_SUBCOMMAND);
       break;
-      
+
     case 'T':
       update_argv (arg, state);
       /* Indicate we've been given -T option. This is for backward
@@ -1644,40 +1644,40 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	 succeed */
       files_from_option = true;
       break;
-      
+
     case 'u':
       set_subcommand_option (UPDATE_SUBCOMMAND);
       break;
-      
+
     case 'U':
       old_files_option = UNLINK_FIRST_OLD_FILES;
       break;
-      
+
     case UTC_OPTION:
       utc_option = true;
       break;
-      
+
     case 'v':
       verbose_option++;
       warning_option |= WARN_VERBOSE_WARNINGS;
       break;
-      
+
     case 'V':
       volume_label_option = arg;
       break;
-      
+
     case 'w':
       interactive_option = true;
       break;
-      
+
     case 'W':
       verify_option = true;
       break;
-      
+
     case 'x':
       set_subcommand_option (EXTRACT_SUBCOMMAND);
       break;
-      
+
     case 'X':
       if (add_exclude_file (add_exclude, excluded, arg,
 			    MAKE_EXCL_OPTIONS (args), '\n')
@@ -1687,19 +1687,19 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	  FATAL_ERROR ((0, e, "%s", quotearg_colon (arg)));
 	}
       break;
-      
+
     case 'z':
       set_use_compress_program_option (GZIP_PROGRAM);
       break;
-      
+
     case 'Z':
       set_use_compress_program_option (COMPRESS_PROGRAM);
       break;
-      
+
     case ANCHORED_OPTION:
       args->matching_flags |= EXCLUDE_ANCHORED;
       break;
-      
+
     case ATIME_PRESERVE_OPTION:
       atime_preserve_option =
 	(arg
@@ -1711,20 +1711,20 @@ parse_opt (int key, char *arg, struct argp_state *state)
 		      _("--atime-preserve='system' is not supported"
 			" on this platform")));
       break;
-      
+
     case CHECK_DEVICE_OPTION:
       check_device_option = true;
       break;
-      
+
     case NO_CHECK_DEVICE_OPTION:
       check_device_option = false;
       break;
-      
+
     case CHECKPOINT_OPTION:
       if (arg)
 	{
 	  char *p;
-	  
+
 	  if (*arg == '.')
 	    {
 	      checkpoint_compile_action (".");
@@ -1738,96 +1738,96 @@ parse_opt (int key, char *arg, struct argp_state *state)
       else
 	checkpoint_option = DEFAULT_CHECKPOINT;
       break;
-      
+
     case CHECKPOINT_ACTION_OPTION:
       checkpoint_compile_action (arg);
       break;
-      
+
     case BACKUP_OPTION:
       backup_option = true;
       if (arg)
 	args->version_control_string = arg;
       break;
-      
+
     case DELAY_DIRECTORY_RESTORE_OPTION:
       delay_directory_restore_option = true;
       break;
-      
+
     case NO_DELAY_DIRECTORY_RESTORE_OPTION:
       delay_directory_restore_option = false;
       break;
-      
+
     case DELETE_OPTION:
       set_subcommand_option (DELETE_SUBCOMMAND);
       break;
-      
+
     case EXCLUDE_BACKUPS_OPTION:
       add_exclude_array (backup_file_table);
       break;
-      
+
     case EXCLUDE_OPTION:
       add_exclude (excluded, arg, MAKE_EXCL_OPTIONS (args));
       break;
-      
+
     case EXCLUDE_CACHES_OPTION:
       add_exclusion_tag ("CACHEDIR.TAG", exclusion_tag_contents,
 			 cachedir_file_p);
       break;
-      
+
     case EXCLUDE_CACHES_UNDER_OPTION:
       add_exclusion_tag ("CACHEDIR.TAG", exclusion_tag_under,
 			 cachedir_file_p);
       break;
-      
+
     case EXCLUDE_CACHES_ALL_OPTION:
       add_exclusion_tag ("CACHEDIR.TAG", exclusion_tag_all,
 			 cachedir_file_p);
       break;
-      
+
     case EXCLUDE_TAG_OPTION:
       add_exclusion_tag (arg, exclusion_tag_contents, NULL);
       break;
-      
+
     case EXCLUDE_TAG_UNDER_OPTION:
       add_exclusion_tag (arg, exclusion_tag_under, NULL);
       break;
-      
+
     case EXCLUDE_TAG_ALL_OPTION:
       add_exclusion_tag (arg, exclusion_tag_all, NULL);
       break;
-      
+
     case EXCLUDE_VCS_OPTION:
       add_exclude_array (vcs_file_table);
       break;
-      
+
     case FORCE_LOCAL_OPTION:
       force_local_option = true;
       break;
-      
+
     case 'H':
       set_archive_format (arg);
       break;
-      
+
     case INDEX_FILE_OPTION:
       index_file_name = arg;
       break;
-      
+
     case IGNORE_CASE_OPTION:
       args->matching_flags |= FNM_CASEFOLD;
       break;
-      
+
     case IGNORE_COMMAND_ERROR_OPTION:
       ignore_command_error_option = true;
       break;
-      
+
     case IGNORE_FAILED_READ_OPTION:
       ignore_failed_read_option = true;
       break;
-      
+
     case KEEP_NEWER_FILES_OPTION:
       old_files_option = KEEP_NEWER_FILES;
       break;
-      
+
     case GROUP_OPTION:
       if (! (strlen (arg) < GNAME_FIELD_SIZE
 	     && gname_to_gid (arg, &group_option)))
@@ -1841,7 +1841,7 @@ parse_opt (int key, char *arg, struct argp_state *state)
 			  _("Invalid group")));
 	}
       break;
-      
+
     case MODE_OPTION:
       mode_option = mode_compile (arg);
       if (!mode_option)
@@ -1849,49 +1849,49 @@ parse_opt (int key, char *arg, struct argp_state *state)
       initial_umask = umask (0);
       umask (initial_umask);
       break;
-      
+
     case NO_ANCHORED_OPTION:
       args->include_anchored = 0; /* Clear the default for comman line args */
       args->matching_flags &= ~ EXCLUDE_ANCHORED;
       break;
-      
+
     case NO_IGNORE_CASE_OPTION:
       args->matching_flags &= ~ FNM_CASEFOLD;
       break;
-      
+
     case NO_IGNORE_COMMAND_ERROR_OPTION:
       ignore_command_error_option = false;
       break;
-      
+
     case NO_OVERWRITE_DIR_OPTION:
       old_files_option = NO_OVERWRITE_DIR_OLD_FILES;
       break;
-      
+
     case NO_QUOTE_CHARS_OPTION:
       for (;*arg; arg++)
 	set_char_quoting (NULL, *arg, 0);
       break;
-      
+
     case NO_WILDCARDS_OPTION:
       args->wildcards = disable_wildcards;
       break;
-      
+
     case NO_WILDCARDS_MATCH_SLASH_OPTION:
       args->matching_flags |= FNM_FILE_NAME;
       break;
-      
+
     case NULL_OPTION:
       filename_terminator = '\0';
       break;
-      
+
     case NO_NULL_OPTION:
       filename_terminator = '\n';
       break;
-      
+
     case NUMERIC_OWNER_OPTION:
       numeric_owner_option = true;
       break;
-      
+
     case OCCURRENCE_OPTION:
       if (!arg)
 	occurrence_option = 1;
@@ -1905,15 +1905,15 @@ parse_opt (int key, char *arg, struct argp_state *state)
 			  _("Invalid number")));
 	}
       break;
-      
+
     case OVERWRITE_DIR_OPTION:
       old_files_option = DEFAULT_OLD_FILES;
       break;
-      
+
     case OVERWRITE_OPTION:
       old_files_option = OVERWRITE_OLD_FILES;
       break;
-      
+
     case OWNER_OPTION:
       if (! (strlen (arg) < UNAME_FIELD_SIZE
 	     && uname_to_uid (arg, &owner_option)))
@@ -1927,16 +1927,16 @@ parse_opt (int key, char *arg, struct argp_state *state)
 			  _("Invalid owner")));
 	}
       break;
-      
+
     case QUOTE_CHARS_OPTION:
       for (;*arg; arg++)
 	set_char_quoting (NULL, *arg, 1);
       break;
-      
+
     case QUOTING_STYLE_OPTION:
       tar_set_quoting_style (arg);
       break;
-      
+
     case PAX_OPTION:
       {
 	char *tmp = expand_pax_option (args, arg);
@@ -1945,11 +1945,11 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	free (tmp);
       }
       break;
-      
+
     case POSIX_OPTION:
       set_archive_format ("posix");
       break;
-      
+
     case PRESERVE_OPTION:
       /* FIXME: What it is good for? */
       same_permissions_option = true;
@@ -1957,7 +1957,7 @@ parse_opt (int key, char *arg, struct argp_state *state)
       WARN ((0, 0, _("The --preserve option is deprecated, "
 		     "use --preserve-permissions --preserve-order instead")));
       break;
-      
+
     case RECORD_SIZE_OPTION:
       {
 	uintmax_t u;
@@ -1972,27 +1972,27 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	blocking_factor = record_size / BLOCKSIZE;
       }
       break;
-      
+
     case RECURSIVE_UNLINK_OPTION:
       recursive_unlink_option = true;
       break;
-      
+
     case REMOVE_FILES_OPTION:
       remove_files_option = true;
       break;
-      
+
     case RESTRICT_OPTION:
       restrict_option = true;
       break;
-      
+
     case RMT_COMMAND_OPTION:
       rmt_command = arg;
       break;
-      
+
     case RSH_COMMAND_OPTION:
       rsh_command_option = arg;
       break;
-      
+
     case SHOW_DEFAULTS_OPTION:
       {
 	char *s = format_default_settings ();
@@ -2001,7 +2001,7 @@ parse_opt (int key, char *arg, struct argp_state *state)
 	free (s);
 	exit (0);
       }
-      
+
     case STRIP_COMPONENTS_OPTION:
       {
 	uintmax_t u;
@@ -2090,7 +2090,7 @@ parse_opt (int key, char *arg, struct argp_state *state)
     case WARNING_OPTION:
       set_warning_option (arg);
       break;
-      
+
     case '0':
     case '1':
     case '2':
@@ -2208,7 +2208,7 @@ decode_options (int argc, char **argv)
   struct tar_args args;
 
   argp_version_setup ("tar", tar_authors);
-  
+
   /* Set some default option values.  */
   args.textual_date = NULL;
   args.wildcards = default_wildcards;
@@ -2220,7 +2220,7 @@ decode_options (int argc, char **argv)
   args.version_control_string = 0;
   args.input_files = false;
   args.compress_autodetect = false;
-  
+
   subcommand_option = UNKNOWN_SUBCOMMAND;
   archive_format = DEFAULT_FORMAT;
   blocking_factor = DEFAULT_BLOCKING;
@@ -2241,7 +2241,7 @@ decode_options (int argc, char **argv)
   incremental_level = -1;
 
   seek_option = -1;
-  
+
   /* Convert old-style tar call by exploding option element and rearranging
      options accordingly.  */
 
@@ -2396,7 +2396,7 @@ decode_options (int argc, char **argv)
   if (incremental_level != -1 && !listed_incremental_option)
     WARN ((0, 0,
 	   _("--level is meaningless without --listed-incremental")));
-  
+
   if (volume_label_option)
     {
       if (archive_format == GNU_FORMAT || archive_format == OLDGNU_FORMAT)
@@ -2474,7 +2474,7 @@ decode_options (int argc, char **argv)
   if (same_order_option && listed_incremental_option)
     USAGE_ERROR ((0, 0, _("--preserve-order is not compatible with "
 			  "--listed-incremental")));
-  
+
   /* Forbid using -c with no input files whatsoever.  Check that `-f -',
      explicit or implied, is used correctly.  */
 
@@ -2542,7 +2542,7 @@ decode_options (int argc, char **argv)
     }
 
   checkpoint_finish_compile ();
-  
+
   report_textual_dates (&args);
 }
 
@@ -2582,7 +2582,7 @@ main (int argc, char **argv)
 
   /* Try to disable the ability to unlink a directory.  */
   priv_set_remove_linkdir ();
-  
+
   /* Decode options.  */
 
   decode_options (argc, argv);
diff --git a/src/transform.c b/src/transform.c
index 03c06f6..c35133f 100644
--- a/src/transform.c
+++ b/src/transform.c
@@ -1,4 +1,4 @@
-/* This file is part of GNU tar. 
+/* This file is part of GNU tar.
    Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
@@ -34,8 +34,8 @@ enum replace_segm_type
 
 enum case_ctl_type
   {
-    ctl_stop,       /* Stop case conversion */ 
-    ctl_upcase_next,/* Turn the next character to uppercase */ 
+    ctl_stop,       /* Stop case conversion */
+    ctl_upcase_next,/* Turn the next character to uppercase */
     ctl_locase_next,/* Turn the next character to lowercase */
     ctl_upcase,     /* Turn the replacement to uppercase until ctl_stop */
     ctl_locase      /* Turn the replacement to lowercase until ctl_stop */
@@ -51,9 +51,9 @@ struct replace_segm
     {
       char *ptr;
       size_t size;
-    } literal;                /* type == segm_literal */   
+    } literal;                /* type == segm_literal */
     size_t ref;               /* type == segm_backref */
-    enum case_ctl_type ctl;   /* type == segm_case_ctl */ 
+    enum case_ctl_type ctl;   /* type == segm_case_ctl */
   } v;
 };
 
@@ -75,7 +75,7 @@ int transform_flags = XFORM_ALL;
 static struct transform *transform_head, *transform_tail;
 
 static struct transform *
-new_transform ()
+new_transform (void)
 {
   struct transform *p = xzalloc (sizeof *p);
   if (transform_tail)
@@ -146,7 +146,7 @@ parse_xform_flags (int *pflags, int c)
     case 'R':
       *pflags &= ~XFORM_REGFILE;
       break;
-	
+
     case 'h':
       *pflags |= XFORM_LINK;
       break;
@@ -154,7 +154,7 @@ parse_xform_flags (int *pflags, int c)
     case 'H':
       *pflags &= ~XFORM_LINK;
       break;
-	
+
     case 's':
       *pflags |= XFORM_SYMLINK;
       break;
@@ -204,10 +204,10 @@ parse_transform_expr (const char *expr)
 			      *expr));
 	    }
 	  return expr;
-	}	  
+	}
       USAGE_ERROR ((0, 0, _("Invalid transform expression")));
     }
-  
+
   delim = expr[1];
 
   /* Scan regular expression */
@@ -258,14 +258,14 @@ parse_transform_expr (const char *expr)
 
   if (*p == ';')
     p++;
-  
+
   /* Extract and compile regex */
   str = xmalloc (i - 1);
   memcpy (str, expr + 2, i - 2);
   str[i - 2] = 0;
 
   rc = regcomp (&tf->regex, str, cflags);
-  
+
   if (rc)
     {
       char errbuf[512];
@@ -275,7 +275,7 @@ parse_transform_expr (const char *expr)
 
   if (str[0] == '^' || str[strlen (str) - 1] == '$')
     tf->transform_type = transform_first;
-  
+
   free (str);
 
   /* Extract and compile replacement expr */
@@ -289,7 +289,7 @@ parse_transform_expr (const char *expr)
       if (*cur == '\\')
 	{
 	  size_t n;
-	  
+
 	  add_literal_segment (tf, beg, cur);
 	  switch (*++cur)
 	    {
@@ -310,32 +310,32 @@ parse_transform_expr (const char *expr)
 	      add_char_segment (tf, '\a');
 	      cur++;
 	      break;
-	      
+
 	    case 'b':
 	      add_char_segment (tf, '\b');
 	      cur++;
 	      break;
-	      
+
 	    case 'f':
 	      add_char_segment (tf, '\f');
 	      cur++;
 	      break;
-	      
+
 	    case 'n':
 	      add_char_segment (tf, '\n');
 	      cur++;
 	      break;
-	      
+
 	    case 'r':
 	      add_char_segment (tf, '\r');
 	      cur++;
 	      break;
-	      
+
 	    case 't':
 	      add_char_segment (tf, '\t');
 	      cur++;
 	      break;
-	      
+
 	    case 'v':
 	      add_char_segment (tf, '\v');
 	      cur++;
@@ -345,39 +345,39 @@ parse_transform_expr (const char *expr)
 	      add_char_segment (tf, '&');
 	      cur++;
 	      break;
-	      
+
 	    case 'L':
 	      /* Turn the replacement to lowercase until a `\U' or `\E'
 		 is found, */
 	      add_case_ctl_segment (tf, ctl_locase);
 	      cur++;
 	      break;
- 
+
 	    case 'l':
 	      /* Turn the next character to lowercase, */
 	      add_case_ctl_segment (tf, ctl_locase_next);
 	      cur++;
 	      break;
-	      
+
 	    case 'U':
 	      /* Turn the replacement to uppercase until a `\L' or `\E'
 		 is found, */
 	      add_case_ctl_segment (tf, ctl_upcase);
 	      cur++;
 	      break;
-	      
+
 	    case 'u':
 	      /* Turn the next character to uppercase, */
 	      add_case_ctl_segment (tf, ctl_upcase_next);
 	      cur++;
 	      break;
-	      
+
 	    case 'E':
 	      /* Stop case conversion started by `\L' or `\U'. */
 	      add_case_ctl_segment (tf, ctl_stop);
 	      cur++;
 	      break;
-  
+
 	    default:
 	      /* Try to be nice */
 	      {
@@ -420,7 +420,7 @@ run_case_conv (enum case_ctl_type case_ctl, char *ptr, size_t size)
   static char *case_ctl_buffer;
   static size_t case_ctl_bufsize;
   char *p;
-  
+
   if (case_ctl_bufsize < size)
     {
       case_ctl_bufsize = size;
@@ -432,16 +432,16 @@ run_case_conv (enum case_ctl_type case_ctl, char *ptr, size_t size)
     case ctl_upcase_next:
       case_ctl_buffer[0] = toupper ((unsigned char) case_ctl_buffer[0]);
       break;
-      
+
     case ctl_locase_next:
       case_ctl_buffer[0] = tolower ((unsigned char) case_ctl_buffer[0]);
       break;
-      
+
     case ctl_upcase:
       for (p = case_ctl_buffer; p < case_ctl_buffer + size; p++)
 	*p = toupper ((unsigned char) *p);
       break;
-      
+
     case ctl_locase:
       for (p = case_ctl_buffer; p < case_ctl_buffer + size; p++)
 	*p = tolower ((unsigned char) *p);
@@ -457,7 +457,7 @@ run_case_conv (enum case_ctl_type case_ctl, char *ptr, size_t size)
 static struct obstack stk;
 static bool stk_init;
 
-void
+static void
 _single_transform_name_to_obstack (struct transform *tf, char *input)
 {
   regmatch_t *rmp;
@@ -465,7 +465,7 @@ _single_transform_name_to_obstack (struct transform *tf, char *input)
   size_t nmatches = 0;
   enum case_ctl_type case_ctl = ctl_stop,  /* Current case conversion op */
                      save_ctl = ctl_stop;  /* Saved case_ctl for \u and \l */
-  
+
   /* Reset case conversion after a single-char operation */
 #define CASE_CTL_RESET()  if (case_ctl == ctl_upcase_next     \
 			      || case_ctl == ctl_locase_next) \
@@ -473,20 +473,20 @@ _single_transform_name_to_obstack (struct transform *tf, char *input)
                               case_ctl = save_ctl;            \
                               save_ctl = ctl_stop;            \
 			    }
-  
+
   rmp = xmalloc ((tf->regex.re_nsub + 1) * sizeof (*rmp));
 
   while (*input)
     {
       size_t disp;
       char *ptr;
-      
+
       rc = regexec (&tf->regex, input, tf->regex.re_nsub + 1, rmp, 0);
-      
+
       if (rc == 0)
 	{
 	  struct replace_segm *segm;
-	  
+
 	  disp = rmp[0].rm_eo;
 
 	  if (rmp[0].rm_so)
@@ -516,7 +516,7 @@ _single_transform_name_to_obstack (struct transform *tf, char *input)
 		    }
 		  obstack_grow (&stk, ptr, segm->v.literal.size);
 		  break;
-	      
+
 		case segm_backref:    /* Back-reference segment */
 		  if (rmp[segm->v.ref].rm_so != -1
 		      && rmp[segm->v.ref].rm_eo != -1)
@@ -529,7 +529,7 @@ _single_transform_name_to_obstack (struct transform *tf, char *input)
 			  ptr = run_case_conv (case_ctl, ptr, size);
 			  CASE_CTL_RESET();
 			}
-		      
+
 		      obstack_grow (&stk, ptr, size);
 		    }
 		  break;
@@ -549,7 +549,7 @@ _single_transform_name_to_obstack (struct transform *tf, char *input)
 			  break;
 			}
 		      /*FALL THROUGH*/
-		      
+
 		    case ctl_upcase:
 		    case ctl_locase:
 		    case ctl_stop:
@@ -577,18 +577,18 @@ _single_transform_name_to_obstack (struct transform *tf, char *input)
   free (rmp);
 }
 
-bool
+static bool
 _transform_name_to_obstack (int flags, char *input, char **output)
 {
   struct transform *tf;
   bool alloced = false;
-  
+
   if (!stk_init)
     {
       obstack_init (&stk);
       stk_init = true;
     }
-  
+
   for (tf = transform_head; tf; tf = tf->next)
     {
       if (tf->flags & flags)
@@ -601,7 +601,7 @@ _transform_name_to_obstack (int flags, char *input, char **output)
   *output = input;
   return alloced;
 }
-  
+
 bool
 transform_name_fp (char **pinput, int flags,
 		   char *(*fun)(char *, void *), void *dat)
diff --git a/src/unlink.c b/src/unlink.c
index 2af6f99..817ab4a 100644
--- a/src/unlink.c
+++ b/src/unlink.c
@@ -1,4 +1,4 @@
-/* This file is part of GNU tar. 
+/* This file is part of GNU tar.
    Copyright (C) 2009 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
@@ -42,7 +42,7 @@ static struct deferred_unlink *dunlink_avail;
 size_t deferred_unlink_delay = 0;
 
 static struct deferred_unlink *
-dunlink_alloc ()
+dunlink_alloc (void)
 {
   struct deferred_unlink *p;
   if (dunlink_avail)
@@ -116,7 +116,7 @@ flush_deferred_unlinks (bool force)
 	{
 	  prev = p;
 	  p = next;
-	}	  
+	}
     }
   if (!dunlink_head)
     dunlink_tail = NULL;
@@ -142,13 +142,13 @@ queue_deferred_unlink (const char *name, bool is_dir)
   if (dunlink_head
       && records_written > dunlink_head->records_written + deferred_unlink_delay)
     flush_deferred_unlinks (false);
-  
+
   p = dunlink_alloc ();
   p->next = NULL;
   p->file_name = normalize_filename (name);
   p->is_dir = is_dir;
   p->records_written = records_written;
-  
+
   if (dunlink_tail)
     dunlink_tail->next = p;
   else
-- 
cgit v1.0-41-gc330

