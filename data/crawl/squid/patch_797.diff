@@ -27,140 +27,140 @@ extern "C"
 {
 #endif
 
-/* Definitions for data structures and routines for the regular
- * expression library, version 0.12.
- *
- * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
-
-/* POSIX says that <sys/types.h> must be included (by the caller) before
- * <regex.h>.  */
+    /* Definitions for data structures and routines for the regular
+     * expression library, version 0.12.
+     *
+     * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+     *
+     * This program is free software; you can redistribute it and/or modify
+     * it under the terms of the GNU General Public License as published by
+     * the Free Software Foundation; either version 2, or (at your option)
+     * any later version.
+     *
+     * This program is distributed in the hope that it will be useful,
+     * but WITHOUT ANY WARRANTY; without even the implied warranty of
+     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     * GNU General Public License for more details.
+     *
+     * You should have received a copy of the GNU General Public License
+     * along with this program; if not, write to the Free Software
+     * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
+
+    /* POSIX says that <sys/types.h> must be included (by the caller) before
+     * <regex.h>.  */
 
 #ifdef VMS
-/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
- * should be there.  */
+    /* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
+     * should be there.  */
 #include <stddef.h>
 #endif
 
 
-/* The following bits are used to determine the regexp syntax we
- * recognize.  The set/not-set meanings are chosen so that Emacs syntax
- * remains the value 0.  The bits are given in alphabetical order, and
- * the definitions shifted by one from the previous bit; thus, when we
- * add or remove a bit, only one other definition need change.  */
-typedef unsigned reg_syntax_t;
+    /* The following bits are used to determine the regexp syntax we
+     * recognize.  The set/not-set meanings are chosen so that Emacs syntax
+     * remains the value 0.  The bits are given in alphabetical order, and
+     * the definitions shifted by one from the previous bit; thus, when we
+     * add or remove a bit, only one other definition need change.  */
+    typedef unsigned reg_syntax_t;
 
-/* If this bit is not set, then \ inside a bracket expression is literal.
- * If set, then such a \ quotes the following character.  */
+    /* If this bit is not set, then \ inside a bracket expression is literal.
+     * If set, then such a \ quotes the following character.  */
 #define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
 
-/* If this bit is not set, then + and ? are operators, and \+ and \? are
- * literals.
- * If set, then \+ and \? are operators and + and ? are literals.  */
+    /* If this bit is not set, then + and ? are operators, and \+ and \? are
+     * literals.
+     * If set, then \+ and \? are operators and + and ? are literals.  */
 #define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
 
-/* If this bit is set, then character classes are supported.  They are:
- * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
- * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
- * If not set, then character classes are not supported.  */
+    /* If this bit is set, then character classes are supported.  They are:
+     * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+     * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+     * If not set, then character classes are not supported.  */
 #define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
 
-/* If this bit is set, then ^ and $ are always anchors (outside bracket
- * expressions, of course).
- * If this bit is not set, then it depends:
- * ^  is an anchor if it is at the beginning of a regular
- * expression or after an open-group or an alternation operator;
- * $  is an anchor if it is at the end of a regular expression, or
- * before a close-group or an alternation operator.
- *
- * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
- * POSIX draft 11.2 says that * etc. in leading positions is undefined.
- * We already implemented a previous draft which made those constructs
- * invalid, though, so we haven't changed the code back.  */
+    /* If this bit is set, then ^ and $ are always anchors (outside bracket
+     * expressions, of course).
+     * If this bit is not set, then it depends:
+     * ^  is an anchor if it is at the beginning of a regular
+     * expression or after an open-group or an alternation operator;
+     * $  is an anchor if it is at the end of a regular expression, or
+     * before a close-group or an alternation operator.
+     *
+     * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+     * POSIX draft 11.2 says that * etc. in leading positions is undefined.
+     * We already implemented a previous draft which made those constructs
+     * invalid, though, so we haven't changed the code back.  */
 #define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
 
-/* If this bit is set, then special characters are always special
- * regardless of where they are in the pattern.
- * If this bit is not set, then special characters are special only in
- * some contexts; otherwise they are ordinary.  Specifically,
- * * + ? and intervals are only special when not after the beginning,
- * open-group, or alternation operator.  */
+    /* If this bit is set, then special characters are always special
+     * regardless of where they are in the pattern.
+     * If this bit is not set, then special characters are special only in
+     * some contexts; otherwise they are ordinary.  Specifically,
+     * * + ? and intervals are only special when not after the beginning,
+     * open-group, or alternation operator.  */
 #define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
 
-/* If this bit is set, then *, +, ?, and { cannot be first in an re or
- * immediately after an alternation or begin-group operator.  */
+    /* If this bit is set, then *, +, ?, and { cannot be first in an re or
+     * immediately after an alternation or begin-group operator.  */
 #define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
 
-/* If this bit is set, then . matches newline.
- * If not set, then it doesn't.  */
+    /* If this bit is set, then . matches newline.
+     * If not set, then it doesn't.  */
 #define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
 
-/* If this bit is set, then . doesn't match NUL.
- * If not set, then it does.  */
+    /* If this bit is set, then . doesn't match NUL.
+     * If not set, then it does.  */
 #define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
 
-/* If this bit is set, nonmatching lists [^...] do not match newline.
- * If not set, they do.  */
+    /* If this bit is set, nonmatching lists [^...] do not match newline.
+     * If not set, they do.  */
 #define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
 
-/* If this bit is set, either \{...\} or {...} defines an
- * interval, depending on RE_NO_BK_BRACES.
- * If not set, \{, \}, {, and } are literals.  */
+    /* If this bit is set, either \{...\} or {...} defines an
+     * interval, depending on RE_NO_BK_BRACES.
+     * If not set, \{, \}, {, and } are literals.  */
 #define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
 
-/* If this bit is set, +, ? and | aren't recognized as operators.
- * If not set, they are.  */
+    /* If this bit is set, +, ? and | aren't recognized as operators.
+     * If not set, they are.  */
 #define RE_LIMITED_OPS (RE_INTERVALS << 1)
 
-/* If this bit is set, newline is an alternation operator.
- * If not set, newline is literal.  */
+    /* If this bit is set, newline is an alternation operator.
+     * If not set, newline is literal.  */
 #define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
 
-/* If this bit is set, then `{...}' defines an interval, and \{ and \}
- * are literals.
- * If not set, then `\{...\}' defines an interval.  */
+    /* If this bit is set, then `{...}' defines an interval, and \{ and \}
+     * are literals.
+     * If not set, then `\{...\}' defines an interval.  */
 #define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
 
-/* If this bit is set, (...) defines a group, and \( and \) are literals.
- * If not set, \(...\) defines a group, and ( and ) are literals.  */
+    /* If this bit is set, (...) defines a group, and \( and \) are literals.
+     * If not set, \(...\) defines a group, and ( and ) are literals.  */
 #define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
 
-/* If this bit is set, then \<digit> matches <digit>.
- * If not set, then \<digit> is a back-reference.  */
+    /* If this bit is set, then \<digit> matches <digit>.
+     * If not set, then \<digit> is a back-reference.  */
 #define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
 
-/* If this bit is set, then | is an alternation operator, and \| is literal.
- * If not set, then \| is an alternation operator, and | is literal.  */
+    /* If this bit is set, then | is an alternation operator, and \| is literal.
+     * If not set, then \| is an alternation operator, and | is literal.  */
 #define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
 
-/* If this bit is set, then an ending range point collating higher
- * than the starting range point, as in [z-a], is invalid.
- * If not set, then when ending range point collates higher than the
- * starting range point, the range is ignored.  */
+    /* If this bit is set, then an ending range point collating higher
+     * than the starting range point, as in [z-a], is invalid.
+     * If not set, then when ending range point collates higher than the
+     * starting range point, the range is ignored.  */
 #define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
 
-/* If this bit is set, then an unmatched ) is ordinary.
- * If not set, then an unmatched ) is invalid.  */
+    /* If this bit is set, then an unmatched ) is ordinary.
+     * If not set, then an unmatched ) is invalid.  */
 #define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
 
-
-/* Define combinations of the above bits for the standard possibilities.
- * (The [[[ comments delimit what gets put into the Texinfo file, so
- * don't delete them!)  */
-/* [[[begin syntaxes]]] */
+    
+    /* Define combinations of the above bits for the standard possibilities.
+     * (The [[[ comments delimit what gets put into the Texinfo file, so
+     * don't delete them!)  */
+    /* [[[begin syntaxes]]] */
 #define RE_SYNTAX_EMACS 0
 
 #define RE_SYNTAX_AWK							\
@@ -186,22 +186,22 @@ typedef unsigned reg_syntax_t;
 #define RE_SYNTAX_POSIX_EGREP						\
   (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
 
-/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+    /* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
 #define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
 
 #define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
 
-/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+    /* Syntax bits common to both basic and extended POSIX regex syntax.  */
 #define _RE_SYNTAX_POSIX_COMMON						\
   (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
    | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
 
 #define RE_SYNTAX_POSIX_BASIC						\
   (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
 
-/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
- * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
- * isn't minimal, since other operators, such as \`, aren't disabled.  */
+    /* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+     * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+     * isn't minimal, since other operators, such as \`, aren't disabled.  */
 #define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
   (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
 
@@ -211,200 +211,200 @@ typedef unsigned reg_syntax_t;
    | RE_NO_BK_PARENS       | RE_NO_BK_VBAR				\
    | RE_UNMATCHED_RIGHT_PAREN_ORD)
 
-/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
- * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
+    /* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
+     * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
 #define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
   (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
    | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
    | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
    | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
-/* [[[end syntaxes]]] */
-
-/* Maximum number of duplicates an interval can allow.  Some systems
- * (erroneously) define this in other header files, but we want our
- * value, so remove any previous define.  */
+    /* [[[end syntaxes]]] */
+    
+    /* Maximum number of duplicates an interval can allow.  Some systems
+     * (erroneously) define this in other header files, but we want our
+     * value, so remove any previous define.  */
 #ifdef RE_DUP_MAX
 #undef RE_DUP_MAX
 #endif
 #define RE_DUP_MAX ((1 << 15) - 1)
 
 
-/* POSIX `cflags' bits (i.e., information for `regcomp').  */
+    /* POSIX `cflags' bits (i.e., information for `regcomp').  */
 
-/* If this bit is set, then use extended regular expression syntax.
- * If not set, then use basic regular expression syntax.  */
+    /* If this bit is set, then use extended regular expression syntax.
+     * If not set, then use basic regular expression syntax.  */
 #define REG_EXTENDED 1
 
-/* If this bit is set, then ignore case when matching.
- * If not set, then case is significant.  */
+    /* If this bit is set, then ignore case when matching.
+     * If not set, then case is significant.  */
 #define REG_ICASE (REG_EXTENDED << 1)
 
-/* If this bit is set, then anchors do not match at newline
- * characters in the string.
- * If not set, then anchors do match at newlines.  */
+    /* If this bit is set, then anchors do not match at newline
+     * characters in the string.
+     * If not set, then anchors do match at newlines.  */
 #define REG_NEWLINE (REG_ICASE << 1)
 
-/* If this bit is set, then report only success or fail in regexec.
- * If not set, then returns differ between not matching and errors.  */
+    /* If this bit is set, then report only success or fail in regexec.
+     * If not set, then returns differ between not matching and errors.  */
 #define REG_NOSUB (REG_NEWLINE << 1)
 
 
-/* POSIX `eflags' bits (i.e., information for regexec).  */
+    /* POSIX `eflags' bits (i.e., information for regexec).  */
 
-/* If this bit is set, then the beginning-of-line operator doesn't match
- * the beginning of the string (presumably because it's not the
- * beginning of a line).
- * If not set, then the beginning-of-line operator does match the
- * beginning of the string.  */
+    /* If this bit is set, then the beginning-of-line operator doesn't match
+     * the beginning of the string (presumably because it's not the
+     * beginning of a line).
+     * If not set, then the beginning-of-line operator does match the
+     * beginning of the string.  */
 #define REG_NOTBOL 1
 
-/* Like REG_NOTBOL, except for the end-of-line.  */
+    /* Like REG_NOTBOL, except for the end-of-line.  */
 #define REG_NOTEOL (1 << 1)
 
 
-/* If any error codes are removed, changed, or added, update the
- * `re_error_msg' table in regex.c.  */
-typedef enum {
-    REG_NOERROR = 0,		/* Success.  */
-    REG_NOMATCH,		/* Didn't find a match (for regexec).  */
-
-    /* POSIX regcomp return error codes.  (In the order listed in the
-     * standard.)  */
-    REG_BADPAT,			/* Invalid pattern.  */
-    REG_ECOLLATE,		/* Not implemented.  */
-    REG_ECTYPE,			/* Invalid character class name.  */
-    REG_EESCAPE,		/* Trailing backslash.  */
-    REG_ESUBREG,		/* Invalid back reference.  */
-    REG_EBRACK,			/* Unmatched left bracket.  */
-    REG_EPAREN,			/* Parenthesis imbalance.  */
-    REG_EBRACE,			/* Unmatched \{.  */
-    REG_BADBR,			/* Invalid contents of \{\}.  */
-    REG_ERANGE,			/* Invalid range end.  */
-    REG_ESPACE,			/* Ran out of memory.  */
-    REG_BADRPT,			/* No preceding re for repetition op.  */
-
-    /* Error codes we've added.  */
-    REG_EEND,			/* Premature end.  */
-    REG_ESIZE,			/* Compiled pattern bigger than 2^16 bytes.  */
-    REG_ERPAREN			/* Unmatched ) or \); not returned from regcomp.  */
-} reg_errcode_t;
-
-/* This data structure represents a compiled pattern.  Before calling
- * the pattern compiler, the fields `buffer', `allocated', `fastmap',
- * `translate', and `no_sub' can be set.  After the pattern has been
- * compiled, the `re_nsub' field is available.  All other fields are
- * private to the regex routines.  */
-
-struct re_pattern_buffer {
-    /* [[[begin pattern_buffer]]] */
-    /* Space that holds the compiled pattern.  It is declared as
-     * `unsigned char *' because its elements are
-     * sometimes used as array indexes.  */
-    unsigned char *buffer;
-
-    /* Number of bytes to which `buffer' points.  */
-    unsigned long allocated;
-
-    /* Number of bytes actually used in `buffer'.  */
-    unsigned long used;
-
-    /* Syntax setting with which the pattern was compiled.  */
-    reg_syntax_t syntax;
-
-    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
-     * the fastmap, if there is one, to skip over impossible
-     * starting points for matches.  */
-    char *fastmap;
-
-    /* Either a translate table to apply to all characters before
-     * comparing them, or zero for no translation.  The translation
-     * is applied to a pattern when it is compiled and to a string
-     * when it is matched.  */
-    char *translate;
-
-    /* Number of subexpressions found by the compiler.  */
-    size_t re_nsub;
-
-    /* Zero if this pattern cannot match the empty string, one else.
-     * Well, in truth it's used only in `re_search_2', to see
-     * whether or not we should use the fastmap, so we don't set
-     * this absolutely perfectly; see `re_compile_fastmap' (the
-     * `duplicate' case).  */
-    unsigned can_be_null:1;
-
-    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
-     * for `max (RE_NREGS, re_nsub + 1)' groups.
-     * If REGS_REALLOCATE, reallocate space if necessary.
-     * If REGS_FIXED, use what's there.  */
+    /* If any error codes are removed, changed, or added, update the
+     * `re_error_msg' table in regex.c.  */
+    typedef enum {
+        REG_NOERROR = 0,		/* Success.  */
+        REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+
+        /* POSIX regcomp return error codes.  (In the order listed in the
+         * standard.)  */
+        REG_BADPAT,			/* Invalid pattern.  */
+        REG_ECOLLATE,		/* Not implemented.  */
+        REG_ECTYPE,			/* Invalid character class name.  */
+        REG_EESCAPE,		/* Trailing backslash.  */
+        REG_ESUBREG,		/* Invalid back reference.  */
+        REG_EBRACK,			/* Unmatched left bracket.  */
+        REG_EPAREN,			/* Parenthesis imbalance.  */
+        REG_EBRACE,			/* Unmatched \{.  */
+        REG_BADBR,			/* Invalid contents of \{\}.  */
+        REG_ERANGE,			/* Invalid range end.  */
+        REG_ESPACE,			/* Ran out of memory.  */
+        REG_BADRPT,			/* No preceding re for repetition op.  */
+
+        /* Error codes we've added.  */
+        REG_EEND,			/* Premature end.  */
+        REG_ESIZE,			/* Compiled pattern bigger than 2^16 bytes.  */
+        REG_ERPAREN			/* Unmatched ) or \); not returned from regcomp.  */
+    } reg_errcode_t;
+    
+    /* This data structure represents a compiled pattern.  Before calling
+     * the pattern compiler, the fields `buffer', `allocated', `fastmap',
+     * `translate', and `no_sub' can be set.  After the pattern has been
+     * compiled, the `re_nsub' field is available.  All other fields are
+     * private to the regex routines.  */
+
+    struct re_pattern_buffer {
+        /* [[[begin pattern_buffer]]] */
+        /* Space that holds the compiled pattern.  It is declared as
+         * `unsigned char *' because its elements are
+         * sometimes used as array indexes.  */
+        unsigned char *buffer;
+
+        /* Number of bytes to which `buffer' points.  */
+        unsigned long allocated;
+
+        /* Number of bytes actually used in `buffer'.  */
+        unsigned long used;
+
+        /* Syntax setting with which the pattern was compiled.  */
+        reg_syntax_t syntax;
+
+        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
+         * the fastmap, if there is one, to skip over impossible
+         * starting points for matches.  */
+        char *fastmap;
+
+        /* Either a translate table to apply to all characters before
+         * comparing them, or zero for no translation.  The translation
+         * is applied to a pattern when it is compiled and to a string
+         * when it is matched.  */
+        char *translate;
+
+        /* Number of subexpressions found by the compiler.  */
+        size_t re_nsub;
+
+        /* Zero if this pattern cannot match the empty string, one else.
+         * Well, in truth it's used only in `re_search_2', to see
+         * whether or not we should use the fastmap, so we don't set
+         * this absolutely perfectly; see `re_compile_fastmap' (the
+         * `duplicate' case).  */
+        unsigned can_be_null:1;
+
+        /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+         * for `max (RE_NREGS, re_nsub + 1)' groups.
+         * If REGS_REALLOCATE, reallocate space if necessary.
+         * If REGS_FIXED, use what's there.  */
 #define REGS_UNALLOCATED 0
 #define REGS_REALLOCATE 1
 #define REGS_FIXED 2
-    unsigned regs_allocated:2;
+        unsigned regs_allocated:2;
 
-    /* Set to zero when `regex_compile' compiles a pattern; set to one
-     * by `re_compile_fastmap' if it updates the fastmap.  */
-    unsigned fastmap_accurate:1;
+        /* Set to zero when `regex_compile' compiles a pattern; set to one
+         * by `re_compile_fastmap' if it updates the fastmap.  */
+        unsigned fastmap_accurate:1;
 
-    /* If set, `re_match_2' does not return information about
-     * subexpressions.  */
-    unsigned no_sub:1;
+        /* If set, `re_match_2' does not return information about
+         * subexpressions.  */
+        unsigned no_sub:1;
 
-    /* If set, a beginning-of-line anchor doesn't match at the
-     * beginning of the string.  */
-    unsigned not_bol:1;
+        /* If set, a beginning-of-line anchor doesn't match at the
+         * beginning of the string.  */
+        unsigned not_bol:1;
 
-    /* Similarly for an end-of-line anchor.  */
-    unsigned not_eol:1;
+        /* Similarly for an end-of-line anchor.  */
+        unsigned not_eol:1;
 
-    /* If true, an anchor at a newline matches.  */
-    unsigned newline_anchor:1;
+        /* If true, an anchor at a newline matches.  */
+        unsigned newline_anchor:1;
 
-    /* [[[end pattern_buffer]]] */
-};
+        /* [[[end pattern_buffer]]] */
+    };
 
-typedef struct re_pattern_buffer regex_t;
+    typedef struct re_pattern_buffer regex_t;
 
 
-/* search.c (search_buffer) in Emacs needs this one opcode value.  It is
- * defined both in `regex.c' and here.  */
+    /* search.c (search_buffer) in Emacs needs this one opcode value.  It is
+     * defined both in `regex.c' and here.  */
 #define RE_EXACTN_VALUE 1
-
-/* Type for byte offsets within the string.  POSIX mandates this.  */
-typedef int regoff_t;
+    
+    /* Type for byte offsets within the string.  POSIX mandates this.  */
+    typedef int regoff_t;
 
 
-/* This is the structure we store register match data in.  See
- * regex.texinfo for a full description of what registers match.  */
-struct re_registers {
-    unsigned num_regs;
-    regoff_t *start;
-    regoff_t *end;
-};
+    /* This is the structure we store register match data in.  See
+     * regex.texinfo for a full description of what registers match.  */
+    struct re_registers {
+        unsigned num_regs;
+        regoff_t *start;
+        regoff_t *end;
+    };
 
 
-/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
- * `re_match_2' returns information about at least this many registers
- * the first time a `regs' structure is passed.  */
+    /* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+     * `re_match_2' returns information about at least this many registers
+     * the first time a `regs' structure is passed.  */
 #ifndef RE_NREGS
 #define RE_NREGS 30
 #endif
 
 
-/* POSIX specification for registers.  Aside from the different names than
- * `re_registers', POSIX uses an array of structures, instead of a
- * structure of arrays.  */
-typedef struct {
-    regoff_t rm_so;		/* Byte offset from string's start to substring's start.  */
-    regoff_t rm_eo;		/* Byte offset from string's start to substring's end.  */
-} regmatch_t;
-
-/* Declarations for routines.  */
+    /* POSIX specification for registers.  Aside from the different names than
+     * `re_registers', POSIX uses an array of structures, instead of a
+     * structure of arrays.  */
+    typedef struct {
+        regoff_t rm_so;		/* Byte offset from string's start to substring's start.  */
+        regoff_t rm_eo;		/* Byte offset from string's start to substring's end.  */
+    } regmatch_t;
+    
+    /* Declarations for routines.  */
 
-/* To avoid duplicating every routine declaration -- once with a
- * prototype (if we are ANSI), and once without (if we aren't) -- we
- * use the following macro to declare argument types.  This
- * unfortunately clutters up the declarations a bit, but I think it's
- * worth it.  */
+    /* To avoid duplicating every routine declaration -- once with a
+     * prototype (if we are ANSI), and once without (if we aren't) -- we
+     * use the following macro to declare argument types.  This
+     * unfortunately clutters up the declarations a bit, but I think it's
+     * worth it.  */
 
 #if STDC_HEADERS
 
@@ -416,15 +416,15 @@ typedef struct {
 
 #endif /* not __STDC__ */
 
-/* POSIX compatibility.  */
-extern int regcomp _RE_ARGS((regex_t * preg, const char *pattern, int cflags));
-extern int regexec
-    _RE_ARGS((const regex_t * preg, const char *string, size_t nmatch,
-              regmatch_t pmatch[], int eflags));
-extern size_t regerror
-    _RE_ARGS((int errcode, const regex_t * preg, char *errbuf,
-              size_t errbuf_size));
-extern void regfree _RE_ARGS((regex_t * preg));
+    /* POSIX compatibility.  */
+    extern int regcomp _RE_ARGS((regex_t * preg, const char *pattern, int cflags));
+    extern int regexec
+        _RE_ARGS((const regex_t * preg, const char *string, size_t nmatch,
+                  regmatch_t pmatch[], int eflags));
+    extern size_t regerror
+        _RE_ARGS((int errcode, const regex_t * preg, char *errbuf,
+                  size_t errbuf_size));
+    extern void regfree _RE_ARGS((regex_t * preg));
 
 #ifdef __cplusplus
 }
@@ -51,6 +51,6 @@ extern "C" void
 #else
 extern void
 #endif
-xassert(const char *, const char *, int);
+    xassert(const char *, const char *, int);
 
 #endif /* SQUID_ASSERT_H */
@@ -9,10 +9,10 @@
  * From discussions it was chosen to push compat code as far down as possible.
  * That means we can have a seperate compat for most
  *  compatability and portability hacks and resolutions.
- * 
+ *
  * This file is meant to collate all those hacks files together and
  * provide a simple include for them in the core squid headers
- * (presently squid.h and config.h) 
+ * (presently squid.h and config.h)
  *
  * It should not be included directly in any of the squid sources.
  * If your code requires any symbols from here you should be importing
@@ -8,7 +8,7 @@
 /*
  * This file contains all the compatibility and portability hacks
  * Which are general-case and shared between all OS and support programs.
- * 
+ *
  * If an OS-specific hack is needed there are per-OS files for that in
  * the os/ sub-directory here.
  *
@@ -54,7 +54,7 @@
 
 /*
  * Filedescriptor limits in the different select loops
- * 
+ *
  * NP: FreeBSD 7 defines FD_SETSIZE as unsigned but Squid needs
  *     it to be signed to compare it with signed values.
  *     Linux and others including FreeBSD <7, define it as signed.
@@ -84,8 +84,7 @@
  * source code cleaner, so we don't need lots of ifdefs in other
  * places
  */
-struct rusage
-{
+struct rusage {
     struct timeval ru_stime;
     struct timeval ru_utime;
     int ru_maxrss;
@@ -35,7 +35,7 @@
  * WAS: lots of special wrappers labeled only 'protect NEXTSTEP'
  * I'm assuming its an incomplete definition problem on that OS.
  * Or a missing safety wrapper by the looks of the _SQUID_NETDB_H_
- * 
+ *
  * Anyway, this file is included before all general non-type headers.
  * doing the include here for Next and undefining HAVE_NETDB_H will
  * save us from including it again in general.
@@ -15,14 +15,14 @@
 #if defined(i386) || defined(__i386)
 #ifndef HAVE_PAD128_T
 typedef union {
-	long double	_q;
-	int32_t		_l[4];
+    long double	_q;
+    int32_t		_l[4];
 } pad128_t;
 #endif
 #ifndef HAVE_UPAD128_T
 typedef union {
-	long double	_q;
-	uint32_t	_l[4];
+    long double	_q;
+    uint32_t	_l[4];
 } upad128_t;
 #endif
 #endif
@@ -39,7 +39,7 @@ SQUIDCEXTERN int getrusage(int, struct rusage *);
  */
 SQUIDCEXTERN int getpagesize(void);
 #if !defined(_XPG4_2) && !(defined(__EXTENSIONS__) || \
-        (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)))
+(!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)))
 SQUIDCEXTERN int gethostname(char *, int);
 #endif
 
@@ -544,7 +544,7 @@ main(int argc, char **argv)
         fprintf(stderr, "\t-v 2|3\t\t\tLDAP version\n");
         fprintf(stderr, "\t-Z\t\t\tTLS encrypt the LDAP connection, requires LDAP version 3\n");
 #endif
-	fprintf(stderr, "\t-d\t\t\tenable debug mode\n");
+        fprintf(stderr, "\t-d\t\t\tenable debug mode\n");
         fprintf(stderr, "\n");
         fprintf(stderr, "\tIf no search filter is specified, then the dn <userattr>=user,basedn\n\twill be used (same as specifying a search filter of '<userattr>=',\n\tbut quicker as as there is no need to search for the user DN)\n\n");
         fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
@@ -431,7 +431,7 @@ main(int argc, char **argv)
         fprintf(stderr, "\t-g\t\t\tfirst query parameter is base DN extension\n\t\t\t\tfor this query\n");
         fprintf(stderr, "\t-S\t\t\tStrip NT domain from usernames\n");
         fprintf(stderr, "\t-K\t\t\tStrip Kerberos realm from usernames\n");
-	fprintf(stderr, "\t-d\t\t\tenable debug mode\n");
+        fprintf(stderr, "\t-d\t\t\tenable debug mode\n");
         fprintf(stderr, "\n");
         fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
         exit(1);
@@ -94,11 +94,11 @@ CvtBin(const HASHHEX Hex, HASH Bin)
         else
             Bin[i / 2] |= n;
     }
-/* FIXME: Coverity detects the below as dead code.
-  Why? :: right here i == 32 
-    which means the first step of the for loop makes i==16
-    and cannot be < HASHLEN (which is also 16)
-*/
+    /* FIXME: Coverity detects the below as dead code.
+      Why? :: right here i == 32
+        which means the first step of the for loop makes i==16
+        and cannot be < HASHLEN (which is also 16)
+    */
     for (i = i / 2; i < HASHLEN; i++) {
         Bin[i] = '\0';
     }
@@ -12,7 +12,7 @@
 void (*snmplib_debug_hook) (int, char *,...) = NULL;
 
 extern void
-snmplib_debug(int lvl, const char *fmt,...)
+    snmplib_debug(int lvl, const char *fmt,...)
 {
     char buf[BUFSIZ];
     va_list args;
@@ -121,24 +121,24 @@ ACL::Prototype ACLUrlPort::RegistryProtoype(&ACLUrlPort::RegistryEntry_, "port")
 ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrategy::Instance(), "port");
 
 #ifdef USE_SSL
-    ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
-    ACLStrategised<int> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
-    ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
-    ACLStrategised<SSL *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (sslGetUserAttribute), ACLCertificateStrategy::Instance(), "user_cert");
-    ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
-    ACLStrategised<SSL *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (sslGetCAAttribute), ACLCertificateStrategy::Instance(), "ca_cert");
+ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
+ACLStrategised<int> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
+ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
+ACLStrategised<SSL *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (sslGetUserAttribute), ACLCertificateStrategy::Instance(), "user_cert");
+ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
+ACLStrategised<SSL *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (sslGetCAAttribute), ACLCertificateStrategy::Instance(), "ca_cert");
 #endif
 
 #ifdef USE_ARP_ACL
-    ACL::Prototype ACLARP::RegistryProtoype(&ACLARP::RegistryEntry_, "arp");
-    ACLARP ACLARP::RegistryEntry_("arp");
+ACL::Prototype ACLARP::RegistryProtoype(&ACLARP::RegistryEntry_, "arp");
+ACLARP ACLARP::RegistryEntry_("arp");
 #endif
 
 #if USE_IDENT
-    ACL::Prototype ACLIdent::UserRegistryProtoype(&ACLIdent::UserRegistryEntry_, "ident");
-    ACLIdent ACLIdent::UserRegistryEntry_(new ACLUserData, "ident");
-    ACL::Prototype ACLIdent::RegexRegistryProtoype(&ACLIdent::RegexRegistryEntry_, "ident_regex" );
-    ACLIdent ACLIdent::RegexRegistryEntry_(new ACLRegexData, "ident_regex");
+ACL::Prototype ACLIdent::UserRegistryProtoype(&ACLIdent::UserRegistryEntry_, "ident");
+ACLIdent ACLIdent::UserRegistryEntry_(new ACLUserData, "ident");
+ACL::Prototype ACLIdent::RegexRegistryProtoype(&ACLIdent::RegexRegistryEntry_, "ident_regex" );
+ACLIdent ACLIdent::RegexRegistryEntry_(new ACLRegexData, "ident_regex");
 #endif
 
 
@@ -40,7 +40,7 @@
 /**
  \defgroup CacheManagerAPI Cache Manager API
  \ingroup Components
- * 
+ *
  \defgroup CacheManagerInternal Cache Manager intenal API (not for public use)
  \ingroup CacheManagerAPI
  */
@@ -236,7 +236,7 @@ httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p)
 
             /* print option name */
             packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                SQUIDSTRINGPRINT(CcFieldsInfo[flag].name));
+                         SQUIDSTRINGPRINT(CcFieldsInfo[flag].name));
 
             /* handle options with values */
 
@@ -255,7 +255,7 @@ httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p)
 
     if (cc->other.size() != 0)
         packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-            SQUIDSTRINGPRINT(cc->other));
+                     SQUIDSTRINGPRINT(cc->other));
 }
 
 /* negative max_age will clean old max_Age setting */
@@ -258,7 +258,7 @@ httpHdrScTargetPackInto(const HttpHdrScTarget * sc, Packer * p)
 
             /* print option name */
             packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
+                         SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
 
             /* handle options with values */
 
@@ -384,7 +384,7 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
     }
 
     /* mangler or checklist went away. default allow */
-    if(!hm || !hm->access_list) {
+    if (!hm || !hm->access_list) {
         return 1;
     }
 
@@ -287,7 +287,8 @@ MemBuf::Printf(const char *fmt,...)
  * vPrintf for other printf()'s to use; calls vsnprintf, extends buf if needed
  */
 void
-MemBuf::vPrintf(const char *fmt, va_list vargs) {
+MemBuf::vPrintf(const char *fmt, va_list vargs)
+{
 #ifdef VA_COPY
     va_list ap;
 #endif
@@ -345,7 +346,8 @@ MemBuf::vPrintf(const char *fmt, va_list vargs) {
  \retval free() function to be used.
  */
 FREE *
-MemBuf::freeFunc() {
+MemBuf::freeFunc()
+{
     FREE *ff;
     assert(buf);
     assert(!stolen);	/* not frozen */
@@ -359,7 +361,8 @@ MemBuf::freeFunc() {
  * Grows (doubles) internal buffer to satisfy required minimal capacity
  */
 void
-MemBuf::grow(mb_size_t min_cap) {
+MemBuf::grow(mb_size_t min_cap)
+{
     size_t new_cap;
     size_t buf_cap;
 
@@ -403,7 +406,8 @@ MemBuf::grow(mb_size_t min_cap) {
  * Puts report on MemBuf _module_ usage into mb
  */
 void
-memBufReport(MemBuf * mb) {
+memBufReport(MemBuf * mb)
+{
     assert(mb);
     mb->Printf("memBufReport is not yet implemented @?@\n");
 }
@@ -344,20 +344,20 @@ GetOSVersion()
                 WIN32_OS_string = xstrdup("Windows Server 2008");
             return _WIN_OS_WINLON;
         }
-	if ((osvi.dwMajorVersion == 6) && (osvi.dwMinorVersion == 1)) {
-	    if (osvi.wProductType == VER_NT_WORKSTATION)
-		WIN32_OS_string = xstrdup("Windows 7");
-	    else
-		WIN32_OS_string = xstrdup("Windows Server 2008 R2");
-	    return _WIN_OS_WIN7;
-	}
-	if (((osvi.dwMajorVersion > 6)) || ((osvi.dwMajorVersion == 6) && (osvi.dwMinorVersion > 1))) {
-	    if (osvi.wProductType == VER_NT_WORKSTATION)
-		WIN32_OS_string = xstrdup("Unknown Windows version, assuming Windows 7 capabilities");
-	    else
-		WIN32_OS_string = xstrdup("Unknown Windows version, assuming Windows Server 2008 R2 capabilities");
-	    return _WIN_OS_WIN7;
-	}
+        if ((osvi.dwMajorVersion == 6) && (osvi.dwMinorVersion == 1)) {
+            if (osvi.wProductType == VER_NT_WORKSTATION)
+                WIN32_OS_string = xstrdup("Windows 7");
+            else
+                WIN32_OS_string = xstrdup("Windows Server 2008 R2");
+            return _WIN_OS_WIN7;
+        }
+        if (((osvi.dwMajorVersion > 6)) || ((osvi.dwMajorVersion == 6) && (osvi.dwMinorVersion > 1))) {
+            if (osvi.wProductType == VER_NT_WORKSTATION)
+                WIN32_OS_string = xstrdup("Unknown Windows version, assuming Windows 7 capabilities");
+            else
+                WIN32_OS_string = xstrdup("Unknown Windows version, assuming Windows Server 2008 R2 capabilities");
+            return _WIN_OS_WIN7;
+        }
         break;
     case VER_PLATFORM_WIN32_WINDOWS:
         if ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion == 0)) {
@@ -225,7 +225,7 @@ aclParseArpList(SplayNode<acl_arp_data *> **curlist)
 int
 ACLARP::match(ACLChecklist *cl)
 {
-	ACLFilledChecklist *checklist = Filled(cl);
+    ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv6 does not do ARP */
     if (!checklist->src_addr.IsIPv4()) {
@@ -97,7 +97,7 @@ class ACLChecklist
 
     /**
      * Trigger a blocking access check for a set of *_access options.
-     * 
+     *
      * ACLs which cannot be satisfied directly from available data are ignored.
      * This means any proxy_auth, external_acl, DNS lookups, Ident lookups etc
      * which have not already been performed and cached will not be checked.
@@ -106,19 +106,19 @@ class ACLChecklist
      * However callers should perform their own check and default based on local
      * knowledge of the ACL usage rather than depend on this default.
      * That will also save on work setting up ACLChecklist fields for a no-op.
-     * 
+     *
      * \retval  1/true    Access Allowed
      * \retval 0/false    Access Denied
      */
     int fastCheck();
 
     /**
      * Trigger a blocking access check for a single ACL line (a AND b AND c).
-     * 
+     *
      * ACLs which cannot be satisfied directly from available data are ignored.
      * This means any proxy_auth, external_acl, DNS lookups, Ident lookups etc
      * which have not already been performed and cached will not be checked.
-     * 
+     *
      * \retval  1/true    Access Allowed
      * \retval 0/false    Access Denied
      */
@@ -148,11 +148,11 @@ class ACLChecklist
     void changeState(AsyncState *);
     AsyncState *asyncState() const;
 
-	// XXX: ACLs that need request or reply have to use ACLFilledChecklist and
-	// should do their own checks so that we do not have to povide these two
+    // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
+    // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
-	virtual bool hasRequest() const = 0;
-	virtual bool hasReply() const = 0;
+    virtual bool hasRequest() const = 0;
+    virtual bool hasReply() const = 0;
 
 protected:
     virtual void checkCallback(allow_t answer);
@@ -52,7 +52,7 @@ DestinationDomainLookup::Instance()
 void
 DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 {
-	ACLFilledChecklist *checklist = Filled(cl);
+    ACLFilledChecklist *checklist = Filled(cl);
     checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(checklist->dst_addr, LookupDone, checklist);
 }
@@ -47,7 +47,7 @@ ACLDestinationIP::typeString() const
 int
 ACLDestinationIP::match(ACLChecklist *cl)
 {
-	ACLFilledChecklist *checklist = Filled(cl);
+    ACLFilledChecklist *checklist = Filled(cl);
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
@@ -80,7 +80,7 @@ DestinationIPLookup::Instance()
 void
 DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 {
-	ACLFilledChecklist *checklist = Filled(cl);
+    ACLFilledChecklist *checklist = Filled(cl);
     checklist->asyncInProgress(true);
     ipcache_nbgethostbyname(checklist->request->GetHost(), LookupDone, checklist);
 }
@@ -77,7 +77,7 @@ ACLExtUser::parse()
 int
 ACLExtUser::match(ACLChecklist *cl)
 {
-	ACLFilledChecklist *checklist = Filled(cl);
+    ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->request->extacl_user.size()) {
         return data->match(checklist->request->extacl_user.termedBuf());
     } else {
@@ -97,7 +97,7 @@ ACLFilledChecklist::checkCallback(allow_t answer)
         conn()->auth_type = AUTH_BROKEN;
     }
 
-	ACLChecklist::checkCallback(answer); // may delete us
+    ACLChecklist::checkCallback(answer); // may delete us
 }
 
 
@@ -230,27 +230,27 @@ ACLFilledChecklist::markSourceDomainChecked()
  *    checkCallback() will delete the list (i.e., self).
  */
 ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_request, const char *ident):
-    dst_peer(NULL),
-    request(NULL),
-    reply(NULL),
-    auth_user_request(NULL),
+        dst_peer(NULL),
+        request(NULL),
+        reply(NULL),
+        auth_user_request(NULL),
 #if SQUID_SNMP
-    snmp_community(NULL),
+        snmp_community(NULL),
 #endif
 #if USE_SSL
-    ssl_error(0),
+        ssl_error(0),
 #endif
-    extacl_entry (NULL),
-    conn_(NULL),
-    fd_(-1),
-    destinationDomainChecked_(false),
-    sourceDomainChecked_(false)
+        extacl_entry (NULL),
+        conn_(NULL),
+        fd_(-1),
+        destinationDomainChecked_(false),
+        sourceDomainChecked_(false)
 {
     my_addr.SetEmpty();
     src_addr.SetEmpty();
     dst_addr.SetEmpty();
     rfc931[0] = '\0';
-    
+
     // cbdataReferenceDone() is in either fastCheck() or the destructor
     if (A)
         accessList = cbdataReference(A);
@@ -17,7 +17,7 @@ class ACLFilledChecklist: public ACLChecklist
     void operator delete(void *);
 
     ACLFilledChecklist();
-	ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
+    ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
     ~ACLFilledChecklist();
 
 public:
@@ -133,7 +133,7 @@ aclIpAddrNetworkCompare(acl_ip_data * const &p, acl_ip_data * const &q)
     A.ApplyMask(q->mask);
 
     debugs(28,9, "aclIpAddrNetworkCompare: compare: " << p->addr1 << "/" << q->mask << " (" << A << ")  vs " <<
-                 q->addr1 << "-" << q->addr2 << "/" << q->mask);
+           q->addr1 << "-" << q->addr2 << "/" << q->mask);
 
     if (q->addr2.IsAnyAddr()) {       /* single address check */
 
@@ -219,7 +219,7 @@ acl_ip_data::DecodeMask(const char *asc, IpAddress &mask, int ctype)
 #if USE_IPV6
         /* HACK: IPv4 netmasks don't cleanly map to IPv6 masks. */
         debugs(28, DBG_IMPORTANT, "WARNING: Netmasks are deprecated. Please use CIDR masks instead.");
-        if(mask.IsIPv4()) {
+        if (mask.IsIPv4()) {
             /* locate what CIDR mask was _probably_ meant to be in its native protocol format. */
             /* this will completely crap out with a security fail-open if the admin is playing mask tricks */
             /* however, thats their fault, and we do warn. see bug 2601 for the effects if we don't do this. */
@@ -150,8 +150,8 @@ template <class MatchType>
 int
 ACLStrategised<MatchType>::match(ACLChecklist *cl)
 {
-	ACLFilledChecklist *checklist = dynamic_cast<ACLFilledChecklist*>(cl);
-	assert(checklist);
+    ACLFilledChecklist *checklist = dynamic_cast<ACLFilledChecklist*>(cl);
+    assert(checklist);
     return matcher->match(data, checklist);
 }
 
@@ -69,10 +69,10 @@ Adaptation::Config::dumpService(StoreEntry *entry, const char *name) const
     for (SCI i = AllServices().begin(); i != AllServices().end(); ++i) {
         const ServiceConfig &cfg = (*i)->cfg();
         storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "_%s %s %d " SQUIDSTRINGPH "\n",
-            name,
-            SQUIDSTRINGPRINT(cfg.key),
-            cfg.methodStr(), cfg.vectPointStr(), cfg.bypass,
-            SQUIDSTRINGPRINT(cfg.uri));
+                          name,
+                          SQUIDSTRINGPRINT(cfg.key),
+                          cfg.methodStr(), cfg.vectPointStr(), cfg.bypass,
+                          SQUIDSTRINGPRINT(cfg.uri));
     }
 }
 
@@ -154,8 +154,8 @@ Adaptation::Config::ParseAccess(ConfigParser &parser)
     ConfigParser::ParseString(&groupId);
     AccessRule *r;
     if (!(r=FindRuleByGroupId(groupId))) {
-	r = new AccessRule(groupId);
-	AllRules().push_back(r);
+        r = new AccessRule(groupId);
+        AllRules().push_back(r);
     }
     r->parse(parser);
 }
@@ -9,7 +9,8 @@
 
 #include "adaptation/Config.h"
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Ecap {
 
 class Config: public Adaptation::Config
@@ -8,7 +8,8 @@
 
 #include <libecap/host/host.h>
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Ecap {
 
 // Squid wrapper, providing host application functionality to eCAP services.
@@ -19,7 +19,8 @@ class HttpMsg;
 class HttpRequest;
 class HttpReply;
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Ecap {
 
 class XactionRep;
@@ -60,7 +60,7 @@ bool Adaptation::Ecap::ServiceRep::wantsUrl(const String &urlPath) const
 
 Adaptation::Initiate *
 Adaptation::Ecap::ServiceRep::makeXactLauncher(Adaptation::Initiator *initiator,
-                                   HttpMsg *virgin, HttpRequest *cause)
+        HttpMsg *virgin, HttpRequest *cause)
 {
     Must(up());
     XactionRep *rep = new XactionRep(initiator, virgin, cause, Pointer(this));
@@ -11,7 +11,8 @@
 #include <libecap/common/forward.h>
 #include <libecap/common/memory.h>
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Ecap {
 
 /* The eCAP service representative maintains information about a single eCAP
@@ -11,8 +11,8 @@ CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Ecap::XactionRep, XactionRep);
 
 
 Adaptation::Ecap::XactionRep::XactionRep(Adaptation::Initiator *anInitiator,
-                             HttpMsg *virginHeader, HttpRequest *virginCause,
-                             const Adaptation::ServicePointer &aService):
+        HttpMsg *virginHeader, HttpRequest *virginCause,
+        const Adaptation::ServicePointer &aService):
         AsyncJob("Adaptation::Ecap::XactionRep"),
         Adaptation::Initiate("Adaptation::Ecap::XactionRep", anInitiator, aService),
         theVirginRep(virginHeader), theCauseRep(NULL),
@@ -16,7 +16,8 @@
 #include <libecap/host/xaction.h>
 #include <libecap/adapter/xaction.h>
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Ecap {
 
 /* The eCAP xaction representative maintains information about a single eCAP
@@ -37,7 +37,8 @@
 // ICAP-related things needed by code unaware of ICAP internals.
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 extern void InitModule();
@@ -42,7 +42,8 @@
 #include "adaptation/icap/ServiceRep.h"
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 class acl_access;
@@ -39,11 +39,11 @@
 // ICAP-related things shared by many ICAP classes
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
-namespace ICAP
-{
+namespace ICAP {
 using Adaptation::Method;
 using Adaptation::methodNone;
 using Adaptation::methodRespmod;
@@ -44,7 +44,8 @@
 // and adapted HTTP messages.
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 class InOut
@@ -11,7 +11,7 @@
 
 
 Adaptation::Icap::Launcher::Launcher(const char *aTypeName,
-                           Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService):
+                                     Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService):
         AsyncJob(aTypeName),
         Adaptation::Initiate(aTypeName, anInitiator, aService),
         theXaction(0), theLaunches(0)
@@ -59,7 +59,8 @@
  */
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 class Xaction;
@@ -38,7 +38,7 @@ Adaptation::Icap::ModXact::State::State()
 }
 
 Adaptation::Icap::ModXact::ModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader,
-                         HttpRequest *virginCause, Adaptation::Icap::ServiceRep::Pointer &aService):
+                                   HttpRequest *virginCause, Adaptation::Icap::ServiceRep::Pointer &aService):
         AsyncJob("Adaptation::Icap::ModXact"),
         Adaptation::Icap::Xaction("Adaptation::Icap::ModXact", anInitiator, aService),
         icapReply(NULL),
@@ -575,7 +575,7 @@ void Adaptation::Icap::ModXact::callException(const std::exception &e)
 
     try {
         debugs(93, 3, HERE << "bypassing " << inCall << " exception: " <<
-            e.what() << ' ' << status());
+               e.what() << ' ' << status());
         bypassFailure();
     } catch (const std::exception &bypassE) {
         Adaptation::Icap::Xaction::callException(bypassE);
@@ -52,7 +52,8 @@
 
 class ChunkedCodingParser;
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 // estimated future presence and size of something (e.g., HTTP body)
@@ -37,7 +37,8 @@
 #include "adaptation/icap/Launcher.h"
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 /* OptXact sends an ICAP OPTIONS request to the ICAP service,
@@ -39,7 +39,8 @@
 
 class wordlist;
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 /* Maintains options supported by a given ICAP service.
@@ -427,7 +427,7 @@ Adaptation::Icap::ServiceRep::optionsFetchTime() const
 
 Adaptation::Initiate *
 Adaptation::Icap::ServiceRep::makeXactLauncher(Adaptation::Initiator *initiator,
-                                 HttpMsg *virgin, HttpRequest *cause)
+        HttpMsg *virgin, HttpRequest *cause)
 {
     return new Adaptation::Icap::ModXactLauncher(initiator, virgin, cause, this);
 }
@@ -41,7 +41,8 @@
 #include "adaptation/icap/Elements.h"
 
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 class Options;
@@ -84,7 +84,7 @@ void Adaptation::Icap::Xaction::openConnection()
         // TODO: can we sync call Adaptation::Icap::Xaction::noteCommConnected here instead?
         typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> Dialer;
         Dialer dialer(this, &Adaptation::Icap::Xaction::noteCommConnected);
-	dialer.params.fd = connection;
+        dialer.params.fd = connection;
         dialer.params.flag = COMM_OK;
         // fake other parameters by copying from the existing connection
         connector = asyncCall(93,3, "Adaptation::Icap::Xaction::noteCommConnected", dialer);
@@ -43,7 +43,8 @@
 class HttpMsg;
 class CommConnectCbParams;
 
-namespace Adaptation {
+namespace Adaptation
+{
 namespace Icap {
 
 /*
@@ -12,8 +12,8 @@
 int
 AuthenticateAcl(ACLChecklist *ch)
 {
-	ACLFilledChecklist *checklist = Filled(ch);
-	HttpRequest *request = checklist->request;
+    ACLFilledChecklist *checklist = Filled(ch);
+    HttpRequest *request = checklist->request;
     http_hdr_type headertype;
 
     if (NULL == request) {
@@ -46,8 +46,8 @@ AuthenticateAcl(ACLChecklist *ch)
      */
     AuthUserRequest *old_auth_user_request = checklist->auth_user_request;
     const auth_acl_t result = AuthUserRequest::tryToAuthenticateAndSetAuthUser(
-        &checklist->auth_user_request, headertype, request, 
-        checklist->conn(), checklist->src_addr);
+                                  &checklist->auth_user_request, headertype, request,
+                                  checklist->conn(), checklist->src_addr);
     if (checklist->auth_user_request)
         AUTHUSERREQUESTLOCK(checklist->auth_user_request, "ACLAuth::authenticated");
     AUTHUSERREQUESTUNLOCK(old_auth_user_request, "old ACLAuth");
@@ -1515,7 +1515,7 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
     }
 
     /* new cache_dir */
-    if(swap->n_configured > 63) {
+    if (swap->n_configured > 63) {
         /* 7 bits, signed */
         debugs(3, DBG_CRITICAL, "WARNING: There is a fixed maximum of 63 cache_dir entries Squid can handle.");
         debugs(3, DBG_CRITICAL, "WARNING: '" << path_str << "' is one to many.");
@@ -244,7 +244,7 @@ clientdbDump(StoreEntry * sentry)
 
     while ((c = (ClientInfo *) hash_next(client_table))) {
         storeAppendPrintf(sentry, "Address: %s\n", hashKeyStr(&c->hash));
-        if( (name = fqdncache_gethostbyaddr(c->addr, 0)) ) {
+        if ( (name = fqdncache_gethostbyaddr(c->addr, 0)) ) {
             storeAppendPrintf(sentry, "Name:    %s\n", name);
         }
         storeAppendPrintf(sentry, "Currently established connections: %d\n",
@@ -533,7 +533,7 @@ ClientHttpRequest::logRequest()
             checklist->reply = HTTPMSGLOCK(al.reply);
 
         if (!Config.accessList.log || checklist->fastCheck()) {
-            if(request)
+            if (request)
                 al.request = HTTPMSGLOCK(request);
             accessLogLog(&al, checklist);
             updateCounters();
@@ -2245,8 +2245,8 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     /* RFC 2616 section 10.5.6 : handle unsupported HTTP versions cleanly. */
     /* We currently only accept 0.9, 1.0, 1.1 */
     if ( (http_ver.major == 0 && http_ver.minor != 9) ||
-         (http_ver.major == 1 && http_ver.minor > 1 ) ||
-         (http_ver.major > 1) ) {
+            (http_ver.major == 1 && http_ver.minor > 1 ) ||
+            (http_ver.major > 1) ) {
 
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Unsupported HTTP version discovered. :\n" << HttpParserHdrBuf(hp));
@@ -3344,7 +3344,7 @@ clientAclChecklistCreate(const acl_access * acl, ClientHttpRequest * http)
 {
     ConnStateData * conn = http->getConn();
     ACLFilledChecklist *ch = new ACLFilledChecklist(acl, http->request,
-        cbdataReferenceValid(conn) && conn != NULL ? conn->rfc931 : dash_str);
+            cbdataReferenceValid(conn) && conn != NULL ? conn->rfc931 : dash_str);
 
     /*
      * hack for ident ACL. It needs to get full addresses, and a place to store
@@ -1357,24 +1357,19 @@ clientReplyContext::buildReplyHeader()
     if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.must_keepalive) {
         debugs(33, 3, "clientBuildReplyHeader: Error, don't keep-alive");
         request->flags.proxy_keepalive = 0;
-    }
-    else if (!Config.onoff.client_pconns && !request->flags.must_keepalive) {
+    } else if (!Config.onoff.client_pconns && !request->flags.must_keepalive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection Keep-Alive not requested by admin or client");
         request->flags.proxy_keepalive = 0;
-    }
-    else if (request->flags.proxy_keepalive && shutting_down) {
+    } else if (request->flags.proxy_keepalive && shutting_down) {
         debugs(88, 3, "clientBuildReplyHeader: Shutting down, don't keep-alive.");
         request->flags.proxy_keepalive = 0;
-    }
-    else if (request->flags.connection_auth && !reply->keep_alive) {
+    } else if (request->flags.connection_auth && !reply->keep_alive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection oriented auth but server side non-persistent");
         request->flags.proxy_keepalive = 0;
-    }
-    else if (reply->bodySize(request->method) < 0) {
+    } else if (reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: can't keep-alive, unknown body size" );
         request->flags.proxy_keepalive = 0;
-    }
-    else if (fdUsageHigh()&& !request->flags.must_keepalive) {
+    } else if (fdUsageHigh()&& !request->flags.must_keepalive) {
         debugs(88, 3, "clientBuildReplyHeader: Not many unused FDs, can't keep-alive");
         request->flags.proxy_keepalive = 0;
     }
@@ -1703,7 +1698,7 @@ void
 clientReplyContext::sendStreamError(StoreIOBuffer const &result)
 {
     /** call clientWriteComplete so the client socket gets closed
-     * 
+     *
      * We call into the stream, because we don't know that there is a
      * client socket!
      */
@@ -2566,8 +2566,8 @@ DeferredReadManager::kickARead(DeferredRead const &aRead) {
     if (aRead.cancelled)
         return;
 
-    if(aRead.theRead.fd>=0 && fd_table[aRead.theRead.fd].closing())
-	return;
+    if (aRead.theRead.fd>=0 && fd_table[aRead.theRead.fd].closing())
+        return;
 
     debugs(5, 3, "Kicking deferred read on FD " << aRead.theRead.fd);
 
@@ -130,7 +130,8 @@ _db_print(const char *format,...)
 }
 
 static void
-_db_print_file(const char *format, va_list args) {
+_db_print_file(const char *format, va_list args)
+{
     if (debug_log == NULL)
         return;
 
@@ -145,7 +146,8 @@ _db_print_file(const char *format, va_list args) {
 }
 
 static void
-_db_print_stderr(const char *format, va_list args) {
+_db_print_stderr(const char *format, va_list args)
+{
     if (opt_debug_stderr < Debug::level)
         return;
 
@@ -157,7 +159,8 @@ _db_print_stderr(const char *format, va_list args) {
 
 #if HAVE_SYSLOG
 static void
-_db_print_syslog(const char *format, va_list args) {
+_db_print_syslog(const char *format, va_list args)
+{
     LOCAL_ARRAY(char, tmpbuf, BUFSIZ);
     /* level 0,1 go to syslog */
 
@@ -179,7 +182,8 @@ _db_print_syslog(const char *format, va_list args) {
 #endif /* HAVE_SYSLOG */
 
 static void
-debugArg(const char *arg) {
+debugArg(const char *arg)
+{
     int s = 0;
     int l = 0;
     int i;
@@ -215,7 +219,8 @@ debugArg(const char *arg) {
 }
 
 static void
-debugOpenLog(const char *logfile) {
+debugOpenLog(const char *logfile)
+{
     if (logfile == NULL) {
         debug_log = stderr;
         return;
@@ -363,7 +368,8 @@ syslog_facility_names[] = {
 #endif
 
 void
-_db_set_syslog(const char *facility) {
+_db_set_syslog(const char *facility)
+{
     opt_syslog_enable = 1;
 #ifdef LOG_LOCAL4
 #ifdef LOG_DAEMON
@@ -399,7 +405,8 @@ _db_set_syslog(const char *facility) {
 #endif
 
 void
-Debug::parseOptions(char const *options) {
+Debug::parseOptions(char const *options)
+{
     int i;
     char *p = NULL;
     char *s = NULL;
@@ -423,7 +430,8 @@ Debug::parseOptions(char const *options) {
 }
 
 void
-_db_init(const char *logfile, const char *options) {
+_db_init(const char *logfile, const char *options)
+{
     Debug::parseOptions(options);
 
     debugOpenLog(logfile);
@@ -438,7 +446,8 @@ _db_init(const char *logfile, const char *options) {
 }
 
 void
-_db_rotate_log(void) {
+_db_rotate_log(void)
+{
     int i;
     LOCAL_ARRAY(char, from, MAXPATHLEN);
     LOCAL_ARRAY(char, to, MAXPATHLEN);
@@ -507,7 +516,8 @@ _db_rotate_log(void) {
 }
 
 static const char *
-debugLogTime(void) {
+debugLogTime(void)
+{
 
     time_t t = getCurrentTime();
 
@@ -533,7 +543,8 @@ debugLogTime(void) {
 }
 
 void
-xassert(const char *msg, const char *file, int line) {
+xassert(const char *msg, const char *file, int line)
+{
     debugs(0, 0, "assertion failed: " << file << ":" << line << ": \"" << msg << "\"");
 
     if (!shutting_down)
@@ -635,7 +646,8 @@ static const char *ctx_get_descr(Ctx ctx);
 
 
 Ctx
-ctx_enter(const char *descr) {
+ctx_enter(const char *descr)
+{
     Ctx_Current_Level++;
 
     if (Ctx_Current_Level <= CTX_MAX_LEVEL)
@@ -650,7 +662,8 @@ ctx_enter(const char *descr) {
 }
 
 void
-ctx_exit(Ctx ctx) {
+ctx_exit(Ctx ctx)
+{
     assert(ctx >= 0);
     Ctx_Current_Level = (ctx >= 0) ? ctx - 1 : -1;
 
@@ -663,7 +676,8 @@ ctx_exit(Ctx ctx) {
  * info for deducing the current execution stack
  */
 static void
-ctx_print(void) {
+ctx_print(void)
+{
     /* lock so _db_print will not call us recursively */
     Ctx_Lock++;
     /* ok, user saw [0,Ctx_Reported_Level] descriptions */
@@ -693,7 +707,8 @@ ctx_print(void) {
 
 /* checks for nulls and overflows */
 static const char *
-ctx_get_descr(Ctx ctx) {
+ctx_get_descr(Ctx ctx)
+{
     if (ctx < 0 || ctx > CTX_MAX_LEVEL)
         return "<lost>";
 
@@ -703,7 +718,8 @@ ctx_get_descr(Ctx ctx) {
 int Debug::TheDepth = 0;
 
 std::ostream &
-Debug::getDebugOut() {
+Debug::getDebugOut()
+{
     assert(TheDepth >= 0);
     ++TheDepth;
     if (TheDepth > 1) {
@@ -720,7 +736,8 @@ Debug::getDebugOut() {
 }
 
 void
-Debug::finishDebug() {
+Debug::finishDebug()
+{
     assert(TheDepth >= 0);
     assert(CurrentDebug);
     if (TheDepth > 1) {
@@ -737,7 +754,8 @@ Debug::finishDebug() {
 // Hack: replaces global ::xassert() to debug debugging assertions
 // Relies on assert macro calling xassert() without a specific scope.
 void
-Debug::xassert(const char *msg, const char *file, int line) {
+Debug::xassert(const char *msg, const char *file, int line)
+{
 
     if (CurrentDebug) {
         *CurrentDebug << "assertion failed: " << file << ":" << line <<
@@ -758,7 +776,7 @@ BuildPrefixInit()
 
     // Disable heuristic if it does not work.
     if (!strstr(file, ThisFileNameTail))
-		return 0;
+        return 0;
 
     return strlen(file)-strlen(ThisFileNameTail);
 }
@@ -679,9 +679,9 @@ idnsSentQueryVC(int fd, char *buf, size_t size, comm_err_t flag, int xerrno, voi
 
     if (flag == COMM_ERR_CLOSING)
         return;
-    
+
     if (fd_table[fd].closing())
-	return;
+        return;
 
     if (flag != COMM_OK || size <= 0) {
         comm_close(fd);
@@ -8,14 +8,16 @@ static ESIParser::Register *prCustom = 0;
 static ESIParser::Register *prLibxml = 0;
 static ESIParser::Register *prExpat = 0;
 
-void Esi::Init() {
+void Esi::Init()
+{
     assert(!prCustom); // we should be called once
     prCustom = new ESIParser::Register("custom", &ESICustomParser::NewParser);
     prLibxml = new ESIParser::Register("libxml2", &ESILibxml2Parser::NewParser);
     prExpat = new ESIParser::Register("expat", &ESIExpatParser::NewParser);
 }
 
-void Esi::Clean() {
+void Esi::Clean()
+{
     assert(prCustom); // we should be called once, and only after Init()
 
     delete prExpat;
@@ -1,10 +1,11 @@
 #ifndef SQUID_ESI_MODULE_H
 #define SQUID_ESI_MODULE_H
 
-namespace Esi {
+namespace Esi
+{
 
-    extern void Init();
-    extern void Clean();
+extern void Init();
+extern void Clean();
 
 }; // namespace Esi
 
@@ -55,12 +55,14 @@ ESIParser::NewParser(ESIParserClient *aClient)
     return (Parser->newParser)(aClient);
 }
 
-ESIParser::Register::Register(const char *_name, ESIParser::Pointer (*_newParser)(ESIParserClient *aClient)) : name(_name), newParser(_newParser) {
+ESIParser::Register::Register(const char *_name, ESIParser::Pointer (*_newParser)(ESIParserClient *aClient)) : name(_name), newParser(_newParser)
+{
     this->next = ESIParser::Parsers;
     ESIParser::Parsers = this;
 }
 
-ESIParser::Register::~Register() {
+ESIParser::Register::~Register()
+{
     // TODO: support random-order deregistration
     assert(ESIParser::Parsers == this);
     ESIParser::Parsers = next;
@@ -201,7 +201,7 @@ FwdState::fwdStart(int client_fd, StoreEntry *entry, HttpRequest *request)
      */
 
     if ( Config.accessList.miss && !request->client_addr.IsNoAddr() &&
-         request->protocol != PROTO_INTERNAL && request->protocol != PROTO_CACHEOBJ) {
+            request->protocol != PROTO_INTERNAL && request->protocol != PROTO_CACHEOBJ) {
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          */
@@ -823,12 +823,11 @@ FwdState::connectStart()
         return;
     }
 
-    if(fs->_peer) {
+    if (fs->_peer) {
         host = fs->_peer->host;
         port = fs->_peer->http_port;
         fd = fwdPconnPool->pop(fs->_peer->name, fs->_peer->http_port, request->GetHost(), client_addr, checkRetriable());
-    }
-    else {
+    } else {
         host = request->GetHost();
         port = request->port;
         fd = fwdPconnPool->pop(host, port, NULL, client_addr, checkRetriable());
@@ -23,16 +23,17 @@ static StoreFSufs<UFSSwapDir> *DiskdInstance;
 #endif
 
 /* TODO: Modify coss code to:
- * (a) remove the StoreFScoss::GetInstance method, 
- * (b) declare the StoreFScoss::stats  as static and 
- * (c) merge the StoreFScoss::stat() method with the static 
+ * (a) remove the StoreFScoss::GetInstance method,
+ * (b) declare the StoreFScoss::stats  as static and
+ * (c) merge the StoreFScoss::stat() method with the static
  *     StoreFScoss::Stats() */
 #ifdef HAVE_FS_COSS
-    StoreFScoss &CossInstance = StoreFScoss::GetInstance();
+StoreFScoss &CossInstance = StoreFScoss::GetInstance();
 #endif
 
 
-void Fs::Init() {
+void Fs::Init()
+{
 
 #ifdef HAVE_FS_UFS
     UfsInstance = new StoreFSufs<UFSSwapDir>("Blocking", "ufs");
@@ -50,7 +51,8 @@ void Fs::Init() {
 }
 
 
-void Fs::Clean() {
+void Fs::Clean()
+{
 #ifdef HAVE_FS_UFS
     delete UfsInstance;
 #endif
@@ -1,10 +1,11 @@
 #ifndef SQUID_FS_MODULE_H
 #define SQUID_FS_MODULE_H
 
-namespace Fs {
+namespace Fs
+{
 
-    extern void Init();
-    extern void Clean();
+extern void Init();
+extern void Clean();
 
 }; // namespace Fs
 
@@ -33,7 +33,7 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
-/* TODO: remove this file as unused */ 
+/* TODO: remove this file as unused */
 
 #include "config.h"
 
@@ -881,7 +881,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, IpAddr
         stuff.S.uri = spec->uri;
         stuff.S.version = spec->version;
         stuff.S.req_hdrs = spec->req_hdrs;
-        if(e)
+        if (e)
             hdr.putInt(HDR_AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
         else
             hdr.putInt(HDR_AGE, 0);
@@ -633,8 +633,8 @@ HttpStateData::keepaliveAccounting(HttpReply *reply)
         if (_peer)
             _peer->stats.n_keepalives_recv++;
 
-	if (Config.onoff.detect_broken_server_pconns
-	&& reply->bodySize(request->method) == -1 && !flags.chunked) {
+        if (Config.onoff.detect_broken_server_pconns
+                && reply->bodySize(request->method) == -1 && !flags.chunked) {
             debugs(11, 1, "keepaliveAccounting: Impossible keep-alive header from '" << entry->url() << "'" );
             // debugs(11, 2, "GOT HTTP REPLY HDR:\n---------\n" << readBuf->content() << "\n----------" );
             flags.keepalive_broken = 1;
@@ -1543,8 +1543,8 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
             if (orig_request->extacl_user.size() && orig_request->extacl_passwd.size()) {
                 char loginbuf[256];
                 snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
-                    SQUIDSTRINGPRINT(orig_request->extacl_user),
-                    SQUIDSTRINGPRINT(orig_request->extacl_passwd));
+                         SQUIDSTRINGPRINT(orig_request->extacl_user),
+                         SQUIDSTRINGPRINT(orig_request->extacl_passwd));
                 httpHeaderPutStrf(hdr_out, HDR_PROXY_AUTHORIZATION, "Basic %s",
                                   base64_encode(loginbuf));
             }
@@ -1572,8 +1572,8 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
             } else if (orig_request->extacl_user.size() && orig_request->extacl_passwd.size()) {
                 char loginbuf[256];
                 snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
-                    SQUIDSTRINGPRINT(orig_request->extacl_user),
-                    SQUIDSTRINGPRINT(orig_request->extacl_passwd));
+                         SQUIDSTRINGPRINT(orig_request->extacl_user),
+                         SQUIDSTRINGPRINT(orig_request->extacl_passwd));
                 httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
                                   base64_encode(loginbuf));
             }
@@ -1610,8 +1610,8 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
             EBIT_SET(cc->mask, CC_NO_CACHE);
 #endif
 
-	/* Add max-age only without no-cache */
-	if (!EBIT_TEST(cc->mask, CC_MAX_AGE) && !EBIT_TEST(cc->mask, CC_NO_CACHE)) {
+        /* Add max-age only without no-cache */
+        if (!EBIT_TEST(cc->mask, CC_MAX_AGE) && !EBIT_TEST(cc->mask, CC_NO_CACHE)) {
             const char *url =
                 entry ? entry->url() : urlCanonical(orig_request);
             httpHdrCcSetMaxAge(cc, getMaxAge(url));
@@ -1662,7 +1662,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
     switch (e->id) {
 
-/** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid should not pass on. */
+        /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid should not pass on. */
 
     case HDR_PROXY_AUTHORIZATION:
         /** \par Proxy-Authorization:
@@ -1678,7 +1678,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
         break;
 
-/** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid does not pass on. */
+        /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid does not pass on. */
 
     case HDR_CONNECTION:          /** \par Connection: */
     case HDR_TE:                  /** \par TE: */
@@ -1690,7 +1690,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
         break;
 
 
-/** \par OTHER headers I haven't bothered to track down yet. */
+        /** \par OTHER headers I haven't bothered to track down yet. */
 
     case HDR_AUTHORIZATION:
         /** \par WWW-Authorization:
@@ -1739,7 +1739,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
     case HDR_IF_MODIFIED_SINCE:
         /** \par If-Modified-Since:
-	 * append unless we added our own;
+        * append unless we added our own;
          * \note at most one client's ims header can pass through */
 
         if (!hdr_out->has(HDR_IF_MODIFIED_SINCE))
@@ -1975,7 +1975,7 @@ HttpStateData::doneSendingRequestBody()
 
 #if HTTP_VIOLATIONS
     if (Config.accessList.brokenPosts) {
-		ACLFilledChecklist ch(Config.accessList.brokenPosts, request, NULL);
+        ACLFilledChecklist ch(Config.accessList.brokenPosts, request, NULL);
         if (!ch.fastCheck()) {
             debugs(11, 5, "doneSendingRequestBody: didn't match brokenPosts");
             CommIoCbParams io(NULL);
@@ -647,7 +647,7 @@ IpAddress::IpAddress(IpAddress *s)
 {
     SetEmpty();
     if (s)
-	memcpy(this, s, sizeof(IpAddress));
+        memcpy(this, s, sizeof(IpAddress));
 }
 
 IpAddress::IpAddress(const struct hostent &s)
@@ -355,10 +355,10 @@ IpIntercept::PfInterception(int fd, const IpAddress &me, IpAddress &client, IpAd
 int
 IpIntercept::NatLookup(int fd, const IpAddress &me, const IpAddress &peer, IpAddress &client, IpAddress &dst)
 {
-  /* --enable-linux-netfilter    */
-  /* --enable-ipfw-transparent   */
-  /* --enable-ipf-transparent    */
-  /* --enable-pf-transparent     */
+    /* --enable-linux-netfilter    */
+    /* --enable-ipfw-transparent   */
+    /* --enable-ipf-transparent    */
+    /* --enable-pf-transparent     */
 #if IPF_TRANSPARENT || LINUX_NETFILTER || IPFW_TRANSPARENT || PF_TRANSPARENT
 
     client = me;
@@ -4,12 +4,12 @@
 
 #include "QosConfig.h"
 
-QosConfig::QosConfig() : 
-	tos_local_hit(0),
-	tos_sibling_hit(0),
-	tos_parent_hit(0),
-	preserve_miss_tos(1),
-	preserve_miss_tos_mask(255)
+QosConfig::QosConfig() :
+        tos_local_hit(0),
+        tos_sibling_hit(0),
+        tos_parent_hit(0),
+        preserve_miss_tos(1),
+        preserve_miss_tos_mask(255)
 {
     ;
 }
@@ -20,22 +20,18 @@ QosConfig::parseConfigLine()
     // %i honors 0 and 0x prefixes, which are important for things like umask
     /* parse options ... */
     char *token;
-    while( (token = strtok(NULL, w_space)) ) {
+    while ( (token = strtok(NULL, w_space)) ) {
 
-        if(strncmp(token, "local-hit=",10) == 0) {
+        if (strncmp(token, "local-hit=",10) == 0) {
             sscanf(&token[10], "%i", &tos_local_hit);
-        }
-        else if(strncmp(token, "sibling-hit=",12) == 0) {
+        } else if (strncmp(token, "sibling-hit=",12) == 0) {
             sscanf(&token[12], "%i", &tos_sibling_hit);
-        }
-        else if(strncmp(token, "parent-hit=",11) == 0) {
+        } else if (strncmp(token, "parent-hit=",11) == 0) {
             sscanf(&token[11], "%i", &tos_parent_hit);
-        }
-        else if(strcmp(token, "disable-preserve-miss") == 0) {
+        } else if (strcmp(token, "disable-preserve-miss") == 0) {
             preserve_miss_tos = 0;
             preserve_miss_tos_mask = 0;
-        }
-        else if(preserve_miss_tos && strncmp(token, "miss-mask=",10) == 0) {
+        } else if (preserve_miss_tos && strncmp(token, "miss-mask=",10) == 0) {
             sscanf(&token[10], "%i", &preserve_miss_tos_mask);
         }
     }
@@ -5,12 +5,12 @@
 #include "QosConfig.h"
 #include "Store.h"
 
-QosConfig::QosConfig() : 
-	tos_local_hit(0),
-	tos_sibling_hit(0),
-	tos_parent_hit(0),
-	preserve_miss_tos(1),
-	preserve_miss_tos_mask(255)
+QosConfig::QosConfig() :
+        tos_local_hit(0),
+        tos_sibling_hit(0),
+        tos_parent_hit(0),
+        preserve_miss_tos(1),
+        preserve_miss_tos_mask(255)
 {
     ;
 }
@@ -21,22 +21,18 @@ QosConfig::parseConfigLine()
     // %i honors 0 and 0x prefixes, which are important for things like umask
     /* parse options ... */
     char *token;
-    while( (token = strtok(NULL, w_space)) ) {
+    while ( (token = strtok(NULL, w_space)) ) {
 
-        if(strncmp(token, "local-hit=",10) == 0) {
+        if (strncmp(token, "local-hit=",10) == 0) {
             sscanf(&token[10], "%i", &tos_local_hit);
-        }
-        else if(strncmp(token, "sibling-hit=",12) == 0) {
+        } else if (strncmp(token, "sibling-hit=",12) == 0) {
             sscanf(&token[12], "%i", &tos_sibling_hit);
-        }
-        else if(strncmp(token, "parent-hit=",11) == 0) {
+        } else if (strncmp(token, "parent-hit=",11) == 0) {
             sscanf(&token[11], "%i", &tos_parent_hit);
-        }
-        else if(strcmp(token, "disable-preserve-miss") == 0) {
+        } else if (strcmp(token, "disable-preserve-miss") == 0) {
             preserve_miss_tos = 0;
             preserve_miss_tos_mask = 0;
-        }
-        else if(preserve_miss_tos && strncmp(token, "miss-mask=",10) == 0) {
+        } else if (preserve_miss_tos && strncmp(token, "miss-mask=",10) == 0) {
             sscanf(&token[10], "%i", &preserve_miss_tos_mask);
         }
     }
@@ -383,7 +383,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 
 #if HAVE_SETSID
     if (opt_no_daemon)
-	setsid();
+        setsid();
 #endif
 
     execvp(prog, (char *const *) args);
@@ -100,16 +100,16 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
 
         if (path[6] != '\0') {
             path += 7;
-	    char *priority = xstrdup(path);
-	    char *facility = (char *) strchr(priority, '.');
-	    if (!facility)
-		facility = (char *) strchr(priority, '|');
-	    if (facility) {
-		*facility++ = '\0';
-		lf->syslog_priority |= syslog_ntoa(facility);
-	    }
-	    lf->syslog_priority |= syslog_ntoa(priority);
-	    xfree(priority);
+            char *priority = xstrdup(path);
+            char *facility = (char *) strchr(priority, '.');
+            if (!facility)
+                facility = (char *) strchr(priority, '|');
+            if (facility) {
+                *facility++ = '\0';
+                lf->syslog_priority |= syslog_ntoa(facility);
+            }
+            lf->syslog_priority |= syslog_ntoa(priority);
+            xfree(priority);
             if (0 == (lf->syslog_priority & PRIORITY_MASK))
                 lf->syslog_priority |= LOG_INFO;
         }
@@ -1230,7 +1230,7 @@ SquidMain(int argc, char **argv)
         storeFsInit();		/* required for config parsing */
 
         /* TODO: call the FS::Clean() in shutdown to do Fs cleanups */
-	Fs::Init();
+        Fs::Init();
 
         /* May not be needed for parsing, have not audited for such */
         DiskIOModule::SetupAllModules();
@@ -301,7 +301,7 @@ PconnPool::pop(const char *host, u_short port, const char *domain, IpAddress &cl
     if (list == NULL) {
         debugs(48, 3, "PconnPool::pop: lookup for key {" << aKey << "} failed.");
         return -1;
-    } else { 
+    } else {
         debugs(48, 3, "PconnPool::pop: found " << hashKeyStr(&list->hash) << (isRetriable?"(to use)":"(to kill)") );
     }
 
@@ -295,9 +295,9 @@ peerSelectFoo(ps_state * ps)
         if (ps->always_direct == 0 && Config.accessList.AlwaysDirect) {
             /** check always_direct; */
             ps->acl_checklist = new ACLFilledChecklist(
-                                    Config.accessList.AlwaysDirect,
-                                    request,
-                                    NULL);		/* ident */
+                Config.accessList.AlwaysDirect,
+                request,
+                NULL);		/* ident */
             ps->acl_checklist->nonBlockingCheck(peerCheckAlwaysDirectDone, ps);
             return;
         } else if (ps->always_direct > 0) {
@@ -306,9 +306,9 @@ peerSelectFoo(ps_state * ps)
         } else if (ps->never_direct == 0 && Config.accessList.NeverDirect) {
             /** check never_direct; */
             ps->acl_checklist = new ACLFilledChecklist(
-                                    Config.accessList.NeverDirect,
-                                    request,
-                                    NULL);		/* ident */
+                Config.accessList.NeverDirect,
+                request,
+                NULL);		/* ident */
             ps->acl_checklist->nonBlockingCheck(peerCheckNeverDirectDone,
                                                 ps);
             return;
@@ -38,13 +38,13 @@
 StorePointer Store::CurrentRoot = NULL;
 
 extern "C" void
-storeAppendPrintf(StoreEntry * e, const char *fmt,...)
+    storeAppendPrintf(StoreEntry * e, const char *fmt,...)
 {
     fatal("Not implemented");
 }
 
 extern "C" void
-storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
+    storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
 {
     fatal("Not implemented");
 }
@@ -135,7 +135,7 @@ fake_auth_setup()
         schemeConfig = getConfig(params[scheme].name);
         if (schemeConfig != NULL)
             setup_scheme(schemeConfig, params[scheme].params,
-                          params[scheme].paramlength);
+                         params[scheme].paramlength);
         else
             fprintf(stderr,"Skipping unknown authentication scheme '%s'.\n",
                     params[scheme].name);
@@ -505,15 +505,17 @@ fatalf(const char *fmt,...)
 
 /* used by fatalf */
 static void
-fatalvf(const char *fmt, va_list args) {
+fatalvf(const char *fmt, va_list args)
+{
     static char fatal_str[BUFSIZ];
     vsnprintf(fatal_str, sizeof(fatal_str), fmt, args);
     fatal(fatal_str);
 }
 
 /* fatal with dumping core */
 void
-fatal_dump(const char *message) {
+fatal_dump(const char *message)
+{
     failure_notify = NULL;
     releaseServerSockets();
 
@@ -536,15 +538,17 @@ fatal_dump(const char *message) {
 }
 
 void
-debug_trap(const char *message) {
+debug_trap(const char *message)
+{
     if (!opt_catch_signals)
         fatal_dump(message);
 
     _db_print("WARNING: %s\n", message);
 }
 
 void
-sig_child(int sig) {
+sig_child(int sig)
+{
 #ifndef _SQUID_MSWIN_
 #ifdef _SQUID_NEXT_
     union wait status;
@@ -59,7 +59,7 @@ storeAppendPrintf(StoreEntry * e, const char *fmt,...)
     va_list args;
     va_start(args, fmt);
 
-	assert(false);
+    assert(false);
 
     va_end(args);
 }
@@ -68,7 +68,7 @@ storeAppendPrintf(StoreEntry * e, const char *fmt,...)
 CacheManager*
 CacheManager::GetInstance()
 {
-	assert(false);
+    assert(false);
     return NULL;
 }
 
@@ -440,7 +440,7 @@ urlCanonical(HttpRequest * request)
 
     if (request->protocol == PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
-            SQUIDSTRINGPRINT(request->urlpath));
+                 SQUIDSTRINGPRINT(request->urlpath));
     } else {
 /// \todo AYJ: this could use "if..else and method == METHOD_CONNECT" easier.
         switch (request->method.id()) {
@@ -484,7 +484,7 @@ urlCanonicalClean(const HttpRequest * request)
 
     if (request->protocol == PROTO_URN) {
         snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
-            SQUIDSTRINGPRINT(request->urlpath));
+                 SQUIDSTRINGPRINT(request->urlpath));
     } else {
 /// \todo AYJ: this could use "if..else and method == METHOD_CONNECT" easier.
         switch (request->method.id()) {
@@ -587,7 +587,7 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 
     if (req->protocol == PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
-            SQUIDSTRINGPRINT(req->urlpath));
+                 SQUIDSTRINGPRINT(req->urlpath));
         return (urlbuf);
     }
 
@@ -202,7 +202,7 @@ UrnState::createUriResRequest (String &uri)
     LOCAL_ARRAY(char, local_urlres, 4096);
     char *host = getHost (uri);
     snprintf(local_urlres, 4096, "http://%s/uri-res/N2L?urn:" SQUIDSTRINGPH,
-        host, SQUIDSTRINGPRINT(uri));
+             host, SQUIDSTRINGPRINT(uri));
     safe_free (host);
     safe_free (urlres);
     urlres = xstrdup (local_urlres);
@@ -204,7 +204,7 @@ struct wccp2_cache_identity_info_t {
 //    uint16_t bits;
 //#define WCCP2_HASH_ASSIGNMENT_DATA  0x0
 
-/* 5.7.2 Hash Assignment Data Element */
+    /* 5.7.2 Hash Assignment Data Element */
     char buckets[32]; /* Draft indicates 8x 32-bit buckets but it's just a mask so doesn't matter how we define. */
     uint16_t weight;
     uint16_t status;
@@ -243,18 +243,18 @@ struct wccp2_cache_mask_identity_info_t {
     uint16_t bits;
 #define WCCP2_MASK_ASSIGNMENT_DATA  (0x1 <<14)
 
-/* Sect 5.7.2 Mask Assignment Data Element
- *
- * NP: draft specifies a variable-length set of keys here.
- *     the following fields only matche the special case Squid sends outbound (single-cache).
- */
-     uint32_t mask_element_count;
+    /* Sect 5.7.2 Mask Assignment Data Element
+     *
+     * NP: draft specifies a variable-length set of keys here.
+     *     the following fields only matche the special case Squid sends outbound (single-cache).
+     */
+    uint32_t mask_element_count;
 
-/* Sect 5.7.6 Mask/Value Set Element */
-/* special case: single mask element. no values. */
+    /* Sect 5.7.6 Mask/Value Set Element */
+    /* special case: single mask element. no values. */
     struct wccp2_mask_element_t mask;
 
-/* Sect 5.7.2 Mask Assignment Data Element */
+    /* Sect 5.7.2 Mask Assignment Data Element */
     uint16_t weight;
     uint16_t status;
 };
@@ -333,13 +333,13 @@ static struct wccp2_capability_element_t wccp2_capability_element;
 /* capability values */
 #define WCCP2_METHOD_GRE		0x00000001
 #define WCCP2_METHOD_L2			0x00000002
- /* when type=WCCP2_CAPABILITY_FORWARDING_METHOD */
+/* when type=WCCP2_CAPABILITY_FORWARDING_METHOD */
 #define WCCP2_FORWARDING_METHOD_GRE	WCCP2_METHOD_GRE
 #define WCCP2_FORWARDING_METHOD_L2	WCCP2_METHOD_L2
- /* when type=WCCP2_CAPABILITY_ASSIGNMENT_METHOD */
+/* when type=WCCP2_CAPABILITY_ASSIGNMENT_METHOD */
 #define WCCP2_ASSIGNMENT_METHOD_HASH	0x00000001
 #define WCCP2_ASSIGNMENT_METHOD_MASK	0x00000002
- /* when type=WCCP2_CAPABILITY_RETURN_METHOD */
+/* when type=WCCP2_CAPABILITY_RETURN_METHOD */
 #define WCCP2_PACKET_RETURN_METHOD_GRE	WCCP2_METHOD_GRE
 #define WCCP2_PACKET_RETURN_METHOD_L2	WCCP2_METHOD_L2
 
@@ -964,8 +964,7 @@ wccp2Init(void)
         if (wccp2_numrouters) {
             if (!eventFind(wccp2HereIam, NULL)) {
                 eventAdd("wccp2HereIam", wccp2HereIam, NULL, 1, 1);
-            }
-            else
+            } else
                 debugs(80,3,"wccp2Init: skip duplicate 'HERE_I_AM'.");
         }
 
@@ -1214,7 +1213,7 @@ wccp2HandleUdp(int sock, void *not_used)
     /* Go through the data structure */
     while (data_length > offset) {
 
-	char *data = wccp2_i_see_you.data;
+        char *data = wccp2_i_see_you.data;
 
         header = (struct wccp2_item_header_t *) &data[offset];
 
@@ -1435,7 +1434,7 @@ wccp2HandleUdp(int sock, void *not_used)
 
         for (num_caches = 0; num_caches < (int) ntohl(tmp); num_caches++) {
             /* Get a copy of the ip */
-	   memset(&cache_address, 0, sizeof(cache_address)); // Make GCC happy
+            memset(&cache_address, 0, sizeof(cache_address)); // Make GCC happy
 
             switch (Config.Wccp2.assignment_method) {
 
@@ -54,7 +54,8 @@ _db_print(const char *format,...)
 }
 
 static void
-_db_print_stderr(const char *format, va_list args) {
+_db_print_stderr(const char *format, va_list args)
+{
     /* FIXME? */
     // if (opt_debug_stderr < Debug::level)
 
@@ -65,43 +66,49 @@ _db_print_stderr(const char *format, va_list args) {
 }
 
 void
-fatal_dump(const char *message) {
+fatal_dump(const char *message)
+{
     debug (0,0) ("Fatal: %s",message);
     exit (1);
 }
 
 void
-fatal(const char *message) {
+fatal(const char *message)
+{
     debug (0,0) ("Fatal: %s",message);
     exit (1);
 }
 
 /* used by fatalf */
 static void
-fatalvf(const char *fmt, va_list args) {
+fatalvf(const char *fmt, va_list args)
+{
     static char fatal_str[BUFSIZ];
     vsnprintf(fatal_str, sizeof(fatal_str), fmt, args);
     fatal(fatal_str);
 }
 
 /* printf-style interface for fatal */
 void
-fatalf(const char *fmt,...) {
+fatalf(const char *fmt,...)
+{
     va_list args;
     va_start(args, fmt);
     fatalvf(fmt, args);
     va_end(args);
 }
 
 void
-debug_trap(const char *message) {
+debug_trap(const char *message)
+{
     fatal(message);
 }
 
 int Debug::TheDepth = 0;
 
 std::ostream &
-Debug::getDebugOut() {
+Debug::getDebugOut()
+{
     assert(TheDepth >= 0);
     ++TheDepth;
     if (TheDepth > 1) {
@@ -118,7 +125,8 @@ Debug::getDebugOut() {
 }
 
 void
-Debug::finishDebug() {
+Debug::finishDebug()
+{
     assert(TheDepth >= 0);
     assert(CurrentDebug);
     if (TheDepth > 1) {
@@ -133,7 +141,8 @@ Debug::finishDebug() {
 }
 
 void
-Debug::xassert(const char *msg, const char *file, int line) {
+Debug::xassert(const char *msg, const char *file, int line)
+{
 
     if (CurrentDebug) {
         *CurrentDebug << "assertion failed: " << file << ":" << line <<
@@ -147,7 +156,8 @@ std::ostringstream *Debug::CurrentDebug (NULL);
 MemAllocator *dlink_node_pool = NULL;
 
 dlink_node *
-dlinkNodeNew() {
+dlinkNodeNew()
+{
     if (dlink_node_pool == NULL)
         dlink_node_pool = memPoolCreate("Dlink list nodes", sizeof(dlink_node));
 
@@ -157,15 +167,17 @@ dlinkNodeNew() {
 
 /* the node needs to be unlinked FIRST */
 void
-dlinkNodeDelete(dlink_node * m) {
+dlinkNodeDelete(dlink_node * m)
+{
     if (m == NULL)
         return;
 
     dlink_node_pool->free(m);
 }
 
 void
-dlinkAdd(void *data, dlink_node * m, dlink_list * list) {
+dlinkAdd(void *data, dlink_node * m, dlink_list * list)
+{
     m->data = data;
     m->prev = NULL;
     m->next = list->head;
@@ -180,7 +192,8 @@ dlinkAdd(void *data, dlink_node * m, dlink_list * list) {
 }
 
 void
-dlinkAddAfter(void *data, dlink_node * m, dlink_node * n, dlink_list * list) {
+dlinkAddAfter(void *data, dlink_node * m, dlink_node * n, dlink_list * list)
+{
     m->data = data;
     m->prev = n;
     m->next = n->next;
@@ -196,7 +209,8 @@ dlinkAddAfter(void *data, dlink_node * m, dlink_node * n, dlink_list * list) {
 }
 
 void
-dlinkAddTail(void *data, dlink_node * m, dlink_list * list) {
+dlinkAddTail(void *data, dlink_node * m, dlink_list * list)
+{
     m->data = data;
     m->next = NULL;
     m->prev = list->tail;
@@ -211,7 +225,8 @@ dlinkAddTail(void *data, dlink_node * m, dlink_list * list) {
 }
 
 void
-dlinkDelete(dlink_node * m, dlink_list * list) {
+dlinkDelete(dlink_node * m, dlink_list * list)
+{
     if (m->next)
         m->next->prev = m->prev;
 
@@ -228,7 +243,8 @@ dlinkDelete(dlink_node * m, dlink_list * list) {
 }
 
 Ctx
-ctx_enter(const char *descr) {
+ctx_enter(const char *descr)
+{
     return 0;
 }
 
@@ -222,8 +222,8 @@ main(int argc, char *argv[])
                 break;
 
             case 'j':
-               host = optarg;
-               break;
+                host = optarg;
+                break;
 
             case 'V':
                 if (optarg != NULL)
@@ -353,99 +353,99 @@ main(int argc, char *argv[])
     }
 
     if (!host) {
-       char *newhost = strstr(url, "://");
-       if (newhost) {
-           char *t;
-           newhost += 3;
-           newhost = strdup(newhost);
-           t = newhost + strcspn(newhost, "@/?");
-           if (*t == '@') {
-               newhost = t + 1;
-               t = newhost + strcspn(newhost, "@/?");
-           }
-           *t = '\0';
-           host = newhost;
-       }
+        char *newhost = strstr(url, "://");
+        if (newhost) {
+            char *t;
+            newhost += 3;
+            newhost = strdup(newhost);
+            t = newhost + strcspn(newhost, "@/?");
+            if (*t == '@') {
+                newhost = t + 1;
+                t = newhost + strcspn(newhost, "@/?");
+            }
+            *t = '\0';
+            host = newhost;
+        }
     }
 
-    if(version[0] == '-' || !version[0] || version[0] == '0') {
-	/* HTTP/0.9, no headers, no version */
+    if (version[0] == '-' || !version[0] || version[0] == '0') {
+        /* HTTP/0.9, no headers, no version */
         snprintf(msg, BUFSIZ, "%s %s\r\n", method, url);
     } else {
         snprintf(msg, BUFSIZ, "%s %s HTTP/%s\r\n", method, url, version);
 
-	if (host) {
-	    snprintf(buf, BUFSIZ, "Host: %s\r\n", host);
-	    strcat(msg,buf);
-	}
-
-	if (reload) {
-	    snprintf(buf, BUFSIZ, "Pragma: no-cache\r\n");
-	    strcat(msg, buf);
-	}
-	if (put_fd > 0) {
-	    snprintf(buf, BUFSIZ, "Content-length: %d\r\n", (int) sb.st_size);
-	    strcat(msg, buf);
-	}
-	if (opt_noaccept == 0) {
-	    snprintf(buf, BUFSIZ, "Accept: */*\r\n");
-	    strcat(msg, buf);
-	}
-	if (ims) {
-	    snprintf(buf, BUFSIZ, "If-Modified-Since: %s\r\n", mkrfc1123(ims));
-	    strcat(msg, buf);
-	}
-	if (max_forwards > -1) {
-	    snprintf(buf, BUFSIZ, "Max-Forwards: %d\r\n", max_forwards);
-	    strcat(msg, buf);
-	}
-	if (proxy_user) {
-	    const char *user = proxy_user;
-	    const char *password = proxy_password;
+        if (host) {
+            snprintf(buf, BUFSIZ, "Host: %s\r\n", host);
+            strcat(msg,buf);
+        }
+
+        if (reload) {
+            snprintf(buf, BUFSIZ, "Pragma: no-cache\r\n");
+            strcat(msg, buf);
+        }
+        if (put_fd > 0) {
+            snprintf(buf, BUFSIZ, "Content-length: %d\r\n", (int) sb.st_size);
+            strcat(msg, buf);
+        }
+        if (opt_noaccept == 0) {
+            snprintf(buf, BUFSIZ, "Accept: */*\r\n");
+            strcat(msg, buf);
+        }
+        if (ims) {
+            snprintf(buf, BUFSIZ, "If-Modified-Since: %s\r\n", mkrfc1123(ims));
+            strcat(msg, buf);
+        }
+        if (max_forwards > -1) {
+            snprintf(buf, BUFSIZ, "Max-Forwards: %d\r\n", max_forwards);
+            strcat(msg, buf);
+        }
+        if (proxy_user) {
+            const char *user = proxy_user;
+            const char *password = proxy_password;
 #if HAVE_GETPASS
-	    if (!password)
-		password = getpass("Proxy password: ");
+            if (!password)
+                password = getpass("Proxy password: ");
 #endif
-	    if (!password) {
-		fprintf(stderr, "ERROR: Proxy password missing\n");
-		exit(1);
-	    }
-	    snprintf(buf, BUFSIZ, "%s:%s", user, password);
-	    snprintf(buf, BUFSIZ, "Proxy-Authorization: Basic %s\r\n", base64_encode(buf));
-	    strcat(msg, buf);
-	}
-	if (www_user) {
-	    const char *user = www_user;
-	    const char *password = www_password;
+            if (!password) {
+                fprintf(stderr, "ERROR: Proxy password missing\n");
+                exit(1);
+            }
+            snprintf(buf, BUFSIZ, "%s:%s", user, password);
+            snprintf(buf, BUFSIZ, "Proxy-Authorization: Basic %s\r\n", base64_encode(buf));
+            strcat(msg, buf);
+        }
+        if (www_user) {
+            const char *user = www_user;
+            const char *password = www_password;
 #if HAVE_GETPASS
-	    if (!password)
-		password = getpass("WWW password: ");
+            if (!password)
+                password = getpass("WWW password: ");
 #endif
-	    if (!password) {
-		fprintf(stderr, "ERROR: WWW password missing\n");
-		exit(1);
-	    }
-	    snprintf(buf, BUFSIZ, "%s:%s", user, password);
-	    snprintf(buf, BUFSIZ, "Authorization: Basic %s\r\n", base64_encode(buf));
-	    strcat(msg, buf);
-	}
-
-	/* HTTP/1.0 may need keep-alive */
-	if (strcmp(version, "1.0") == 0) {
-	    if (keep_alive) {
-		if (strchr(url, ':'))
-		    snprintf(buf, BUFSIZ, "Proxy-Connection: keep-alive\r\n");
-		else
-		    strcat(msg, "Connection: keep-alive\r\n");
-	   }
-	} else {
-	    if (!keep_alive)
-		strcat(msg, "Connection: close\r\n");
-	}
-	strcat(msg, buf);
-
-	strcat(msg, extra_hdrs);
-	strcat(msg, "\r\n");
+            if (!password) {
+                fprintf(stderr, "ERROR: WWW password missing\n");
+                exit(1);
+            }
+            snprintf(buf, BUFSIZ, "%s:%s", user, password);
+            snprintf(buf, BUFSIZ, "Authorization: Basic %s\r\n", base64_encode(buf));
+            strcat(msg, buf);
+        }
+
+        /* HTTP/1.0 may need keep-alive */
+        if (strcmp(version, "1.0") == 0) {
+            if (keep_alive) {
+                if (strchr(url, ':'))
+                    snprintf(buf, BUFSIZ, "Proxy-Connection: keep-alive\r\n");
+                else
+                    strcat(msg, "Connection: keep-alive\r\n");
+            }
+        } else {
+            if (!keep_alive)
+                strcat(msg, "Connection: close\r\n");
+        }
+        strcat(msg, buf);
+
+        strcat(msg, extra_hdrs);
+        strcat(msg, "\r\n");
     }
 
     if (opt_verbose)