@@ -102,7 +102,7 @@
 #endif
 
 ACL::Prototype ACLBrowser::RegistryProtoype(&ACLBrowser::RegistryEntry_, "browser");
-ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_USER_AGENT>::Instance(), "browser");
+ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>::Instance(), "browser");
 ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
 ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&ACLDestinationDomain::LiteralRegistryEntry_, "dstdomain");
 ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain", DestinationDomainFlags);
@@ -144,11 +144,11 @@ ACLStrategised<AnyP::ProtocolType> ACLProtocol::RegistryEntry_(new ACLProtocolDa
 ACL::Prototype ACLRandom::RegistryProtoype(&ACLRandom::RegistryEntry_, "random");
 ACLRandom ACLRandom::RegistryEntry_("random");
 ACL::Prototype ACLReferer::RegistryProtoype(&ACLReferer::RegistryEntry_, "referer_regex");
-ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_REFERER>::Instance(), "referer_regex");
+ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::REFERER>::Instance(), "referer_regex");
 ACL::Prototype ACLReplyMIMEType::RegistryProtoype(&ACLReplyMIMEType::RegistryEntry_, "rep_mime_type");
-ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::Instance(), "rep_mime_type");
+ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "rep_mime_type");
 ACL::Prototype ACLRequestMIMEType::RegistryProtoype(&ACLRequestMIMEType::RegistryEntry_, "req_mime_type");
-ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::Instance(), "req_mime_type");
+ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "req_mime_type");
 ACL::Prototype ACLSourceDomain::LiteralRegistryProtoype(&ACLSourceDomain::LiteralRegistryEntry_, "srcdomain");
 ACLStrategised<char const *> ACLSourceDomain::LiteralRegistryEntry_(new ACLDomainData, ACLSourceDomainStrategy::Instance(), "srcdomain");
 ACL::Prototype ACLSourceDomain::RegexRegistryProtoype(&ACLSourceDomain::RegexRegistryEntry_, "srcdom_regex");
@@ -60,160 +60,160 @@
  * local constants and vars
  */
 
-// statistics counters for headers. clients must not allow HDR_BAD_HDR to be counted
-std::vector<HttpHeaderFieldStat> headerStatsTable(HDR_ENUM_END);
+// statistics counters for headers. clients must not allow Http::HdrType::BAD_HDR to be counted
+std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::ENUM_END);
 
 /*
  * headers with field values defined as #(values) in HTTP/1.1
  * Headers that are currently not recognized, are commented out.
  */
 static HttpHeaderMask ListHeadersMask;  /* set run-time using  ListHeadersArr */
-static http_hdr_type ListHeadersArr[] = {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET,
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES,
-    HDR_ALLOW,
-    HDR_CACHE_CONTROL,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONNECTION,
-    HDR_EXPECT,
-    HDR_IF_MATCH,
-    HDR_IF_NONE_MATCH,
-    HDR_KEY,
-    HDR_LINK,
-    HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_PROXY_SUPPORT,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_VARY,
-    HDR_VIA,
-    HDR_WARNING,
-    HDR_WWW_AUTHENTICATE,
-    HDR_AUTHENTICATION_INFO,
-    HDR_PROXY_AUTHENTICATION_INFO,
-    /* HDR_TE, HDR_TRAILER */
+static Http::HdrType ListHeadersArr[] = {
+    Http::HdrType::ACCEPT,
+    Http::HdrType::ACCEPT_CHARSET,
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_LANGUAGE,
+    Http::HdrType::ACCEPT_RANGES,
+    Http::HdrType::ALLOW,
+    Http::HdrType::CACHE_CONTROL,
+    Http::HdrType::CONTENT_ENCODING,
+    Http::HdrType::CONTENT_LANGUAGE,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::EXPECT,
+    Http::HdrType::IF_MATCH,
+    Http::HdrType::IF_NONE_MATCH,
+    Http::HdrType::KEY,
+    Http::HdrType::LINK,
+    Http::HdrType::PRAGMA,
+    Http::HdrType::PROXY_CONNECTION,
+    Http::HdrType::PROXY_SUPPORT,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    Http::HdrType::VARY,
+    Http::HdrType::VIA,
+    Http::HdrType::WARNING,
+    Http::HdrType::WWW_AUTHENTICATE,
+    Http::HdrType::AUTHENTICATION_INFO,
+    Http::HdrType::PROXY_AUTHENTICATION_INFO,
+    /* Http::HdrType::TE, Http::HdrType::TRAILER */
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+    Http::HdrType::HDR_X_ACCELERATOR_VARY,
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,
+    Http::HdrType::X_NEXT_SERVICES,
 #endif
-    HDR_SURROGATE_CAPABILITY,
-    HDR_SURROGATE_CONTROL,
-    HDR_FORWARDED,
-    HDR_X_FORWARDED_FOR
+    Http::HdrType::SURROGATE_CAPABILITY,
+    Http::HdrType::SURROGATE_CONTROL,
+    Http::HdrType::FORWARDED,
+    Http::HdrType::X_FORWARDED_FOR
 };
 
 /* general-headers */
-static http_hdr_type GeneralHeadersArr[] = {
-    HDR_CACHE_CONTROL,
-    HDR_CONNECTION,
-    HDR_DATE,
-    HDR_FORWARDED,
-    HDR_X_FORWARDED_FOR,
-    HDR_MIME_VERSION,
-    HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    /* HDR_TRAILER, */
-    HDR_VIA,
+static Http::HdrType GeneralHeadersArr[] = {
+    Http::HdrType::CACHE_CONTROL,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::DATE,
+    Http::HdrType::FORWARDED,
+    Http::HdrType::X_FORWARDED_FOR,
+    Http::HdrType::MIME_VERSION,
+    Http::HdrType::PRAGMA,
+    Http::HdrType::PROXY_CONNECTION,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    /* Http::HdrType::TRAILER, */
+    Http::HdrType::VIA,
 };
 
 /* entity-headers */
-static http_hdr_type EntityHeadersArr[] = {
-    HDR_ALLOW,
-    HDR_CONTENT_BASE,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONTENT_LENGTH,
-    HDR_CONTENT_LOCATION,
-    HDR_CONTENT_MD5,
-    HDR_CONTENT_RANGE,
-    HDR_CONTENT_TYPE,
-    HDR_ETAG,
-    HDR_EXPIRES,
-    HDR_LAST_MODIFIED,
-    HDR_LINK,
-    HDR_OTHER
+static Http::HdrType EntityHeadersArr[] = {
+    Http::HdrType::ALLOW,
+    Http::HdrType::CONTENT_BASE,
+    Http::HdrType::CONTENT_ENCODING,
+    Http::HdrType::CONTENT_LANGUAGE,
+    Http::HdrType::CONTENT_LENGTH,
+    Http::HdrType::CONTENT_LOCATION,
+    Http::HdrType::CONTENT_MD5,
+    Http::HdrType::CONTENT_RANGE,
+    Http::HdrType::CONTENT_TYPE,
+    Http::HdrType::ETAG,
+    Http::HdrType::EXPIRES,
+    Http::HdrType::LAST_MODIFIED,
+    Http::HdrType::LINK,
+    Http::HdrType::OTHER
 };
 
 /* request-only headers */
 static HttpHeaderMask RequestHeadersMask;   /* set run-time using RequestHeaders */
-static http_hdr_type RequestHeadersArr[] = {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET,
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_LANGUAGE,
-    HDR_AUTHORIZATION,
-    HDR_EXPECT,
-    HDR_FROM,
-    HDR_HOST,
-    HDR_HTTP2_SETTINGS,
-    HDR_IF_MATCH,
-    HDR_IF_MODIFIED_SINCE,
-    HDR_IF_NONE_MATCH,
-    HDR_IF_RANGE,
-    HDR_IF_UNMODIFIED_SINCE,
-    HDR_MAX_FORWARDS,
-    HDR_ORIGIN,
-    HDR_PROXY_AUTHORIZATION,
-    HDR_RANGE,
-    HDR_REFERER,
-    HDR_REQUEST_RANGE,
-    HDR_TE,
-    HDR_USER_AGENT,
-    HDR_SURROGATE_CAPABILITY
+static Http::HdrType RequestHeadersArr[] = {
+    Http::HdrType::ACCEPT,
+    Http::HdrType::ACCEPT_CHARSET,
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_LANGUAGE,
+    Http::HdrType::AUTHORIZATION,
+    Http::HdrType::EXPECT,
+    Http::HdrType::FROM,
+    Http::HdrType::HOST,
+    Http::HdrType::HTTP2_SETTINGS,
+    Http::HdrType::IF_MATCH,
+    Http::HdrType::IF_MODIFIED_SINCE,
+    Http::HdrType::IF_NONE_MATCH,
+    Http::HdrType::IF_RANGE,
+    Http::HdrType::IF_UNMODIFIED_SINCE,
+    Http::HdrType::MAX_FORWARDS,
+    Http::HdrType::ORIGIN,
+    Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::RANGE,
+    Http::HdrType::REFERER,
+    Http::HdrType::REQUEST_RANGE,
+    Http::HdrType::TE,
+    Http::HdrType::USER_AGENT,
+    Http::HdrType::SURROGATE_CAPABILITY
 };
 
 /* reply-only headers */
 static HttpHeaderMask ReplyHeadersMask;     /* set run-time using ReplyHeaders */
-static http_hdr_type ReplyHeadersArr[] = {
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_RANGES,
-    HDR_AGE,
-    HDR_KEY,
-    HDR_LOCATION,
-    HDR_PROXY_AUTHENTICATE,
-    HDR_PUBLIC,
-    HDR_RETRY_AFTER,
-    HDR_SERVER,
-    HDR_SET_COOKIE,
-    HDR_SET_COOKIE2,
-    HDR_VARY,
-    HDR_WARNING,
-    HDR_WWW_AUTHENTICATE,
-    HDR_X_CACHE,
-    HDR_X_CACHE_LOOKUP,
-    HDR_X_REQUEST_URI,
+static Http::HdrType ReplyHeadersArr[] = {
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_RANGES,
+    Http::HdrType::AGE,
+    Http::HdrType::KEY,
+    Http::HdrType::LOCATION,
+    Http::HdrType::PROXY_AUTHENTICATE,
+    Http::HdrType::PUBLIC,
+    Http::HdrType::RETRY_AFTER,
+    Http::HdrType::SERVER,
+    Http::HdrType::SET_COOKIE,
+    Http::HdrType::SET_COOKIE2,
+    Http::HdrType::VARY,
+    Http::HdrType::WARNING,
+    Http::HdrType::WWW_AUTHENTICATE,
+    Http::HdrType::X_CACHE,
+    Http::HdrType::X_CACHE_LOOKUP,
+    Http::HdrType::X_REQUEST_URI,
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+    Http::HdrType::HDR_X_ACCELERATOR_VARY,
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,
+    Http::HdrType::X_NEXT_SERVICES,
 #endif
-    HDR_X_SQUID_ERROR,
-    HDR_SURROGATE_CONTROL
+    Http::HdrType::X_SQUID_ERROR,
+    Http::HdrType::SURROGATE_CONTROL
 };
 
 /* hop-by-hop headers */
 static HttpHeaderMask HopByHopHeadersMask;
-static http_hdr_type HopByHopHeadersArr[] = {
-    HDR_ALTERNATE_PROTOCOL,
-    HDR_CONNECTION,
-    HDR_HTTP2_SETTINGS,
-    HDR_KEEP_ALIVE,
-    /*HDR_PROXY_AUTHENTICATE, // removal handled specially for peer login */
-    HDR_PROXY_AUTHORIZATION,
-    HDR_TE,
-    HDR_TRAILER,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_PROXY_CONNECTION
+static Http::HdrType HopByHopHeadersArr[] = {
+    Http::HdrType::ALTERNATE_PROTOCOL,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::HTTP2_SETTINGS,
+    Http::HdrType::KEEP_ALIVE,
+    /*Http::HdrType::PROXY_AUTHENTICATE, // removal handled specially for peer login */
+    Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::TE,
+    Http::HdrType::TRAILER,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    Http::HdrType::PROXY_CONNECTION
 };
 
 /* header accounting */
@@ -242,19 +242,19 @@ class StoreEntry;
 
 static inline
 bool
-any_registered_header (const http_hdr_type id)
+any_registered_header (const Http::HdrType id)
 {
-    return (id == HDR_BAD_HDR || (id >= HDR_ACCEPT && id < HDR_ENUM_END));
+    return (id == Http::HdrType::BAD_HDR || (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END));
 }
 
 static inline
 bool
-any_valid_header (const http_hdr_type id)
+any_valid_header (const Http::HdrType id)
 {
-    return (id >= HDR_ACCEPT && id < HDR_ENUM_END);
+    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END);
 }
 
-static void httpHeaderNoteParsedEntry(http_hdr_type id, String const &value, int error);
+static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, int error);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
 /** store report about current header usage and other stats */
 static void httpHeaderStoreReport(StoreEntry * e);
@@ -275,7 +275,7 @@ void
 httpHeaderInitModule(void)
 {
     /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= HDR_ENUM_END);
+    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::ENUM_END);
 
     // check invariant: for each index in headerTable, (int)headerTable[index] = index
     for (int i = 0; headerTable[i].name; ++i)
@@ -387,7 +387,7 @@ HttpHeader::clean()
         HttpHeaderEntry *e = *i;
         if (e == NULL)
             continue;
-        if (e->id >= HDR_ENUM_END) {
+        if (e->id >= Http::HdrType::ENUM_END) {
             debugs(55, DBG_CRITICAL, "BUG: invalid entry (" << e->id << "). Ignored.");
         } else {
             if (owner <= hoReply)
@@ -434,20 +434,20 @@ HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
     assert(this != fresh);
 
     while ((e = fresh->getEntry(&pos))) {
-        /* deny bad guys (ok to check for HDR_OTHER) here */
+        /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        if (e->id != HDR_OTHER)
+        if (e->id != Http::HdrType::OTHER)
             delById(e->id);
         else
             delByName(e->name.termedBuf());
     }
 
     pos = HttpHeaderInitPos;
     while ((e = fresh->getEntry(&pos))) {
-        /* deny bad guys (ok to check for HDR_OTHER) here */
+        /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
@@ -576,7 +576,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
             return reset();
         }
 
-        if (e->id == HDR_CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
+        if (e->id == Http::HdrType::CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
             if (e->value != e2->value) {
                 int64_t l1, l2;
                 debugs(55, warnOnError, "WARNING: found two conflicting content-length headers in {" <<
@@ -613,7 +613,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
             }
         }
 
-        if (e->id == HDR_OTHER && stringHasWhitespace(e->name.termedBuf())) {
+        if (e->id == Http::HdrType::OTHER && stringHasWhitespace(e->name.termedBuf())) {
             debugs(55, warnOnError, "WARNING: found whitespace in HTTP header name {" <<
                    getStringPrefix(field_start, field_end-field_start) << "}");
 
@@ -629,7 +629,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
 
     if (chunked()) {
         // RFC 2616 section 4.4: ignore Content-Length with Transfer-Encoding
-        delById(HDR_CONTENT_LENGTH);
+        delById(Http::HdrType::CONTENT_LENGTH);
     }
 
     PROF_stop(HttpHeaderParse);
@@ -654,13 +654,13 @@ HttpHeader::packInto(Packable * p, bool mask_sensitive_info) const
 
         bool maskThisEntry = false;
         switch (e->id) {
-        case HDR_AUTHORIZATION:
-        case HDR_PROXY_AUTHORIZATION:
+        case Http::HdrType::AUTHORIZATION:
+        case Http::HdrType::PROXY_AUTHORIZATION:
             maskThisEntry = true;
             break;
 
-        case HDR_FTP_ARGUMENTS:
-            if (const HttpHeaderEntry *cmd = findEntry(HDR_FTP_COMMAND))
+        case Http::HdrType::FTP_ARGUMENTS:
+            if (const HttpHeaderEntry *cmd = findEntry(Http::HdrType::FTP_COMMAND))
                 maskThisEntry = (cmd->value == "PASS");
             break;
 
@@ -701,7 +701,7 @@ HttpHeader::getEntry(HttpHeaderPos * pos) const
  * "list" headers
  */
 HttpHeaderEntry *
-HttpHeader::findEntry(http_hdr_type id) const
+HttpHeader::findEntry(Http::HdrType id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
@@ -729,7 +729,7 @@ HttpHeader::findEntry(http_hdr_type id) const
  * same as httpHeaderFindEntry
  */
 HttpHeaderEntry *
-HttpHeader::findLastEntry(http_hdr_type id) const
+HttpHeader::findLastEntry(Http::HdrType id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
@@ -776,14 +776,14 @@ HttpHeader::delByName(const char *name)
 
 /* deletes all entries with a given id, returns the #entries deleted */
 int
-HttpHeader::delById(http_hdr_type id)
+HttpHeader::delById(Http::HdrType id)
 {
     int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
     debugs(55, 8, this << " del-by-id " << id);
     assert(any_valid_header(id));
-    assert(id != HDR_OTHER);        /* does not make sense */
+    assert(id != Http::HdrType::OTHER);        /* does not make sense */
 
     if (!CBIT_TEST(mask, id))
         return 0;
@@ -856,7 +856,7 @@ HttpHeader::addEntry(HttpHeaderEntry * e)
 
     debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
-    if (e->id != HDR_BAD_HDR) {
+    if (e->id != Http::HdrType::BAD_HDR) {
         if (CBIT_TEST(mask, e->id)) {
             ++ headerStatsTable[e->id].repCount;
         } else {
@@ -881,7 +881,7 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
 
     debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
-    // HDR_BAD_HDR is filtered out by assert_any_valid_header
+    // Http::HdrType::BAD_HDR is filtered out by assert_any_valid_header
     if (CBIT_TEST(mask, e->id)) {
         ++ headerStatsTable[e->id].repCount;
     } else {
@@ -895,7 +895,7 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
 }
 
 bool
-HttpHeader::getList(http_hdr_type id, String *s) const
+HttpHeader::getList(Http::HdrType id, String *s) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -927,7 +927,7 @@ HttpHeader::getList(http_hdr_type id, String *s) const
 
 /* return a list of entries with the same id separated by ',' and ws */
 String
-HttpHeader::getList(http_hdr_type id) const
+HttpHeader::getList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -961,7 +961,7 @@ HttpHeader::getList(http_hdr_type id) const
 
 /* return a string or list of entries with the same id separated by ',' and ws */
 String
-HttpHeader::getStrOrList(http_hdr_type id) const
+HttpHeader::getStrOrList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
 
@@ -989,7 +989,7 @@ HttpHeader::getByName(const char *name) const
 bool
 HttpHeader::getByNameIfPresent(const char *name, String &result) const
 {
-    http_hdr_type id;
+    Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
 
@@ -998,7 +998,7 @@ HttpHeader::getByNameIfPresent(const char *name, String &result) const
     /* First try the quick path */
     id = HeaderLookupTable.lookup(SBuf(name));
 
-    if (id != HDR_BAD_HDR) {
+    if (id != Http::HdrType::BAD_HDR) {
         if (!has(id))
             return false;
         result = getStrOrList(id);
@@ -1008,7 +1008,7 @@ HttpHeader::getByNameIfPresent(const char *name, String &result) const
     /* Sorry, an unknown header name. Do linear search */
     bool found = false;
     while ((e = getEntry(&pos))) {
-        if (e->id == HDR_OTHER && e->name.caseCmp(name) == 0) {
+        if (e->id == Http::HdrType::OTHER && e->name.caseCmp(name) == 0) {
             found = true;
             strListAdd(&result, e->value.termedBuf(), ',');
         }
@@ -1049,7 +1049,7 @@ HttpHeader::getByNameListMember(const char *name, const char *member, const char
  * returns a the value of the specified list member, if any.
  */
 String
-HttpHeader::getListMember(http_hdr_type id, const char *member, const char separator) const
+HttpHeader::getListMember(Http::HdrType id, const char *member, const char separator) const
 {
     String header;
     const char *pos = NULL;
@@ -1075,16 +1075,16 @@ HttpHeader::getListMember(http_hdr_type id, const char *member, const char separ
 
 /* test if a field is present */
 int
-HttpHeader::has(http_hdr_type id) const
+HttpHeader::has(Http::HdrType id) const
 {
     assert(any_valid_header(id));
-    assert(id != HDR_OTHER);
+    assert(id != Http::HdrType::OTHER);
     debugs(55, 9, this << " lookup for " << id);
     return CBIT_TEST(mask, id);
 }
 
 void
-HttpHeader::putInt(http_hdr_type id, int number)
+HttpHeader::putInt(Http::HdrType id, int number)
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftInt);  /* must be of an appropriate type */
@@ -1093,7 +1093,7 @@ HttpHeader::putInt(http_hdr_type id, int number)
 }
 
 void
-HttpHeader::putInt64(http_hdr_type id, int64_t number)
+HttpHeader::putInt64(Http::HdrType id, int64_t number)
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftInt64);    /* must be of an appropriate type */
@@ -1102,7 +1102,7 @@ HttpHeader::putInt64(http_hdr_type id, int64_t number)
 }
 
 void
-HttpHeader::putTime(http_hdr_type id, time_t htime)
+HttpHeader::putTime(Http::HdrType id, time_t htime)
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftDate_1123);    /* must be of an appropriate type */
@@ -1111,7 +1111,7 @@ HttpHeader::putTime(http_hdr_type id, time_t htime)
 }
 
 void
-HttpHeader::insertTime(http_hdr_type id, time_t htime)
+HttpHeader::insertTime(Http::HdrType id, time_t htime)
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftDate_1123);    /* must be of an appropriate type */
@@ -1120,7 +1120,7 @@ HttpHeader::insertTime(http_hdr_type id, time_t htime)
 }
 
 void
-HttpHeader::putStr(http_hdr_type id, const char *str)
+HttpHeader::putStr(Http::HdrType id, const char *str)
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftStr);  /* must be of an appropriate type */
@@ -1132,21 +1132,21 @@ void
 HttpHeader::putAuth(const char *auth_scheme, const char *realm)
 {
     assert(auth_scheme && realm);
-    httpHeaderPutStrf(this, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
+    httpHeaderPutStrf(this, Http::HdrType::WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
 }
 
 void
 HttpHeader::putCc(const HttpHdrCc * cc)
 {
     assert(cc);
     /* remove old directives if any */
-    delById(HDR_CACHE_CONTROL);
+    delById(Http::HdrType::CACHE_CONTROL);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     cc->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_CACHE_CONTROL, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::CACHE_CONTROL, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1156,13 +1156,13 @@ HttpHeader::putContRange(const HttpHdrContRange * cr)
 {
     assert(cr);
     /* remove old directives if any */
-    delById(HDR_CONTENT_RANGE);
+    delById(Http::HdrType::CONTENT_RANGE);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     httpHdrContRangePackInto(cr, &mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_CONTENT_RANGE, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::CONTENT_RANGE, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1172,13 +1172,13 @@ HttpHeader::putRange(const HttpHdrRange * range)
 {
     assert(range);
     /* remove old directives if any */
-    delById(HDR_RANGE);
+    delById(Http::HdrType::RANGE);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     range->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_RANGE, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::RANGE, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1188,13 +1188,13 @@ HttpHeader::putSc(HttpHdrSc *sc)
 {
     assert(sc);
     /* remove old directives if any */
-    delById(HDR_SURROGATE_CONTROL);
+    delById(Http::HdrType::SURROGATE_CONTROL);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     sc->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_SURROGATE_CONTROL, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::SURROGATE_CONTROL, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1204,7 +1204,7 @@ HttpHeader::putWarning(const int code, const char *const text)
 {
     char buf[512];
     snprintf(buf, sizeof(buf), "%i %s \"%s\"", code, visible_appname_string, text);
-    putStr(HDR_WARNING, buf);
+    putStr(Http::HdrType::WARNING, buf);
 }
 
 /* add extension header (these fields are not parsed/analyzed/joined, etc.) */
@@ -1213,11 +1213,11 @@ HttpHeader::putExt(const char *name, const char *value)
 {
     assert(name && value);
     debugs(55, 8, this << " adds ext entry " << name << " : " << value);
-    addEntry(new HttpHeaderEntry(HDR_OTHER, name, value));
+    addEntry(new HttpHeaderEntry(Http::HdrType::OTHER, name, value));
 }
 
 int
-HttpHeader::getInt(http_hdr_type id) const
+HttpHeader::getInt(Http::HdrType id) const
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftInt);  /* must be of an appropriate type */
@@ -1230,7 +1230,7 @@ HttpHeader::getInt(http_hdr_type id) const
 }
 
 int64_t
-HttpHeader::getInt64(http_hdr_type id) const
+HttpHeader::getInt64(Http::HdrType id) const
 {
     assert(any_valid_header(id));
     assert(headerTable[id].type == field_type::ftInt64);    /* must be of an appropriate type */
@@ -1243,7 +1243,7 @@ HttpHeader::getInt64(http_hdr_type id) const
 }
 
 time_t
-HttpHeader::getTime(http_hdr_type id) const
+HttpHeader::getTime(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     time_t value = -1;
@@ -1260,7 +1260,7 @@ HttpHeader::getTime(http_hdr_type id) const
 
 /* sync with httpHeaderGetLastStr */
 const char *
-HttpHeader::getStr(http_hdr_type id) const
+HttpHeader::getStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     assert(any_valid_header(id));
@@ -1276,7 +1276,7 @@ HttpHeader::getStr(http_hdr_type id) const
 
 /* unusual */
 const char *
-HttpHeader::getLastStr(http_hdr_type id) const
+HttpHeader::getLastStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     assert(any_valid_header(id));
@@ -1293,12 +1293,12 @@ HttpHeader::getLastStr(http_hdr_type id) const
 HttpHdrCc *
 HttpHeader::getCc() const
 {
-    if (!CBIT_TEST(mask, HDR_CACHE_CONTROL))
+    if (!CBIT_TEST(mask, Http::HdrType::CACHE_CONTROL))
         return NULL;
     PROF_start(HttpHeader_getCc);
 
     String s;
-    getList(HDR_CACHE_CONTROL, &s);
+    getList(Http::HdrType::CACHE_CONTROL, &s);
 
     HttpHdrCc *cc=new HttpHdrCc();
 
@@ -1312,7 +1312,7 @@ HttpHeader::getCc() const
     if (cc)
         httpHdrCcUpdateStats(cc, &HttpHeaderStats[owner].ccTypeDistr);
 
-    httpHeaderNoteParsedEntry(HDR_CACHE_CONTROL, s, !cc);
+    httpHeaderNoteParsedEntry(Http::HdrType::CACHE_CONTROL, s, !cc);
 
     PROF_stop(HttpHeader_getCc);
 
@@ -1329,8 +1329,8 @@ HttpHeader::getRange() const
      * this "if" should work correctly in both cases;
      * hopefully no clients send mismatched headers! */
 
-    if ((e = findEntry(HDR_RANGE)) ||
-            (e = findEntry(HDR_REQUEST_RANGE))) {
+    if ((e = findEntry(Http::HdrType::RANGE)) ||
+            (e = findEntry(Http::HdrType::REQUEST_RANGE))) {
         r = HttpHdrRange::ParseCreate(&e->value);
         httpHeaderNoteParsedEntry(e->id, e->value, !r);
     }
@@ -1341,12 +1341,12 @@ HttpHeader::getRange() const
 HttpHdrSc *
 HttpHeader::getSc() const
 {
-    if (!CBIT_TEST(mask, HDR_SURROGATE_CONTROL))
+    if (!CBIT_TEST(mask, Http::HdrType::SURROGATE_CONTROL))
         return NULL;
 
     String s;
 
-    (void) getList(HDR_SURROGATE_CONTROL, &s);
+    (void) getList(Http::HdrType::SURROGATE_CONTROL, &s);
 
     HttpHdrSc *sc = httpHdrScParseCreate(s);
 
@@ -1355,7 +1355,7 @@ HttpHeader::getSc() const
     if (sc)
         sc->updateStats(&HttpHeaderStats[owner].scTypeDistr);
 
-    httpHeaderNoteParsedEntry(HDR_SURROGATE_CONTROL, s, !sc);
+    httpHeaderNoteParsedEntry(Http::HdrType::SURROGATE_CONTROL, s, !sc);
 
     return sc;
 }
@@ -1366,7 +1366,7 @@ HttpHeader::getContRange() const
     HttpHdrContRange *cr = NULL;
     HttpHeaderEntry *e;
 
-    if ((e = findEntry(HDR_CONTENT_RANGE))) {
+    if ((e = findEntry(Http::HdrType::CONTENT_RANGE))) {
         cr = httpHdrContRangeParseCreate(e->value.termedBuf());
         httpHeaderNoteParsedEntry(e->id, e->value, !cr);
     }
@@ -1375,7 +1375,7 @@ HttpHeader::getContRange() const
 }
 
 const char *
-HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
+HttpHeader::getAuth(Http::HdrType id, const char *auth_scheme) const
 {
     const char *field;
     int l;
@@ -1414,7 +1414,7 @@ HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
 }
 
 ETag
-HttpHeader::getETag(http_hdr_type id) const
+HttpHeader::getETag(Http::HdrType id) const
 {
     ETag etag = {NULL, -1};
     HttpHeaderEntry *e;
@@ -1427,7 +1427,7 @@ HttpHeader::getETag(http_hdr_type id) const
 }
 
 TimeOrTag
-HttpHeader::getTimeOrTag(http_hdr_type id) const
+HttpHeader::getTimeOrTag(Http::HdrType id) const
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
@@ -1457,19 +1457,19 @@ HttpHeader::getTimeOrTag(http_hdr_type id) const
  * HttpHeaderEntry
  */
 
-HttpHeaderEntry::HttpHeaderEntry(http_hdr_type anId, const char *aName, const char *aValue)
+HttpHeaderEntry::HttpHeaderEntry(Http::HdrType anId, const char *aName, const char *aValue)
 {
     assert(any_registered_header(anId));
     id = anId;
 
-    if (id != HDR_OTHER)
+    if (id != Http::HdrType::OTHER)
         name = headerTable[id].name;
     else
         name = aName;
 
     value = aValue;
 
-    if (anId != HDR_BAD_HDR)
+    if (anId != Http::HdrType::BAD_HDR)
         ++ headerStatsTable[id].aliveCount;
 
     debugs(55, 9, "created HttpHeaderEntry " << this << ": '" << name << " : " << value );
@@ -1480,11 +1480,11 @@ HttpHeaderEntry::~HttpHeaderEntry()
     assert(any_valid_header(id));
     debugs(55, 9, "destroying entry " << this << ": '" << name << ": " << value << "'");
 
-    // HDR_BAD_HDR is filtered out by assert_any_valid_header
+    // Http::HdrType::BAD_HDR is filtered out by assert_any_valid_header
     assert(headerStatsTable[id].aliveCount); // is this really needed?
     -- headerStatsTable[id].aliveCount;
 
-    id = HDR_BAD_HDR;
+    id = Http::HdrType::BAD_HDR;
 }
 
 /* parses and inits header entry, returns true/false */
@@ -1526,20 +1526,20 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     debugs(55, 9, "parsing HttpHeaderEntry: near '" <<  getStringPrefix(field_start, field_end-field_start) << "'");
 
     /* is it a "known" field? */
-    http_hdr_type id = HeaderLookupTable.lookup(SBuf(field_start,name_len));
+    Http::HdrType id = HeaderLookupTable.lookup(SBuf(field_start,name_len));
     debugs(55, 9, "got hdr id hdr: " << id);
 
     String name;
 
     String value;
 
-    if (id == HDR_BAD_HDR)
-        id = HDR_OTHER;
+    if (id == Http::HdrType::BAD_HDR)
+        id = Http::HdrType::OTHER;
 
     assert(any_valid_header(id));
 
     /* set field name */
-    if (id == HDR_OTHER)
+    if (id == Http::HdrType::OTHER)
         name.limitInit(field_start, name_len);
     else
         name = headerTable[id].name;
@@ -1555,7 +1555,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
         /* String must be LESS THAN 64K and it adds a terminating NULL */
         debugs(55, DBG_IMPORTANT, "WARNING: ignoring '" << name << "' header of " << (field_end - value_start) << " bytes");
 
-        if (id == HDR_OTHER)
+        if (id == Http::HdrType::OTHER)
             name.clean();
 
         return NULL;
@@ -1564,7 +1564,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     /* set field value */
     value.limitInit(value_start, field_end - value_start);
 
-    if (id != HDR_BAD_HDR)
+    if (id != Http::HdrType::BAD_HDR)
         ++ headerStatsTable[id].seenCount;
 
     debugs(55, 9, "parsed HttpHeaderEntry: '" << name << ": " << value << "'");
@@ -1615,13 +1615,13 @@ HttpHeaderEntry::getInt64() const
 }
 
 static void
-httpHeaderNoteParsedEntry(http_hdr_type id, String const &context, int error)
+httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, int error)
 {
-    if (id != HDR_BAD_HDR)
+    if (id != Http::HdrType::BAD_HDR)
         ++ headerStatsTable[id].parsCount;
 
     if (error) {
-        if (id != HDR_BAD_HDR)
+        if (id != Http::HdrType::BAD_HDR)
             ++ headerStatsTable[id].errCount;
         debugs(55, 2, "cannot parse hdr field: '" << headerTable[id].name << ": " << context << "'");
     }
@@ -1639,7 +1639,7 @@ void
 httpHeaderFieldStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     const int id = (int) val;
-    const int valid_id = id < HDR_ENUM_END;
+    const int valid_id = id < Http::HdrType::ENUM_END;
     const char *name = valid_id ? headerTable[id].name : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
@@ -1731,7 +1731,7 @@ httpHeaderStoreReport(StoreEntry * e)
 }
 
 int
-HttpHeader::hasListMember(http_hdr_type id, const char *member, const char separator) const
+HttpHeader::hasListMember(Http::HdrType id, const char *member, const char separator) const
 {
     int result = 0;
     const char *pos = NULL;
@@ -1787,7 +1787,7 @@ HttpHeader::removeHopByHopEntries()
     HttpHeaderPos pos = HttpHeaderInitPos;
     int headers_deleted = 0;
     while ((e = getEntry(&pos))) {
-        int id = e->id;
+        Http::HdrType id = e->id;
         if (CBIT_TEST(HopByHopHeadersMask, id)) {
             delAt(pos, headers_deleted);
             CBIT_CLR(mask, id);
@@ -1798,11 +1798,11 @@ HttpHeader::removeHopByHopEntries()
 void
 HttpHeader::removeConnectionHeaderEntries()
 {
-    if (has(HDR_CONNECTION)) {
+    if (has(Http::HdrType::CONNECTION)) {
         /* anything that matches Connection list member will be deleted */
         String strConnection;
 
-        (void) getList(HDR_CONNECTION, &strConnection);
+        (void) getList(Http::HdrType::CONNECTION, &strConnection);
         const HttpHeaderEntry *e;
         HttpHeaderPos pos = HttpHeaderInitPos;
         /*
@@ -51,15 +51,15 @@ class HttpHeaderEntry
     MEMPROXY_CLASS(HttpHeaderEntry);
 
 public:
-    HttpHeaderEntry(http_hdr_type id, const char *name, const char *value);
+    HttpHeaderEntry(Http::HdrType id, const char *name, const char *value);
     ~HttpHeaderEntry();
     static HttpHeaderEntry *parse(const char *field_start, const char *field_end);
     HttpHeaderEntry *clone() const;
     void packInto(Packable *p) const;
     int getInt() const;
     int64_t getInt64() const;
 
-    http_hdr_type id;
+    Http::HdrType id;
     String name;
     String value;
 };
@@ -87,47 +87,47 @@ class HttpHeader
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
-    HttpHeaderEntry *findEntry(http_hdr_type id) const;
+    HttpHeaderEntry *findEntry(Http::HdrType id) const;
     int delByName(const char *name);
-    int delById(http_hdr_type id);
+    int delById(Http::HdrType id);
     void delAt(HttpHeaderPos pos, int &headers_deleted);
     void refreshMask();
     void addEntry(HttpHeaderEntry * e);
     void insertEntry(HttpHeaderEntry * e);
-    String getList(http_hdr_type id) const;
-    bool getList(http_hdr_type id, String *s) const;
-    String getStrOrList(http_hdr_type id) const;
+    String getList(Http::HdrType id) const;
+    bool getList(Http::HdrType id, String *s) const;
+    String getStrOrList(Http::HdrType id) const;
     String getByName(const char *name) const;
     /// sets value and returns true iff a [possibly empty] named field is there
     bool getByNameIfPresent(const char *name, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
-    String getListMember(http_hdr_type id, const char *member, const char separator) const;
-    int has(http_hdr_type id) const;
-    void putInt(http_hdr_type id, int number);
-    void putInt64(http_hdr_type id, int64_t number);
-    void putTime(http_hdr_type id, time_t htime);
-    void insertTime(http_hdr_type id, time_t htime);
-    void putStr(http_hdr_type id, const char *str);
+    String getListMember(Http::HdrType id, const char *member, const char separator) const;
+    int has(Http::HdrType id) const;
+    void putInt(Http::HdrType id, int number);
+    void putInt64(Http::HdrType id, int64_t number);
+    void putTime(Http::HdrType id, time_t htime);
+    void insertTime(Http::HdrType id, time_t htime);
+    void putStr(Http::HdrType id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
     void putContRange(const HttpHdrContRange * cr);
     void putRange(const HttpHdrRange * range);
     void putSc(HttpHdrSc *sc);
     void putWarning(const int code, const char *const text); ///< add a Warning header
     void putExt(const char *name, const char *value);
-    int getInt(http_hdr_type id) const;
-    int64_t getInt64(http_hdr_type id) const;
-    time_t getTime(http_hdr_type id) const;
-    const char *getStr(http_hdr_type id) const;
-    const char *getLastStr(http_hdr_type id) const;
+    int getInt(Http::HdrType id) const;
+    int64_t getInt64(Http::HdrType id) const;
+    time_t getTime(Http::HdrType id) const;
+    const char *getStr(Http::HdrType id) const;
+    const char *getLastStr(Http::HdrType id) const;
     HttpHdrCc *getCc() const;
     HttpHdrRange *getRange() const;
     HttpHdrSc *getSc() const;
     HttpHdrContRange *getContRange() const;
-    const char *getAuth(http_hdr_type id, const char *auth_scheme) const;
-    ETag getETag(http_hdr_type id) const;
-    TimeOrTag getTimeOrTag(http_hdr_type id) const;
-    int hasListMember(http_hdr_type id, const char *member, const char separator) const;
+    const char *getAuth(Http::HdrType id, const char *auth_scheme) const;
+    ETag getETag(Http::HdrType id) const;
+    TimeOrTag getTimeOrTag(Http::HdrType id) const;
+    int hasListMember(Http::HdrType id, const char *member, const char separator) const;
     int hasByNameListMember(const char *name, const char *member, const char separator) const;
     void removeHopByHopEntries();
     inline bool chunked() const; ///< whether message uses chunked Transfer-Encoding
@@ -143,7 +143,7 @@ class HttpHeader
     void removeConnectionHeaderEntries();
 
 private:
-    HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
+    HttpHeaderEntry *findLastEntry(Http::HdrType id) const;
 };
 
 int httpHeaderParseQuotedString(const char *start, const int len, String *val);
@@ -153,13 +153,13 @@ SBuf httpHeaderQuoteString(const char *raw);
 
 int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
 void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
-void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
+void httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
 {
-    return has(HDR_TRANSFER_ENCODING) &&
-           hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
+    return has(Http::HdrType::TRANSFER_ENCODING) &&
+           hasListMember(Http::HdrType::TRANSFER_ENCODING, "chunked", ',');
 }
 
 void httpHeaderInitModule(void);
@@ -17,9 +17,9 @@
 class HttpHeaderFieldInfo
 {
 public:
-    HttpHeaderFieldInfo() : id(HDR_ACCEPT), type(field_type::ftInvalid) {}
+    HttpHeaderFieldInfo() : id(Http::HdrType::ACCEPT), type(field_type::ftInvalid) {}
 
-    http_hdr_type id;
+    Http::HdrType id;
     String name;
     field_type type;
     HttpHeaderFieldStat stat;
@@ -27,7 +27,7 @@ class HttpHeaderStat
         busyDestroyedCount(0)
     {
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(HDR_ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
         ccTypeDistr.enumInit(CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -43,7 +43,7 @@ class HttpHeaderStat
     {
         assert(label);
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(HDR_ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
         ccTypeDistr.enumInit(CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -37,7 +37,7 @@
 #include <cerrno>
 #include <string>
 
-static void httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs);
+static void httpHeaderPutStrvf(HttpHeader * hdr, Http::HdrType id, const char *fmt, va_list vargs);
 
 void
 httpHeaderMaskInit(HttpHeaderMask * mask, int value)
@@ -47,7 +47,7 @@ httpHeaderMaskInit(HttpHeaderMask * mask, int value)
 
 /** calculates a bit mask of a given array; does not reset mask! */
 void
-httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count)
+httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count)
 {
     size_t i;
     const int * enums = (const int *) http_hdr_type_enums;
@@ -62,7 +62,7 @@ httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], s
 
 /* same as httpHeaderPutStr, but formats the string using snprintf first */
 void
-httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...)
+httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
@@ -73,7 +73,7 @@ httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...)
 
 /* used by httpHeaderPutStrf */
 static void
-httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs)
+httpHeaderPutStrvf(HttpHeader * hdr, Http::HdrType id, const char *fmt, va_list vargs)
 {
     MemBuf mb;
     mb.init();
@@ -95,8 +95,8 @@ httpHeaderAddContRange(HttpHeader * hdr, HttpHdrRangeSpec spec, int64_t ent_len)
 
 /**
  * return true if a given directive is found in at least one of
- * the "connection" header-fields note: if HDR_PROXY_CONNECTION is
- * present we ignore HDR_CONNECTION.
+ * the "connection" header-fields note: if Http::HdrType::PROXY_CONNECTION is
+ * present we ignore Http::HdrType::CONNECTION.
  */
 int
 httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
@@ -106,12 +106,12 @@ httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
     /* what type of header do we have? */
 
 #if USE_HTTP_VIOLATIONS
-    if (hdr->has(HDR_PROXY_CONNECTION))
-        list = hdr->getList(HDR_PROXY_CONNECTION);
+    if (hdr->has(Http::HdrType::PROXY_CONNECTION))
+        list = hdr->getList(Http::HdrType::PROXY_CONNECTION);
     else
 #endif
-        if (hdr->has(HDR_CONNECTION))
-            list = hdr->getList(HDR_CONNECTION);
+        if (hdr->has(Http::HdrType::CONNECTION))
+            list = hdr->getList(Http::HdrType::CONNECTION);
         else
             return 0;
 
@@ -374,7 +374,7 @@ HeaderManglers::HeaderManglers()
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i)
+    for (int i = 0; i < Http::HdrType::ENUM_END; ++i)
         header_mangler_clean(known[i]);
 
     typedef ManglersByName::iterator MBNI;
@@ -417,22 +417,22 @@ HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 headerMangler *
 HeaderManglers::track(const char *name)
 {
-    int id = HeaderLookupTable.lookup(SBuf(name));
+    Http::HdrType id = HeaderLookupTable.lookup(SBuf(name));
 
-    if (id == HDR_BAD_HDR) { // special keyword or a custom header
+    if (id == Http::HdrType::BAD_HDR) { // special keyword or a custom header
         if (strcmp(name, "All") == 0)
-            id = HDR_ENUM_END;
+            id = Http::HdrType::ENUM_END;
         else if (strcmp(name, "Other") == 0)
-            id = HDR_OTHER;
+            id = Http::HdrType::OTHER;
     }
 
     headerMangler *m = NULL;
-    if (id == HDR_ENUM_END) {
+    if (id == Http::HdrType::ENUM_END) {
         m = &all;
-    } else if (id == HDR_BAD_HDR) {
+    } else if (id == Http::HdrType::BAD_HDR) {
         m = &custom[name];
     } else {
-        m = &known[id]; // including HDR_OTHER
+        m = &known[id]; // including Http::HdrType::OTHER
     }
 
     assert(m);
@@ -454,12 +454,12 @@ const headerMangler *
 HeaderManglers::find(const HttpHeaderEntry &e) const
 {
     // a known header with a configured ACL list
-    if (e.id != HDR_OTHER && e.id < HDR_ENUM_END &&
+    if (e.id != Http::HdrType::OTHER && e.id < Http::HdrType::ENUM_END &&
             known[e.id].access_list)
         return &known[e.id];
 
     // a custom header
-    if (e.id == HDR_OTHER) {
+    if (e.id == Http::HdrType::OTHER) {
         // does it have an ACL list configured?
         // Optimize: use a name type that we do not need to convert to here
         const ManglersByName::const_iterator i = custom.find(e.name.termedBuf());
@@ -468,8 +468,8 @@ HeaderManglers::find(const HttpHeaderEntry &e) const
     }
 
     // Next-to-last resort: "Other" rules match any custom header
-    if (e.id == HDR_OTHER && known[HDR_OTHER].access_list)
-        return &known[HDR_OTHER];
+    if (e.id == Http::HdrType::OTHER && known[Http::HdrType::OTHER].access_list)
+        return &known[Http::HdrType::OTHER];
 
     // Last resort: "All" rules match any header
     if (all.access_list)
@@ -74,7 +74,7 @@ class HeaderManglers
     typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
-    headerMangler known[HDR_ENUM_END];
+    headerMangler known[static_cast<int>(Http::HdrType::ENUM_END)];
 
     /// one mangler for each custom header
     ManglersByName custom;
@@ -91,7 +91,7 @@ class HeaderManglers
 class HeaderWithAcl
 {
 public:
-    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(HDR_BAD_HDR), quoted(false) {}
+    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(Http::HdrType::BAD_HDR), quoted(false) {}
 
     /// HTTP header field name
     std::string fieldName;
@@ -106,7 +106,7 @@ class HeaderWithAcl
     Format::Format *valueFormat;
 
     /// internal ID for "known" headers or HDR_OTHER
-    http_hdr_type fieldId;
+    Http::HdrType fieldId;
 
     /// whether fieldValue may contain macros
     bool quoted;
@@ -116,7 +116,7 @@ int httpHeaderParseOffset(const char *start, int64_t * off);
 
 int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
 int httpHeaderParseInt(const char *start, int *val);
-void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
+void httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...) PRINTF_FORMAT_ARG3;
 
 const char *getStringPrefix(const char *str, size_t len);
 
@@ -292,8 +292,8 @@ HttpMsg::httpMsgParseError()
 void
 HttpMsg::setContentLength(int64_t clen)
 {
-    header.delById(HDR_CONTENT_LENGTH); // if any
-    header.putInt64(HDR_CONTENT_LENGTH, clen);
+    header.delById(Http::HdrType::CONTENT_LENGTH); // if any
+    header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     content_length = clen;
 }
 
@@ -321,7 +321,7 @@ void HttpMsg::packInto(Packable *p, bool full_uri) const
 
 void HttpMsg::hdrCacheInit()
 {
-    content_length = header.getInt64(HDR_CONTENT_LENGTH);
+    content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
     assert(NULL == cache_control);
     cache_control = header.getCc();
 }
@@ -40,13 +40,13 @@
  *     all entity-headers except Expires and Content-Location
  */
 static HttpHeaderMask Denied304HeadersMask;
-static http_hdr_type Denied304HeadersArr[] = {
+static Http::HdrType Denied304HeadersArr[] = {
     // hop-by-hop headers
-    HDR_CONNECTION, HDR_KEEP_ALIVE, HDR_PROXY_AUTHENTICATE, HDR_PROXY_AUTHORIZATION,
-    HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE,
+    Http::HdrType::CONNECTION, Http::HdrType::KEEP_ALIVE, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::TE, Http::HdrType::TRAILER, Http::HdrType::TRANSFER_ENCODING, Http::HdrType::UPGRADE,
     // entity headers
-    HDR_ALLOW, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE, HDR_CONTENT_LENGTH,
-    HDR_CONTENT_MD5, HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_LAST_MODIFIED
+    Http::HdrType::ALLOW, Http::HdrType::CONTENT_ENCODING, Http::HdrType::CONTENT_LANGUAGE, Http::HdrType::CONTENT_LENGTH,
+    Http::HdrType::CONTENT_MD5, Http::HdrType::CONTENT_RANGE, Http::HdrType::CONTENT_TYPE, Http::HdrType::LAST_MODIFIED
 };
 
 /* module initialization */
@@ -135,7 +135,7 @@ HttpReply::pack()
 HttpReply *
 HttpReply::make304() const
 {
-    static const http_hdr_type ImsEntries[] = {HDR_DATE, HDR_CONTENT_TYPE, HDR_EXPIRES, HDR_LAST_MODIFIED, /* eof */ HDR_OTHER};
+    static const Http::HdrType ImsEntries[] = {Http::HdrType::DATE, Http::HdrType::CONTENT_TYPE, Http::HdrType::EXPIRES, Http::HdrType::LAST_MODIFIED, /* eof */ Http::HdrType::OTHER};
 
     HttpReply *rv = new HttpReply;
     int t;
@@ -151,7 +151,7 @@ HttpReply::make304() const
     /* rv->keep_alive */
     rv->sline.set(Http::ProtocolVersion(), Http::scNotModified, NULL);
 
-    for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
+    for (t = 0; ImsEntries[t] != Http::HdrType::OTHER; ++t)
         if ((e = header.findEntry(ImsEntries[t])))
             rv->header.addEntry(e->clone());
 
@@ -178,24 +178,24 @@ HttpReply::setHeaders(Http::StatusCode status, const char *reason,
     HttpHeader *hdr;
     sline.set(Http::ProtocolVersion(), status, reason);
     hdr = &header;
-    hdr->putStr(HDR_SERVER, visible_appname_string);
-    hdr->putStr(HDR_MIME_VERSION, "1.0");
-    hdr->putTime(HDR_DATE, squid_curtime);
+    hdr->putStr(Http::HdrType::SERVER, visible_appname_string);
+    hdr->putStr(Http::HdrType::MIME_VERSION, "1.0");
+    hdr->putTime(Http::HdrType::DATE, squid_curtime);
 
     if (ctype) {
-        hdr->putStr(HDR_CONTENT_TYPE, ctype);
+        hdr->putStr(Http::HdrType::CONTENT_TYPE, ctype);
         content_type = ctype;
     } else
         content_type = String();
 
     if (clen >= 0)
-        hdr->putInt64(HDR_CONTENT_LENGTH, clen);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, clen);
 
     if (expiresTime >= 0)
-        hdr->putTime(HDR_EXPIRES, expiresTime);
+        hdr->putTime(Http::HdrType::EXPIRES, expiresTime);
 
     if (lmt > 0)        /* this used to be lmt != 0 @?@ */
-        hdr->putTime(HDR_LAST_MODIFIED, lmt);
+        hdr->putTime(Http::HdrType::LAST_MODIFIED, lmt);
 
     date = squid_curtime;
 
@@ -212,10 +212,10 @@ HttpReply::redirect(Http::StatusCode status, const char *loc)
     HttpHeader *hdr;
     sline.set(Http::ProtocolVersion(), status, NULL);
     hdr = &header;
-    hdr->putStr(HDR_SERVER, APP_FULLNAME);
-    hdr->putTime(HDR_DATE, squid_curtime);
-    hdr->putInt64(HDR_CONTENT_LENGTH, 0);
-    hdr->putStr(HDR_LOCATION, loc);
+    hdr->putStr(Http::HdrType::SERVER, APP_FULLNAME);
+    hdr->putTime(Http::HdrType::DATE, squid_curtime);
+    hdr->putInt64(Http::HdrType::CONTENT_LENGTH, 0);
+    hdr->putStr(Http::HdrType::LOCATION, loc);
     date = squid_curtime;
     content_length = 0;
 }
@@ -239,9 +239,9 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
         return 0;
 
     /* ETag */
-    one = header.getStrOrList(HDR_ETAG);
+    one = header.getStrOrList(Http::HdrType::ETAG);
 
-    two = otherRep->header.getStrOrList(HDR_ETAG);
+    two = otherRep->header.getStrOrList(Http::HdrType::ETAG);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
@@ -253,9 +253,9 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
         return 0;
 
     /* MD5 */
-    one = header.getStrOrList(HDR_CONTENT_MD5);
+    one = header.getStrOrList(Http::HdrType::CONTENT_MD5);
 
-    two = otherRep->header.getStrOrList(HDR_CONTENT_MD5);
+    two = otherRep->header.getStrOrList(Http::HdrType::CONTENT_MD5);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
@@ -311,16 +311,16 @@ HttpReply::hdrExpirationTime()
     }
 
     if (Config.onoff.vary_ignore_expire &&
-            header.has(HDR_VARY)) {
-        const time_t d = header.getTime(HDR_DATE);
-        const time_t e = header.getTime(HDR_EXPIRES);
+            header.has(Http::HdrType::VARY)) {
+        const time_t d = header.getTime(Http::HdrType::DATE);
+        const time_t e = header.getTime(Http::HdrType::EXPIRES);
 
         if (d == e)
             return -1;
     }
 
-    if (header.has(HDR_EXPIRES)) {
-        const time_t e = header.getTime(HDR_EXPIRES);
+    if (header.has(Http::HdrType::EXPIRES)) {
+        const time_t e = header.getTime(Http::HdrType::EXPIRES);
         /*
          * HTTP/1.0 says that robust implementations should consider
          * bad or malformed Expires header as equivalent to "expires
@@ -339,13 +339,13 @@ HttpReply::hdrCacheInit()
     HttpMsg::hdrCacheInit();
 
     http_ver = sline.version;
-    content_length = header.getInt64(HDR_CONTENT_LENGTH);
-    date = header.getTime(HDR_DATE);
-    last_modified = header.getTime(HDR_LAST_MODIFIED);
+    content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
+    date = header.getTime(Http::HdrType::DATE);
+    last_modified = header.getTime(Http::HdrType::LAST_MODIFIED);
     surrogate_control = header.getSc();
     content_range = header.getContRange();
     keep_alive = persistent() ? 1 : 0;
-    const char *str = header.getStr(HDR_CONTENT_TYPE);
+    const char *str = header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (str)
         content_type.limitInit(str, strcspn(str, ";\t "));
@@ -593,14 +593,14 @@ bool HttpReply::inheritProperties(const HttpMsg *aMsg)
 void HttpReply::removeStaleWarnings()
 {
     String warning;
-    if (header.getList(HDR_WARNING, &warning)) {
+    if (header.getList(Http::HdrType::WARNING, &warning)) {
         const String newWarning = removeStaleWarningValues(warning);
         if (warning.size() && warning.size() == newWarning.size())
             return; // some warnings are there and none changed
-        header.delById(HDR_WARNING);
+        header.delById(Http::HdrType::WARNING);
         if (newWarning.size()) { // some warnings left
             HttpHeaderEntry *const e =
-                new HttpHeaderEntry(HDR_WARNING, NULL, newWarning.termedBuf());
+                new HttpHeaderEntry(Http::HdrType::WARNING, NULL, newWarning.termedBuf());
             header.addEntry(e);
         }
     }
@@ -593,8 +593,8 @@ bool
 HttpRequest::conditional() const
 {
     return flags.ims ||
-           header.has(HDR_IF_MATCH) ||
-           header.has(HDR_IF_NONE_MATCH);
+           header.has(Http::HdrType::IF_MATCH) ||
+           header.has(Http::HdrType::IF_NONE_MATCH);
 }
 
 void
@@ -653,8 +653,8 @@ bool
 HttpRequest::canHandle1xx() const
 {
     // old clients do not support 1xx unless they sent Expect: 100-continue
-    // (we reject all other HDR_EXPECT values so just check for HDR_EXPECT)
-    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(HDR_EXPECT))
+    // (we reject all other Http::HdrType::EXPECT values so just check for Http::HdrType::EXPECT)
+    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(Http::HdrType::EXPECT))
         return false;
 
     // others must support 1xx control messages
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_USER_AGENT>;
+template class ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>;
 
@@ -25,7 +25,7 @@
  * TODO: This can be generalised by making the type of the regex_rule into a
  * template parameter - so that we can use different rules types in future.
  */
-ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(HDR_BAD_HDR), regex_rule(new ACLRegexData)
+ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(Http::HdrType::BAD_HDR), regex_rule(new ACLRegexData)
 {}
 
 ACLHTTPHeaderData::~ACLHTTPHeaderData()
@@ -42,7 +42,7 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
     debugs(28, 3, "aclHeaderData::match: checking '" << hdrName << "'");
 
     String value;
-    if (hdrId != HDR_BAD_HDR) {
+    if (hdrId != Http::HdrType::BAD_HDR) {
         if (!hdr->has(hdrId))
             return false;
         value = hdr->getStrOrList(hdrId);
@@ -83,7 +83,7 @@ ACLHTTPHeaderData::parse()
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == HDR_BAD_HDR && hdrName.size()==0) || regex_rule->empty();
+    return (hdrId == Http::HdrType::BAD_HDR && hdrName.size()==0) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *
@@ -27,7 +27,7 @@ class ACLHTTPHeaderData : public ACLData<HttpHeader*>
     virtual ACLData<HttpHeader*> *clone() const;
 
 private:
-    http_hdr_type hdrId;                /**< set if header is known */
+    Http::HdrType hdrId;                /**< set if header is known */
     String hdrName;                     /**< always set */
     ACLData<char const *> * regex_rule;
 };
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_REFERER>;
+template class ACLRequestHeaderStrategy<Http::HdrType::REFERER>;
 
@@ -17,7 +17,7 @@ class ACLChecklist;
 #include "acl/Strategy.h"
 #include "HttpReply.h"
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
@@ -38,7 +38,7 @@ class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
     ACLReplyHeaderStrategy&operator=(ACLReplyHeaderStrategy const &);
 };
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 int
 ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
@@ -50,7 +50,7 @@ ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledC
     return data->match(theHeader);
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLReplyHeaderStrategy<header> *
 ACLReplyHeaderStrategy<header>::Instance()
 {
@@ -60,7 +60,7 @@ ACLReplyHeaderStrategy<header>::Instance()
     return Instance_;
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLReplyHeaderStrategy<header> * ACLReplyHeaderStrategy<header>::Instance_ = NULL;
 
 #endif /* SQUID_REPLYHEADERSTRATEGY_H */
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>;
+template class ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
 
@@ -28,9 +28,9 @@ class ACLReplyMIMEType
 
 template <>
 inline int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->reply->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
@@ -14,7 +14,7 @@
 #include "acl/Strategy.h"
 #include "HttpRequest.h"
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 
 class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
@@ -36,7 +36,7 @@ class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
     ACLRequestHeaderStrategy&operator=(ACLRequestHeaderStrategy const &);
 };
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 int
 ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
@@ -48,7 +48,7 @@ ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFille
     return data->match(theHeader);
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLRequestHeaderStrategy<header> *
 ACLRequestHeaderStrategy<header>::Instance()
 {
@@ -58,7 +58,7 @@ ACLRequestHeaderStrategy<header>::Instance()
     return Instance_;
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLRequestHeaderStrategy<header> * ACLRequestHeaderStrategy<header>::Instance_ = NULL;
 
 #endif /* SQUID_REQUESTHEADERSTRATEGY_H */
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>;
+template class ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
 
@@ -28,9 +28,9 @@ class ACLRequestMIMEType
 
 template <>
 inline int
-ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->request->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
@@ -38,12 +38,12 @@ Adaptation::Ecap::Host::Host()
     // assign our host-specific IDs to well-known names
     // this code can run only once
 
-    libecap::headerTransferEncoding.assignHostId(HDR_TRANSFER_ENCODING);
-    libecap::headerReferer.assignHostId(HDR_REFERER);
-    libecap::headerContentLength.assignHostId(HDR_CONTENT_LENGTH);
-    libecap::headerVia.assignHostId(HDR_VIA);
-    // TODO: libecap::headerXClientIp.assignHostId(HDR_X_CLIENT_IP);
-    // TODO: libecap::headerXServerIp.assignHostId(HDR_X_SERVER_IP);
+    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);
+    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);
+    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);
+    libecap::headerVia.assignHostId(Http::HdrType::VIA);
+    // TODO: libecap::headerXClientIp.assignHostId(Http::HdrType::X_CLIENT_IP);
+    // TODO: libecap::headerXServerIp.assignHostId(Http::HdrType::X_SERVER_IP);
 
     libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);
     libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);
@@ -32,18 +32,18 @@ Adaptation::Ecap::HeaderRep::HeaderRep(HttpMsg &aMessage): theHeader(aMessage.he
 bool
 Adaptation::Ecap::HeaderRep::hasAny(const Name &name) const
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
+    const Http::HdrType squidId = TranslateHeaderId(name);
     // XXX: optimize to remove getByName: we do not need the value here
-    return squidId == HDR_OTHER ?
+    return squidId == Http::HdrType::OTHER ?
            theHeader.getByName(name.image().c_str()).size() > 0:
            (bool)theHeader.has(squidId);
 }
 
 Adaptation::Ecap::HeaderRep::Value
 Adaptation::Ecap::HeaderRep::value(const Name &name) const
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
-    const String value = squidId == HDR_OTHER ?
+    const Http::HdrType squidId = TranslateHeaderId(name);
+    const String value = squidId == Http::HdrType::OTHER ?
                          theHeader.getByName(name.image().c_str()) :
                          theHeader.getStrOrList(squidId);
     return value.size() > 0 ?
@@ -53,26 +53,26 @@ Adaptation::Ecap::HeaderRep::value(const Name &name) const
 void
 Adaptation::Ecap::HeaderRep::add(const Name &name, const Value &value)
 {
-    const http_hdr_type squidId = TranslateHeaderId(name); // HDR_OTHER OK
+    const Http::HdrType squidId = TranslateHeaderId(name); // Http::HdrType::OTHER OK
     HttpHeaderEntry *e = new HttpHeaderEntry(squidId, name.image().c_str(),
             value.toString().c_str());
     theHeader.addEntry(e);
 
-    if (squidId == HDR_CONTENT_LENGTH)
-        theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
+    if (squidId == Http::HdrType::CONTENT_LENGTH)
+        theMessage.content_length = theHeader.getInt64(Http::HdrType::CONTENT_LENGTH);
 }
 
 void
 Adaptation::Ecap::HeaderRep::removeAny(const Name &name)
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
-    if (squidId == HDR_OTHER)
+    const Http::HdrType squidId = TranslateHeaderId(name);
+    if (squidId == Http::HdrType::OTHER)
         theHeader.delByName(name.image().c_str());
     else
         theHeader.delById(squidId);
 
-    if (squidId == HDR_CONTENT_LENGTH)
-        theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
+    if (squidId == Http::HdrType::CONTENT_LENGTH)
+        theMessage.content_length = theHeader.getInt64(Http::HdrType::CONTENT_LENGTH);
 }
 
 void
@@ -103,12 +103,12 @@ Adaptation::Ecap::HeaderRep::parse(const Area &buf)
     Must(theMessage.parse(buf.start, buf.size, true, &error));
 }
 
-http_hdr_type
+Http::HdrType
 Adaptation::Ecap::HeaderRep::TranslateHeaderId(const Name &name)
 {
     if (name.assignedHostId())
-        return static_cast<http_hdr_type>(name.hostId());
-    return HDR_OTHER;
+        return static_cast<Http::HdrType>(name.hostId());
+    return Http::HdrType::OTHER;
 }
 
 /* FirstLineRep */
@@ -51,7 +51,7 @@ class HeaderRep: public libecap::Header
     virtual void parse(const Area &buf); // throws on failures
 
 protected:
-    static http_hdr_type TranslateHeaderId(const Name &name);
+    static Http::HdrType TranslateHeaderId(const Name &name);
 
 private:
     HttpHeader &theHeader; // the header being translated to libecap
@@ -833,12 +833,12 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // update the adaptation plan if needed (all status codes!)
     if (service().cfg().routing) {
         String services;
-        if (icapReply->header.getList(HDR_X_NEXT_SERVICES, &services)) {
+        if (icapReply->header.getList(Http::HdrType::X_NEXT_SERVICES, &services)) {
             Adaptation::History::Pointer ah = request->adaptHistory(true);
             if (ah != NULL)
                 ah->updateNextServices(services);
         }
-    } // TODO: else warn (occasionally!) if we got HDR_X_NEXT_SERVICES
+    } // TODO: else warn (occasionally!) if we got Http::HdrType::X_NEXT_SERVICES
 
     // We need to store received ICAP headers for <icapLastHeader logformat option.
     // If we already have stored headers from previous ICAP transaction related to this
@@ -1341,12 +1341,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
-    if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
+    if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getByName("Proxy-Authenticate");
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
-    if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
+    if (virgin.header->header.has(Http::HdrType::PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
         buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
@@ -1553,7 +1553,7 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
     // end cloning
 
     // remove all hop-by-hop headers from the clone
-    headClone->header.delById(HDR_PROXY_AUTHENTICATE);
+    headClone->header.delById(Http::HdrType::PROXY_AUTHENTICATE);
     headClone->header.removeHopByHopEntries();
 
     // pack polished HTTP header
@@ -117,15 +117,15 @@ void Adaptation::Icap::Options::configure(const HttpReply *reply)
 
     cfgIntHeader(h, "Options-TTL", theTTL);
 
-    theTimestamp = h->getTime(HDR_DATE);
+    theTimestamp = h->getTime(Http::HdrType::DATE);
 
     if (theTimestamp < 0)
         theTimestamp = squid_curtime;
 
-    if (h->hasListMember(HDR_ALLOW, "204", ','))
+    if (h->hasListMember(Http::HdrType::ALLOW, "204", ','))
         allow204 = true;
 
-    if (h->hasListMember(HDR_ALLOW, "206", ','))
+    if (h->hasListMember(Http::HdrType::ALLOW, "206", ','))
         allow206 = true;
 
     cfgIntHeader(h, "Preview", preview);
@@ -28,7 +28,7 @@ AuthenticateAcl(ACLChecklist *ch)
 {
     ACLFilledChecklist *checklist = Filled(ch);
     HttpRequest *request = checklist->request;
-    http_hdr_type headertype;
+    Http::HdrType headertype;
 
     if (NULL == request) {
         fatal ("requiresRequest SHOULD have been true for this ACL!!");
@@ -42,13 +42,13 @@ AuthenticateAcl(ACLChecklist *ch)
             return ACCESS_DENIED;
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
-        headertype = HDR_AUTHORIZATION;
+        headertype = Http::HdrType::AUTHORIZATION;
     } else if (request->flags.intercepted || request->flags.interceptTproxy) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
         /* Proxy authorization on proxy requests */
-        headertype = HDR_PROXY_AUTHORIZATION;
+        headertype = Http::HdrType::PROXY_AUTHORIZATION;
     }
 
     /* get authed here */
@@ -20,7 +20,7 @@ class HttpReply;
 class HttpRequest;
 class wordlist;
 
-/* for http_hdr_type parameters-by-value */
+/* for Http::HdrType parameters-by-value */
 #include "HttpHeader.h"
 
 namespace Format
@@ -106,7 +106,7 @@ class Config
     virtual bool dump(StoreEntry *, const char *, Config *) const;
 
     /** add headers as needed when challenging for auth */
-    virtual void fixHeader(UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *) = 0;
+    virtual void fixHeader(UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *) = 0;
 
     /// Find any existing user credentials in the authentication cache by name and type.
     virtual Auth::User::Pointer findUserInCache(const char *nameKey, Auth::Type type);
@@ -218,7 +218,7 @@ Auth::UserRequest::connLastHeader()
  * This is basically a handle approach.
  */
 static void
-authenticateAuthenticateUser(Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, ConnStateData * conn, http_hdr_type type)
+authenticateAuthenticateUser(Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, ConnStateData * conn, Http::HdrType type)
 {
     assert(auth_user_request.getRaw() != NULL);
 
@@ -271,7 +271,7 @@ authTryGetUser(Auth::UserRequest::Pointer auth_user_request, ConnStateData * con
  * Caller is responsible for locking and unlocking their *auth_user_request!
  */
 AuthAclState
-Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
+Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
 {
     const char *proxy_auth;
     assert(headertype != 0);
@@ -433,7 +433,7 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
 }
 
 AuthAclState
-Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer * aUR, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
+Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer * aUR, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
 {
     // If we have already been called, return the cached value
     Auth::UserRequest::Pointer t = authTryGetUser(*aUR, conn, request);
@@ -464,24 +464,24 @@ void
 Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal)
 /* send the auth types we are configured to support (and have compiled in!) */
 {
-    http_hdr_type type;
+    Http::HdrType type;
 
     switch (rep->sline.status()) {
 
     case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
-        type = HDR_PROXY_AUTHENTICATE;
+        type = Http::HdrType::PROXY_AUTHENTICATE;
         break;
 
     case Http::scUnauthorized:
         /* WWW Authorisation needed */
-        type = HDR_WWW_AUTHENTICATE;
+        type = Http::HdrType::WWW_AUTHENTICATE;
         break;
 
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
-        type = HDR_ENUM_END;
+        type = Http::HdrType::ENUM_END;
         break;
     }
 
@@ -126,7 +126,7 @@ class UserRequest : public RefCountable
      */
     bool valid() const;
 
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type) = 0;
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type) = 0;
 
     /* template method - what needs to be done next? advertise schemes, challenge, handle error, nothing? */
     virtual Direction module_direction() = 0;
@@ -162,7 +162,7 @@ class UserRequest : public RefCountable
      *
      * \return Some AUTH_ACL_* state
      */
-    static AuthAclState tryToAuthenticateAndSetAuthUser(UserRequest::Pointer *aUR, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &);
+    static AuthAclState tryToAuthenticateAndSetAuthUser(UserRequest::Pointer *aUR, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &);
 
     /// Add the appropriate [Proxy-]Authenticate header to the given reply
     static void addReplyAuthHeader(HttpReply * rep, UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal);
@@ -218,7 +218,7 @@ class UserRequest : public RefCountable
 
 private:
 
-    static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
+    static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
 
     /** return a message on the 407 error pages */
     char *message;
@@ -72,7 +72,7 @@ Auth::Basic::Config::type() const
 }
 
 void
-Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
+Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)
 {
     if (authenticateProgram) {
         debugs(29, 9, "Sending type:" << hdrType << " header: 'Basic realm=\"" << realm << "\"'");
@@ -30,7 +30,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     void decode(char const *httpAuthHeader, Auth::UserRequest::Pointer);
@@ -50,7 +50,7 @@ Auth::Basic::UserRequest::credentialsStr()
 /* log a basic user in
  */
 void
-Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, http_hdr_type)
+Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, Http::HdrType)
 {
     assert(user() != NULL);
 
@@ -31,7 +31,7 @@ class UserRequest : public Auth::UserRequest
     virtual ~UserRequest() { assert(LockCount()==0); }
 
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData *conn, Http::HdrType type);
     virtual Auth::Direction module_direction();
     virtual void startHelperLookup(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
@@ -509,7 +509,7 @@ Auth::Digest::Config::configured() const
 
 /* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */
 void
-Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
+Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)
 {
     if (!authenticateProgram)
         return;
@@ -79,7 +79,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);
@@ -78,7 +78,7 @@ Auth::Digest::UserRequest::credentialsStr()
 /** log a digest user in
  */
 void
-Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, http_hdr_type)
+Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, Http::HdrType)
 {
     HASHHEX SESSIONKEY;
     HASHHEX HA2 = "";
@@ -145,7 +145,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *,
                 digest_request->setDenyMessage("Incorrect password");
                 return;
             } else {
-                const char *useragent = request->header.getStr(HDR_USER_AGENT);
+                const char *useragent = request->header.getStr(Http::HdrType::USER_AGENT);
 
                 static Ip::Address last_broken_addr;
                 static int seen_broken_client = 0;
@@ -223,14 +223,14 @@ Auth::Digest::UserRequest::module_direction()
 void
 Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
 {
-    http_hdr_type type;
+    Http::HdrType type;
 
     /* don't add to authentication error pages */
     if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
             || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
+    type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
 #if WAITING_FOR_TE
     /* test for http/1.1 transfer chunked encoding */
@@ -272,7 +272,7 @@ Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int acc
             || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
+    type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
     if ((static_cast<Auth::Digest::Config*>(digestScheme::GetInstance()->getConfig())->authenticate) && authDigestNonceLastRequest(nonce)) {
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
@@ -32,7 +32,7 @@ class UserRequest : public Auth::UserRequest
     virtual ~UserRequest();
 
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
 #if WAITING_FOR_TE
@@ -174,7 +174,7 @@ Auth::Negotiate::Config::configured() const
 /* Negotiate Scheme */
 
 void
-Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type reqType, HttpRequest * request)
+Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType reqType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;
@@ -30,7 +30,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);
@@ -181,7 +181,7 @@ Auth::Negotiate::UserRequest::releaseAuthServer()
 }
 
 void
-Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
+Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, Http::HdrType type)
 {
     /* Check that we are in the client side, where we can generate
      * auth challenges */
@@ -30,7 +30,7 @@ class UserRequest : public Auth::UserRequest
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
@@ -164,7 +164,7 @@ Auth::Ntlm::Config::configured() const
 /* NTLM Scheme */
 
 void
-Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest * request)
+Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;
@@ -33,7 +33,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);
@@ -175,7 +175,7 @@ Auth::Ntlm::UserRequest::releaseAuthServer()
 }
 
 void
-Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
+Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, Http::HdrType type)
 {
     /* Check that we are in the client side, where we can generate
      * auth challenges */
@@ -29,7 +29,7 @@ class UserRequest : public Auth::UserRequest
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Auth::Direction module_direction();
     virtual void startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
@@ -4609,8 +4609,8 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
     HeaderWithAcl hwa;
     hwa.fieldName = fn;
     hwa.fieldId = HeaderLookupTable.lookup(SBuf(fn));
-    if (hwa.fieldId == HDR_BAD_HDR)
-        hwa.fieldId = HDR_OTHER;
+    if (hwa.fieldId == Http::HdrType::BAD_HDR)
+        hwa.fieldId = Http::HdrType::OTHER;
 
     Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
     ConfigParser::EnableMacros();
@@ -243,7 +243,7 @@ CacheManager::ParseHeaders(const HttpRequest * request, Mgr::ActionParams &param
     // TODO: use the authentication system decode to retrieve these details properly.
 
     /* base 64 _decoded_ user:passwd pair */
-    const char *basic_cookie = request->header.getAuth(HDR_AUTHORIZATION, "Basic");
+    const char *basic_cookie = request->header.getAuth(Http::HdrType::AUTHORIZATION, "Basic");
 
     if (!basic_cookie)
         return;
@@ -356,8 +356,8 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
         rep->header.putAuth("Basic", actionName);
 #endif
         // Allow cachemgr and other XHR scripts access to our version string
-        if (request->header.has(HDR_ORIGIN)) {
-            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
+        if (request->header.has(Http::HdrType::ORIGIN)) {
+            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(Http::HdrType::ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif
@@ -374,8 +374,8 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
         return;
     }
 
-    if (request->header.has(HDR_ORIGIN)) {
-        cmd->params.httpOrigin = request->header.getStr(HDR_ORIGIN);
+    if (request->header.has(Http::HdrType::ORIGIN)) {
+        cmd->params.httpOrigin = request->header.getStr(Http::HdrType::ORIGIN);
     }
 
     debugs(16, 2, "CacheManager: " <<
@@ -391,8 +391,8 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
         if (strncmp(rep->body.content(),"Internal Error:", 15) == 0)
             rep->sline.set(Http::ProtocolVersion(1,1), Http::scNotFound);
         // Allow cachemgr and other XHR scripts access to our version string
-        if (request->header.has(HDR_ORIGIN)) {
-            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
+        if (request->header.has(Http::HdrType::ORIGIN)) {
+            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(Http::HdrType::ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif
@@ -1047,8 +1047,8 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
 
     /* stuff the header with required entries and pack it */
 
-    if (rep->header.has(HDR_CONTENT_TYPE))
-        hdr.putStr(HDR_CONTENT_TYPE, rep->header.getStr(HDR_CONTENT_TYPE));
+    if (rep->header.has(Http::HdrType::CONTENT_TYPE))
+        hdr.putStr(Http::HdrType::CONTENT_TYPE, rep->header.getStr(Http::HdrType::CONTENT_TYPE));
 
     httpHeaderAddContRange(&hdr, *spec, rep->content_length);
 
@@ -1191,15 +1191,15 @@ ClientHttpRequest::mRangeCLen()
 static int
 clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
 {
-    const TimeOrTag spec = http->request->header.getTimeOrTag(HDR_IF_RANGE);
+    const TimeOrTag spec = http->request->header.getTimeOrTag(Http::HdrType::IF_RANGE);
     /* check for parsing falure */
 
     if (!spec.valid)
         return 0;
 
     /* got an ETag? */
     if (spec.tag.str) {
-        ETag rep_tag = rep->header.getETag(HDR_ETAG);
+        ETag rep_tag = rep->header.getETag(Http::HdrType::ETAG);
         debugs(33, 3, "clientIfRangeMatch: ETags: " << spec.tag.str << " and " <<
                (rep_tag.str ? rep_tag.str : "<none>"));
 
@@ -1253,7 +1253,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         range_err = "no [parse-able] reply";
     else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
         range_err = "wrong status code";
-    else if (hdr->has(HDR_CONTENT_RANGE))
+    else if (hdr->has(Http::HdrType::CONTENT_RANGE))
         range_err = "origin server does ranges";
     else if (rep->content_length < 0)
         range_err = "unknown length";
@@ -1263,7 +1263,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates
      */
-    else if (http->logType.isTcpHit() && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
+    else if (http->logType.isTcpHit() && http->request->header.has(Http::HdrType::IF_RANGE) && !clientIfRangeMatch(http, rep))
         range_err = "If-Range match failed";
     else if (!http->request->range->canonize(rep))
         range_err = "canonization failed";
@@ -1299,7 +1299,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
 
         if (spec_count == 1) {
             if (!replyMatchRequest) {
-                hdr->delById(HDR_CONTENT_RANGE);
+                hdr->delById(Http::HdrType::CONTENT_RANGE);
                 hdr->putContRange(rep->content_range);
                 actual_clen = rep->content_length;
                 //http->range_iter.pos = rep->content_range->spec.begin();
@@ -1311,7 +1311,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
                 assert(*pos);
                 /* append Content-Range */
 
-                if (!hdr->has(HDR_CONTENT_RANGE)) {
+                if (!hdr->has(Http::HdrType::CONTENT_RANGE)) {
                     /* No content range, so this was a full object we are
                      * sending parts of.
                      */
@@ -1327,8 +1327,8 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
             /* generate boundary string */
             http->range_iter.boundary = http->rangeBoundaryStr();
             /* delete old Content-Type, add ours */
-            hdr->delById(HDR_CONTENT_TYPE);
-            httpHeaderPutStrf(hdr, HDR_CONTENT_TYPE,
+            hdr->delById(Http::HdrType::CONTENT_TYPE);
+            httpHeaderPutStrf(hdr, Http::HdrType::CONTENT_TYPE,
                               "multipart/byteranges; boundary=\"" SQUIDSTRINGPH "\"",
                               SQUIDSTRINGPRINT(http->range_iter.boundary));
             /* Content-Length is not required in multipart responses
@@ -1341,9 +1341,9 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         /* replace Content-Length header */
         assert(actual_clen >= 0);
 
-        hdr->delById(HDR_CONTENT_LENGTH);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
 
-        hdr->putInt64(HDR_CONTENT_LENGTH, actual_clen);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, actual_clen);
 
         debugs(33, 3, "clientBuildRangeHeader: actual content length: " << actual_clen);
 
@@ -2609,14 +2609,14 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
 
     if (request->header.chunked()) {
         chunked = true;
-    } else if (request->header.has(HDR_TRANSFER_ENCODING)) {
-        const String te = request->header.getList(HDR_TRANSFER_ENCODING);
+    } else if (request->header.has(Http::HdrType::TRANSFER_ENCODING)) {
+        const String te = request->header.getList(Http::HdrType::TRANSFER_ENCODING);
         // HTTP/1.1 requires chunking to be the last encoding if there is one
         unsupportedTe = te.size() && te != "identity";
     } // else implied identity coding
 
     mustReplyToOptions = (request->method == Http::METHOD_OPTIONS) &&
-                         (request->header.getInt64(HDR_MAX_FORWARDS) == 0);
+                         (request->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0);
     if (!urlCheckRequest(request.getRaw()) || mustReplyToOptions || unsupportedTe) {
         clientStreamNode *node = context->getClientReplyContext();
         conn->quitAfterError(request.getRaw());
@@ -4556,11 +4556,11 @@ int
 varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
 {
     const char *vary = request->vary_headers;
-    int has_vary = entry->getReply()->header.has(HDR_VARY);
+    int has_vary = entry->getReply()->header.has(Http::HdrType::VARY);
 #if X_ACCELERATOR_VARY
 
     has_vary |=
-        entry->getReply()->header.has(HDR_X_ACCELERATOR_VARY);
+        entry->getReply()->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 #endif
 
     if (!has_vary || !entry->mem_obj->vary_headers) {
@@ -297,7 +297,7 @@ clientReplyContext::processExpired()
 
     http->request->lastmod = old_entry->lastmod;
 
-    if (!http->request->header.has(HDR_IF_NONE_MATCH)) {
+    if (!http->request->header.has(Http::HdrType::IF_NONE_MATCH)) {
         ETag etag = {NULL, -1}; // TODO: make that a default ETag constructor
         if (old_entry->hasEtag(etag) && !etag.weak)
             http->request->etag = etag.str;
@@ -743,20 +743,20 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
 
     HttpRequest &r = *http->request;
 
-    if (r.header.has(HDR_IF_MATCH) && !e->hasIfMatchEtag(r)) {
+    if (r.header.has(Http::HdrType::IF_MATCH) && !e->hasIfMatchEtag(r)) {
         // RFC 2616: reply with 412 Precondition Failed if If-Match did not match
         sendPreconditionFailedError();
         return;
     }
 
     bool matchedIfNoneMatch = false;
-    if (r.header.has(HDR_IF_NONE_MATCH)) {
+    if (r.header.has(Http::HdrType::IF_NONE_MATCH)) {
         if (!e->hasIfNoneMatchEtag(r)) {
             // RFC 2616: ignore IMS if If-None-Match did not match
             r.flags.ims = false;
             r.ims = -1;
             r.imslen = 0;
-            r.header.delById(HDR_IF_MODIFIED_SINCE);
+            r.header.delById(Http::HdrType::IF_MODIFIED_SINCE);
             http->logType = LOG_TCP_MISS;
             sendMoreData(result);
             return;
@@ -1318,13 +1318,13 @@ clientReplyContext::buildReplyHeader()
 #endif
 
     if (is_hit)
-        hdr->delById(HDR_SET_COOKIE);
+        hdr->delById(Http::HdrType::SET_COOKIE);
     // TODO: RFC 2965 : Must honour Cache-Control: no-cache="set-cookie2" and remove header.
 
     // if there is not configured a peer proxy with login=PASS or login=PASSTHRU option enabled
     // remove the Proxy-Authenticate header
     if ( !request->peer_login || (strcmp(request->peer_login,"PASS") != 0 && strcmp(request->peer_login,"PASSTHRU") != 0))
-        reply->header.delById(HDR_PROXY_AUTHENTICATE);
+        reply->header.delById(Http::HdrType::PROXY_AUTHENTICATE);
 
     reply->header.removeHopByHopEntries();
 
@@ -1340,27 +1340,27 @@ clientReplyContext::buildReplyHeader()
          * (note that the existing header is passed along unmodified
          * on cache misses)
          */
-        hdr->delById(HDR_AGE);
+        hdr->delById(Http::HdrType::AGE);
         /*
          * This adds the calculated object age. Note that the details of the
          * age calculation is performed by adjusting the timestamp in
          * StoreEntry::timestampsSet(), not here.
          */
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
-            hdr->delById(HDR_DATE);
-            hdr->insertTime(HDR_DATE, squid_curtime);
+            hdr->delById(Http::HdrType::DATE);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
-            HttpHeaderEntry *h = hdr->findEntry(HDR_DATE);
+            HttpHeaderEntry *h = hdr->findEntry(Http::HdrType::DATE);
             if (h)
                 hdr->putExt("X-Origin-Date", h->value.termedBuf());
-            hdr->delById(HDR_DATE);
-            hdr->insertTime(HDR_DATE, squid_curtime);
-            h = hdr->findEntry(HDR_EXPIRES);
+            hdr->delById(Http::HdrType::DATE);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            h = hdr->findEntry(Http::HdrType::EXPIRES);
             if (h && http->storeEntry()->expires >= 0) {
                 hdr->putExt("X-Origin-Expires", h->value.termedBuf());
-                hdr->delById(HDR_EXPIRES);
-                hdr->insertTime(HDR_EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
+                hdr->delById(Http::HdrType::EXPIRES);
+                hdr->insertTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
@@ -1369,7 +1369,7 @@ clientReplyContext::buildReplyHeader()
                 hdr->putExt("X-Cache-Age", age);
             }
         } else if (http->storeEntry()->timestamp <= squid_curtime) {
-            hdr->putInt(HDR_AGE,
+            hdr->putInt(Http::HdrType::AGE,
                         squid_curtime - http->storeEntry()->timestamp);
             /* Signal old objects.  NB: rfc 2616 is not clear,
              * by implication, on whether we should do this to all
@@ -1385,7 +1385,7 @@ clientReplyContext::buildReplyHeader()
                 snprintf (tbuf, sizeof(tbuf), "%s %s %s",
                           "113", ThisCache,
                           "This cache hit is still fresh and more than 1 day old");
-                hdr->putStr(HDR_WARNING, tbuf);
+                hdr->putStr(Http::HdrType::WARNING, tbuf);
             }
         }
     }
@@ -1397,11 +1397,11 @@ clientReplyContext::buildReplyHeader()
      *
      * NP: done after Age: to prevent ENTRY_SPECIAL double-handling this header.
      */
-    if ( !hdr->has(HDR_DATE) ) {
+    if ( !hdr->has(Http::HdrType::DATE) ) {
         if (!http->storeEntry())
-            hdr->insertTime(HDR_DATE, squid_curtime);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
         else if (http->storeEntry()->timestamp > 0)
-            hdr->insertTime(HDR_DATE, http->storeEntry()->timestamp);
+            hdr->insertTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
         else {
             debugs(88,DBG_IMPORTANT,"BUG 3279: HTTP reply without Date:");
             /* dump something useful about the problem */
@@ -1418,13 +1418,13 @@ clientReplyContext::buildReplyHeader()
 
     /* Filter unproxyable authentication types */
     if (http->logType.oldType != LOG_TCP_DENIED &&
-            hdr->has(HDR_WWW_AUTHENTICATE)) {
+            hdr->has(Http::HdrType::WWW_AUTHENTICATE)) {
         HttpHeaderPos pos = HttpHeaderInitPos;
         HttpHeaderEntry *e;
 
         int connection_auth_blocked = 0;
         while ((e = hdr->getEntry(&pos))) {
-            if (e->id == HDR_WWW_AUTHENTICATE) {
+            if (e->id == Http::HdrType::WWW_AUTHENTICATE) {
                 const char *value = e->value.rawBuf();
 
                 if ((strncasecmp(value, "NTLM", 4) == 0 &&
@@ -1441,14 +1441,14 @@ clientReplyContext::buildReplyHeader()
                     }
                     request->flags.mustKeepalive = true;
                     if (!request->flags.accelerated && !request->flags.intercepted) {
-                        httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
+                        httpHeaderPutStrf(hdr, Http::HdrType::PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
                           We send "Connection: Proxy-Support" header to mark
                           Proxy-Support as a hop-by-hop header for intermediaries that do not
                           understand the semantics of this header. The RFC should have included
                           this recommendation.
                         */
-                        httpHeaderPutStrf(hdr, HDR_CONNECTION, "Proxy-support");
+                        httpHeaderPutStrf(hdr, Http::HdrType::CONNECTION, "Proxy-support");
                     }
                     break;
                 }
@@ -1477,12 +1477,12 @@ clientReplyContext::buildReplyHeader()
 #endif
 
     /* Append X-Cache */
-    httpHeaderPutStrf(hdr, HDR_X_CACHE, "%s from %s",
+    httpHeaderPutStrf(hdr, Http::HdrType::X_CACHE, "%s from %s",
                       is_hit ? "HIT" : "MISS", getMyHostname());
 
 #if USE_CACHE_DIGESTS
     /* Append X-Cache-Lookup: -- temporary hack, to be removed @?@ @?@ */
-    httpHeaderPutStrf(hdr, HDR_X_CACHE_LOOKUP, "%s from %s:%d",
+    httpHeaderPutStrf(hdr, Http::HdrType::X_CACHE_LOOKUP, "%s from %s:%d",
                       lookup_type ? lookup_type : "NONE",
                       getMyHostname(), getMyPort());
 
@@ -1534,24 +1534,24 @@ clientReplyContext::buildReplyHeader()
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
         request->flags.chunkedReply = true;
-        hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
+        hdr->putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     /* Append VIA */
     if (Config.onoff.via) {
         LOCAL_ARRAY(char, bbuf, MAX_URL + 32);
         String strVia;
-        hdr->getList(HDR_VIA, &strVia);
+        hdr->getList(Http::HdrType::VIA, &strVia);
         snprintf(bbuf, MAX_URL + 32, "%d.%d %s",
                  reply->sline.version.major,
                  reply->sline.version.minor,
                  ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        hdr->delById(HDR_VIA);
-        hdr->putStr(HDR_VIA, strVia.termedBuf());
+        hdr->delById(Http::HdrType::VIA);
+        hdr->putStr(Http::HdrType::VIA, strVia.termedBuf());
     }
     /* Signal keep-alive or close explicitly */
-    hdr->putStr(HDR_CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
+    hdr->putStr(Http::HdrType::CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
 
 #if ADD_X_REQUEST_URI
     /*
@@ -1560,15 +1560,15 @@ clientReplyContext::buildReplyHeader()
      * but X-Request-URI is likely to be the very last header to ease use from a
      * debugger [hdr->entries.count-1].
      */
-    hdr->putStr(HDR_X_REQUEST_URI,
+    hdr->putStr(Http::HdrType::X_REQUEST_URI,
                 http->memOjbect()->url ? http->memObject()->url : http->uri);
 
 #endif
 
     /* Surrogate-Control requires Surrogate-Capability from upstream to pass on */
-    if ( hdr->has(HDR_SURROGATE_CONTROL) ) {
-        if (!request->header.has(HDR_SURROGATE_CAPABILITY)) {
-            hdr->delById(HDR_SURROGATE_CONTROL);
+    if ( hdr->has(Http::HdrType::SURROGATE_CONTROL) ) {
+        if (!request->header.has(Http::HdrType::SURROGATE_CAPABILITY)) {
+            hdr->delById(Http::HdrType::SURROGATE_CONTROL);
         }
         /* TODO: else case: drop any controls intended specifically for our surrogate ID */
     }
@@ -1753,7 +1753,7 @@ clientGetMoreData(clientStreamNode * aNode, ClientHttpRequest * http)
     // OPTIONS with Max-Forwards:0 handled in clientProcessRequest()
 
     if (context->http->request->method == Http::METHOD_TRACE) {
-        if (context->http->request->header.getInt64(HDR_MAX_FORWARDS) == 0) {
+        if (context->http->request->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0) {
             context->traceReply(aNode);
             return;
         }
@@ -573,7 +573,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
 
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: Host header forgery detected on " <<
            http->getConn()->clientConnection << " (" << A << " does not match " << B << ")");
-    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(HDR_USER_AGENT));
+    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(Http::HdrType::USER_AGENT));
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: on URL: " << http->request->effectiveRequestUri());
 
     // IP address validation for Host: failed. reject the connection.
@@ -599,7 +599,7 @@ void
 ClientRequestContext::hostHeaderVerify()
 {
     // Require a Host: header.
-    const char *host = http->request->header.getStr(HDR_HOST);
+    const char *host = http->request->header.getStr(Http::HdrType::HOST);
 
     if (!host) {
         // TODO: dump out the HTTP/1.1 error about missing host header.
@@ -696,14 +696,14 @@ ClientRequestContext::clientAccessCheck()
 #if FOLLOW_X_FORWARDED_FOR
     if (!http->request->flags.doneFollowXff() &&
             Config.accessList.followXFF &&
-            http->request->header.has(HDR_X_FORWARDED_FOR)) {
+            http->request->header.has(Http::HdrType::X_FORWARDED_FOR)) {
 
         /* we always trust the direct client address for actual use */
         http->request->indirect_client_addr = http->request->client_addr;
         http->request->indirect_client_addr.port(0);
 
         /* setup the XFF iterator for processing */
-        http->request->x_forwarded_for_iterator = http->request->header.getList(HDR_X_FORWARDED_FOR);
+        http->request->x_forwarded_for_iterator = http->request->header.getList(Http::HdrType::X_FORWARDED_FOR);
 
         /* begin by checking to see if we trust direct client enough to walk XFF */
         acl_checklist = clientAclChecklistCreate(Config.accessList.followXFF, http);
@@ -1016,19 +1016,19 @@ clientCheckPinning(ClientHttpRequest * http)
      * is already pinned if it was pinned earlier due to proxy auth
      */
     if (!request->flags.connectionAuth) {
-        if (req_hdr->has(HDR_AUTHORIZATION) || req_hdr->has(HDR_PROXY_AUTHORIZATION)) {
+        if (req_hdr->has(Http::HdrType::AUTHORIZATION) || req_hdr->has(Http::HdrType::PROXY_AUTHORIZATION)) {
             HttpHeaderPos pos = HttpHeaderInitPos;
             HttpHeaderEntry *e;
             int may_pin = 0;
             while ((e = req_hdr->getEntry(&pos))) {
-                if (e->id == HDR_AUTHORIZATION || e->id == HDR_PROXY_AUTHORIZATION) {
+                if (e->id == Http::HdrType::AUTHORIZATION || e->id == Http::HdrType::PROXY_AUTHORIZATION) {
                     const char *value = e->value.rawBuf();
                     if (strncasecmp(value, "NTLM ", 5) == 0
                             ||
                             strncasecmp(value, "Negotiate ", 10) == 0
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
-                        if (e->id == HDR_AUTHORIZATION) {
+                        if (e->id == Http::HdrType::AUTHORIZATION) {
                             request->flags.connectionAuth = true;
                             may_pin = 1;
                         } else {
@@ -1055,7 +1055,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     const char *str;
 
     request->imslen = -1;
-    request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
+    request->ims = req_hdr->getTime(Http::HdrType::IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
         request->flags.ims = true;
@@ -1066,8 +1066,8 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
                 no_cache=true;
 
             // RFC 2616: treat Pragma:no-cache as if it was Cache-Control:no-cache when Cache-Control is missing
-        } else if (req_hdr->has(HDR_PRAGMA))
-            no_cache = req_hdr->hasListMember(HDR_PRAGMA,"no-cache",',');
+        } else if (req_hdr->has(Http::HdrType::PRAGMA))
+            no_cache = req_hdr->hasListMember(Http::HdrType::PRAGMA,"no-cache",',');
 
         /*
         * Work around for supporting the Reload button in IE browsers when Squid
@@ -1078,7 +1078,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         */
         if (Config.onoff.ie_refresh) {
             if (http->flags.accel && request->flags.ims) {
-                if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
+                if ((str = req_hdr->getStr(Http::HdrType::USER_AGENT))) {
                     if (strstr(str, "MSIE 5.01") != NULL)
                         no_cache=true;
                     else if (strstr(str, "MSIE 5.0") != NULL)
@@ -1136,21 +1136,21 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
      * If these headers appear on any other type of request, delete them now.
      */
     else {
-        req_hdr->delById(HDR_RANGE);
-        req_hdr->delById(HDR_REQUEST_RANGE);
+        req_hdr->delById(Http::HdrType::RANGE);
+        req_hdr->delById(Http::HdrType::REQUEST_RANGE);
         request->ignoreRange("neither HEAD nor GET");
     }
 
-    if (req_hdr->has(HDR_AUTHORIZATION))
+    if (req_hdr->has(Http::HdrType::AUTHORIZATION))
         request->flags.auth = true;
 
     clientCheckPinning(http);
 
     if (!request->url.userInfo().isEmpty())
         request->flags.auth = true;
 
-    if (req_hdr->has(HDR_VIA)) {
-        String s = req_hdr->getList(HDR_VIA);
+    if (req_hdr->has(Http::HdrType::VIA)) {
+        String s = req_hdr->getList(Http::HdrType::VIA);
         /*
          * ThisCache cannot be a member of Via header, "1.1 ThisCache" can.
          * Note ThisCache2 has a space prepended to the hostname so we don't
@@ -1173,8 +1173,8 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 
 #if USE_FORW_VIA_DB
 
-    if (req_hdr->has(HDR_X_FORWARDED_FOR)) {
-        String s = req_hdr->getList(HDR_X_FORWARDED_FOR);
+    if (req_hdr->has(Http::HdrType::X_FORWARDED_FOR)) {
+        String s = req_hdr->getList(Http::HdrType::X_FORWARDED_FOR);
         fvdbCountForw(s.termedBuf());
         s.clean();
     }
@@ -449,7 +449,7 @@ sameUrlHosts(const char *url1, const char *url2)
 
 // purges entries that match the value of a given HTTP [response] header
 static void
-purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hdr_type hdr)
+purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, Http::HdrType hdr)
 {
     const char *hdrUrl, *absUrl;
 
@@ -497,8 +497,8 @@ Client::maybePurgeOthers()
     const char *reqUrl = tmp.c_str();
     debugs(88, 5, "maybe purging due to " << request->method << ' ' << tmp);
     purgeEntriesByUrl(request, reqUrl);
-    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
-    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, Http::HdrType::LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, Http::HdrType::CONTENT_LOCATION);
 }
 
 /// called when we have final (possibly adapted) reply headers; kids extend
@@ -1045,7 +1045,7 @@ Ftp::Gateway::checkAuth(const HttpHeader * req_hdr)
 
 #if HAVE_AUTH_MODULE_BASIC
     /* Check HTTP Authorization: headers (better than defaults, but less than URL) */
-    const SBuf auth(req_hdr->getAuth(HDR_AUTHORIZATION, "Basic"));
+    const SBuf auth(req_hdr->getAuth(Http::HdrType::AUTHORIZATION, "Basic"));
     if (!auth.isEmpty()) {
         flags.authenticated = 1;
         loginParser(auth, false);
@@ -2045,7 +2045,7 @@ ftpSendStor(Ftp::Gateway * ftpState)
         snprintf(cbuf, CTRL_BUFLEN, "STOR %s\r\n", ftpState->filepath);
         ftpState->writeCommand(cbuf);
         ftpState->state = Ftp::Client::SENT_STOR;
-    } else if (ftpState->request->header.getInt64(HDR_CONTENT_LENGTH) > 0) {
+    } else if (ftpState->request->header.getInt64(Http::HdrType::CONTENT_LENGTH) > 0) {
         /* File upload without a filename. use STOU to generate one */
         snprintf(cbuf, CTRL_BUFLEN, "STOU\r\n");
         ftpState->writeCommand(cbuf);
@@ -2605,7 +2605,7 @@ Ftp::Gateway::appendSuccessHeader()
 
     /* additional info */
     if (mime_enc)
-        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
     setVirginReply(reply);
     adaptOrFinalizeReply();
@@ -396,8 +396,8 @@ Ftp::Relay::createHttpReply(const Http::StatusCode httpStatus, const int64_t cle
     HttpReply *const reply = Ftp::HttpReplyWrapper(ctrl.replycode, ctrl.last_reply, httpStatus, clen);
     if (ctrl.message) {
         for (wordlist *W = ctrl.message; W && W->next; W = W->next)
-            reply->header.putStr(HDR_FTP_PRE, httpHeaderQuoteString(W->key).c_str());
-        // no hdrCacheInit() is needed for after HDR_FTP_PRE addition
+            reply->header.putStr(Http::HdrType::FTP_PRE, httpHeaderQuoteString(W->key).c_str());
+        // no hdrCacheInit() is needed for after Http::HdrType::FTP_PRE addition
     }
     return reply;
 }
@@ -473,16 +473,16 @@ Ftp::Relay::readGreeting()
 void
 Ftp::Relay::sendCommand()
 {
-    if (!fwd->request->header.has(HDR_FTP_COMMAND)) {
+    if (!fwd->request->header.has(Http::HdrType::FTP_COMMAND)) {
         abortTransaction("Internal error: FTP relay request with no command");
         return;
     }
 
     HttpHeader &header = fwd->request->header;
-    assert(header.has(HDR_FTP_COMMAND));
-    const String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
-    assert(header.has(HDR_FTP_ARGUMENTS));
-    const String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+    assert(header.has(Http::HdrType::FTP_COMMAND));
+    const String &cmd = header.findEntry(Http::HdrType::FTP_COMMAND)->value;
+    assert(header.has(Http::HdrType::FTP_ARGUMENTS));
+    const String &params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)->value;
 
     if (params.size() > 0)
         debugs(9, 5, "command: " << cmd << ", parameters: " << params);
@@ -418,7 +418,7 @@ TemplateFile::loadFor(const HttpRequest *request)
     if (loaded()) // already loaded?
         return true;
 
-    if (!request || !request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr) )
+    if (!request || !request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr) )
         return false;
 
     char lang[256];
@@ -1149,10 +1149,10 @@ ErrorState::BuildHttpReply()
             MemBuf redirect_location;
             redirect_location.init();
             DenyInfoLocation(name, request, redirect_location);
-            httpHeaderPutStrf(&rep->header, HDR_LOCATION, "%s", redirect_location.content() );
+            httpHeaderPutStrf(&rep->header, Http::HdrType::LOCATION, "%s", redirect_location.content() );
         }
 
-        httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
+        httpHeaderPutStrf(&rep->header, Http::HdrType::X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
     } else {
         MemBuf *content = BuildContent();
         rep->setHeaders(httpStatus, NULL, "text/html;charset=utf-8", content->contentSize(), 0, -1);
@@ -1164,7 +1164,7 @@ ErrorState::BuildHttpReply()
          * might want to know. Someone _will_ want to know OTOH, the first
          * X-CACHE-MISS entry should tell us who.
          */
-        httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d", name, xerrno);
+        httpHeaderPutStrf(&rep->header, Http::HdrType::X_SQUID_ERROR, "%s %d", name, xerrno);
 
 #if USE_ERR_LOCALES
         /*
@@ -1175,20 +1175,20 @@ ErrorState::BuildHttpReply()
          */
         if (!Config.errorDirectory) {
             /* We 'negotiated' this ONLY from the Accept-Language. */
-            rep->header.delById(HDR_VARY);
-            rep->header.putStr(HDR_VARY, "Accept-Language");
+            rep->header.delById(Http::HdrType::VARY);
+            rep->header.putStr(Http::HdrType::VARY, "Accept-Language");
         }
 
         /* add the Content-Language header according to RFC section 14.12 */
         if (err_language) {
-            rep->header.putStr(HDR_CONTENT_LANGUAGE, err_language);
+            rep->header.putStr(Http::HdrType::CONTENT_LANGUAGE, err_language);
         } else
 #endif /* USE_ERROR_LOCALES */
         {
             /* default templates are in English */
             /* language is known unless error_directory override used */
             if (!Config.errorDirectory)
-                rep->header.putStr(HDR_CONTENT_LANGUAGE, "en");
+                rep->header.putStr(Http::HdrType::CONTENT_LANGUAGE, "en");
         }
 
         rep->body.setMb(content);
@@ -839,10 +839,10 @@ ESIContextNew (HttpReply *rep, clientStreamNode *thisNode, ClientHttpRequest *ht
         /* remove specific headers for ESI to prevent
          * downstream cache confusion */
         HttpHeader *hdr = &rep->header;
-        hdr->delById(HDR_ACCEPT_RANGES);
-        hdr->delById(HDR_ETAG);
-        hdr->delById(HDR_CONTENT_LENGTH);
-        hdr->delById(HDR_CONTENT_MD5);
+        hdr->delById(Http::HdrType::ACCEPT_RANGES);
+        hdr->delById(Http::HdrType::ETAG);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
+        hdr->delById(Http::HdrType::CONTENT_MD5);
         rv->tree = new esiSequence (rv, true);
         rv->thisNode = thisNode;
         rv->http = http;
@@ -319,8 +319,8 @@ ESIVariableUserAgent::ESIVariableUserAgent(ESIVarState &state)
      * In future, this may be better implemented as a regexp.
      */
 
-    if (state.header().has(HDR_USER_AGENT)) {
-        char const *s = state.header().getStr(HDR_USER_AGENT);
+    if (state.header().has(Http::HdrType::USER_AGENT)) {
+        char const *s = state.header().getStr(Http::HdrType::USER_AGENT);
         UserOs = identifyOs(s);
         char const *t, *t1;
 
@@ -376,11 +376,11 @@ ESIVariableCookie::eval (ESIVarState &state, char const *subref, char const *fou
     const char *s = NULL;
     state.cookieUsed();
 
-    if (state.header().has(HDR_COOKIE)) {
+    if (state.header().has(Http::HdrType::COOKIE)) {
         if (!subref)
-            s = state.header().getStr (HDR_COOKIE);
+            s = state.header().getStr (Http::HdrType::COOKIE);
         else {
-            String S = state.header().getListMember (HDR_COOKIE, subref, ';');
+            String S = state.header().getListMember (Http::HdrType::COOKIE, subref, ';');
 
             if (S.size())
                 ESISegment::ListAppend (state.getOutput(), S.rawBuf(), S.size());
@@ -400,8 +400,8 @@ ESIVariableHost::eval (ESIVarState &state, char const *subref, char const *found
     const char *s = NULL;
     state.hostUsed();
 
-    if (!subref && state.header().has(HDR_HOST)) {
-        s = state.header().getStr (HDR_HOST);
+    if (!subref && state.header().has(Http::HdrType::HOST)) {
+        s = state.header().getStr (Http::HdrType::HOST);
     } else
         s = found_default;
 
@@ -414,12 +414,12 @@ ESIVariableLanguage::eval (ESIVarState &state, char const *subref, char const *f
     char const *s = NULL;
     state.languageUsed();
 
-    if (state.header().has(HDR_ACCEPT_LANGUAGE)) {
+    if (state.header().has(Http::HdrType::ACCEPT_LANGUAGE)) {
         if (!subref) {
-            String S (state.header().getList (HDR_ACCEPT_LANGUAGE));
+            String S (state.header().getList (Http::HdrType::ACCEPT_LANGUAGE));
             ESISegment::ListAppend (state.getOutput(), S.rawBuf(), S.size());
         } else {
-            if (state.header().hasListMember (HDR_ACCEPT_LANGUAGE, subref, ',')) {
+            if (state.header().hasListMember (Http::HdrType::ACCEPT_LANGUAGE, subref, ',')) {
                 s = "true";
             } else {
                 s = "false";
@@ -463,8 +463,8 @@ ESIVariableReferer::eval (ESIVarState &state, char const *subref, char const *fo
     const char *s = NULL;
     state.refererUsed();
 
-    if (!subref && state.header().has(HDR_REFERER))
-        s = state.header().getStr (HDR_REFERER);
+    if (!subref && state.header().has(Http::HdrType::REFERER))
+        s = state.header().getStr (Http::HdrType::REFERER);
     else
         s = found_default;
 
@@ -477,9 +477,9 @@ ESIVariableUserAgent::eval (ESIVarState &state, char const *subref, char const *
     char const *s = NULL;
     state.useragentUsed();
 
-    if (state.header().has(HDR_USER_AGENT)) {
+    if (state.header().has(Http::HdrType::USER_AGENT)) {
         if (!subref)
-            s = state.header().getStr (HDR_USER_AGENT);
+            s = state.header().getStr (Http::HdrType::USER_AGENT);
         else {
             if (!strcmp (subref, "os")) {
                 s = esiUserOs[UserOs];
@@ -830,10 +830,10 @@ ESIVarState::buildVary (HttpReply *rep)
     if (!tempstr[0])
         return;
 
-    String strVary (rep->header.getList (HDR_VARY));
+    String strVary (rep->header.getList (Http::HdrType::VARY));
 
     if (!strVary.size() || strVary[0] != '*') {
-        rep->header.putStr (HDR_VARY, tempstr);
+        rep->header.putStr (Http::HdrType::VARY, tempstr);
     }
 }
 
@@ -73,7 +73,7 @@ class external_acl_format : public RefCountable
 public:
     typedef RefCount<external_acl_format> Pointer;
 
-    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(HDR_BAD_HDR) {}
+    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(Http::HdrType::BAD_HDR) {}
     ~external_acl_format() {
         xfree(header);
         xfree(member);
@@ -84,7 +84,7 @@ class external_acl_format : public RefCountable
     char *header;
     char *member;
     char separator;
-    http_hdr_type header_id;
+    Http::HdrType header_id;
 };
 
 class external_acl
@@ -1010,15 +1010,15 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
         break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER:
-            if (format->header_id == HDR_BAD_HDR)
+            if (format->header_id == Http::HdrType::BAD_HDR)
                 sb = request->header.getByName(format->header);
             else
                 sb = request->header.getStrOrList(format->header_id);
             str = sb.termedBuf();
             break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-            if (format->header_id == HDR_BAD_HDR)
+            if (format->header_id == Http::HdrType::BAD_HDR)
                 sb = request->header.getByNameListMember(format->header, format->member, format->separator);
             else
                 sb = request->header.getListMember(format->header_id, format->member, format->separator);
@@ -1027,7 +1027,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
         case Format::LFT_REPLY_HEADER:
             if (reply) {
-                if (format->header_id == HDR_BAD_HDR)
+                if (format->header_id == Http::HdrType::BAD_HDR)
                     sb = reply->header.getByName(format->header);
                 else
                     sb = reply->header.getStrOrList(format->header_id);
@@ -1037,7 +1037,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
         case Format::LFT_REPLY_HEADER_ELEM:
             if (reply) {
-                if (format->header_id == HDR_BAD_HDR)
+                if (format->header_id == Http::HdrType::BAD_HDR)
                     sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
                 else
                     sb = reply->header.getListMember(format->header_id, format->member, format->separator);
@@ -36,18 +36,18 @@ Ftp::HttpReplyWrapper(const int ftpStatus, const char *ftpReason, const Http::St
     reply->sline.set(httpVersion, httpStatus);
 
     HttpHeader &header = reply->header;
-    header.putTime(HDR_DATE, squid_curtime);
+    header.putTime(Http::HdrType::DATE, squid_curtime);
     {
         HttpHdrCc cc;
         cc.Private(String());
         header.putCc(&cc);
     }
     if (ftpStatus > 0)
-        header.putInt(HDR_FTP_STATUS, ftpStatus);
+        header.putInt(Http::HdrType::FTP_STATUS, ftpStatus);
     if (ftpReason)
-        header.putStr(HDR_FTP_REASON, ftpReason);
+        header.putStr(Http::HdrType::FTP_REASON, ftpReason);
     if (clen >= 0)
-        header.putInt64(HDR_CONTENT_LENGTH, clen);
+        header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     reply->hdrCacheInit();
     return reply;
 }
@@ -243,7 +243,7 @@ gopherMimeCreate(GopherStateData * gopherState)
     entry->buffer();
     reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, -1, -1, -2);
     if (mime_enc)
-        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
     entry->replaceHttpReply(reply);
 }
@@ -843,9 +843,9 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         stuff.S.req_hdrs = spec->req_hdrs;
         stuff.S.reqHdrsSz = spec->reqHdrsSz;
         if (e)
-            hdr.putInt(HDR_AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
+            hdr.putInt(Http::HdrType::AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
         else
-            hdr.putInt(HDR_AGE, 0);
+            hdr.putInt(Http::HdrType::AGE, 0);
         MemBuf mb;
         mb.init();
         hdr.packInto(&mb);
@@ -856,10 +856,10 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         hdr.reset();
 
         if (e && e->expires > -1)
-            hdr.putTime(HDR_EXPIRES, e->expires);
+            hdr.putTime(Http::HdrType::EXPIRES, e->expires);
 
         if (e && e->lastmod > -1)
-            hdr.putTime(HDR_LAST_MODIFIED, e->lastmod);
+            hdr.putTime(Http::HdrType::LAST_MODIFIED, e->lastmod);
 
         hdr.packInto(&mb);
 
@@ -439,7 +439,7 @@ HttpStateData::cacheableReply()
      * continuous push replies.  These are generally dynamic and
      * probably should not be cachable
      */
-    if ((v = hdr->getStr(HDR_CONTENT_TYPE)))
+    if ((v = hdr->getStr(Http::HdrType::CONTENT_TYPE)))
         if (!strncasecmp(v, "multipart/x-mixed-replace", 25)) {
             debugs(22, 3, HERE << "NO because Content-Type:multipart/x-mixed-replace");
             return 0;
@@ -586,7 +586,7 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
     static String vstr;
 
     vstr.clean();
-    vary = reply->header.getList(HDR_VARY);
+    vary = reply->header.getList(Http::HdrType::VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -619,7 +619,7 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
 #if X_ACCELERATOR_VARY
 
     pos = NULL;
-    vary = reply->header.getList(HDR_X_ACCELERATOR_VARY);
+    vary = reply->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -912,10 +912,10 @@ bool HttpStateData::peerSupportsConnectionPinning() const
       reply and has in its list the "Session-Based-Authentication"
       which means that the peer supports connection pinning.
      */
-    if (!hdr->has(HDR_PROXY_SUPPORT))
+    if (!hdr->has(Http::HdrType::PROXY_SUPPORT))
         return false;
 
-    header = hdr->getStrOrList(HDR_PROXY_SUPPORT);
+    header = hdr->getStrOrList(Http::HdrType::PROXY_SUPPORT);
     /* XXX This ought to be done in a case-insensitive manner */
     rc = (strstr(header.termedBuf(), "Session-Based-Authentication") != NULL);
 
@@ -941,9 +941,9 @@ HttpStateData::haveParsedReplyHeaders()
         httpMaybeRemovePublic(entry, rep->sline.status());
 
     bool varyFailure = false;
-    if (rep->header.has(HDR_VARY)
+    if (rep->header.has(Http::HdrType::VARY)
 #if X_ACCELERATOR_VARY
-            || rep->header.has(HDR_X_ACCELERATOR_VARY)
+            || rep->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY)
 #endif
        ) {
         const char *vary = httpMakeVaryMark(request, rep);
@@ -1018,8 +1018,8 @@ HttpStateData::haveParsedReplyHeaders()
 
             /* HACK: Pragma: no-cache in _replies_ is not documented in HTTP,
              * but servers like "Active Imaging Webcast/2.0" sure do use it */
-            if (rep->header.has(HDR_PRAGMA) &&
-                    rep->header.hasListMember(HDR_PRAGMA,"no-cache",','))
+            if (rep->header.has(Http::HdrType::PRAGMA) &&
+                    rep->header.hasListMember(Http::HdrType::PRAGMA,"no-cache",','))
                 EBIT_SET(entry->flags, ENTRY_REVALIDATE);
         }
 #endif
@@ -1655,7 +1655,7 @@ HttpStateData::doneWithServer() const
 static void
 httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHeader * hdr_out, const HttpStateFlags &flags)
 {
-    http_hdr_type header = flags.originpeer ? HDR_AUTHORIZATION : HDR_PROXY_AUTHORIZATION;
+    Http::HdrType header = flags.originpeer ? Http::HdrType::AUTHORIZATION : Http::HdrType::PROXY_AUTHORIZATION;
 
     /* Nothing to do unless we are forwarding to a peer */
     if (!request->flags.proxying)
@@ -1674,8 +1674,8 @@ httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHe
         return;
 
     /* PROXYPASS is a special case, single-signon to servers with the proxy password (basic only) */
-    if (flags.originpeer && strcmp(request->peer_login, "PROXYPASS") == 0 && hdr_in->has(HDR_PROXY_AUTHORIZATION)) {
-        const char *auth = hdr_in->getStr(HDR_PROXY_AUTHORIZATION);
+    if (flags.originpeer && strcmp(request->peer_login, "PROXYPASS") == 0 && hdr_in->has(Http::HdrType::PROXY_AUTHORIZATION)) {
+        const char *auth = hdr_in->getStr(Http::HdrType::PROXY_AUTHORIZATION);
 
         if (auth && strncasecmp(auth, "basic ", 6) == 0) {
             hdr_out->putStr(header, auth);
@@ -1767,18 +1767,18 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* use our IMS header if the cached entry has Last-Modified time */
     if (request->lastmod > -1)
-        hdr_out->putTime(HDR_IF_MODIFIED_SINCE, request->lastmod);
+        hdr_out->putTime(Http::HdrType::IF_MODIFIED_SINCE, request->lastmod);
 
     // Add our own If-None-Match field if the cached entry has a strong ETag.
     // copyOneHeaderFromClientsideRequestToUpstreamRequest() adds client ones.
     if (request->etag.size() > 0) {
-        hdr_out->addEntry(new HttpHeaderEntry(HDR_IF_NONE_MATCH, NULL,
+        hdr_out->addEntry(new HttpHeaderEntry(Http::HdrType::IF_NONE_MATCH, NULL,
                                               request->etag.termedBuf()));
     }
 
     bool we_do_ranges = decideIfWeDoRanges (request);
 
-    String strConnection (hdr_in->getList(HDR_CONNECTION));
+    String strConnection (hdr_in->getList(Http::HdrType::CONNECTION));
 
     while ((e = hdr_in->getEntry(&pos)))
         copyOneHeaderFromClientsideRequestToUpstreamRequest(e, strConnection, request, hdr_out, we_do_ranges, flags);
@@ -1797,31 +1797,31 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     /* append Via */
     if (Config.onoff.via) {
         String strVia;
-        strVia = hdr_in->getList(HDR_VIA);
+        strVia = hdr_in->getList(Http::HdrType::VIA);
         snprintf(bbuf, BBUF_SZ, "%d.%d %s",
                  request->http_ver.major,
                  request->http_ver.minor, ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        hdr_out->putStr(HDR_VIA, strVia.termedBuf());
+        hdr_out->putStr(Http::HdrType::VIA, strVia.termedBuf());
         strVia.clean();
     }
 
     if (request->flags.accelerated) {
         /* Append Surrogate-Capabilities */
-        String strSurrogate(hdr_in->getList(HDR_SURROGATE_CAPABILITY));
+        String strSurrogate(hdr_in->getList(Http::HdrType::SURROGATE_CAPABILITY));
 #if USE_SQUID_ESI
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0 ESI/1.0\"", Config.Accel.surrogate_id);
 #else
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0\"", Config.Accel.surrogate_id);
 #endif
         strListAdd(&strSurrogate, bbuf, ',');
-        hdr_out->putStr(HDR_SURROGATE_CAPABILITY, strSurrogate.termedBuf());
+        hdr_out->putStr(Http::HdrType::SURROGATE_CAPABILITY, strSurrogate.termedBuf());
     }
 
     /** \pre Handle X-Forwarded-For */
     if (strcmp(opt_forwarded_for, "delete") != 0) {
 
-        String strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
+        String strFwd = hdr_in->getList(Http::HdrType::X_FORWARDED_FOR);
 
         if (strFwd.size() > 65536/2) {
             // There is probably a forwarding loop with Via detection disabled.
@@ -1855,22 +1855,22 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
                 strFwd = request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN);
         }
         if (strFwd.size() > 0)
-            hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.termedBuf());
+            hdr_out->putStr(Http::HdrType::X_FORWARDED_FOR, strFwd.termedBuf());
     }
     /** If set to DELETE - do not copy through. */
 
     /* append Host if not there already */
-    if (!hdr_out->has(HDR_HOST)) {
+    if (!hdr_out->has(Http::HdrType::HOST)) {
         if (request->peer_domain) {
-            hdr_out->putStr(HDR_HOST, request->peer_domain);
+            hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);
         } else {
             SBuf authority = request->url.authority();
-            hdr_out->putStr(HDR_HOST, authority.c_str());
+            hdr_out->putStr(Http::HdrType::HOST, authority.c_str());
         }
     }
 
     /* append Authorization if known in URL, not in header and going direct */
-    if (!hdr_out->has(HDR_AUTHORIZATION)) {
+    if (!hdr_out->has(Http::HdrType::AUTHORIZATION)) {
         if (!request->flags.proxying && !request->url.userInfo().isEmpty()) {
             static uint8_t result[base64_encode_len(MAX_URL*2)]; // should be big enough for a single URI segment
             struct base64_encode_ctx ctx;
@@ -1879,7 +1879,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
             blen += base64_encode_final(&ctx, result+blen);
             result[blen] = '\0';
             if (blen)
-                httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %.*s", (int)blen, result);
+                httpHeaderPutStrf(hdr_out, Http::HdrType::AUTHORIZATION, "Basic %.*s", (int)blen, result);
         }
     }
 
@@ -1917,19 +1917,19 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* maybe append Connection: keep-alive */
     if (flags.keepalive) {
-        hdr_out->putStr(HDR_CONNECTION, "keep-alive");
+        hdr_out->putStr(Http::HdrType::CONNECTION, "keep-alive");
     }
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
         if (flags.front_end_https == 1 || request->url.getScheme() == AnyP::PROTO_HTTPS)
-            hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
+            hdr_out->putStr(Http::HdrType::FRONT_END_HTTPS, "On");
     }
 
     if (flags.chunked_request) {
         // Do not just copy the original value so that if the client-side
         // starts decode other encodings, this code may remain valid.
-        hdr_out->putStr(HDR_TRANSFER_ENCODING, "chunked");
+        hdr_out->putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     /* Now mangle the headers. */
@@ -1955,7 +1955,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
     /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid should not pass on. */
 
-    case HDR_PROXY_AUTHORIZATION:
+    case Http::HdrType::PROXY_AUTHORIZATION:
         /** \par Proxy-Authorization:
          * Only pass on proxy authentication to peers for which
          * authentication forwarding is explicitly enabled
@@ -1970,18 +1970,18 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
     /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid does not pass on. */
 
-    case HDR_CONNECTION:          /** \par Connection: */
-    case HDR_TE:                  /** \par TE: */
-    case HDR_KEEP_ALIVE:          /** \par Keep-Alive: */
-    case HDR_PROXY_AUTHENTICATE:  /** \par Proxy-Authenticate: */
-    case HDR_TRAILER:             /** \par Trailer: */
-    case HDR_UPGRADE:             /** \par Upgrade: */
-    case HDR_TRANSFER_ENCODING:   /** \par Transfer-Encoding: */
+    case Http::HdrType::CONNECTION:          /** \par Connection: */
+    case Http::HdrType::TE:                  /** \par TE: */
+    case Http::HdrType::KEEP_ALIVE:          /** \par Keep-Alive: */
+    case Http::HdrType::PROXY_AUTHENTICATE:  /** \par Proxy-Authenticate: */
+    case Http::HdrType::TRAILER:             /** \par Trailer: */
+    case Http::HdrType::UPGRADE:             /** \par Upgrade: */
+    case Http::HdrType::TRANSFER_ENCODING:   /** \par Transfer-Encoding: */
         break;
 
     /** \par OTHER headers I haven't bothered to track down yet. */
 
-    case HDR_AUTHORIZATION:
+    case Http::HdrType::AUTHORIZATION:
         /** \par WWW-Authorization:
          * Pass on WWW authentication */
 
@@ -2001,25 +2001,25 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
         break;
 
-    case HDR_HOST:
+    case Http::HdrType::HOST:
         /** \par Host:
          * Normally Squid rewrites the Host: header.
          * However, there is one case when we don't: If the URL
          * went through our redirector and the admin configured
          * 'redir_rewrites_host' to be off.
          */
         if (request->peer_domain)
-            hdr_out->putStr(HDR_HOST, request->peer_domain);
+            hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);
         else if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
             hdr_out->addEntry(e->clone());
         else {
             SBuf authority = request->url.authority();
-            hdr_out->putStr(HDR_HOST, authority.c_str());
+            hdr_out->putStr(Http::HdrType::HOST, authority.c_str());
         }
 
         break;
 
-    case HDR_IF_MODIFIED_SINCE:
+    case Http::HdrType::IF_MODIFIED_SINCE:
         /** \par If-Modified-Since:
          * append unless we added our own,
          * but only if cache_miss_revalidate is enabled, or
@@ -2028,13 +2028,13 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          * \note at most one client's If-Modified-Since header can pass through
          */
         // XXX: need to check and cleanup the auth case so cacheable auth requests get cached.
-        if (hdr_out->has(HDR_IF_MODIFIED_SINCE))
+        if (hdr_out->has(Http::HdrType::IF_MODIFIED_SINCE))
             break;
         else if (Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_IF_NONE_MATCH:
+    case Http::HdrType::IF_NONE_MATCH:
         /** \par If-None-Match:
          * append if the wildcard '*' special case value is present, or
          *   cache_miss_revalidate is disabled, or
@@ -2043,23 +2043,23 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          * \note this header lists a set of responses for the server to elide sending. Squid added values are extending that set.
          */
         // XXX: need to check and cleanup the auth case so cacheable auth requests get cached.
-        if (hdr_out->hasListMember(HDR_IF_MATCH, "*", ',') || Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
+        if (hdr_out->hasListMember(Http::HdrType::IF_MATCH, "*", ',') || Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_MAX_FORWARDS:
+    case Http::HdrType::MAX_FORWARDS:
         /** \par Max-Forwards:
          * pass only on TRACE or OPTIONS requests */
         if (request->method == Http::METHOD_TRACE || request->method == Http::METHOD_OPTIONS) {
             const int64_t hops = e->getInt64();
 
             if (hops > 0)
-                hdr_out->putInt64(HDR_MAX_FORWARDS, hops - 1);
+                hdr_out->putInt64(Http::HdrType::MAX_FORWARDS, hops - 1);
         }
 
         break;
 
-    case HDR_VIA:
+    case Http::HdrType::VIA:
         /** \par Via:
          * If Via is disabled then forward any received header as-is.
          * Otherwise leave for explicit updated addition later. */
@@ -2069,37 +2069,37 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
         break;
 
-    case HDR_RANGE:
+    case Http::HdrType::RANGE:
 
-    case HDR_IF_RANGE:
+    case Http::HdrType::IF_RANGE:
 
-    case HDR_REQUEST_RANGE:
+    case Http::HdrType::REQUEST_RANGE:
         /** \par Range:, If-Range:, Request-Range:
          * Only pass if we accept ranges */
         if (!we_do_ranges)
             hdr_out->addEntry(e->clone());
 
         break;
 
-    case HDR_PROXY_CONNECTION: // SHOULD ignore. But doing so breaks things.
+    case Http::HdrType::PROXY_CONNECTION: // SHOULD ignore. But doing so breaks things.
         break;
 
-    case HDR_CONTENT_LENGTH:
+    case Http::HdrType::CONTENT_LENGTH:
         // pass through unless we chunk; also, keeping this away from default
         // prevents request smuggling via Connection: Content-Length tricks
         if (!flags.chunked_request)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_X_FORWARDED_FOR:
+    case Http::HdrType::X_FORWARDED_FOR:
 
-    case HDR_CACHE_CONTROL:
+    case Http::HdrType::CACHE_CONTROL:
         /** \par X-Forwarded-For:, Cache-Control:
          * handled specially by Squid, so leave off for now.
          * append these after the loop if needed */
         break;
 
-    case HDR_FRONT_END_HTTPS:
+    case Http::HdrType::FRONT_END_HTTPS:
         /** \par Front-End-Https:
          * Pass thru only if peer is configured with front-end-https */
         if (!flags.front_end_https)
@@ -2175,7 +2175,7 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
 
         if (request->flags.pinned && request->flags.connectionAuth)
             request->flags.authSent = true;
-        else if (hdr.has(HDR_AUTHORIZATION))
+        else if (hdr.has(Http::HdrType::AUTHORIZATION))
             request->flags.authSent = true;
 
         hdr.packInto(mb);
@@ -9,105 +9,122 @@
 #include "squid.h"
 #include "RegisteredHeaders.h"
 
+#include <ostream>
+
 /*
  * A table with major attributes for every known field.
  *
  * Invariant on this table:
  * for each index in headerTable, (int)headerTable[index] = index
  */
 const HeaderTableRecord headerTable[] = {
-    {"Accept", HDR_ACCEPT, field_type::ftStr},
-    {"Accept-Charset", HDR_ACCEPT_CHARSET, field_type::ftStr},
-    {"Accept-Encoding", HDR_ACCEPT_ENCODING, field_type::ftStr},
-    {"Accept-Language", HDR_ACCEPT_LANGUAGE, field_type::ftStr},
-    {"Accept-Ranges", HDR_ACCEPT_RANGES, field_type::ftStr},
-    {"Age", HDR_AGE, field_type::ftInt},
-    {"Allow", HDR_ALLOW, field_type::ftStr},
-    {"Alternate-Protocol", HDR_ALTERNATE_PROTOCOL, field_type::ftStr},
-    {"Authentication-Info", HDR_AUTHENTICATION_INFO, field_type::ftStr},
-    {"Authorization", HDR_AUTHORIZATION, field_type::ftStr},    /* for now */
-    {"Cache-Control", HDR_CACHE_CONTROL, field_type::ftPCc},
-    {"Connection", HDR_CONNECTION, field_type::ftStr},
-    {"Content-Base", HDR_CONTENT_BASE, field_type::ftStr},
-    {"Content-Disposition", HDR_CONTENT_DISPOSITION, field_type::ftStr},  /* for now */
-    {"Content-Encoding", HDR_CONTENT_ENCODING, field_type::ftStr},
-    {"Content-Language", HDR_CONTENT_LANGUAGE, field_type::ftStr},
-    {"Content-Length", HDR_CONTENT_LENGTH, field_type::ftInt64},
-    {"Content-Location", HDR_CONTENT_LOCATION, field_type::ftStr},
-    {"Content-MD5", HDR_CONTENT_MD5, field_type::ftStr},    /* for now */
-    {"Content-Range", HDR_CONTENT_RANGE, field_type::ftPContRange},
-    {"Content-Type", HDR_CONTENT_TYPE, field_type::ftStr},
-    {"Cookie", HDR_COOKIE, field_type::ftStr},
-    {"Cookie2", HDR_COOKIE2, field_type::ftStr},
-    {"Date", HDR_DATE, field_type::ftDate_1123},
-    {"ETag", HDR_ETAG, field_type::ftETag},
-    {"Expect", HDR_EXPECT, field_type::ftStr},
-    {"Expires", HDR_EXPIRES, field_type::ftDate_1123},
-    {"Forwarded", HDR_FORWARDED, field_type::ftStr},
-    {"From", HDR_FROM, field_type::ftStr},
-    {"Host", HDR_HOST, field_type::ftStr},
-    {"HTTP2-Settings", HDR_HTTP2_SETTINGS, field_type::ftStr}, /* for now */
-    {"If-Match", HDR_IF_MATCH, field_type::ftStr},  /* for now */
-    {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, field_type::ftDate_1123},
-    {"If-None-Match", HDR_IF_NONE_MATCH, field_type::ftStr},    /* for now */
-    {"If-Range", HDR_IF_RANGE, field_type::ftDate_1123_or_ETag},
-    {"If-Unmodified-Since", HDR_IF_UNMODIFIED_SINCE, field_type::ftDate_1123},
-    {"Keep-Alive", HDR_KEEP_ALIVE, field_type::ftStr},
-    {"Key", HDR_KEY, field_type::ftStr},
-    {"Last-Modified", HDR_LAST_MODIFIED, field_type::ftDate_1123},
-    {"Link", HDR_LINK, field_type::ftStr},
-    {"Location", HDR_LOCATION, field_type::ftStr},
-    {"Max-Forwards", HDR_MAX_FORWARDS, field_type::ftInt64},
-    {"Mime-Version", HDR_MIME_VERSION, field_type::ftStr},  /* for now */
-    {"Negotiate", HDR_NEGOTIATE, field_type::ftStr},
-    {"Origin", HDR_ORIGIN, field_type::ftStr},
-    {"Pragma", HDR_PRAGMA, field_type::ftStr},
-    {"Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, field_type::ftStr},
-    {"Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, field_type::ftStr},
-    {"Proxy-Authorization", HDR_PROXY_AUTHORIZATION, field_type::ftStr},
-    {"Proxy-Connection", HDR_PROXY_CONNECTION, field_type::ftStr},
-    {"Proxy-support", HDR_PROXY_SUPPORT, field_type::ftStr},
-    {"Public", HDR_PUBLIC, field_type::ftStr},
-    {"Range", HDR_RANGE, field_type::ftPRange},
-    {"Referer", HDR_REFERER, field_type::ftStr},
-    {"Request-Range", HDR_REQUEST_RANGE, field_type::ftPRange}, /* usually matches HDR_RANGE */
-    {"Retry-Afield_type::fter", HDR_RETRY_AFTER, field_type::ftStr},    /* for now (field_type::ftDate_1123 or field_type::ftInt!} */
-    {"Server", HDR_SERVER, field_type::ftStr},
-    {"Set-Cookie", HDR_SET_COOKIE, field_type::ftStr},
-    {"Set-Cookie2", HDR_SET_COOKIE2, field_type::ftStr},
-    {"TE", HDR_TE, field_type::ftStr},
-    {"Title", HDR_TITLE, field_type::ftStr},
-    {"Trailer", HDR_TRAILER, field_type::ftStr},
-    {"Transfer-Encoding", HDR_TRANSFER_ENCODING, field_type::ftStr},
-    {"Translate", HDR_TRANSLATE, field_type::ftStr},    /* for now. may need to crop */
-    {"Unless-Modified-Since", HDR_UNLESS_MODIFIED_SINCE, field_type::ftStr},  /* for now ignore. may need to crop */
-    {"Upgrade", HDR_UPGRADE, field_type::ftStr},    /* for now */
-    {"User-Agent", HDR_USER_AGENT, field_type::ftStr},
-    {"Vary", HDR_VARY, field_type::ftStr},  /* for now */
-    {"Via", HDR_VIA, field_type::ftStr},    /* for now */
-    {"Warning", HDR_WARNING, field_type::ftStr},    /* for now */
-    {"WWW-Authenticate", HDR_WWW_AUTHENTICATE, field_type::ftStr},
-    {"X-Cache", HDR_X_CACHE, field_type::ftStr},
-    {"X-Cache-Lookup", HDR_X_CACHE_LOOKUP, field_type::ftStr},
-    {"X-Forwarded-For", HDR_X_FORWARDED_FOR, field_type::ftStr},
-    {"X-Request-URI", HDR_X_REQUEST_URI, field_type::ftStr},
-    {"X-Squid-Error", HDR_X_SQUID_ERROR, field_type::ftStr},
+    {"Accept", Http::HdrType::ACCEPT, field_type::ftStr},
+    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, field_type::ftStr},
+    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, field_type::ftStr},
+    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, field_type::ftStr},
+    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, field_type::ftStr},
+    {"Age", Http::HdrType::AGE, field_type::ftInt},
+    {"Allow", Http::HdrType::ALLOW, field_type::ftStr},
+    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, field_type::ftStr},
+    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, field_type::ftStr},
+    {"Authorization", Http::HdrType::AUTHORIZATION, field_type::ftStr},    /* for now */
+    {"Cache-Control", Http::HdrType::CACHE_CONTROL, field_type::ftPCc},
+    {"Connection", Http::HdrType::CONNECTION, field_type::ftStr},
+    {"Content-Base", Http::HdrType::CONTENT_BASE, field_type::ftStr},
+    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, field_type::ftStr},  /* for now */
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, field_type::ftStr},
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, field_type::ftStr},
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, field_type::ftInt64},
+    {"Content-Location", Http::HdrType::CONTENT_LOCATION, field_type::ftStr},
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, field_type::ftStr},    /* for now */
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, field_type::ftPContRange},
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, field_type::ftStr},
+    {"Cookie", Http::HdrType::COOKIE, field_type::ftStr},
+    {"Cookie2", Http::HdrType::COOKIE2, field_type::ftStr},
+    {"Date", Http::HdrType::DATE, field_type::ftDate_1123},
+    {"ETag", Http::HdrType::ETAG, field_type::ftETag},
+    {"Expect", Http::HdrType::EXPECT, field_type::ftStr},
+    {"Expires", Http::HdrType::EXPIRES, field_type::ftDate_1123},
+    {"Forwarded", Http::HdrType::FORWARDED, field_type::ftStr},
+    {"From", Http::HdrType::FROM, field_type::ftStr},
+    {"Host", Http::HdrType::HOST, field_type::ftStr},
+    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, field_type::ftStr}, /* for now */
+    {"If-Match", Http::HdrType::IF_MATCH, field_type::ftStr},  /* for now */
+    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, field_type::ftDate_1123},
+    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, field_type::ftStr},    /* for now */
+    {"If-Range", Http::HdrType::IF_RANGE, field_type::ftDate_1123_or_ETag},
+    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, field_type::ftDate_1123},
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, field_type::ftStr},
+    {"Key", Http::HdrType::KEY, field_type::ftStr},
+    {"Last-Modified", Http::HdrType::LAST_MODIFIED, field_type::ftDate_1123},
+    {"Link", Http::HdrType::LINK, field_type::ftStr},
+    {"Location", Http::HdrType::LOCATION, field_type::ftStr},
+    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, field_type::ftInt64},
+    {"Mime-Version", Http::HdrType::MIME_VERSION, field_type::ftStr},  /* for now */
+    {"Negotiate", Http::HdrType::NEGOTIATE, field_type::ftStr},
+    {"Origin", Http::HdrType::ORIGIN, field_type::ftStr},
+    {"Pragma", Http::HdrType::PRAGMA, field_type::ftStr},
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, field_type::ftStr},
+    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, field_type::ftStr},
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, field_type::ftStr},
+    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, field_type::ftStr},
+    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, field_type::ftStr},
+    {"Public", Http::HdrType::PUBLIC, field_type::ftStr},
+    {"Range", Http::HdrType::RANGE, field_type::ftPRange},
+    {"Referer", Http::HdrType::REFERER, field_type::ftStr},
+    {"Request-Range", Http::HdrType::REQUEST_RANGE, field_type::ftPRange}, /* usually matches Http::HdrType::RANGE */
+    {"Retry-Afield_type::fter", Http::HdrType::RETRY_AFTER, field_type::ftStr},    /* for now (field_type::ftDate_1123 or field_type::ftInt!} */
+    {"Server", Http::HdrType::SERVER, field_type::ftStr},
+    {"Set-Cookie", Http::HdrType::SET_COOKIE, field_type::ftStr},
+    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, field_type::ftStr},
+    {"TE", Http::HdrType::TE, field_type::ftStr},
+    {"Title", Http::HdrType::TITLE, field_type::ftStr},
+    {"Trailer", Http::HdrType::TRAILER, field_type::ftStr},
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, field_type::ftStr},
+    {"Translate", Http::HdrType::TRANSLATE, field_type::ftStr},    /* for now. may need to crop */
+    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, field_type::ftStr},  /* for now ignore. may need to crop */
+    {"Upgrade", Http::HdrType::UPGRADE, field_type::ftStr},    /* for now */
+    {"User-Agent", Http::HdrType::USER_AGENT, field_type::ftStr},
+    {"Vary", Http::HdrType::VARY, field_type::ftStr},  /* for now */
+    {"Via", Http::HdrType::VIA, field_type::ftStr},    /* for now */
+    {"Warning", Http::HdrType::WARNING, field_type::ftStr},    /* for now */
+    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, field_type::ftStr},
+    {"X-Cache", Http::HdrType::X_CACHE, field_type::ftStr},
+    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, field_type::ftStr},
+    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, field_type::ftStr},
+    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, field_type::ftStr},
+    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, field_type::ftStr},
 #if X_ACCELERATOR_VARY
-    {"X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, field_type::ftStr},
+    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, field_type::ftStr},
 #endif
 #if USE_ADAPTATION
-    {"X-Next-Services", HDR_X_NEXT_SERVICES, field_type::ftStr},
+    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, field_type::ftStr},
 #endif
-    {"Surrogate-Capability", HDR_SURROGATE_CAPABILITY, field_type::ftStr},
-    {"Surrogate-Control", HDR_SURROGATE_CONTROL, field_type::ftPSc},
-    {"Front-End-Https", HDR_FRONT_END_HTTPS, field_type::ftStr},
-    {"FTP-Command", HDR_FTP_COMMAND, field_type::ftStr},
-    {"FTP-Arguments", HDR_FTP_ARGUMENTS, field_type::ftStr},
-    {"FTP-Pre", HDR_FTP_PRE, field_type::ftStr},
-    {"FTP-Status", HDR_FTP_STATUS, field_type::ftInt},
-    {"FTP-Reason", HDR_FTP_REASON, field_type::ftStr},
-    {"Other:", HDR_OTHER, field_type::ftStr},    /* ':' will not allow matches */
-    {nullptr, HDR_BAD_HDR, field_type::ftInvalid}    /* end of table */
+    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, field_type::ftStr},
+    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, field_type::ftPSc},
+    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, field_type::ftStr},
+    {"FTP-Command", Http::HdrType::FTP_COMMAND, field_type::ftStr},
+    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, field_type::ftStr},
+    {"FTP-Pre", Http::HdrType::FTP_PRE, field_type::ftStr},
+    {"FTP-Status", Http::HdrType::FTP_STATUS, field_type::ftInt},
+    {"FTP-Reason", Http::HdrType::FTP_REASON, field_type::ftStr},
+    {"Other:", Http::HdrType::OTHER, field_type::ftStr},    /* ':' will not allow matches */
+    {nullptr, Http::HdrType::ENUM_END, field_type::ftInvalid},    /* end of table */
+    {nullptr, Http::HdrType::BAD_HDR, field_type::ftInvalid}
 };
 
-const LookupTable<http_hdr_type, HeaderTableRecord> HeaderLookupTable(HDR_BAD_HDR, headerTable);
+const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable(Http::HdrType::BAD_HDR, headerTable);
+
+extern std::ostream &
+operator << (std::ostream &s , Http::HdrType id)
+{
+    // id is guaranteed to be valid by strong type-safety
+    s << HeaderById(id).name << '(' << static_cast<int>(id) << ')';
+    return s;
+}
+
+const HeaderTableRecord&
+HeaderById(Http::HdrType id)
+{
+    return headerTable[static_cast<int>(id)];
+}
@@ -10,120 +10,125 @@
 #define SQUID_HTTP_REGISTEREDHEADERS_H
 
 #include "base/LookupTable.h"
+#include <iosfwd>
 
+namespace Http
+{
 /// recognized or "known" header fields; and the RFC which defines them (or not)
 /// http://www.iana.org/assignments/message-headers/message-headers.xhtml
-typedef enum {
-    HDR_ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
-    HDR_ACCEPT_CHARSET,                 /**< RFC 7231 */
-    HDR_ACCEPT_ENCODING,                /**< RFC 7231 */
-    /*HDR_ACCEPT_FEATURES,*/            /* RFC 2295 */
-    HDR_ACCEPT_LANGUAGE,                /**< RFC 7231 */
-    HDR_ACCEPT_RANGES,                  /**< RFC 7233 */
-    HDR_AGE,                            /**< RFC 7234 */
-    HDR_ALLOW,                          /**< RFC 7231 */
-    HDR_ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
-    HDR_AUTHENTICATION_INFO,            /**< RFC 2617 */
-    HDR_AUTHORIZATION,                  /**< RFC 7235, 4559 */
-    HDR_CACHE_CONTROL,                  /**< RFC 7234 */
-    HDR_CONNECTION,                     /**< RFC 7230 */
-    HDR_CONTENT_BASE,                   /**< obsoleted RFC 2068 */
-    HDR_CONTENT_DISPOSITION,            /**< RFC 2183, 6266 */
-    HDR_CONTENT_ENCODING,               /**< RFC 7231 */
-    HDR_CONTENT_LANGUAGE,               /**< RFC 7231 */
-    HDR_CONTENT_LENGTH,                 /**< RFC 7230 */
-    HDR_CONTENT_LOCATION,               /**< RFC 7231 */
-    HDR_CONTENT_MD5,                    /**< deprecated, RFC 2616 */
-    HDR_CONTENT_RANGE,                  /**< RFC 7233 */
-    HDR_CONTENT_TYPE,                   /**< RFC 7231 */
-    HDR_COOKIE,                         /**< RFC 6265 header we may need to erase */
-    HDR_COOKIE2,                        /**< obsolete RFC 2965 header we may need to erase */
-    HDR_DATE,                           /**< RFC 7231 */
-    /*HDR_DAV,*/                        /* RFC 2518 */
-    /*HDR_DEPTH,*/                      /* RFC 2518 */
-    /*HDR_DERIVED_FROM,*/               /* deprecated RFC 2068 */
-    /*HDR_DESTINATION,*/                /* RFC 2518 */
-    HDR_ETAG,                           /**< RFC 7232 */
-    HDR_EXPECT,                         /**< RFC 7231 */
-    HDR_EXPIRES,                        /**< RFC 7234 */
-    HDR_FORWARDED,                      /**< RFC 7239 */
-    HDR_FROM,                           /**< RFC 7231 */
-    HDR_HOST,                           /**< RFC 7230 */
-    HDR_HTTP2_SETTINGS,                 /**< RFC 7540 */
-    /*HDR_IF,*/                         /* RFC 2518 */
-    HDR_IF_MATCH,                       /**< RFC 7232 */
-    HDR_IF_MODIFIED_SINCE,              /**< RFC 7232 */
-    HDR_IF_NONE_MATCH,                  /**< RFC 7232 */
-    HDR_IF_RANGE,                       /**< RFC 7233 */
-    HDR_IF_UNMODIFIED_SINCE,            /**< RFC 7232 */
-    HDR_KEEP_ALIVE,                     /**< obsoleted RFC 2068 header we may need to erase */
-    HDR_KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
-    HDR_LAST_MODIFIED,                  /**< RFC 7232 */
-    HDR_LINK,                           /**< RFC 5988 */
-    HDR_LOCATION,                       /**< RFC 7231 */
-    /*HDR_LOCK_TOKEN,*/                 /* RFC 2518 */
-    HDR_MAX_FORWARDS,                   /**< RFC 7231 */
-    HDR_MIME_VERSION,                   /**< RFC 2045, 7231 */
-    HDR_NEGOTIATE,                      /**< experimental RFC 2295. Why only this one from 2295? */
-    /*HDR_OVERWRITE,*/                  /* RFC 2518 */
-    HDR_ORIGIN,                         /* CORS Draft specification (see http://www.w3.org/TR/cors/) */
-    HDR_PRAGMA,                         /**< RFC 7234 */
-    HDR_PROXY_AUTHENTICATE,             /**< RFC 7235 */
-    HDR_PROXY_AUTHENTICATION_INFO,      /**< RFC 2617 */
-    HDR_PROXY_AUTHORIZATION,            /**< RFC 7235 */
-    HDR_PROXY_CONNECTION,               /**< obsolete Netscape header we may need to erase. */
-    HDR_PROXY_SUPPORT,                  /**< RFC 4559 */
-    HDR_PUBLIC,                         /**<  RFC 2068 */
-    HDR_RANGE,                          /**< RFC 7233 */
-    HDR_REFERER,                        /**< RFC 7231 */
-    HDR_REQUEST_RANGE,                  /**< some clients use this, sigh */
-    HDR_RETRY_AFTER,                    /**< RFC 7231 */
-    HDR_SERVER,                         /**< RFC 7231 */
-    HDR_SET_COOKIE,                     /**< RFC 6265 header we may need to erase */
-    HDR_SET_COOKIE2,                    /**< obsoleted RFC 2965 header we may need to erase */
-    /*HDR_STATUS_URI,*/                 /* RFC 2518 */
-    /*HDR_TCN,*/                        /* experimental RFC 2295 */
-    HDR_TE,                             /**< RFC 7230 */
-    /*HDR_TIMEOUT,*/                    /* RFC 2518 */
-    HDR_TITLE,                          /* obsolete draft suggested header */
-    HDR_TRAILER,                        /**< RFC 7230 */
-    HDR_TRANSFER_ENCODING,              /**< RFC 7230 */
-    HDR_TRANSLATE,                      /**< IIS custom header we may need to erase */
-    HDR_UNLESS_MODIFIED_SINCE,          /**< IIS custom header we may need to erase */
-    HDR_UPGRADE,                        /**< RFC 7230 */
-    HDR_USER_AGENT,                     /**< RFC 7231 */
-    /*HDR_VARIANT_VARY,*/               /* experimental RFC 2295 */
-    HDR_VARY,                           /**< RFC 7231 */
-    HDR_VIA,                            /**< RFC 7230 */
-    HDR_WARNING,                        /**< RFC 7234 */
-    HDR_WWW_AUTHENTICATE,               /**< RFC 7235, 4559 */
-    HDR_X_CACHE,                        /**< Squid custom header */
-    HDR_X_CACHE_LOOKUP,                 /**< Squid custom header. temporary hack that became de-facto. TODO remove */
-    HDR_X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
-    HDR_X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
-    HDR_X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
+enum HdrType {
+    ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
+    ACCEPT_CHARSET,                 /**< RFC 7231 */
+    ACCEPT_ENCODING,                /**< RFC 7231 */
+    /*ACCEPT_FEATURES,*/            /* RFC 2295 */
+    ACCEPT_LANGUAGE,                /**< RFC 7231 */
+    ACCEPT_RANGES,                  /**< RFC 7233 */
+    AGE,                            /**< RFC 7234 */
+    ALLOW,                          /**< RFC 7231 */
+    ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
+    AUTHENTICATION_INFO,            /**< RFC 2617 */
+    AUTHORIZATION,                  /**< RFC 7235, 4559 */
+    CACHE_CONTROL,                  /**< RFC 7234 */
+    CONNECTION,                     /**< RFC 7230 */
+    CONTENT_BASE,                   /**< obsoleted RFC 2068 */
+    CONTENT_DISPOSITION,            /**< RFC 2183, 6266 */
+    CONTENT_ENCODING,               /**< RFC 7231 */
+    CONTENT_LANGUAGE,               /**< RFC 7231 */
+    CONTENT_LENGTH,                 /**< RFC 7230 */
+    CONTENT_LOCATION,               /**< RFC 7231 */
+    CONTENT_MD5,                    /**< deprecated, RFC 2616 */
+    CONTENT_RANGE,                  /**< RFC 7233 */
+    CONTENT_TYPE,                   /**< RFC 7231 */
+    COOKIE,                         /**< RFC 6265 header we may need to erase */
+    COOKIE2,                        /**< obsolete RFC 2965 header we may need to erase */
+    DATE,                           /**< RFC 7231 */
+    /*DAV,*/                        /* RFC 2518 */
+    /*DEPTH,*/                      /* RFC 2518 */
+    /*DERIVED_FROM,*/               /* deprecated RFC 2068 */
+    /*DESTINATION,*/                /* RFC 2518 */
+    ETAG,                           /**< RFC 7232 */
+    EXPECT,                         /**< RFC 7231 */
+    EXPIRES,                        /**< RFC 7234 */
+    FORWARDED,                      /**< RFC 7239 */
+    FROM,                           /**< RFC 7231 */
+    HOST,                           /**< RFC 7230 */
+    HTTP2_SETTINGS,                 /**< RFC 7540 */
+    /*IF,*/                         /* RFC 2518 */
+    IF_MATCH,                       /**< RFC 7232 */
+    IF_MODIFIED_SINCE,              /**< RFC 7232 */
+    IF_NONE_MATCH,                  /**< RFC 7232 */
+    IF_RANGE,                       /**< RFC 7233 */
+    IF_UNMODIFIED_SINCE,            /**< RFC 7232 */
+    KEEP_ALIVE,                     /**< obsoleted RFC 2068 header we may need to erase */
+    KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
+    LAST_MODIFIED,                  /**< RFC 7232 */
+    LINK,                           /**< RFC 5988 */
+    LOCATION,                       /**< RFC 7231 */
+    /*LOCK_TOKEN,*/                 /* RFC 2518 */
+    MAX_FORWARDS,                   /**< RFC 7231 */
+    MIME_VERSION,                   /**< RFC 2045, 7231 */
+    NEGOTIATE,                      /**< experimental RFC 2295. Why only this one from 2295? */
+    /*OVERWRITE,*/                  /* RFC 2518 */
+    ORIGIN,                         /* CORS Draft specification (see http://www.w3.org/TR/cors/) */
+    PRAGMA,                         /**< RFC 7234 */
+    PROXY_AUTHENTICATE,             /**< RFC 7235 */
+    PROXY_AUTHENTICATION_INFO,      /**< RFC 2617 */
+    PROXY_AUTHORIZATION,            /**< RFC 7235 */
+    PROXY_CONNECTION,               /**< obsolete Netscape header we may need to erase. */
+    PROXY_SUPPORT,                  /**< RFC 4559 */
+    PUBLIC,                         /**<  RFC 2068 */
+    RANGE,                          /**< RFC 7233 */
+    REFERER,                        /**< RFC 7231 */
+    REQUEST_RANGE,                  /**< some clients use this, sigh */
+    RETRY_AFTER,                    /**< RFC 7231 */
+    SERVER,                         /**< RFC 7231 */
+    SET_COOKIE,                     /**< RFC 6265 header we may need to erase */
+    SET_COOKIE2,                    /**< obsoleted RFC 2965 header we may need to erase */
+    /*STATUS_URI,*/                 /* RFC 2518 */
+    /*TCN,*/                        /* experimental RFC 2295 */
+    TE,                             /**< RFC 7230 */
+    /*TIMEOUT,*/                    /* RFC 2518 */
+    TITLE,                          /* obsolete draft suggested header */
+    TRAILER,                        /**< RFC 7230 */
+    TRANSFER_ENCODING,              /**< RFC 7230 */
+    TRANSLATE,                      /**< IIS custom header we may need to erase */
+    UNLESS_MODIFIED_SINCE,          /**< IIS custom header we may need to erase */
+    UPGRADE,                        /**< RFC 7230 */
+    USER_AGENT,                     /**< RFC 7231 */
+    /*VARIANT_VARY,*/               /* experimental RFC 2295 */
+    VARY,                           /**< RFC 7231 */
+    VIA,                            /**< RFC 7230 */
+    WARNING,                        /**< RFC 7234 */
+    WWW_AUTHENTICATE,               /**< RFC 7235, 4559 */
+    X_CACHE,                        /**< Squid custom header */
+    X_CACHE_LOOKUP,                 /**< Squid custom header. temporary hack that became de-facto. TODO remove */
+    X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
+    X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
+    X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
 #if X_ACCELERATOR_VARY
     HDR_X_ACCELERATOR_VARY,             /**< obsolete Squid custom header. */
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,                /**< Squid custom ICAP header */
+    X_NEXT_SERVICES,                /**< Squid custom ICAP header */
 #endif
-    HDR_SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
-    HDR_SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
-    HDR_FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
-    HDR_FTP_COMMAND,                    /**< Internal header for FTP command */
-    HDR_FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
-    HDR_FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
-    HDR_FTP_STATUS,                     /**< Internal header for FTP reply status */
-    HDR_FTP_REASON,                     /**< Internal header for FTP reply reason */
-    HDR_OTHER,                          /**< internal tag value for "unknown" headers */
-    HDR_ENUM_END,                       /**< internal tag for end-of-valid headers */
-    HDR_BAD_HDR                         /**< Invalid header. Must be after HDR_ENUM_END */
-} http_hdr_type;
+    SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
+    SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
+    FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
+    FTP_COMMAND,                    /**< Internal header for FTP command */
+    FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
+    FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
+    FTP_STATUS,                     /**< Internal header for FTP reply status */
+    FTP_REASON,                     /**< Internal header for FTP reply reason */
+    OTHER,                          /**< internal tag value for "unknown" headers */
+    ENUM_END,                       /**< internal tag for end-of-valid headers */
+    BAD_HDR                         /**< Invalid header. Must be after ENUM_END */
+};
+
+}; /* namespace Http */
 
 /** possible types for http header fields */
 enum class field_type {
-    ftInvalid,// = HDR_ENUM_END,   /**< to catch nasty errors with hdr_id<->fld_type clashes */
+    ftInvalid,// = ENUM_END,   /**< to catch nasty errors with hdr_id<->fld_type clashes */
     ftInt,
     ftInt64,
     ftStr,
@@ -140,15 +145,21 @@ enum class field_type {
 class HeaderTableRecord {
 public:
     const char *name;
-    http_hdr_type id;
+    Http::HdrType id;
     field_type type;
 };
 
 /// header ID->namelookup table.
 extern const HeaderTableRecord headerTable[];
 
 /// for header name->id lookup, use HeaderLookupTable.lookup(hdr-as-sbuf);
-extern const LookupTable<http_hdr_type, HeaderTableRecord> HeaderLookupTable;
+extern const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable;
+
+const HeaderTableRecord&
+HeaderById(Http::HdrType id);
+
+std::ostream &
+operator << (std::ostream &, Http::HdrType);
 
 #endif /* SQUID_HTTP_REGISTEREDHEADERS_H */
 
@@ -32,8 +32,8 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
         if (al->request->auth_user_request != NULL)
             user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
 #endif
-        referer = al->request->header.getStr(HDR_REFERER);
-        agent = al->request->header.getStr(HDR_USER_AGENT);
+        referer = al->request->header.getStr(Http::HdrType::REFERER);
+        agent = al->request->header.getStr(Http::HdrType::USER_AGENT);
     }
 
     if (!referer || *referer == '\0')
@@ -20,7 +20,7 @@ Log::Format::SquidReferer(const AccessLogEntry::Pointer &al, Logfile *logfile)
 {
     const char *referer = NULL;
     if (al->request)
-        referer = al->request->header.getStr(HDR_REFERER);
+        referer = al->request->header.getStr(Http::HdrType::REFERER);
 
     if (!referer || *referer == '\0')
         referer = "-";
@@ -21,7 +21,7 @@ Log::Format::SquidUserAgent(const AccessLogEntry::Pointer &al, Logfile * logfile
     const char *agent = NULL;
 
     if (al->request)
-        agent = al->request->header.getStr(HDR_USER_AGENT);
+        agent = al->request->header.getStr(Http::HdrType::USER_AGENT);
 
     if (!agent || *agent == '\0')
         agent = "-";
@@ -83,7 +83,7 @@ Mgr::Inquirer::start()
     } else {
         std::unique_ptr<HttpReply> reply(new HttpReply);
         reply->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
-        reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
+        reply->header.putStr(Http::HdrType::CONNECTION, "close"); // until we chunk response
         replyBuf.reset(reply->pack());
     }
     writer = asyncCall(16, 5, "Mgr::Inquirer::noteWroteHeader",
@@ -343,9 +343,9 @@ peerDigestRequest(PeerDigest * pd)
     /* add custom headers */
     assert(!req->header.len);
 
-    req->header.putStr(HDR_ACCEPT, StoreDigestMimeStr);
+    req->header.putStr(Http::HdrType::ACCEPT, StoreDigestMimeStr);
 
-    req->header.putStr(HDR_ACCEPT, "text/html");
+    req->header.putStr(Http::HdrType::ACCEPT, "text/html");
 
     if (p->login &&
             p->login[0] != '*' &&
@@ -492,7 +492,7 @@ Ftp::Server::writeCustomReply(const int code, const char *msg, const HttpReply *
     assert(99 < code && code < 1000);
 
     const bool sendDetails = reply != NULL &&
-                             reply->header.has(HDR_FTP_STATUS) && reply->header.has(HDR_FTP_REASON);
+                             reply->header.has(Http::HdrType::FTP_STATUS) && reply->header.has(Http::HdrType::FTP_REASON);
 
     MemBuf mb;
     mb.init();
@@ -727,11 +727,11 @@ Ftp::Server::parseOneRequest()
     request->flags.cachable = false; // XXX: reset later by maybeCacheable()
     request->flags.noCache = true;
 
-    request->header.putStr(HDR_FTP_COMMAND, cmd.c_str());
-    request->header.putStr(HDR_FTP_ARGUMENTS, params.c_str()); // may be ""
+    request->header.putStr(Http::HdrType::FTP_COMMAND, cmd.c_str());
+    request->header.putStr(Http::HdrType::FTP_ARGUMENTS, params.c_str()); // may be ""
     if (method == Http::METHOD_PUT) {
-        request->header.putStr(HDR_EXPECT, "100-continue");
-        request->header.putStr(HDR_TRANSFER_ENCODING, "chunked");
+        request->header.putStr(Http::HdrType::EXPECT, "100-continue");
+        request->header.putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     ClientHttpRequest *const http = new ClientHttpRequest(this);
@@ -808,11 +808,11 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
     bool hasEPSV = false;
     int prependSpaces = 1;
 
-    featReply->header.putStr(HDR_FTP_PRE, "\"211-Features:\"");
-    const int scode = serverReplyHeader.getInt(HDR_FTP_STATUS);
+    featReply->header.putStr(Http::HdrType::FTP_PRE, "\"211-Features:\"");
+    const int scode = serverReplyHeader.getInt(Http::HdrType::FTP_STATUS);
     if (scode == 211) {
         while (const HttpHeaderEntry *e = serverReplyHeader.getEntry(&pos)) {
-            if (e->id == HDR_FTP_PRE) {
+            if (e->id == Http::HdrType::FTP_PRE) {
                 // assume RFC 2389 FEAT response format, quoted by Squid:
                 // <"> SP NAME [SP PARAMS] <">
                 // but accommodate MS servers sending four SPs before NAME
@@ -848,11 +848,11 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
     char buf[256];
     if (!hasEPRT) {
         snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPRT");
-        featReply->header.putStr(HDR_FTP_PRE, buf);
+        featReply->header.putStr(Http::HdrType::FTP_PRE, buf);
     }
     if (!hasEPSV) {
         snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPSV");
-        featReply->header.putStr(HDR_FTP_PRE, buf);
+        featReply->header.putStr(Http::HdrType::FTP_PRE, buf);
     }
 
     featReply->header.refreshMask();
@@ -1023,8 +1023,8 @@ Ftp::Server::writeForwardedReply(const HttpReply *reply)
 {
     assert(reply != NULL);
     const HttpHeader &header = reply->header;
-    // adaptation and forwarding errors lack HDR_FTP_STATUS
-    if (!header.has(HDR_FTP_STATUS)) {
+    // adaptation and forwarding errors lack Http::HdrType::FTP_STATUS
+    if (!header.has(Http::HdrType::FTP_STATUS)) {
         writeForwardedForeign(reply); // will get to Ftp::Server::wroteReply
         return;
     }
@@ -1103,8 +1103,8 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
 #endif
 
     assert(reply != NULL);
-    const char *reason = reply->header.has(HDR_FTP_REASON) ?
-                         reply->header.getStr(HDR_FTP_REASON):
+    const char *reason = reply->header.has(Http::HdrType::FTP_REASON) ?
+                         reply->header.getStr(Http::HdrType::FTP_REASON):
                          reply->sline.reason();
 
     mb.appendf("%i %s\r\n", scode, reason); // error terminating line
@@ -1131,7 +1131,7 @@ void
 Ftp::Server::writeControlMsgAndCall(ClientSocketContext *, HttpReply *reply, AsyncCall::Pointer &call)
 {
     // the caller guarantees that we are dealing with the current context only
-    // the caller should also make sure reply->header.has(HDR_FTP_STATUS)
+    // the caller should also make sure reply->header.has(Http::HdrType::FTP_STATUS)
     writeForwardedReplyAndCall(reply, call);
 }
 
@@ -1142,9 +1142,9 @@ Ftp::Server::writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Point
     const HttpHeader &header = reply->header;
 
     // without status, the caller must use the writeForwardedForeign() path
-    Must(header.has(HDR_FTP_STATUS));
-    Must(header.has(HDR_FTP_REASON));
-    const int scode = header.getInt(HDR_FTP_STATUS);
+    Must(header.has(Http::HdrType::FTP_STATUS));
+    Must(header.has(Http::HdrType::FTP_REASON));
+    const int scode = header.getInt(Http::HdrType::FTP_STATUS);
     debugs(33, 7, "scode: " << scode);
 
     // Status 125 or 150 implies upload or data request, but we still check
@@ -1194,16 +1194,16 @@ Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const)
 
     HttpHeaderPos pos = HttpHeaderInitPos;
     while (const HttpHeaderEntry *e = header.getEntry(&pos)) {
-        if (e->id == HDR_FTP_PRE) {
+        if (e->id == Http::HdrType::FTP_PRE) {
             String raw;
             if (httpHeaderParseQuotedString(e->value.rawBuf(), e->value.size(), &raw))
                 mb.appendf("%s\r\n", raw.termedBuf());
         }
     }
 
-    if (header.has(HDR_FTP_STATUS)) {
-        const char *reason = header.getStr(HDR_FTP_REASON);
-        mb.appendf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
+    if (header.has(Http::HdrType::FTP_STATUS)) {
+        const char *reason = header.getStr(Http::HdrType::FTP_REASON);
+        mb.appendf("%i %s\r\n", header.getInt(Http::HdrType::FTP_STATUS),
                    (reason ? reason : 0));
     }
 }
@@ -1279,10 +1279,10 @@ Ftp::Server::handleRequest(HttpRequest *request)
     Must(request);
 
     HttpHeader &header = request->header;
-    Must(header.has(HDR_FTP_COMMAND));
-    String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
-    Must(header.has(HDR_FTP_ARGUMENTS));
-    String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+    Must(header.has(Http::HdrType::FTP_COMMAND));
+    String &cmd = header.findEntry(Http::HdrType::FTP_COMMAND)->value;
+    Must(header.has(Http::HdrType::FTP_ARGUMENTS));
+    String &params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)->value;
 
     if (do_debug(9, 2)) {
         MemBuf mb;
@@ -1596,10 +1596,10 @@ Ftp::Server::setDataCommand()
     HttpRequest *const request = http->request;
     assert(request != NULL);
     HttpHeader &header = request->header;
-    header.delById(HDR_FTP_COMMAND);
-    header.putStr(HDR_FTP_COMMAND, "PASV");
-    header.delById(HDR_FTP_ARGUMENTS);
-    header.putStr(HDR_FTP_ARGUMENTS, "");
+    header.delById(Http::HdrType::FTP_COMMAND);
+    header.putStr(Http::HdrType::FTP_COMMAND, "PASV");
+    header.delById(Http::HdrType::FTP_ARGUMENTS);
+    header.putStr(Http::HdrType::FTP_ARGUMENTS, "");
     debugs(9, 5, "client data command converted to fake PASV");
 }
 
@@ -193,8 +193,8 @@ Http::One::Server::processParsedRequest(ClientSocketContext *context)
     ClientHttpRequest *http = context->http;
     HttpRequest::Pointer request = http->request;
 
-    if (request->header.has(HDR_EXPECT)) {
-        const String expect = request->header.getList(HDR_EXPECT);
+    if (request->header.has(Http::HdrType::EXPECT)) {
+        const String expect = request->header.getList(Http::HdrType::EXPECT);
         const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
         if (!supportedExpect) {
             clientStreamNode *node = context->getClientReplyContext();
@@ -276,7 +276,7 @@ Http::One::Server::writeControlMsgAndCall(ClientSocketContext *context, HttpRepl
     // apply selected clientReplyContext::buildReplyHeader() mods
     // it is not clear what headers are required for control messages
     rep->header.removeHopByHopEntries();
-    rep->header.putStr(HDR_CONNECTION, "keep-alive");
+    rep->header.putStr(Http::HdrType::CONNECTION, "keep-alive");
     httpHdrMangleList(&rep->header, getCurrentContext()->http->request, ROR_REPLY);
 
     MemBuf *mb = rep->pack();
@@ -127,7 +127,7 @@ Ssl::ErrorDetailsManager::getErrorDetail(Ssl::ssl_error_t value, const HttpReque
 {
 #if USE_ERR_LOCALES
     String hdr;
-    if (request != NULL && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr)) {
+    if (request != NULL && request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr)) {
         ErrorDetailsList::Pointer errDetails = NULL;
         //Try to retrieve from cache
         size_t pos = 0;
@@ -721,20 +721,20 @@ StoreEntry::setPublicKey()
             /* We are allowed to do this typecast */
             HttpReply *rep = new HttpReply;
             rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
-            vary = mem_obj->getReply()->header.getList(HDR_VARY);
+            vary = mem_obj->getReply()->header.getList(Http::HdrType::VARY);
 
             if (vary.size()) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_VARY, vary.termedBuf());
+                rep->header.putStr(Http::HdrType::VARY, vary.termedBuf());
                 vary.clean();
             }
 
 #if X_ACCELERATOR_VARY
-            vary = mem_obj->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
+            vary = mem_obj->getReply()->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 
             if (vary.size() > 0) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.termedBuf());
+                rep->header.putStr(Http::HdrType::HDR_X_ACCELERATOR_VARY, vary.termedBuf());
                 vary.clean();
             }
 
@@ -1597,7 +1597,7 @@ StoreEntry::timestampsSet()
 {
     const HttpReply *reply = getReply();
     time_t served_date = reply->date;
-    int age = reply->header.getInt(HDR_AGE);
+    int age = reply->header.getInt(Http::HdrType::AGE);
     /* Compute the timestamp, mimicking RFC2616 section 13.2.3. */
     /* make sure that 0 <= served_date <= squid_curtime */
 
@@ -2049,7 +2049,7 @@ bool
 StoreEntry::hasEtag(ETag &etag) const
 {
     if (const HttpReply *reply = getReply()) {
-        etag = reply->header.getETag(HDR_ETAG);
+        etag = reply->header.getETag(Http::HdrType::ETAG);
         if (etag.str)
             return true;
     }
@@ -2059,14 +2059,14 @@ StoreEntry::hasEtag(ETag &etag) const
 bool
 StoreEntry::hasIfMatchEtag(const HttpRequest &request) const
 {
-    const String reqETags = request.header.getList(HDR_IF_MATCH);
+    const String reqETags = request.header.getList(Http::HdrType::IF_MATCH);
     return hasOneOfEtags(reqETags, false);
 }
 
 bool
 StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 {
-    const String reqETags = request.header.getList(HDR_IF_NONE_MATCH);
+    const String reqETags = request.header.getList(Http::HdrType::IF_NONE_MATCH);
     // weak comparison is allowed only for HEAD or full-body GET requests
     const bool allowWeakMatch = !request.flags.isRanged &&
                                 (request.method == Http::METHOD_GET || request.method == Http::METHOD_HEAD);
@@ -2077,7 +2077,7 @@ StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 bool
 StoreEntry::hasOneOfEtags(const String &reqETags, const bool allowWeakMatch) const
 {
-    const ETag repETag = getReply()->header.getETag(HDR_ETAG);
+    const ETag repETag = getReply()->header.getETag(Http::HdrType::ETAG);
     if (!repETag.str)
         return strListIsMember(&reqETags, "*", ',');
 
@@ -71,8 +71,8 @@ void Auth::UserRequest::addAuthenticationInfoHeader(HttpReply *, int) STUB
 void Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply *, int) STUB
 void Auth::UserRequest::releaseAuthServer() STUB
 const char * Auth::UserRequest::connLastHeader() STUB_RETVAL("stub")
-AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
-AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
+AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
+AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
 void Auth::UserRequest::addReplyAuthHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int) STUB
@@ -15,7 +15,7 @@
 
 /** \todo CLEANUP: This file should be called something_stub.cc */
 
-void httpHeaderPutStr(HttpHeader * hdr, http_hdr_type type, const char *str)
+void httpHeaderPutStr(HttpHeader * hdr, Http::HdrType type, const char *str)
 {
     fatal ("dummy function\n");
 }
@@ -26,13 +26,13 @@ HttpHeaderEntry *httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
     return NULL;
 }
 
-String httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
+String httpHeaderGetList(const HttpHeader * hdr, Http::HdrType id)
 {
     fatal ("dummy function\n");
     return String();
 }
 
-int httpHeaderHas(const HttpHeader * hdr, http_hdr_type type)
+int httpHeaderHas(const HttpHeader * hdr, Http::HdrType type)
 {
     fatal ("dummy function\n");
     return 0;
@@ -760,7 +760,7 @@ urlCheckRequest(const HttpRequest * r)
     // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)
     // we also support forwarding OPTIONS and TRACE, except for the *-URI ones
     if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)
-        return (r->header.getInt64(HDR_MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
+        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
 
     if (r->method == Http::METHOD_PURGE)
         return 1;
@@ -163,7 +163,7 @@ UrnState::setUriResFromRequest(HttpRequest *r)
         return;
     }
 
-    urlres_r->header.putStr(HDR_ACCEPT, "text/plain");
+    urlres_r->header.putStr(Http::HdrType::ACCEPT, "text/plain");
 }
 
 void
@@ -371,7 +371,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
     if (urnState->flags.force_menu) {
         debugs(51, 3, "urnHandleReply: forcing menu");
     } else if (min_u) {
-        rep->header.putStr(HDR_LOCATION, min_u->url);
+        rep->header.putStr(Http::HdrType::LOCATION, min_u->url);
     }
 
     rep->body.setMb(mb);