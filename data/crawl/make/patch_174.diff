diff --git a/ChangeLog b/ChangeLog
index 7396742..cf9bf61 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+2002-10-14  Paul D. Smith  <psmith@gnu.org>
+
+	* *.c: Convert to using ANSI C-style function definitions.
+	* Makefile.am: Enable the ansi2knr feature of automake.
+	* configure.in: ditto.
+
 2002-10-13  Paul D. Smith  <psmith@gnu.org>
 
 	* commands.c (set_file_variables): Bug #1379: Don't use alloca()
diff --git a/Makefile.am b/Makefile.am
index 33b498b..8856962 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,6 +1,6 @@
 # This is a -*-Makefile-*-, or close enough
 
-AUTOMAKE_OPTIONS = 1.7 dist-bzip2 check-news
+AUTOMAKE_OPTIONS = 1.7 dist-bzip2 check-news ansi2knr
 ACLOCAL_AMFLAGS	=  -I config
 
 SUBDIRS =	glob config po doc
@@ -121,7 +121,7 @@ check-loadavg: loadavg
 
 # The loadavg function is invoked during "make check" to test getloadavg.
 noinst_PROGRAMS = loadavg
-loadavg_SOURCES = loadavg.c
+nodist_loadavg_SOURCES = loadavg.c
 loadavg_CFLAGS = -DTEST
 loadavg_LDADD = @GETLOADAVG_LIBS@
 
diff --git a/alloca.c b/alloca.c
index 8f98b73..6e009b4 100644
--- a/alloca.c
+++ b/alloca.c
@@ -114,7 +114,7 @@ static int stack_dir;		/* 1 or -1 once known.  */
 #define	STACK_DIR	stack_dir
 
 static void
-find_stack_direction ()
+find_stack_direction (void)
 {
   static char *addr = NULL;	/* Address of first `dummy', once known.  */
   auto char dummy;		/* To get stack address.  */
@@ -168,8 +168,7 @@ static header *last_alloca_header = NULL;	/* -> last alloca header.  */
    implementations of C, for example under Gould's UTX/32.  */
 
 pointer
-alloca (size)
-     unsigned size;
+alloca (unsigned size)
 {
   auto char probe;		/* Probes stack depth: */
   register char *depth = ADDRESS_FUNCTION (probe);
diff --git a/amiga.c b/amiga.c
index db8ef0d..b6d1e92 100644
--- a/amiga.c
+++ b/amiga.c
@@ -30,8 +30,7 @@ static const char Amiga_version[] = "$VER: Make 3.74.3 (12.05.96) \n"
 		    "Amiga Port by A. Digulla (digulla@home.lake.de)";
 
 int
-MyExecute (argv)
-char ** argv;
+MyExecute (char **argv)
 {
     char * buffer, * ptr;
     char ** aptr;
@@ -92,8 +91,7 @@ char ** argv;
 }
 
 char *
-wildcard_expansion (wc, o)
-char * wc, * o;
+wildcard_expansion (char *wc, char *o)
 {
 #   define PATH_SIZE	1024
     struct AnchorPath * apath;
diff --git a/ar.c b/ar.c
index 286be55..3b9d3a7 100644
--- a/ar.c
+++ b/ar.c
@@ -39,8 +39,7 @@ extern int ar_member_touch PARAMS ((char *arname, char *memname));
    the attempt to use this unsupported feature.  */
 
 int
-ar_name (name)
-     char *name;
+ar_name (char *name)
 {
   char *p = strchr (name, '(');
   char *end;
@@ -64,8 +63,7 @@ ar_name (name)
    put the malloc'd member name in *MEMNAME_P if MEMNAME_P is non-nil.  */
 
 void
-ar_parse_name (name, arname_p, memname_p)
-     char *name, **arname_p, **memname_p;
+ar_parse_name (char *name, char **arname_p, char **memname_p)
 {
   char *p = strchr (name, '('), *end = name + strlen (name) - 1;
 
@@ -82,8 +80,7 @@ static long int ar_member_date_1 PARAMS ((int desc, char *mem, int truncated, lo
 /* Return the modtime of NAME.  */
 
 time_t
-ar_member_date (name)
-     char *name;
+ar_member_date (char *name)
 {
   char *arname;
   int arname_used = 0;
@@ -125,14 +122,9 @@ ar_member_date (name)
 
 /* ARGSUSED */
 static long int
-ar_member_date_1 (desc, mem, truncated,
-		  hdrpos, datapos, size, date, uid, gid, mode, name)
-     int desc;
-     char *mem;
-     int truncated;
-     long int hdrpos, datapos, size, date;
-     int uid, gid, mode;
-     char *name;
+ar_member_date_1 (int desc, char *mem, int truncated,
+		  long int hdrpos, long int datapos, long int size,
+                  long int date, int uid, int gid, int mode, char *name)
 {
   return ar_name_equal (name, mem, truncated) ? date : 0;
 }
@@ -141,16 +133,14 @@ ar_member_date_1 (desc, mem, truncated,
 
 #ifdef VMS
 int
-ar_touch (name)
-     char *name;
+ar_touch (char *name)
 {
   error (NILF, _("touch archive member is not available on VMS"));
   return -1;
 }
 #else
 int
-ar_touch (name)
-     char *name;
+ar_touch (char *name)
 {
   char *arname, *memname;
   int arname_used = 0;
@@ -219,15 +209,10 @@ struct ar_glob_state
    element against the pattern in STATE.  */
 
 static long int
-ar_glob_match (desc, mem, truncated,
-	       hdrpos, datapos, size, date, uid, gid, mode,
-	       state)
-     int desc;
-     char *mem;
-     int truncated;
-     long int hdrpos, datapos, size, date;
-     int uid, gid, mode;
-     struct ar_glob_state *state;
+ar_glob_match (int desc, char *mem, int truncated,
+	       long int hdrpos, long int datapos, long int size,
+               long int date, int uid, int gid, int mode,
+               struct ar_glob_state *state)
 {
   if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
     {
@@ -245,11 +230,9 @@ ar_glob_match (desc, mem, truncated,
 /* Return nonzero if PATTERN contains any metacharacters.
    Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
 static int
-glob_pattern_p (pattern, quote)
-     const char *pattern;
-     const int quote;
+glob_pattern_p (const char *pattern, int quote)
 {
-  register const char *p;
+  const char *p;
   int open = 0;
 
   for (p = pattern; *p != '\0'; ++p)
@@ -281,9 +264,7 @@ glob_pattern_p (pattern, quote)
    Return a malloc'd chain of matching elements (or nil if none).  */
 
 struct nameseq *
-ar_glob (arname, member_pattern, size)
-     char *arname, *member_pattern;
-     unsigned int size;
+ar_glob (char *arname, char *member_pattern, unsigned int size)
 {
   struct ar_glob_state state;
   char **names;
diff --git a/arscan.c b/arscan.c
index fc003e9..2c67947 100644
--- a/arscan.c
+++ b/arscan.c
@@ -46,9 +46,7 @@ static time_t VMS_member_date;
 static long int (*VMS_function) ();
 
 static int
-VMS_get_member_info (module, rfa)
-     struct dsc$descriptor_s *module;
-     unsigned long *rfa;
+VMS_get_member_info (struct dsc$descriptor_s *module, unsigned long *rfa)
 {
   int status, i;
   long int fnval;
@@ -136,10 +134,7 @@ VMS_get_member_info (module, rfa)
    Returns 0 if have scanned successfully.  */
 
 long int
-ar_scan (archive, function, arg)
-     char *archive;
-     long int (*function) ();
-     long int arg;
+ar_scan (char *archive, long int (*function) PARAMS ((void)), long int arg)
 {
   char *p;
 
@@ -306,10 +301,7 @@ struct ar_hdr
    Returns 0 if have scanned successfully.  */
 
 long int
-ar_scan (archive, function, arg)
-     char *archive;
-     long int (*function) ();
-     long int arg;
+ar_scan (char *archive, long int (*function)(), long int arg)
 {
 #ifdef AIAMAG
   FL_HDR fl_header;
@@ -714,9 +706,7 @@ ar_scan (archive, function, arg)
    sizeof (struct ar_hdr.ar_name) - 1.  */
 
 int
-ar_name_equal (name, mem, truncated)
-     char *name, *mem;
-     int truncated;
+ar_name_equal (char *name, char *mem, int truncated)
 {
   char *p;
 
@@ -747,14 +737,9 @@ ar_name_equal (name, mem, truncated)
 #ifndef VMS
 /* ARGSUSED */
 static long int
-ar_member_pos (desc, mem, truncated,
-	       hdrpos, datapos, size, date, uid, gid, mode, name)
-     int desc;
-     char *mem;
-     int truncated;
-     long int hdrpos, datapos, size, date;
-     int uid, gid, mode;
-     char *name;
+ar_member_pos (int desc, char *mem, int truncated,
+	       long int hdrpos, long int datapos, long int size,
+               long int date, int uid, int gid, int mode, char *name)
 {
   if (!ar_name_equal (name, mem, truncated))
     return 0;
@@ -769,8 +754,7 @@ ar_member_pos (desc, mem, truncated,
    1 if valid but member MEMNAME does not exist.  */
 
 int
-ar_member_touch (arname, memname)
-     char *arname, *memname;
+ar_member_touch (char *arname, char *memname)
 {
   register long int pos = ar_scan (arname, ar_member_pos, (long int) memname);
   register int fd;
@@ -829,13 +813,9 @@ ar_member_touch (arname, memname)
 #ifdef TEST
 
 long int
-describe_member (desc, name, truncated,
-		 hdrpos, datapos, size, date, uid, gid, mode)
-     int desc;
-     char *name;
-     int truncated;
-     long int hdrpos, datapos, size, date;
-     int uid, gid, mode;
+describe_member (int desc, char *name, int truncated,
+		 long int hdrpos, long int datapos, long int size,
+                 long int date, int uid, int gid, int mode)
 {
   extern char *ctime ();
 
@@ -848,14 +828,12 @@ describe_member (desc, name, truncated,
   return 0;
 }
 
-main (argc, argv)
-     int argc;
-     char **argv;
+int
+main (int argc, char **argv)
 {
   ar_scan (argv[1], describe_member);
   return 0;
 }
 
 #endif	/* TEST.  */
-
 #endif	/* NO_ARCHIVES.  */
diff --git a/commands.c b/commands.c
index a0483c4..30787a4 100644
--- a/commands.c
+++ b/commands.c
@@ -39,8 +39,7 @@ extern int getpid ();
 /* Set FILE's automatic variables up.  */
 
 static void
-set_file_variables (file)
-     register struct file *file;
+set_file_variables (struct file *file)
 {
   char *at, *percent, *star, *less;
 
@@ -258,8 +257,7 @@ set_file_variables (file)
    Also set the `lines_flags' and `any_recurse' members.  */
 
 void
-chop_commands (cmds)
-     register struct commands *cmds;
+chop_commands (struct commands *cmds)
 {
   register char *p;
   unsigned int nlines, idx;
@@ -360,8 +358,7 @@ chop_commands (cmds)
    fork off a child process to run the first command line in the sequence.  */
 
 void
-execute_file_commands (file)
-     struct file *file;
+execute_file_commands (struct file *file)
 {
   register char *p;
 
@@ -398,8 +395,7 @@ int handling_fatal_signal = 0;
 /* Handle fatal signals.  */
 
 RETSIGTYPE
-fatal_error_signal (sig)
-     int sig;
+fatal_error_signal (int sig)
 {
 #ifdef __MSDOS__
   extern int dos_status, dos_command_running;
@@ -493,9 +489,7 @@ fatal_error_signal (sig)
    and it has changed on disk since we last stat'd it.  */
 
 static void
-delete_target (file, on_behalf_of)
-     struct file *file;
-     char *on_behalf_of;
+delete_target (struct file *file, char *on_behalf_of)
 {
   struct stat st;
 
@@ -540,8 +534,7 @@ delete_target (file, on_behalf_of)
    Set the flag in CHILD to say they've been deleted.  */
 
 void
-delete_child_targets (child)
-     struct child *child;
+delete_child_targets (struct child *child)
 {
   struct dep *d;
 
@@ -561,8 +554,7 @@ delete_child_targets (child)
 /* Print out the commands in CMDS.  */
 
 void
-print_commands (cmds)
-     register struct commands *cmds;
+print_commands (struct commands *cmds)
 {
   register char *s;
 
diff --git a/configure.in b/configure.in
index df18069..8df2e27 100644
--- a/configure.in
+++ b/configure.in
@@ -1,6 +1,6 @@
 # Process this file with autoconf to produce a configure script.
 
-AC_INIT(GNU make,3.80,bug-make@gnu.org)
+AC_INIT(GNU make,3.81a1,bug-make@gnu.org)
 
 AC_PREREQ(2.54)
 
@@ -30,6 +30,9 @@ AC_AIX
 AC_ISC_POSIX
 AC_MINIX
 
+# Needed for ansi2knr
+AM_C_PROTOTYPES
+
 # Enable gettext, in "external" mode.
 
 AM_GNU_GETTEXT_VERSION(0.11.5)
diff --git a/default.c b/default.c
index 5d981b9..5b9d62d 100644
--- a/default.c
+++ b/default.c
@@ -511,7 +511,7 @@ static char *default_variables[] =
 /* Set up the default .SUFFIXES list.  */
 
 void
-set_default_suffixes ()
+set_default_suffixes (void)
 {
   suffix_file = enter_file (".SUFFIXES");
 
@@ -533,7 +533,7 @@ set_default_suffixes ()
    installed after.  */
 
 void
-install_default_suffix_rules ()
+install_default_suffix_rules (void)
 {
   register char **s;
 
@@ -558,7 +558,7 @@ install_default_suffix_rules ()
 /* Install the default pattern rules.  */
 
 void
-install_default_implicit_rules ()
+install_default_implicit_rules (void)
 {
   register struct pspec *p;
 
@@ -573,7 +573,7 @@ install_default_implicit_rules ()
 }
 
 void
-define_default_variables ()
+define_default_variables (void)
 {
   register char **s;
 
diff --git a/dir.c b/dir.c
index e862b9d..39f3e2a 100644
--- a/dir.c
+++ b/dir.c
@@ -70,8 +70,7 @@ extern char *vmsify PARAMS ((char *name, int type));
 #endif
 
 static char *
-dosify (filename)
-     char *filename;
+dosify (char *filename)
 {
   static char dos_filename[14];
   char *df;
@@ -121,8 +120,7 @@ dosify (filename)
 
 #ifdef HAVE_CASE_INSENSITIVE_FS
 static char *
-downcase (filename)
-     char *filename;
+downcase (char *filename)
 {
 #ifdef _AMIGA
   static char new_filename[136];
@@ -153,8 +151,7 @@ downcase (filename)
 #ifdef VMS
 
 static int
-vms_hash (name)
-    char *name;
+vms_hash (char *name)
 {
   int h = 0;
   int g;
@@ -176,9 +173,7 @@ vms_hash (name)
 
 /* fake stat entry for a directory */
 static int
-vmsstat_dir (name, st)
-    char *name;
-    struct stat *st;
+vmsstat_dir (char *name, struct stat *st)
 {
   char *s;
   int h;
@@ -248,8 +243,7 @@ struct directory_contents
   };
 
 static unsigned long
-directory_contents_hash_1 (key_0)
-    const void *key_0;
+directory_contents_hash_1 (const void *key_0)
 {
   struct directory_contents const *key = (struct directory_contents const *) key_0;
   unsigned long hash;
@@ -271,8 +265,7 @@ directory_contents_hash_1 (key_0)
 }
 
 static unsigned long
-directory_contents_hash_2 (key_0)
-    const void *key_0;
+directory_contents_hash_2 (const void *key_0)
 {
   struct directory_contents const *key = (struct directory_contents const *) key_0;
   unsigned long hash;
@@ -295,9 +288,7 @@ directory_contents_hash_2 (key_0)
 }
 
 static int
-directory_contents_hash_cmp (xv, yv)
-    const void *xv;
-    const void *yv;
+directory_contents_hash_cmp (const void *xv, const void *yv)
 {
   struct directory_contents const *x = (struct directory_contents const *) xv;
   struct directory_contents const *y = (struct directory_contents const *) yv;
@@ -345,23 +336,19 @@ struct directory
   };
 
 static unsigned long
-directory_hash_1 (key)
-    const void *key;
+directory_hash_1 (const void *key)
 {
   return_ISTRING_HASH_1 (((struct directory const *) key)->name);
 }
 
 static unsigned long
-directory_hash_2 (key)
-    const void *key;
+directory_hash_2 (const void *key)
 {
   return_ISTRING_HASH_2 (((struct directory const *) key)->name);
 }
 
 static int
-directory_hash_cmp (x, y)
-    const void *x;
-    const void *y;
+directory_hash_cmp (const void *x, const void *y)
 {
   return_ISTRING_COMPARE (((struct directory const *) x)->name,
 			  ((struct directory const *) y)->name);
@@ -387,23 +374,19 @@ struct dirfile
   };
 
 static unsigned long
-dirfile_hash_1 (key)
-    const void *key;
+dirfile_hash_1 (const void *key)
 {
   return_ISTRING_HASH_1 (((struct dirfile const *) key)->name);
 }
 
 static unsigned long
-dirfile_hash_2 (key)
-    const void *key;
+dirfile_hash_2 (const void *key)
 {
   return_ISTRING_HASH_2 (((struct dirfile const *) key)->name);
 }
 
 static int
-dirfile_hash_cmp (xv, yv)
-    const void *xv;
-    const void *yv;
+dirfile_hash_cmp (const void *xv, const void *yv)
 {
   struct dirfile const *x = ((struct dirfile const *) xv);
   struct dirfile const *y = ((struct dirfile const *) yv);
@@ -423,8 +406,7 @@ static struct directory *find_directory PARAMS ((char *name));
 /* Find the directory named NAME and return its `struct directory'.  */
 
 static struct directory *
-find_directory (name)
-     register char *name;
+find_directory (char *name)
 {
   register char *p;
   register struct directory *dir;
@@ -584,9 +566,7 @@ find_directory (name)
    FILENAME must contain no slashes.  */
 
 static int
-dir_contents_file_exists_p (dir, filename)
-     register struct directory_contents *dir;
-     register char *filename;
+dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 {
   unsigned int hash;
   struct dirfile *df;
@@ -724,9 +704,7 @@ dir_contents_file_exists_p (dir, filename)
    FILENAME must contain no slashes.  */
 
 int
-dir_file_exists_p (dirname, filename)
-     register char *dirname;
-     register char *filename;
+dir_file_exists_p (char *dirname, char *filename)
 {
   return dir_contents_file_exists_p (find_directory (dirname)->contents,
 				     filename);
@@ -735,8 +713,7 @@ dir_file_exists_p (dirname, filename)
 /* Return 1 if the file named NAME exists.  */
 
 int
-file_exists_p (name)
-     register char *name;
+file_exists_p (char *name)
 {
   char *dirend;
   char *dirname;
@@ -798,8 +775,7 @@ file_exists_p (name)
    as an intermediate file, and it has failed.  */
 
 void
-file_impossible (filename)
-     register char *filename;
+file_impossible (char *filename)
 {
   char *dirend;
   register char *p = filename;
@@ -882,8 +858,7 @@ file_impossible (filename)
 /* Return nonzero if FILENAME has been marked impossible.  */
 
 int
-file_impossible_p (filename)
-     char *filename;
+file_impossible_p (char *filename)
 {
   char *dirend;
   register char *p = filename;
@@ -964,8 +939,7 @@ file_impossible_p (filename)
    directory hash table that matches DIR.  */
 
 char *
-dir_name (dir)
-     char *dir;
+dir_name (char *dir)
 {
   return find_directory (dir)->name;
 }
@@ -973,7 +947,7 @@ dir_name (dir)
 /* Print the data base of directories.  */
 
 void
-print_dir_data_base ()
+print_dir_data_base (void)
 {
   register unsigned int files;
   register unsigned int impossible;
@@ -1096,8 +1070,7 @@ static __ptr_t open_dirstream PARAMS ((const char *));
 static struct dirent *read_dirstream PARAMS ((__ptr_t));
 
 static __ptr_t
-open_dirstream (directory)
-     const char *directory;
+open_dirstream (const char *directory)
 {
   struct dirstream *new;
   struct directory *dir = find_directory ((char *)directory);
@@ -1120,8 +1093,7 @@ open_dirstream (directory)
 }
 
 static struct dirent *
-read_dirstream (stream)
-     __ptr_t stream;
+read_dirstream (__ptr_t stream)
 {
   struct dirstream *const ds = (struct dirstream *) stream;
   struct directory_contents *dc = ds->contents;
@@ -1164,8 +1136,7 @@ read_dirstream (stream)
 }
 
 static void
-ansi_free(p)
-  void *p;
+ansi_free(void *p)
 {
     if (p)
       free(p);
@@ -1177,21 +1148,19 @@ ansi_free(p)
  */
 #ifndef stat
 # ifndef VMS
-extern int stat ();
+extern int stat PARAMS ((const char *path, struct stat *sbuf));
 # endif
 # define local_stat stat
 #else
-static int local_stat (path, buf)
-    char *path;
-    struct stat *buf;
+static int
+local_stat (const char *path, struct stat *buf)
 {
   return stat (path, buf);
 }
 #endif
 
 void
-dir_setup_glob (gl)
-     glob_t *gl;
+dir_setup_glob (glob_t *gl)
 {
   /* Bogus sunos4 compiler complains (!) about & before functions.  */
   gl->gl_opendir = open_dirstream;
@@ -1203,7 +1172,7 @@ dir_setup_glob (gl)
 }
 
 void
-hash_init_directories ()
+hash_init_directories (void)
 {
   hash_init (&directories, DIRECTORY_BUCKETS,
 	     directory_hash_1, directory_hash_2, directory_hash_cmp);
diff --git a/expand.c b/expand.c
index 3027f47..5c2c3e2 100644
--- a/expand.c
+++ b/expand.c
@@ -52,9 +52,7 @@ char *variable_buffer;
    the following call.  */
 
 char *
-variable_buffer_output (ptr, string, length)
-     char *ptr, *string;
-     unsigned int length;
+variable_buffer_output (char *ptr, char *string, unsigned int length)
 {
   register unsigned int newlen = length + (ptr - variable_buffer);
 
@@ -76,7 +74,7 @@ variable_buffer_output (ptr, string, length)
 /* Return a pointer to the beginning of the variable buffer.  */
 
 static char *
-initialize_variable_output ()
+initialize_variable_output (void)
 {
   /* If we don't have a variable output buffer yet, get one.  */
 
@@ -95,9 +93,7 @@ initialize_variable_output ()
 static char *allocated_variable_append PARAMS ((const struct variable *v));
 
 char *
-recursively_expand_for_file (v, file)
-     struct variable *v;
-     struct file *file;
+recursively_expand_for_file (struct variable *v, struct file *file)
 {
   char *value;
   struct variable_set_list *save = 0;
@@ -137,10 +133,7 @@ recursively_expand_for_file (v, file)
 __inline
 #endif
 static char *
-reference_variable (o, name, length)
-     char *o;
-     char *name;
-     unsigned int length;
+reference_variable (char *o, char *name, unsigned int length)
 {
   register struct variable *v;
   char *value;
@@ -173,10 +166,7 @@ reference_variable (o, name, length)
    NULL.  */
 
 char *
-variable_expand_string (line, string, length)
-     register char *line;
-     char *string;
-     long length;
+variable_expand_string (char *line, char *string, long length)
 {
   register struct variable *v;
   register char *p, *o, *p1;
@@ -409,8 +399,7 @@ variable_expand_string (line, string, length)
    and is valid only until the next time this function is called.  */
 
 char *
-variable_expand (line)
-     char *line;
+variable_expand (char *line)
 {
   return variable_expand_string(NULL, line, (long)-1);
 }
@@ -422,8 +411,7 @@ variable_expand (line)
    variable-expansion that is in progress.  */
 
 char *
-expand_argument (str, end)
-     char *str, *end;
+expand_argument (char *str, char *end)
 {
   char *tmp;
 
@@ -446,9 +434,7 @@ expand_argument (str, end)
    FILE's commands were found.  Expansion uses FILE's variable set list.  */
 
 static char *
-variable_expand_for_file (line, file)
-     char *line;
-     register struct file *file;
+variable_expand_for_file (char *line, struct file *file)
 {
   char *result;
   struct variable_set_list *save;
@@ -474,10 +460,8 @@ variable_expand_for_file (line, file)
    any upper variable sets.  Then expand the resulting value.  */
 
 static char *
-variable_append (name, length, set)
-     const char *name;
-     unsigned int length;
-     const struct variable_set_list *set;
+variable_append (const char *name, unsigned int length,
+                 const struct variable_set_list *set)
 {
   const struct variable *v;
   char *buf = 0;
@@ -510,8 +494,7 @@ variable_append (name, length, set)
 
 
 static char *
-allocated_variable_append (v)
-     const struct variable *v;
+allocated_variable_append (const struct variable *v)
 {
   char *val, *retval;
 
@@ -541,9 +524,7 @@ allocated_variable_append (v)
    This function is called a lot.  It wants to be efficient.  */
 
 char *
-allocated_variable_expand_for_file (line, file)
-     char *line;
-     struct file *file;
+allocated_variable_expand_for_file (char *line, struct file *file)
 {
   char *value;
 
diff --git a/file.c b/file.c
index ce1a0f9..b2767a2 100644
--- a/file.c
+++ b/file.c
@@ -34,23 +34,19 @@ Boston, MA 02111-1307, USA.  */
 /* Hash table of files the makefile knows how to make.  */
 
 static unsigned long
-file_hash_1 (key)
-    const void *key;
+file_hash_1 (const void *key)
 {
   return_ISTRING_HASH_1 (((struct file const *) key)->hname);
 }
 
 static unsigned long
-file_hash_2 (key)
-    const void *key;
+file_hash_2 (const void *key)
 {
   return_ISTRING_HASH_2 (((struct file const *) key)->hname);
 }
 
 static int
-file_hash_cmp (x, y)
-    const void *x;
-    const void *y;
+file_hash_cmp (const void *x, const void *y)
 {
   return_ISTRING_COMPARE (((struct file const *) x)->hname,
 			  ((struct file const *) y)->hname);
@@ -70,8 +66,7 @@ static int all_secondary = 0;
    enter_file   similar, but create one if there is none.  */
 
 struct file *
-lookup_file (name)
-     char *name;
+lookup_file (char *name)
 {
   register struct file *f;
   struct file file_key;
@@ -128,8 +123,7 @@ lookup_file (name)
 }
 
 struct file *
-enter_file (name)
-     char *name;
+enter_file (char *name)
 {
   register struct file *f;
   register struct file *new;
@@ -195,9 +189,7 @@ enter_file (name)
    and possibly merged with an existing file called NAME.  */
 
 void
-rename_file (from_file, to_hname)
-     register struct file *from_file;
-     char *to_hname;
+rename_file (struct file *from_file, char *to_hname)
 {
   rehash_file (from_file, to_hname);
   while (from_file)
@@ -212,9 +204,7 @@ rename_file (from_file, to_hname)
    and possibly merged with an existing file called NAME.  */
 
 void
-rehash_file (from_file, to_hname)
-     register struct file *from_file;
-     char *to_hname;
+rehash_file (struct file *from_file, char *to_hname)
 {
   struct file file_key;
   struct file **file_slot;
@@ -333,8 +323,7 @@ rehash_file (from_file, to_hname)
    the message will go to stderr rather than stdout.  */
 
 void
-remove_intermediates (sig)
-     int sig;
+remove_intermediates (int sig)
 {
   register struct file **file_slot;
   register struct file **file_end;
@@ -410,7 +399,7 @@ remove_intermediates (sig)
    and various other special targets.  */
 
 void
-snap_deps ()
+snap_deps (void)
 {
   register struct file *f;
   register struct file *f2;
@@ -525,9 +514,7 @@ snap_deps ()
 /* Set the `command_state' member of FILE and all its `also_make's.  */
 
 void
-set_command_state (file, state)
-     struct file *file;
-     int state;
+set_command_state (struct file *file, int state)
 {
   struct dep *d;
 
@@ -540,10 +527,7 @@ set_command_state (file, state)
 /* Convert an external file timestamp to internal form.  */
 
 FILE_TIMESTAMP
-file_timestamp_cons (fname, s, ns)
-     char const *fname;
-     time_t s;
-     int ns;
+file_timestamp_cons (const char *fname, time_t s, int ns)
 {
   int offset = ORDINARY_MTIME_MIN + (FILE_TIMESTAMP_HI_RES ? ns : 0);
   FILE_TIMESTAMP product = (FILE_TIMESTAMP) s << FILE_TIMESTAMP_LO_BITS;
@@ -565,8 +549,7 @@ file_timestamp_cons (fname, s, ns)
 /* Return the current time as a file timestamp, setting *RESOLUTION to
    its resolution.  */
 FILE_TIMESTAMP
-file_timestamp_now (resolution)
-     int *resolution;
+file_timestamp_now (int *resolution)
 {
   int r;
   time_t s;
@@ -606,7 +589,9 @@ file_timestamp_now (resolution)
   s = time ((time_t *) 0);
   ns = 0;
 
+#if FILE_TIMESTAMP_HI_RES
  got_time:
+#endif
   *resolution = r;
   return file_timestamp_cons (0, s, ns);
 }
@@ -614,9 +599,7 @@ file_timestamp_now (resolution)
 /* Place into the buffer P a printable representation of the file
    timestamp TS.  */
 void
-file_timestamp_sprintf (p, ts)
-     char *p;
-     FILE_TIMESTAMP ts;
+file_timestamp_sprintf (char *p, FILE_TIMESTAMP ts)
 {
   time_t t = FILE_TIMESTAMP_S (ts);
   struct tm *tm = localtime (&t);
@@ -648,9 +631,9 @@ file_timestamp_sprintf (p, ts)
 /* Print the data base of files.  */
 
 static void
-print_file (f)
-     struct file *f;
+print_file (const void *item)
 {
+  struct file *f = (struct file *)f;
   struct dep *d;
   struct dep *ood = 0;
 
@@ -759,7 +742,7 @@ print_file (f)
 }
 
 void
-print_file_data_base ()
+print_file_data_base (void)
 {
   puts (_("\n# Files"));
 
@@ -772,8 +755,7 @@ print_file_data_base ()
 #define EXPANSION_INCREMENT(_l)  ((((_l) / 500) + 1) * 500)
 
 char *
-build_target_list (value)
-     char *value;
+build_target_list (char *value)
 {
   static unsigned long last_targ_count = 0;
 
@@ -819,7 +801,7 @@ build_target_list (value)
 }
 
 void
-init_hash_files ()
+init_hash_files (void)
 {
   hash_init (&files, 1000, file_hash_1, file_hash_2, file_hash_cmp);
 }
diff --git a/function.c b/function.c
index cf646d6..3282cdf 100644
--- a/function.c
+++ b/function.c
@@ -41,25 +41,21 @@ struct function_table_entry
   };
 
 static unsigned long
-function_table_entry_hash_1 (keyv)
-    const void *keyv;
+function_table_entry_hash_1 (const void *keyv)
 {
   struct function_table_entry const *key = (struct function_table_entry const *) keyv;
   return_STRING_N_HASH_1 (key->name, key->len);
 }
 
 static unsigned long
-function_table_entry_hash_2 (keyv)
-    const void *keyv;
+function_table_entry_hash_2 (const void *keyv)
 {
   struct function_table_entry const *key = (struct function_table_entry const *) keyv;
   return_STRING_N_HASH_2 (key->name, key->len);
 }
 
 static int
-function_table_entry_hash_cmp (xv, yv)
-    const void *xv;
-    const void *yv;
+function_table_entry_hash_cmp (const void *xv, const void *yv)
 {
   struct function_table_entry const *x = (struct function_table_entry const *) xv;
   struct function_table_entry const *y = (struct function_table_entry const *) yv;
@@ -80,12 +76,9 @@ static struct hash_table function_table;
    done only at the ends of whitespace-delimited words.  */
 
 char *
-subst_expand (o, text, subst, replace, slen, rlen, by_word, suffix_only)
-     char *o;
-     char *text;
-     char *subst, *replace;
-     unsigned int slen, rlen;
-     int by_word, suffix_only;
+subst_expand (char *o, char *text, char *subst, char *replace,
+              unsigned int slen, unsigned int rlen,
+              int by_word, int suffix_only)
 {
   register char *t = text;
   register char *p;
@@ -150,11 +143,8 @@ subst_expand (o, text, subst, replace, slen, rlen, by_word, suffix_only)
    run through find_percent, and REPLACE_PERCENT is the result.  */
 
 char *
-patsubst_expand (o, text, pattern, replace, pattern_percent, replace_percent)
-     char *o;
-     char *text;
-     register char *pattern, *replace;
-     register char *pattern_percent, *replace_percent;
+patsubst_expand (char *o, char *text, char *pattern, char *replace,
+                 char *pattern_percent, char *replace_percent)
 {
   unsigned int pattern_prepercent_len, pattern_postpercent_len;
   unsigned int replace_prepercent_len, replace_postpercent_len = 0;
@@ -255,8 +245,7 @@ patsubst_expand (o, text, pattern, replace, pattern_percent, replace_percent)
 /* Look up a function by name.  */
 
 static const struct function_table_entry *
-lookup_function (s)
-     const char *s;
+lookup_function (const char *s)
 {
   const char *e = s;
 
@@ -277,8 +266,7 @@ lookup_function (s)
 /* Return 1 if PATTERN matches STR, 0 if not.  */
 
 int
-pattern_matches (pattern, percent, str)
-     register char *pattern, *percent, *str;
+pattern_matches (char *pattern, char *percent, char *str)
 {
   unsigned int sfxlen, strlength;
 
@@ -312,11 +300,8 @@ pattern_matches (pattern, percent, str)
 */
 
 static char *
-find_next_argument (startparen, endparen, ptr, end)
-     char startparen;
-     char endparen;
-     const char *ptr;
-     const char *end;
+find_next_argument (char startparen, char endparen,
+                    const char *ptr, const char *end)
 {
   int count = 0;
 
@@ -343,8 +328,7 @@ find_next_argument (startparen, endparen, ptr, end)
    only good until the next call to string_glob.  */
 
 static char *
-string_glob (line)
-     char *line;
+string_glob (char *line)
 {
   static char *result = 0;
   static unsigned int length;
@@ -406,10 +390,7 @@ string_glob (line)
  */
 
 static char *
-func_patsubst (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_patsubst (char *o, char **argv, const char *funcname)
 {
   o = patsubst_expand (o, argv[2], argv[0], argv[1], (char *) 0, (char *) 0);
   return o;
@@ -417,10 +398,7 @@ func_patsubst (o, argv, funcname)
 
 
 static char *
-func_join (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_join (char *o, char **argv, const char *funcname)
 {
   int doneany = 0;
 
@@ -460,10 +438,7 @@ func_join (o, argv, funcname)
 
 
 static char *
-func_origin (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_origin (char *o, char **argv, const char *funcname)
 {
   /* Expand the argument.  */
   register struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
@@ -514,10 +489,7 @@ func_origin (o, argv, funcname)
 
 
 static char *
-func_notdir_suffix (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_notdir_suffix (char *o, char **argv, const char *funcname)
 {
   /* Expand the argument.  */
   char *list_iterator = argv[0];
@@ -575,10 +547,7 @@ func_notdir_suffix (o, argv, funcname)
 
 
 static char *
-func_basename_dir (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_basename_dir (char *o, char **argv, const char *funcname)
 {
   /* Expand the argument.  */
   char *p3 = argv[0];
@@ -634,10 +603,7 @@ func_basename_dir (o, argv, funcname)
 }
 
 static char *
-func_addsuffix_addprefix (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_addsuffix_addprefix (char *o, char **argv, const char *funcname)
 {
   int fixlen = strlen (argv[0]);
   char *list_iterator = argv[1];
@@ -667,10 +633,7 @@ func_addsuffix_addprefix (o, argv, funcname)
 }
 
 static char *
-func_subst (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_subst (char *o, char **argv, const char *funcname)
 {
   o = subst_expand (o, argv[2], argv[0], argv[1], strlen (argv[0]),
 		    strlen (argv[1]), 0, 0);
@@ -680,10 +643,7 @@ func_subst (o, argv, funcname)
 
 
 static char *
-func_firstword (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_firstword (char *o, char **argv, const char *funcname)
 {
   unsigned int i;
   char *words = argv[0];    /* Use a temp variable for find_next_token */
@@ -697,10 +657,7 @@ func_firstword (o, argv, funcname)
 
 
 static char *
-func_words (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_words (char *o, char **argv, const char *funcname)
 {
   int i = 0;
   char *word_iterator = argv[0];
@@ -717,9 +674,7 @@ func_words (o, argv, funcname)
 }
 
 char *
-strip_whitespace (begpp, endpp)
-     char **begpp;
-     char **endpp;
+strip_whitespace (char **begpp, char **endpp)
 {
   while (isspace ((unsigned char)**begpp) && *begpp <= *endpp)
     (*begpp) ++;
@@ -729,8 +684,7 @@ strip_whitespace (begpp, endpp)
 }
 
 int
-is_numeric (p)
-     char *p;
+is_numeric (char *p)
 {
   char *end = p + strlen (p) - 1;
   char *beg = p;
@@ -744,9 +698,7 @@ is_numeric (p)
 }
 
 void
-check_numeric (s, message)
-     char *s;
-     char *message;
+check_numeric (char *s, char *message)
 {
   if (!is_numeric (s))
     fatal (reading_file, message);
@@ -755,10 +707,7 @@ check_numeric (s, message)
 
 
 static char *
-func_word (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_word (char *o, char **argv, const char *funcname)
 {
   char *end_p=0;
   int i=0;
@@ -784,10 +733,7 @@ func_word (o, argv, funcname)
 }
 
 static char *
-func_wordlist (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_wordlist (char *o, char **argv, const char *funcname)
 {
   int start, count;
 
@@ -824,10 +770,7 @@ func_wordlist (o, argv, funcname)
 }
 
 static char*
-func_findstring (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_findstring (char *o, char **argv, const char *funcname)
 {
   /* Find the first occurrence of the first string in the second.  */
   int i = strlen (argv[0]);
@@ -838,10 +781,7 @@ func_findstring (o, argv, funcname)
 }
 
 static char *
-func_foreach (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_foreach (char *o, char **argv, const char *funcname)
 {
   /* expand only the first two.  */
   char *varname = expand_argument (argv[0], NULL);
@@ -900,23 +840,19 @@ struct a_word
 };
 
 static unsigned long
-a_word_hash_1 (key)
-    const void *key;
+a_word_hash_1 (const void *key)
 {
   return_STRING_HASH_1 (((struct a_word const *) key)->str);
 }
 
 static unsigned long
-a_word_hash_2 (key)
-    const void *key;
+a_word_hash_2 (const void *key)
 {
   return_STRING_HASH_2 (((struct a_word const *) key)->str);
 }
 
 static int
-a_word_hash_cmp (x, y)
-    const void *x;
-    const void *y;
+a_word_hash_cmp (const void *x, const void *y)
 {
   int result = ((struct a_word const *) x)->length - ((struct a_word const *) y)->length;
   if (result)
@@ -935,10 +871,7 @@ struct a_pattern
 };
 
 static char *
-func_filter_filterout (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_filter_filterout (char *o, char **argv, const char *funcname)
 {
   struct a_word *wordhead;
   struct a_word **wordtail;
@@ -1068,10 +1001,7 @@ func_filter_filterout (o, argv, funcname)
 
 
 static char *
-func_strip (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_strip (char *o, char **argv, const char *funcname)
 {
   char *p = argv[0];
   int doneany =0;
@@ -1103,10 +1033,7 @@ func_strip (o, argv, funcname)
   Print a warning or fatal message.
 */
 static char *
-func_error (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_error (char *o, char **argv, const char *funcname)
 {
   char **argvp;
   char *msg, *p;
@@ -1143,10 +1070,7 @@ func_error (o, argv, funcname)
   chop argv[0] into words, and sort them.
  */
 static char *
-func_sort (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_sort (char *o, char **argv, const char *funcname)
 {
   char **words = 0;
   int nwords = 0;
@@ -1208,10 +1132,7 @@ func_sort (o, argv, funcname)
 */
 
 static char *
-func_if (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_if (char *o, char **argv, const char *funcname)
 {
   char *begp = argv[0];
   char *endp = begp + strlen (argv[0]);
@@ -1252,10 +1173,7 @@ func_if (o, argv, funcname)
 }
 
 static char *
-func_wildcard (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_wildcard (char *o, char **argv, const char *funcname)
 {
 
 #ifdef _AMIGA
@@ -1276,10 +1194,7 @@ func_wildcard (o, argv, funcname)
 */
 
 static char *
-func_eval (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_eval (char *o, char **argv, const char *funcname)
 {
   eval_buffer (argv[0]);
 
@@ -1288,10 +1203,7 @@ func_eval (o, argv, funcname)
 
 
 static char *
-func_value (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_value (char *o, char **argv, const char *funcname)
 {
   /* Look up the variable.  */
   struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
@@ -1307,9 +1219,7 @@ func_value (o, argv, funcname)
   \r  is replaced on UNIX as well. Is this desirable?
  */
 void
-fold_newlines (buffer, length)
-     char *buffer;
-     int *length;
+fold_newlines (char *buffer, int *length)
 {
   char *dst = buffer;
   char *src = buffer;
@@ -1493,10 +1403,7 @@ msdos_openpipe (int* pipedes, int *pidp, char *text)
 #else
 #ifndef _AMIGA
 static char *
-func_shell (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_shell (char *o, char **argv, const char *funcname)
 {
   char* batch_filename = NULL;
   int i;
@@ -1839,11 +1746,8 @@ static struct function_table_entry function_table_init[] =
 /* These must come after the definition of function_table.  */
 
 static char *
-expand_builtin_function (o, argc, argv, entry_p)
-     char *o;
-     int argc;
-     char **argv;
-     struct function_table_entry *entry_p;
+expand_builtin_function (char *o, int argc, char **argv,
+                         const struct function_table_entry *entry_p)
 {
   if (argc < (int)entry_p->minimum_args)
     fatal (reading_file,
@@ -1870,9 +1774,7 @@ expand_builtin_function (o, argc, argv, entry_p)
    *STRINGP past the reference and returning nonzero.  If not, return zero.  */
 
 int
-handle_function (op, stringp)
-     char **op;
-     char **stringp;
+handle_function (char **op, char **stringp)
 {
   const struct function_table_entry *entry_p;
   char openparen = (*stringp)[0];
@@ -1979,10 +1881,7 @@ handle_function (op, stringp)
    assigned to $1, $2, ... $N.  $0 is the name of the function.  */
 
 static char *
-func_call (o, argv, funcname)
-     char *o;
-     char **argv;
-     const char *funcname;
+func_call (char *o, char **argv, const char *funcname)
 {
   char *fname;
   char *cp;
@@ -2066,7 +1965,7 @@ func_call (o, argv, funcname)
 }
 
 void
-hash_init_function_table ()
+hash_init_function_table (void)
 {
   hash_init (&function_table, FUNCTION_TABLE_ENTRIES * 2,
 	     function_table_entry_hash_1, function_table_entry_hash_2,
diff --git a/getloadavg.c b/getloadavg.c
index 7d575cd..c4d9746 100644
--- a/getloadavg.c
+++ b/getloadavg.c
@@ -498,9 +498,7 @@ static kvm_t *kd;
    or -1 if an error occurred.  */
 
 int
-getloadavg (loadavg, nelem)
-     double loadavg[];
-     int nelem;
+getloadavg (double loadavg[], int nelem)
 {
   int elem = 0;			/* Return value.  */
 
@@ -994,9 +992,7 @@ getloadavg (loadavg, nelem)
 #include "make.h"
 
 int
-main (argc, argv)
-     int argc;
-     char **argv;
+main (int argc, char **argv)
 {
   int naptime = 0;
 
diff --git a/getopt.c b/getopt.c
index cd77419..21c775c 100644
--- a/getopt.c
+++ b/getopt.c
@@ -210,9 +210,7 @@ extern char *getenv ();
 #endif
 
 static char *
-my_index (str, chr)
-     const char *str;
-     int chr;
+my_index (const char *str, int chr)
 {
   while (*str)
     {
@@ -262,8 +260,7 @@ static char *const *original_argv;
 /* Make sure the environment variable bash 2.0 puts in the environment
    is valid for the getopt call we must make sure that the ARGV passed
    to getopt is that one passed to the process.  */
-static void
-__attribute__ ((unused))
+static void __attribute__ ((unused))
 store_args_and_env (int argc, char *const *argv)
 {
   /* XXX This is no good solution.  We should rather copy the args so
@@ -300,8 +297,7 @@ static void exchange (char **);
 #endif
 
 static void
-exchange (argv)
-     char **argv;
+exchange (char **argv)
 {
   int bottom = first_nonopt;
   int middle = last_nonopt;
@@ -385,10 +381,7 @@ exchange (argv)
 static const char *_getopt_initialize (int, char *const *, const char *);
 #endif
 static const char *
-_getopt_initialize (argc, argv, optstring)
-     int argc;
-     char *const *argv;
-     const char *optstring;
+_getopt_initialize (int argc, char *const *argv, const char *optstring)
 {
   /* Start processing options with ARGV-element 1 (since ARGV-element 0
      is the program name); the sequence of previously skipped
@@ -507,13 +500,8 @@ _getopt_initialize (argc, argv, optstring)
    long-named options.  */
 
 int
-_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
-     int argc;
-     char *const *argv;
-     const char *optstring;
-     const struct option *longopts;
-     int *longind;
-     int long_only;
+_getopt_internal (int argc, char *const *argv, const char *optstring,
+                  const struct option *longopts, int *longind, int long_only)
 {
   optarg = NULL;
 
@@ -961,10 +949,7 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)
 }
 
 int
-getopt (argc, argv, optstring)
-     int argc;
-     char *const *argv;
-     const char *optstring;
+getopt (int argc, char *const *argv, const char *optstring)
 {
   return _getopt_internal (argc, argv, optstring,
 			   (const struct option *) 0,
@@ -980,9 +965,7 @@ getopt (argc, argv, optstring)
    the above definition of `getopt'.  */
 
 int
-main (argc, argv)
-     int argc;
-     char **argv;
+main (int argc, char **argv)
 {
   int c;
   int digit_optind = 0;
diff --git a/getopt1.c b/getopt1.c
index 4ce1065..f09a283 100644
--- a/getopt1.c
+++ b/getopt1.c
@@ -3,7 +3,7 @@
      Free Software Foundation, Inc.
 
    NOTE: The canonical source of this file is maintained with the GNU C Library.
-   Bugs can be reported to bug-glibc@prep.ai.mit.edu.
+   Bugs can be reported to bug-glibc@gnu.org.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
@@ -66,12 +66,8 @@
 #endif
 
 int
-getopt_long (argc, argv, options, long_options, opt_index)
-     int argc;
-     char *const *argv;
-     const char *options;
-     const struct option *long_options;
-     int *opt_index;
+getopt_long (int argc, char *const *argv, const char *options,
+             const struct option *long_options, int *opt_index)
 {
   return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
 }
@@ -82,12 +78,8 @@ getopt_long (argc, argv, options, long_options, opt_index)
    instead.  */
 
 int
-getopt_long_only (argc, argv, options, long_options, opt_index)
-     int argc;
-     char *const *argv;
-     const char *options;
-     const struct option *long_options;
-     int *opt_index;
+getopt_long_only (int argc, char *const *argv, const char *options,
+                  const struct option *long_options, int *opt_index)
 {
   return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
 }
@@ -100,9 +92,7 @@ getopt_long_only (argc, argv, options, long_options, opt_index)
 #include <stdio.h>
 
 int
-main (argc, argv)
-     int argc;
-     char **argv;
+main (int argc, char **argv)
 {
   int c;
   int digit_optind = 0;
diff --git a/hash.c b/hash.c
index 9083b60..5eed69c 100644
--- a/hash.c
+++ b/hash.c
@@ -41,12 +41,8 @@ void *hash_deleted_item = &hash_deleted_item;
    given size.  */
 
 void
-hash_init (ht, size, hash_1, hash_2, hash_cmp)
-     struct hash_table* ht;
-     unsigned long size;
-     hash_func_t hash_1;
-     hash_func_t hash_2;
-     hash_cmp_func_t hash_cmp;
+hash_init (struct hash_table *ht, unsigned long size,
+           hash_func_t hash_1, hash_func_t hash_2, hash_cmp_func_t hash_cmp)
 {
   ht->ht_size = round_up_2 (size);
   ht->ht_empty_slots = ht->ht_size;
@@ -71,11 +67,8 @@ hash_init (ht, size, hash_1, hash_2, hash_cmp)
 /* Load an array of items into `ht'.  */
 
 void
-hash_load (ht, item_table, cardinality, size)
-     struct hash_table* ht;
-     void *item_table;
-     unsigned long cardinality;
-     unsigned long size;
+hash_load (struct hash_table *ht, void *item_table,
+           unsigned long cardinality, unsigned long size)
 {
   char *items = (char *) item_table;
   while (cardinality--)
@@ -91,9 +84,7 @@ hash_load (ht, item_table, cardinality, size)
    ht_fill on insertion.  */
 
 void **
-hash_find_slot (ht, key)
-     struct hash_table* ht;
-     void const *key;
+hash_find_slot (struct hash_table *ht, const void *key)
 {
   void **slot;
   void **deleted_slot = 0;
@@ -128,18 +119,14 @@ hash_find_slot (ht, key)
 }
 
 void *
-hash_find_item (ht, key)
-     struct hash_table* ht;
-     void const *key;
+hash_find_item (struct hash_table *ht, const void *key)
 {
   void **slot = hash_find_slot (ht, key);
   return ((HASH_VACANT (*slot)) ? 0 : *slot);
 }
 
 void *
-hash_insert (ht, item)
-     struct hash_table* ht;
-     void *item;
+hash_insert (struct hash_table *ht, void *item)
 {
   void **slot = hash_find_slot (ht, item);
   void *old_item = slot ? *slot : 0;
@@ -148,10 +135,7 @@ hash_insert (ht, item)
 }
 
 void *
-hash_insert_at (ht, item, slot)
-     struct hash_table* ht;
-     void *item;
-     void const *slot;
+hash_insert_at (struct hash_table *ht, void *item, const void *slot)
 {
   void *old_item = *(void **) slot;
   if (HASH_VACANT (old_item))
@@ -172,18 +156,14 @@ hash_insert_at (ht, item, slot)
 }
 
 void *
-hash_delete (ht, item)
-     struct hash_table* ht;
-     void const *item;
+hash_delete (struct hash_table *ht, const void *item)
 {
   void **slot = hash_find_slot (ht, item);
   return hash_delete_at (ht, slot);
 }
 
 void *
-hash_delete_at (ht, slot)
-     struct hash_table* ht;
-     void const *slot;
+hash_delete_at (struct hash_table *ht, const void *slot)
 {
   void *item = *(void **) slot;
   if (!HASH_VACANT (item))
@@ -197,8 +177,7 @@ hash_delete_at (ht, slot)
 }
 
 void
-hash_free_items (ht)
-     struct hash_table* ht;
+hash_free_items (struct hash_table *ht)
 {
   void **vec = ht->ht_vec;
   void **end = &vec[ht->ht_size];
@@ -214,8 +193,7 @@ hash_free_items (ht)
 }
 
 void
-hash_delete_items (ht)
-     struct hash_table* ht;
+hash_delete_items (struct hash_table *ht)
 {
   void **vec = ht->ht_vec;
   void **end = &vec[ht->ht_size];
@@ -229,9 +207,7 @@ hash_delete_items (ht)
 }
 
 void
-hash_free (ht, free_items)
-     struct hash_table* ht;
-     int free_items;
+hash_free (struct hash_table *ht, int free_items)
 {
   if (free_items)
     hash_free_items (ht);
@@ -246,9 +222,7 @@ hash_free (ht, free_items)
 }
 
 void
-hash_map (ht, map)
-     struct hash_table *ht;
-     hash_map_func_t map;
+hash_map (struct hash_table *ht, hash_map_func_t map)
 {
   void **slot;
   void **end = &ht->ht_vec[ht->ht_size];
@@ -261,10 +235,7 @@ hash_map (ht, map)
 }
 
 void
-hash_map_arg (ht, map, arg)
-     struct hash_table *ht;
-     hash_map_arg_func_t map;
-     void *arg;
+hash_map_arg (struct hash_table *ht, hash_map_arg_func_t map, void *arg)
 {
   void **slot;
   void **end = &ht->ht_vec[ht->ht_size];
@@ -279,8 +250,7 @@ hash_map_arg (ht, map, arg)
 /* Double the size of the hash table in the event of overflow... */
 
 static void
-hash_rehash (ht)
-     struct hash_table* ht;
+hash_rehash (struct hash_table *ht)
 {
   unsigned long old_ht_size = ht->ht_size;
   void **old_vec = ht->ht_vec;
@@ -307,9 +277,7 @@ hash_rehash (ht)
 }
 
 void
-hash_print_stats (ht, out_FILE)
-     struct hash_table *ht;
-     FILE *out_FILE;
+hash_print_stats (struct hash_table *ht, FILE *out_FILE)
 {
   /* GKM FIXME: honor NO_FLOAT */
   fprintf (out_FILE, _("Load=%ld/%ld=%.0f%%, "), ht->ht_fill, ht->ht_size,
@@ -325,10 +293,7 @@ hash_print_stats (ht, out_FILE)
    user-supplied vector, or malloc one.  */
 
 void **
-hash_dump (ht, vector_0, compare)
-     struct hash_table *ht;
-     void **vector_0;
-     qsort_cmp_t compare;
+hash_dump (struct hash_table *ht, void **vector_0, qsort_cmp_t compare)
 {
   void **vector;
   void **slot;
@@ -351,8 +316,7 @@ hash_dump (ht, vector_0, compare)
 /* Round a given number up to the nearest power of 2. */
 
 static unsigned long
-round_up_2 (n)
-     unsigned long n;
+round_up_2 (unsigned long n)
 {
   n |= (n >> 1);
   n |= (n >> 2);
diff --git a/implicit.c b/implicit.c
index 857895d..0908cbd 100644
--- a/implicit.c
+++ b/implicit.c
@@ -33,9 +33,7 @@ static int pattern_search PARAMS ((struct file *file, int archive, unsigned int
    or returns 0 if no implicit rule was found.  */
 
 int
-try_implicit_rule (file, depth)
-     struct file *file;
-     unsigned int depth;
+try_implicit_rule (struct file *file, unsigned int depth)
 {
   DBF (DB_IMPLICIT, _("Looking for an implicit rule for `%s'.\n"));
 
@@ -78,11 +76,8 @@ try_implicit_rule (file, depth)
    DEPTH is used for debugging messages.  */
 
 static int
-pattern_search (file, archive, depth, recursions)
-     struct file *file;
-     int archive;
-     unsigned int depth;
-     unsigned int recursions;
+pattern_search (struct file *file, int archive,
+                unsigned int depth, unsigned int recursions)
 {
   /* Filename we are searching for a rule for.  */
   char *filename = archive ? strchr (file->name, '(') : file->name;
diff --git a/job.c b/job.c
index 63456a7..efdf4dd 100644
--- a/job.c
+++ b/job.c
@@ -239,10 +239,8 @@ int w32_kill(int pid, int sig)
    Append "(ignored)" if IGNORED is nonzero.  */
 
 static void
-child_error (target_name, exit_code, exit_sig, coredump, ignored)
-     char *target_name;
-     int exit_code, exit_sig, coredump;
-     int ignored;
+child_error (char *target_name, int exit_code, int exit_sig, int coredump,
+             int ignored)
 {
   if (ignored && silent_flag)
     return;
@@ -286,10 +284,7 @@ vmsWaitForChildren(int *status)
 /* Set up IO redirection.  */
 
 char *
-vms_redirect (desc, fname, ibuf)
-    struct dsc$descriptor_s *desc;
-    char *fname;
-    char *ibuf;
+vms_redirect (struct dsc$descriptor_s *desc, char *fname, char *ibuf)
 {
   char *fptr;
   extern char *vmsify ();
@@ -390,8 +385,7 @@ handle_apos (char *p)
 static unsigned int dead_children = 0;
 
 RETSIGTYPE
-child_handler (sig)
-     int sig;
+child_handler (int sig)
 {
   ++dead_children;
 
@@ -415,8 +409,7 @@ extern int shell_function_pid, shell_function_completed;
    print an error message first.  */
 
 void
-reap_children (block, err)
-     int block, err;
+reap_children (int block, int err)
 {
   WAIT_T status;
   /* Initially, assume we have some.  */
@@ -771,8 +764,7 @@ reap_children (block, err)
 /* Free the storage allocated for CHILD.  */
 
 static void
-free_child (child)
-     register struct child *child;
+free_child (struct child *child)
 {
   /* If this child is the only one it was our "free" job, so don't put a
      token back for it.  This child has already been removed from the list,
@@ -818,7 +810,7 @@ extern sigset_t fatal_signal_set;
 #endif
 
 void
-block_sigs ()
+block_sigs (void)
 {
 #ifdef POSIX
   (void) sigprocmask (SIG_BLOCK, &fatal_signal_set, (sigset_t *) 0);
@@ -831,7 +823,7 @@ block_sigs ()
 
 #ifdef	POSIX
 void
-unblock_sigs ()
+unblock_sigs (void)
 {
   sigset_t empty;
   sigemptyset (&empty);
@@ -842,8 +834,7 @@ unblock_sigs ()
 #ifdef MAKE_JOBSERVER
 /* Set the child handler action flags to FLAGS.  */
 static void
-set_child_handler_action_flags (flags)
-     int flags;
+set_child_handler_action_flags (int flags)
 {
   struct sigaction sa;
   bzero ((char *) &sa, sizeof sa);
@@ -867,8 +858,7 @@ set_child_handler_action_flags (flags)
    it can be cleaned up in the event of a fatal signal.  */
 
 static void
-start_job_command (child)
-     register struct child *child;
+start_job_command (struct child *child)
 {
 #ifndef _AMIGA
   static int bad_stdin = -1;
@@ -1284,8 +1274,7 @@ start_job_command (child)
    the load was too high and the child was put on the `waiting_jobs' chain.  */
 
 static int
-start_waiting_job (c)
-     struct child *c;
+start_waiting_job (struct child *c)
 {
   struct file *f = c->file;
 
@@ -1344,8 +1333,7 @@ start_waiting_job (c)
 /* Create a `struct child' for FILE and start its commands running.  */
 
 void
-new_job (file)
-     register struct file *file;
+new_job (struct file *file)
 {
   register struct commands *cmds = file->cmds;
   register struct child *c;
@@ -1587,8 +1575,7 @@ new_job (file)
    Returns nonzero if there is another command.  */
 
 static int
-job_next_command (child)
-     struct child *child;
+job_next_command (struct child *child)
 {
   while (child->command_ptr == 0 || *child->command_ptr == '\0')
     {
@@ -1607,7 +1594,7 @@ job_next_command (child)
 }
 
 static int
-load_too_high ()
+load_too_high (void)
 {
 #if defined(__MSDOS__) || defined(VMS) || defined(_AMIGA)
   return 1;
@@ -1645,7 +1632,7 @@ load_too_high ()
 /* Start jobs that are waiting for the load to be lower.  */
 
 void
-start_waiting_jobs ()
+start_waiting_jobs (void)
 {
   struct child *job;
 
@@ -1844,9 +1831,7 @@ static void tryToSetupYAst(void) {
 	}
 }
 int
-child_execute_job (argv, child)
-     char *argv;
-     struct child *child;
+child_execute_job (char *argv, struct child *child)
 {
   int i;
   static struct dsc$descriptor_s cmddsc;
@@ -2226,9 +2211,7 @@ child_execute_job (argv, child)
    the environment of the new program.  This function does not return.  */
 
 void
-child_execute_job (stdin_fd, stdout_fd, argv, envp)
-     int stdin_fd, stdout_fd;
-     char **argv, **envp;
+child_execute_job (int stdin_fd, int stdout_fd, char **argv, char **envp)
 {
   if (stdin_fd != 0)
     (void) dup2 (stdin_fd, 0);
@@ -2251,8 +2234,7 @@ child_execute_job (stdin_fd, stdout_fd, argv, envp)
    with environment ENVP.  This function does not return.  */
 
 void
-exec_command (argv, envp)
-     char **argv, **envp;
+exec_command (char **argv, char **envp)
 {
 #ifdef VMS
   /* to work around a problem with signals and execve: ignore them */
@@ -2374,8 +2356,7 @@ exec_command (argv, envp)
 #endif /* !VMS */
 }
 #else /* On Amiga */
-void exec_command (argv)
-     char **argv;
+void exec_command (char **argv)
 {
   MyExecute (argv);
 }
@@ -2402,10 +2383,8 @@ void clean_tmp (void)
    IFS is the value of $IFS, or nil (meaning the default).  */
 
 static char **
-construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
-     char *line, **restp;
-     char *shell, *ifs;
-     char **batch_filename_ptr;
+construct_command_argv_internal (char *line, char **restp, char *shell,
+                                 char *ifs, char **batch_filename_ptr)
 {
 #ifdef __MSDOS__
   /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
@@ -3011,10 +2990,8 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
    variable expansion for $(SHELL) and $(IFS).  */
 
 char **
-construct_command_argv (line, restp, file, batch_filename_ptr)
-     char *line, **restp;
-     struct file *file;
-     char** batch_filename_ptr;
+construct_command_argv (char *line, char **restp, struct file *file,
+                        char **batch_filename_ptr)
 {
   char *shell, *ifs;
   char **argv;
@@ -3091,8 +3068,7 @@ construct_command_argv (line, restp, file, batch_filename_ptr)
 
 #if !defined(HAVE_DUP2) && !defined(_AMIGA)
 int
-dup2 (old, new)
-     int old, new;
+dup2 (int old, int new)
 {
   int fd;
 
diff --git a/loadtest.c b/loadtest.c
deleted file mode 100644
index 19b80f6..0000000
--- a/loadtest.c
+++ /dev/null
@@ -1,31 +0,0 @@
-extern volatile void exit (int);
-extern double load_average (void);
-
-double max_load_average = -1;
-unsigned int job_slots_used = 0;
-
-
-int
-main ()
-{
-  printf ("load_average () = %.2f\n", load_average ());
-  exit (0);
-}
-
-void
-error (char *fmt, ...)
-{
-  exit (1);
-}
-
-void 
-perror_with_name (char *a, char *b)
-{
-  exit (1);
-}
-
-void
-wait_for_children (int i)
-{
-  return;
-}
diff --git a/main.c b/main.c
index a04671d..50b44d2 100644
--- a/main.c
+++ b/main.c
@@ -478,9 +478,7 @@ int fatal_signal_mask;
 typedef RETSIGTYPE (*bsd_signal_ret_t) ();
 
 static bsd_signal_ret_t
-bsd_signal (sig, func)
-     int sig;
-     bsd_signal_ret_t func;
+bsd_signal (int sig, bsd_signal_ret_t func)
 {
   struct sigaction act, oact;
   act.sa_handler = func;
@@ -495,7 +493,7 @@ bsd_signal (sig, func)
 #endif
 
 static void
-initialize_global_hash_tables ()
+initialize_global_hash_tables (void)
 {
   init_hash_global_variable_set ();
   init_hash_files ();
@@ -504,8 +502,7 @@ initialize_global_hash_tables ()
 }
 
 static struct file *
-enter_command_line_file (name)
-     char *name;
+enter_command_line_file (char *name)
 {
   if (name[0] == '\0')
     fatal (NILF, _("empty string invalid as file name"));
@@ -544,14 +541,13 @@ enter_command_line_file (name)
 /* Toggle -d on receipt of SIGUSR1.  */
 
 static RETSIGTYPE
-debug_signal_handler (sig)
-     int sig;
+debug_signal_handler (int sig)
 {
   db_level = db_level ? DB_NONE : DB_BASIC;
 }
 
 static void
-decode_debug_flags ()
+decode_debug_flags (void)
 {
   char **pp;
 
@@ -688,7 +684,7 @@ handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
  */
 
 int
-find_and_set_default_shell(char *token)
+find_and_set_default_shell (char *token)
 {
   int sh_found = 0;
   char* search_token;
@@ -775,20 +771,18 @@ find_and_set_default_shell(char *token)
 #ifdef  __MSDOS__
 
 static void
-msdos_return_to_initial_directory ()
+msdos_return_to_initial_directory (void)
 {
   if (directory_before_chdir)
     chdir (directory_before_chdir);
 }
 #endif
 
-extern char *mktemp ();
-extern int mkstemp ();
+extern char *mktemp PARAMS ((char *template));
+extern int mkstemp PARAMS ((char *template));
 
 FILE *
-open_tmpfile(name, template)
-     char **name;
-     const char *template;
+open_tmpfile(char **name, const char *template)
 {
   int fd;
 
@@ -827,14 +821,12 @@ open_tmpfile(name, template)
 }
 
 
-#ifndef _AMIGA
+#ifdef _AMIGA
 int
-main (argc, argv, envp)
-     int argc;
-     char **argv;
-     char **envp;
+main (int argc, char **argv)
 #else
-int main (int argc, char ** argv)
+int
+main (int argc, char **argv, char **envp)
 #endif
 {
   static char *stdin_nm = 0;
@@ -1985,7 +1977,7 @@ static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
 
 /* Fill in the string and vector for getopt.  */
 static void
-init_switches ()
+init_switches (void)
 {
   register char *p;
   register int c;
@@ -2042,9 +2034,7 @@ init_switches ()
 }
 
 static void
-handle_non_switch_argument (arg, env)
-     char *arg;
-     int env;
+handle_non_switch_argument (char *arg, int env)
 {
   /* Non-option argument.  It might be a variable definition.  */
   struct variable *v;
@@ -2112,8 +2102,7 @@ handle_non_switch_argument (arg, env)
 /* Print a nice usage method.  */
 
 static void
-print_usage (bad)
-     int bad;
+print_usage (int bad)
 {
   extern char *make_host;
   const char *const *cpp;
@@ -2142,10 +2131,7 @@ print_usage (bad)
    They came from the environment if ENV is nonzero.  */
 
 static void
-decode_switches (argc, argv, env)
-     int argc;
-     char **argv;
-     int env;
+decode_switches (int argc, char **argv, int env)
 {
   int bad = 0;
   register const struct command_switch *cs;
@@ -2309,9 +2295,7 @@ decode_switches (argc, argv, env)
    decode_switches.  */
 
 static void
-decode_env_switches (envar, len)
-     char *envar;
-     unsigned int len;
+decode_env_switches (char *envar, unsigned int len)
 {
   char *varref = (char *) alloca (2 + len + 2);
   char *value, *p;
@@ -2382,8 +2366,7 @@ decode_env_switches (envar, len)
    Allocating space for OUT twice the length of IN is always sufficient.  */
 
 static char *
-quote_for_env (out, in)
-     char *out, *in;
+quote_for_env (char *out, char *in)
 {
   while (*in != '\0')
     {
@@ -2402,8 +2385,7 @@ quote_for_env (out, in)
    Don't include options with the `no_makefile' flag set if MAKEFILE.  */
 
 static void
-define_makeflags (all, makefile)
-     int all, makefile;
+define_makeflags (int all, int makefile)
 {
   static const char ref[] = "$(MAKEOVERRIDES)";
   static const char posixref[] = "$(-*-command-variables-*-)";
@@ -2665,7 +2647,7 @@ define_makeflags (all, makefile)
 /* Print version information.  */
 
 static void
-print_version ()
+print_version (void)
 {
   static int printed_version = 0;
 
@@ -2699,7 +2681,7 @@ print_version ()
 /* Print a bunch of information about this and that.  */
 
 static void
-print_data_base ()
+print_data_base (void)
 {
   time_t when;
 
@@ -2719,8 +2701,7 @@ print_data_base ()
 /* Exit with STATUS, cleaning up as necessary.  */
 
 void
-die (status)
-     int status;
+die (int status)
 {
   static char dying = 0;
 
@@ -2764,8 +2745,7 @@ die (status)
    left (according to ENTERING) the current directory.  */
 
 void
-log_working_directory (entering)
-     int entering;
+log_working_directory (int entering)
 {
   static int entered = 0;
 
diff --git a/maintMakefile b/maintMakefile
index 2bc1949..1bf49f0 100644
--- a/maintMakefile
+++ b/maintMakefile
@@ -79,7 +79,7 @@ build.sh.in: build.template Makefile
 maintFILES = configure aclocal.m4 config.h.in Makefile.in stamp-h.in
 
 CVS-CLEAN-FILES +=	$(maintFILES) $(TEMPLATES) $(MTEMPLATES) NMakefile \
-			missing build.sh.in .dep_segment
+			missing build.sh.in .dep_segment po-check-?
 
 # This rule tries to clean the tree right down to how it looks when you do a
 # virgin CVS checkout.
@@ -218,10 +218,11 @@ changelog-check:
 	fi
 
 # Verify that all source files using _() are listed in po/POTFILES.in.
+# Ignore make.h; it defines _().
 po-check:
 	if test -f po/POTFILES.in; then \
 	  grep -E -v '^(#|$$)' po/POTFILES.in | sort > $@-1; \
-	  grep -E -l '\b_\(' *.c | sort > $@-2; \
+	  grep -E -l '\b_\(' *.c *.h | grep -v make.h | sort > $@-2; \
 	  diff -u $@-1 $@-2 || exit 1; \
 	  rm -f $@-1 $@-2; \
 	fi
diff --git a/misc.c b/misc.c
index 7f0b1b3..5305220 100644
--- a/misc.c
+++ b/misc.c
@@ -60,8 +60,7 @@ Boston, MA 02111-1307, USA.  */
    zero if they are equal.  */
 
 int
-alpha_compare (v1, v2)
-     const void *v1, *v2;
+alpha_compare (const void *v1, const void *v2)
 {
   const char *s1 = *((char **)v1);
   const char *s2 = *((char **)v2);
@@ -76,8 +75,7 @@ alpha_compare (v1, v2)
    This is done by copying the text at LINE into itself.  */
 
 void
-collapse_continuations (line)
-     char *line;
+collapse_continuations (char *line)
 {
   register char *in, *out, *p;
   register int backslash;
@@ -158,8 +156,7 @@ collapse_continuations (line)
    This is done by copying the text at LINE onto itself.  */
 
 void
-remove_comments (line)
-     char *line;
+remove_comments (char *line)
 {
   char *comment;
 
@@ -173,8 +170,7 @@ remove_comments (line)
 /* Print N spaces (used in debug for target-depth).  */
 
 void
-print_spaces (n)
-     unsigned int n;
+print_spaces (unsigned int n)
 {
   while (n-- > 0)
     putchar (' ');
@@ -185,8 +181,7 @@ print_spaces (n)
    concatenate those of s1, s2, s3.  */
 
 char *
-concat (s1, s2, s3)
-     const char *s1, *s2, *s3;
+concat (const char *s1, const char *s2, const char *s3)
 {
   unsigned int len1, len2, len3;
   char *result;
@@ -316,8 +311,7 @@ fatal (flocp, fmt, va_alist)
 #undef	strerror
 
 char *
-strerror (errnum)
-     int errnum;
+strerror (int errnum)
 {
   extern int errno, sys_nerr;
 #ifndef __DECC
@@ -336,8 +330,7 @@ strerror (errnum)
 /* Print an error message from errno.  */
 
 void
-perror_with_name (str, name)
-     const char *str, *name;
+perror_with_name (const char *str, const char *name)
 {
   error (NILF, _("%s%s: %s"), str, name, strerror (errno));
 }
@@ -345,8 +338,7 @@ perror_with_name (str, name)
 /* Print an error message from errno and exit.  */
 
 void
-pfatal_with_name (name)
-     const char *name;
+pfatal_with_name (const char *name)
 {
   fatal (NILF, _("%s: %s"), name, strerror (errno));
 
@@ -363,8 +355,7 @@ pfatal_with_name (name)
 #undef xstrdup
 
 char *
-xmalloc (size)
-     unsigned int size;
+xmalloc (unsigned int size)
 {
   char *result = (char *) malloc (size);
   if (result == 0)
@@ -374,9 +365,7 @@ xmalloc (size)
 
 
 char *
-xrealloc (ptr, size)
-     char *ptr;
-     unsigned int size;
+xrealloc (char *ptr, unsigned int size)
 {
   char *result;
 
@@ -389,8 +378,7 @@ xrealloc (ptr, size)
 
 
 char *
-xstrdup (ptr)
-     const char *ptr;
+xstrdup (const char *ptr)
 {
   char *result;
 
@@ -413,9 +401,7 @@ xstrdup (ptr)
 #endif  /* HAVE_DMALLOC_H */
 
 char *
-savestring (str, length)
-     const char *str;
-     unsigned int length;
+savestring (const char *str, unsigned int length)
 {
   register char *out = (char *) xmalloc (length + 1);
   if (length > 0)
@@ -429,11 +415,8 @@ savestring (str, length)
    beginning of the first occurrence, or return nil if none found.  */
 
 char *
-sindex (big, blen, small, slen)
-     const char *big;
-     unsigned int blen;
-     const char *small;
-     unsigned int slen;
+sindex (const char *big, unsigned int blen,
+        const char *small, unsigned int slen)
 {
   if (!blen)
     blen = strlen (big);
@@ -463,9 +446,7 @@ sindex (big, blen, small, slen)
    instead of at the first null.  */
 
 char *
-lindex (s, limit, c)
-     register const char *s, *limit;
-     int c;
+lindex (const char *s, const char *limit, int c)
 {
   while (s < limit)
     if (*s++ == c)
@@ -477,8 +458,7 @@ lindex (s, limit, c)
 /* Return the address of the first whitespace or null in the string S.  */
 
 char *
-end_of_token (s)
-     char *s;
+end_of_token (char *s)
 {
   while (*s != '\0' && !isblank ((unsigned char)*s))
     ++s;
@@ -490,9 +470,7 @@ end_of_token (s)
  * Same as end_of_token, but take into account a stop character
  */
 char *
-end_of_token_w32 (s, stopchar)
-     char *s;
-     char stopchar;
+end_of_token_w32 (char *s, char stopchar)
 {
   register char *p = s;
   register int backslash = 0;
@@ -520,8 +498,7 @@ end_of_token_w32 (s, stopchar)
 /* Return the address of the first nonwhitespace or null in the string S.  */
 
 char *
-next_token (s)
-     const char *s;
+next_token (const char *s)
 {
   while (isblank ((unsigned char)*s))
     ++s;
@@ -532,9 +509,7 @@ next_token (s)
    length of the token into *LENGTHPTR if LENGTHPTR is not nil.  */
 
 char *
-find_next_token (ptr, lengthptr)
-     char **ptr;
-     unsigned int *lengthptr;
+find_next_token (char **ptr, unsigned int *lengthptr)
 {
   char *p = next_token (*ptr);
   char *end;
@@ -552,8 +527,7 @@ find_next_token (ptr, lengthptr)
    with the same contents as the old one.  */
 
 struct dep *
-copy_dep_chain (d)
-     register struct dep *d;
+copy_dep_chain (struct dep *d)
 {
   register struct dep *c;
   struct dep *firstnew = 0;
@@ -581,8 +555,7 @@ copy_dep_chain (d)
 /* The losing compiler on this machine can't handle this macro.  */
 
 char *
-dep_name (dep)
-     struct dep *dep;
+dep_name (struct dep *dep)
 {
   return dep->name == 0 ? dep->file->name : dep->name;
 }
@@ -641,8 +614,7 @@ static enum { make, user } current_access;
 /* Under -d, write a message describing the current IDs.  */
 
 static void
-log_access (flavor)
-     char *flavor;
+log_access (char *flavor)
 {
   if (! ISDB (DB_JOBS))
     return;
@@ -659,7 +631,7 @@ log_access (flavor)
 
 
 static void
-init_access ()
+init_access (void)
 {
 #ifndef VMS
   user_uid = getuid ();
@@ -683,7 +655,7 @@ init_access ()
 /* Give the process appropriate permissions for access to
    user data (i.e., to stat files, or to spawn a child process).  */
 void
-user_access ()
+user_access (void)
 {
 #ifdef	GETLOADAVG_PRIVILEGED
 
@@ -759,7 +731,7 @@ user_access ()
 /* Give the process appropriate permissions for access to
    make data (i.e., the load average).  */
 void
-make_access ()
+make_access (void)
 {
 #ifdef	GETLOADAVG_PRIVILEGED
 
@@ -807,7 +779,7 @@ make_access ()
 /* Give the process appropriate permissions for a child process.
    This is like user_access, but you can't get back to make_access.  */
 void
-child_access ()
+child_access (void)
 {
 #ifdef	GETLOADAVG_PRIVILEGED
 
@@ -840,7 +812,7 @@ child_access ()
 
 #ifdef NEED_GET_PATH_MAX
 unsigned int
-get_path_max ()
+get_path_max (void)
 {
   static unsigned int value;
 
@@ -864,9 +836,7 @@ get_path_max ()
 #undef readdir
 
 int
-atomic_stat(file, buf)
-     const char *file;
-     struct stat *buf;
+atomic_stat (const char *file, struct stat *buf)
 {
   int r;
 
@@ -878,8 +848,7 @@ atomic_stat(file, buf)
 }
 
 struct dirent *
-atomic_readdir(dir)
-     DIR *dir;
+atomic_readdir (DIR *dir)
 {
   struct dirent *r;
 
diff --git a/read.c b/read.c
index 1d91647..4fb811a 100644
--- a/read.c
+++ b/read.c
@@ -147,8 +147,7 @@ static enum make_word_type get_next_mword PARAMS ((char *buffer, char *delim,
 /* Read in all the makefiles and return the chain of their names.  */
 
 struct dep *
-read_all_makefiles (makefiles)
-     char **makefiles;
+read_all_makefiles (char **makefiles)
 {
   unsigned int num_makefiles = 0;
 
@@ -274,9 +273,7 @@ read_all_makefiles (makefiles)
 }
 
 static int
-eval_makefile (filename, flags)
-     char *filename;
-     int flags;
+eval_makefile (char *filename, int flags)
 {
   struct dep *deps;
   struct ebuffer ebuf;
@@ -388,8 +385,7 @@ eval_makefile (filename, flags)
 }
 
 int
-eval_buffer (buffer)
-     char *buffer;
+eval_buffer (char *buffer)
 {
   struct ebuffer ebuf;
   const struct floc *curfile;
@@ -425,9 +421,7 @@ eval_buffer (buffer)
    Returns 2 if FILENAME was read, and we kept a reference (don't free it).  */
 
 static int
-eval (ebuf, set_default)
-     struct ebuffer *ebuf;
-     int set_default;
+eval (struct ebuffer *ebuf, int set_default)
 {
   static char *collapsed = 0;
   static unsigned int collapsed_length = 0;
@@ -1230,11 +1224,8 @@ eval (ebuf, set_default)
    the variable to be defined.  The following lines remain to be read.  */
 
 static void
-do_define (name, namelen, origin, ebuf)
-     char *name;
-     unsigned int namelen;
-     enum variable_origin origin;
-     struct ebuffer *ebuf;
+do_define (char *name, unsigned int namelen,
+           enum variable_origin origin, struct ebuffer *ebuf)
 {
   struct floc defstart;
   long nlines = 0;
@@ -1343,9 +1334,7 @@ do_define (name, namelen, origin, ebuf)
    1 if following text should be ignored.  */
 
 static int
-conditional_line (line, flocp)
-     char *line;
-     const struct floc *flocp;
+conditional_line (char *line, const struct floc *flocp)
 {
   int notdef;
   char *cmdname;
@@ -1561,23 +1550,19 @@ conditional_line (line, flocp)
 /* Remove duplicate dependencies in CHAIN.  */
 
 static unsigned long
-dep_hash_1 (key)
-    const void *key;
+dep_hash_1 (const void *key)
 {
   return_STRING_HASH_1 (dep_name ((struct dep const *) key));
 }
 
 static unsigned long
-dep_hash_2 (key)
-    const void *key;
+dep_hash_2 (const void *key)
 {
   return_STRING_HASH_2 (dep_name ((struct dep const *) key));
 }
 
 static int
-dep_hash_cmp (x, y)
-    const void *x;
-    const void *y;
+dep_hash_cmp (const void *x, const void *y)
 {
   struct dep *dx = (struct dep *) x;
   struct dep *dy = (struct dep *) y;
@@ -1595,8 +1580,7 @@ dep_hash_cmp (x, y)
 
 
 void
-uniquize_deps (chain)
-     struct dep *chain;
+uniquize_deps (struct dep *chain)
 {
   struct hash_table deps;
   register struct dep **depp;
@@ -1638,13 +1622,9 @@ uniquize_deps (chain)
    variable value list.  */
 
 static void
-record_target_var (filenames, defn, two_colon, origin, exported, flocp)
-     struct nameseq *filenames;
-     char *defn;
-     int two_colon;
-     enum variable_origin origin;
-     int exported;
-     const struct floc *flocp;
+record_target_var (struct nameseq *filenames, char *defn, int two_colon,
+                   enum variable_origin origin, int exported,
+                   const struct floc *flocp)
 {
   struct nameseq *nextf;
   struct variable_set_list *global;
@@ -1742,19 +1722,10 @@ record_target_var (filenames, defn, two_colon, origin, exported, flocp)
    that are not incorporated into other data structures.  */
 
 static void
-record_files (filenames, pattern, pattern_percent, deps, cmds_started,
-	      commands, commands_idx, two_colon, have_sysv_atvar,
-              flocp, set_default)
-     struct nameseq *filenames;
-     char *pattern, *pattern_percent;
-     struct dep *deps;
-     unsigned int cmds_started;
-     char *commands;
-     unsigned int commands_idx;
-     int two_colon;
-     int have_sysv_atvar;
-     const struct floc *flocp;
-     int set_default;
+record_files (struct nameseq *filenames, char *pattern, char *pattern_percent,
+              struct dep *deps, unsigned int cmds_started, char *commands,
+              unsigned int commands_idx, int two_colon,
+              int have_sysv_atvar, const struct floc *flocp, int set_default)
 {
   struct nameseq *nextf;
   int implicit = 0;
@@ -2156,11 +2127,7 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
    one, or nil if there are none.  */
 
 char *
-find_char_unquote (string, stop1, stop2, blank)
-     char *string;
-     int stop1;
-     int stop2;
-     int blank;
+find_char_unquote (char *string, int stop1, int stop2, int blank)
 {
   unsigned int string_len = 0;
   register char *p = string;
@@ -2218,8 +2185,7 @@ find_char_unquote (string, stop1, stop2, blank)
 /* Search PATTERN for an unquoted %.  */
 
 char *
-find_percent (pattern)
-     char *pattern;
+find_percent (char *pattern)
 {
   return find_char_unquote (pattern, '%', 0, 0);
 }
@@ -2238,11 +2204,7 @@ find_percent (pattern)
    If STRIP is nonzero, strip `./'s off the beginning.  */
 
 struct nameseq *
-parse_file_seq (stringp, stopchar, size, strip)
-     char **stringp;
-     int stopchar;
-     unsigned int size;
-     int strip;
+parse_file_seq (char **stringp, int stopchar, unsigned int size, int strip)
 {
   register struct nameseq *new = 0;
   register struct nameseq *new1, *lastnew1;
@@ -2485,8 +2447,7 @@ parse_file_seq (stringp, stopchar, size, strip)
  */
 
 static unsigned long
-readstring (ebuf)
-     struct ebuffer *ebuf;
+readstring (struct ebuffer *ebuf)
 {
   char *p;
 
@@ -2522,8 +2483,7 @@ readstring (ebuf)
 }
 
 static long
-readline (ebuf)
-     struct ebuffer *ebuf;
+readline (struct ebuffer *ebuf)
 {
   char *p;
   char *end;
@@ -2647,11 +2607,7 @@ readline (ebuf)
    in a command list, etc.)  */
 
 static enum make_word_type
-get_next_mword (buffer, delim, startp, length)
-     char *buffer;
-     char *delim;
-     char **startp;
-     unsigned int *length;
+get_next_mword (char *buffer, char *delim, char **startp, unsigned int *length)
 {
   enum make_word_type wtype = w_bogus;
   char *p = buffer, *beg;
@@ -2815,8 +2771,7 @@ get_next_mword (buffer, delim, startp, length)
    from the arguments and the default list.  */
 
 void
-construct_include_path (arg_dirs)
-     char **arg_dirs;
+construct_include_path (char **arg_dirs)
 {
   register unsigned int i;
 #ifdef VAXC		/* just don't ask ... */
@@ -2912,8 +2867,7 @@ construct_include_path (arg_dirs)
    Return a newly malloc'd string or 0.  */
 
 char *
-tilde_expand (name)
-     char *name;
+tilde_expand (char *name)
 {
 #ifndef VMS
   if (name[1] == '/' || name[1] == '\0')
@@ -2994,9 +2948,7 @@ tilde_expand (name)
    that have room for additional info.  */
 
 struct nameseq *
-multi_glob (chain, size)
-     struct nameseq *chain;
-     unsigned int size;
+multi_glob (struct nameseq *chain, unsigned int size)
 {
   extern void dir_setup_glob ();
   register struct nameseq *new = 0;
diff --git a/remake.c b/remake.c
index 72c4d78..db1dd2c 100644
--- a/remake.c
+++ b/remake.c
@@ -79,9 +79,7 @@ static int library_search PARAMS ((char **lib, FILE_TIMESTAMP *mtime_ptr));
    `changed' member is nonzero is successfully made.  */
 
 int
-update_goal_chain (goals, makefiles)
-     register struct dep *goals;
-     int makefiles;
+update_goal_chain (struct dep *goals, int makefiles)
 {
   int t = touch_flag, q = question_flag, n = just_print_flag;
   unsigned int j = job_slots;
@@ -282,9 +280,7 @@ update_goal_chain (goals, makefiles)
    each is considered in turn.  */
 
 static int
-update_file (file, depth)
-     struct file *file;
-     unsigned int depth;
+update_file (struct file *file, unsigned int depth)
 {
   register int status = 0;
   register struct file *f;
@@ -341,9 +337,7 @@ update_file (file, depth)
 /* Consider a single `struct file' and update it as appropriate.  */
 
 static int
-update_file_1 (file, depth)
-     struct file *file;
-     unsigned int depth;
+update_file_1 (struct file *file, unsigned int depth)
 {
   register FILE_TIMESTAMP this_mtime;
   int noexist, must_make, deps_changed;
@@ -722,8 +716,7 @@ update_file_1 (file, depth)
    On return, FILE->update_status will no longer be -1 if it was.  */
 
 void
-notice_finished_file (file)
-     register struct file *file;
+notice_finished_file (struct file *file)
 {
   struct dep *d;
   int ran = file->command_state == cs_running;
@@ -837,11 +830,8 @@ notice_finished_file (file)
    Return nonzero if any updating failed.  */
 
 static int
-check_dep (file, depth, this_mtime, must_make_ptr)
-     struct file *file;
-     unsigned int depth;
-     FILE_TIMESTAMP this_mtime;
-     int *must_make_ptr;
+check_dep (struct file *file, unsigned int depth,
+           FILE_TIMESTAMP this_mtime, int *must_make_ptr)
 {
   struct dep *d;
   int dep_status = 0;
@@ -952,8 +942,7 @@ check_dep (file, depth, this_mtime, must_make_ptr)
 #define TOUCH_ERROR(call) return (perror_with_name (call, file->name), 1)
 
 static int
-touch_file (file)
-     register struct file *file;
+touch_file (struct file *file)
 {
   if (!silent_flag)
     message (0, "touch %s", file->name);
@@ -1003,8 +992,7 @@ touch_file (file)
    Return the status from executing FILE's commands.  */
 
 static void
-remake_file (file)
-     struct file *file;
+remake_file (struct file *file)
 {
   if (file->cmds == 0)
     {
@@ -1070,9 +1058,7 @@ remake_file (file)
    FILE.  */
 
 FILE_TIMESTAMP
-f_mtime (file, search)
-     register struct file *file;
-     int search;
+f_mtime (struct file *file, int search)
 {
   FILE_TIMESTAMP mtime;
 
@@ -1268,8 +1254,7 @@ f_mtime (file, search)
 /* Return the mtime of the file or archive-member reference NAME.  */
 
 static FILE_TIMESTAMP
-name_mtime (name)
-     register char *name;
+name_mtime (char *name)
 {
   struct stat st;
 
@@ -1289,9 +1274,7 @@ name_mtime (name)
    directories.  */
 
 static int
-library_search (lib, mtime_ptr)
-     char **lib;
-     FILE_TIMESTAMP *mtime_ptr;
+library_search (char **lib, FILE_TIMESTAMP *mtime_ptr)
 {
   static char *dirs[] =
     {
diff --git a/remote-cstms.c b/remote-cstms.c
index b058739..dae3535 100644
--- a/remote-cstms.c
+++ b/remote-cstms.c
@@ -48,22 +48,21 @@ static char *normalized_cwd;
 /* Call once at startup even if no commands are run.  */
 
 void
-remote_setup ()
+remote_setup (void)
 {
 }
 
 /* Called before exit.  */
 
 void
-remote_cleanup ()
+remote_cleanup (void)
 {
 }
 
 /* Return nonzero if the next job should be done remotely.  */
 
 int
-start_remote_job_p (first_p)
-     int first_p;
+start_remote_job_p (int first_p)
 {
   static int inited = 0;
   int status;
@@ -140,12 +139,8 @@ start_remote_job_p (first_p)
    if it is local (meaning *ID_PTR is a process ID).  */
 
 int
-start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
-     char **argv, **envp;
-     int stdin_fd;
-     int *is_remote;
-     int *id_ptr;
-     int *used_stdin;
+start_remote_job (char **argv, char **envp, int stdin_fd,
+                  int *is_remote, int *id_ptr, int *used_stdin)
 {
   char waybill[MAX_DATA_SIZE], msg[128];
   struct hostent *host;
@@ -275,9 +270,8 @@ start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
    0 if we would have to block and !BLOCK, or < 0 if there were none.  */
 
 int
-remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
-     int *exit_code_ptr, *signal_ptr, *coredump_ptr;
-     int block;
+remote_status (int *exit_code_ptr, int *signal_ptr, int *coredump_ptr,
+               int block)
 {
   return -1;
 }
@@ -286,7 +280,7 @@ remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
    If this notification is done by raising the child termination
    signal, do not block that signal.  */
 void
-block_remote_children ()
+block_remote_children (void)
 {
   return;
 }
@@ -295,16 +289,14 @@ block_remote_children ()
    If this is done by raising the child termination signal,
    do not unblock that signal.  */
 void
-unblock_remote_children ()
+unblock_remote_children (void)
 {
   return;
 }
 
 /* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
 int
-remote_kill (id, sig)
-     int id;
-     int sig;
+remote_kill (int id, int sig)
 {
   return -1;
 }
diff --git a/remote-stub.c b/remote-stub.c
index 69af397..73e6018 100644
--- a/remote-stub.c
+++ b/remote-stub.c
@@ -28,22 +28,21 @@ char *remote_description = 0;
 /* Call once at startup even if no commands are run.  */
 
 void
-remote_setup ()
+remote_setup (void)
 {
 }
 
 /* Called before exit.  */
 
 void
-remote_cleanup ()
+remote_cleanup (void)
 {
 }
 
 /* Return nonzero if the next job should be done remotely.  */
 
 int
-start_remote_job_p (first_p)
-     int first_p;
+start_remote_job_p (int first_p)
 {
   return 0;
 }
@@ -56,12 +55,8 @@ start_remote_job_p (first_p)
    nonzero if it is remote (meaning *ID_PTR is a process ID).  */
 
 int
-start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
-     char **argv, **envp;
-     int stdin_fd;
-     int *is_remote;
-     int *id_ptr;
-     int *used_stdin;
+start_remote_job (char **argv, char **envp, int stdin_fd,
+                  int *is_remote, int *id_ptr, int *used_stdin)
 {
   return -1;
 }
@@ -73,9 +68,8 @@ start_remote_job (argv, envp, stdin_fd, is_remote, id_ptr, used_stdin)
    0 if we would have to block and !BLOCK, or < 0 if there were none.  */
 
 int
-remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
-     int *exit_code_ptr, *signal_ptr, *coredump_ptr;
-     int block;
+remote_status (int *exit_code_ptr, int *signal_ptr, int *coredump_ptr,
+               int block)
 {
   errno = ECHILD;
   return -1;
@@ -85,7 +79,7 @@ remote_status (exit_code_ptr, signal_ptr, coredump_ptr, block)
    If this notification is done by raising the child termination
    signal, do not block that signal.  */
 void
-block_remote_children ()
+block_remote_children (void)
 {
   return;
 }
@@ -94,16 +88,14 @@ block_remote_children ()
    If this is done by raising the child termination signal,
    do not unblock that signal.  */
 void
-unblock_remote_children ()
+unblock_remote_children (void)
 {
   return;
 }
 
 /* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
 int
-remote_kill (id, sig)
-     int id;
-     int sig;
+remote_kill (int id, int sig)
 {
   return -1;
 }
diff --git a/rule.c b/rule.c
index e693c02..1d4a089 100644
--- a/rule.c
+++ b/rule.c
@@ -74,7 +74,7 @@ unsigned int maxsuffix;
    completely when appropriate.  */
 
 void
-count_implicit_rule_limits ()
+count_implicit_rule_limits (void)
 {
   char *name;
   unsigned int namelen;
@@ -182,9 +182,7 @@ count_implicit_rule_limits ()
    If SOURCE is nil, it means there should be no deps.  */
 
 static void
-convert_suffix_rule (target, source, cmds)
-     char *target, *source;
-     struct commands *cmds;
+convert_suffix_rule (char *target, char *source, struct commands *cmds)
 {
   char *targname, *targpercent, *depname;
   char **names, **percents;
@@ -241,7 +239,7 @@ convert_suffix_rule (target, source, cmds)
    are converted and added to the chain of pattern rules.  */
 
 void
-convert_to_pattern ()
+convert_to_pattern (void)
 {
   register struct dep *d, *d2;
   register struct file *f;
@@ -310,9 +308,7 @@ convert_to_pattern ()
    list.  Return nonzero if RULE is used; zero if not.  */
 
 int
-new_pattern_rule (rule, override)
-     register struct rule *rule;
-     int override;
+new_pattern_rule (struct rule *rule, int override)
 {
   register struct rule *r, *lastrule;
   register unsigned int i, j;
@@ -387,9 +383,7 @@ new_pattern_rule (rule, override)
    TERMINAL specifies what the `terminal' field of the rule should be.  */
 
 void
-install_pattern_rule (p, terminal)
-     struct pspec *p;
-     int terminal;
+install_pattern_rule (struct pspec *p, int terminal)
 {
   register struct rule *r;
   char *ptr;
@@ -439,8 +433,7 @@ install_pattern_rule (p, terminal)
    points to RULE.  */
 
 static void
-freerule (rule, lastrule)
-     register struct rule *rule, *lastrule;
+freerule (struct rule *rule, struct rule *lastrule)
 {
   struct rule *next = rule->next;
   register unsigned int i;
@@ -501,13 +494,9 @@ freerule (rule, lastrule)
    it may be freed.  */
 
 void
-create_pattern_rule (targets, target_percents,
-		     terminal, deps, commands, override)
-     char **targets, **target_percents;
-     int terminal;
-     struct dep *deps;
-     struct commands *commands;
-     int override;
+create_pattern_rule (char **targets, char **target_percents,
+		     int terminal, struct dep *deps,
+                     struct commands *commands, int override)
 {
   register struct rule *r = (struct rule *) xmalloc (sizeof (struct rule));
   register unsigned int max_targets, i;
@@ -551,8 +540,7 @@ create_pattern_rule (targets, target_percents,
 /* Create a new pattern-specific variable struct.  */
 
 struct pattern_var *
-create_pattern_var (target, suffix)
-     char *target, *suffix;
+create_pattern_var (char *target, char *suffix)
 {
   register struct pattern_var *p = 0;
   unsigned int len = strlen(target);
@@ -583,8 +571,7 @@ create_pattern_var (target, suffix)
 /* Look up a target in the pattern-specific variable list.  */
 
 struct pattern_var *
-lookup_pattern_var (target)
-     char *target;
+lookup_pattern_var (char *target)
 {
   struct pattern_var *p;
   unsigned int targlen = strlen(target);
@@ -623,8 +610,7 @@ lookup_pattern_var (target)
 /* Print the data base of rules.  */
 
 static void			/* Useful to call from gdb.  */
-print_rule (r)
-     struct rule *r;
+print_rule (struct rule *r)
 {
   register unsigned int i;
   register struct dep *d;
@@ -649,7 +635,7 @@ print_rule (r)
 }
 
 void
-print_rule_data_base ()
+print_rule_data_base (void)
 {
   register unsigned int rules, terminal;
   register struct rule *r;
diff --git a/signame.c b/signame.c
index 051d544..432c312 100644
--- a/signame.c
+++ b/signame.c
@@ -63,10 +63,7 @@ static int sig_table_nelts = 0;
 /* Enter signal number NUMBER into the tables with ABBREV and NAME.  */
 
 static void
-init_sig (number, abbrev, name)
-     int number;
-     const char *abbrev;
-     const char *name;
+init_sig (int number, const char *abbrev, const char *name)
 {
   /* If this value is ever greater than NSIG it seems like it'd be a bug in
      the system headers, but... better safe than sorry.  We know, for
@@ -83,7 +80,7 @@ init_sig (number, abbrev, name)
 }
 
 static int
-signame_init ()
+signame_init (void)
 {
   int i;
 
@@ -233,8 +230,7 @@ signame_init ()
 
 
 char *
-strsignal (signal)
-     int signal;
+strsignal (int signal)
 {
   static char buf[] = "Signal 12345678901234567890";
 
diff --git a/variable.c b/variable.c
index bb8d810..fe8c4c8 100644
--- a/variable.c
+++ b/variable.c
@@ -33,25 +33,21 @@ Boston, MA 02111-1307, USA.  */
 /* Hash table of all global variable definitions.  */
 
 static unsigned long
-variable_hash_1 (keyv)
-    const void *keyv;
+variable_hash_1 (const void *keyv)
 {
   struct variable const *key = (struct variable const *) keyv;
   return_STRING_N_HASH_1 (key->name, key->length);
 }
 
 static unsigned long
-variable_hash_2 (keyv)
-    const void *keyv;
+variable_hash_2 (const void *keyv)
 {
   struct variable const *key = (struct variable const *) keyv;
   return_STRING_N_HASH_2 (key->name, key->length);
 }
 
 static int
-variable_hash_cmp (xv, yv)
-    const void *xv;
-    const void *yv;
+variable_hash_cmp (const void *xv, const void *yv)
 {
   struct variable const *x = (struct variable const *) xv;
   struct variable const *y = (struct variable const *) yv;
@@ -79,7 +75,7 @@ struct variable_set_list *current_variable_set_list = &global_setlist;
 /* Implement variables.  */
 
 void
-init_hash_global_variable_set ()
+init_hash_global_variable_set (void)
 {
   hash_init (&global_variable_set.table, VARIABLE_BUCKETS,
 	     variable_hash_1, variable_hash_2, variable_hash_cmp);
@@ -93,14 +89,10 @@ init_hash_global_variable_set ()
    that it should be recursively re-expanded.  */
 
 struct variable *
-define_variable_in_set (name, length, value, origin, recursive, set, flocp)
-     const char *name;
-     unsigned int length;
-     char *value;
-     enum variable_origin origin;
-     int recursive;
-     struct variable_set *set;
-     const struct floc *flocp;
+define_variable_in_set (const char *name, unsigned int length,
+                        char *value, enum variable_origin origin,
+                        int recursive, struct variable_set *set,
+                        const struct floc *flocp)
 {
   struct variable *v;
   struct variable **var_slot;
@@ -190,8 +182,7 @@ define_variable_in_set (name, length, value, origin, recursive, set, flocp)
 #define EXPANSION_INCREMENT(_l)  ((((_l) / 500) + 1) * 500)
 
 static struct variable *
-handle_special_var (var)
-     struct variable *var;
+handle_special_var (struct variable *var)
 {
   static unsigned long last_var_count = 0;
 
@@ -275,9 +266,7 @@ handle_special_var (var)
    on the variable, or nil if no such variable is defined.  */
 
 struct variable *
-lookup_variable (name, length)
-     const char *name;
-     unsigned int length;
+lookup_variable (const char *name, unsigned int length)
 {
   const struct variable_set_list *setlist;
   struct variable var_key;
@@ -361,10 +350,8 @@ lookup_variable (name, length)
    on the variable, or nil if no such variable is defined.  */
 
 struct variable *
-lookup_variable_in_set (name, length, set)
-     const char *name;
-     unsigned int length;
-     const struct variable_set *set;
+lookup_variable_in_set (const char *name, unsigned int length,
+                        const struct variable_set *set)
 {
   struct variable var_key;
 
@@ -384,9 +371,7 @@ lookup_variable_in_set (name, length, set)
    since the pattern variable might not have been defined yet.  */
 
 void
-initialize_file_variables (file, reading)
-     struct file *file;
-     int reading;
+initialize_file_variables (struct file *file, int reading)
 {
   register struct variable_set_list *l = file->variables;
 
@@ -450,8 +435,7 @@ initialize_file_variables (file, reading)
    and free all its storage.  */
 
 static void
-free_variable_name_and_value (item)
-     void *item;
+free_variable_name_and_value (const void *item)
 {
   struct variable *v = (struct variable *) item;
   free (v->name);
@@ -459,7 +443,7 @@ free_variable_name_and_value (item)
 }
 
 void
-pop_variable_scope ()
+pop_variable_scope (void)
 {
   struct variable_set_list *setlist = current_variable_set_list;
   struct variable_set *set = setlist->set;
@@ -474,7 +458,7 @@ pop_variable_scope ()
 }
 
 struct variable_set_list *
-create_new_variable_set ()
+create_new_variable_set (void)
 {
   register struct variable_set_list *setlist;
   register struct variable_set *set;
@@ -494,7 +478,7 @@ create_new_variable_set ()
 /* Create a new variable set and push it on the current setlist.  */
 
 struct variable_set_list *
-push_new_variable_scope ()
+push_new_variable_scope (void)
 {
   return (current_variable_set_list = create_new_variable_set());
 }
@@ -502,8 +486,8 @@ push_new_variable_scope ()
 /* Merge SET1 into SET0, freeing unused storage in SET1.  */
 
 static void
-merge_variable_sets (to_set, from_set)
-     struct variable_set *to_set, *from_set;
+merge_variable_sets (struct variable_set *to_set,
+                     struct variable_set *from_set)
 {
   struct variable **from_var_slot = (struct variable **) from_set->table.ht_vec;
   struct variable **from_var_end = from_var_slot + from_set->table.ht_size;
@@ -528,8 +512,8 @@ merge_variable_sets (to_set, from_set)
 /* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
 
 void
-merge_variable_set_lists (setlist0, setlist1)
-     struct variable_set_list **setlist0, *setlist1;
+merge_variable_set_lists (struct variable_set_list **setlist0,
+                          struct variable_set_list *setlist1)
 {
   register struct variable_set_list *list0 = *setlist0;
   struct variable_set_list *last0 = 0;
@@ -558,7 +542,7 @@ merge_variable_set_lists (setlist0, setlist1)
    of their structures so we can change their values quickly.  */
 
 void
-define_automatic_variables ()
+define_automatic_variables (void)
 {
 #ifdef WINDOWS32
   extern char* default_shell;
@@ -661,8 +645,7 @@ int export_all_variables;
    The child's MAKELEVEL variable is incremented.  */
 
 char **
-target_environment (file)
-     struct file *file;
+target_environment (struct file *file)
 {
   struct variable_set_list *set_list;
   register struct variable_set_list *s;
@@ -794,13 +777,9 @@ target_environment (file)
    See the try_variable_definition() function for details on the parameters. */
 
 struct variable *
-do_variable_definition (flocp, varname, value, origin, flavor, target_var)
-     const struct floc *flocp;
-     const char *varname;
-     char *value;
-     enum variable_origin origin;
-     enum variable_flavor flavor;
-     int target_var;
+do_variable_definition (const struct floc *flocp, const char *varname,
+                        char *value, enum variable_origin origin,
+                        enum variable_flavor flavor, int target_var)
 {
   char *p, *alloc_value = NULL;
   struct variable *v;
@@ -1026,11 +1005,8 @@ do_variable_definition (flocp, varname, value, origin, flavor, target_var)
    returned.  */
 
 struct variable *
-try_variable_definition (flocp, line, origin, target_var)
-     const struct floc *flocp;
-     char *line;
-     enum variable_origin origin;
-     int target_var;
+try_variable_definition (const struct floc *flocp, char *line,
+                         enum variable_origin origin, int target_var)
 {
   register int c;
   register char *p = line;
@@ -1128,10 +1104,10 @@ try_variable_definition (flocp, line, origin, target_var)
 /* Print information for variable V, prefixing it with PREFIX.  */
 
 static void
-print_variable (v, prefix)
-     register struct variable *v;
-     char *prefix;
+print_variable (const void *item, void *arg)
 {
+  const struct variable *v = (struct variable *) item;
+  const char *prefix = (char *) arg;
   const char *origin;
 
   switch (v->origin)
@@ -1202,9 +1178,7 @@ print_variable (v, prefix)
    the actual variable definitions (everything else is comments).  */
 
 void
-print_variable_set (set, prefix)
-     register struct variable_set *set;
-     char *prefix;
+print_variable_set (struct variable_set *set, char *prefix)
 {
   hash_map_arg (&set->table, print_variable, prefix);
 
@@ -1217,7 +1191,7 @@ print_variable_set (set, prefix)
 /* Print the data base of variables.  */
 
 void
-print_variable_data_base ()
+print_variable_data_base (void)
 {
   puts (_("\n# Variables\n"));
 
@@ -1228,8 +1202,7 @@ print_variable_data_base ()
 /* Print all the local variables of FILE.  */
 
 void
-print_file_variables (file)
-     struct file *file;
+print_file_variables (struct file *file)
 {
   if (file->variables != 0)
     print_variable_set (file->variables->set, "# ");
@@ -1237,27 +1210,27 @@ print_file_variables (file)
 
 #ifdef WINDOWS32
 void
-sync_Path_environment(void)
+sync_Path_environment (void)
 {
-    char* path = allocated_variable_expand("$(Path)");
-    static char* environ_path = NULL;
-
-    if (!path)
-        return;
-
-    /*
-     * If done this before, don't leak memory unnecessarily.
-     * Free the previous entry before allocating new one.
-     */
-    if (environ_path)
-        free(environ_path);
-
-    /*
-     * Create something WINDOWS32 world can grok
-     */
-    convert_Path_to_windows32(path, ';');
-    environ_path = concat("Path", "=", path);
-    putenv(environ_path);
-    free(path);
+  char *path = allocated_variable_expand ("$(Path)");
+  static char *environ_path = NULL;
+
+  if (!path)
+    return;
+
+  /*
+   * If done this before, don't leak memory unnecessarily.
+   * Free the previous entry before allocating new one.
+   */
+  if (environ_path)
+    free (environ_path);
+
+  /*
+   * Create something WINDOWS32 world can grok
+   */
+  convert_Path_to_windows32 (path, ';');
+  environ_path = concat ("Path", "=", path);
+  putenv (environ_path);
+  free (path);
 }
 #endif
diff --git a/vmsfunctions.c b/vmsfunctions.c
index f6708cc..48cb9a5 100644
--- a/vmsfunctions.c
+++ b/vmsfunctions.c
@@ -16,8 +16,7 @@
 #ifdef HAVE_VMSDIR_H
 
 DIR *
-opendir (dspec)
-     char *dspec;
+opendir (char *dspec)
 {
   struct DIR *dir  = (struct DIR *)xmalloc (sizeof (struct DIR));
   struct NAM *dnam = (struct NAM *)xmalloc (sizeof (struct NAM));
@@ -60,8 +59,7 @@ opendir (dspec)
   while (0)
 
 struct direct *
-readdir (dir)
-     DIR * dir;
+readdir (DIR *dir)
 {
   struct FAB *dfab = &dir->fab;
   struct NAM *dnam = (struct NAM *)(dfab->fab$l_nam);
@@ -97,8 +95,7 @@ readdir (dir)
 }
 
 int
-closedir (dir)
-     DIR *dir;
+closedir (DIR *dir)
 {
   if (dir != NULL)
     {
@@ -115,8 +112,7 @@ closedir (dir)
 #endif /* compiled for OpenVMS prior to V7.x */
 
 char *
-getwd (cwd)
-     char *cwd;
+getwd (char *cwd)
 {
   static char buf[512];
 
@@ -127,9 +123,7 @@ getwd (cwd)
 }
 
 int
-vms_stat (name, buf)
-     char *name;
-     struct stat *buf;
+vms_stat (char *name, struct stat *buf)
 {
   int status;
   int i;
@@ -226,8 +220,7 @@ vms_stat (name, buf)
 }
 
 char *
-cvt_time (tval)
-     unsigned long tval;
+cvt_time (unsigned long tval)
 {
   static long int date[2];
   static char str[27];
@@ -247,9 +240,7 @@ cvt_time (tval)
 }
 
 int
-strcmpi (s1, s2)
-    const char *s1;
-    const char *s2;
+strcmpi (const char *s1, const char *s2)
 {
   while (*s1 != '\0' && toupper(*s1) == toupper(*s2))
     {
diff --git a/vmsify.c b/vmsify.c
index f7871bb..d8d3d85 100644
--- a/vmsify.c
+++ b/vmsify.c
@@ -196,9 +196,7 @@ enum namestate { N_START, N_DEVICE, N_OPEN, N_DOT, N_CLOSED, N_DONE };
 */
 
 char *
-vmsify (name, type)
-    char *name;
-    int type;
+vmsify (char *name, int type)
 {
 /* max 255 device
    max 39 directory
diff --git a/vpath.c b/vpath.c
index 065779b..18aaaa9 100644
--- a/vpath.c
+++ b/vpath.c
@@ -157,8 +157,7 @@ build_vpath_lists ()
    VPATHS chain.  */
 
 void
-construct_vpath_list (pattern, dirpath)
-     char *pattern, *dirpath;
+construct_vpath_list (char *pattern, char *dirpath)
 {
   register unsigned int elem;
   register char *p;
@@ -317,9 +316,7 @@ construct_vpath_list (pattern, dirpath)
    in.  If it is found, return 1.  Otherwise we return 0.  */
 
 int
-gpath_search (file, len)
-     char *file;
-     int len;
+gpath_search (char *file, int len)
 {
   register char **gp;
 
@@ -338,9 +335,7 @@ gpath_search (file, len)
    Otherwise we return 0.  */
 
 int
-vpath_search (file, mtime_ptr)
-     char **file;
-     FILE_TIMESTAMP *mtime_ptr;
+vpath_search (char **file, FILE_TIMESTAMP *mtime_ptr)
 {
   register struct vpath *v;
 
@@ -375,10 +370,8 @@ vpath_search (file, mtime_ptr)
    Otherwise we return 0.  */
 
 static int
-selective_vpath_search (path, file, mtime_ptr)
-     struct vpath *path;
-     char **file;
-     FILE_TIMESTAMP *mtime_ptr;
+selective_vpath_search (struct vpath *path, char **file,
+                        FILE_TIMESTAMP *mtime_ptr)
 {
   int not_target;
   char *name, *n;
@@ -545,7 +538,7 @@ selective_vpath_search (path, file, mtime_ptr)
 /* Print the data base of VPATH search paths.  */
 
 void
-print_vpath_data_base ()
+print_vpath_data_base (void)
 {
   register unsigned int nvpaths;
   register struct vpath *v;
-- 
cgit v1.0-41-gc330

