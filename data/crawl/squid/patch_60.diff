@@ -1,3 +1,36 @@
+Changes to squid-4.0.12 (01 Jul 2016):
+
+	- Regression Fix: shell issues with require_smblib definition
+	- Regression Bug 4532: pid_filename not working as documented
+	- Regression Bug 4504: Too many WARNING: Ignoring error setting CA certificate locations
+	- Bug 4516: security_file_certgen man page update
+	- Bug 4446: undefined reference to 'libecap::Name::Name'
+	- Bug 4376: clang cannot build Squid eCAP code
+	- HTTP/1.1: Update all stored headers on 304 revalidation
+	- TLS: Authority Key Identifier certificate extension
+	- Add a script to find kid-specific cache.log lines
+	- Cleanup cppunit detection and use
+	- ... and several performance improvements
+	- ... and some unit test updates
+	- ... and all fixes from 3.5.20
+
+Changes to squid-4.0.11 (09 Jun 2016):
+
+	- Bug 4517: error: comparison between signed and unsigned integer
+	- Bug 4492: chunked parser needs to accept BWS after chunk size
+	- HTTP/1.1: allow chunking the last HTTP response on a connection
+	- HTTP/1.1: unfold mime header blocks
+	- TLS: fast SNI peek
+	- TLS: check for SSL_CIPHER_get_id() support required in adjustSSL()
+	- TLS: never enable OPENSSL_HELLO_OVERWRITE_HACK automatically
+	- squidclient: improve shell-escape support in -H option
+	- Do not allow low-level debugging to hide important/critical messages
+	- Replace new/delete operators using modern C++ rules
+	- Remove ie_refresh configuration option
+	- Deprecating SMB LanMan helpers
+	- Mark refresh-waiting transactions with REFRESH
+	- ... and some code cleanup and polishing
+
 Changes to squid-4.0.10 (06 May 2016):
 
 	- Accumulate fewer unknown-size responses to avoid overwhelming disks.
@@ -155,6 +188,25 @@ Changes to squid-4.0.1 (14 Oct 2015):
 	- ... and many documentation changes
 	- ... and much code cleanup and polishing
 
+Changes to squid-3.5.20 (01 Jul 2016):
+
+	- Bug 4523: smblib compile fails on NetBSD
+	- Bug 4485: off-by-one out-of-bounds Parser::Tokenizer::int64() read errors
+	- Bug 3579: assertion failed 'MemPools[type]' from dst_as ACL
+	- Fix icons loading speed
+	- Fix OpenSSL detection on FreeBSD
+	- Fix assertion failed: Write.cc:38: 'fd_table[conn->fd].flags.open'
+	- Fix SEGFAULT parsing malformed adaptation service configuration
+	- Fix ConnStateData::In::maybeMakeSpaceAvailable() logic
+	- Do not override user defined -std option
+	- Do not allow low-level debugging to hide important/critical messages
+	- Do not make bogus recvmsg(2) calls when closing UDS sockets
+	- Support unified EUI format code in external_acl_type
+
+Changes to squid-3.5.19 (09 May 2016):
+
+	- Regression Bug 4515: interception proxy hangs
+
 Changes to squid-3.5.18 (06 May 2016):
 
 	- Bug 4510: stale comment about 32KB limit on shared memory cache entries
@@ -48,7 +48,7 @@ install-pinger:
 check: have-cppunit check-recursive
 
 have-cppunit:
-	@if test "$(SQUID_CPPUNIT_INC)$(SQUID_CPPUNIT_LA)$(SQUID_CPPUNIT_LIBS)" = "" ; then \
+	@if test "$(LIBCPPUNIT_CFLAGS)$(LIBCPPUNIT_LIBS)" = "" ; then \
 		echo "FATAL: 'make check' requires cppunit and cppunit development packages. They do not appear to be installed." ; \
 		exit 1 ; \
 	fi
@@ -94,7 +94,7 @@ TESTS += testPreCompiler
 testPreCompiler_SOURCES= \
 	testPreCompiler.h \
 	testPreCompiler.cc
-testPreCompiler_LDADD= $(SQUID_CPPUNIT_LA) $(SQUID_CPPUNIT_LIBS)
+testPreCompiler_LDADD= $(LIBCPPUNIT_LIBS)
 testPreCompiler_LDFLAGS=
 
 # os/ subdir prevents us using src/TestHeaders.am
@@ -28,11 +28,6 @@
 
 #include "compat/cmsg.h"
 
-// MacOS GCC 4.0.1 and 4.2.1 supply __GNUC_GNU_INLINE__ but do not actually define  __attribute__((gnu_inline))
-#if defined(__cplusplus) && !defined(_SQUID_EXTERNNEW_)
-#define _SQUID_EXTERNNEW_ extern inline
-#endif
-
 #endif /* _SQUID_APPLE_ */
 #endif /* SQUID_OS_MACOSX_H */
 
@@ -25,15 +25,6 @@
 #define _ABI_SOURCE
 #endif /* USE_ASYNC_IO */
 
-#if defined(__cplusplus) && !defined(_SQUID_EXTERNNEW_) && !defined(_GNUC_)
-/*
- * The gcc compiler treats extern inline functions as being extern,
- * while the SGI MIPSpro compilers treat them as inline. To get equivalent
- * behavior, remove the inline keyword.
- */
-#define _SQUID_EXTERNNEW_ extern
-#endif
-
 #endif /* _SQUID_SGI_ */
 #endif /* SQUID_OS_SGI_H */
 
@@ -58,13 +58,6 @@ SQUIDCEXTERN int getpagesize(void);
 SQUIDCEXTERN int gethostname(char *, int);
 #endif
 
-/*
- * SunPro CC handles extern inline as inline, PLUS extern symbols.
- */
-#if !defined(_SQUID_EXTERNNEW_) && defined(__SUNPRO_CC)
-#define _SQUID_EXTERNNEW_ extern
-#endif
-
 /*
  * SunStudio CC does not define C++ portability API __FUNCTION__
  */
@@ -5,7 +5,7 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-AC_INIT([Squid Web Proxy],[4.0.10-BZR],[http://bugs.squid-cache.org/],[squid])
+AC_INIT([Squid Web Proxy],[4.0.12-BZR],[http://bugs.squid-cache.org/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
 AC_CONFIG_AUX_DIR(cfgaux)
@@ -115,10 +115,11 @@ AC_PATH_PROG(LN, ln, cp)
 AC_PATH_PROG(CHMOD, chmod, $FALSE)
 AC_PATH_PROG(TR, tr, $FALSE)
 AC_PATH_PROG(RM, rm, $FALSE)
-AC_PATH_PROG(CPPUNITCONFIG, cppunit-config, false)
 dnl Libtool 2.2.6 requires: rm -f
 RM="$RM -f"
 
+PKG_PROG_PKG_CONFIG
+
 AC_PATH_PROG(PERL, perl, none)
 if test "x$ac_cv_path_PERL" = "xnone"; then
   AC_MSG_FAILURE([Perl is required to compile Squid. Please install Perl and then re-run configure ])
@@ -728,17 +729,16 @@ done
 AC_MSG_NOTICE([IO Modules built: $DISK_MODULES])
 AC_SUBST(DISK_MODULES)
 AC_SUBST(DISK_LIBS)
-AM_CONDITIONAL([ENABLE_DISKIO_AIO], [test "x$squid_disk_module_candidates_AIO" = "xyes"])
+AM_CONDITIONAL(ENABLE_DISKIO_AIO, test "x$squid_disk_module_candidates_AIO" = "xyes")
 AC_SUBST(AIOLIB)
-AM_CONDITIONAL([ENABLE_WIN32_AIO], [test "x$squid_disk_module_candidates_AIO" = "xyes" -a "x$ENABLE_WIN32_AIO" = "x1"])
-AM_CONDITIONAL([ENABLE_DISKIO_BLOCKING], [test "x$squid_disk_module_candidates_Blocking" = "xyes"])
-AM_CONDITIONAL([ENABLE_DISKIO_DISKDAEMON], [test "x$squid_disk_module_candidates_DiskDaemon" = "xyes"])
-AM_CONDITIONAL([ENABLE_DISKIO_DISKTHREADS], [test "x$squid_disk_module_candidates_DiskThreads" = "xyes"])
+AM_CONDITIONAL(ENABLE_WIN32_AIO, test "x$squid_disk_module_candidates_AIO" = "xyes" -a "x$ENABLE_WIN32_AIO" = "x1")
+AM_CONDITIONAL(ENABLE_DISKIO_BLOCKING, test "x$squid_disk_module_candidates_Blocking" = "xyes")
+AM_CONDITIONAL(ENABLE_DISKIO_DISKDAEMON, test "x$squid_disk_module_candidates_DiskDaemon" = "xyes")
+AM_CONDITIONAL(ENABLE_DISKIO_DISKTHREADS, test "x$squid_disk_module_candidates_DiskThreads" = "xyes")
 AC_SUBST(LIBPTHREADS)
-AM_CONDITIONAL([ENABLE_WIN32_AIOPS], [test "x$squid_disk_module_candidates_DiskThreads" = "xyes" -a "x$ENABLE_WIN32_AIOPS" = "x1"])
-AM_CONDITIONAL([ENABLE_DISKIO_IPCIO], [test "x$squid_disk_module_candidates_IpcIo" = "xyes"])
-AM_CONDITIONAL([ENABLE_DISKIO_MMAPPED], [test "x$squid_disk_module_candidates_Mmapped" = "xyes"])
-
+AM_CONDITIONAL(ENABLE_WIN32_AIOPS, test "x$squid_disk_module_candidates_DiskThreads" = "xyes" -a "x$ENABLE_WIN32_AIOPS" = "x1")
+AM_CONDITIONAL(ENABLE_DISKIO_IPCIO, test "x$squid_disk_module_candidates_IpcIo" = "xyes")
+AM_CONDITIONAL(ENABLE_DISKIO_MMAPPED, test "x$squid_disk_module_candidates_Mmapped" = "xyes")
 
 dnl Check what Storage formats are wanted.
 dnl This version will error out with a message saying why if a required DiskIO is missing.
@@ -807,8 +807,8 @@ for fs in $squid_storeio_module_candidates none; do
     esac
 done
 
-AM_CONDITIONAL(HAVE_FS_UFS,[test "x$squid_do_build_ufs" = "xtrue" ])
-AM_CONDITIONAL(HAVE_FS_ROCK,[test "x$squid_do_build_rock" = "xtrue" ])
+AM_CONDITIONAL(ENABLE_FS_UFS, test "x$squid_do_build_ufs" = "xtrue")
+AM_CONDITIONAL(ENABLE_FS_ROCK, test "x$squid_do_build_rock" = "xtrue")
 dnl hack: need to define those even if not used in the build system to
 dnl make sure that global FS objects are linked to the squid binary.
 AH_TEMPLATE(HAVE_FS_UFS, "Define to 1 if ufs filesystem module is build")
@@ -955,10 +955,10 @@ if test "x$squid_opt_use_esi" = "xyes" -a "x$with_libxml2" != "xno" ; then
   fi
 fi
 
-AM_CONDITIONAL(USE_ESI, test "x$squid_opt_use_esi" = "xyes")
-AM_CONDITIONAL(HAVE_LIBEXPAT, test "$HAVE_LIBEXPAT" = 1)
+AM_CONDITIONAL(ENABLE_ESI, test "x$squid_opt_use_esi" = "xyes")
+AM_CONDITIONAL(ENABLE_LIBEXPAT, test "$HAVE_LIBEXPAT" = 1)
 AC_SUBST(EXPATLIB)
-AM_CONDITIONAL(HAVE_LIBXML2, test "$HAVE_LIBXML2" = 1)
+AM_CONDITIONAL(ENABLE_LIBXML2, test "$HAVE_LIBXML2" = 1)
 AC_SUBST(XMLLIB)
 
 # icap argument handling
@@ -967,14 +967,8 @@ AC_ARG_ENABLE(icap-client,
   SQUID_YESNO([$enableval],[Unrecognized argument to --disable-icap-client: $enableval])
 ])
 SQUID_DEFINE_BOOL(ICAP_CLIENT,${enable_icap_client:=yes}, [Enable ICAP client features in Squid])
-AM_CONDITIONAL(USE_ICAP_CLIENT, [test "x$enable_icap_client" != "xno" ])
-if test "x$enable_icap_client" != "xno" ; then
-  ICAP_LIBS="icap/libicap.la"
-  squid_opt_use_adaptation=yes
-else
-  ICAP_LIBS=""
-fi
-AC_SUBST(ICAP_LIBS)
+AS_IF(test "x$enable_icap_client" != "xno", squid_opt_use_adaptation="yes")
+AM_CONDITIONAL(ENABLE_ICAP_CLIENT, test "x$enable_icap_client" != "xno")
 
 squid_opt_use_ecap=1
 AC_MSG_CHECKING(whether to support eCAP)
@@ -991,9 +985,6 @@ AC_MSG_RESULT([$squid_opt_use_ecap, explicitly])
     ]
 )
 
-dnl Necessary if the first PKG_CHECK_MODULES call is conditional
-PKG_PROG_PKG_CONFIG
-
 dnl Perform configuration consistency checks for eCAP
 if test "x$squid_opt_use_ecap" != "xno";
 then
@@ -1012,32 +1003,41 @@ then
   else
     AC_MSG_NOTICE([eCAP support requires pkg-config to verify the correct library version. Trouble may follow.])
   fi
-fi
 
-AM_CONDITIONAL(USE_ECAP, test "x$squid_opt_use_ecap" = "xyes")
-if test "x$squid_opt_use_ecap" = "xyes";
-then
-    AC_DEFINE(USE_ECAP,1,[Enable eCAP support])
-    ECAP_LIBS="ecap/libecapsquid.la"
+  SQUID_STATE_SAVE(squid_ecap_state)
+  AC_MSG_CHECKING([whether -lecap will link])
+  CXXFLAGS="$CXXFLAGS $EXT_LIBECAP_CFLAGS"
+  LIBS="$LIBS $EXT_LIBECAP_LIBS"
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <libecap/common/names.h>]],[[
+    const libecap::Name test("test", libecap::Name::NextId());
+  ]])],[
+    AC_MSG_RESULT(yes)
     squid_opt_use_adaptation=yes
-else
-    AC_DEFINE(USE_ECAP,0,[Disable eCAP support])
-    ECAP_LIBS=""
+  ],[
+    AC_MSG_RESULT(no)
+    AS_IF(
+      test "x$squid_opt_use_ecap" = "xyes", AC_MSG_ERROR([eCAP library will not link.
+                  You may need to rebuild libecap using the same version of GCC as Squid.
+                  There have been breaking ABI changes in the libstdc++ STL with GCC 5.]),
+
+    [AC_MSG_NOTICE([eCAP library will not link.
+                  You may need to rebuild libecap using the same version of GCC as Squid.
+                  There have been breaking ABI changes in the libstdc++ STL with GCC 5.])
+      squid_opt_use_ecap="no"
+    ])
+  ])
+  SQUID_STATE_ROLLBACK(squid_ecap_state)
 fi
-dnl convenience library
-AC_SUBST(ECAP_LIBS)
-
+SQUID_DEFINE_BOOL(USE_ECAP,${squid_opt_use_ecap:=no},[Whether to use eCAP support])
+AM_CONDITIONAL(ENABLE_ECAP, test "x$squid_opt_use_ecap" = "xyes")
 
 dnl enable adaptation if requested by specific adaptation mechanisms
-AM_CONDITIONAL(USE_ADAPTATION, test "x$squid_opt_use_adaptation" = "xyes")
-if test "x$squid_opt_use_adaptation" = "xyes"
-then
-    AC_DEFINE(USE_ADAPTATION,1,[common adaptation support])
+ADAPTATION_LIBS=""
+if test "x$squid_opt_use_adaptation" = "xyes"; then
     ADAPTATION_LIBS="adaptation/libadaptation.la"
-else
-    AC_DEFINE(USE_ADAPTATION,0,[common adaptation support])
-    ADAPTATION_LIBS=""
 fi
+SQUID_DEFINE_BOOL(USE_ADAPTATION,${squid_opt_use_adaptation:=no}, [common adaptation support])
+AM_CONDITIONAL(ENABLE_ADAPTATION, test "x$squid_opt_use_adaptation" = "xyes")
 AC_SUBST(ADAPTATION_LIBS)
 
 test "x$squid_host_os" = "xmingw" && enable_wccp=no
@@ -1154,7 +1154,7 @@ AC_SUBST(EUILIB)
 AC_MSG_NOTICE([EUI (MAC address) controls enabled: $enable_eui])
 SQUID_DEFINE_BOOL(USE_SQUID_EUI,$enable_eui,
    [Define this to include code which lets you use ethernet addresses. This code uses API initially defined in 4.4-BSD.])
-AM_CONDITIONAL(USE_SQUID_EUI, [test "x$enable_eui" = "xyes" ])
+AM_CONDITIONAL(ENABLE_EUI, [test "x$enable_eui" = "xyes" ])
 
 
 AC_ARG_ENABLE(htcp,
@@ -1843,9 +1843,8 @@ fi
 AC_MSG_NOTICE([$KRB5_FLAVOUR Kerberos library support: ${with_krb5:=no} ${LIB_KRB5_PATH} ${LIB_KRB5_LIBS}])
 AC_SUBST(KRB5INCS)
 AC_SUBST(KRB5LIBS)
-AM_CONDITIONAL(HAVE_SPNEGO, test x"$squid_cv_have_spnego" = x"yes" )
 
-dnl On MinGW OpenLDAP is not available, so LDAP helpers can be linked 
+dnl On MinGW OpenLDAP is not available, so LDAP helpers can be linked
 dnl only with Windows LDAP libraries using -lwldap32
 case "$squid_host_os" in
 	mingw)
@@ -2429,7 +2428,7 @@ AC_ARG_ENABLE(leakfinder,
 AC_MSG_NOTICE([Leak Finder enabled: ${enable_leakfinder:=no}])
 SQUID_DEFINE_BOOL(USE_LEAKFINDER,$enable_leakfinder,
   [Enable code for assisting in finding memory leaks. Not for the faint of heart])
-AM_CONDITIONAL(MAKE_LEAKFINDER, [test "x$enable_leakfinder" = "xyes"])
+AM_CONDITIONAL(ENABLE_LEAKFINDER, [test "x$enable_leakfinder" = "xyes"])
 
 
 AC_ARG_ENABLE(follow-x-forwarded-for,
@@ -2483,6 +2482,7 @@ AC_MSG_NOTICE([Authentication support enabled: ${enable_auth:=yes}])
 SQUID_DEFINE_BOOL(USE_AUTH,$enable_auth,[Enable support for authentication])
 AM_CONDITIONAL(ENABLE_AUTH, test "x$enable_auth" != "xno")
 AUTH_MODULES=""
+require_smblib="no"
 
 AC_ARG_ENABLE(auth-basic,
   AS_HELP_STRING([--enable-auth-basic="list of helpers"],
@@ -2542,6 +2542,7 @@ for module in $AUTH_MODULES; do
 done
 AC_SUBST(AUTH_MODULES)
 AC_SUBST(AUTH_LIBS_TO_BUILD)
+AM_CONDITIONAL(ENABLE_SMBLIB, test "x$require_smblib" = "xyes")
 
 dnl Select logging daemon helpers to build
 AC_ARG_ENABLE(log-daemon-helpers,
@@ -2722,45 +2723,29 @@ SQUID_DEFINE_BOOL(X_ACCELERATOR_VARY,${enable_x_accelerator_vary:=no},
                       [Enable support for the X-Accelerator-Vary HTTP header])
 AC_MSG_NOTICE([X-Accelerator-Vary support enabled: $enable_x_accelerator_vary])
 
-
-if $CPPUNITCONFIG --help >/dev/null; then
-  squid_cv_cppunit_version="`$CPPUNITCONFIG --version`"
-  AC_MSG_NOTICE([using system installed cppunit version $squid_cv_cppunit_version])
-  unset squid_cv_cppunit_version
-  SQUID_CPPUNIT_LIBS="`$CPPUNITCONFIG --libs`"
-  SQUID_CPPUNIT_LA=''
-  SQUID_CPPUNIT_INC="`$CPPUNITCONFIG --cflags`"
-else
-  AC_MSG_WARN([cppunit does not appear to be installed. squid does not require this, but code testing with 'make check' will fail.])
-  SQUID_CPPUNIT_LA='' 
-  SQUID_CPPUNIT_LIBS=''
-  SQUID_CPPUNIT_INC=''
-fi
-
-AC_ARG_WITH(cppunit-basedir,
-  AS_HELP_STRING([--with-cppunit-basedir=PATH],
-              [Path where the cppunit headers are libraries can be found ]), [
-if test -f "$withval/include/cppunit/TestCase.h"; then
-  AC_MSG_NOTICE([Using cppunit includes from $withval])
-  SQUID_CPPUNIT_INC="-I${withval}/include"
-else
-  AC_MSG_ERROR(Cannot find cppunit at $withval)
-fi
-if test -f "$withval/lib/libcppunit.la"; then
-  AC_MSG_NOTICE([Using cppunit lib from $withval])
-  SQUID_CPPUNIT_LA="${withval}/lib/libcppunit.la"
-  SQUID_CPPUNIT_LIBS='$(SQUID_CPPUNIT_LA)'
-else
-  AC_MSG_ERROR(Cannot find cppunit at $withval)
-fi
+AC_ARG_WITH([cppunit], AS_HELP_STRING([--without-cppunit],[Do not use cppunit test framework]),[
+  AS_CASE($with_cppunit, [yes|no],[],
+   [
+    AS_IF([test ! -d "$withval"],AC_MSG_ERROR([--with-cppunit PATH does not point to a directory]))
+    LIBCPPUNIT_CFLAGS="-I$with_cppunit/include"
+    LIBCPPUNIT_LIBS="-L$with_cppunit/lib -lcppunit"
+  ])
+])
+AS_IF([test "x$with_cppunit" != "xno"],[
+  PKG_CHECK_MODULES([LIBCPPUNIT],[cppunit],[
+    squid_cv_cppunit_version="`pkg-config cppunit --version`"
+    AC_MSG_NOTICE([using system installed cppunit version $squid_cv_cppunit_version])
+    AS_UNSET(squid_cv_cppunit_version)
+
+    SQUID_STATE_SAVE(squid_cppunit_state)
+    AS_VAR_APPEND(CXXFLAGS,[$LIBCPPUNIT_CFLAGS])
+    AS_VAR_APPEND(LIBS,[$LIBCPPUNIT_LIBS])
+    AC_CHECK_HEADERS(cppunit/extensions/HelperMacros.h)
+    SQUID_STATE_ROLLBACK(squid_cppunit_state)
+  ],[
+    AC_MSG_WARN([cppunit does not appear to be installed. Squid does not require this, but code testing with 'make check' will fail.])
+  ])
 ])
-SQUID_STATE_SAVE(squid_cppunit_state)
-CXXFLAGS="$CXXFLAGS $SQUID_CPPUNIT_INC"
-AC_CHECK_HEADERS(cppunit/extensions/HelperMacros.h)
-SQUID_STATE_ROLLBACK(squid_cppunit_state)
-AC_SUBST(SQUID_CPPUNIT_LIBS)
-AC_SUBST(SQUID_CPPUNIT_LA)
-AC_SUBST(SQUID_CPPUNIT_INC)
 
 # Force some compilers to use ANSI features
 #
@@ -3442,12 +3427,12 @@ fi
 
 AC_MSG_NOTICE([Using ${squid_opt_io_loop_engine} for the IO loop.])
 
-AM_CONDITIONAL([USE_POLL], [test $squid_opt_io_loop_engine = poll])
-AM_CONDITIONAL([USE_EPOLL], [test $squid_opt_io_loop_engine = epoll])
-AM_CONDITIONAL([USE_SELECT], [test $squid_opt_io_loop_engine = select])
-AM_CONDITIONAL([USE_SELECT_WIN32], [test $squid_opt_io_loop_engine = select_win32])
-AM_CONDITIONAL([USE_KQUEUE], [test $squid_opt_io_loop_engine = kqueue])
-AM_CONDITIONAL([USE_DEVPOLL], [test $squid_opt_io_loop_engine = devpoll])
+AM_CONDITIONAL(ENABLE_POLL, test "x$squid_opt_io_loop_engine" = "xpoll")
+AM_CONDITIONAL(ENABLE_EPOLL, test "x$squid_opt_io_loop_engine" = "xepoll")
+AM_CONDITIONAL(ENABLE_SELECT, test "x$squid_opt_io_loop_engine" = "xselect")
+AM_CONDITIONAL(ENABLE_SELECT_WIN32, test "x$squid_opt_io_loop_engine" = "xselect_win32")
+AM_CONDITIONAL(ENABLE_KQUEUE, test "x$squid_opt_io_loop_engine" = "xkqueue")
+AM_CONDITIONAL(ENABLE_DEVPOLL, test "x$squid_opt_io_loop_engine" = "xdevpoll")
 
 case $squid_opt_io_loop_engine in
   epoll) AC_DEFINE(USE_EPOLL,1,[Use epoll() for the IO loop]) ;;
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.18 release notes</title>
+<title>Squid 3.5.20 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.18.
+The Squid Team are pleased to announce the release of Squid-3.5.20.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -364,6 +364,10 @@ This section gives a thorough account of those changes in three categories:
 	<tag>sslproxy_cert_sign_hash</tag>
 	<p>New directive to set the hashing algorithm to use when signing generated certificates.
 
+	<tag>sslproxy_foreign_intermediate_certs</tag>
+	<p>New directive to load intermediate certificates for validating server
+	   certificate chains. This directive is only available in 3.5.13 and later.
+
 	<tag>sslproxy_session_cache_size</tag>
 	<p>New directive which sets the cache size to use for TLS/SSL sessions cache.
 
@@ -452,6 +456,7 @@ This section gives a thorough account of those changes in three categories:
 	<p>New format code <em>%ssl::&lt;cert_subject</em> to send SSL server certificate DN.
 	<p>New format code <em>%ssl::&lt;cert_issuer</em> to send SSL server certificate issuer DN.
 	<p>New format code <em>%un</em> to send any available user name (requires 3.5.7 or later).
+	<p>New format code <em>%&gt;eui</em> to send either EUI-48 or EUI-64 (requires 3.5.20 or later).
 	<p>New response kv-pair <em>clt_conn_tag=</em> to associates a given tag with the client TCP connection.
 
 	<tag>forward_max_tries</tag>
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 4.0.10 release notes</title>
+<title>Squid 4.0.12 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -12,7 +12,7 @@ for Applied Network Research and members of the Web Caching community.
 <toc>
 
 <sect>Notice
-<p>The Squid Team are pleased to announce the release of Squid-4.0.10 for testing.
+<p>The Squid Team are pleased to announce the release of Squid-4.0.12 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v4/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -343,6 +343,9 @@ This section gives a thorough account of those changes in three categories:
 	<p>Superceded by <em>cache_peer_access</em>. Use dstdomain ACL
 	   in the access control list to restrict domains requested.
 
+	<tag>ie_refresh</tag>
+	<p>Removed. MSIE 3.x, 4.x, 5.0 and 5.01 are no longer popular browsers.
+
 	<tag>sslproxy_cafile</tag>
 	<p>Replaced by <em>tls_outgoing_options cafile=</em>.
 	   Which now takes multiple entries.
@@ -394,7 +397,7 @@ This section gives an account of those changes in three categories:
 	<tag>--enable-security-cert-generators</tag>
 	<p>New option to control which TLS/SSL dynamic certificate generator
 	   helpers are built and installed.
-	<p>Helper <em>ssl_crtd<em> has been renamed to <em>security_file_certgen</em>
+	<p>Helper <em>ssl_crtd</em> has been renamed to <em>security_file_certgen</em>
 	   and built with module name <em>file</em>. Requires <em>--with-openssl</em>.
 
 	<tag>--enable-security-cert-validators</tag>
@@ -404,17 +407,25 @@ This section gives an account of those changes in three categories:
 	   certificate checks is provided for testing and as an example
 	   for writing custom helpers.
 
+	<tag>--without-cppunit</tag>
+	<p>The cppunit testing framework is auto-detected and used when available.
+	   This option can be used to disable it explicitly.
+
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
 <p>
 <descrip>
 	<tag>--enable-auth-basic</tag>
 	<p>The <em>MSNT-multi-domain</em> helper has been removed.
+	<p>The SMB LanMan helper <em>SMB_LM</em> is no longer built by default.
+	   It needs to be explicitly listed to be built.
 
 	<tag>--enable-auth-ntlm</tag>
 	<p>The SMB LanMan helper is now built using <em>SMB_LM</em>
 	   (was lower case <em>smb_lm</em>).
+	<p>The SMB LanMan helper <em>SMB_LM</em> is no longer built by default.
+	   It needs to be explicitly listed to be built.
 
 	<tag>--enable-diskio</tag>
 	<p>Auto-detection of SMP related modules has been fixed to
@@ -427,6 +438,9 @@ This section gives an account of those changes in three categories:
 <sect1>Removed options<label id="removedoptions">
 <p>
 <descrip>
+	<tag>--with-cppunit-basedir</tag>
+	<p>Replaced by <em>--with-cppunit=PATH</em>.
+	   Please prefer the default auto-detection though.
 
 </descrip>
 
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_NEW_H
-#define SQUID_NEW_H
-
-#if !defined(__SUNPRO_CC) && !defined(__clang__)
-/* Any code using libstdc++ must have externally resolvable overloads
- * for void * operator new - which means in the .o for the binary,
- * or in a shared library. static libs don't propogate the symbol
- * so, look in the translation unit containing main() in squid
- * for the extern version in squid
- */
-#include <new>
-
-_SQUID_EXTERNNEW_ void *operator new(size_t size) throw (std::bad_alloc)
-{
-    return xmalloc(size);
-}
-_SQUID_EXTERNNEW_ void operator delete (void *address) throw()
-{
-    xfree(address);
-}
-_SQUID_EXTERNNEW_ void *operator new[] (size_t size) throw (std::bad_alloc)
-{
-    return xmalloc(size);
-}
-_SQUID_EXTERNNEW_ void operator delete[] (void *address) throw()
-{
-    xfree(address);
-}
-
-#endif /* !__SUNPRO_CC && !__clang__*/
-
-#endif /* SQUID_NEW_H */
-
@@ -19,23 +19,6 @@
 SQUIDCEXTERN int tvSubUsec(struct timeval, struct timeval);
 SQUIDCEXTERN double tvSubDsec(struct timeval, struct timeval);
 SQUIDCEXTERN void Tolower(char *);
-#if defined(__cplusplus)
-/*
- * Any code using libstdc++ must have externally resolvable overloads
- * for void * operator new - which means in the .o for the binary,
- * or in a shared library. static libs don't propogate the symbol
- * so, look in the translation unit containing main() in squid
- * for the extern version in squid
- */
-#if !defined(_SQUID_EXTERNNEW_)
-#if defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__)
-#define _SQUID_EXTERNNEW_ extern inline __attribute__((gnu_inline))
-#else
-#define _SQUID_EXTERNNEW_ extern inline
-#endif
-#endif
-#include "SquidNew.h"
-#endif
 
 SQUIDCEXTERN time_t parse_iso3307_time(const char *buf);
 
@@ -11,7 +11,7 @@ DIST_SUBDIRS = ntlmauth profiler rfcnb smblib libTrie snmplib
 SUBDIRS=
 EXTRA_DIST=
 
-if USE_ESI
+if ENABLE_ESI
 SUBDIRS += libTrie
 endif
 if ENABLE_SNMP
@@ -37,9 +37,12 @@ if ENABLE_WIN32SPECIFIC
 noinst_LTLIBRARIES += libsspwin32.la
 libsspwin32_la_SOURCES = sspwin32.cc
 else
-SUBDIRS += rfcnb smblib
 EXTRA_DIST += sspwin32.cc
 endif
+if ENABLE_SMBLIB
+# smblib is the only user of the rfcnb library
+SUBDIRS += rfcnb smblib
+endif
 if ENABLE_AUTH_NTLM
 SUBDIRS += ntlmauth
 endif
@@ -85,9 +88,9 @@ tests_testRFC1738_SOURCES= \
 	tests/testRFC1738.cc
 
 tests_testRFC1738_LDADD= \
-	$(SQUID_CPPUNIT_LA) $(SQUID_CPPUNIT_LIBS) \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB)
 
 tests_testRFC1738_LDFLAGS = $(LIBADD_DL)
@@ -150,12 +150,12 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
        service we are going to call, sine some servers want it in uppercase */
 
     for (i=0; i < strlen(server); i++)
-        called[i] = toupper(server[i]);
+        called[i] = xtoupper(server[i]);
 
     called[strlen(server)] = 0;    /* Make it a string */
 
     for (i=0; i < strlen(con -> myname); i++)
-        calling[i] = toupper(con -> myname[i]);
+        calling[i] = xtoupper(con -> myname[i]);
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
@@ -266,12 +266,12 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
        service we are going to call, sine some servers want it in uppercase */
 
     for (i=0; i < strlen(host); i++)
-        called[i] = toupper(host[i]);
+        called[i] = xtoupper(host[i]);
 
     called[strlen(host)] = 0;    /* Make it a string */
 
     for (i=0; i < strlen(con -> myname); i++)
-        calling[i] = toupper(con -> myname[i]);
+        calling[i] = xtoupper(con -> myname[i]);
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
@@ -97,8 +97,12 @@
 	} 
 	elsif (my @deIds = (/$reDestructor/)) {
 		my $id = join(':', @deIds);
-		#warn("unborn: $_") unless $AliveCount{$id};
-		$AliveImage{$id} = undef() unless --$AliveCount{$id};
+		if ($AliveCount{$id}) {
+			$AliveImage{$id} = undef() unless --$AliveCount{$id};
+		} else {
+			#warn("unborn: $_");
+			# do nothing; we are probably looking at a partial log
+		}
 	}
 }
 
@@ -0,0 +1,65 @@
+#!/usr/bin/perl -w
+#
+## Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+# Reads cache.log and displays lines that correspond to a given kid.
+#
+# Cache log format and logging bugs make accurate kid attribution impossible,
+# but this script is much better than running "grep kidN cache.log" and missing
+# all "kidless" lines that do not contain kidN ID, such as HTTP header dumps.
+
+use strict;
+use warnings;
+use Getopt::Long;
+
+my $IncludePrefix = 0; # include initial kidless lines
+my $IncludeMentions = 0; # include other kid references to the targeted kid
+GetOptions(
+	"prefix!"  => \$IncludePrefix,
+    "mentions!"  => \$IncludeMentions,
+) or die(usage());
+
+my $Kid = shift or die(usage());
+die("$0: error: expecting an integer kid ID but got $Kid\n")
+	unless $Kid =~ /^\d+$/;
+
+my $lastKid;
+while (<>) {
+	my ($currentKid) = (/^\d[^a-z]+? kid(\d+)[|]/);
+	$lastKid = $currentKid if defined $currentKid;
+
+	if (!defined($currentKid) && !defined($lastKid)) { # kidless prefix
+		print $_ if $IncludePrefix;
+		next;
+	}
+
+	# targeted kid output or kidless output by, hopefully, the targeted kid
+	if (defined $lastKid && $lastKid == $Kid) {
+		print $_;
+		next;
+	}
+
+	if (defined $currentKid) { # wrong kid output
+		# print lines mentioning our kid if requested, isolating each such line
+		print "\n$_\n" if $IncludeMentions && /\bkid(:\s*)?$Kid\b/o;
+		next;
+	}
+
+	# ignore kidless output produced by, hopefully, wrong kids
+}
+
+exit(0);
+
+sub usage() {
+	return <<"USAGE";
+usage: $0 [option...] <kid ID> [log file...]
+options:
+    --prefix   include initial kidless lines
+    --mentions include other kid references to the targeted kid
+USAGE
+}
@@ -42,7 +42,6 @@ CachePeer::CachePeer() :
     domain(NULL),
 #if USE_OPENSSL
     sslContext(NULL),
-    sslSession(NULL),
 #endif
     front_end_https(0),
     connection_auth(2 /* auto */)
@@ -102,9 +101,6 @@ CachePeer::~CachePeer()
 #if USE_OPENSSL
     if (sslContext)
         SSL_CTX_free(sslContext);
-
-    if (sslSession)
-        SSL_SESSION_free(sslSession);
 #endif
 }
 
@@ -184,9 +184,7 @@ class CachePeer
     /// security settings for peer connection
     Security::PeerOptions secure;
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
     int front_end_https;
     int connection_auth;
@@ -47,7 +47,7 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src \
 	-I$(top_builddir)/include \
-	$(SQUID_CPPUNIT_INC)
+	$(LIBCPPUNIT_CFLAGS)
 
 ## Kerberos headers require their include path.
 ## Because we use libcompat for comm_err.h header protections ...
@@ -155,7 +155,7 @@ HttpHeader::HttpHeader(const http_hdr_owner_type anOwner): owner(anOwner), len(0
 HttpHeader::HttpHeader(const HttpHeader &other): owner(other.owner), len(other.len), conflictingContentLength_(false)
 {
     httpHeaderMaskInit(&mask, 0);
-    update(&other, NULL); // will update the mask as well
+    update(&other); // will update the mask as well
 }
 
 HttpHeader::~HttpHeader()
@@ -170,7 +170,7 @@ HttpHeader::operator =(const HttpHeader &other)
         // we do not really care, but the caller probably does
         assert(owner == other.owner);
         clean();
-        update(&other, NULL); // will update the mask as well
+        update(&other); // will update the mask as well
         len = other.len;
         conflictingContentLength_ = other.conflictingContentLength_;
     }
@@ -239,17 +239,39 @@ HttpHeader::append(const HttpHeader * src)
 }
 
 void
-HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
+HttpHeader::updateWarnings()
+{
+    int count = 0;
+    HttpHeaderPos pos = HttpHeaderInitPos;
+
+    // RFC 7234, section 4.3.4: delete 1xx warnings and retain 2xx warnings
+    while (HttpHeaderEntry *e = getEntry(&pos)) {
+        if (e->id == Http::HdrType::WARNING && (e->getInt()/100 == 1) )
+            delAt(pos, count);
+    }
+}
+
+bool
+HttpHeader::skipUpdateHeader(const Http::HdrType id) const
+{
+    // RFC 7234, section 4.3.4: use fields other from Warning for update
+    return id == Http::HdrType::WARNING;
+}
+
+void
+HttpHeader::update(HttpHeader const *fresh)
 {
     const HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
     assert(fresh);
     assert(this != fresh);
 
+    updateWarnings();
+
     while ((e = fresh->getEntry(&pos))) {
         /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
-        if (denied_mask && CBIT_TEST(*denied_mask, e->id))
+        if (skipUpdateHeader(e->id))
             continue;
 
         if (e->id != Http::HdrType::OTHER)
@@ -262,7 +284,7 @@ HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
     while ((e = fresh->getEntry(&pos))) {
         /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
-        if (denied_mask && CBIT_TEST(*denied_mask, e->id))
+        if (skipUpdateHeader(e->id))
             continue;
 
         debugs(55, 7, "Updating header '" << Http::HeaderLookupTable.lookup(e->id).name << "' in cached entry");
@@ -81,7 +81,7 @@ class HttpHeader
     /* Interface functions */
     void clean();
     void append(const HttpHeader * src);
-    void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
+    void update(HttpHeader const *fresh);
     void compact();
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
@@ -145,6 +145,8 @@ class HttpHeader
 protected:
     /** \deprecated Public access replaced by removeHopByHopEntries() */
     void removeConnectionHeaderEntries();
+    bool skipUpdateHeader(const Http::HdrType id) const;
+    void updateWarnings();
 
 private:
     HttpHeaderEntry *findLastEntry(Http::HdrType id) const;
@@ -25,39 +25,6 @@
 #include "Store.h"
 #include "StrList.h"
 
-/* local constants */
-
-/* If we receive a 304 from the origin during a cache revalidation, we must
- * update the headers of the existing entry. Specifically, we need to update all
- * end-to-end headers and not any hop-by-hop headers (rfc2616 13.5.3).
- *
- * This is not the whole story though: since it is possible for a faulty/malicious
- * origin server to set headers it should not in a 304, we must explicitly ignore
- * these too. Specifically all entity-headers except those permitted in a 304
- * (rfc2616 10.3.5) must be ignored.
- *
- * The list of headers we don't update is made up of:
- *     all hop-by-hop headers
- *     all entity-headers except Expires and Content-Location
- *
- * These headers are now stored in RegisteredHeadersHash.gperf and accessible
- * as Http::HeaderLookupTable.lookup(id).denied304
- */
-static HttpHeaderMask Denied304HeadersMask;
-
-/* module initialization */
-void
-httpReplyInitModule(void)
-{
-    assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
-    httpHeaderMaskInit(&Denied304HeadersMask, 0);
-
-    for (auto id : WholeEnum<Http::HdrType>()) {
-        if (Http::HeaderLookupTable.lookup(id).denied304)
-            CBIT_SET(Denied304HeadersMask, id);
-    }
-}
-
 HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
     expires (0), surrogate_control (NULL), content_range (NULL), keep_alive (0),
     protoPrefix("HTTP/"), bodySizeMax(-2)
@@ -276,8 +243,7 @@ HttpReply::updateOnNotModified(HttpReply const * freshRep)
     /* clean cache */
     hdrCacheClean();
     /* update raw headers */
-    header.update(&freshRep->header,
-                  (const HttpHeaderMask *) &Denied304HeadersMask);
+    header.update(&freshRep->header);
 
     header.compact();
     /* init cache */
@@ -18,6 +18,7 @@ const char * LogTags::Str_[] = {
     "TCP_REFRESH_FAIL_OLD",
     "TCP_REFRESH_FAIL_ERR",
     "TCP_REFRESH_MODIFIED",
+    "TCP_REFRESH",
     "TCP_CLIENT_REFRESH_MISS",
     "TCP_IMS_HIT",
     "TCP_SWAPFAIL_MISS",
@@ -25,6 +25,7 @@ typedef enum {
     LOG_TCP_REFRESH_FAIL_OLD,   // refresh from origin failed, stale reply sent
     LOG_TCP_REFRESH_FAIL_ERR,   // refresh from origin failed, error forwarded
     LOG_TCP_REFRESH_MODIFIED,   // refresh from origin replaced existing entry
+    LOG_TCP_REFRESH,            // refresh from origin started, but still pending
     LOG_TCP_CLIENT_REFRESH_MISS,
     LOG_TCP_IMS_HIT,
     LOG_TCP_SWAPFAIL_MISS,
@@ -66,16 +66,16 @@ SNMP_SOURCE = $(SNMP_ALL_SOURCE)
 SUBDIRS += snmp
 SNMP_LIBS = snmp/libsnmp.la $(SNMPLIB)
 else
-SNMP_SOURCE = 
+SNMP_SOURCE =
 endif
 DIST_SUBDIRS += snmp
 
-if USE_ADAPTATION
+if ENABLE_ADAPTATION
 SUBDIRS += adaptation
 endif
 DIST_SUBDIRS += adaptation
 
-if USE_ESI
+if ENABLE_ESI
 SUBDIRS += esi
 ESI_LIBS = \
 	esi/libesi.la \
@@ -113,35 +113,35 @@ DELAY_POOL_ALL_SOURCE = \
 	NullDelayId.h \
 	ClientDelayConfig.cc \
 	ClientDelayConfig.h
-	
+
 if ENABLE_DELAY_POOLS
 DELAY_POOL_SOURCE = $(DELAY_POOL_ALL_SOURCE)
 else
-DELAY_POOL_SOURCE = 
+DELAY_POOL_SOURCE =
 endif
 
 if ENABLE_XPROF_STATS
 XPROF_STATS_SOURCE = ProfStats.cc
 else
-XPROF_STATS_SOURCE = 
+XPROF_STATS_SOURCE =
 endif
 
 if ENABLE_HTCP
 HTCPSOURCE = htcp.cc htcp.h
 endif
 
-if MAKE_LEAKFINDER
+if ENABLE_LEAKFINDER
 LEAKFINDERSOURCE =  LeakFinder.cc
 else
-LEAKFINDERSOURCE = 
+LEAKFINDERSOURCE =
 endif
 
 if ENABLE_UNLINKD
 UNLINKDSOURCE = unlinkd.h unlinkd.cc
 UNLINKD = unlinkd
 else
 UNLINKDSOURCE = unlinkd.h
-UNLINKD = 
+UNLINKD =
 endif
 
 WIN32_ALL_SOURCE = \
@@ -181,8 +181,7 @@ noinst_PROGRAMS = \
 sbin_PROGRAMS = \
 	squid
 
-bin_PROGRAMS = 
-
+bin_PROGRAMS =
 
 libexec_PROGRAMS = \
 	$(UNLINKD)
@@ -890,10 +889,10 @@ check_PROGRAMS+=\
 	tests/testLookupTable \
 	tests/testYesNoNone
 
-if HAVE_FS_ROCK
+if ENABLE_FS_ROCK
 check_PROGRAMS += tests/testRock
 endif
-if HAVE_FS_UFS
+if ENABLE_FS_UFS
 check_PROGRAMS += tests/testUfs
 endif
 
@@ -917,9 +916,9 @@ TESTS += $(check_PROGRAMS)
 #	$(TESTSOURCES)
 #tests_testX_LDFLAGS = $(LIBADD_DL)
 #tests_testX_LDADD=\
-#	$(SQUID_CPPUNIT_LIBS) \
-#	$(SQUID_CPPUNIT_LA) \
-#	$(COMPAT_LIB) 
+#	$(LIBCPPUNIT_LIBS) \
+#	$(COMPAT_LIB) \
+#	$(XTRA_LIBS)
 
 # - add other component .(h|cc) files needed to link and run tests
 tests_testHttpReply_SOURCES=\
@@ -1020,10 +1019,9 @@ tests_testHttpReply_LDADD=\
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(NETTLELIB) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -1153,8 +1151,8 @@ tests_testACLMaxUserIP_LDADD= \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testACLMaxUserIP_LDFLAGS = $(LIBADD_DL)
@@ -1172,10 +1170,9 @@ nodist_tests_testBoilerplate_SOURCES = \
 	tests/stub_MemBuf.cc \
 	$(TESTSOURCES)
 tests_testBoilerplate_LDADD= \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	base/libbase.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testBoilerplate_LDFLAGS = $(LIBADD_DL)
@@ -1194,9 +1191,8 @@ nodist_tests_testCharacterSet_SOURCES = \
 tests_testCharacterSet_LDFLAGS = $(LIBADD_DL)
 tests_testCharacterSet_LDADD= \
 	base/libbase.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(SQUID_CPPUNIT_LA) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 
 ## Tests of the CacheManager module.
@@ -1431,10 +1427,9 @@ tests_testCacheManager_LDADD = \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testCacheManager_LDFLAGS = $(LIBADD_DL)
@@ -1604,15 +1599,14 @@ tests_testDiskIO_LDADD = \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testDiskIO_LDFLAGS = $(LIBADD_DL)
 tests_testDiskIO_DEPENDENCIES = \
 	DiskIO/libdiskio.la \
-	$(SWAP_TEST_DS) \
-	$(SQUID_CPPUNIT_LA)
+	$(SWAP_TEST_DS)
 
 tests_testDns_SOURCES= \
 	tests/testRFC1035.cc \
@@ -1626,10 +1620,9 @@ tests_testDns_LDADD= \
 	dns/libdns.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(XTRA_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
-	$(SQUID_CPPUNIT_LIBS)
+	$(XTRA_LIBS)
 tests_testDns_LDFLAGS= $(LIBADD_DL)
 
 tests_testEvent_SOURCES = \
@@ -1863,10 +1856,9 @@ tests_testEvent_LDADD = \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testEvent_LDFLAGS = $(LIBADD_DL)
@@ -2102,10 +2094,9 @@ tests_testEventLoop_LDADD = \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testEventLoop_LDFLAGS = $(LIBADD_DL)
@@ -2337,10 +2328,9 @@ tests_test_http_range_LDADD = \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_test_http_range_LDFLAGS = $(LIBADD_DL)
@@ -2364,9 +2354,8 @@ tests_testTokenizer_LDADD = \
 	base/libbase.la \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(SQUID_CPPUNIT_LA) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 
 tests_testHttp1Parser_SOURCES = \
@@ -2409,9 +2398,8 @@ tests_testHttp1Parser_LDADD= \
 	ip/libip.la \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttp1Parser_LDFLAGS = $(LIBADD_DL)
@@ -2646,10 +2634,9 @@ tests_testHttpRequest_LDADD = \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpRequest_LDFLAGS = $(LIBADD_DL)
@@ -2671,9 +2658,8 @@ tests_testIcmp_LDADD=\
 	icmp/libicmpcore.la \
 	ip/libip.la \
 	base/libbase.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(SQUID_CPPUNIT_LA) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 
 ## Tests for ip/* objects
@@ -2688,9 +2674,8 @@ nodist_tests_testIpAddress_SOURCES= \
 tests_testIpAddress_LDADD= \
 	ip/libip.la \
 	base/libbase.la \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(SQUID_CPPUNIT_LA) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 tests_testIpAddress_LDFLAGS= $(LIBADD_DL)
 
@@ -2853,10 +2838,9 @@ tests_testStore_LDADD= \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	CommCalls.o \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testStore_LDFLAGS = $(LIBADD_DL)
@@ -2892,9 +2876,8 @@ tests_testString_LDADD = \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testString_LDFLAGS = $(LIBADD_DL)
@@ -2912,8 +2895,7 @@ SWAP_TEST_DS =\
 	DiskIO/libdiskio.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
-	$(REPL_OBJS) \
-	$(SQUID_CPPUNIT_LA)
+	$(REPL_OBJS)
 
 tests_testUfs_SOURCES = \
 	tests/testUfs.cc \
@@ -3079,8 +3061,8 @@ tests_testUfs_LDADD = \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
@@ -3252,8 +3234,8 @@ tests_testRock_LDADD = \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testRock_LDFLAGS = $(AM_CPPFLAGS) $(LIBADD_DL)
@@ -3493,11 +3475,9 @@ tests_testURL_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(COMPAT_LIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testURL_LDFLAGS = $(LIBADD_DL)
@@ -3517,10 +3497,9 @@ tests_testSBuf_LDFLAGS = $(LIBADD_DL)
 tests_testSBuf_LDADD= \
 	sbuf/libsbuf.la \
 	base/libbase.la \
-	$(SQUID_CPPUNIT_LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(XTRA_LIBS) \
-	$(SQUID_CPPUNIT_LA)
+	$(XTRA_LIBS)
 
 tests_testSBufList_SOURCES= \
 	tests/testSBufList.h \
@@ -3535,10 +3514,9 @@ tests_testSBufList_LDFLAGS = $(LIBADD_DL)
 tests_testSBufList_LDADD=\
 	sbuf/libsbuf.la \
 	base/libbase.la \
-	$(SQUID_CPPUNIT_LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(XTRA_LIBS) \
-	$(SQUID_CPPUNIT_LA)
+	$(XTRA_LIBS)
 
 tests_testConfigParser_SOURCES = \
 	ClientInfo.h \
@@ -3570,13 +3548,12 @@ tests_testConfigParser_LDADD = \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(REGEXLIB) \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testConfigParser_LDFLAGS = $(LIBADD_DL)
-	
+
 tests_testStatHist_SOURCES = \
 	tests/stub_cbdata.cc \
 	fatal.h \
@@ -3613,8 +3590,7 @@ tests_testStatHist_LDADD = \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(top_builddir)/lib/libmisccontainers.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SQUID_CPPUNIT_LA) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB)
 
 tests_testLookupTable_SOURCES = \
@@ -3629,10 +3605,9 @@ tests_testLookupTable_LDFLAGS = $(LIBADD_DL)
 tests_testLookupTable_LDADD = \
 	sbuf/libsbuf.la \
 	base/libbase.la \
-	$(SQUID_CPPUNIT_LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(XTRA_LIBS) \
-	$(SQUID_CPPUNIT_LA)
+	$(XTRA_LIBS)
 
 tests_testEnumIterator_SOURCES = \
 	base/EnumIterator.h \
@@ -3645,9 +3620,8 @@ nodist_tests_testEnumIterator_SOURCES = \
 tests_testEnumIterator_LDFLAGS = $(LIBADD_DL)
 tests_testEnumIterator_LDADD = \
 	base/libbase.la \
-	$(SQUID_CPPUNIT_LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
-	$(SQUID_CPPUNIT_LA) \
 	$(XTRA_LIBS)
 
 tests_testYesNoNone_SOURCES = \
@@ -3660,7 +3634,7 @@ nodist_tests_testYesNoNone_SOURCES = \
 	base/YesNoNone.h
 tests_testYesNoNone_LDADD= \
 	base/libbase.la \
-	$(SQUID_CPPUNIT_LIBS) \
+	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testYesNoNone_LDFLAGS = $(LIBADD_DL)
@@ -305,7 +305,6 @@ class SquidConfig
         int digest_generation;
 #endif
 
-        int ie_refresh;
         int vary_ignore_expire;
         int surrogate_is_remote;
         int request_entities;
@@ -8,29 +8,45 @@
 
 /* DEBUG: none          Memory Allocation */
 
-#define _SQUID_EXTERNNEW_
-
 #include "squid.h"
 
-#ifdef __SUNPRO_CC
+#if !defined(__clang__)
 
 #include <new>
-void *operator new(size_t size) throw (std::bad_alloc)
+
+void *operator new(size_t size)
+{
+    return xmalloc(size);
+}
+void operator delete(void *address)
+{
+    xfree(address);
+}
+void *operator new[](size_t size)
+{
+    return xmalloc(size);
+}
+void operator delete[](void *address)
+{
+    xfree(address);
+}
+
+void *operator new(size_t size, const std::nothrow_t &tag)
 {
     return xmalloc(size);
 }
-void operator delete (void *address) throw()
+void operator delete(void *address, const std::nothrow_t &tag)
 {
-    xfree (address);
+    xfree(address);
 }
-void *operator new[] (size_t size) throw (std::bad_alloc)
+void *operator new[](size_t size, const std::nothrow_t &tag)
 {
     return xmalloc(size);
 }
-void operator delete[] (void *address) throw()
+void operator delete[](void *address, const std::nothrow_t &tag)
 {
-    xfree (address);
+    xfree(address);
 }
 
-#endif /* __SUNPRO_CC */
+#endif /* !defined(__clang__) */
 
@@ -177,14 +177,14 @@ ADAPT_ACLS= \
 	AdaptationServiceData.h \
 	AdaptationServiceData.cc
 
-if USE_ADAPTATION
+if ENABLE_ADAPTATION
 libacls_la_SOURCES += $(ADAPT_ACLS)
 endif
 EXTRA_libacls_la_SOURCES += $(ADAPT_ACLS)
 
 ARP_ACLS = Arp.cc Arp.h Eui64.cc Eui64.h
 
-if USE_SQUID_EUI
+if ENABLE_EUI
 libacls_la_SOURCES += $(ARP_ACLS)
 endif
 EXTRA_libacls_la_SOURCES += $(ARP_ACLS)
@@ -150,9 +150,9 @@ bool Adaptation::History::extractNextServices(String &value)
 void Adaptation::History::recordMeta(const HttpHeader *lm)
 {
     lastMeta.clean();
-    lastMeta.update(lm, NULL);
+    lastMeta.update(lm);
 
-    allMeta.update(lm, NULL);
+    allMeta.update(lm);
     allMeta.compact();
 }
 
@@ -8,20 +8,11 @@
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
-## make a list of directories for configured adaptation schemes
+DIST_SUBDIRS= ecap icap
 SUBDIRS =
 
-if USE_ICAP_CLIENT
-SUBDIRS += icap
-endif
-
-if USE_ECAP
-SUBDIRS += ecap
-endif
-
 noinst_LTLIBRARIES = libadaptation.la
 
-## start with the code shared among all adaptation schemes
 libadaptation_la_SOURCES = \
 	AccessCheck.cc \
 	AccessCheck.h \
@@ -53,9 +44,17 @@ libadaptation_la_SOURCES = \
 	ServiceFilter.cc \
 	ServiceFilter.h \
 	History.cc \
-	History.h 
+	History.h
 
-# add libraries for specific adaptation schemes
-libadaptation_la_LIBADD = $(ECAP_LIBS) $(ICAP_LIBS)
+libadaptation_la_LIBADD =
+
+if ENABLE_ECAP
+SUBDIRS += ecap
+libadaptation_la_LIBADD += ecap/libecapsquid.la
+endif
+
+if ENABLE_ICAP_CLIENT
+SUBDIRS += icap
+libadaptation_la_LIBADD += icap/libicap.la
+endif
 
-libadaptation_la_DEPENDENCIES = $(ECAP_LIBS) $(ICAP_LIBS)
@@ -69,8 +69,19 @@ Adaptation::ServiceConfig::parse()
 {
     key = ConfigParser::NextToken();
     String method_point = ConfigParser::NextToken();
+    if (!method_point.size()) {
+        debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' << config_lineno << ": " <<
+               "Missing vectoring point in adaptation service definition");
+        return false;
+    }
+
     method = parseMethod(method_point.termedBuf());
     point = parseVectPoint(method_point.termedBuf());
+    if (method == Adaptation::methodNone && point == Adaptation::pointNone) {
+        debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' << config_lineno << ": " <<
+               "Unknown vectoring point '" << method_point << "' in adaptation service definition");
+        return false;
+    }
 
     // reset optional parameters in case we are reconfiguring
     bypass = routing = false;
@@ -105,7 +116,7 @@ Adaptation::ServiceConfig::parse()
 
         // Check if option is set twice
         if (options.find(name) != options.end()) {
-            debugs(3, DBG_CRITICAL, cfg_filename << ':' << config_lineno << ": " <<
+            debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' << config_lineno << ": " <<
                    "Duplicate option \"" << name << "\" in adaptation service definition");
             return false;
         }
@@ -160,7 +171,7 @@ Adaptation::ServiceConfig::parse()
 
     // is the service URI set?
     if (!grokkedUri) {
-        debugs(3, DBG_CRITICAL, cfg_filename << ':' << config_lineno << ": " <<
+        debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' << config_lineno << ": " <<
                "No \"uri\" option in adaptation service definition");
         return false;
     }
@@ -236,7 +236,7 @@ bool Adaptation::Ecap::ServiceRep::probed() const
 
 bool Adaptation::Ecap::ServiceRep::up() const
 {
-    return theService;
+    return bool(theService);
 }
 
 bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &urlPath) const
@@ -34,9 +34,6 @@ CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &svcCfg):
     AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(svcCfg),
     sslContext(NULL),
-#if USE_OPENSSL
-    sslSession(NULL),
-#endif
     theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
@@ -111,9 +111,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     virtual void noteAdaptationAnswer(const Answer &answer);
 
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
 private:
     // stores Prepare() callback info
@@ -725,8 +725,7 @@ Ssl::IcapPeerConnector::initializeSsl()
     if (check)
         check->dst_peer_name = *host;
 
-    if (icapService->sslSession)
-        SSL_set_session(ssl, icapService->sslSession);
+    Security::GetSessionResumeData(Security::SessionPointer(ssl), icapService->sslSession);
 
     return ssl;
 }
@@ -738,13 +737,7 @@ Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
 
     const int fd = serverConnection()->fd;
-    auto ssl = fd_table[fd].ssl.get();
-    assert(ssl);
-    if (!SSL_session_reused(ssl)) {
-        if (icapService->sslSession)
-            SSL_SESSION_free(icapService->sslSession);
-        icapService->sslSession = SSL_get1_session(ssl);
-    }
+    Security::GetSessionResumeData(fd_table[fd].ssl, icapService->sslSession);
 }
 
 void
@@ -143,10 +143,7 @@ AnyP::PortCfg::configureSslServerContext()
         }
     }
 
-    secure.updateTlsVersionLimits();
-    secure.staticContext.reset(sslCreateServerContext(*this));
-
-    if (!secure.staticContext) {
+    if (!secure.createStaticServerContext(*this)) {
         char buf[128];
         fatalf("%s_port %s initialization error", AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
     }
@@ -201,7 +201,7 @@ Auth::User::addIp(Ip::Address ipaddr)
             /* This ip has already been seen. */
             found = 1;
             /* update IP ttl */
-            ipdata->ip_expiretime = squid_curtime;
+            ipdata->ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
         } else if (ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&ipdata->node, &ip_list);
@@ -5,7 +5,10 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-BUILD_HELPER="SMB_LM"
-
 # DONT build this helper on Windows
-AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
+# DONT build this helper by default
+if test "x$auto_auth_basic_modules" != "xyes";then
+  BUILD_HELPER="SMB_LM"
+  AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
+  AS_IF([test "x$BUILD_HELPER" = "xSMB_LM"],[require_smblib="yes"])
+fi
@@ -7,9 +7,11 @@
 
 #
 # DONT build this helper on Windows
+# DONT build this helper by default
 #
 # XXX: do we really need the mingw check?
-if test "$squid_host_os" != "mingw"; then
+if test "$squid_host_os" != "mingw" -a "x$auto_auth_ntlm_modules" != "xyes"; then
   BUILD_HELPER="SMB_LM"
   AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
+  AS_IF([test "x$BUILD_HELPER" = "xSMB_LM"],[require_smblib="yes"])
 fi
@@ -25,6 +25,8 @@ template <typename T, void (*DeAllocator)(T *t)> class TidyPointer
 public:
     bool operator !() const { return !raw; }
     explicit operator bool() const { return raw; }
+    T* operator ->() const { return get(); }
+
     /// Returns raw and possibly NULL pointer
     T *get() const { return raw; }
 
@@ -163,13 +163,19 @@ DOC_START
 	This option is not yet supported by Squid-3.
 DOC_END
 
-# Options removed in 3.6
+# Options removed in 4.x
 NAME: cache_peer_domain cache_host_domain
 TYPE: obsolete
 DOC_START
 	Replace with dstdomain ACLs and cache_peer_access.
 DOC_END
 
+NAME: ie_refresh
+TYPE: obsolete
+DOC_START
+	Remove this line. The behaviour enabled by this is no longer needed.
+DOC_END
+
 NAME: sslproxy_cafile
 TYPE: obsolete
 DOC_START
@@ -5889,30 +5895,6 @@ DOC_START
 	replies as required by RFC2616.
 DOC_END
 
-NAME: ie_refresh
-COMMENT: on|off
-TYPE: onoff
-LOC: Config.onoff.ie_refresh
-DEFAULT: off
-DOC_START
-	Microsoft Internet Explorer up until version 5.5 Service
-	Pack 1 has an issue with transparent proxies, wherein it
-	is impossible to force a refresh.  Turning this on provides
-	a partial fix to the problem, by causing all IMS-REFRESH
-	requests from older IE versions to check the origin server
-	for fresh content.  This reduces hit ratio by some amount
-	(~10% in my experience), but allows users to actually get
-	fresh content when they want it.  Note because Squid
-	cannot tell if the user is using 5.5 or 5.5SP1, the behavior
-	of 5.5 is unchanged from old versions of Squid (i.e. a
-	forced refresh is impossible).  Newer versions of IE will,
-	hopefully, continue to have the new behavior and will be
-	handled based on that assumption.  This option defaults to
-	the old Squid behavior, which is better for hit ratios but
-	worse for clients using IE, if they need to be able to
-	force fresh content.
-DOC_END
-
 NAME: vary_ignore_expire
 COMMENT: on|off
 TYPE: onoff
@@ -478,11 +478,13 @@ gen_default(const EntryList &head, std::ostream &fout)
     fout << "static void" << std::endl <<
          "default_line(const char *s)" << std::endl <<
          "{" << std::endl <<
-         "    LOCAL_ARRAY(char, tmp_line, BUFSIZ);" << std::endl <<
-         "    xstrncpy(tmp_line, s, BUFSIZ);" << std::endl <<
-         "    xstrncpy(config_input_line, s, BUFSIZ);" << std::endl <<
+         "    int len = strlen(s) +1;" << std::endl <<
+         "    char *tmp_line = xstrndup(s, len);" << std::endl <<
+         "    ProcessMacros(tmp_line, len);" << std::endl <<
+         "    xstrncpy(config_input_line, tmp_line, len);" << std::endl <<
          "    config_lineno++;" << std::endl <<
          "    parse_line(tmp_line);" << std::endl <<
+         "    xfree(tmp_line);" << std::endl <<
          "}" << std::endl << std::endl;
     fout << "static void" << std::endl <<
          "default_all(void)" << std::endl <<
@@ -2570,8 +2570,8 @@ httpAccept(const CommAcceptCbParams &params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = Http::NewServer(xact);
-    AsyncJob::Start(connState); // usually async-calls readSomeData()
+    auto *srv = Http::NewServer(xact);
+    AsyncJob::Start(srv); // usually async-calls readSomeData()
 }
 
 #if USE_OPENSSL
@@ -2657,7 +2657,7 @@ clientNegotiateSSL(int fd, void *data)
         return;
     }
 
-    if (SSL_session_reused(ssl)) {
+    if (Security::SessionIsResumed(fd_table[fd].ssl)) {
         debugs(83, 2, "clientNegotiateSSL: Session " << SSL_get_session(ssl) <<
                " reused on FD " << fd << " (" << fd_table[fd].ipaddr << ":" << (int)fd_table[fd].remote_port << ")");
     } else {
@@ -2798,8 +2798,8 @@ httpsAccept(const CommAcceptCbParams &params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = Https::NewServer(xact);
-    AsyncJob::Start(connState); // usually async-calls postHttpsAccept()
+    auto *srv = Https::NewServer(xact);
+    AsyncJob::Start(srv); // usually async-calls postHttpsAccept()
 }
 
 void
@@ -278,6 +278,7 @@ clientReplyContext::processExpired()
         return;
     }
 
+    http->logType = LOG_TCP_REFRESH;
     http->request->flags.refresh = true;
 #if STORE_CLIENT_LIST_DEBUG
     /* Prevent a race with the store client memory free routines
@@ -357,7 +357,7 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
      * correctness.
      */
     if (header)
-        request->header.update(header, NULL);
+        request->header.update(header);
 
     http->log_uri = xstrdup(urlCanonicalClean(request));
 
@@ -1056,7 +1056,6 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     HttpRequest *request = http->request;
     HttpHeader *req_hdr = &request->header;
     bool no_cache = false;
-    const char *str;
 
     request->imslen = -1;
     request->ims = req_hdr->getTime(Http::HdrType::IF_MODIFIED_SINCE);
@@ -1072,28 +1071,6 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
             // RFC 2616: treat Pragma:no-cache as if it was Cache-Control:no-cache when Cache-Control is missing
         } else if (req_hdr->has(Http::HdrType::PRAGMA))
             no_cache = req_hdr->hasListMember(Http::HdrType::PRAGMA,"no-cache",',');
-
-        /*
-        * Work around for supporting the Reload button in IE browsers when Squid
-        * is used as an accelerator or transparent proxy, by turning accelerated
-        * IMS request to no-cache requests. Now knows about IE 5.5 fix (is
-        * actually only fixed in SP1, but we can't tell whether we are talking to
-        * SP1 or not so all 5.5 versions are treated 'normally').
-        */
-        if (Config.onoff.ie_refresh) {
-            if (http->flags.accel && request->flags.ims) {
-                if ((str = req_hdr->getStr(Http::HdrType::USER_AGENT))) {
-                    if (strstr(str, "MSIE 5.01") != NULL)
-                        no_cache=true;
-                    else if (strstr(str, "MSIE 5.0") != NULL)
-                        no_cache=true;
-                    else if (strstr(str, "MSIE 4.") != NULL)
-                        no_cache=true;
-                    else if (strstr(str, "MSIE 3.") != NULL)
-                        no_cache=true;
-                }
-            }
-        }
     }
 
     if (request->method == Http::METHOD_OTHER) {
@@ -110,7 +110,7 @@ comm_empty_os_read_buffers(int fd)
 
     /* prevent those nasty RST packets */
     char buf[SQUID_TCP_SO_RCVBUF];
-    if (fd_table[fd].flags.nonblocking) {
+    if (fd_table[fd].flags.nonblocking && fd_table[fd].type != FD_MSGHDR) {
         while (FD_READ_METHOD(fd, buf, SQUID_TCP_SO_RCVBUF) > 0) {};
     }
 #endif
@@ -1774,7 +1774,7 @@ DeferredReadManager::popHead(CbDataListContainer<DeferredRead> &deferredReads)
     //       amount of time. We must re-validate that it is active and usable.
 
     // If the connection has been closed already. Cancel this read.
-    if (!Comm::IsConnOpen(read.theRead.conn)) {
+    if (!fd_table || !Comm::IsConnOpen(read.theRead.conn)) {
         if (read.closer != NULL) {
             read.closer->cancel("Connection closed before.");
             read.closer = NULL;
@@ -278,7 +278,7 @@ ESIInclude::ESIInclude(ESIInclude const &old) :
 void
 ESIInclude::prepareRequestHeaders(HttpHeader &tempheaders, ESIVarState *vars)
 {
-    tempheaders.update (&vars->header(), NULL);
+    tempheaders.update(&vars->header());
     tempheaders.removeHopByHopEntries();
 }
 
@@ -14,13 +14,13 @@ ESI_PARSER_SOURCES = \
 	CustomParser.cc \
 	CustomParser.h
 
-if HAVE_LIBEXPAT
+if ENABLE_LIBEXPAT
 ESI_PARSER_SOURCES += \
 	ExpatParser.cc \
 	ExpatParser.h
 endif
 
-if HAVE_LIBXML2
+if ENABLE_LIBXML2
 ESI_PARSER_SOURCES += \
 	Libxml2Parser.cc \
 	Libxml2Parser.h
@@ -185,7 +185,7 @@ Rock::IoState::tryWrite(char const *buf, size_t size, off_t coreOff)
     assert(!coreOff || coreOff == -1);
 
     // throw if an accepted unknown-size entry grew too big or max-size changed
-    Must(offset_ + size <= static_cast<uint64_t>(dir->maxObjectSize()));
+    Must(static_cast<uint64_t>(offset_ + size) <= static_cast<uint64_t>(dir->maxObjectSize()));
 
     // allocate the first slice during the first write
     if (!coreOff) {
@@ -169,7 +169,7 @@ Fs::Ufs::UFSStoreState::write(char const *buf, size_t size, off_t aOffset, FREE
     }
 
     const Store::Disk &dir = *INDEXSD(swap_dirn);
-    if (offset_ + size > static_cast<uint64_t>(dir.maxObjectSize())) {
+    if (static_cast<uint64_t>(offset_ + size) > static_cast<uint64_t>(dir.maxObjectSize())) {
         debugs(79, 2, "accepted unknown-size entry grew too big: " <<
                (offset_ + size) << " > " << dir.maxObjectSize());
         free_func((void*)buf);
@@ -182,7 +182,7 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 79 "RegisteredHeadersHash.gperf"
     {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
 #line 85 "RegisteredHeadersHash.gperf"
-    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader},
 #line 94 "RegisteredHeadersHash.gperf"
     {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
     {""},
@@ -191,7 +191,7 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 51 "RegisteredHeadersHash.gperf"
     {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
 #line 87 "RegisteredHeadersHash.gperf"
-    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader},
 #line 80 "RegisteredHeadersHash.gperf"
     {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None},
 #line 26 "RegisteredHeadersHash.gperf"
@@ -221,7 +221,7 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 35 "RegisteredHeadersHash.gperf"
     {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
 #line 45 "RegisteredHeadersHash.gperf"
-    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader},
 #line 66 "RegisteredHeadersHash.gperf"
     {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
 #line 77 "RegisteredHeadersHash.gperf"
@@ -231,11 +231,11 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 49 "RegisteredHeadersHash.gperf"
     {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader},
 #line 46 "RegisteredHeadersHash.gperf"
-    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
 #line 91 "RegisteredHeadersHash.gperf"
-    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
 #line 72 "RegisteredHeadersHash.gperf"
-    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header},
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
 #line 33 "RegisteredHeadersHash.gperf"
     {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader},
 #line 113 "RegisteredHeadersHash.gperf"
@@ -250,17 +250,17 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
     {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
     {""},
 #line 74 "RegisteredHeadersHash.gperf"
-    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader},
 #line 55 "RegisteredHeadersHash.gperf"
     {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
 #line 41 "RegisteredHeadersHash.gperf"
-    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader},
 #line 101 "RegisteredHeadersHash.gperf"
     {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
 #line 83 "RegisteredHeadersHash.gperf"
     {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
 #line 32 "RegisteredHeadersHash.gperf"
-    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader},
 #line 36 "RegisteredHeadersHash.gperf"
     {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader},
 #line 105 "RegisteredHeadersHash.gperf"
@@ -292,7 +292,7 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 50 "RegisteredHeadersHash.gperf"
     {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader},
 #line 62 "RegisteredHeadersHash.gperf"
-    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader},
 #line 102 "RegisteredHeadersHash.gperf"
     {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
 #line 103 "RegisteredHeadersHash.gperf"
@@ -318,15 +318,15 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 99 "RegisteredHeadersHash.gperf"
     {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
 #line 42 "RegisteredHeadersHash.gperf"
-    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader},
 #line 106 "RegisteredHeadersHash.gperf"
     {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None},
 #line 68 "RegisteredHeadersHash.gperf"
     {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader},
 #line 44 "RegisteredHeadersHash.gperf"
-    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
 #line 37 "RegisteredHeadersHash.gperf"
-    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
 #line 53 "RegisteredHeadersHash.gperf"
     {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
 #line 111 "RegisteredHeadersHash.gperf"
@@ -338,12 +338,12 @@ static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
 #line 34 "RegisteredHeadersHash.gperf"
     {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
 #line 88 "RegisteredHeadersHash.gperf"
-    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
     {""},
 #line 108 "RegisteredHeadersHash.gperf"
     {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None},
 #line 40 "RegisteredHeadersHash.gperf"
-    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader},
 #line 73 "RegisteredHeadersHash.gperf"
     {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
     {""}, {""}, {""}, {""}, {""}, {""},
@@ -29,21 +29,21 @@ Accept-Encoding, Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrK
 Accept-Language, Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
 Accept-Ranges, Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
 Age, Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader
-Allow, Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Allow, Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
 Alternate-Protocol, Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader
 Authentication-Info, Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
 Authorization, Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
 Cache-Control, Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader
-Connection, Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Connection, Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
 Content-Base, Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
 Content-Disposition, Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None
-Content-Encoding, Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
-Content-Language, Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
-Content-Length, Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Encoding, Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
+Content-Language, Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
+Content-Length, Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader
 Content-Location, Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
-Content-MD5, Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
-Content-Range, Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header
-Content-Type, Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-MD5, Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-Range, Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader
+Content-Type, Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
 Cookie, Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None
 Cookie2, Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None
 Date, Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader
@@ -59,7 +59,7 @@ If-Modified-Since, Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_
 If-None-Match, Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader
 If-Range, Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None
 If-Unmodified-Since, Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None
-Keep-Alive, Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Keep-Alive, Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader
 Key, Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
 Last-Modified, Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader
 Link, Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
@@ -69,9 +69,9 @@ Mime-Version, Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::G
 Negotiate, Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None
 Origin, Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
 Pragma, Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
-Proxy-Authenticate, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header
+Proxy-Authenticate, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
 Proxy-Authentication-Info, Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
-Proxy-Authorization, Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Proxy-Authorization, Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader
 Proxy-Connection, Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
 Proxy-support, Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader
 Public, Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
@@ -82,13 +82,13 @@ Retry-After, Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::Rep
 Server, Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
 Set-Cookie, Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
 Set-Cookie2, Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
-TE, Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+TE, Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader
 Title, Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None
-Trailer, Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
-Transfer-Encoding, Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Trailer, Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader
+Transfer-Encoding, Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
 Translate, Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None
 Unless-Modified-Since, Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None
-Upgrade, Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Upgrade, Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
 User-Agent, Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
 Vary, Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
 Via, Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
@@ -1180,8 +1180,6 @@ mainInitialize(void)
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
-    httpReplyInitModule();  /* must go before accepting replies */
-
     errorInitialize();
 
     accessLogInit();
@@ -123,6 +123,29 @@ SBuf::reserveCapacity(size_type minCapacity)
     cow(minCapacity);
 }
 
+SBuf::size_type
+SBuf::reserve(const SBufReservationRequirements &req)
+{
+    debugs(24, 8, id << " was: " << off_ << '+' << len_ << '+' << spaceSize() <<
+           '=' << store_->capacity);
+
+    const bool mustRealloc = !req.allowShared && store_->LockCount() > 1;
+
+    if (!mustRealloc && spaceSize() >= req.minSpace)
+        return spaceSize(); // the caller is content with what we have
+
+    /* only reallocation can make the caller happy */
+
+    if (!mustRealloc && len_ >= req.maxCapacity)
+        return spaceSize(); // but we cannot reallocate
+
+    const size_type newSpace = std::min(req.idealSpace, maxSize - len_);
+    reserveCapacity(std::min(len_ + newSpace, req.maxCapacity));
+    debugs(24, 7, id << " now: " << off_ << '+' << len_ << '+' << spaceSize() <<
+           '=' << store_->capacity);
+    return spaceSize(); // reallocated and probably reserved enough space
+}
+
 char *
 SBuf::rawSpace(size_type minSpace)
 {
@@ -15,6 +15,7 @@
 #include "Debug.h"
 #include "globals.h"
 #include "sbuf/Exceptions.h"
+#include "sbuf/forward.h"
 #include "sbuf/MemBlob.h"
 #include "sbuf/Stats.h"
 
@@ -39,7 +40,6 @@ typedef enum {
 } SBufCaseSensitive;
 
 class CharacterSet;
-class SBuf;
 
 /** Forward input const_iterator for SBufs
  *
@@ -465,6 +465,12 @@ class SBuf
      */
     void reserveCapacity(size_type minCapacity);
 
+    /** Accommodate caller's requirements regarding SBuf's storage if possible.
+     *
+     * \return spaceSize(), which may be zero
+     */
+    size_type reserve(const SBufReservationRequirements &requirements);
+
     /** slicing method
      *
      * Removes SBuf prefix and suffix, leaving a sequence of 'n'
@@ -686,6 +692,22 @@ class SBuf
     SBuf& lowAppend(const char * memArea, size_type areaSize);
 };
 
+/// Named SBuf::reserve() parameters. Defaults ask for and restrict nothing.
+class SBufReservationRequirements
+{
+public:
+    typedef SBuf::size_type size_type;
+
+    /*
+     * Parameters are listed in the reverse order of importance: Satisfaction of
+     * the lower-listed requirements may violate the higher-listed requirements.
+     */
+    size_type idealSpace = 0; ///< if allocating anyway, provide this much space
+    size_type minSpace = 0; ///< allocate if spaceSize() is smaller
+    size_type maxCapacity = SBuf::maxSize; ///< do not allocate more than this
+    bool allowShared = true; ///< whether sharing our storage with others is OK
+};
+
 /// ostream output operator
 inline std::ostream &
 operator <<(std::ostream& os, const SBuf& S)
@@ -17,6 +17,7 @@ class MemBlob;
 class SBuf;
 class SBufIterator;
 class SBufReverseIterator;
+class SBufReservationRequirements;
 
 class OutOfBoundsException;
 class InvalidParamException;
@@ -240,7 +240,7 @@ Security::PeerOptions::createBlankContext() const
     }
 
 #else
-    fatal("Failed to allocate TLS client context: No TLS library\n");
+    debugs(83, 1, "WARNING: Failed to allocate TLS client context: No TLS library");
 
 #endif
 
@@ -250,20 +250,14 @@ Security::PeerOptions::createBlankContext() const
 Security::ContextPtr
 Security::PeerOptions::createClientContext(bool setOptions)
 {
-    Security::ContextPtr t = nullptr;
-
     updateTlsVersionLimits();
 
+    Security::ContextPtr t = createBlankContext();
+    if (t) {
 #if USE_OPENSSL
-    // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
-    t = sslCreateClientContext(*this, (setOptions ? parsedOptions : 0), parsedFlags);
-
-#elif USE_GNUTLS && WHEN_READY_FOR_GNUTLS
-    t = createBlankContext();
-
+        // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
+        Ssl::InitClientContext(t, *this, (setOptions ? parsedOptions : 0), parsedFlags);
 #endif
-
-    if (t) {
         updateContextNpn(t);
         updateContextCa(t);
         updateContextCrl(t);
@@ -593,10 +587,12 @@ void
 Security::PeerOptions::updateContextCa(Security::ContextPtr &ctx)
 {
     debugs(83, 8, "Setting CA certificate locations.");
-
+#if USE_OPENSSL
+    const char *path = caDir.isEmpty() ? nullptr : caDir.c_str();
+#endif
     for (auto i : caFiles) {
 #if USE_OPENSSL
-        if (!SSL_CTX_load_verify_locations(ctx, i.c_str(), caDir.c_str())) {
+        if (!SSL_CTX_load_verify_locations(ctx, i.c_str(), path)) {
             const int ssl_error = ERR_get_error();
             debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
         }
@@ -117,6 +117,23 @@ Security::ServerOptions::createBlankContext() const
     return t;
 }
 
+bool
+Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &port)
+{
+    updateTlsVersionLimits();
+
+    Security::ContextPointer t(createBlankContext());
+    if (t) {
+#if USE_OPENSSL
+        if (!Ssl::InitServerContext(t, port))
+            return false;
+#endif
+    }
+
+    staticContext = std::move(t);
+    return bool(staticContext);
+}
+
 void
 Security::ServerOptions::loadDhParams()
 {
@@ -9,6 +9,7 @@
 #ifndef SQUID_SRC_SECURITY_SERVEROPTIONS_H
 #define SQUID_SRC_SECURITY_SERVEROPTIONS_H
 
+#include "anyp/forward.h"
 #include "security/PeerOptions.h"
 
 namespace Security
@@ -31,6 +32,11 @@ class ServerOptions : public PeerOptions
     virtual Security::ContextPtr createBlankContext() const;
     virtual void dumpCfg(Packable *, const char *pfx) const;
 
+    /// generate a security server-context from these configured options
+    /// the resulting context is stored in staticContext
+    /// \returns true if a context could be created
+    bool createStaticServerContext(AnyP::PortCfg &);
+
     /// update the context with DH, EDH, EECDH settings
     void updateContextEecdh(Security::ContextPtr &);
 
@@ -16,6 +16,45 @@
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
+bool
+Security::SessionIsResumed(const Security::SessionPointer &s)
+{
+    return
+#if USE_OPENSSL
+        SSL_session_reused(s.get()) == 1;
+#elif USE_GNUTLS
+        gnutls_session_is_resumed(s.get()) != 0;
+#else
+        false;
+#endif
+}
+
+void
+Security::GetSessionResumeData(const Security::SessionPointer &s, Security::SessionStatePointer &data)
+{
+    if (!SessionIsResumed(s)) {
+#if USE_OPENSSL
+        data.reset(SSL_get1_session(s.get()));
+#elif USE_GNUTLS
+        gnutls_datum_t *tmp = nullptr;
+        (void)gnutls_session_get_data2(s.get(), tmp);
+        data.reset(tmp);
+#endif
+    }
+}
+
+void
+Security::SetSessionResumeData(const Security::SessionPtr &s, const Security::SessionStatePointer &data)
+{
+    if (s) {
+#if USE_OPENSSL
+        (void)SSL_set_session(s, data.get());
+#elif USE_GNUTLS
+        (void)gnutls_session_set_data(s, data->data, data->size);
+#endif
+    }
+}
+
 static bool
 isTlsServer()
 {
@@ -31,6 +31,10 @@ typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer<SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL> SessionPointer;
 
+typedef SSL_SESSION* SessionStatePtr;
+CtoCpp1(SSL_SESSION_free, SSL_SESSION *);
+typedef LockingPointer<SSL_SESSION, Security::SSL_SESSION_free_cpp, CRYPTO_LOCK_SSL_SESSION> SessionStatePointer;
+
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
 CtoCpp1(gnutls_deinit, gnutls_session_t);
@@ -40,13 +44,28 @@ CtoCpp1(gnutls_deinit, gnutls_session_t);
 // library functions
 typedef TidyPointer<struct gnutls_session_int, Security::gnutls_deinit_cpp> SessionPointer;
 
+typedef gnutls_datum_t *SessionStatePtr;
+CtoCpp1(gnutls_free, gnutls_datum_t *);
+typedef TidyPointer<gnutls_datum_t, Security::gnutls_free_cpp> SessionStatePointer;
+
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
 typedef TidyPointer<void, nullptr> SessionPointer;
+typedef TidyPointer<void, nullptr> SessionStatePointer;
 
 #endif
 
+/// whether the session is a resumed one
+bool SessionIsResumed(const Security::SessionPointer &);
+
+/// Retrieve the data needed to resume this session on a later connection
+void GetSessionResumeData(const Security::SessionPointer &, Security::SessionStatePointer &);
+
+/// Set the data for resuming a previous session.
+/// Needs to be done before using the SessionPointer for a handshake.
+void SetSessionResumeData(const Security::SessionPtr &, const Security::SessionStatePointer &);
+
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
@@ -114,7 +114,7 @@ parameters.
 .PP
 For example:
 .if !'po4a'hide' .RS
-.if !'po4a'hide' .B security_file_certgen -c -s @DEFAULT_SSL_DB_DIR@
+.if !'po4a'hide' .B @DEFAULT_SSL_CRTD@ -c -s @DEFAULT_SSL_DB_DIR@
 .if !'po4a'hide' .RE
 .
 .PP
@@ -126,7 +126,7 @@ For simple configuration the helper defaults can be used.
 Only HTTP listening port options are required to enable generation and set the signign CA certificate.
 For Example:
 .if !'po4a'hide' .RS
-.if !'po4a'hide' .B http_port 3128 ssl-bump generate-host-certificates=on dynamic_cert_mem_cache_size=4MB cert=@SYSCONFDIR@/ssl_cert/www.sample.com.pem
+.if !'po4a'hide' .B http_port 3128 ssl-bump generate-host-certificates=on dynamic_cert_mem_cache_size=4MB cert=@SYSCONFDIR@/ssl_cert/example.com.pem
 .if !'po4a'hide' .RE
 .
 .PP
@@ -220,12 +220,18 @@ Ftp::Server::shovelUploadData()
 void
 Ftp::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 {
+    if (!isOpen()) // if we are closing, nothing to do
+        return;
+
     shovelUploadData();
 }
 
 void
 Ftp::Server::noteBodyConsumerAborted(BodyPipe::Pointer ptr)
 {
+    if (!isOpen()) // if we are closing, nothing to do
+        return;
+
     ConnStateData::noteBodyConsumerAborted(ptr);
     closeDataConnection();
 }
@@ -1731,6 +1737,9 @@ Ftp::Server::callException(const std::exception &e)
 void
 Ftp::Server::startWaitingForOrigin()
 {
+    if (!isOpen()) // if we are closing, nothing to do
+        return;
+
     debugs(33, 5, "waiting for Ftp::Client data transfer to end");
     waitingForOrigin = true;
 }
@@ -1741,6 +1750,9 @@ Ftp::Server::stopWaitingForOrigin(int originStatus)
     Must(waitingForOrigin);
     waitingForOrigin = false;
 
+    if (!isOpen()) // if we are closing, nothing to do
+        return;
+
     // if we have already decided how to respond, respond now
     if (delayedReply) {
         HttpReply::Pointer reply = delayedReply;
@@ -61,26 +61,24 @@ Server::stopReading()
     }
 }
 
-bool
+/// Prepare inBuf for I/O. This method balances several conflicting desires:
+/// 1. Do not read too few bytes at a time.
+/// 2. Do not waste too much buffer space.
+/// 3. Do not [re]allocate or memmove the buffer too much.
+/// 4. Obey Config.maxRequestBufferSize limit.
+void
 Server::maybeMakeSpaceAvailable()
 {
-    if (inBuf.spaceSize() < 2) {
-        const SBuf::size_type haveCapacity = inBuf.length() + inBuf.spaceSize();
-        if (haveCapacity >= Config.maxRequestBufferSize) {
-            debugs(33, 4, "request buffer full: client_request_buffer_max_size=" << Config.maxRequestBufferSize);
-            return false;
-        }
-        if (haveCapacity == 0) {
-            // haveCapacity is based on the SBuf visible window of the MemBlob buffer, which may fill up.
-            // at which point bump the buffer back to default. This allocates a new MemBlob with any un-parsed bytes.
-            inBuf.reserveCapacity(CLIENT_REQ_BUF_SZ);
-        } else {
-            const SBuf::size_type wantCapacity = min(static_cast<SBuf::size_type>(Config.maxRequestBufferSize), haveCapacity*2);
-            inBuf.reserveCapacity(wantCapacity);
-        }
-        debugs(33, 2, "growing request buffer: available=" << inBuf.spaceSize() << " used=" << inBuf.length());
-    }
-    return (inBuf.spaceSize() >= 2);
+    // The hard-coded parameters are arbitrary but seem reasonable.
+    // A careful study of Squid I/O and parsing patterns is needed to tune them.
+    SBufReservationRequirements requirements;
+    requirements.minSpace = 1024; // smaller I/Os are not worth their overhead
+    requirements.idealSpace = CLIENT_REQ_BUF_SZ; // we expect few larger I/Os
+    requirements.maxCapacity = Config.maxRequestBufferSize;
+    requirements.allowShared = true; // allow because inBuf is used immediately
+    inBuf.reserve(requirements);
+    if (!inBuf.spaceSize())
+        debugs(33, 4, "request buffer full: client_request_buffer_max_size=" << Config.maxRequestBufferSize);
 }
 
 void
@@ -90,7 +90,7 @@ class Server : virtual public AsyncJob, public BodyProducer
 public:
 
     /// grows the available read buffer space (if possible)
-    bool maybeMakeSpaceAvailable();
+    void maybeMakeSpaceAvailable();
 
     // Client TCP connection details from comm layer.
     Comm::ConnectionPointer clientConnection;
@@ -46,8 +46,7 @@ Ssl::BlindPeerConnector::initializeSsl()
         SBuf *host = new SBuf(peer->secure.sslDomain);
         SSL_set_ex_data(ssl, ssl_ex_index_server, host);
 
-        if (peer->sslSession)
-            SSL_set_session(ssl, peer->sslSession);
+        Security::SetSessionResumeData(ssl, peer->sslSession);
     } else {
         SBuf *hostName = new SBuf(request->url.host());
         SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
@@ -70,13 +69,9 @@ Ssl::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
     }
 
-    const int fd = serverConnection()->fd;
-    Security::SessionPtr ssl = fd_table[fd].ssl.get();
-    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
-        if (serverConnection()->getPeer()->sslSession)
-            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
-
-        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
+    if (auto *peer = serverConnection()->getPeer()) {
+        const int fd = serverConnection()->fd;
+        Security::GetSessionResumeData(fd_table[fd].ssl, peer->sslSession);
     }
 }
 
@@ -264,13 +264,95 @@ std::string & Ssl::CertificateProperties::dbKey() const
     return certKey;
 }
 
+/// Check if mimicCert certificate has the Authority Key Identifier extension
+/// and if yes add the extension to cert certificate with the same fields if
+/// possible. If the issuerCert certificate  does not have the Subject Key
+/// Identifier extension (required to build the keyIdentifier field of
+/// AuthorityKeyIdentifier) then the authorityCertIssuer and
+/// authorityCertSerialNumber fields added.
+static bool
+mimicAuthorityKeyId(Security::CertPointer &cert, Security::CertPointer const &mimicCert, Security::CertPointer const &issuerCert)
+{
+    if (!mimicCert.get() || !issuerCert.get())
+        return false;
+
+    Ssl::AUTHORITY_KEYID_Pointer akid((AUTHORITY_KEYID *)X509_get_ext_d2i(mimicCert.get(), NID_authority_key_identifier, nullptr, nullptr));
+
+    bool addKeyId = false, addIssuer = false;
+    if (akid.get()) {
+        addKeyId = (akid.get()->keyid != nullptr);
+        addIssuer = (akid.get()->issuer && akid.get()->serial);
+    }
+
+    if (!addKeyId && !addIssuer)
+        return false; // No need to add AuthorityKeyIdentifier
+
+    Ssl::ASN1_OCTET_STRING_Pointer issuerKeyId;
+    if (addKeyId) {
+        X509_EXTENSION *ext;
+        // Check if the issuer has the Subject Key Identifier extension
+        const int indx = X509_get_ext_by_NID(issuerCert.get(), NID_subject_key_identifier, -1);
+        if (indx >= 0 && (ext = X509_get_ext(issuerCert.get(), indx))) {
+            issuerKeyId.reset((ASN1_OCTET_STRING *)X509V3_EXT_d2i(ext));
+        }
+    }
+
+    Ssl::X509_NAME_Pointer issuerName;
+    Ssl::ASN1_INT_Pointer issuerSerial;
+    if (issuerKeyId.get() == nullptr || addIssuer) {
+        issuerName.reset(X509_NAME_dup(X509_get_issuer_name(issuerCert.get())));
+        issuerSerial.reset(M_ASN1_INTEGER_dup(X509_get_serialNumber(issuerCert.get())));
+    }
+
+    Ssl::AUTHORITY_KEYID_Pointer theAuthKeyId(AUTHORITY_KEYID_new());
+    if (!theAuthKeyId.get())
+        return false;
+    theAuthKeyId.get()->keyid = issuerKeyId.release();
+    if (issuerName && issuerSerial) {
+        Ssl::GENERAL_NAME_STACK_Pointer genNames(sk_GENERAL_NAME_new_null());
+        if (genNames.get()) {
+            if (GENERAL_NAME *aname = GENERAL_NAME_new()) {
+                sk_GENERAL_NAME_push(genNames.get(), aname);
+                aname->type = GEN_DIRNAME;
+                aname->d.dirn = issuerName.release();
+                theAuthKeyId.get()->issuer = genNames.release();
+                theAuthKeyId.get()->serial = issuerSerial.release();
+            }
+        }
+    }
+
+    // The Authority Key Identifier extension should include KeyId or/and both
+    /// issuer name and issuer serial
+    if (!theAuthKeyId.get()->keyid && (!theAuthKeyId.get()->issuer || !theAuthKeyId.get()->serial))
+        return false;
+
+    const X509V3_EXT_METHOD *method = X509V3_EXT_get_nid(NID_authority_key_identifier);
+    if (!method)
+        return false;
+
+    unsigned char *ext_der = NULL;
+    int ext_len = ASN1_item_i2d((ASN1_VALUE *)theAuthKeyId.get(), &ext_der, ASN1_ITEM_ptr(method->it));
+    Ssl::ASN1_OCTET_STRING_Pointer extOct(M_ASN1_OCTET_STRING_new());
+    extOct.get()->data = ext_der;
+    extOct.get()->length = ext_len;
+    Ssl::X509_EXTENSION_Pointer extAuthKeyId(X509_EXTENSION_create_by_NID(NULL, NID_authority_key_identifier, 0, extOct.get()));
+    if (!extAuthKeyId.get())
+        return false;
+
+    extOct.release();
+    if (!X509_add_ext(cert.get(), extAuthKeyId.get(), -1))
+        return false;
+
+    return true;
+}
+
 /// Copy certificate extensions from cert to mimicCert.
 /// Returns the number of extensions copied.
 // Currently only extensions which are reported by the users that required are
 // mimicked. More safe to mimic extensions would be added here if users request
 // them.
 static int
-mimicExtensions(Security::CertPointer & cert, Security::CertPointer const & mimicCert)
+mimicExtensions(Security::CertPointer & cert, Security::CertPointer const &mimicCert, Security::CertPointer const &issuerCert)
 {
     static int extensions[]= {
         NID_key_usage,
@@ -333,6 +415,9 @@ mimicExtensions(Security::CertPointer & cert, Security::CertPointer const & mimi
         }
     }
 
+    if (mimicAuthorityKeyId(cert, mimicCert, issuerCert))
+        ++added;
+
     // We could also restrict mimicking of the CA extension to CA:FALSE
     // because Squid does not generate valid fake CA certificates.
 
@@ -409,7 +494,7 @@ static bool buildCertificate(Security::CertPointer & cert, Ssl::CertificatePrope
             }
         }
 
-        addedExtensions += mimicExtensions(cert, properties.mimicCert);
+        addedExtensions += mimicExtensions(cert, properties.mimicCert, properties.signWithX509);
 
         // According to RFC 5280, using extensions requires v3 certificate.
         if (addedExtensions)
@@ -15,6 +15,9 @@
 #if HAVE_OPENSSL_TXT_DB_H
 #include <openssl/txt_db.h>
 #endif
+#if HAVE_OPENSSL_X509V3_H
+#include <openssl/x509v3.h>
+#endif
 #include <string>
 
 namespace Ssl
@@ -54,6 +57,9 @@ typedef TidyPointer<BIO, BIO_free_cpp> BIO_Pointer;
 CtoCpp1(ASN1_INTEGER_free, ASN1_INTEGER *)
 typedef TidyPointer<ASN1_INTEGER, ASN1_INTEGER_free_cpp> ASN1_INT_Pointer;
 
+CtoCpp1(ASN1_OCTET_STRING_free, ASN1_OCTET_STRING *)
+typedef TidyPointer<ASN1_OCTET_STRING, ASN1_OCTET_STRING_free_cpp> ASN1_OCTET_STRING_Pointer;
+
 CtoCpp1(TXT_DB_free, TXT_DB *)
 typedef TidyPointer<TXT_DB, TXT_DB_free_cpp> TXT_DB_Pointer;
 
@@ -69,6 +75,18 @@ typedef TidyPointer<X509_REQ, X509_REQ_free_cpp> X509_REQ_Pointer;
 sk_free_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free)
 typedef TidyPointer<STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper> X509_NAME_STACK_Pointer;
 
+CtoCpp1(AUTHORITY_KEYID_free, AUTHORITY_KEYID *)
+typedef TidyPointer<AUTHORITY_KEYID, AUTHORITY_KEYID_free_cpp> AUTHORITY_KEYID_Pointer;
+
+sk_free_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free)
+typedef TidyPointer<STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper> GENERAL_NAME_STACK_Pointer;
+
+CtoCpp1(GENERAL_NAME_free, GENERAL_NAME *)
+typedef TidyPointer<GENERAL_NAME, GENERAL_NAME_free_cpp> GENERAL_NAME_Pointer;
+
+CtoCpp1(X509_EXTENSION_free, X509_EXTENSION *)
+typedef TidyPointer<X509_EXTENSION, X509_EXTENSION_free_cpp> X509_EXTENSION_Pointer;
+
 /**
  \ingroup SslCrtdSslAPI
  * Create 1024 bits rsa key.
@@ -560,77 +560,69 @@ configureSslContext(Security::ContextPtr sslContext, AnyP::PortCfg &port)
     return true;
 }
 
-Security::ContextPtr
-sslCreateServerContext(AnyP::PortCfg &port)
+bool
+Ssl::InitServerContext(const Security::ContextPointer &ctx, AnyP::PortCfg &port)
 {
-    Security::ContextPtr sslContext(port.secure.createBlankContext());
-    if (!sslContext)
-        return nullptr;
+    if (!ctx)
+        return false;
 
-    if (!SSL_CTX_use_certificate(sslContext, port.signingCert.get())) {
+    if (!SSL_CTX_use_certificate(ctx.get(), port.signingCert.get())) {
         const int ssl_error = ERR_get_error();
         const auto &keys = port.secure.certs.front();
         debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS certificate '" << keys.certFile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
-        return NULL;
+        return false;
     }
 
-    if (!SSL_CTX_use_PrivateKey(sslContext, port.signPkey.get())) {
+    if (!SSL_CTX_use_PrivateKey(ctx.get(), port.signPkey.get())) {
         const int ssl_error = ERR_get_error();
         const auto &keys = port.secure.certs.front();
         debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS private key '" << keys.privateKeyFile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
-        return NULL;
+        return false;
     }
 
-    Ssl::addChainToSslContext(sslContext, port.certsToChain.get());
+    Ssl::addChainToSslContext(ctx.get(), port.certsToChain.get());
 
     /* Alternate code;
         debugs(83, DBG_IMPORTANT, "Using certificate in " << certfile);
 
-        if (!SSL_CTX_use_certificate_chain_file(sslContext, certfile)) {
+        if (!SSL_CTX_use_certificate_chain_file(ctx.get(), certfile)) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << certfile << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
-            return NULL;
+            return false;
         }
 
         debugs(83, DBG_IMPORTANT, "Using private key in " << keyfile);
-        ssl_ask_password(sslContext, keyfile);
+        ssl_ask_password(ctx.get(), keyfile);
 
-        if (!SSL_CTX_use_PrivateKey_file(sslContext, keyfile, SSL_FILETYPE_PEM)) {
+        if (!SSL_CTX_use_PrivateKey_file(ctx.get(), keyfile, SSL_FILETYPE_PEM)) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << keyfile << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
-            return NULL;
+            return false;
         }
 
         debugs(83, 5, "Comparing private and public SSL keys.");
 
-        if (!SSL_CTX_check_private_key(sslContext)) {
+        if (!SSL_CTX_check_private_key(ctx.get())) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: SSL private key '" << certfile << "' does not match public key '" <<
                    keyfile << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
-            return NULL;
+            return false;
         }
     */
 
-    if (!configureSslContext(sslContext, port)) {
+    if (!configureSslContext(ctx.get(), port)) {
         debugs(83, DBG_CRITICAL, "ERROR: Configuring static SSL context");
-        SSL_CTX_free(sslContext);
-        return NULL;
+        return false;
     }
 
-    return sslContext;
+    return true;
 }
 
-Security::ContextPtr
-sslCreateClientContext(Security::PeerOptions &peer, long options, long fl)
+bool
+Ssl::InitClientContext(Security::ContextPtr &sslContext, Security::PeerOptions &peer, long options, long fl)
 {
-    Security::ContextPtr sslContext(peer.createBlankContext());
     if (!sslContext)
-        return nullptr;
+        return false;
 
     SSL_CTX_set_options(sslContext, options);
 
@@ -693,7 +685,7 @@ sslCreateClientContext(Security::PeerOptions &peer, long options, long fl)
         SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
     }
 
-    return sslContext;
+    return true;
 }
 
 /// \ingroup ServerProtocolSSLInternal
@@ -112,13 +112,13 @@ void SetSessionCallbacks(Security::ContextPtr);
 extern Ipc::MemMap *SessionCache;
 extern const char *SessionCacheName;
 
-} //namespace Ssl
+/// initialize a TLS server context with OpenSSL specific settings
+bool InitServerContext(const Security::ContextPointer &, AnyP::PortCfg &);
 
-/// \ingroup ServerProtocolSSLAPI
-Security::ContextPtr sslCreateServerContext(AnyP::PortCfg &port);
+/// initialize a TLS client context with OpenSSL specific settings
+bool InitClientContext(Security::ContextPtr &, Security::PeerOptions &, long options, long flags);
 
-/// \ingroup ServerProtocolSSLAPI
-Security::ContextPtr sslCreateClientContext(Security::PeerOptions &, long options, long flags);
+} //namespace Ssl
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_read_method(int, char *, int);
@@ -599,8 +599,6 @@ getKeyCounter(void)
 void
 StoreEntry::setPrivateKey()
 {
-    const cache_key *newkey;
-
     if (key && EBIT_TEST(flags, KEY_PRIVATE))
         return;                 /* is already private */
 
@@ -614,12 +612,9 @@ StoreEntry::setPrivateKey()
         hashDelete();
     }
 
-    if (mem_obj && mem_obj->hasUris()) {
+    if (mem_obj && mem_obj->hasUris())
         mem_obj->id = getKeyCounter();
-        newkey = storeKeyPrivate(mem_obj->storeId(), mem_obj->method, mem_obj->id);
-    } else {
-        newkey = storeKeyPrivate("JUNK", Http::METHOD_NONE, getKeyCounter());
-    }
+    const cache_key *newkey = storeKeyPrivate();
 
     assert(hash_lookup(store_table, newkey) == NULL);
     EBIT_SET(flags, KEY_PRIVATE);
@@ -80,18 +80,18 @@ storeKeyHashHash(const void *key, unsigned int n)
 }
 
 const cache_key *
-storeKeyPrivate(const char *url, const HttpRequestMethod& method, int id)
+storeKeyPrivate()
 {
-    static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
-    SquidMD5_CTX M;
-    assert(id > 0);
-    debugs(20, 3, "storeKeyPrivate: " << method << " " << url);
-    SquidMD5Init(&M);
-    SquidMD5Update(&M, (unsigned char *) &id, sizeof(id));
-    SquidMD5Update(&M, (unsigned char *) &method, sizeof(method));
-    SquidMD5Update(&M, (unsigned char *) url, strlen(url));
-    SquidMD5Final(digest, &M);
-    return digest;
+    // only the count field is required
+    // others just simplify searching for keys in a multi-process cache.log
+    static struct {
+        uint64_t count;
+        pid_t pid;
+        int32_t kid;
+    } key = { 0, getpid(), KidIdentifier };
+    assert(sizeof(key) == SQUID_MD5_DIGEST_LENGTH);
+    ++key.count;
+    return reinterpret_cast<cache_key*>(&key);
 }
 
 const cache_key *
@@ -25,7 +25,7 @@ const char *storeKeyText(const cache_key *);
 const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
 const cache_key *storeKeyPublicByRequest(HttpRequest *);
 const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
-const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
+const cache_key *storeKeyPrivate();
 int storeKeyHashBuckets(int);
 int storeKeyNull(const cache_key *);
 void storeKeyInit(void);
@@ -53,6 +53,7 @@ char *SBuf::rawSpace(size_type minSize) STUB_RETVAL(NULL)
 void SBuf::forceSize(size_type newSize) STUB
 const char* SBuf::c_str() STUB_RETVAL("")
 void SBuf::reserveCapacity(size_type minCapacity) STUB
+SBuf::size_type SBuf::reserve(const SBufReservationRequirements &) STUB_RETVAL(0)
 SBuf& SBuf::chop(size_type pos, size_type n) STUB_RETVAL(*this)
 SBuf& SBuf::trim(const SBuf &toRemove, bool atBeginning, bool atEnd) STUB_RETVAL(*this)
 SBuf SBuf::substr(size_type pos, size_type n) const STUB_RETVAL(*this)
@@ -14,8 +14,8 @@
 
 class StatHist;
 
-void recordSBufSizeAtDestruct(SBuf::size_type) STUB_NOP
+void recordSBufSizeAtDestruct(SBuf::size_type) {} // STUB_NOP
 const StatHist * collectSBufDestructTimeStats() STUB_RETVAL(nullptr)
-void recordMemBlobSizeAtDestruct(SBuf::size_type) STUB_NOP
+void recordMemBlobSizeAtDestruct(SBuf::size_type) {} // STUB_NOP
 const StatHist * collectMemBlobDestructTimeStats() STUB_RETVAL(nullptr)
 
@@ -34,6 +34,7 @@ void parse_securePeerOptions(Security::PeerOptions *) STUB
 void Security::ServerOptions::parse(const char *) STUB
 void Security::ServerOptions::dumpCfg(Packable *, const char *) const STUB
 Security::ContextPtr Security::ServerOptions::createBlankContext() const STUB
+bool Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &) STUB_RETVAL(false)
 void Security::ServerOptions::updateContextEecdh(Security::ContextPtr &) STUB
 
 #include "security/NegotiationHistory.h"
@@ -47,3 +48,10 @@ const char *Security::NegotiationHistory::printTlsVersion(AnyP::ProtocolVersion
 Security::HandshakeParser::HandshakeParser() STUB
 bool Security::HandshakeParser::parseHello(const SBuf &) STUB_RETVAL(false)
 
+#include "security/Session.h"
+namespace Security {
+bool SessionIsResumed(const Security::SessionPointer &) STUB_RETVAL(false)
+void GetSessionResumeData(const Security::SessionPointer &, Security::SessionStatePointer &) STUB
+void SetSessionResumeData(const Security::SessionPtr &, const Security::SessionStatePointer &) STUB
+} // namespace Security
+
@@ -55,9 +55,9 @@ namespace Ssl
 CertError & CertError::operator = (const CertError &old) STUB_RETVAL(*this)
 bool CertError::operator == (const CertError &ce) const STUB_RETVAL(false)
 bool CertError::operator != (const CertError &ce) const STUB_RETVAL(false)
+bool InitServerContext(const Security::ContextPointer &, AnyP::PortCfg &) STUB_RETVAL(false)
+bool InitClientContext(Security::ContextPtr &, Security::PeerOptions &, long, const char *) STUB_RETVAL(false)
 } // namespace Ssl
-Security::ContextPtr sslCreateServerContext(AnyP::PortCfg &port) STUB_RETVAL(NULL)
-Security::ContextPtr sslCreateClientContext(Security::PeerOptions &, long, const char *) STUB_RETVAL(nullptr)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
 void ssl_shutdown_method(SSL *ssl) STUB
@@ -146,8 +146,6 @@ testRock::commonInit()
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
-    httpReplyInitModule();  /* must go before accepting replies */
-
     mem_policy = createRemovalPolicy(Config.replPolicy);
 
     inited = true;
@@ -812,6 +812,40 @@ testSBuf::testGrow()
     CPPUNIT_ASSERT_EQUAL(ref,match);
 }
 
+void
+testSBuf::testReserve()
+{
+    SBufReservationRequirements requirements;
+    // use unusual numbers to ensure we dont hit a lucky boundary situation
+    requirements.minSpace = 10;
+    requirements.idealSpace = 82;
+    requirements.maxCapacity = 259;
+    requirements.allowShared = true;
+
+    // for each possible starting buffer length within the capacity
+    for (SBuf::size_type startLength = 0; startLength <= requirements.maxCapacity; ++startLength) {
+        std::cerr << ".";
+        SBuf b;
+        b.reserveCapacity(startLength);
+        CPPUNIT_ASSERT_EQUAL(b.length(), static_cast<unsigned int>(0));
+        CPPUNIT_ASSERT_EQUAL(b.spaceSize(), startLength);
+
+        // check that it never grows outside capacity.
+        // do 5 excess cycles to check that.
+        for (SBuf::size_type filled = 0; filled < requirements.maxCapacity +5; ++filled) {
+            CPPUNIT_ASSERT_EQUAL(b.length(), min(filled, requirements.maxCapacity));
+            auto x = b.reserve(requirements);
+            // the amount of space advertized must not cause users to exceed capacity
+            CPPUNIT_ASSERT(x <= requirements.maxCapacity - filled);
+            CPPUNIT_ASSERT(b.spaceSize() <= requirements.maxCapacity - filled);
+            // the total size of buffer must not cause users to exceed capacity
+            CPPUNIT_ASSERT(b.length() + b.spaceSize() <= requirements.maxCapacity);
+            if (x > 0)
+                b.append('X');
+        }
+    }
+}
+
 void
 testSBuf::testStartsWith()
 {
@@ -49,6 +49,7 @@ class testSBuf : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testCopy );
     CPPUNIT_TEST( testStringOps );
     CPPUNIT_TEST( testGrow );
+    CPPUNIT_TEST( testReserve );
     CPPUNIT_TEST( testSBufStream );
     CPPUNIT_TEST( testAutoFind );
     CPPUNIT_TEST( testStdStringOps );
@@ -87,6 +88,7 @@ class testSBuf : public CPPUNIT_NS::TestFixture
     void testCopy();
     void testStringOps();
     void testGrow();
+    void testReserve();
     void testStartsWith();
     void testSBufStream();
     void testFindFirstOf();
@@ -76,8 +76,6 @@ testUfs::commonInit()
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
-    httpReplyInitModule();  /* must go before accepting replies */
-
     inited = true;
 }
 
@@ -718,6 +718,8 @@ writePidFile(void)
     mode_t old_umask;
     char buf[32];
 
+    debugs(50, DBG_IMPORTANT, "creating PID file: " << Config.pidFilename);
+
     if ((f = Config.pidFilename) == NULL)
         return;
 
@@ -751,6 +753,7 @@ void
 removePidFile()
 {
     if (Config.pidFilename && strcmp(Config.pidFilename, "none") != 0) {
+        debugs(50, DBG_IMPORTANT, "removing PID file: " << Config.pidFilename);
         enter_suid();
         safeunlink(Config.pidFilename, 0);
         leave_suid();
@@ -27,10 +27,10 @@ EXTRA_DIST = \
 ESI_ALL_TESTS = \
 	ESIExpressions
 
-if USE_ESI
+if ENABLE_ESI
   ESI_TESTS = $(ESI_ALL_TESTS)
 else
-  ESI_TESTS = 
+  ESI_TESTS =
 endif
 
 ## Sort by dependencies - test lowest layers first
@@ -28,7 +28,6 @@ MAKETEST="distcheck"
 #   --without-default-user \
 #   --without-aufs-threads \
 #   --without-filedescriptors \
-#   --without-cppunit-basedir \
 #   --without-build-environment \
 #
 #
@@ -30,7 +30,6 @@ MAKETEST="distcheck"
 #   --with-default-user=NAME \
 #   --with-aufs-threads=N \
 #   --with-filedescriptors=N \
-#   --with-cppunit-basedir=PATH \
 #   --with-po2html=PATH \
 #   --with-tags=TAGS \
 #
@@ -30,7 +30,6 @@ MAKETEST="distcheck"
 #   --with-default-user=NAME \
 #   --with-aufs-threads=N \
 #   --with-filedescriptors=N \
-#   --with-cppunit-basedir=PATH \
 #   --with-openssl=PATH \
 #   --with-po2html=PATH \
 #   --with-tags=TAGS \
@@ -31,7 +31,6 @@ DISTCHECK_CONFIGURE_FLAGS=" \
 	--datadir=/usr/share/squid3 \
 	--sysconfdir=/etc/squid3 \
 	--mandir=/usr/share/man \
-	--with-cppunit-basedir=/usr \
 	--with-default-user=proxy \
  \
 	--disable-maintainer-mode \
@@ -30,7 +30,6 @@ DISTCHECK_CONFIGURE_FLAGS=" \
 	--datadir=/usr/share/squid3 \
 	--sysconfdir=/etc/squid3 \
 	--mandir=/usr/share/man \
-	--with-cppunit-basedir=/usr \
 	--with-default-user=proxy \
  \
 	--disable-maintainer-mode \