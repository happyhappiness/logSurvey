@@ -1,5 +1,5 @@
 /*
- * $Id: ACLChecklist.cc,v 1.12 2003/05/18 00:04:07 robertc Exp $
+ * $Id: ACLChecklist.cc,v 1.13 2003/07/11 01:40:33 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -220,7 +220,7 @@ ACLChecklist::checkCallback(allow_t answer)
         /* the checklist lock */
         authenticateAuthUserRequestUnlock(auth_user_request);
         /* it might have been connection based */
-        assert(conn());
+        assert(conn().getRaw() != NULL);
         conn()->auth_user_request = NULL;
         conn()->auth_type = AUTH_BROKEN;
         auth_user_request = NULL;
@@ -329,24 +329,24 @@ ACLChecklist::~ACLChecklist()
 
     request = NULL;
 
-    cbdataReferenceDone(conn_);
+    conn_ = NULL;
 
     cbdataReferenceDone(accessList);
 
     debug (28,4)("ACLChecklist::~ACLChecklist: destroyed %p\n", this);
 }
 
 
-ConnStateData *
+ConnStateData::Pointer
 ACLChecklist::conn()
 {
     return  conn_;
 }
 
 void
-ACLChecklist::conn(ConnStateData *aConn)
+ACLChecklist::conn(ConnStateData::Pointer aConn)
 {
-    assert (conn() == NULL);
+    assert (conn().getRaw() == NULL);
     conn_ = aConn;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLChecklist.h,v 1.12 2003/07/06 21:50:55 hno Exp $
+ * $Id: ACLChecklist.h,v 1.13 2003/07/11 01:40:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,6 +35,7 @@
 #define SQUID_ACLCHECKLIST_H
 
 #include "typedefs.h"
+#include "client_side.h"
 
 class ExternalACLEntry;
 
@@ -92,8 +93,8 @@ class NullState : public AsyncState
     void checkCallback(allow_t answer);
     bool _SQUID_INLINE_ matchAclListFast(const acl_list * list);
     void _SQUID_INLINE_ matchAclListSlow(const acl_list * list);
-    ConnStateData *conn();
-    void conn(ConnStateData *);
+    ConnStateData::Pointer conn();
+    void conn(ConnStateData::Pointer);
     int authenticated();
 
     bool asyncInProgress() const;
@@ -137,7 +138,7 @@ class NullState : public AsyncState
 private:
     void matchAclList(const acl_list * list, bool const fast);
     CBDATA_CLASS(ACLChecklist);
-    ConnStateData *conn_;	/* hack for ident and NTLM */
+    ConnStateData::Pointer conn_;	/* hack for ident and NTLM */
     bool async_;
     bool finished_;
     allow_t allow_;
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLDestinationDomain.cc,v 1.3 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLDestinationDomain.cc,v 1.4 2003/07/11 01:40:34 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -40,6 +40,7 @@
 #include "ACLChecklist.h"
 #include "ACLRegexData.h"
 #include "ACLDomainData.h"
+#include "HttpRequest.h"
 
 MemPool *ACLDestinationDomain::Pool(NULL);
 void *
@@ -36,6 +36,7 @@
 #include "squid.h"
 #include "ACLDestinationIP.h"
 #include "ACLChecklist.h"
+#include "HttpRequest.h"
 
 MemPool *ACLDestinationIP::Pool(NULL);
 void *
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLExtUser.cc,v 1.1 2003/06/27 22:32:31 hno Exp $
+ * $Id: ACLExtUser.cc,v 1.2 2003/07/11 01:40:34 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -41,6 +41,7 @@
 #include "ACLRegexData.h"
 #include "ACLUserData.h"
 #include "client_side.h"
+#include "HttpRequest.h"
 
 MemPool *ACLExtUser::Pool(NULL);
 void *
@@ -147,7 +147,7 @@ IdentLookup::checkForAsync(ACLChecklist *checklist)const
     checklist->asyncInProgress(true);
     debug(28, 3) ("IdentLookup::checkForAsync: Doing ident lookup\n");
 
-    if (checklist->conn() && cbdataReferenceValid(checklist->conn())) {
+    if (checklist->conn().getRaw() != NULL) {
         identStart(&checklist->conn()->me, &checklist->conn()->peer,
                    LookupDone, checklist);
     } else {
@@ -173,7 +173,7 @@ IdentLookup::LookupDone(const char *ident, void *data)
      * Cache the ident result in the connection, to avoid redoing ident lookup
      * over and over on persistent connections
      */
-    if (cbdataReferenceValid(checklist->conn()) && !checklist->conn()->rfc931[0])
+    if (checklist->conn().getRaw() != NULL && !checklist->conn()->rfc931[0])
         xstrncpy(checklist->conn()->rfc931, checklist->rfc931, USER_IDENT_SZ);
 
     checklist->asyncInProgress(false);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLMethod.cc,v 1.1 2003/02/25 12:16:55 robertc Exp $
+ * $Id: ACLMethod.cc,v 1.2 2003/07/11 01:40:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,6 +37,7 @@
 #include "ACLMethod.h"
 #include "ACLMethodData.h"
 #include "ACLChecklist.h"
+#include "HttpRequest.h"
 
 ACL::Prototype ACLMethod::RegistryProtoype(&ACLMethod::RegistryEntry_, "method");
 ACLStrategised<method_t> ACLMethod::RegistryEntry_(new ACLMethodData, ACLMethodStrategy::Instance(), "method");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLProtocol.cc,v 1.1 2003/02/25 12:16:55 robertc Exp $
+ * $Id: ACLProtocol.cc,v 1.2 2003/07/11 01:40:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,6 +37,7 @@
 #include "ACLProtocol.h"
 #include "ACLProtocolData.h"
 #include "ACLChecklist.h"
+#include "HttpRequest.h"
 
 ACL::Prototype ACLProtocol::RegistryProtoype(&ACLProtocol::RegistryEntry_, "proto");
 ACLStrategised<protocol_t> ACLProtocol::RegistryEntry_(new ACLProtocolData, ACLProtocolStrategy::Instance(), "proto");
@@ -41,6 +41,7 @@
 #include "ACLUserData.h"
 #include "ACLRegexData.h"
 #include "client_side.h"
+#include "HttpRequest.h"
 
 MemPool *ACLProxyAuth::Pool(NULL);
 void *
@@ -181,7 +182,7 @@ ProxyAuthLookup::LookupDone(void *data, char *result)
         /* OR the connection was closed, there's no way to continue */
         authenticateAuthUserRequestUnlock(checklist->auth_user_request);
 
-        if (checklist->conn()) {
+        if (checklist->conn().getRaw() != NULL) {
             checklist->conn()->auth_user_request = NULL;
             checklist->conn()->auth_type = AUTH_BROKEN;
         }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLReplyMIMEType.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ * $Id: ACLReplyMIMEType.h,v 1.2 2003/07/11 01:40:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,6 +40,7 @@
 #include "ACLReplyHeaderStrategy.h"
 #include "ACLStrategised.h"
 #include "ACLChecklist.h"
+#include "HttpRequest.h"
 
 class ACLReplyMIMEType
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRequestHeaderStrategy.h,v 1.4 2003/06/19 13:12:01 robertc Exp $
+ * $Id: ACLRequestHeaderStrategy.h,v 1.5 2003/07/11 01:40:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,6 +38,7 @@
 #include "ACL.h"
 #include "ACLData.h"
 #include "ACLStrategy.h"
+#include "HttpRequest.h"
 
 template <http_hdr_type header>
 
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLUrlPath.cc,v 1.1 2003/02/17 07:01:35 robertc Exp $
+ * $Id: ACLUrlPath.cc,v 1.2 2003/07/11 01:40:34 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -38,6 +38,7 @@
 #include "ACLUrlPath.h"
 #include "ACLChecklist.h"
 #include "ACLRegexData.h"
+#include "HttpRequest.h"
 
 ACL::Prototype ACLUrlPath::LegacyRegistryProtoype(&ACLUrlPath::RegistryEntry_, "pattern");
 ACL::Prototype ACLUrlPath::RegistryProtoype(&ACLUrlPath::RegistryEntry_, "urlpath_regex");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLUrlPort.cc,v 1.1 2003/02/25 12:16:55 robertc Exp $
+ * $Id: ACLUrlPort.cc,v 1.2 2003/07/11 01:40:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,6 +37,7 @@
 #include "ACLUrlPort.h"
 #include "ACLIntRange.h"
 #include "ACLChecklist.h"
+#include "HttpRequest.h"
 
 ACL::Prototype ACLUrlPort::RegistryProtoype(&ACLUrlPort::RegistryEntry_, "port");
 ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrategy::Instance(), "port");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayId.cc,v 1.11 2003/07/10 11:04:06 robertc Exp $
+ * $Id: DelayId.cc,v 1.12 2003/07/11 01:40:34 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -109,8 +109,8 @@ DelayId::DelayClient(clientHttpRequest * http)
         ch.my_addr = r->my_addr;
         ch.my_port = r->my_port;
 
-        if (http->getConn())
-            ch.conn(cbdataReference(http->getConn()));
+        if (http->getConn().getRaw() != NULL)
+            ch.conn(http->getConn());
 
         ch.request = requestLink(r);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpRequest.cc,v 1.38 2003/07/09 14:14:57 hno Exp $
+ * $Id: HttpRequest.cc,v 1.39 2003/07/11 01:40:34 robertc Exp $
  *
  * DEBUG: section 73    HTTP Request
  * AUTHOR: Duane Wessels
@@ -70,7 +70,7 @@ requestDestroy(request_t * req)
 {
     assert(req);
 
-    if (req->body_connection)
+    if (req->body_connection.getRaw() != NULL)
         clientAbortBody(req);
 
     if (req->auth_user_request)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpRequest.h,v 1.1 2003/01/23 00:37:13 robertc Exp $
+ * $Id: HttpRequest.h,v 1.2 2003/07/11 01:40:35 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,6 +35,51 @@
 #define SQUID_HTTPREQUEST_H
 
 #include "typedefs.h"
+#include "client_side.h"
+
+class request_t
+{
+
+public:
+    bool multipartRangeRequest() const;
+
+    method_t method;
+    protocol_t protocol;
+    char login[MAX_LOGIN_SZ];
+    char host[SQUIDHOSTNAMELEN + 1];
+    auth_user_request_t *auth_user_request;
+    u_short port;
+    String urlpath;
+    char *canonical;
+    int link_count;		/* free when zero */
+    request_flags flags;
+    HttpHdrCc *cache_control;
+    HttpHdrRange *range;
+    http_version_t http_ver;
+    time_t ims;
+    int imslen;
+    int max_forwards;
+    /* these in_addr's could probably be sockaddr_in's */
+
+    struct in_addr client_addr;
+
+    struct in_addr my_addr;
+    unsigned short my_port;
+    unsigned short client_port;
+    HttpHeader header;
+    ConnStateData::Pointer body_connection;	/* used by clientReadBody() */
+    int content_length;
+    HierarchyLogEntry hier;
+    err_type errType;
+    char *peer_login;		/* Configured peer login:password */
+    time_t lastmod;		/* Used on refreshes */
+    const char *vary_headers;	/* Used when varying entities are detected. Changes how the store key is calculated */
+    char *peer_domain;		/* Configured peer forceddomain */
+    String tag;			/* Internal tag for this request */
+    String extacl_user;		/* User name returned by extacl lookup */
+    String extacl_passwd;	/* Password returned by extacl lookup */
+    String extacl_log;		/* String to be used for access.log purposes */
+};
 
 /*  Http Request */
 extern request_t *requestCreate(method_t, protocol_t, const char *urlpath);
@@ -48,4 +93,5 @@ extern int httpRequestPrefixLen(const request_t * req);
 extern int httpRequestHdrAllowed(const HttpHeaderEntry * e, String * strConnection);
 extern int httpRequestHdrAllowedByName(http_hdr_type id);
 
+
 #endif /* SQUID_HTTPREQUEST_H */
@@ -1,5 +1,5 @@
 /*
- * $Id: auth_basic.cc,v 1.25 2003/05/29 15:54:09 hno Exp $
+ * $Id: auth_basic.cc,v 1.26 2003/07/11 01:40:39 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -182,7 +182,7 @@ authenticateBasiccmpUsername(basic_data * u1, basic_data * u2)
 /* log a basic user in
  */
 static void
-authenticateBasicAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData * conn, http_hdr_type type)
+authenticateBasicAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
     auth_user_t *auth_user;
     basic_data *basic_auth;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_digest.cc,v 1.24 2003/06/19 19:56:11 hno Exp $
+ * $Id: auth_digest.cc,v 1.25 2003/07/11 01:40:41 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Robert Collins
@@ -43,6 +43,7 @@
 #include "auth_digest.h"
 #include "authenticate.h"
 #include "Store.h"
+#include "HttpRequest.h"
 
 extern AUTHSSETUP authSchemeSetup_digest;
 
@@ -643,7 +644,7 @@ digest_request_h::authenticated() const
 /* log a digest user in
  */
 void
-digest_request_h::authenticate(request_t * request, ConnStateData * conn, http_hdr_type type)
+digest_request_h::authenticate(request_t * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
     auth_user_t *auth_user;
     digest_request_h *digest_request;
@@ -60,7 +60,7 @@ class digest_request_h : public AuthUserRequestState
     ~digest_request_h();
 
     int authenticated() const;
-    virtual void authenticate(request_t * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(request_t * request, ConnStateData::Pointer conn, http_hdr_type type);
     virtual int direction();
     virtual void addHeader(HttpReply * rep, int accel);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_ntlm.cc,v 1.31 2003/03/04 01:40:55 robertc Exp $
+ * $Id: auth_ntlm.cc,v 1.32 2003/07/11 01:40:42 robertc Exp $
  *
  * DEBUG: section 29    NTLM Authenticator
  * AUTHOR: Robert Collins
@@ -43,6 +43,7 @@
 #include "authenticate.h"
 #include "Store.h"
 #include "client_side.h"
+#include "HttpRequest.h"
 
 extern AUTHSSETUP authSchemeSetup_ntlm;
 
@@ -1063,13 +1064,13 @@ ntlm_request_t::authenticated() const
 }
 
 void
-ntlm_request_t::authenticate(request_t * request, ConnStateData * conn, http_hdr_type type)
+ntlm_request_t::authenticate(request_t * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
     fatal ("unusable");
 }
 
 static void
-authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData * conn, http_hdr_type type)
+authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
     const char *proxy_auth;
 
@@ -1092,7 +1093,7 @@ authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, reques
     /* Check that we are in the client side, where we can generate
      * auth challenges */
 
-    if (!conn) {
+    if (conn.getRaw() == NULL) {
         ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
         debug(29, 1) ("authenticateNTLMAuthenticateUser: attempt to perform authentication without a connection!\n");
         return;
@@ -46,7 +46,7 @@ class ntlm_request_t : public AuthUserRequestState
 
     ~ntlm_request_t();
     virtual int authenticated() const;
-    virtual void authenticate(request_t * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(request_t * request, ConnStateData::Pointer conn, http_hdr_type type);
     virtual int direction();
     /* what negotiate string did the client use? */
     char *ntlmnegotiate;
@@ -61,7 +61,7 @@ class ntlm_request_t : public AuthUserRequestState
     /* have we got the helper-server in a deferred state? */
     int authserver_deferred;
     /* what connection is this associated with */
-    ConnStateData *conn;
+    ConnStateData::Pointer conn;
 
 private:
     static MemPool *Pool;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.cc,v 1.58 2003/06/19 18:56:59 hno Exp $
+ * $Id: authenticate.cc,v 1.59 2003/07/11 01:40:35 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR:  Robert Collins
@@ -41,6 +41,7 @@
 #include "authenticate.h"
 #include "ACL.h"
 #include "client_side.h"
+#include "HttpRequest.h"
 
 CBDATA_TYPE(auth_user_ip_t);
 
@@ -536,7 +537,7 @@ authenticateUserAuthenticated(auth_user_request_t * auth_user_request)
  * This is basically a handle approach.
  */
 static void
-authenticateAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData * conn, http_hdr_type type)
+authenticateAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData::Pointer &conn, http_hdr_type type)
 {
     assert(auth_user_request != NULL);
 
@@ -551,11 +552,11 @@ authenticateAuthenticateUser(auth_user_request_t * auth_user_request, request_t
 }
 
 static auth_user_request_t *
-authTryGetUser (auth_user_request_t **auth_user_request, ConnStateData * conn)
+authTryGetUser (auth_user_request_t **auth_user_request, ConnStateData::Pointer & conn)
 {
     if (*auth_user_request)
         return *auth_user_request;
-    else if (conn)
+    else if (conn.getRaw() != NULL)
         return conn->auth_user_request;
     else
         return NULL;
@@ -582,7 +583,7 @@ authTryGetUser (auth_user_request_t **auth_user_request, ConnStateData * conn)
  */
 auth_acl_t
 
-AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData * conn, struct in_addr src_addr)
+AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData::Pointer conn, struct in_addr src_addr)
 {
     const char *proxy_auth;
     assert(headertype != 0);
@@ -597,13 +598,13 @@ AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr
      */
 
     if (((proxy_auth == NULL) && (!authenticateUserAuthenticated(authTryGetUser(auth_user_request,conn))))
-            || (conn && conn->auth_type == AUTH_BROKEN))
+            || (conn.getRaw() != NULL  && conn->auth_type == AUTH_BROKEN))
     {
         /* no header or authentication failed/got corrupted - restart */
         debug(28, 4) ("authenticateAuthenticate: broken auth or no proxy_auth header. Requesting auth header.\n");
         /* something wrong with the AUTH credentials. Force a new attempt */
 
-        if (conn) {
+        if (conn.getRaw() != NULL) {
             conn->auth_type = AUTH_UNKNOWN;
 
             if (conn->auth_user_request)
@@ -626,7 +627,7 @@ AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr
      * No check for function required in the if: its compulsory for conn based 
      * auth modules
      */
-    if (proxy_auth && conn && conn->auth_user_request &&
+    if (proxy_auth && conn.getRaw() != NULL && conn->auth_user_request &&
             authenticateUserAuthenticated(conn->auth_user_request) &&
             strcmp(proxy_auth, authscheme_list[conn->auth_user_request->auth_user->auth_module - 1].authConnLastHeader(conn->auth_user_request)))
     {
@@ -654,10 +655,10 @@ AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr
     if (*auth_user_request == NULL)
     {
         debug(28, 9) ("authenticateAuthenticate: This is a new checklist test on FD:%d\n",
-                      conn ? conn->fd : -1);
+                      conn.getRaw() != NULL ? conn->fd : -1);
 
         if ((!request->auth_user_request)
-                && (!conn || conn->auth_type == AUTH_UNKNOWN)) {
+                && (conn.getRaw() == NULL || conn->auth_type == AUTH_UNKNOWN)) {
             /* beginning of a new request check */
             debug(28, 4) ("authenticateAuthenticate: no connection authentication type\n");
 
@@ -692,7 +693,7 @@ AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr
 
             ;
         } else {
-            assert (conn);
+            assert (conn.getRaw() != NULL);
 
             if (conn->auth_user_request != NULL) {
                 *auth_user_request = conn->auth_user_request;
@@ -792,7 +793,7 @@ AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr
 
 auth_acl_t
 
-AuthUserRequest::tryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData * conn, struct in_addr src_addr)
+AuthUserRequest::tryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData::Pointer conn, struct in_addr src_addr)
 {
     /* If we have already been called, return the cached value */
     auth_user_request_t *t = authTryGetUser (auth_user_request, conn);
@@ -820,7 +821,7 @@ AuthUserRequest::tryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_use
 
 auth_acl_t
 
-authenticateTryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData * conn, struct in_addr src_addr)
+authenticateTryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData::Pointer conn, struct in_addr src_addr)
 {
     return AuthUserRequest::tryToAuthenticateAndSetAuthUser (auth_user_request, headertype,request, conn, src_addr);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.h,v 1.8 2003/02/26 06:11:40 robertc Exp $
+ * $Id: authenticate.h,v 1.9 2003/07/11 01:40:36 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -34,6 +34,8 @@
 #ifndef SQUID_AUTHENTICATE_H
 #define SQUID_AUTHENTICATE_H
 
+#include "client_side.h"
+
 class AuthUser;
 
 struct AuthUserHashPointer : public hash_link
@@ -116,7 +118,7 @@ class AuthUserRequestState
     virtual ~AuthUserRequestState(){}
 
     virtual int authenticated() const = 0;
-    virtual void authenticate(request_t * request, ConnStateData * conn, http_hdr_type type) = 0;
+    virtual void authenticate(request_t * request, ConnStateData::Pointer conn, http_hdr_type type) = 0;
     virtual int direction() = 0;
     virtual void addHeader(HttpReply * rep, int accel) {}}
 
@@ -136,7 +138,7 @@ class AuthUserRequest
 
 public:
 
-    static auth_acl_t tryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, request_t *, ConnStateData *, struct in_addr);
+    static auth_acl_t tryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, request_t *, ConnStateData::Pointer, struct in_addr);
     static void addReplyAuthHeader(HttpReply * rep, auth_user_request_t * auth_user_request, request_t * request, int accelerated, int internal);
 
     ~AuthUserRequest();
@@ -156,7 +158,7 @@ class AuthUserRequest
 
 private:
 
-    static auth_acl_t authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData * conn, struct in_addr src_addr);
+    static auth_acl_t authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, request_t * request, ConnStateData::Pointer conn, struct in_addr src_addr);
 
     static auth_user_request_t *createAuthUser (const char *proxy_auth);
 
@@ -184,7 +186,7 @@ class AuthUserRequest
 /* authenticate.c authenticate scheme routines typedefs */
 typedef int AUTHSACTIVE(void);
 typedef int AUTHSAUTHED(auth_user_request_t *);
-typedef void AUTHSAUTHUSER(auth_user_request_t *, request_t *, ConnStateData *, http_hdr_type);
+typedef void AUTHSAUTHUSER(auth_user_request_t *, request_t *, ConnStateData::Pointer, http_hdr_type);
 typedef int AUTHSCONFIGURED(void);
 typedef void AUTHSDECODE(auth_user_request_t *, const char *);
 typedef int AUTHSDIRECTION(auth_user_request_t *);
@@ -204,53 +206,49 @@ typedef void AUTHSSTART(auth_user_request_t *, RH *, void *);
 typedef void AUTHSSTATS(StoreEntry *);
 typedef const char *AUTHSCONNLASTHEADER(auth_user_request_t *);
 
-extern "C"
-{
-    /* subsumed by the C++ interface */
-    extern void authenticateAuthUserMerge(auth_user_t *, auth_user_t *);
-    extern auth_user_t *authenticateAuthUserNew(const char *);
-
-    /* AuthUserRequest */
-    extern void authenticateStart(auth_user_request_t *, RH *, void *);
-
-    extern auth_acl_t authenticateTryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, request_t *, ConnStateData *, struct in_addr);
-    extern void authenticateSetDenyMessage (auth_user_request_t *, char const *);
-    extern size_t authenticateRequestRefCount (auth_user_request_t *);
-    extern char const *authenticateAuthUserRequestMessage(auth_user_request_t *);
-
-    extern int authenticateAuthSchemeId(const char *typestr);
-    extern void authenticateSchemeInit(void);
-    extern void authenticateInit(authConfig *);
-    extern void authenticateShutdown(void);
-    extern void authenticateFixHeader(HttpReply *, auth_user_request_t *, request_t *, int, int);
-    extern void authenticateAddTrailer(HttpReply *, auth_user_request_t *, request_t *, int);
-    extern void authenticateAuthUserUnlock(auth_user_t * auth_user);
-    extern void authenticateAuthUserLock(auth_user_t * auth_user);
-    extern void authenticateAuthUserRequestUnlock(auth_user_request_t *);
-    extern void authenticateAuthUserRequestLock(auth_user_request_t *);
-    extern int authenticateAuthUserInuse(auth_user_t * auth_user);
-
-    extern void authenticateAuthUserRequestRemoveIp(auth_user_request_t *, struct in_addr);
-    extern void authenticateAuthUserRequestClearIp(auth_user_request_t *);
-    extern size_t authenticateAuthUserRequestIPCount(auth_user_request_t *);
-    extern int authenticateDirection(auth_user_request_t *);
-    extern void authenticateFreeProxyAuthUserACLResults(void *data);
-    extern int authenticateActiveSchemeCount(void);
-    extern int authenticateSchemeCount(void);
-    extern void authenticateUserNameCacheAdd(auth_user_t * auth_user);
-
-    extern int authenticateCheckAuthUserIP(struct in_addr request_src_addr, auth_user_request_t * auth_user);
-    extern int authenticateUserAuthenticated(auth_user_request_t *);
-    extern void authenticateUserCacheRestart(void);
-    extern char const *authenticateUserRequestUsername(auth_user_request_t *);
-    extern int authenticateValidateUser(auth_user_request_t *);
-    extern void authenticateOnCloseConnection(ConnStateData * conn);
-    extern void authSchemeAdd(const char *type, AUTHSSETUP * setup);
-
-    /* AuthUserHashPointer */
-    extern auth_user_t* authUserHashPointerUser(auth_user_hash_pointer *);
-
-}
+/* subsumed by the C++ interface */
+extern void authenticateAuthUserMerge(auth_user_t *, auth_user_t *);
+extern auth_user_t *authenticateAuthUserNew(const char *);
+
+/* AuthUserRequest */
+extern void authenticateStart(auth_user_request_t *, RH *, void *);
+
+extern auth_acl_t authenticateTryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, request_t *, ConnStateData::Pointer, struct in_addr);
+extern void authenticateSetDenyMessage (auth_user_request_t *, char const *);
+extern size_t authenticateRequestRefCount (auth_user_request_t *);
+extern char const *authenticateAuthUserRequestMessage(auth_user_request_t *);
+
+extern int authenticateAuthSchemeId(const char *typestr);
+extern void authenticateSchemeInit(void);
+extern void authenticateInit(authConfig *);
+extern void authenticateShutdown(void);
+extern void authenticateFixHeader(HttpReply *, auth_user_request_t *, request_t *, int, int);
+extern void authenticateAddTrailer(HttpReply *, auth_user_request_t *, request_t *, int);
+extern void authenticateAuthUserUnlock(auth_user_t * auth_user);
+extern void authenticateAuthUserLock(auth_user_t * auth_user);
+extern void authenticateAuthUserRequestUnlock(auth_user_request_t *);
+extern void authenticateAuthUserRequestLock(auth_user_request_t *);
+extern int authenticateAuthUserInuse(auth_user_t * auth_user);
+
+extern void authenticateAuthUserRequestRemoveIp(auth_user_request_t *, struct in_addr);
+extern void authenticateAuthUserRequestClearIp(auth_user_request_t *);
+extern size_t authenticateAuthUserRequestIPCount(auth_user_request_t *);
+extern int authenticateDirection(auth_user_request_t *);
+extern void authenticateFreeProxyAuthUserACLResults(void *data);
+extern int authenticateActiveSchemeCount(void);
+extern int authenticateSchemeCount(void);
+extern void authenticateUserNameCacheAdd(auth_user_t * auth_user);
+
+extern int authenticateCheckAuthUserIP(struct in_addr request_src_addr, auth_user_request_t * auth_user);
+extern int authenticateUserAuthenticated(auth_user_request_t *);
+extern void authenticateUserCacheRestart(void);
+extern char const *authenticateUserRequestUsername(auth_user_request_t *);
+extern int authenticateValidateUser(auth_user_request_t *);
+extern void authenticateOnCloseConnection(ConnStateData * conn);
+extern void authSchemeAdd(const char *type, AUTHSSETUP * setup);
+
+/* AuthUserHashPointer */
+extern auth_user_t* authUserHashPointerUser(auth_user_hash_pointer *);
 
 /* auth_modules.c */
 SQUIDCEXTERN void authSchemeSetup(void);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.647 2003/07/10 11:04:06 robertc Exp $
+ * $Id: client_side.cc,v 1.648 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -128,9 +128,9 @@ static IOCB clientReadRequest;
 static PF connStateFree;
 static PF requestTimeout;
 static PF clientLifetimeTimeout;
-static ClientSocketContext *parseHttpRequestAbort(ConnStateData * conn,
+static ClientSocketContext *parseHttpRequestAbort(ConnStateData::Pointer & conn,
         const char *uri);
-static ClientSocketContext *parseHttpRequest(ConnStateData *, method_t *,
+static ClientSocketContext *parseHttpRequest(ConnStateData::Pointer &, method_t *,
         char **, size_t *);
 #if USE_IDENT
 static IDCB clientIdentDone;
@@ -149,13 +149,13 @@ class ClientBody
 {
 
 public:
-    ClientBody (ConnStateData *);
+    ClientBody (ConnStateData::Pointer &);
     void process();
     void preProcessing();
     void processBuffer();
 
 private:
-    ConnStateData *conn;
+    ConnStateData::Pointer conn;
     char *buf;
     CBCB *callback;
     request_t *request;
@@ -166,32 +166,32 @@ static void clientUpdateStatCounters(log_type logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 static void clientPrepareLogWithRequestDetails(request_t *, AccessLogEntry *);
-static int connIsUsable(ConnStateData * conn);
+static int connIsUsable(ConnStateData::Pointer conn);
 static int responseFinishedOrFailed(HttpReply * rep, StoreIOBuffer const &recievedData);
-static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
+static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData::Pointer & conn);
 static void clientUpdateSocketStats(log_type logType, size_t size);
 
-static ClientSocketContext *clientParseRequestMethod(char *inbuf, method_t * method_p, ConnStateData * conn);
+static ClientSocketContext *clientParseRequestMethod(char *inbuf, method_t * method_p, ConnStateData::Pointer & conn);
 static char *skipLeadingSpace(char *aString);
 static char *findTrailingHTTPVersion(char *uriAndHTTPVersion);
 #if UNUSED_CODE
 static void trimTrailingSpaces(char *aString, size_t len);
 #endif
-static ClientSocketContext *parseURIandHTTPVersion(char **url_p, http_version_t * http_ver_p, ConnStateData * conn, char *http_version_str);
+static ClientSocketContext *parseURIandHTTPVersion(char **url_p, http_version_t * http_ver_p, ConnStateData::Pointer& conn, char *http_version_str);
 static void setLogUri(clientHttpRequest * http, char const *uri);
-static int connReadWasError(ConnStateData * conn, comm_err_t, int size, int xerrno);
-static int connFinishedWithConn(ConnStateData * conn, int size);
-static void connNoteUseOfBuffer(ConnStateData * conn, size_t byteCount);
-static int connKeepReadingIncompleteRequest(ConnStateData * conn);
-static void connCancelIncompleteRequests(ConnStateData * conn);
+static int connReadWasError(ConnStateData::Pointer& conn, comm_err_t, int size, int xerrno);
+static int connFinishedWithConn(ConnStateData::Pointer& conn, int size);
+static void connNoteUseOfBuffer(ConnStateData::Pointer & conn, size_t byteCount);
+static int connKeepReadingIncompleteRequest(ConnStateData::Pointer & conn);
+static void connCancelIncompleteRequests(ConnStateData::Pointer & conn);
 
 static ConnStateData *connStateCreate(struct sockaddr_in *peer, struct sockaddr_in *me, int fd, http_port_list *port);
 
 int
 ClientSocketContext::fd() const
 {
     assert (http);
-    assert (http->getConn());
+    assert (http->getConn().getRaw() != NULL);
     return http->getConn()->fd;
 }
 
@@ -235,10 +235,10 @@ ConnStateData::readSomeData()
 
 
 void
-ClientSocketContext::removeFromConnectionList(ConnStateData * conn)
+ClientSocketContext::removeFromConnectionList(ConnStateData::Pointer conn)
 {
     ClientSocketContext::Pointer *tempContextPointer;
-    assert(conn);
+    assert(conn.getRaw() != NULL);
     assert(conn->getCurrentContext().getRaw() != NULL);
     /* Unlink us from the connection request list */
     tempContextPointer = & conn->currentobject;
@@ -283,7 +283,7 @@ ClientSocketContext::registerWithConn()
 {
     assert (!connRegistered_);
     assert (http);
-    assert (http->getConn());
+    assert (http->getConn().getRaw() != NULL);
     connRegistered_ = true;
     http->getConn()->addContextToQueue(this);
 }
@@ -300,7 +300,7 @@ void
 ClientSocketContext::connIsFinished()
 {
     assert (http);
-    assert (http->getConn());
+    assert (http->getConn().getRaw() != NULL);
     deRegisterWithConn();
     /* we can't handle any more stream data - detach */
     clientStreamDetach(getTail(), http);
@@ -510,15 +510,15 @@ ClientHttpRequest::logRequest()
             al.http.content_type = memObject()->getReply()->content_type.buf();
         }
 
-        al.cache.caddr = getConn() ? getConn()->log_addr : no_addr;
+        al.cache.caddr = getConn().getRaw() != NULL ? getConn()->log_addr : no_addr;
         al.cache.size = out.size;
         al.cache.code = logType;
         al.cache.msec = tvSubMsec(start, current_time);
 
         if (request)
             clientPrepareLogWithRequestDetails(request, &al);
 
-        if (getConn() && getConn()->rfc931[0])
+        if (getConn().getRaw() != NULL && getConn()->rfc931[0])
             al.cache.rfc931 = getConn()->rfc931;
 
 #if USE_SSL
@@ -537,7 +537,7 @@ ClientHttpRequest::logRequest()
             accessLogLog(&al, checklist);
             updateCounters();
 
-            if (getConn())
+            if (getConn().getRaw() != NULL)
                 clientdbUpdate(getConn()->peer.sin_addr, logType, PROTO_HTTP, out.size);
         }
 
@@ -604,24 +604,39 @@ connStateFree(int fd, void *data)
 {
     ConnStateData *connState = (ConnStateData *)data;
     assert (fd == connState->fd);
-    connState->deleteSelf();
+    connState->close();
 }
 
-ConnStateData::~ConnStateData()
+void
+ConnStateData::close()
 {
-    debug(33, 3) ("ConnStateData::~ConnStateData: FD %d\n", fd);
-    assert(this != NULL);
+    debug(33, 3) ("ConnStateData::close: FD %d\n", fd);
+    open_ = false;
     clientdbEstablished(peer.sin_addr, -1);	/* decrement */
     assert(areAllContextsForThisConnection());
     freeAllContexts();
+    authenticateOnCloseConnection(this);
+}
+
+bool
+ConnStateData::isOpen() const
+{
+    return open_;
+}
+
+ConnStateData::~ConnStateData()
+{
+    assert(this != NULL);
+    debug(33, 3) ("ConnStateData::~ConnStateData: FD %d\n", fd);
+
+    if (isOpen())
+        close();
 
     if (auth_user_request)
         authenticateAuthUserRequestUnlock(auth_user_request);
 
     auth_user_request = NULL;
 
-    authenticateOnCloseConnection(this);
-
     pconnHistCount(0, nrequests);
 
     cbdataReferenceDone(port);
@@ -701,9 +716,9 @@ clientIsRequestBodyTooLargeForPolicy(size_t bodyLength)
 }
 
 int
-connIsUsable(ConnStateData * conn)
+connIsUsable(ConnStateData::Pointer conn)
 {
-    if (!conn || conn->fd == -1)
+    if (conn.getRaw() == NULL || conn->fd == -1)
         return 0;
 
     return 1;
@@ -1267,7 +1282,7 @@ ConnStateData::readNextRequest()
 }
 
 void
-ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn)
+ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData::Pointer & conn)
 {
     debug(33, 2) ("ClientSocketContextPushDeferredIfNeeded: FD %d Sending next\n",
                   conn->fd);
@@ -1290,7 +1305,7 @@ ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredReq
 void
 ClientSocketContext::keepaliveNextRequest()
 {
-    ConnStateData *conn = http->getConn();
+    ConnStateData::Pointer conn = http->getConn();
 
     debug(33, 3) ("ClientSocketContext::keepaliveNextRequest: FD %d\n", conn->fd);
     connIsFinished();
@@ -1485,7 +1500,7 @@ extern "C" CSS clientReplyStatus;
 extern "C" CSD clientReplyDetach;
 
 static ClientSocketContext *
-parseHttpRequestAbort(ConnStateData * conn, const char *uri)
+parseHttpRequestAbort(ConnStateData::Pointer & conn, const char *uri)
 {
     clientHttpRequest *http;
     ClientSocketContext *context;
@@ -1506,7 +1521,7 @@ parseHttpRequestAbort(ConnStateData * conn, const char *uri)
 }
 
 ClientSocketContext *
-clientParseRequestMethod(char *inbuf, method_t * method_p, ConnStateData * conn)
+clientParseRequestMethod(char *inbuf, method_t * method_p, ConnStateData::Pointer & conn)
 {
     char *mstr = NULL;
 
@@ -1571,7 +1586,7 @@ trimTrailingSpaces(char *aString, size_t len)
 
 static ClientSocketContext *
 parseURIandHTTPVersion(char **url_p, http_version_t * http_ver_p,
-                       ConnStateData * conn, char *http_version_str)
+                       ConnStateData::Pointer & conn, char *http_version_str)
 {
     char *url;
     char *t;
@@ -1620,7 +1635,7 @@ parseURIandHTTPVersion(char **url_p, http_version_t * http_ver_p,
 
 /* Utility function to perform part of request parsing */
 static ClientSocketContext *
-clientParseHttpRequestLine(char *reqline, ConnStateData * conn,
+clientParseHttpRequestLine(char *reqline, ConnStateData::Pointer &conn,
                            method_t * method_p, char **url_p, http_version_t * http_ver_p, char * http_version_str)
 {
     ClientSocketContext *result = NULL;
@@ -1645,7 +1660,7 @@ setLogUri(clientHttpRequest * http, char const *uri)
 }
 
 static void
-prepareAcceleratedURL(ConnStateData * conn, clientHttpRequest *http, char *url, const char *req_hdr)
+prepareAcceleratedURL(ConnStateData::Pointer & conn, clientHttpRequest *http, char *url, const char *req_hdr)
 {
     int vhost = conn->port->vhost;
     int vport = conn->port->vport;
@@ -1716,7 +1731,7 @@ prepareAcceleratedURL(ConnStateData * conn, clientHttpRequest *http, char *url,
 }
 
 static void
-prepareTransparentURL(ConnStateData * conn, clientHttpRequest *http, char *url, const char *req_hdr)
+prepareTransparentURL(ConnStateData::Pointer & conn, clientHttpRequest *http, char *url, const char *req_hdr)
 {
     char *host;
 
@@ -1760,7 +1775,7 @@ prepareTransparentURL(ConnStateData * conn, clientHttpRequest *http, char *url,
  *  Sets result->flags.parsed_ok to 1 if we have a good request.
  */
 static ClientSocketContext *
-parseHttpRequest(ConnStateData * conn, method_t * method_p,
+parseHttpRequest(ConnStateData::Pointer & conn, method_t * method_p,
                  char **prefix_p, size_t * req_line_sz_p)
 {
     char *inbuf = NULL;
@@ -1963,7 +1978,7 @@ ConnStateData::getConcurrentRequestCount() const
 }
 
 int
-connReadWasError(ConnStateData * conn, comm_err_t flag, int size, int xerrno)
+connReadWasError(ConnStateData::Pointer & conn, comm_err_t flag, int size, int xerrno)
 {
     if (flag != COMM_OK) {
         debug(50, 2) ("connReadWasError: FD %d: got flag %d\n", conn->fd, flag);
@@ -1984,7 +1999,7 @@ connReadWasError(ConnStateData * conn, comm_err_t flag, int size, int xerrno)
 }
 
 int
-connFinishedWithConn(ConnStateData * conn, int size)
+connFinishedWithConn(ConnStateData::Pointer & conn, int size)
 {
     if (size == 0) {
         if (conn->getConcurrentRequestCount() == 0 && conn->in.notYetUsed == 0) {
@@ -2002,7 +2017,7 @@ connFinishedWithConn(ConnStateData * conn, int size)
 }
 
 void
-connNoteUseOfBuffer(ConnStateData * conn, size_t byteCount)
+connNoteUseOfBuffer(ConnStateData::Pointer & conn, size_t byteCount)
 {
     assert(byteCount > 0 && byteCount <= conn->in.notYetUsed);
     conn->in.notYetUsed -= byteCount;
@@ -2018,13 +2033,13 @@ connNoteUseOfBuffer(ConnStateData * conn, size_t byteCount)
 }
 
 int
-connKeepReadingIncompleteRequest(ConnStateData * conn)
+connKeepReadingIncompleteRequest(ConnStateData::Pointer & conn)
 {
     return conn->in.notYetUsed >= Config.maxRequestHeaderSize ? 0 : 1;
 }
 
 void
-connCancelIncompleteRequests(ConnStateData * conn)
+connCancelIncompleteRequests(ConnStateData::Pointer & conn)
 {
     ClientSocketContext *context = parseHttpRequestAbort(conn, "error:request-too-large");
     clientStreamNode *node = context->getClientReplyContext();
@@ -2043,7 +2058,7 @@ connCancelIncompleteRequests(ConnStateData * conn)
 }
 
 static void
-clientMaybeReadData(ConnStateData *conn, int do_next_read)
+clientMaybeReadData(ConnStateData::Pointer &conn, int do_next_read)
 {
     if (do_next_read) {
         conn->flags.readMoreRequests = 1;
@@ -2052,7 +2067,7 @@ clientMaybeReadData(ConnStateData *conn, int do_next_read)
 }
 
 static void
-clientAfterReadingRequests(int fd, ConnStateData *conn, int do_next_read)
+clientAfterReadingRequests(int fd, ConnStateData::Pointer &conn, int do_next_read)
 {
     fde *F = &fd_table[fd];
 
@@ -2072,7 +2087,7 @@ clientAfterReadingRequests(int fd, ConnStateData *conn, int do_next_read)
 }
 
 static void
-clientProcessRequest(ConnStateData *conn, ClientSocketContext *context, method_t method, char *prefix, size_t req_line_sz)
+clientProcessRequest(ConnStateData::Pointer &conn, ClientSocketContext *context, method_t method, char *prefix, size_t req_line_sz)
 {
     clientHttpRequest *http = context->http;
     request_t *request = NULL;
@@ -2206,7 +2221,7 @@ clientProcessRequest(ConnStateData *conn, ClientSocketContext *context, method_t
 }
 
 static void
-connStripBufferWhitespace (ConnStateData *conn)
+connStripBufferWhitespace (ConnStateData::Pointer &conn)
 {
     while (conn->in.notYetUsed > 0 && xisspace(conn->in.buf[0])) {
         xmemmove(conn->in.buf, conn->in.buf + 1, conn->in.notYetUsed - 1);
@@ -2215,7 +2230,7 @@ connStripBufferWhitespace (ConnStateData *conn)
 }
 
 static int
-connOkToAddRequest(ConnStateData *conn)
+connOkToAddRequest(ConnStateData::Pointer &conn)
 {
     int result = conn->getConcurrentRequestCount() < (Config.onoff.pipeline_prefetch ? 2 : 1);
 
@@ -2233,7 +2248,7 @@ static void
 clientReadRequest(int fd, char *buf, size_t size, comm_err_t flag, int xerrno,
                   void *data)
 {
-    ConnStateData *conn = (ConnStateData *)data;
+    ConnStateData::Pointer conn ((ConnStateData *)data);
     conn->reading(false);
     method_t method;
     char *prefix = NULL;
@@ -2370,9 +2385,9 @@ void
 clientReadBody(request_t * request, char *buf, size_t size, CBCB * callback,
                void *cbdata)
 {
-    ConnStateData *conn = request->body_connection;
+    ConnStateData::Pointer conn = request->body_connection;
 
-    if (!conn) {
+    if (conn.getRaw() == NULL) {
         debug(33, 5) ("clientReadBody: no body to read, request=%p\n", request);
         callback(buf, 0, cbdata);	/* Signal end of body */
         return;
@@ -2390,7 +2405,7 @@ clientReadBody(request_t * request, char *buf, size_t size, CBCB * callback,
     body.process();
 }
 
-ClientBody::ClientBody(ConnStateData *aConn) : conn(aConn), buf (NULL), callback(NULL), request(NULL)
+ClientBody::ClientBody(ConnStateData::Pointer &aConn) : conn(aConn), buf (NULL), callback(NULL), request(NULL)
 {}
 
 void
@@ -2503,12 +2518,12 @@ clientReadBodyAbortHandler(char *buf, ssize_t size, void *data)
 int
 clientAbortBody(request_t * request)
 {
-    ConnStateData *conn = request->body_connection;
+    ConnStateData::Pointer conn = request->body_connection;
     char *buf;
     CBCB *callback;
     request->body_connection = NULL;
 
-    if (!conn || conn->body.size_left <= 0)
+    if (conn.getRaw() == NULL || conn->body.size_left <= 0)
         return 0;		/* No body to abort */
 
     if (conn->body.callback != NULL) {
@@ -2527,7 +2542,7 @@ clientAbortBody(request_t * request)
         requestUnlink(request);
     }
 
-    clientReadBodyAbortHandler(NULL, -1, conn);	/* Install abort handler */
+    clientReadBodyAbortHandler(NULL, -1, conn.getRaw());	/* Install abort handler */
     /* ClientBody::process() */
     return 1;			/* Aborted */
 }
@@ -2610,10 +2625,9 @@ static void
 clientLifetimeTimeout(int fd, void *data)
 {
     clientHttpRequest *http = (clientHttpRequest *)data;
-    ConnStateData *conn = http->getConn();
     debug(33,
           1) ("WARNING: Closing client %s connection due to lifetime timeout\n",
-              inet_ntoa(conn->peer.sin_addr));
+              inet_ntoa(http->getConn()->peer.sin_addr));
     debug(33, 1) ("\t%s\n", http->uri);
     comm_close(fd);
 }
@@ -3020,8 +3034,8 @@ ACLChecklist *
 clientAclChecklistCreate(const acl_access * acl, clientHttpRequest * http)
 {
     ACLChecklist *ch;
-    ConnStateData *conn = http->getConn();
-    ch = aclChecklistCreate(acl, http->request, conn ? conn->rfc931 : dash_str);
+    ConnStateData::Pointer conn = http->getConn();
+    ch = aclChecklistCreate(acl, http->request, conn.getRaw() != NULL ? conn->rfc931 : dash_str);
 
     /*
      * hack for ident ACL. It needs to get full addresses, and a place to store
@@ -3035,8 +3049,8 @@ clientAclChecklistCreate(const acl_access * acl, clientHttpRequest * http)
      * the server end.
      */
 
-    if (conn)
-        ch->conn(cbdataReference(conn));	/* unreferenced in acl.cc */
+    if (conn.getRaw() != NULL)
+        ch->conn(conn);	/* unreferenced in acl.cc */
 
     return ch;
 }
@@ -3064,7 +3078,7 @@ ConnStateData::deleteSelf () const
     delete this;
 }
 
-ConnStateData::ConnStateData() : transparent_ (false), reading_ (false)
+ConnStateData::ConnStateData() : transparent_ (false), reading_ (false), open_(true)
 {}
 
 bool
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.h,v 1.2 2003/03/15 04:17:39 robertc Exp $
+ * $Id: client_side.h,v 1.3 2003/07/11 01:40:36 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,6 +35,7 @@
 #define SQUID_CLIENTSIDE_H
 
 #include "StoreIOBuffer.h"
+#include "RefCount.h"
 
 class ConnStateData;
 
@@ -101,7 +102,7 @@ int parsed_ok:
     clientStreamNode * getTail() const;
     clientStreamNode * getClientReplyContext() const;
     void connIsFinished();
-    void removeFromConnectionList(ConnStateData * conn);
+    void removeFromConnectionList(RefCount<ConnStateData> conn);
     void deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer recievedData);
     bool multipartRangeRequest() const;
     void packRange(const char **buf,
@@ -117,10 +118,11 @@ int parsed_ok:
     bool connRegistered_;
 };
 
-class ConnStateData
+class ConnStateData : public RefCountable
 {
 
 public:
+    typedef RefCount<ConnStateData> Pointer;
     void * operator new (size_t);
     void operator delete (void *);
     void deleteSelf() const;
@@ -137,6 +139,8 @@ class ConnStateData
     ClientSocketContext::Pointer getCurrentContext() const;
     void addContextToQueue(ClientSocketContext * context);
     int getConcurrentRequestCount() const;
+    void close();
+    bool isOpen() const;
 
     int fd;
 
@@ -197,6 +201,7 @@ int readMoreRequests:
     CBDATA_CLASS(ConnStateData);
     bool transparent_;
     bool reading_;
+    bool open_;
 };
 
 #endif /* SQUID_CLIENTSIDE_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_reply.cc,v 1.57 2003/07/10 11:04:06 robertc Exp $
+ * $Id: client_side_reply.cc,v 1.58 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 88    Client-side Reply Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -268,7 +268,7 @@ clientReplyContext::processExpired()
                  (long int) entry->lastmod);
     http->storeEntry(entry);
     assert(http->out.offset == 0);
-    fwdStart(http->getConn() ? http->getConn()->fd : -1, http->storeEntry(), http->request);
+    fwdStart(http->getConn().getRaw() != NULL ? http->getConn()->fd : -1, http->storeEntry(), http->request);
     /* Register with storage manager to receive updates when data comes in. */
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED))
@@ -833,7 +833,7 @@ clientReplyContext::processMiss()
         if (http->flags.internal)
             r->protocol = PROTO_INTERNAL;
 
-        fwdStart(http->getConn() ? http->getConn()->fd : -1, http->storeEntry(), r);
+        fwdStart(http->getConn().getRaw() != NULL ? http->getConn()->fd : -1, http->storeEntry(), r);
     }
 }
 
@@ -1146,7 +1146,7 @@ clientHttpRequestStatus(int fd, clientHttpRequest const *http)
         debug(88, 1) ("WARNING: closing FD %d to prevent counter overflow\n",
                       fd);
         debug(88, 1) ("\tclient %s\n",
-                      inet_ntoa(http->getConn() ? http->getConn()->peer.sin_addr : no_addr));
+                      inet_ntoa(http->getConn().getRaw() != NULL ? http->getConn()->peer.sin_addr : no_addr));
         debug(88, 1) ("\treceived %d bytes\n", (int) http->out.size);
         debug(88, 1) ("\tURI %s\n", http->log_uri);
         return 1;
@@ -1158,7 +1158,7 @@ clientHttpRequestStatus(int fd, clientHttpRequest const *http)
         debug(88, 1) ("WARNING: closing FD %d to prevent counter overflow\n",
                       fd);
         debug(88, 1) ("\tclient %s\n",
-                      inet_ntoa(http->getConn() ? http->getConn()->peer.sin_addr : no_addr));
+                      inet_ntoa(http->getConn().getRaw() != NULL ? http->getConn()->peer.sin_addr : no_addr));
         debug(88, 1) ("\treceived %d bytes (offset %d)\n", (int) http->out.size,
                       (int) http->out.offset);
         debug(88, 1) ("\tURI %s\n", http->log_uri);
@@ -1859,7 +1859,7 @@ clientReplyContext::processReplyAccess ()
     if (http->isReplyBodyTooLarge(rep->content_length)) {
         ErrorState *err =
             clientBuildError(ERR_TOO_BIG, HTTP_FORBIDDEN, NULL,
-                             http->getConn() ? &http->getConn()->peer.sin_addr : &no_addr,
+                             http->getConn().getRaw() != NULL ? &http->getConn()->peer.sin_addr : &no_addr,
                              http->request);
         removeClientStoreReference(&sc, http);
         startError(err);
@@ -1900,7 +1900,7 @@ clientReplyContext::processReplyAccessResult(bool accessAllowed)
         ErrorState *err;
         err =
             clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL,
-                             http->getConn() ? &http->getConn()->peer.sin_addr : &no_addr,
+                             http->getConn().getRaw() != NULL ? &http->getConn()->peer.sin_addr : &no_addr,
                              http->request);
         removeClientStoreReference(&sc, http);
         startError(err);
@@ -1967,9 +1967,9 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
 
     StoreEntry *entry = http->storeEntry();
 
-    ConnStateData *conn = http->getConn();
+    ConnStateData::Pointer conn = http->getConn();
 
-    int fd = conn ? conn->fd : -1;
+    int fd = conn.getRaw() != NULL ? conn->fd : -1;
 
     char *buf = next()->readBuffer.data;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_request.cc,v 1.26 2003/07/10 11:04:06 robertc Exp $
+ * $Id: client_side_request.cc,v 1.27 2003/07/11 01:40:36 robertc Exp $
  * 
  * DEBUG: section 85    Client-side Request Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -257,7 +257,7 @@ ClientHttpRequest::~ClientHttpRequest()
      * found the end of the body yet
      */
 
-    if (request && request->body_connection)
+    if (request && request->body_connection.getRaw() != NULL)
         clientAbortBody(request);	/* abort body transter */
 
     /* the ICP check here was erroneous
@@ -396,7 +396,7 @@ clientAccessCheckDone(int answer, void *data)
                   RequestMethodStr[http->request->method], http->uri,
                   answer == ACCESS_ALLOWED ? "ALLOWED" : "DENIED",
                   AclMatchedName ? AclMatchedName : "NO ACL's");
-    proxy_auth_msg = authenticateAuthUserRequestMessage((http->getConn()
+    proxy_auth_msg = authenticateAuthUserRequestMessage((http->getConn().getRaw() != NULL
                      && http->getConn()->auth_user_request) ? http->getConn()->
                      auth_user_request : http->request->auth_user_request);
 
@@ -446,8 +446,8 @@ clientAccessCheckDone(int answer, void *data)
         assert (repContext);
         repContext->setReplyToError(page_id, status,
                                     http->request->method, NULL,
-                                    http->getConn() ? &http->getConn()->peer.sin_addr : &no_addr, http->request,
-                                    NULL, http->getConn()
+                                    http->getConn().getRaw() != NULL ? &http->getConn()->peer.sin_addr : &no_addr, http->request,
+                                    NULL, http->getConn().getRaw() != NULL
                                     && http->getConn()->auth_user_request ? http->getConn()->
                                     auth_user_request : http->request->auth_user_request);
         node = (clientStreamNode *)http->client_stream.tail->data;
@@ -768,7 +768,7 @@ clientRedirectDone(void *data, char *result)
             authenticateAuthUserRequestLock(new_request->auth_user_request);
         }
 
-        if (old_request->body_connection) {
+        if (old_request->body_connection.getRaw() != NULL) {
             new_request->body_connection = old_request->body_connection;
             old_request->body_connection = NULL;
         }
@@ -788,7 +788,7 @@ clientRedirectDone(void *data, char *result)
 #endif
     /* FIXME PIPELINE: This is innacurate during pipelining */
 
-    if (http->getConn())
+    if (http->getConn().getRaw() != NULL)
         fd_note(http->getConn()->fd, http->uri);
 
     assert(http->uri);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_request.cci,v 1.2 2003/07/10 11:04:06 robertc Exp $
+ * $Id: client_side_request.cci,v 1.3 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 85    Client-side Request Routines
  * AUTHOR: Robert Collins 
@@ -49,21 +49,21 @@ ClientHttpRequest::memObject() const
     return NULL;
 }
 
-ConnStateData *
+ConnStateData::Pointer
 ClientHttpRequest::getConn()
 {
     return conn_;
 }
 
-ConnStateData const *
+ConnStateData::Pointer const
 ClientHttpRequest::getConn() const
 {
     return conn_;
 }
 
 void
-ClientHttpRequest::setConn(ConnStateData *aConn)
+ClientHttpRequest::setConn(ConnStateData::Pointer aConn)
 {
-    assert (!conn_ || !aConn);
+    assert (conn_.getRaw() == NULL || aConn.getRaw() == NULL);
     conn_ = aConn;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_request.h,v 1.13 2003/07/10 11:04:06 robertc Exp $
+ * $Id: client_side_request.h,v 1.14 2003/07/11 01:40:36 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,6 +36,7 @@
 
 #include "HttpHeader.h"
 #include "clientStream.h"
+#include "client_side.h"
 
 /* client_side_request.c - client side request related routines (pure logic) */
 extern int clientBeginRequest(method_t, char const *, CSCB *, CSD *, ClientStreamData, HttpHeader const *, char *, size_t);
@@ -71,9 +72,9 @@ class ClientHttpRequest
     _SQUID_INLINE_ StoreEntry *storeEntry() const;
     void storeEntry(StoreEntry *);
 
-    _SQUID_INLINE_ ConnStateData *getConn();
-    _SQUID_INLINE_ ConnStateData const *getConn() const;
-    _SQUID_INLINE_ void setConn(ConnStateData *);
+    _SQUID_INLINE_ ConnStateData::Pointer getConn();
+    _SQUID_INLINE_ ConnStateData::Pointer const getConn() const;
+    _SQUID_INLINE_ void setConn(ConnStateData::Pointer);
     request_t *request;		/* Parsed URL ... */
     char *uri;
     char *log_uri;
@@ -134,7 +135,7 @@ unsigned int purging:
     CBDATA_CLASS(ClientHttpRequest);
     ssize_t maxReplyBodySize_;
     StoreEntry *entry_;
-    ConnStateData *conn_;
+    ConnStateData::Pointer conn_;
 };
 
 /* client http based routines */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: external_acl.cc,v 1.48 2003/07/09 14:14:58 hno Exp $
+ * $Id: external_acl.cc,v 1.49 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 82    External ACL
  * AUTHOR: Henrik Nordstrom, MARA Systems AB
@@ -52,6 +52,7 @@
 #include "ACLIdent.h"
 #endif
 #include "client_side.h"
+#include "HttpRequest.h"
 
 #ifndef DEFAULT_EXTERNAL_ACL_TTL
 #define DEFAULT_EXTERNAL_ACL_TTL 1 * 60 * 60
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.105 2003/07/09 11:02:28 hno Exp $
+ * $Id: forward.cc,v 1.106 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -182,7 +182,7 @@ fwdCheckRetriable(FwdState * fwdState)
      * even if the method is indempotent
      */
 
-    if (fwdState->request->body_connection)
+    if (fwdState->request->body_connection.getRaw() != NULL)
         return 0;
 
     /* RFC2616 9.1 Safe and Idempotent Methods */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.417 2003/06/27 22:32:31 hno Exp $
+ * $Id: http.cc,v 1.418 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -1513,7 +1513,7 @@ httpSendRequest(HttpStateData * httpState)
     debug(11, 5) ("httpSendRequest: FD %d: httpState %p.\n", httpState->fd,
                   httpState);
 
-    if (httpState->orig_request->body_connection)
+    if (httpState->orig_request->body_connection.getRaw() != NULL)
         sendHeaderDone = httpSendRequestEntity;
     else
         sendHeaderDone = HttpStateData::SendComplete;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.79 2003/06/19 13:27:50 hno Exp $
+ * $Id: mem.cc,v 1.80 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -362,6 +362,7 @@ memConfigure(void)
 
 /* XXX make these classes do their own memory management */
 #include "HttpHdrContRange.h"
+#include "HttpRequest.h"
 
 void
 Mem::Init(void)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.99 2003/07/10 11:04:06 robertc Exp $
+ * $Id: redirect.cc,v 1.100 2003/07/11 01:40:36 robertc Exp $
  *
  * DEBUG: section 61    Redirector
  * AUTHOR: Duane Wessels
@@ -106,7 +106,7 @@ redirectStats(StoreEntry * sentry)
 void
 redirectStart(clientHttpRequest * http, RH * handler, void *data)
 {
-    ConnStateData *conn = http->getConn();
+    ConnStateData::Pointer conn = http->getConn();
     redirectStateData *r = NULL;
     const char *fqdn;
     char buf[8192];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: refresh.cc,v 1.60 2003/02/21 22:50:10 robertc Exp $
+ * $Id: refresh.cc,v 1.61 2003/07/11 01:40:37 robertc Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -40,6 +40,7 @@
 #include "squid.h"
 #include "Store.h"
 #include "MemObject.h"
+#include "HttpRequest.h"
 
 typedef enum {
     rcHTTP,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.377 2003/07/10 11:04:06 robertc Exp $
+ * $Id: stat.cc,v 1.378 2003/07/11 01:40:37 robertc Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -1575,17 +1575,16 @@ statClientRequests(StoreEntry * s)
 {
     dlink_node *i;
     clientHttpRequest *http;
-    ConnStateData *conn;
     StoreEntry *e;
     int fd;
 
     for (i = ClientActiveRequests.head; i; i = i->next) {
         http = static_cast<clientHttpRequest *>(i->data);
         assert(http);
-        conn = http->getConn();
-        storeAppendPrintf(s, "Connection: %p\n", conn);
+        ConnStateData::Pointer conn = http->getConn();
+        storeAppendPrintf(s, "Connection: %p\n", conn.getRaw());
 
-        if (conn) {
+        if (conn.getRaw() != NULL) {
             fd = conn->fd;
             storeAppendPrintf(s, "\tFD %d, read %d, wrote %d\n", fd,
                               fd_table[fd].bytes_read, fd_table[fd].bytes_written);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_client.cc,v 1.128 2003/06/24 12:42:27 robertc Exp $
+ * $Id: store_client.cc,v 1.129 2003/07/11 01:40:37 robertc Exp $
  *
  * DEBUG: section 90    Storage Manager Client-Side Interface
  * AUTHOR: Duane Wessels
@@ -44,6 +44,7 @@
 #if DELAY_POOLS
 #include "DelayPools.h"
 #endif
+#include "HttpRequest.h"
 
 CBDATA_TYPE(store_client);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_key_md5.cc,v 1.29 2003/02/21 22:50:12 robertc Exp $
+ * $Id: store_key_md5.cc,v 1.30 2003/07/11 01:40:37 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager MD5 Cache Keys
  * AUTHOR: Duane Wessels
@@ -34,6 +34,7 @@
  */
 
 #include "squid.h"
+#include "HttpRequest.h"
 
 static cache_key null_key[MD5_DIGEST_CHARS];
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.470 2003/07/09 14:14:58 hno Exp $
+ * $Id: structs.h,v 1.471 2003/07/11 01:40:37 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -1672,50 +1672,7 @@ class HttpHdrRange;
 
 class ConnStateData;
 
-class request_t
-{
-
-public:
-    bool multipartRangeRequest() const;
-
-    method_t method;
-    protocol_t protocol;
-    char login[MAX_LOGIN_SZ];
-    char host[SQUIDHOSTNAMELEN + 1];
-    auth_user_request_t *auth_user_request;
-    u_short port;
-    String urlpath;
-    char *canonical;
-    int link_count;		/* free when zero */
-    request_flags flags;
-    HttpHdrCc *cache_control;
-    HttpHdrRange *range;
-    http_version_t http_ver;
-    time_t ims;
-    int imslen;
-    int max_forwards;
-    /* these in_addr's could probably be sockaddr_in's */
-
-    struct in_addr client_addr;
-
-    struct in_addr my_addr;
-    unsigned short my_port;
-    unsigned short client_port;
-    HttpHeader header;
-    ConnStateData *body_connection;	/* used by clientReadBody() */
-    int content_length;
-    HierarchyLogEntry hier;
-    err_type errType;
-    char *peer_login;		/* Configured peer login:password */
-    time_t lastmod;		/* Used on refreshes */
-    const char *vary_headers;	/* Used when varying entities are detected. Changes how the store key is calculated */
-    char *peer_domain;		/* Configured peer forceddomain */
-    String tag;			/* Internal tag for this request */
-    String extacl_user;		/* User name returned by extacl lookup */
-    String extacl_passwd;	/* Password returned by extacl lookup */
-    String extacl_log;		/* String to be used for access.log purposes */
-};
-
+class request_t;
 #endif
 
 struct _cachemgr_passwd
@@ -1,6 +1,6 @@
 
 /*
- * $Id: whois.cc,v 1.24 2003/02/21 22:50:13 robertc Exp $
+ * $Id: whois.cc,v 1.25 2003/07/11 01:40:37 robertc Exp $
  *
  * DEBUG: section 75    WHOIS protocol
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -37,6 +37,7 @@
 #include "Store.h"
 #include "HttpReply.h"
 #include "comm.h"
+#include "HttpRequest.h"
 
 #define WHOIS_PORT 43
 