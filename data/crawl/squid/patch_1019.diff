@@ -1,6 +1,6 @@
 
 /*
- * $Id: Packer.cc,v 1.20 2005/11/21 22:55:53 wessels Exp $
+ * $Id: Packer.cc,v 1.21 2007/04/21 07:14:13 wessels Exp $
  *
  * DEBUG: section 60    Packer: A uniform interface to store-like modules
  * AUTHOR: Alex Rousskov
@@ -105,9 +105,15 @@ memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs)
     mb->vPrintf(fmt, vargs);
 }
 
+static void
+storeEntryAppend(StoreEntry *e, const char *buf, int len)
+{
+    e->append(buf, len);
+}
+
 
 /* append()'s */
-static void (*const store_append) (StoreEntry *, const char *, int) = &storeAppend;
+static void (*const store_append) (StoreEntry *, const char *, int) = &storeEntryAppend;
 static void (*const memBuf_append) (MemBuf *, const char *, mb_size_t) = &memBufAppend;
 
 /* vprintf()'s */
@@ -125,7 +131,7 @@ packerToStoreInit(Packer * p, StoreEntry * e)
     p->append = (append_f) store_append;
     p->packer_vprintf = (vprintf_f) store_vprintf;
     p->real_handler = e;
-    storeBuffer(e);
+    e->buffer();
 }
 
 /* init with this to accumulate data in MemBuf */
@@ -145,7 +151,7 @@ packerClean(Packer * p)
     assert(p);
 
     if (p->append == (append_f) store_append && p->real_handler)
-        storeBufferFlush(static_cast<StoreEntry*>(p->real_handler));
+        static_cast<StoreEntry*>(p->real_handler)->flush();
 
     /* it is not really necessary to do this, but, just in case... */
     p->append = NULL;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Store.h,v 1.32 2007/04/20 23:53:41 wessels Exp $
+ * $Id: Store.h,v 1.33 2007/04/21 07:14:13 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -95,6 +95,23 @@ class StoreEntry : public hash_link
     void swapOut();
     bool swapOutAble() const;
     void swapOutFileClose();
+    const char *url() const;
+    int checkCachable();
+    int checkNegativeHit() const;
+    int locked() const;
+    int validToSend() const;
+    int keepInMemory() const;
+    void createMemObject(const char *, const char *);
+    void dump(int debug_lvl) const;
+    void hashDelete();
+    void hashInsert(const cache_key *);
+    void registerAbort(STABH * cb, void *);
+    void reset();
+    void setMemStatus(mem_status_t);
+    void timestampsSet();
+    void unregisterAbort();
+    void destroyMemObject();
+    int checkTooSmall();
 
     void delayAwareRead(int fd, char *buf, int len, IOCB *handler, void *data);
 
@@ -285,42 +302,26 @@ typedef RefCount<Store> StorePointer;
 
 SQUIDCEXTERN size_t storeEntryInUse();
 SQUIDCEXTERN const char *storeEntryFlags(const StoreEntry *);
-SQUIDCEXTERN int storeEntryLocked(const StoreEntry *);
 extern void storeEntryReplaceObject(StoreEntry *, HttpReply *);
 
 SQUIDCEXTERN StoreEntry *storeGetPublic(const char *uri, const method_t method);
 SQUIDCEXTERN StoreEntry *storeGetPublicByRequest(HttpRequest * request);
 SQUIDCEXTERN StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const method_t method);
 SQUIDCEXTERN StoreEntry *storeCreateEntry(const char *, const char *, request_flags, method_t);
-SQUIDCEXTERN void storeCreateMemObject(StoreEntry *, const char *, const char *);
 SQUIDCEXTERN void storeInit(void);
 extern void storeRegisterWithCacheManager(CacheManager & manager);
-SQUIDCEXTERN void storeAppend(StoreEntry *, const char *, int);
 SQUIDCEXTERN void storeConfigure(void);
-SQUIDCEXTERN int storeCheckNegativeHit(StoreEntry *);
 SQUIDCEXTERN void storeFreeMemory(void);
 SQUIDCEXTERN int expiresMoreThan(time_t, time_t);
-SQUIDCEXTERN int storeEntryValidToSend(StoreEntry *);
-SQUIDCEXTERN void storeTimestampsSet(StoreEntry *);
-SQUIDCEXTERN void storeRegisterAbort(StoreEntry * e, STABH * cb, void *);
-SQUIDCEXTERN void storeUnregisterAbort(StoreEntry * e);
-SQUIDCEXTERN void storeEntryDump(const StoreEntry * e, int debug_lvl);
-SQUIDCEXTERN const char *storeUrl(const StoreEntry *);
-SQUIDCEXTERN void storeBuffer(StoreEntry *);
-SQUIDCEXTERN void storeBufferFlush(StoreEntry *);
-SQUIDCEXTERN void storeHashInsert(StoreEntry * e, const cache_key *);
-SQUIDCEXTERN void storeSetMemStatus(StoreEntry * e, mem_status_t);
 #if STDC_HEADERS
 SQUIDCEXTERN void
 storeAppendPrintf(StoreEntry *, const char *,...) PRINTF_FORMAT_ARG2;
 #else
 SQUIDCEXTERN void storeAppendPrintf();
 #endif
 SQUIDCEXTERN void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
-SQUIDCEXTERN int storeCheckCachable(StoreEntry * e);
 SQUIDCEXTERN ssize_t objectLen(const StoreEntry * e);
 SQUIDCEXTERN int storeTooManyDiskFilesOpen(void);
-SQUIDCEXTERN void storeEntryReset(StoreEntry *);
 SQUIDCEXTERN void storeHeapPositionUpdate(StoreEntry *, SwapDir *);
 SQUIDCEXTERN void storeSwapFileNumberSet(StoreEntry * e, sfileno filn);
 SQUIDCEXTERN void storeFsInit(void);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.119 2006/11/04 15:44:58 hno Exp $
+ * $Id: access_log.cc,v 1.120 2007/04/21 07:14:13 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -1177,35 +1177,35 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
                     break;
                 }
 
-                storeAppend(entry, "%", 1);
+                entry->append("%", 1);
 
                 switch (t->quote) {
 
                 case LOG_QUOTE_QUOTES:
-                    storeAppend(entry, "\"", 1);
+                    entry->append("\"", 1);
                     break;
 
                 case LOG_QUOTE_BRAKETS:
-                    storeAppend(entry, "[", 1);
+                    entry->append("[", 1);
                     break;
 
                 case LOG_QUOTE_URL:
-                    storeAppend(entry, "#", 1);
+                    entry->append("#", 1);
                     break;
 
                 case LOG_QUOTE_RAW:
-                    storeAppend(entry, "'", 1);
+                    entry->append("'", 1);
                     break;
 
                 case LOG_QUOTE_NONE:
                     break;
                 }
 
                 if (t->left)
-                    storeAppend(entry, "-", 1);
+                    entry->append("-", 1);
 
                 if (t->zero)
-                    storeAppend(entry, "0", 1);
+                    entry->append("0", 1);
 
                 if (t->width)
                     storeAppendPrintf(entry, "%d", (int) t->width);
@@ -1224,13 +1224,13 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
                 }
 
                 if (t->space)
-                    storeAppend(entry, " ", 1);
+                    entry->append(" ", 1);
 
                 assert(te->config != NULL);
             }
         }
 
-        storeAppend(entry, "\n", 1);
+        entry->append("\n", 1);
     }
 
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: asn.cc,v 1.109 2006/06/05 18:35:02 serassio Exp $
+ * $Id: asn.cc,v 1.110 2007/04/21 07:14:13 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -288,7 +288,7 @@ asHandleReply(void *data, StoreIOBuffer result)
     }
 
     if (result.length == 0 && asState->dataRead) {
-        debug(53, 3) ("asHandleReply: Done: %s\n", storeUrl(e));
+        debug(53, 3) ("asHandleReply: Done: %s\n", e->url());
         asStateFree(asState);
         return;
     } else if (result.flags.error) {
@@ -354,7 +354,7 @@ asHandleReply(void *data, StoreIOBuffer result)
     debug(53, 3) ("asState->offset = %ld\n", (long int) asState->offset);
 
     if (e->store_status == STORE_PENDING) {
-        debug(53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", storeUrl(e));
+        debug(53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", e->url());
         StoreIOBuffer tempBuffer (AS_REQBUF_SZ - asState->reqofs,
                                   asState->offset,
                                   asState->reqbuf + asState->reqofs);
@@ -365,7 +365,7 @@ asHandleReply(void *data, StoreIOBuffer result)
                         asState);
     } else {
         StoreIOBuffer tempBuffer;
-        debug(53, 3) ("asHandleReply: store complete, but data recieved %s\n", storeUrl(e));
+        debug(53, 3) ("asHandleReply: store complete, but data recieved %s\n", e->url());
         tempBuffer.offset = asState->offset;
         tempBuffer.length = AS_REQBUF_SZ - asState->reqofs;
         tempBuffer.data = asState->reqbuf + asState->reqofs;
@@ -381,7 +381,7 @@ static void
 asStateFree(void *data)
 {
     ASState *asState = (ASState *)data;
-    debug(53, 3) ("asnStateFree: %s\n", storeUrl(asState->entry));
+    debug(53, 3) ("asnStateFree: %s\n", asState->entry->url());
     storeUnregister(asState->sc, asState->entry, asState);
     asState->entry->unlock();
     HTTPMSGUNLOCK(asState->request);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_manager.cc,v 1.45 2006/08/25 15:22:34 serassio Exp $
+ * $Id: cache_manager.cc,v 1.46 2007/04/21 07:14:13 wessels Exp $
  *
  * DEBUG: section 16    Cache Manager Objects
  * AUTHOR: Duane Wessels
@@ -244,11 +244,11 @@ cachemgrStart(int fd, HttpRequest * request, StoreEntry * entry)
     cachemgrStateData *mgr = NULL;
     ErrorState *err = NULL;
     CacheManagerAction *a;
-    debug(16, 3) ("objectcacheStart: '%s'\n", storeUrl(entry));
+    debug(16, 3) ("objectcacheStart: '%s'\n", entry->url());
 
-    if ((mgr = cachemgrParseUrl(storeUrl(entry))) == NULL) {
+    if ((mgr = cachemgrParseUrl(entry->url())) == NULL) {
         err = errorCon(ERR_INVALID_URL, HTTP_NOT_FOUND, request);
-        err->url = xstrdup(storeUrl(entry));
+        err->url = xstrdup(entry->url());
         errorAppendEntry(entry, err);
         entry->expires = squid_curtime;
         return;
@@ -314,7 +314,7 @@ cachemgrStart(int fd, HttpRequest * request, StoreEntry * entry)
     a = cachemgrFindAction(mgr->action);
     assert(a != NULL);
 
-    storeBuffer(entry);
+    entry->buffer();
 
     {
         HttpVersion version(1,0);
@@ -331,7 +331,7 @@ cachemgrStart(int fd, HttpRequest * request, StoreEntry * entry)
 
     a->handler(entry);
 
-    storeBufferFlush(entry);
+    entry->flush();
 
     if (a->flags.atomic)
         entry->complete();
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_reply.cc,v 1.119 2007/04/20 23:53:41 wessels Exp $
+ * $Id: client_side_reply.cc,v 1.120 2007/04/21 07:14:13 wessels Exp $
  *
  * DEBUG: section 88    Client-side Reply Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -341,7 +341,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
         return;
 
     debug(88, 3) ("handleIMSReply: %s, %lu bytes\n",
-                  storeUrl(http->storeEntry()),
+                  http->storeEntry()->url(),
                   (long unsigned) result.length);
 
     if (http->storeEntry() == NULL)
@@ -357,7 +357,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
 
     // request to origin was aborted
     if (EBIT_TEST(http->storeEntry()->flags, ENTRY_ABORTED)) {
-        debug(88, 3) ("handleIMSReply: request to origin aborted '%s', sending old entry to client\n", storeUrl(http->storeEntry()));
+        debug(88, 3) ("handleIMSReply: request to origin aborted '%s', sending old entry to client\n", http->storeEntry()->url());
         http->logType = LOG_TCP_REFRESH_FAIL;
         sendClientOldEntry();
     }
@@ -367,14 +367,14 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
         // header is too large, send old entry
 
         if (reqsize >= HTTP_REQBUF_SZ) {
-            debug(88, 3) ("handleIMSReply: response from origin is too large '%s', sending old entry to client\n", storeUrl(http->storeEntry()));
+            debug(88, 3) ("handleIMSReply: response from origin is too large '%s', sending old entry to client\n", http->storeEntry()->url());
             http->logType = LOG_TCP_REFRESH_FAIL;
             sendClientOldEntry();
         }
 
         // everything looks fine, we're just waiting for more data
         else {
-            debug(88, 3) ("handleIMSReply: incomplete headers for '%s', waiting for more data\n", storeUrl(http->storeEntry()));
+            debug(88, 3) ("handleIMSReply: incomplete headers for '%s', waiting for more data\n", http->storeEntry()->url());
             reqofs = reqsize;
             waitForMoreData();
         }
@@ -392,7 +392,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
             // update headers on existing entry
             HttpReply *old_rep = (HttpReply *) old_entry->getReply();
             old_rep->updateOnNotModified(http->storeEntry()->getReply());
-            storeTimestampsSet(old_entry);
+            old_entry->timestampsSet();
 
             // if client sent IMS
 
@@ -550,7 +550,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
         return;
     }
 
-    if (storeCheckNegativeHit(e)
+    if (e->checkNegativeHit()
 #if HTTP_VIOLATIONS
             && !r->flags.nocache_hack
 #endif
@@ -670,7 +670,7 @@ clientReplyContext::processMiss()
             debug(88, 0) ("clientProcessMiss: miss on a special object (%s).\n",
                           url);
             debug(88, 0) ("\tlog_type = %s\n", log_tags[http->logType]);
-            storeEntryDump(http->storeEntry(), 1);
+            http->storeEntry()->dump(1);
         }
 
         removeClientStoreReference(&sc, http);
@@ -809,7 +809,7 @@ clientReplyContext::purgeFoundObject(StoreEntry *entry)
     http->storeEntry()->lock()
 
     ;
-    storeCreateMemObject(http->storeEntry(), http->uri, http->log_uri);
+    http->storeEntry()->createMemObject(http->uri, http->log_uri);
 
     http->storeEntry()->mem_obj->method = http->request->method;
 
@@ -870,7 +870,7 @@ clientReplyContext::purgeDoPurgeGet(StoreEntry *newEntry)
 
     if (!newEntry->isNull()) {
         /* Release the cached URI */
-        debug(88, 4) ("clientPurgeRequest: GET '%s'\n", storeUrl(newEntry));
+        debug(88, 4) ("clientPurgeRequest: GET '%s'\n", newEntry->url());
         newEntry->release();
         purgeStatus = HTTP_OK;
     }
@@ -883,7 +883,7 @@ void
 clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
 {
     if (newEntry && !newEntry->isNull()) {
-        debug(88, 4) ("clientPurgeRequest: HEAD '%s'\n", storeUrl(newEntry));
+        debug(88, 4) ("clientPurgeRequest: HEAD '%s'\n", newEntry->url());
         newEntry->release();
         purgeStatus = HTTP_OK;
     }
@@ -896,7 +896,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
 
         if (entry) {
             debug(88, 4) ("clientPurgeRequest: Vary GET '%s'\n",
-                          storeUrl(entry));
+                          entry->url());
             entry->release();
             purgeStatus = HTTP_OK;
         }
@@ -905,7 +905,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
 
         if (entry) {
             debug(88, 4) ("clientPurgeRequest: Vary HEAD '%s'\n",
-                          storeUrl(entry));
+                          entry->url());
             entry->release();
             purgeStatus = HTTP_OK;
         }
@@ -946,7 +946,7 @@ clientReplyContext::traceReply(clientStreamNode * node)
     storeClientCopy(sc, http->storeEntry(),
                     tempBuffer, SendMoreData, this);
     http->storeEntry()->releaseRequest();
-    storeBuffer(http->storeEntry());
+    http->storeEntry()->buffer();
     HttpReply *rep = new HttpReply;
     HttpVersion version(1,0);
     rep->setHeaders(version, HTTP_OK, NULL, "text/plain",
@@ -1225,7 +1225,7 @@ clientReplyContext::buildReplyHeader()
         /*
          * This adds the calculated object age. Note that the details of the
          * age calculation is performed by adjusting the timestamp in
-         * storeTimestampsSet(), not here.
+         * StoreEntry::timestampsSet(), not here.
          *
          * BROWSER WORKAROUND: IE sometimes hangs when receiving a 0 Age
          * header, so don't use it unless there is a age to report. Please
@@ -1477,8 +1477,8 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
         return;
     }
 
-    if (!storeEntryValidToSend(e)) {
-        debug(85, 3) ("clientProcessRequest2: !storeEntryValidToSend MISS\n");
+    if (!e->validToSend()) {
+        debug(85, 3) ("clientProcessRequest2: !validToSend MISS\n");
         http->storeEntry(NULL);
         http->logType = LOG_TCP_MISS;
         doGetMoreData();
@@ -1583,8 +1583,7 @@ clientReplyContext::doGetMoreData()
              * is a cache hit for a GET response, we want to keep
              * the method as GET.
              */
-            storeCreateMemObject(http->storeEntry(), http->uri,
-                                 http->log_uri);
+            http->storeEntry()->createMemObject(http->uri, http->log_uri);
             http->storeEntry()->mem_obj->method =
                 http->request->method;
         }
@@ -1941,7 +1940,7 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
                   http->uri, (int) reqofs, (unsigned int)result.length);
 
     debug(88, 5) ("clientReplyContext::sendMoreData: FD %d '%s', out.offset=%ld \n",
-                  fd, storeUrl(entry), (long int) http->out.offset);
+                  fd, entry->url(), (long int) http->out.offset);
 
     /* update size of the request */
     reqsize = reqofs;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.221 2007/04/20 23:53:41 wessels Exp $
+ * $Id: errorpage.cc,v 1.222 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -382,7 +382,7 @@ errorAppendEntry(StoreEntry * entry, ErrorState * err)
     }
 
     entry->lock();
-    storeBuffer(entry);
+    entry->buffer();
     rep = errorBuildReply(err);
     /* Add authentication header */
     /* TODO: alter errorstate to be accel on|off aware. The 0 on the next line
@@ -393,7 +393,7 @@ errorAppendEntry(StoreEntry * entry, ErrorState * err)
     authenticateFixHeader(rep, err->auth_user_request, err->request, 0, 1);
     entry->replaceHttpReply(rep);
     EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
-    storeBufferFlush(entry);
+    entry->flush();
     entry->complete();
     entry->negativeCache();
     entry->releaseRequest();
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.159 2007/04/20 23:53:41 wessels Exp $
+ * $Id: forward.cc,v 1.160 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -117,7 +117,7 @@ void FwdState::start(Pointer aSelf)
     // We hope that either the store entry aborts or peer is selected.
     // Otherwise we are going to leak our object.
 
-    storeRegisterAbort(entry, FwdState::abort, this);
+    entry->registerAbort(FwdState::abort, this);
     peerSelect(request, entry, fwdStartCompleteWrapper, this);
 
     // TODO: set self _after_ the peer is selected because we do not need
@@ -174,7 +174,7 @@ FwdState::~FwdState()
     if (err)
         errorStateFree(err);
 
-    storeUnregisterAbort(entry);
+    entry->unregisterAbort();
 
     entry->unlock();
 
@@ -234,7 +234,7 @@ FwdState::fwdStart(int client_fd, StoreEntry *entry, HttpRequest *request)
         }
     }
 
-    debug(17, 3) ("FwdState::start() '%s'\n", storeUrl(entry));
+    debug(17, 3) ("FwdState::start() '%s'\n", entry->url());
     /*
      * This seems like an odd place to bind mem_obj and request.
      * Might want to assert that request is NULL at this point
@@ -289,7 +289,7 @@ FwdState::fail(ErrorState * errorState)
     debug(17, 3) ("fwdFail: %s \"%s\"\n\t%s\n",
                   err_type_str[errorState->type],
                   httpStatusString(errorState->httpStatus),
-                  storeUrl(entry));
+                  entry->url());
 
     if (err)
         errorStateFree(err);
@@ -306,7 +306,7 @@ FwdState::fail(ErrorState * errorState)
 void
 FwdState::unregister(int fd)
 {
-    debug(17, 3) ("fwdUnregister: %s\n", storeUrl(entry));
+    debug(17, 3) ("fwdUnregister: %s\n", entry->url());
     assert(fd == server_fd);
     assert(fd > -1);
     comm_remove_close_handler(fd, fwdServerClosedWrapper, this);
@@ -324,7 +324,7 @@ FwdState::complete()
 {
     StoreEntry *e = entry;
     assert(entry->store_status == STORE_PENDING);
-    debug(17, 3) ("fwdComplete: %s\n\tstatus %d\n", storeUrl(e),
+    debug(17, 3) ("fwdComplete: %s\n\tstatus %d\n", e->url(),
                   entry->getReply()->sline.status);
 #if URL_CHECKSUM_DEBUG
 
@@ -336,12 +336,12 @@ FwdState::complete()
     if (reforward()) {
         debug(17, 3) ("fwdComplete: re-forwarding %d %s\n",
                       entry->getReply()->sline.status,
-                      storeUrl(e));
+                      e->url());
 
         if (server_fd > -1)
             unregister(server_fd);
 
-        storeEntryReset(e);
+        e->reset();
 
         startComplete(servers);
     } else {
@@ -500,7 +500,7 @@ FwdState::checkRetriable()
 void
 FwdState::serverClosed(int fd)
 {
-    debug(17, 2) ("fwdServerClosed: FD %d %s\n", fd, storeUrl(entry));
+    debug(17, 2) ("fwdServerClosed: FD %d %s\n", fd, entry->url());
     assert(server_fd == fd);
     server_fd = -1;
 
@@ -698,7 +698,7 @@ FwdState::connectDone(int aServerFD, comm_err_t status, int xerrno)
 
         comm_close(server_fd);
     } else {
-        debug(17, 3) ("fwdConnectDone: FD %d: '%s'\n", server_fd, storeUrl(entry));
+        debug(17, 3) ("fwdConnectDone: FD %d: '%s'\n", server_fd, entry->url());
 
         if (fs->_peer)
             peerConnectSucceded(fs->_peer);
@@ -721,7 +721,7 @@ FwdState::connectTimeout(int fd)
 {
     FwdServer *fs = servers;
 
-    debug(17, 2) ("fwdConnectTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
+    debug(17, 2) ("fwdConnectTimeout: FD %d: '%s'\n", fd, entry->url());
     assert(fd == server_fd);
 
     if (Config.onoff.log_ip_on_direct && fs->code == HIER_DIRECT && fd_table[fd].ipaddr[0])
@@ -746,7 +746,7 @@ FwdState::connectTimeout(int fd)
 void
 FwdState::connectStart()
 {
-    const char *url = storeUrl(entry);
+    const char *url = entry->url();
     int fd = -1;
     FwdServer *fs = servers;
     const char *host;
@@ -910,7 +910,7 @@ FwdState::connectStart()
 void
 FwdState::startComplete(FwdServer * theServers)
 {
-    debug(17, 3) ("fwdStartComplete: %s\n", storeUrl(entry));
+    debug(17, 3) ("fwdStartComplete: %s\n", entry->url());
 
     if (theServers != NULL) {
         servers = theServers;
@@ -923,7 +923,7 @@ FwdState::startComplete(FwdServer * theServers)
 void
 FwdState::startFail()
 {
-    debug(17, 3) ("fwdStartFail: %s\n", storeUrl(entry));
+    debug(17, 3) ("fwdStartFail: %s\n", entry->url());
     ErrorState *anErr = errorCon(ERR_CANNOT_FORWARD, HTTP_SERVICE_UNAVAILABLE, request);
     anErr->xerrno = errno;
     fail(anErr);
@@ -937,15 +937,15 @@ FwdState::dispatch()
     debug(17, 3) ("fwdDispatch: FD %d: Fetching '%s %s'\n",
                   client_fd,
                   RequestMethodStr[request->method],
-                  storeUrl(entry));
+                  entry->url());
     /*
      * Assert that server_fd is set.  This is to guarantee that fwdState
      * is attached to something and will be deallocated when server_fd
      * is closed.
      */
     assert(server_fd > -1);
 
-    fd_note(server_fd, storeUrl(entry));
+    fd_note(server_fd, entry->url());
 
     fd_table[server_fd].noteUse(fwdPconnPool);
 
@@ -1003,7 +1003,7 @@ FwdState::dispatch()
 
         default:
             debug(17, 1) ("fwdDispatch: Cannot retrieve '%s'\n",
-                          storeUrl(entry));
+                          entry->url());
             ErrorState *anErr = errorCon(ERR_UNSUP_REQ, HTTP_BAD_REQUEST, request);
             fail(anErr);
             /*
@@ -1044,7 +1044,7 @@ FwdState::reforward()
     e->mem_obj->checkUrlChecksum();
 #endif
 
-    debug(17, 3) ("fwdReforward: %s?\n", storeUrl(e));
+    debug(17, 3) ("fwdReforward: %s?\n", e->url());
 
     if (!EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT)) {
         debug(17, 3) ("fwdReforward: No, ENTRY_FWD_HDR_WAIT isn't set\n");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_coss.cc,v 1.69 2007/04/20 23:53:42 wessels Exp $
+ * $Id: store_dir_coss.cc,v 1.70 2007/04/21 07:14:16 wessels Exp $
  * vim: set et : 
  *
  * DEBUG: section 47    Store COSS Directory Routines
@@ -534,7 +534,7 @@ storeCossAddDiskRestore(CossSwapDir * SD, const cache_key * key,
     e = new StoreEntry();
     e->store_status = STORE_OK;
     e->swap_dirn = SD->index;
-    storeSetMemStatus(e, NOT_IN_MEMORY);
+    e->setMemStatus(NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_DONE;
     e->swap_filen = file_number;
     e->swap_file_sz = swap_file_sz;
@@ -550,7 +550,7 @@ storeCossAddDiskRestore(CossSwapDir * SD, const cache_key * key,
     EBIT_CLR(e->flags, KEY_PRIVATE);
     e->ping_status = PING_NONE;
     EBIT_CLR(e->flags, ENTRY_VALIDATED);
-    storeHashInsert(e, key);	/* do it after we clear KEY_PRIVATE */
+    hashInsert(key);	/* do it after we clear KEY_PRIVATE */
     storeCossAdd(SD, e);
     assert(e->swap_filen >= 0);
     return e;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_ufs.cc,v 1.79 2007/04/12 23:51:58 wessels Exp $
+ * $Id: store_dir_ufs.cc,v 1.80 2007/04/21 07:14:16 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -276,7 +276,7 @@ UFSSwapDir::dumpEntry(StoreEntry &e) const
     debug(47, 0) ("UFSSwapDir::dumpEntry: FILENO %08X\n", e.swap_filen);
     debug(47, 0) ("UFSSwapDir::dumpEntry: PATH %s\n",
                   fullPath(e.swap_filen, NULL));
-    storeEntryDump(&e, 0);
+    e.dump(0);
 }
 
 /*
@@ -704,7 +704,7 @@ UFSSwapDir::addDiskRestore(const cache_key * key,
      * already in use! */
     e = new StoreEntry();
     e->store_status = STORE_OK;
-    storeSetMemStatus(e, NOT_IN_MEMORY);
+    e->setMemStatus(NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_DONE;
     e->swap_filen = file_number;
     e->swap_dirn = index;
@@ -722,7 +722,7 @@ UFSSwapDir::addDiskRestore(const cache_key * key,
     e->ping_status = PING_NONE;
     EBIT_CLR(e->flags, ENTRY_VALIDATED);
     mapBitSet(e->swap_filen);
-    storeHashInsert(e, key);	/* do it after we clear KEY_PRIVATE */
+    e->hashInsert(key);	/* do it after we clear KEY_PRIVATE */
     replacementAdd (e);
     return e;
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: ufscommon.cc,v 1.9 2007/04/20 23:53:42 wessels Exp $
+ * $Id: ufscommon.cc,v 1.10 2007/04/21 07:14:16 wessels Exp $
  * vim: set et : 
  *
  * DEBUG: section 47    Store Directory Routines
@@ -284,7 +284,7 @@ RebuildState::rebuildFromDirectory()
         }
 
         counts.objcount++;
-        storeEntryDump(&tmpe, 5);
+        tmpe.dump(5);
         currentEntry(sd->addDiskRestore(key,
                                         filn,
                                         tmpe.swap_file_sz,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.413 2007/04/20 23:53:41 wessels Exp $
+ * $Id: ftp.cc,v 1.414 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -375,7 +375,7 @@ FtpStateData::ftpSocketClosed(int fdnotused, void *data)
 
 FtpStateData::FtpStateData(FwdState *theFwdState) : ServerStateData(theFwdState)
 {
-    const char *url = storeUrl(entry);
+    const char *url = entry->url();
     debug(9, 3) ("ftpStart: '%s'\n", url);
     statCounter.server.all.requests++;
     statCounter.server.ftp.requests++;
@@ -397,9 +397,9 @@ FtpStateData::FtpStateData(FwdState *theFwdState) : ServerStateData(theFwdState)
 
 FtpStateData::~FtpStateData()
 {
-    debug(9, 3) ("~ftpStateData: %s\n", storeUrl(entry));
+    debug(9, 3) ("~ftpStateData: %s\n", entry->url());
 
-    storeUnregisterAbort(entry);
+    entry->unregisterAbort();
 
     if (reply_hdr) {
         memFree(reply_hdr, MEM_8K_BUF);
@@ -489,7 +489,7 @@ FtpStateData::ftpTimeout(int fd, void *data)
 {
     FtpStateData *ftpState = (FtpStateData *)data;
     StoreEntry *entry = ftpState->entry;
-    debug(9, 4) ("ftpTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
+    debug(9, 4) ("ftpTimeout: FD %d: '%s'\n", fd, entry->url());
 
     if (SENT_PASV == ftpState->state && fd == ftpState->data.fd) {
         /* stupid ftp.netscape.com */
@@ -592,7 +592,7 @@ void
 FtpStateData::listingFinish()
 {
     debugs(9,3,HERE << "listingFinish()");
-    storeBuffer(entry);
+    entry->buffer();
     printfReplyBody("</PRE>\n");
 
     if (flags.listformat_unknown && !flags.tried_nlst) {
@@ -1107,7 +1107,7 @@ FtpStateData::parseListing()
     size_t len = data.readBuf->contentSize();
 
     if (!len) {
-        debug(9, 3) ("ftpParseListing: no content to parse for %s\n", storeUrl(e));
+        debug(9, 3) ("ftpParseListing: no content to parse for %s\n", e->url());
         return;
     }
 
@@ -1126,15 +1126,15 @@ FtpStateData::parseListing()
     debug(9, 3) ("ftpParseListing: usable = %d\n", (int) usable);
 
     if (usable == 0) {
-        debug(9, 3) ("ftpParseListing: didn't find end for %s\n", storeUrl(e));
+        debug(9, 3) ("ftpParseListing: didn't find end for %s\n", e->url());
         xfree(sbuf);
         return;
     }
 
     debug(9, 3) ("ftpParseListing: %lu bytes to play with\n", (unsigned long int)len);
     line = (char *)memAllocate(MEM_4K_BUF);
     end++;
-    storeBuffer(e);	/* released when done processing current data payload */
+    e->buffer();	/* released when done processing current data payload */
     s = sbuf;
     s += strspn(s, crlf);
 
@@ -1343,7 +1343,7 @@ FtpStateData::processReplyBody()
         data.readBuf->consume(data.readBuf->contentSize());
     }
 
-    storeBufferFlush(entry);
+    entry->flush();
 
     maybeReadVirginBody();
 }
@@ -2192,7 +2192,7 @@ ftpSendPasv(FtpStateData * ftpState)
     if (ftpState->request->method == METHOD_HEAD && (ftpState->flags.isdir || ftpState->size != -1)) {
         /* Terminate here for HEAD requests */
         ftpState->appendSuccessHeader();
-        storeTimestampsSet(ftpState->entry);
+        ftpState->entry->timestampsSet();
         /*
          * On rare occasions I'm seeing the entry get aborted after
          * ftpReadControlReply() and before here, probably when
@@ -2233,7 +2233,7 @@ ftpSendPasv(FtpStateData * ftpState)
                        addr.sin_addr,
                        0,
                        COMM_NONBLOCKING,
-                       storeUrl(ftpState->entry));
+                       ftpState->entry->url());
 
     debug(9, 3) ("ftpSendPasv: Unconnected data socket created on FD %d\n", fd);
 
@@ -2405,7 +2405,7 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
                    addr.sin_addr,
                    port,
                    COMM_NONBLOCKING | (fallback ? COMM_REUSEADDR : 0),
-                   storeUrl(ftpState->entry));
+                   ftpState->entry->url());
     debug(9, 3) ("ftpOpenListenSocket: Unconnected data socket created on FD %d\n", fd);
 
     if (fd < 0) {
@@ -2826,7 +2826,7 @@ ftpWriteTransferDone(FtpStateData * ftpState)
         return;
     }
 
-    storeTimestampsSet(ftpState->entry);	/* XXX Is this needed? */
+    ftpState->entry->timestampsSet();	/* XXX Is this needed? */
     ftpSendReply(ftpState);
 }
 
@@ -3030,7 +3030,7 @@ ftpSendReply(FtpStateData * ftpState)
     http_status http_code;
     err_type err_code = ERR_NONE;
     debug(9, 5) ("ftpSendReply: %s, code %d\n",
-                 storeUrl(ftpState->entry), code);
+                 ftpState->entry->url(), code);
 
     if (cbdataReferenceValid(ftpState))
         debug(9, 5) ("ftpSendReply: ftpState (%p) is valid!\n", ftpState);
@@ -3089,7 +3089,7 @@ FtpStateData::appendSuccessHeader()
 
     EBIT_CLR(e->flags, ENTRY_FWD_HDR_WAIT);
 
-    storeBuffer(e);	/* released when done processing current data payload */
+    e->buffer();	/* released when done processing current data payload */
 
     filename = (t = urlpath.rpos('/')) ? t + 1 : urlpath.buf();
 
@@ -3155,7 +3155,7 @@ FtpStateData::appendSuccessHeader()
 
     e->replaceHttpReply(reply);
 
-    storeTimestampsSet(e);
+    e->timestampsSet();
 
     if (flags.authenticated) {
         /*
@@ -3256,7 +3256,7 @@ FtpStateData::writeReplyBody(const char *data, int len)
 
     //debugs(9,5,HERE << data);
 
-    storeAppend(entry, data, len);
+    entry->append(data, len);
 }
 
 // called after we wrote the last byte of the request body
@@ -1,6 +1,6 @@
 
 /*
- * $Id: gopher.cc,v 1.201 2007/04/20 23:53:41 wessels Exp $
+ * $Id: gopher.cc,v 1.202 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -222,7 +222,7 @@ gopherMimeCreate(GopherStateData * gopherState)
 
     mb.Printf("\r\n");
     EBIT_CLR(gopherState->entry->flags, ENTRY_FWD_HDR_WAIT);
-    storeAppend(gopherState->entry, mb.buf, mb.size);
+    gopherState->entry->append(mb.buf, mb.size);
     mb.clean();
 }
 
@@ -347,30 +347,30 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
     entry = gopherState->entry;
 
     if (gopherState->conversion == gopher_ds::HTML_INDEX_PAGE) {
-        char *html_url = html_quote(storeUrl(entry));
+        char *html_url = html_quote(entry->url());
         gopherHTMLHeader(entry, "Gopher Index %s", html_url);
         storeAppendPrintf(entry,
                           "<p>This is a searchable Gopher index. Use the search\n"
                           "function of your browser to enter search terms.\n"
                           "<ISINDEX>\n");
         gopherHTMLFooter(entry);
         /* now let start sending stuff to client */
-        storeBufferFlush(entry);
+        entry->flush();
         gopherState->HTML_header_added = 1;
 
         return;
     }
 
     if (gopherState->conversion == gopher_ds::HTML_CSO_PAGE) {
-        char *html_url = html_quote(storeUrl(entry));
+        char *html_url = html_quote(entry->url());
         gopherHTMLHeader(entry, "CSO Search of %s", html_url);
         storeAppendPrintf(entry,
                           "<P>A CSO database usually contains a phonebook or\n"
                           "directory.  Use the search function of your browser to enter\n"
                           "search terms.</P><ISINDEX>\n");
         gopherHTMLFooter(entry);
         /* now let start sending stuff to client */
-        storeBufferFlush(entry);
+        entry->flush();
         gopherState->HTML_header_added = 1;
 
         return;
@@ -400,7 +400,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 
             if (gopherState->len + len > TEMP_BUF_SIZE) {
                 debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
-                              storeUrl(entry));
+                              entry->url());
                 len = TEMP_BUF_SIZE - gopherState->len;
             }
 
@@ -414,7 +414,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 
                 if (gopherState->len + len > TEMP_BUF_SIZE) {
                     debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
-                                  storeUrl(entry));
+                                  entry->url());
                     len = TEMP_BUF_SIZE - gopherState->len;
                 }
 
@@ -445,7 +445,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 
                 if ((len - (pos - inbuf)) > TEMP_BUF_SIZE) {
                     debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
-                                  storeUrl(entry));
+                                  entry->url());
                     len = TEMP_BUF_SIZE;
                 }
 
@@ -694,9 +694,9 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
     }				/* while loop */
 
     if (outbuf.size() > 0) {
-        storeAppend(entry, outbuf.buf(), outbuf.size());
+        entry->append(outbuf.buf(), outbuf.size());
         /* now let start sending stuff to client */
-        storeBufferFlush(entry);
+        entry->flush();
     }
 
     outbuf.clean();
@@ -708,7 +708,7 @@ gopherTimeout(int fd, void *data)
 {
     GopherStateData *gopherState = (GopherStateData *)data;
     StoreEntry *entry = gopherState->entry;
-    debug(10, 4) ("gopherTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
+    debug(10, 4) ("gopherTimeout: FD %d: '%s'\n", fd, entry->url());
 
     gopherState->fwd->fail(errorCon(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT, gopherState->fwd->request));
 
@@ -797,9 +797,9 @@ gopherReadReply(int fd, char *buf, size_t len, comm_err_t flag, int xerrno, void
         if (gopherState->conversion != gopher_ds::NORMAL)
             gopherEndHTML(gopherState);
 
-        storeTimestampsSet(entry);
+        entry->timestampsSet();
 
-        storeBufferFlush(entry);
+        entry->flush();
 
         gopherState->fwd->complete();
 
@@ -810,7 +810,7 @@ gopherReadReply(int fd, char *buf, size_t len, comm_err_t flag, int xerrno, void
         if (gopherState->conversion != gopher_ds::NORMAL) {
             gopherToHTML(gopherState, buf, len);
         } else {
-            storeAppend(entry, buf, len);
+            entry->append(buf, len);
         }
 
         do_next_read = 1;
@@ -843,7 +843,7 @@ gopherSendComplete(int fd, char *buf, size_t size, comm_err_t errflag, int xerrn
         err = errorCon(ERR_WRITE_ERROR, HTTP_SERVICE_UNAVAILABLE, gopherState->fwd->request);
         err->xerrno = errno;
         err->port = gopherState->req->port;
-        err->url = xstrdup(storeUrl(entry));
+        err->url = xstrdup(entry->url());
         gopherState->fwd->fail(err);
         comm_close(fd);
 
@@ -857,7 +857,7 @@ gopherSendComplete(int fd, char *buf, size_t size, comm_err_t errflag, int xerrn
      * OK. We successfully reach remote site.  Start MIME typing
      * stuff.  Do it anyway even though request is not HTML type.
      */
-    storeBuffer(entry);
+    entry->buffer();
 
     gopherMimeCreate(gopherState);
 
@@ -884,7 +884,7 @@ gopherSendComplete(int fd, char *buf, size_t size, comm_err_t errflag, int xerrn
 
     default:
         gopherState->conversion = gopher_ds::NORMAL;
-        storeBufferFlush(entry);
+        entry->flush();
     }
 
     /* Schedule read reply. */
@@ -947,7 +947,7 @@ gopherStart(FwdState * fwd)
 
     gopherState->fwd = fwd;
 
-    debug(10, 3) ("gopherStart: %s\n", storeUrl(entry));
+    debug(10, 3) ("gopherStart: %s\n", entry->url());
 
     statCounter.server.all.requests++;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: htcp.cc,v 1.73 2007/04/20 23:53:41 wessels Exp $
+ * $Id: htcp.cc,v 1.74 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 31    Hypertext Caching Protocol
  * AUTHOR: Duane Wesssels
@@ -1042,7 +1042,7 @@ htcpSpecifier::created (StoreEntry *e)
         goto miss;
     }
 
-    if (!storeEntryValidToSend(e)) {
+    if (!e->validToSend()) {
         debug(31, 3) ("htcpCheckHit: NO; entry not valid to send\n");
         goto miss;
     }
@@ -1062,7 +1062,7 @@ htcpSpecifier::created (StoreEntry *e)
 static void
 htcpClrStoreEntry(StoreEntry * e)
 {
-    debug(31, 4) ("htcpClrStoreEntry: Clearing store for entry: %s\n", storeUrl(e));
+    debug(31, 4) ("htcpClrStoreEntry: Clearing store for entry: %s\n", e->url());
     e->releaseRequest();
 }
 
@@ -1596,7 +1596,7 @@ htcpQuery(StoreEntry * e, HttpRequest * req, peer * p)
 
     stuff.S.method = (char *) RequestMethodStr[req->method];
 
-    stuff.S.uri = (char *) storeUrl(e);
+    stuff.S.uri = (char *) e->url();
 
     stuff.S.version = vbuf;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.514 2007/04/20 23:53:41 wessels Exp $
+ * $Id: http.cc,v 1.515 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -94,7 +94,7 @@ HttpStateData::HttpStateData(FwdState *theFwdState) : ServerStateData(theFwdStat
         if (_peer->options.originserver)
             url = orig_request->urlpath.buf();
         else
-            url = storeUrl(entry);
+            url = entry->url();
 
         HttpRequest * proxy_req = new HttpRequest(orig_request->method,
                                   orig_request->protocol, url);
@@ -182,7 +182,7 @@ httpTimeout(int fd, void *data)
 {
     HttpStateData *httpState = static_cast<HttpStateData *>(data);
     StoreEntry *entry = httpState->entry;
-    debug(11, 4) ("httpTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
+    debug(11, 4) ("httpTimeout: FD %d: '%s'\n", fd, entry->url());
 
     if (entry->store_status == STORE_PENDING) {
         httpState->fwd->fail(errorCon(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT, httpState->fwd->request));
@@ -358,7 +358,7 @@ HttpStateData::processSurrogateControl(HttpReply *reply)
                     reply->expires = reply->date + sctusable->max_stale;
 
                 /* And update the timestamps */
-                storeTimestampsSet(entry);
+                entry->timestampsSet();
             }
 
             /* We ignore cache-control directives as per the Surrogate specification */
@@ -660,7 +660,7 @@ HttpStateData::keepaliveAccounting(HttpReply *reply)
             _peer->stats.n_keepalives_recv++;
 
         if (Config.onoff.detect_broken_server_pconns && reply->bodySize(request->method) == -1) {
-            debug(11, 1) ("keepaliveAccounting: Impossible keep-alive header from '%s'\n", storeUrl(entry));
+            debug(11, 1) ("keepaliveAccounting: Impossible keep-alive header from '%s'\n", entry->url());
             // debug(11, 2) ("GOT HTTP REPLY HDR:\n---------\n%s\n----------\n", readBuf->content());
             flags.keepalive_broken = 1;
         }
@@ -774,7 +774,7 @@ HttpStateData::haveParsedReplyHeaders()
             getReply()->content_range)
         currentOffset = getReply()->content_range->spec.offset;
 
-    storeTimestampsSet(entry);
+    entry->timestampsSet();
 
     /* Check if object is cacheable or not based on reply code */
     debug(11, 3) ("haveParsedReplyHeaders: HTTP CODE: %d\n", getReply()->sline.status);
@@ -873,7 +873,7 @@ HttpStateData::statusIfComplete() const
     if (!flags.request_sent) {
         debug(11, 1) ("statusIfComplete: Request not yet fully sent \"%s %s\"\n",
                       RequestMethodStr[orig_request->method],
-                      storeUrl(entry));
+                      entry->url());
         return COMPLETE_NONPERSISTENT_MSG;
     }
 
@@ -1053,7 +1053,7 @@ HttpStateData::readReply (size_t len, comm_err_t flag, int xerrno)
             flags.do_next_read = 0;
         } else {
             if (entry->mem_obj->getReply()->sline.status == HTTP_HEADER_TOO_LARGE) {
-                storeEntryReset(entry);
+                entry->reset();
                 fwd->fail( errorCon(ERR_TOO_BIG, HTTP_BAD_GATEWAY, fwd->request));
                 fwd->dontRetry(true);
                 flags.do_next_read = 0;
@@ -1078,7 +1078,7 @@ HttpStateData::readReply (size_t len, comm_err_t flag, int xerrno)
                 }
 
                 if (fail) {
-                    storeEntryReset(entry);
+                    entry->reset();
                     fwd->fail( errorCon(ERR_INVALID_RESP, HTTP_BAD_GATEWAY, fwd->request));
                     comm_close(fd);
                     return;
@@ -1515,7 +1515,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
         if (!EBIT_TEST(cc->mask, CC_MAX_AGE)) {
             const char *url =
-                entry ? storeUrl(entry) : urlCanonical(orig_request);
+                entry ? entry->url() : urlCanonical(orig_request);
             httpHdrCcSetMaxAge(cc, getMaxAge(url));
 
             if (request->urlpath.size())
@@ -1814,7 +1814,7 @@ httpStart(FwdState *fwd)
 {
     debug(11, 3) ("httpStart: \"%s %s\"\n",
                   RequestMethodStr[fwd->request->method],
-                  storeUrl(fwd->entry));
+                  fwd->entry->url());
     HttpStateData *httpState = new HttpStateData(fwd);
 
     if (!httpState->sendRequest()) {
@@ -1878,7 +1878,7 @@ HttpStateData::handleMoreRequestBodyAvailable()
             flags.abuse_detected = 1;
             debug(11, 1) ("http handleMoreRequestBodyAvailable: Likely proxy abuse detected '%s' -> '%s'\n",
                           inet_ntoa(orig_request->client_addr),
-                          storeUrl(entry));
+                          entry->url());
 
             if (getReply()->sline.status == HTTP_INVALID_HEADER) {
                 comm_close(fd);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icp_v2.cc,v 1.96 2007/04/19 20:21:34 wessels Exp $
+ * $Id: icp_v2.cc,v 1.97 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 12    Internet Cache Protocol
  * AUTHOR: Duane Wessels
@@ -316,7 +316,7 @@ icpCheckUdpHit(StoreEntry * e, HttpRequest * request)
     if (e == NULL)
         return 0;
 
-    if (!storeEntryValidToSend(e))
+    if (!e->validToSend())
         return 0;
 
     if (Config.onoff.icp_hit_stale)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: internal.cc,v 1.43 2006/08/25 15:22:34 serassio Exp $
+ * $Id: internal.cc,v 1.44 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 76    Internal Squid Object handling
  * AUTHOR: Duane, Alex, Henrik
@@ -74,7 +74,7 @@ internalStart(HttpRequest * request, StoreEntry * entry)
                           squid_curtime,
                           -2);
         entry->replaceHttpReply(reply);
-        storeAppend(entry, msgbuf, strlen(msgbuf));
+        entry->append(msgbuf, strlen(msgbuf));
         entry->complete();
     } else {
         debugObj(76, 1, "internalStart: unknown request:\n",
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.129 2007/04/20 23:53:41 wessels Exp $
+ * $Id: mime.cc,v 1.130 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -573,7 +573,7 @@ MimeIcon::created (StoreEntry *newEntry)
     assert(e != NULL);
     EBIT_SET(e->flags, ENTRY_SPECIAL);
     e->setPublicKey();
-    storeBuffer(e);
+    e->buffer();
     HttpRequest *r = HttpRequest::CreateFromUrl(url);
 
     if (NULL == r)
@@ -600,15 +600,15 @@ MimeIcon::created (StoreEntry *newEntry)
     buf = (char *)memAllocate(MEM_4K_BUF);
 
     while ((n = FD_READ_METHOD(fd, buf, 4096)) > 0)
-        storeAppend(e, buf, n);
+        e->append(buf, n);
 
     file_close(fd);
 
-    storeBufferFlush(e);
+    e->flush();
 
     e->complete();
 
-    storeTimestampsSet(e);
+    e->timestampsSet();
 
     debug(25, 3) ("Loaded icon %s\n", url);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.346 2007/04/20 23:53:41 wessels Exp $
+ * $Id: neighbors.cc,v 1.347 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -577,7 +577,7 @@ neighborsUdpPing(HttpRequest * request,
                  int *exprep,
                  int *timeout)
 {
-    const char *url = storeUrl(entry);
+    const char *url = entry->url();
     MemObject *mem = entry->mem_obj;
     peer *p = NULL;
     int i;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.191 2006/08/21 00:50:41 robertc Exp $
+ * $Id: net_db.cc,v 1.192 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -871,7 +871,7 @@ static void
 netdbExchangeDone(void *data)
 {
     netdbExchangeState *ex = (netdbExchangeState *)data;
-    debug(38, 3) ("netdbExchangeDone: %s\n", storeUrl(ex->e));
+    debug(38, 3) ("netdbExchangeDone: %s\n", ex->e->url());
     HTTPMSGUNLOCK(ex->r);
     storeUnregister(ex->sc, ex->e, ex);
     ex->e->unlock();
@@ -1216,7 +1216,7 @@ netdbBinaryExchange(StoreEntry * s)
     char *buf;
 
     struct IN_ADDR addr;
-    storeBuffer(s);
+    s->buffer();
     HttpVersion version(1, 0);
     reply->setHeaders(version, HTTP_OK, "OK", NULL, -1, squid_curtime, -2);
     s->replaceHttpReply(reply);
@@ -1261,18 +1261,18 @@ netdbBinaryExchange(StoreEntry * s)
         i += sizeof(int);
 
         if (i + rec_sz > 4096) {
-            storeAppend(s, buf, i);
+            s->append(buf, i);
             i = 0;
         }
     }
 
     if (i > 0) {
-        storeAppend(s, buf, i);
+        s->append(buf, i);
         i = 0;
     }
 
     assert(0 == i);
-    storeBufferFlush(s);
+    s->flush();
     memFree(buf, MEM_4K_BUF);
 #else
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.120 2007/04/20 23:53:41 wessels Exp $
+ * $Id: peer_digest.cc,v 1.121 2007/04/21 07:14:14 wessels Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -378,7 +378,7 @@ peerDigestRequest(PeerDigest * pd)
         old_e->lock()
 
         ;
-        storeCreateMemObject(old_e, url, url);
+        old_e->createMemObject(url, url);
 
         fetch->old_sc = storeClientListAdd(old_e, fetch);
     }
@@ -566,7 +566,7 @@ peerDigestFetchReply(void *data, char *buf, ssize_t size)
 
             old_rep->updateOnNotModified(reply);
 
-            storeTimestampsSet(fetch->old_entry);
+            fetch->old_entry->timestampsSet();
 
             /* get rid of 304 reply */
             storeUnregister(fetch->sc, fetch->entry, fetch);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.144 2007/02/25 11:32:32 hno Exp $
+ * $Id: peer_select.cc,v 1.145 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -131,7 +131,7 @@ peerSelectIcpPing(HttpRequest * request, int direct, StoreEntry * entry)
     assert(entry);
     assert(entry->ping_status == PING_NONE);
     assert(direct != DIRECT_YES);
-    debug(44, 3) ("peerSelectIcpPing: %s\n", storeUrl(entry));
+    debug(44, 3) ("peerSelectIcpPing: %s\n", entry->url());
 
     if (!request->flags.hierarchical && direct != DIRECT_NO)
         return 0;
@@ -157,7 +157,7 @@ peerSelect(HttpRequest * request,
     ps_state *psstate;
 
     if (entry)
-        debug(44, 3) ("peerSelect: %s\n", storeUrl(entry));
+        debug(44, 3) ("peerSelect: %s\n", entry->url());
     else
         debug(44, 3) ("peerSelect: %s\n", RequestMethodStr[request->method]);
 
@@ -216,7 +216,7 @@ peerSelectCallback(ps_state * psstate)
     void *cbdata;
 
     if (entry) {
-        debug(44, 3) ("peerSelectCallback: %s\n", storeUrl(entry));
+        debug(44, 3) ("peerSelectCallback: %s\n", entry->url());
 
         if (entry->ping_status == PING_WAITING)
             eventDelete(peerPingTimeout, psstate);
@@ -225,7 +225,7 @@ peerSelectCallback(ps_state * psstate)
     }
 
     if (fs == NULL) {
-        debug(44, 1) ("Failed to select source for '%s'\n", storeUrl(entry));
+        debug(44, 1) ("Failed to select source for '%s'\n", entry->url());
         debug(44, 1) ("  always_direct = %d\n", psstate->always_direct);
         debug(44, 1) ("   never_direct = %d\n", psstate->never_direct);
         debug(44, 1) ("       timedout = %d\n", psstate->ping.timedout);
@@ -584,7 +584,7 @@ peerPingTimeout(void *data)
     StoreEntry *entry = psstate->entry;
 
     if (entry)
-        debug(44, 3) ("peerPingTimeout: '%s'\n", storeUrl(entry));
+        debug(44, 3) ("peerPingTimeout: '%s'\n", entry->url());
 
     if (!cbdataReferenceValid(psstate->callback_data)) {
         /* request aborted */
@@ -654,7 +654,7 @@ peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
     icp_opcode op = header->getOpCode();
     debug(44, 3) ("peerHandleIcpReply: %s %s\n",
                   icp_opcode_str[op],
-                  storeUrl(psstate->entry));
+                  psstate->entry->url());
 #if USE_CACHE_DIGESTS && 0
     /* do cd lookup to count false misses */
 
@@ -697,7 +697,7 @@ peerHandleHtcpReply(peer * p, peer_t type, htcpReplyData * htcp, void *data)
     ps_state *psstate = (ps_state *)data;
     debug(44, 3) ("peerHandleHtcpReply: %s %s\n",
                   htcp->hit ? "HIT" : "MISS",
-                  storeUrl(psstate->entry));
+                  psstate->entry->url());
     psstate->ping.n_recv++;
 
     if (htcp->hit) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_repl_heap.cc,v 1.21 2006/08/21 00:50:47 robertc Exp $
+ * $Id: store_repl_heap.cc,v 1.22 2007/04/21 07:14:19 wessels Exp $
  *
  * DEBUG: section ?     HEAP based removal policies
  * AUTHOR: Henrik Nordstrom
@@ -232,7 +232,7 @@ heap_purgeNext(RemovalPurgeWalker * walker)
 
     entry = (StoreEntry *)heap_extractmin(heap->theHeap);
 
-    if (storeEntryLocked(entry)) {
+    if (entry->locked()) {
 
         entry->lock()
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_repl_lru.cc,v 1.20 2006/09/03 21:05:21 hno Exp $
+ * $Id: store_repl_lru.cc,v 1.21 2007/04/21 07:14:19 wessels Exp $
  *
  * DEBUG: section ?     LRU Removal policy
  * AUTHOR: Henrik Nordstrom
@@ -246,7 +246,7 @@ lru_purgeNext(RemovalPurgeWalker * walker)
     entry = (StoreEntry *) lru_node->node.data;
     dlinkDelete(&lru_node->node, &lru->list);
 
-    if (storeEntryLocked(entry)) {
+    if (entry->locked()) {
         /* Shit, it is locked. we can't return this one */
         walker->locked++;
         dlinkAddTail(entry, &lru_node->node, &lru->list);
@@ -300,7 +300,7 @@ lru_stats(RemovalPolicy * policy, StoreEntry * sentry)
     if (lru_node) {
         StoreEntry *entry = (StoreEntry *) lru_node->node.data;
 
-        if (storeEntryLocked(entry)) {
+        if (entry->locked()) {
             lru_node = (LruNode *) lru_node->node.next;
             goto again;
         }
@@ -1,5 +1,5 @@
 /*
- * $Id: stat.cc,v 1.403 2007/04/20 22:11:34 wessels Exp $
+ * $Id: stat.cc,v 1.404 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -349,7 +349,7 @@ statObjects(void *data)
         return;
     }
 
-    storeBuffer(state->sentry);
+    state->sentry->buffer();
     size_t statCount = 0;
     MemBuf mb;
     mb.init();
@@ -365,7 +365,7 @@ statObjects(void *data)
     }
 
     if (mb.size)
-        storeAppend(state->sentry, mb.buf, mb.size);
+        state->sentry->append(mb.buf, mb.size);
     mb.clean();
 
     eventAdd("statObjects", statObjects, state, 0.0, 1);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.608 2007/04/20 23:53:41 wessels Exp $
+ * $Id: store.cc,v 1.609 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -105,10 +105,7 @@ static storerepl_entry_t *storerepl_list = NULL;
  * local function prototypes
  */
 static void storeGetMemSpace(int);
-static void storeHashDelete(StoreEntry *);
-static void destroy_MemObject(StoreEntry *);
 static int getKeyCounter(void);
-static int storeKeepInMemory(const StoreEntry *);
 static OBJH storeCheckCachableStats;
 static EVH storeLateRelease;
 
@@ -375,13 +372,13 @@ StoreEntry::StoreEntry(const char *url, const char *log_url)
     swap_dirn = -1;
 }
 
-static void
-destroy_MemObject(StoreEntry * e)
+void
+StoreEntry::destroyMemObject()
 {
-    debugs(20, 3, HERE << "destroy mem_obj" << e->mem_obj);
-    storeSetMemStatus(e, NOT_IN_MEMORY);
-    MemObject *mem = e->mem_obj;
-    e->mem_obj = NULL;
+    debugs(20, 3, HERE << "destroyMemObject " << mem_obj);
+    setMemStatus(NOT_IN_MEMORY);
+    MemObject *mem = mem_obj;
+    mem_obj = NULL;
     delete mem;
 }
 
@@ -395,9 +392,9 @@ destroyStoreEntry(void *data)
     if (e == NullStoreEntry::getInstance())
         return;
 
-    destroy_MemObject(e);
+    e->destroyMemObject();
 
-    storeHashDelete(e);
+    e->hashDelete();
 
     assert(e->key == NULL);
 
@@ -407,20 +404,20 @@ destroyStoreEntry(void *data)
 /* ----- INTERFACE BETWEEN STORAGE MANAGER AND HASH TABLE FUNCTIONS --------- */
 
 void
-storeHashInsert(StoreEntry * e, const cache_key * key)
+StoreEntry::hashInsert(const cache_key * someKey)
 {
-    debug(20, 3) ("storeHashInsert: Inserting Entry %p key '%s'\n",
-                  e, storeKeyText(key));
-    e->key = storeKeyDup(key);
-    hash_join(store_table, e);
+    debug(20, 3) ("StoreEntry::hashInsert: Inserting Entry %p key '%s'\n",
+                  this, storeKeyText(someKey));
+    key = storeKeyDup(someKey);
+    hash_join(store_table, this);
 }
 
-static void
-storeHashDelete(StoreEntry * e)
+void
+StoreEntry::hashDelete()
 {
-    hash_remove_link(store_table, e);
-    storeKeyFree((const cache_key *)e->key);
-    e->key = NULL;
+    hash_remove_link(store_table, this);
+    storeKeyFree((const cache_key *)key);
+    key = NULL;
 }
 
 /* -------------------------------------------------------------------------- */
@@ -436,7 +433,7 @@ StoreEntry::purgeMem()
     debug(20, 3) ("StoreEntry::purgeMem: Freeing memory-copy of %s\n",
                   getMD5Text());
 
-    destroy_MemObject(this);
+    destroyMemObject();
 
     if (swap_status != SWAPOUT_DONE)
         release();
@@ -508,9 +505,9 @@ StoreEntry::unlock()
 
     if (EBIT_TEST(flags, RELEASE_REQUEST))
         this->release();
-    else if (storeKeepInMemory(this)) {
+    else if (keepInMemory()) {
         Store::Root().dereference(*this);
-        storeSetMemStatus(this, IN_MEMORY);
+        setMemStatus(IN_MEMORY);
         mem_obj->unlinkRequest();
     } else {
         Store::Root().dereference(*this);
@@ -617,7 +614,7 @@ StoreEntry::setPrivateKey()
         if (swap_filen > -1)
             storeDirSwapLog(this, SWAP_LOG_DEL);
 
-        storeHashDelete(this);
+        hashDelete();
     }
 
     if (mem_obj != NULL) {
@@ -629,7 +626,7 @@ StoreEntry::setPrivateKey()
 
     assert(hash_lookup(store_table, newkey) == NULL);
     EBIT_SET(flags, KEY_PRIVATE);
-    storeHashInsert(this, newkey);
+    hashInsert(newkey);
 }
 
 void
@@ -718,7 +715,7 @@ StoreEntry::setPublicKey()
 #endif
             pe->replaceHttpReply(rep);
 
-            storeTimestampsSet(pe);
+            pe->timestampsSet();
 
             pe->makePublic();
 
@@ -743,11 +740,11 @@ StoreEntry::setPublicKey()
     }
 
     if (key)
-        storeHashDelete(this);
+        hashDelete();
 
     EBIT_CLR(flags, KEY_PRIVATE);
 
-    storeHashInsert(this, newkey);
+    hashInsert(newkey);
 
     if (swap_filen > -1)
         storeDirSwapLog(this, SWAP_LOG_ADD);
@@ -779,13 +776,13 @@ storeCreateEntry(const char *url, const char *log_url, request_flags flags, meth
     }
 
     e->store_status = STORE_PENDING;
-    storeSetMemStatus(e, NOT_IN_MEMORY);
+    e->setMemStatus(NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_NONE;
     e->swap_filen = -1;
     e->swap_dirn = -1;
     e->refcount = 0;
     e->lastref = squid_curtime;
-    e->timestamp = -1;          /* set in storeTimestampsSet() */
+    e->timestamp = -1;          /* set in StoreEntry::timestampsSet() */
     e->ping_status = PING_NONE;
     EBIT_SET(e->flags, ENTRY_VALIDATED);
     return e;
@@ -844,13 +841,6 @@ StoreEntry::write (StoreIOBuffer writeBuffer)
     mem_obj->write (writeBuffer, storeWriteComplete, this);
 }
 
-/* Legacy call for appending data to a store entry */
-void
-storeAppend(StoreEntry * e, const char *buf, int len)
-{
-    e->append(buf, len);
-}
-
 /* Append incoming data from a primary server to an entry. */
 void
 StoreEntry::append(char const *buf, int len)
@@ -903,7 +893,7 @@ storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
     LOCAL_ARRAY(char, buf, 4096);
     buf[0] = '\0';
     vsnprintf(buf, 4096, fmt, vargs);
-    storeAppend(e, buf, strlen(buf));
+    e->append(buf, strlen(buf));
 }
 
 struct _store_check_cachable_hist
@@ -946,66 +936,62 @@ storeTooManyDiskFilesOpen(void)
     return 0;
 }
 
-static int
-storeCheckTooSmall(StoreEntry * e)
+int
+StoreEntry::checkTooSmall()
 {
-    MemObject * const mem = e->mem_obj;
-
-    if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
+    if (EBIT_TEST(flags, ENTRY_SPECIAL))
         return 0;
 
-    if (STORE_OK == e->store_status)
-        if (mem->object_sz < 0 ||
-                static_cast<size_t>(mem->object_sz)
+    if (STORE_OK == store_status)
+        if (mem_obj->object_sz < 0 ||
+                static_cast<size_t>(mem_obj->object_sz)
                 < Config.Store.minObjectSize)
             return 1;
-    if (e->getReply()
-            ->content_length > -1)
-        if (e->getReply()
-                ->content_length < (int) Config.Store.minObjectSize)
+    if (getReply()->content_length > -1)
+        if (getReply()->content_length < (int) Config.Store.minObjectSize)
             return 1;
     return 0;
 }
 
 int
-storeCheckCachable(StoreEntry * e)
+StoreEntry::checkCachable()
 {
 #if CACHE_ALL_METHODS
 
-    if (e->mem_obj->method != METHOD_GET) {
-        debug(20, 2) ("storeCheckCachable: NO: non-GET method\n");
+    if (mem_obj->method != METHOD_GET) {
+        debug(20, 2) ("StoreEntry::checkCachable: NO: non-GET method\n");
         store_check_cachable_hist.no.non_get++;
     } else
 #endif
-        if (e->store_status == STORE_OK && EBIT_TEST(e->flags, ENTRY_BAD_LENGTH)) {
-            debug(20, 2) ("storeCheckCachable: NO: wrong content-length\n");
+        if (store_status == STORE_OK && EBIT_TEST(flags, ENTRY_BAD_LENGTH)) {
+            debug(20, 2) ("StoreEntry::checkCachable: NO: wrong content-length\n");
             store_check_cachable_hist.no.wrong_content_length++;
-        } else if (!EBIT_TEST(e->flags, ENTRY_CACHABLE)) {
-            debug(20, 2) ("storeCheckCachable: NO: not cachable\n");
+        } else if (!EBIT_TEST(flags, ENTRY_CACHABLE)) {
+            debug(20, 2) ("StoreEntry::checkCachable: NO: not cachable\n");
             store_check_cachable_hist.no.not_entry_cachable++;
-        } else if (EBIT_TEST(e->flags, ENTRY_NEGCACHED)) {
-            debug(20, 3) ("storeCheckCachable: NO: negative cached\n");
+        } else if (EBIT_TEST(flags, ENTRY_NEGCACHED)) {
+            debug(20, 3) ("StoreEntry::checkCachable: NO: negative cached\n");
             store_check_cachable_hist.no.negative_cached++;
             return 0;           /* avoid release call below */
-        } else if ((e->getReply()->content_length > 0 &&
-                    static_cast<size_t>(e->getReply()->content_length)
+        } else if ((getReply()->content_length > 0 &&
+                    static_cast<size_t>(getReply()->content_length)
                     > Config.Store.maxObjectSize) ||
-                   static_cast<size_t>(e->mem_obj->endOffset()) > Config.Store.maxObjectSize) {
-            debug(20, 2) ("storeCheckCachable: NO: too big\n");
+                   static_cast<size_t>(mem_obj->endOffset()) > Config.Store.maxObjectSize) {
+            debug(20, 2) ("StoreEntry::checkCachable: NO: too big\n");
             store_check_cachable_hist.no.too_big++;
-        } else if (e->getReply()->content_length > (int) Config.Store.maxObjectSize) {
+        } else if (getReply()->content_length > (int) Config.Store.maxObjectSize) {
             debug(20, 2)
-            ("storeCheckCachable: NO: too big\n");
+            ("StoreEntry::checkCachable: NO: too big\n");
             store_check_cachable_hist.no.too_big++;
-        } else if (storeCheckTooSmall(e)) {
+        } else if (checkTooSmall()) {
             debug(20, 2)
-            ("storeCheckCachable: NO: too small\n");
+            ("StoreEntry::checkCachable: NO: too small\n");
             store_check_cachable_hist.no.too_small++;
-        } else if (EBIT_TEST(e->flags, KEY_PRIVATE)) {
+        } else if (EBIT_TEST(flags, KEY_PRIVATE)) {
             debug(20, 3)
-            ("storeCheckCachable: NO: private key\n");
+            ("StoreEntry::checkCachable: NO: private key\n");
             store_check_cachable_hist.no.private_key++;
-        } else if (e->swap_status != SWAPOUT_NONE) {
+        } else if (swap_status != SWAPOUT_NONE) {
             /*
              * here we checked the swap_status because the remaining
              * cases are only relevant only if we haven't started swapping
@@ -1014,24 +1000,24 @@ storeCheckCachable(StoreEntry * e)
             return 1;
         } else if (storeTooManyDiskFilesOpen()) {
             debug(20, 2)
-            ("storeCheckCachable: NO: too many disk files open\n");
+            ("StoreEntry::checkCachable: NO: too many disk files open\n");
             store_check_cachable_hist.no.too_many_open_files++;
         } else if (fdNFree() < RESERVED_FD) {
             debug(20, 2)
-            ("storeCheckCachable: NO: too many FD's open\n");
+            ("StoreEntry::checkCachable: NO: too many FD's open\n");
             store_check_cachable_hist.no.too_many_open_fds++;
         } else {
             store_check_cachable_hist.yes.Default++;
             return 1;
         }
 
-    e->releaseRequest();
+    releaseRequest();
     /* StoreEntry::releaseRequest() cleared ENTRY_CACHABLE */
     return 0;
 }
 
-static void
-storeCheckCachableStats(StoreEntry * sentry)
+void
+storeCheckCachableStats(StoreEntry *sentry)
 {
     storeAppendPrintf(sentry, "Category\t Count\n");
 
@@ -1126,7 +1112,7 @@ StoreEntry::abort()
 
     EBIT_SET(flags, ENTRY_ABORTED);
 
-    storeSetMemStatus(this, NOT_IN_MEMORY);
+    setMemStatus(NOT_IN_MEMORY);
 
     store_status = STORE_OK;
 
@@ -1266,7 +1252,7 @@ StoreEntry::release()
     /* If, for any reason we can't discard this object because of an
      * outstanding request, mark it for pending release */
 
-    if (storeEntryLocked(this)) {
+    if (locked()) {
         expireNow();
         debug(20, 3) ("storeRelease: Only setting RELEASE_REQUEST bit\n");
         releaseRequest();
@@ -1278,7 +1264,7 @@ StoreEntry::release()
         setPrivateKey();
 
         if (mem_obj)
-            destroy_MemObject(this);
+            destroyMemObject();
 
         if (swap_filen > -1) {
             /*
@@ -1315,7 +1301,7 @@ StoreEntry::release()
 
     }
 
-    storeSetMemStatus(this, NOT_IN_MEMORY);
+    setMemStatus(NOT_IN_MEMORY);
     destroyStoreEntry(static_cast<hash_link *>(this));
     PROF_stop(storeRelease);
 }
@@ -1350,22 +1336,22 @@ storeLateRelease(void *unused)
 
 /* return 1 if a store entry is locked */
 int
-storeEntryLocked(const StoreEntry * e)
+StoreEntry::locked() const
 {
-    if (e->lock_count)
+    if (lock_count)
         return 1;
 
-    if (e->swap_status == SWAPOUT_WRITING)
+    if (swap_status == SWAPOUT_WRITING)
         return 1;
 
-    if (e->store_status == STORE_PENDING)
+    if (store_status == STORE_PENDING)
         return 1;
 
     /*
      * SPECIAL, PUBLIC entries should be "locked"
      */
-    if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
-        if (!EBIT_TEST(e->flags, KEY_PRIVATE))
+    if (EBIT_TEST(flags, ENTRY_SPECIAL))
+        if (!EBIT_TEST(flags, KEY_PRIVATE))
             return 1;
 
     return 0;
@@ -1459,30 +1445,28 @@ storeConfigure(void)
     store_pages_max = Config.memMaxSize / SM_PAGE_SIZE;
 }
 
-static int
-storeKeepInMemory(const StoreEntry * e)
+int
+StoreEntry::keepInMemory() const
 {
-    MemObject *mem = e->mem_obj;
-
-    if (mem == NULL)
+    if (mem_obj == NULL)
         return 0;
 
-    if (mem->data_hdr.size() == 0)
+    if (mem_obj->data_hdr.size() == 0)
         return 0;
 
-    return mem->inmem_lo == 0;
+    return mem_obj->inmem_lo == 0;
 }
 
 int
-storeCheckNegativeHit(StoreEntry * e)
+StoreEntry::checkNegativeHit() const
 {
-    if (!EBIT_TEST(e->flags, ENTRY_NEGCACHED))
+    if (!EBIT_TEST(flags, ENTRY_NEGCACHED))
         return 0;
 
-    if (e->expires <= squid_curtime)
+    if (expires <= squid_curtime)
         return 0;
 
-    if (e->store_status != STORE_OK)
+    if (store_status != STORE_OK)
         return 0;
 
     return 1;
@@ -1519,25 +1503,25 @@ expiresMoreThan(time_t expires, time_t when)
 }
 
 int
-storeEntryValidToSend(StoreEntry * e)
+StoreEntry::validToSend() const
 {
-    if (EBIT_TEST(e->flags, RELEASE_REQUEST))
+    if (EBIT_TEST(flags, RELEASE_REQUEST))
         return 0;
 
-    if (EBIT_TEST(e->flags, ENTRY_NEGCACHED))
-        if (e->expires <= squid_curtime)
+    if (EBIT_TEST(flags, ENTRY_NEGCACHED))
+        if (expires <= squid_curtime)
             return 0;
 
-    if (EBIT_TEST(e->flags, ENTRY_ABORTED))
+    if (EBIT_TEST(flags, ENTRY_ABORTED))
         return 0;
 
     return 1;
 }
 
 void
-storeTimestampsSet(StoreEntry * entry)
+StoreEntry::timestampsSet()
 {
-    const HttpReply *reply = entry->getReply();
+    const HttpReply *reply = getReply();
     time_t served_date = reply->date;
     int age = reply->header.getInt(HDR_AGE);
     /*
@@ -1564,122 +1548,111 @@ storeTimestampsSet(StoreEntry * entry)
             served_date = squid_curtime - age;
 
     if (reply->expires > 0 && reply->date > -1)
-	entry->expires = served_date + (reply->expires - reply->date);
+	expires = served_date + (reply->expires - reply->date);
     else
-	entry->expires = reply->expires;
+	expires = reply->expires;
 
-    entry->lastmod = reply->last_modified;
+    lastmod = reply->last_modified;
 
-    entry->timestamp = served_date;
+    timestamp = served_date;
 }
 
 void
-storeRegisterAbort(StoreEntry * e, STABH * cb, void *data)
+StoreEntry::registerAbort(STABH * cb, void *data)
 {
-    MemObject *mem = e->mem_obj;
-    assert(mem);
-    assert(mem->abort.callback == NULL);
-    mem->abort.callback = cb;
-    mem->abort.data = data;
+    assert(mem_obj);
+    assert(mem_obj->abort.callback == NULL);
+    mem_obj->abort.callback = cb;
+    mem_obj->abort.data = data;
 }
 
 void
-storeUnregisterAbort(StoreEntry * e)
+StoreEntry::unregisterAbort()
 {
-    MemObject *mem = e->mem_obj;
-    assert(mem);
-    mem->abort.callback = NULL;
+    assert(mem_obj);
+    mem_obj->abort.callback = NULL;
 }
 
 void
-storeEntryDump(const StoreEntry * e, int l)
-{
-    debug(20, l) ("StoreEntry->key: %s\n", e->getMD5Text());
-    debug(20, l) ("StoreEntry->next: %p\n", e->next);
-    debug(20, l) ("StoreEntry->mem_obj: %p\n", e->mem_obj);
-    debug(20, l) ("StoreEntry->timestamp: %d\n", (int) e->timestamp);
-    debug(20, l) ("StoreEntry->lastref: %d\n", (int) e->lastref);
-    debug(20, l) ("StoreEntry->expires: %d\n", (int) e->expires);
-    debug(20, l) ("StoreEntry->lastmod: %d\n", (int) e->lastmod);
-    debug(20, l) ("StoreEntry->swap_file_sz: %d\n", (int) e->swap_file_sz);
-    debug(20, l) ("StoreEntry->refcount: %d\n", e->refcount);
-    debug(20, l) ("StoreEntry->flags: %s\n", storeEntryFlags(e));
-    debug(20, l) ("StoreEntry->swap_dirn: %d\n", (int) e->swap_dirn);
-    debug(20, l) ("StoreEntry->swap_filen: %d\n", (int) e->swap_filen);
-    debug(20, l) ("StoreEntry->lock_count: %d\n", (int) e->lock_count);
-    debug(20, l) ("StoreEntry->mem_status: %d\n", (int) e->mem_status);
-    debug(20, l) ("StoreEntry->ping_status: %d\n", (int) e->ping_status);
-    debug(20, l) ("StoreEntry->store_status: %d\n", (int) e->store_status);
-    debug(20, l) ("StoreEntry->swap_status: %d\n", (int) e->swap_status);
+StoreEntry::dump(int l) const
+{
+    debug(20, l) ("StoreEntry->key: %s\n", getMD5Text());
+    debug(20, l) ("StoreEntry->next: %p\n", next);
+    debug(20, l) ("StoreEntry->mem_obj: %p\n", mem_obj);
+    debug(20, l) ("StoreEntry->timestamp: %d\n", (int) timestamp);
+    debug(20, l) ("StoreEntry->lastref: %d\n", (int) lastref);
+    debug(20, l) ("StoreEntry->expires: %d\n", (int) expires);
+    debug(20, l) ("StoreEntry->lastmod: %d\n", (int) lastmod);
+    debug(20, l) ("StoreEntry->swap_file_sz: %d\n", (int) swap_file_sz);
+    debug(20, l) ("StoreEntry->refcount: %d\n", refcount);
+    debug(20, l) ("StoreEntry->flags: %s\n", storeEntryFlags(this));
+    debug(20, l) ("StoreEntry->swap_dirn: %d\n", (int) swap_dirn);
+    debug(20, l) ("StoreEntry->swap_filen: %d\n", (int) swap_filen);
+    debug(20, l) ("StoreEntry->lock_count: %d\n", (int) lock_count);
+    debug(20, l) ("StoreEntry->mem_status: %d\n", (int) mem_status);
+    debug(20, l) ("StoreEntry->ping_status: %d\n", (int) ping_status);
+    debug(20, l) ("StoreEntry->store_status: %d\n", (int) store_status);
+    debug(20, l) ("StoreEntry->swap_status: %d\n", (int) swap_status);
 }
 
 /*
  * NOTE, this function assumes only two mem states
  */
 void
-storeSetMemStatus(StoreEntry * e, mem_status_t new_status)
+StoreEntry::setMemStatus(mem_status_t new_status)
 {
-    MemObject *mem = e->mem_obj;
-
-    if (new_status == e->mem_status)
+    if (new_status == mem_status)
         return;
 
-    assert(mem != NULL);
+    assert(mem_obj != NULL);
 
     if (new_status == IN_MEMORY) {
-        assert(mem->inmem_lo == 0);
+        assert(mem_obj->inmem_lo == 0);
 
-        if (EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-            debug(20, 4) ("storeSetMemStatus: not inserting special %s into policy\n",
-                          mem->url);
+        if (EBIT_TEST(flags, ENTRY_SPECIAL)) {
+            debug(20, 4) ("StoreEntry::setMemStatus: not inserting special %s into policy\n",
+                          mem_obj->url);
         } else {
-            mem_policy->Add(mem_policy, e, &mem->repl);
-            debug(20, 4) ("storeSetMemStatus: inserted mem node %s\n",
-                          mem->url);
+            mem_policy->Add(mem_policy, this, &mem_obj->repl);
+            debug(20, 4) ("StoreEntry::setMemStatus: inserted mem node %s\n",
+                          mem_obj->url);
         }
 
         hot_obj_count++;
     } else {
-        if (EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-            debug(20, 4) ("storeSetMemStatus: special entry %s\n",
-                          mem->url);
+        if (EBIT_TEST(flags, ENTRY_SPECIAL)) {
+            debug(20, 4) ("StoreEntry::setMemStatus: special entry %s\n",
+                          mem_obj->url);
         } else {
-            mem_policy->Remove(mem_policy, e, &mem->repl);
-            debug(20, 4) ("storeSetMemStatus: removed mem node %s\n",
-                          mem->url);
+            mem_policy->Remove(mem_policy, this, &mem_obj->repl);
+            debug(20, 4) ("StoreEntry::setMemStatus: removed mem node %s\n",
+                          mem_obj->url);
         }
 
         hot_obj_count--;
     }
 
-    e->mem_status = new_status;
+    mem_status = new_status;
 }
 
 const char *
-storeUrl(const StoreEntry * e)
+StoreEntry::url() const
 {
-    if (e == NULL)
+    if (this == NULL)
         return "[null_entry]";
-    else if (e->mem_obj == NULL)
+    else if (mem_obj == NULL)
         return "[null_mem_obj]";
     else
-        return e->mem_obj->url;
+        return mem_obj->url;
 }
 
 void
-storeCreateMemObject(StoreEntry * e, const char *url, const char *log_url)
+StoreEntry::createMemObject(const char *url, const char *log_url)
 {
-    if (e->mem_obj)
+    if (mem_obj)
         return;
 
-    e->mem_obj = new MemObject(url, log_url);
-}
-
-/* DEPRECATED: please use entry->buffer() */
-void
-storeBuffer(StoreEntry * e)
-{
-    e->buffer();
+    mem_obj = new MemObject(url, log_url);
 }
 
 /* this just sets DELAY_SENDING */
@@ -1689,12 +1662,6 @@ StoreEntry::buffer()
     EBIT_SET(flags, DELAY_SENDING);
 }
 
-/* DEPRECATED - please use e->flush(); */
-void storeBufferFlush(StoreEntry * e)
-{
-    e->flush();
-}
-
 /* this just clears DELAY_SENDING and Invokes the handlers */
 void
 StoreEntry::flush()
@@ -1730,15 +1697,14 @@ StoreEntry::getReply () const
 }
 
 void
-storeEntryReset(StoreEntry * e)
+StoreEntry::reset()
 {
-    MemObject *mem = e->mem_obj;
-    assert (mem);
-    debug(20, 3) ("storeEntryReset: %s\n", storeUrl(e));
-    mem->reset();
-    HttpReply *rep = (HttpReply *) e->getReply();       // bypass const
+    assert (mem_obj);
+    debug(20, 3) ("StoreEntry::reset: %s\n", url());
+    mem_obj->reset();
+    HttpReply *rep = (HttpReply *) getReply();       // bypass const
     rep->reset();
-    e->expires = e->lastmod = e->timestamp = -1;
+    expires = lastmod = timestamp = -1;
 }
 
 /*
@@ -1826,7 +1792,7 @@ storeSwapFileNumberSet(StoreEntry * e, sfileno filn)
 void
 StoreEntry::replaceHttpReply(HttpReply *rep)
 {
-    debug(20, 3) ("StoreEntry::replaceHttpReply: %s\n", storeUrl(this));
+    debug(20, 3) ("StoreEntry::replaceHttpReply: %s\n", url());
     Packer p;
 
     if (!mem_obj) {
@@ -1869,7 +1835,7 @@ bool
 StoreEntry::swapoutPossible()
 {
     /* should we swap something out to disk? */
-    debug(20, 7) ("storeSwapOut: %s\n", storeUrl(this));
+    debug(20, 7) ("storeSwapOut: %s\n", url());
     debug(20, 7) ("storeSwapOut: store_status = %s\n",
                   storeStatusStr[store_status]);
 
@@ -1880,7 +1846,7 @@ StoreEntry::swapoutPossible()
     }
 
     if (EBIT_TEST(flags, ENTRY_SPECIAL)) {
-        debug(20, 3) ("storeSwapOut: %s SPECIAL\n", storeUrl(this));
+        debug(20, 3) ("storeSwapOut: %s SPECIAL\n", url());
         return false;
     }
 
@@ -1918,7 +1884,7 @@ StoreEntry::modifiedSince(HttpRequest * request) const
     if (mod_time < 0)
         mod_time = timestamp;
 
-    debug(88, 3) ("modifiedSince: '%s'\n", storeUrl(this));
+    debug(88, 3) ("modifiedSince: '%s'\n", url());
 
     debug(88, 3) ("modifiedSince: mod_time = %ld\n", (long int) mod_time);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_digest.cc,v 1.72 2007/04/20 23:53:42 wessels Exp $
+ * $Id: store_digest.cc,v 1.73 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -168,7 +168,7 @@ storeDigestDel(const StoreEntry * entry)
         if (!cacheDigestTest(store_digest,  (const cache_key *)entry->key)) {
             sd_stats.del_lost_count++;
             debug(71, 6) ("storeDigestDel: lost entry, key: %s url: %s\n",
-                          entry->getMD5Text(), storeUrl(entry));
+                          entry->getMD5Text(), entry->url());
         } else {
             sd_stats.del_count++;
             cacheDigestDel(store_digest,  (const cache_key *)entry->key);
@@ -221,7 +221,7 @@ storeDigestAddable(const StoreEntry * e)
     debug(71, 6) ("storeDigestAddable: checking entry, key: %s\n",
                   e->getMD5Text());
 
-    /* check various entry flags (mimics storeCheckCachable XXX) */
+    /* check various entry flags (mimics StoreEntry::checkCachable XXX) */
 
     if (!EBIT_TEST(e->flags, ENTRY_CACHABLE)) {
         debug(71, 6) ("storeDigestAddable: NO: not cachable\n");
@@ -432,10 +432,10 @@ storeDigestRewriteResume(void)
                     squid_curtime, squid_curtime + Config.digest.rewrite_period);
     debug(71, 3) ("storeDigestRewrite: entry expires on %ld (%+d)\n",
                   (long int) rep->expires, (int) (rep->expires - squid_curtime));
-    storeBuffer(e);
+    e->buffer();
     e->replaceHttpReply(rep);
     storeDigestCBlockSwapOut(e);
-    storeBufferFlush(e);
+    e->flush();
     eventAdd("storeDigestSwapOutStep", storeDigestSwapOutStep, sd_state.rewrite_lock, 0.0, 1, false);
 }
 
@@ -445,7 +445,7 @@ storeDigestRewriteFinish(StoreEntry * e)
 {
     assert(e == sd_state.rewrite_lock);
     e->complete();
-    storeTimestampsSet(e);
+    e->timestampsSet();
     debug(71, 2) ("storeDigestRewriteFinish: digest expires at %ld (%+d)\n",
                   (long int) e->expires, (int) (e->expires - squid_curtime));
     /* is this the write order? @?@ */
@@ -474,7 +474,7 @@ storeDigestSwapOutStep(void *data)
     if ((size_t)(sd_state.rewrite_offset + chunk_size) > store_digest->mask_size)
         chunk_size = store_digest->mask_size - sd_state.rewrite_offset;
 
-    storeAppend(e, store_digest->mask + sd_state.rewrite_offset, chunk_size);
+    e->append(store_digest->mask + sd_state.rewrite_offset, chunk_size);
 
     debugs(71, 3, "storeDigestSwapOutStep: size: " << store_digest->mask_size <<
            " offset: " << sd_state.rewrite_offset << " chunk: " <<
@@ -502,7 +502,7 @@ storeDigestCBlockSwapOut(StoreEntry * e)
     sd_state.cblock.bits_per_entry = (unsigned char)
                                      Config.digest.bits_per_entry;
     sd_state.cblock.hash_func_count = (unsigned char) CacheDigestHashFuncCount;
-    storeAppend(e, (char *) &sd_state.cblock, sizeof(sd_state.cblock));
+    e->append((char *) &sd_state.cblock, sizeof(sd_state.cblock));
 }
 
 /* calculates digest capacity */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapmeta.cc,v 1.23 2006/05/20 13:15:14 hno Exp $
+ * $Id: store_swapmeta.cc,v 1.24 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -63,7 +63,7 @@ storeSwapMetaBuild(StoreEntry * e)
     const char *vary;
     assert(e->mem_obj != NULL);
     assert(e->swap_status == SWAPOUT_WRITING);
-    url = storeUrl(e);
+    url = e->url();
     debug(20, 3) ("storeSwapMetaBuild: %s\n", url);
     tlv *t = StoreMeta::Factory (STORE_META_KEY,MD5_DIGEST_CHARS, e->key);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapout.cc,v 1.114 2007/04/20 23:53:42 wessels Exp $
+ * $Id: store_swapout.cc,v 1.115 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapout Functions
  * AUTHOR: Duane Wessels
@@ -57,7 +57,7 @@ storeSwapOutStart(StoreEntry * e)
      * metadata there is to store
      */
     debug(20, 5) ("storeSwapOutStart: Begin SwapOut '%s' to dirno %d, fileno %08X\n",
-                  storeUrl(e), e->swap_dirn, e->swap_filen);
+                  e->url(), e->swap_dirn, e->swap_filen);
     e->swap_status = SWAPOUT_WRITING;
     /* If we start swapping out objects with OutOfBand Metadata,
      * then this code needs changing
@@ -234,7 +234,7 @@ StoreEntry::swapOut()
 #if SIZEOF_OFF_T == 4
 
     if (mem_obj->endOffset() > 0x7FFF0000) {
-        debug(20, 0) ("WARNING: preventing off_t overflow for %s\n", storeUrl(this));
+        debug(20, 0) ("WARNING: preventing off_t overflow for %s\n", url());
         abort();
         return;
     }
@@ -275,7 +275,7 @@ StoreEntry::swapOut()
         assert(mem_obj->swapout.sio == NULL);
         assert(mem_obj->inmem_lo == 0);
 
-        if (storeCheckCachable(this))
+        if (checkCachable())
             storeSwapOutStart(this);
         else
             return;
@@ -351,12 +351,12 @@ storeSwapOutFileClosed(void *data, int errflag, StoreIOState::Pointer self)
     } else {
         /* swapping complete */
         debug(20, 3) ("storeSwapOutFileClosed: SwapOut complete: '%s' to %d, %08X\n",
-                      storeUrl(e), e->swap_dirn, e->swap_filen);
+                      e->url(), e->swap_dirn, e->swap_filen);
         e->swap_file_sz = e->objectLen() + mem->swap_hdr_sz;
         e->swap_status = SWAPOUT_DONE;
         e->store()->updateSize(e->swap_file_sz, 1);
 
-        if (storeCheckCachable(e)) {
+        if (e->checkCachable()) {
             storeLog(STORE_LOG_SWAPOUT, e);
             storeDirSwapLog(e, SWAP_LOG_ADD);
         }
@@ -1,5 +1,5 @@
 /*
- * $Id: stub_store.cc,v 1.2 2006/04/25 07:13:34 robertc Exp $
+ * $Id: stub_store.cc,v 1.3 2007/04/21 07:14:20 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Robert Collins
@@ -54,24 +54,6 @@ extern "C" void
     fatal("Not implemented");
 }
 
-extern "C" void
-    storeBuffer(StoreEntry * e)
-{
-    fatal("Not implemented");
-}
-
-extern "C" void
-    storeBufferFlush(StoreEntry * e)
-{
-    fatal("Not implemented");
-}
-
-extern "C" void
-    storeAppend(StoreEntry * e, const char *buf, int len)
-{
-    fatal("Not implemented");
-}
-
 #ifndef _USE_INLINE_
 #include "Store.cci"
 #endif
@@ -198,7 +198,7 @@ testCoss::testCossSearch()
 
         pe->setPublicKey();
 
-        storeBuffer(pe);
+        pe->buffer();
         /* TODO: remove this when the metadata is separated */
         {
             Packer p;
@@ -207,8 +207,8 @@ testCoss::testCossSearch()
             packerClean(&p);
         }
 
-        storeBufferFlush(pe);
-        storeTimestampsSet(pe);
+        pe->flush();
+        pe->timestampsSet();
         pe->complete();
         storeSwapOut(pe);
         CPPUNIT_ASSERT(pe->swap_dirn == 0);
@@ -166,7 +166,7 @@ testNull::testNullSearch()
 
         pe->setPublicKey();
 
-        storeBuffer(pe);
+        pe->buffer();
         /* TODO: remove this when the metadata is separated */
         {
             Packer p;
@@ -175,8 +175,8 @@ testNull::testNullSearch()
             packerClean(&p);
         }
 
-        storeBufferFlush(pe);
-        storeTimestampsSet(pe);
+        pe->flush();
+        pe->timestampsSet();
         pe->complete();
         pe->swapOut();
         /* Null does not accept store entries */
@@ -86,7 +86,7 @@ addedEntry(StorePointer hashStore,
 {
     StoreEntry *e = new StoreEntry();
     e->store_status = STORE_OK;
-    storeSetMemStatus(e, NOT_IN_MEMORY);
+    e->setMemStatus(NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_DONE; /* bogus haha */
     e->swap_filen = 0; /* garh - lower level*/
     e->swap_dirn = -1;
@@ -109,7 +109,7 @@ addedEntry(StorePointer hashStore,
     EBIT_CLR(e->flags, KEY_PRIVATE);
     e->ping_status = PING_NONE;
     EBIT_CLR(e->flags, ENTRY_VALIDATED);
-    storeHashInsert(e, (const cache_key *)name.buf());	/* do it after we clear KEY_PRIVATE */
+    e->hashInsert((const cache_key *)name.buf());	/* do it after we clear KEY_PRIVATE */
     return e;
 }
 
@@ -67,7 +67,7 @@ addedEntry(StorePointer hashStore,
 {
     StoreEntry *e = new StoreEntry();
     e->store_status = STORE_OK;
-    storeSetMemStatus(e, NOT_IN_MEMORY);
+    e->setMemStatus(NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_DONE; /* bogus haha */
     e->swap_filen = 0; /* garh - lower level*/
     e->swap_dirn = -1;
@@ -90,7 +90,7 @@ addedEntry(StorePointer hashStore,
     EBIT_CLR(e->flags, KEY_PRIVATE);
     e->ping_status = PING_NONE;
     EBIT_CLR(e->flags, ENTRY_VALIDATED);
-    storeHashInsert(e, (const cache_key *)name.buf());	/* do it after we clear KEY_PRIVATE */
+    e->hashInsert((const cache_key *)name.buf());	/* do it after we clear KEY_PRIVATE */
     return e;
 }
 
@@ -146,7 +146,7 @@ testUfs::testUfsSearch()
 
         pe->setPublicKey();
 
-        storeBuffer(pe);
+        pe->buffer();
         /* TODO: remove this when the metadata is separated */
         {
             Packer p;
@@ -155,8 +155,8 @@ testUfs::testUfsSearch()
             packerClean(&p);
         }
 
-        storeBufferFlush(pe);
-        storeTimestampsSet(pe);
+        pe->flush();
+        pe->timestampsSet();
         pe->complete();
         pe->swapOut();
         CPPUNIT_ASSERT(pe->swap_dirn == 0);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: urn.cc,v 1.103 2006/08/25 15:22:34 serassio Exp $
+ * $Id: urn.cc,v 1.104 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 52    URN Parsing
  * AUTHOR: Kostas Anagnostakis
@@ -242,7 +242,7 @@ UrnState::setUriResFromRequest(HttpRequest *r)
 void
 UrnState::start(HttpRequest * r, StoreEntry * e)
 {
-    debug(52, 3) ("urnStart: '%s'\n", storeUrl(e));
+    debug(52, 3) ("urnStart: '%s'\n", e->url());
     entry = e;
     request = HTTPMSGLOCK(r);
 
@@ -369,7 +369,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
 
     if (0 == k) {
         debug(52, 1) ("urnHandleReply: didn't find end-of-headers for %s\n",
-                      storeUrl(e));
+                      e->url());
         goto error;
     }
 
@@ -382,7 +382,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
     if (rep->sline.status != HTTP_OK) {
         debug(52, 3) ("urnHandleReply: failed.\n");
         err = errorCon(ERR_URN_RESOLVE, HTTP_NOT_FOUND, urnState->request);
-        err->url = xstrdup(storeUrl(e));
+        err->url = xstrdup(e->url());
         errorAppendEntry(e, err);
         delete rep;
         goto error;
@@ -401,22 +401,22 @@ urnHandleReply(void *data, StoreIOBuffer result)
     debug(53, 3) ("urnFindMinRtt: Counted %d URLs\n", i);
 
     if (urls == NULL) {		/* unkown URN error */
-        debug(52, 3) ("urnTranslateDone: unknown URN %s\n", storeUrl(e));
+        debug(52, 3) ("urnTranslateDone: unknown URN %s\n", e->url());
         err = errorCon(ERR_URN_RESOLVE, HTTP_NOT_FOUND, urnState->request);
-        err->url = xstrdup(storeUrl(e));
+        err->url = xstrdup(e->url());
         errorAppendEntry(e, err);
         goto error;
     }
 
     min_u = urnFindMinRtt(urls, urnState->request->method, NULL);
     qsort(urls, urlcnt, sizeof(*urls), url_entry_sort);
-    storeBuffer(e);
+    e->buffer();
     mb = new MemBuf;
     mb->init();
     mb->Printf( "<TITLE>Select URL for %s</TITLE>\n"
                 "<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n"
                 "<H2>Select URL for %s</H2>\n"
-                "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", storeUrl(e), storeUrl(e));
+                "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", e->url(), e->url());
 
     for (i = 0; i < urlcnt; i++) {
         u = &urls[i];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: whois.cc,v 1.39 2007/04/20 23:53:42 wessels Exp $
+ * $Id: whois.cc,v 1.40 2007/04/21 07:14:15 wessels Exp $
  *
  * DEBUG: section 75    WHOIS protocol
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -113,7 +113,7 @@ static void
 whoisTimeout(int fd, void *data)
 {
     WhoisState *p = (WhoisState *)data;
-    debug(75, 1) ("whoisTimeout: %s\n", storeUrl(p->entry));
+    debug(75, 1) ("whoisTimeout: %s\n", p->entry->url());
     whoisClose(fd, p);
 }
 
@@ -128,7 +128,7 @@ void
 WhoisState::setReplyToOK(StoreEntry *entry)
 {
     HttpReply *reply = new HttpReply;
-    storeBuffer(entry);
+    entry->buffer();
     HttpVersion version(1, 0);
     reply->setHeaders(version, HTTP_OK, "Gatewaying", "text/plain", -1, -1, -2);
     entry->replaceHttpReply(reply);
@@ -160,9 +160,9 @@ WhoisState::readReply (int fd, char *buf, size_t len, comm_err_t flag, int xerrn
         /* No range support, we always grab it all */
         dataWritten = 1;
 
-        storeAppend(entry, buf, len);
+        entry->append(buf, len);
 
-        storeBufferFlush(entry);
+        entry->flush();
 
         do_next_read = 1;
     } else if (flag != COMM_OK || len < 0) {
@@ -180,15 +180,15 @@ WhoisState::readReply (int fd, char *buf, size_t len, comm_err_t flag, int xerrn
             do_next_read = 0;
         }
     } else {
-        storeTimestampsSet(entry);
-        storeBufferFlush(entry);
+        entry->timestampsSet();
+        entry->flush();
 
         if (!EBIT_TEST(entry->flags, RELEASE_REQUEST))
             entry->setPublicKey();
 
         fwd->complete();
 
-        debug(75, 3) ("whoisReadReply: Done: %s\n", storeUrl(entry));
+        debug(75, 3) ("whoisReadReply: Done: %s\n", entry->url());
 
         comm_close(fd);
 