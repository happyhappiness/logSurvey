@@ -1,3 +1,19 @@
+Changes to squid-3.2.0.8 (30 May 2011):
+
+	- Bug 3214: "helperHandleRead: unexpected read from ssl_crtd" errors.
+	- Bug 3043: Properly detect Iphlpapi.h on windows
+	- Bug 2055: Honor ICAP Max-Connections
+	- Fix NTLM/Negotiate reply auth PASSTHRU to peers
+	- Support SSL SNI to origin servers
+	- Add %EXT_LOG and %EXT_TAG external_acl_type format options
+	- Add %b tag for proxy listening port display in error pages
+	- Optimize base64 encoding/decoding
+	- Require libcap before enabling netfilter MARK support
+	- Require libtool 2.2
+	- Bundle pkg.m4 from pkg-config 0.25 for OS without pkg-config
+	- ... and all bug fixes and updates from 3.1.12.2
+	- ... and some documentation and code polishing
+
 Changes to squid-3.2.0.7 (19 Apr 2011):
 
 	- Regression fix: NTLM and Negotiate auth assertion "RefCountCount() == 2"
@@ -164,6 +180,26 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.12.2 (30 May 2011):
+
+	- Bug 3226: Tags from external ACLs do not correctly expire
+	- Bug 3215: Malformed IPv6 DNS reverse lookup
+	- Bug 3209: ssl-bumped requests forwarded unencrypted to the parent proxies/caches
+	- Bug 3205: SSL-bump starts then hangs
+	- Bug 3178: gcc-4.6 complains unused variables
+	- Bug 3122: Unknown record type in WCCPv2 Packet (6)
+	- Bug 2965 (partial): Compile errors on MinGW
+	- Fix to only ssl-bump CONNECT requests if they are about to be tunneled
+	- Fix cache manager display of -i/+i in regex ACL config display
+	- Fix cache manager display of cache_peer options userhash and sourcehash 
+	- Fix URL re-writer loosing many transaction details
+	- Fix always-true comparison in ICAP for some 32-bit platforms
+	- Support for 'slow' group ACLs in ssl_bump access control
+	- Support OpenSSL 1.0.0 built without SSLv2
+	- Support GCC 4.6 and binutils-gold
+	- Add CSS id attribute to BODY tag of generated error pages.
+	- Display WARNING and ERROR when max_filedescriptors has failed
+
 Changes to squid-3.1.12.1 (19 Apr 2011):
 
 	- Port from 3.2: Dynamic SSL Certificate generation
@@ -161,7 +161,7 @@ typedef unsigned long ino_t;
 #define SIGUSR1 30	/* user defined signal 1 */
 #define SIGUSR2 31	/* user defined signal 2 */
 
-typedef unsigned short int ushort;
+typedef unsigned short int u_short;
 #if !_SQUID_CYGWIN_
 typedef int uid_t;
 typedef int gid_t;
@@ -112,7 +112,7 @@ else
 fi
 
 # LT_INIT requires libtool v2, might as well state it loud
-LT_PREREQ ([2.2])
+LT_PREREQ([2.2])
 LT_INIT([dlopen],[disable-shared])
 if ! test "${ac_top_build_prefix}" = "";
 then
@@ -1042,8 +1042,8 @@ if test "x${enable_eui:=yes}" = "xyes" ; then
       AC_MSG_WARN([EUI support probably will not work on host $host.])
       ;;
   esac
+  #Iphlpapi.h check delayed after winsock2.h
   AC_CHECK_HEADERS( \
-    Iphlpapi.h \
     net/if_dl.h \
     sys/sockio.h \
     sys/param.h
@@ -2428,6 +2428,7 @@ AC_CHECK_SIZEOF(int64_t)
 AC_CHECK_SIZEOF(long)
 #need the define for overflow checks
 AC_CHECK_SIZEOF(off_t)
+AC_CHECK_SIZEOF(size_t)
 
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
@@ -2508,6 +2509,10 @@ AC_SEARCH_LIBS([yp_match], [nsl nss_nis nss_nisplus])
 dnl Check for Winsock only on MinGW, on Cygwin we must use emulated BSD socket API
 if test "x$squid_host_os" = "xmingw" ; then
   SQUID_CHECK_WINSOCK_LIB
+  AC_CHECK_HEADERS(Iphlpapi.h,,,[
+#if HAVE_WINSOCK2_H
+#include <winsock2.h>
+#endif])
 fi
 
 # check that we have unix sockets
@@ -2,4 +2,7 @@
 ## None of the .po or .pot are distributed for builds at this stage.
 ##
 
-EXTRA_DIST =
+include $(srcdir)/language.list
+
+EXTRA_DIST = \
+	language.list
@@ -0,0 +1,2168 @@
+# SOME DESCRIPTIVE TITLE
+# Copyright (C) YEAR Free Software Foundation, Inc.
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+msgid ""
+msgstr ""
+"Project-Id-Version: PACKAGE VERSION\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2010-02-13 00:05+1400\n"
+"PO-Revision-Date: 2011-02-17 20:57+0200\n"
+"Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: fr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Pootle 2.0.5\n"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:3 helpers/basic_auth/LDAP/basic_ldap_auth.8:3 helpers/basic_auth/NCSA/basic_ncsa_auth.8:3 helpers/basic_auth/PAM/basic_pam_auth.8:3 helpers/basic_auth/RADIUS/basic_radius_auth.8:3 helpers/external_acl/ldap_group/squid_ldap_group.8:3 helpers/external_acl/session/squid_session.8:3 helpers/external_acl/unix_group/squid_unix_group.8:3 src/squid.8.in:3 tools/cachemgr.cgi.8.in:3 tools/squidclient.1:3
+#, no-wrap
+msgid "NAME"
+msgstr "NOM"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:7
+msgid "Local Users auth helper for Squid"
+msgstr "Aide à l'authentification des utilisateurs locaux pour Squid"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:8 helpers/basic_auth/LDAP/basic_ldap_auth.8:8 helpers/basic_auth/NCSA/basic_ncsa_auth.8:8 helpers/basic_auth/PAM/basic_pam_auth.8:8 helpers/basic_auth/RADIUS/basic_radius_auth.8:8 helpers/external_acl/ldap_group/squid_ldap_group.8:10 helpers/external_acl/session/squid_session.8:10 helpers/external_acl/unix_group/squid_unix_group.8:8 src/squid.8.in:8 tools/cachemgr.cgi.8.in:8 tools/squidclient.1:8
+#, no-wrap
+msgid "SYNOPSIS"
+msgstr "SYNOPSIS"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:11 helpers/basic_auth/LDAP/basic_ldap_auth.8:39 helpers/basic_auth/NCSA/basic_ncsa_auth.8:12 helpers/basic_auth/PAM/basic_pam_auth.8:15 helpers/basic_auth/RADIUS/basic_radius_auth.8:26 helpers/external_acl/ldap_group/squid_ldap_group.8:26 helpers/external_acl/session/squid_session.8:18 helpers/external_acl/unix_group/squid_unix_group.8:15 src/squid.8.in:25 tools/cachemgr.cgi.8.in:11 tools/squidclient.1:47
+#, no-wrap
+msgid "DESCRIPTION"
+msgstr "DESCRIPTION"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:15
+msgid ""
+"B<basic_getpwnam_auth> allows Squid to authenticate any local user accounts "
+"to validate the user name and password of Basic HTTP authentication."
+msgstr ""
+"B<basic_getpwnam_auth> permet d'authentifier les comptes utilisateurs locaux "
+"de Squid, pour valider le nom d'utilisateur et le mot de passe de "
+"l'authentification de base avec HTTP."
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:21
+msgid "It uses B<getpwnam()> and B<getspnam()> routines for authentication."
+msgstr ""
+"Vous devez utiliser les routines B<getpwnam()> et B<getspnam()> pour "
+"l'authentification."
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:23
+msgid "This has the following advantages over the NCSA module:"
+msgstr "Cela a les avantages suivants sur le module NCSA :"
+
+#. type: TP
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:23
+#, no-wrap
+msgid "Allows authentication of all known local users"
+msgstr "Permet l'authentification de tous les utilisateurs locaux connus"
+
+#. type: TP
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:25
+#, no-wrap
+msgid "Allows authentication through nsswitch.conf"
+msgstr "Permet l'authentification avec nsswitch.conf"
+
+#. type: TP
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:27
+#, no-wrap
+msgid "Can handle NIS(+) requests"
+msgstr "Peut gérer les requêtes NIS(+)"
+
+#. type: TP
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:29
+#, no-wrap
+msgid "Can handle LDAP request"
+msgstr "Peut gérer les requêtes LDAP"
+
+#. type: TP
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:31
+#, no-wrap
+msgid "Can handle PAM request"
+msgstr "Peut gérer les requêtes PAM"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:34 helpers/basic_auth/LDAP/basic_ldap_auth.8:242 helpers/basic_auth/NCSA/basic_ncsa_auth.8:24 helpers/basic_auth/PAM/basic_pam_auth.8:41 helpers/basic_auth/RADIUS/basic_radius_auth.8:61 helpers/external_acl/ldap_group/squid_ldap_group.8:209 helpers/external_acl/session/squid_session.8:50 helpers/external_acl/unix_group/squid_unix_group.8:33 tools/cachemgr.cgi.8.in:19
+#, no-wrap
+msgid "CONFIGURATION"
+msgstr "CONFIGURATION"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:47
+msgid ""
+"When used for authenticating to local UNIX shadow password databases the "
+"program must be running as root or else it won't have sufficient permissions "
+"to access the user password database. Such use of this program is not "
+"recommended, but if you absolutely need to then make the program B<setuid> "
+"B<root>"
+msgstr ""
+"quand vous utilisez l'authentification locale dans l'esprit UNIX, le "
+"programme doit être exécuté en tant que root pour accéder à la base de "
+"données des mots de passes. Autrement vous n'aurez pas les autorisations "
+"suffisantes pour accéder à la base de données utilisateurs. L'utilisation "
+"de ce programme n'est pas recommandée, mais si c'est absolument nécessaire, "
+"alors utiliser le programme B<setuid> sous B<root>"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:60 helpers/basic_auth/PAM/basic_pam_auth.8:79
+msgid ""
+"Please note that in such configurations it is also strongly recommended that "
+"the program is moved into a directory where normal users cannot access it, "
+"as this mode of operation will allow any local user to brute-force other "
+"users passwords. Also note the program has not been fully audited and the "
+"author cannot be held responsible for any security issues due to such "
+"installations."
+msgstr ""
+"Notez s'il vous plaît, que pour une telle configuration, il est fortement "
+"recommandé de placer le programme dans un endroit où les utilisateurs "
+"normaux ne peuvent pas y accéder, si vous ne respectez pas ce mode "
+"opératoire tout utilisateur local accédera aux mots de passe des autres "
+"utilisateurs par une méthode très radicale. Notez également que le programme "
+"n'a pas été complètement vérifiés et l'auteur ne peut pas être tenu "
+"responsable des problèmes de sécurité dus à de telles installations."
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:61 helpers/basic_auth/LDAP/basic_ldap_auth.8:288 helpers/basic_auth/NCSA/basic_ncsa_auth.8:30 helpers/basic_auth/PAM/basic_pam_auth.8:80 helpers/basic_auth/RADIUS/basic_radius_auth.8:85 helpers/external_acl/ldap_group/squid_ldap_group.8:232 helpers/external_acl/session/squid_session.8:63 helpers/external_acl/unix_group/squid_unix_group.8:62 src/squid.8.in:216 tools/cachemgr.cgi.8.in:51 tools/squidclient.1:163
+#, no-wrap
+msgid "AUTHOR"
+msgstr "AUTEUR"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:63 helpers/external_acl/ldap_group/squid_ldap_group.8:234 helpers/external_acl/unix_group/squid_unix_group.8:64
+msgid "This program was written by"
+msgstr "Ce programme a été écrit par"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:68
+msgid "Based on original code by"
+msgstr "Basé sur le code original de"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:71 helpers/basic_auth/NCSA/basic_ncsa_auth.8:32 helpers/basic_auth/RADIUS/basic_radius_auth.8:93 helpers/external_acl/ldap_group/squid_ldap_group.8:243 helpers/external_acl/unix_group/squid_unix_group.8:67
+msgid "This manual was written by"
+msgstr "Ce manuel a été écrit par"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:73 helpers/basic_auth/LDAP/basic_ldap_auth.8:296 helpers/basic_auth/NCSA/basic_ncsa_auth.8:37 helpers/basic_auth/PAM/basic_pam_auth.8:84 helpers/basic_auth/RADIUS/basic_radius_auth.8:95 helpers/external_acl/ldap_group/squid_ldap_group.8:245 helpers/external_acl/session/squid_session.8:67 helpers/external_acl/unix_group/squid_unix_group.8:69 src/squid.8.in:226 tools/cachemgr.cgi.8.in:57 tools/squidclient.1:169
+#, no-wrap
+msgid "COPYRIGHT"
+msgstr "COPYRIGHT"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:75 helpers/basic_auth/LDAP/basic_ldap_auth.8:298 helpers/basic_auth/RADIUS/basic_radius_auth.8:97 helpers/external_acl/ldap_group/squid_ldap_group.8:247 helpers/external_acl/session/squid_session.8:69 helpers/external_acl/unix_group/squid_unix_group.8:71
+msgid "This program and documentation is copyright to the authors named above."
+msgstr ""
+"Ce programme et la documentation est la propriété des auteurs nommés "
+"ci-dessus."
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:77 helpers/basic_auth/LDAP/basic_ldap_auth.8:300 helpers/basic_auth/PAM/basic_pam_auth.8:91 helpers/basic_auth/RADIUS/basic_radius_auth.8:99 helpers/external_acl/ldap_group/squid_ldap_group.8:249 helpers/external_acl/session/squid_session.8:71 helpers/external_acl/unix_group/squid_unix_group.8:73 tools/cachemgr.cgi.8.in:59 tools/squidclient.1:171
+msgid ""
+"Distributed under the GNU General Public License (GNU GPL) version 2 or "
+"later (GPL2+)."
+msgstr ""
+"Distribué sous la Licence Publique Générale GNU (GNU GPL) version 2 ou "
+"ultérieure (GPL2+)."
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:78 helpers/basic_auth/LDAP/basic_ldap_auth.8:301 helpers/basic_auth/NCSA/basic_ncsa_auth.8:50 helpers/basic_auth/PAM/basic_pam_auth.8:92 helpers/basic_auth/RADIUS/basic_radius_auth.8:100 helpers/external_acl/ldap_group/squid_ldap_group.8:250 helpers/external_acl/session/squid_session.8:72 helpers/external_acl/unix_group/squid_unix_group.8:74 src/squid.8.in:243 tools/cachemgr.cgi.8.in:60 tools/squidclient.1:172
+#, no-wrap
+msgid "QUESTIONS"
+msgstr "QUESTIONS"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:81 helpers/basic_auth/LDAP/basic_ldap_auth.8:304 helpers/basic_auth/NCSA/basic_ncsa_auth.8:53 helpers/basic_auth/PAM/basic_pam_auth.8:95 helpers/basic_auth/RADIUS/basic_radius_auth.8:103 helpers/external_acl/ldap_group/squid_ldap_group.8:253 helpers/external_acl/session/squid_session.8:75 helpers/external_acl/unix_group/squid_unix_group.8:77 src/squid.8.in:246 tools/cachemgr.cgi.8.in:63 tools/squidclient.1:175
+msgid ""
+"Questions on the usage of this program can be sent to the I<Squid Users "
+"mailing list>"
+msgstr ""
+"Les questions sur l'utilisation de ce programme peuvent être envoyées à "
+"I<Squid Users mailing list>"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:83 helpers/basic_auth/LDAP/basic_ldap_auth.8:309 helpers/basic_auth/NCSA/basic_ncsa_auth.8:55 helpers/basic_auth/PAM/basic_pam_auth.8:97 helpers/basic_auth/RADIUS/basic_radius_auth.8:108 helpers/external_acl/ldap_group/squid_ldap_group.8:258 helpers/external_acl/session/squid_session.8:77 helpers/external_acl/unix_group/squid_unix_group.8:79 src/squid.8.in:248 tools/cachemgr.cgi.8.in:65 tools/squidclient.1:177
+#, no-wrap
+msgid "REPORTING BUGS"
+msgstr "RAPPORT de BUGS"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:85 helpers/basic_auth/LDAP/basic_ldap_auth.8:311 helpers/basic_auth/NCSA/basic_ncsa_auth.8:57 helpers/basic_auth/PAM/basic_pam_auth.8:99 helpers/basic_auth/RADIUS/basic_radius_auth.8:110 helpers/external_acl/ldap_group/squid_ldap_group.8:260 helpers/external_acl/session/squid_session.8:79 helpers/external_acl/unix_group/squid_unix_group.8:81 src/squid.8.in:250 tools/cachemgr.cgi.8.in:67 tools/squidclient.1:179
+msgid "Report bugs or bug fixes using http://bugs.squid-cache.org/"
+msgstr ""
+"Pour signaler un bug ou une correction de bug utilisez "
+"http://bugs.squid-cache.org/"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:88 helpers/basic_auth/LDAP/basic_ldap_auth.8:314 helpers/basic_auth/NCSA/basic_ncsa_auth.8:60 helpers/basic_auth/PAM/basic_pam_auth.8:102 helpers/basic_auth/RADIUS/basic_radius_auth.8:113 helpers/external_acl/ldap_group/squid_ldap_group.8:263 helpers/external_acl/session/squid_session.8:82 helpers/external_acl/unix_group/squid_unix_group.8:84 src/squid.8.in:253 tools/cachemgr.cgi.8.in:70 tools/squidclient.1:182
+msgid ""
+"Report serious security bugs to I<Squid Bugs "
+"E<lt>squid-bugs@squid-cache.orgE<gt>>"
+msgstr ""
+"Pour signaler un bug de sécurité sérieux utilisez "
+"E<lt>squid-bugs@squid-cache.orgE<gt>>"
+
+#. type: Plain text
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:91 helpers/basic_auth/LDAP/basic_ldap_auth.8:317 helpers/basic_auth/NCSA/basic_ncsa_auth.8:63 helpers/basic_auth/PAM/basic_pam_auth.8:105 helpers/basic_auth/RADIUS/basic_radius_auth.8:116 helpers/external_acl/ldap_group/squid_ldap_group.8:266 helpers/external_acl/session/squid_session.8:85 helpers/external_acl/unix_group/squid_unix_group.8:87 src/squid.8.in:256 tools/cachemgr.cgi.8.in:73 tools/squidclient.1:185
+msgid "Report ideas for new improvements to the I<Squid Developers mailing list>"
+msgstr ""
+"Pour donner des idées ou pour de nouvelles améliorations utilisez "
+"I<Squid Developers mailing list>"
+
+#. type: SH
+#: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:93 helpers/basic_auth/LDAP/basic_ldap_auth.8:319 helpers/basic_auth/NCSA/basic_ncsa_auth.8:65 helpers/basic_auth/PAM/basic_pam_auth.8:107 helpers/basic_auth/RADIUS/basic_radius_auth.8:118 helpers/external_acl/ldap_group/squid_ldap_group.8:268 helpers/external_acl/session/squid_session.8:87 helpers/external_acl/unix_group/squid_unix_group.8:92 src/squid.8.in:258 tools/cachemgr.cgi.8.in:75 tools/squidclient.1:187
+#, no-wrap
+msgid "SEE ALSO"
+msgstr "VOIR AUSSI"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:7
+msgid "LDAP authentication helper for Squid"
+msgstr "Aide à l'authentification LDAP pour Squid"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:12 helpers/basic_auth/LDAP/basic_ldap_auth.8:27 helpers/external_acl/ldap_group/squid_ldap_group.8:14
+msgid "base DN"
+msgstr "Base DN (ou Nom de Domaine)"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:14
+msgid "attribute"
+msgstr "Attribut"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:16 helpers/basic_auth/LDAP/basic_ldap_auth.8:31 helpers/external_acl/ldap_group/squid_ldap_group.8:18
+msgid "options"
+msgstr "Options"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:18 helpers/basic_auth/LDAP/basic_ldap_auth.8:33
+msgid "LDAP server name"
+msgstr "Nom du serveur LDAP"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:20 helpers/basic_auth/LDAP/basic_ldap_auth.8:35 helpers/basic_auth/RADIUS/basic_radius_auth.8:18 helpers/external_acl/ldap_group/squid_ldap_group.8:22 src/squid.8.in:17 tools/squidclient.1:28
+msgid "port"
+msgstr "Port"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:22 helpers/basic_auth/LDAP/basic_ldap_auth.8:37 helpers/external_acl/ldap_group/squid_ldap_group.8:24
+msgid "URI"
+msgstr "URI"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:29 helpers/external_acl/ldap_group/squid_ldap_group.8:16
+msgid "LDAP search filter"
+msgstr "Filtre de recherche LDAP"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:47
+msgid ""
+"B<basic_ldap_auth> allows Squid to connect to a LDAP directory to validate "
+"the user name and password of Basic HTTP authentication.  LDAP options are "
+"specified as parameters on the command line, while the username(s) and "
+"password(s) to be checked against the LDAP directory are specified on "
+"subsequent lines of input to the helper, one username/password pair per line "
+"separated by a space."
+msgstr ""
+"B<basic_ldap_auth> permet à Squid de se connecter à un annuaire LDAP pour "
+"valider le nom d'utilisateur et le mot de passe de l'authentification de "
+"base avec HTTP. Les options LDAP sont spécifiées par des paramètres en ligne "
+"de commande, le(s) nom(s) d'utilisateur(s) et le(s) mot(s) de passe(s) sont "
+"vérifiés dans l'annuaire LDAP, les entrées sont vérifiées sur la ligne "
+"suivante, le couple nom d'utilisateur/mot de passe sont sur une ligne et "
+"séparée par un espace."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:56
+msgid ""
+"As expected by the basic authentication construct of Squid, after specifying "
+"a username and password followed by a new line, this helper will produce "
+"either B<OK> or B<ERR> on the following line to show if the specified "
+"credentials are correct according to the LDAP directory."
+msgstr ""
+"Pendant la construction de l'authentification de base Squid et après avoir "
+"spécifié sur une nouvelle ligne, le nom d'utilisateur et le mot de passe. "
+"Une aide sur la ligne suivante produira soit B<OK> soit B<ERR>, pour "
+"indiquer si les informations d'identification spécifiées sont correctes en "
+"fonction de l'annuaire LDAP."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:61
+msgid ""
+"The program has two major modes of operation. In the default mode of "
+"operation the users DN is constructed using the base DN and user "
+"attribute. In the other mode of operation a search filter is used to locate "
+"valid user DN's below the base DN."
+msgstr ""
+"Le programme a deux modes majeurs de fonctionnement. Dans le mode de "
+"fonctionnement par défaut, le nom de domaine de l'utilisateur est construit "
+"en utilisant la base DN avec les attributs de l'utilisateur. Dans l'autre "
+"mode de fonctionnement, un filtre de recherche est utilisé pour localiser le "
+"nom de domaine valide dans la base DN."
+
+#. type: SH
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:62 helpers/basic_auth/NCSA/basic_ncsa_auth.8:20 helpers/basic_auth/PAM/basic_pam_auth.8:21 helpers/basic_auth/RADIUS/basic_radius_auth.8:31 helpers/external_acl/ldap_group/squid_ldap_group.8:49 helpers/external_acl/session/squid_session.8:26 helpers/external_acl/unix_group/squid_unix_group.8:19 src/squid.8.in:59 tools/squidclient.1:56
+#, no-wrap
+msgid "OPTIONS"
+msgstr "OPTIONS"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:67
+msgid "B<REQUIRED.> Specifies the base DN under which the users are located."
+msgstr ""
+"B<REQUIRED.> permet de spécifie la base DN dans laquelle se trouve les "
+"utilisateurs."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:75
+msgid ""
+"LDAP search B<filter> to locate the user DN. Required if the users are in a "
+"hierarchy below the base DN, or if the login name is not what builds the "
+"user specific part of the users DN."
+msgstr ""
+"B<filter> permet de rechercher dans le LDAP et de localiser l'utilisateur DN "
+"(ou nom de domaine). Cela est requis si les utilisateurs sont dans une "
+"hiérarchie en dessous de la base DN, ou si le nom de l'identifiant ne fait "
+"pas partie spécifiques de la construction des utilisateurs DN."
+
+#. uid\=%s\""
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:82
+msgid ""
+"The search filter can contain up to 15 occurrences of B<%s> which will be "
+"replaced by the username, as in B<\\&\\&> for RFC2037 directories. For a "
+"detailed description of LDAP search filter syntax see RFC2254."
+msgstr ""
+"Le filtre de recherche peut contenir jusqu'à 15 entrées, par ex. B<%s> sera "
+"remplacé par le nom d'utilisateur, comme dans B<\\&\\&> pour les annuaires "
+"RFC2037. Pour une description détaillée des syntaxes du filtre de recherche "
+"LDAP voir RFC2254."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:90
+msgid ""
+"Will crash if other B<%> values than B<%s> are used, or if more than 15 "
+"B<%s> are used."
+msgstr ""
+"La recherche se bloquera si la valeur B<%> est différente de la valeur B<%s> "
+"ou si B<%s> est supérieur à 15 entrées."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:99
+msgid ""
+"Specifies the name of the DN attribute that contains the username/login.  "
+"Combined with the base DN to construct the users DN when no search filter is "
+"specified ( B<-f> option). Defaults to B<uid>"
+msgstr ""
+"Spécifie le nom attribuer du DN, qui contient le nom "
+"utilisateur/identifiant. Combiné avec la base DN pour construire les "
+"utilisateurs DN quand aucun filtre de la recherche n'est spécifié (B<-f> "
+"option). Par défaut B<uid>"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:108
+msgid ""
+"B<Note:> This can only be done if all your users are located directly under "
+"the same position in the LDAP tree and the login name is used for naming "
+"each user object. If your LDAP tree does not match these criterias or if you "
+"want to filter who are valid users then you need to use a search filter to "
+"search for your users DN ( B<-f> option)."
+msgstr ""
+"B<Note:> n'est possible que si tous les utilisateurs sont directement situés "
+"dans arborescence LDAP et que le nom de l'identifiant soit utilisé pour "
+"nommer chaque objet de l'utilisateur. Si votre arborescence LDAP ne "
+"correspond pas à ces critères ou si vous souhaitez filtrer les utilisateurs "
+"valides, vous devez utiliser le filtre de recherche avec (l'option B<-f>) "
+"pour rechercher les utilisateurs DN (ou nom de domaine)."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:118
+msgid ""
+"Use I<ldap_compare> instead of I<ldap_simple_bind> to verify the users "
+"password.  B<passwordattr> is the LDAP attribute storing the users password."
+msgstr ""
+"Utilisez I<ldap_compare> au lieu de I<ldap_simple_bind> pour vérifier les "
+"mots de passe utilisateurs. B<passwordattr> est l'attribut LDAP pour stocker "
+"les mots de passe utilisateurs."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:126
+msgid ""
+"Search scope when performing user DN searches specified by the B<-f> "
+"option. Defaults to B<sub>"
+msgstr ""
+"Recherche étendue pour exécuter une recherche les utilisateurs DN, indiquer "
+"l'option B<-f>. Par défaut, B<sub>"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:130 helpers/external_acl/ldap_group/squid_ldap_group.8:178
+msgid "B<base> object only,"
+msgstr "B<base> seulement un objet,"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:133 helpers/external_acl/ldap_group/squid_ldap_group.8:181
+msgid "B<one> level below the base object or"
+msgstr "B<one> niveau inférieur de la base de l'objet ou"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:136 helpers/external_acl/ldap_group/squid_ldap_group.8:184
+msgid "B<sub>tree below the base object"
+msgstr "B<sub> arborescence inférieur de la base de l'objet"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:142
+msgid ""
+"The DN and password to bind as while performing searches. Required by the "
+"B<-f> flag if the directory does not allow anonymous searches."
+msgstr ""
+"Attacher le DN et le mot de passe pour exécuter des recherches. Il est "
+"nécessaire d'indiquer l'option B<-f> si l'annuaire ne permet pas de "
+"recherches anonymes"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:147
+msgid ""
+"As the password needs to be printed in plain text in your Squid "
+"configuration it is strongly recommended to use a account with minimal "
+"associated privileges.  This to limit the damage in case someone could get "
+"hold of a copy of your Squid configuration file."
+msgstr ""
+"Dans la mesure où le mot de passe doit être paramétrer en clair dans votre "
+"configuration Squid, il est fortement recommandé d'utiliser un compte avec "
+"un minimum de privilèges associés. Afin de limiter les dégâts si quelqu'un "
+"essai de mettre la main sur la copie de votre fichier de configuration Squid."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:152 helpers/external_acl/ldap_group/squid_ldap_group.8:98
+msgid ""
+"The DN and the name of a file containing the password to bind as while "
+"performing searches."
+msgstr ""
+"Attacher le DN et le nom du fichier contenant les mots de passe pour "
+"exécuter les recherches"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:157 helpers/external_acl/ldap_group/squid_ldap_group.8:103
+msgid ""
+"Less insecure version of the former parameter pair with two advantages: The "
+"password does not occur in the process listing, and the password is not "
+"being compromised if someone gets the squid configuration file without "
+"getting the secretfile."
+msgstr ""
+"Avec l'ancienne version peu sûre, les paramètres avaient deux avantages : le "
+"mot de passe n'apparaissait pas dans le processus d'enregistrement, le mot "
+"de passe n'était pas compromis, mais si quelqu'un récupère le fichier de "
+"configuration squid sans avoir récupère le fichier secret."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:165
+msgid ""
+"Use a persistent LDAP connection. Normally the LDAP connection is only open "
+"while validating a username to preserve resources at the LDAP server. This "
+"option causes the LDAP connection to be kept open, allowing it to be reused "
+"for further user validations. Recommended for larger installations."
+msgstr ""
+"Utilisation d'une connexion LDAP persistante. Normalement, la connexion LDAP "
+"est uniquement ouvert lorsqu'elle valide le nom d'utilisateur, pour "
+"préserver les ressources au niveau du serveur LDAP. Cette option maintient "
+"la connexion LDAP ouverte et permet d'être réutilisé pour une nouvelle "
+"validation d'un utilisateur. Recommandé dans la plus par des installations."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:178
+msgid ""
+"Only bind once per LDAP connection. Some LDAP servers do not allow "
+"re-binding as another user after a successful I<ldap_bind.> The use of this "
+"option always opens a new connection for each login attempt. If combined "
+"with the B<-P> option for persistent LDAP connection then the connection "
+"used for searching for the user DN is kept persistent but a new connection "
+"is opened to verify each users password once the DN is found."
+msgstr ""
+"Effectuer seulement une connexion LDAP à la fois. Certains serveurs LDAP ne "
+"permettent pas de rajouter un autre utilisateur après une connexion réussi. "
+"I<ldap_bind> L'utilisation de cette option ouvre toujours une nouvelle "
+"connexion après chaque identifiant connecté. Si cette option est combiné "
+"avec l'option B<-P> pour une connexion LDAP persistante, la connexion "
+"utilisée pour la recherche d'utilisateur DN sera maintenu persistant mais "
+"une nouvelle connexion sera ouverte pour contrôler chaque mot de passe des "
+"utilisateurs, une fois que le DN sera trouvé."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:182 helpers/external_acl/ldap_group/squid_ldap_group.8:170
+msgid "Do not follow referrals"
+msgstr "Ne pas faire suivre les références"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:187
+msgid "when to dereference aliases. Defaults to B<never>"
+msgstr "lorsque elles sont suivi par un alias. Par défaut B<never> (ou jamais)"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:196
+msgid ""
+"B<never> dereference aliases (default), B<always> dereference aliases, only "
+"while B<search ing> or only to B<find> the base object."
+msgstr ""
+"B<never> Ne jamais résoudre les alias, par (défaut), B<always> résous en "
+"plus les alias, B<search> uniquement pendant une recherche ou B<find> "
+"uniquement pour une recherche dans une base d'objets."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:201
+msgid ""
+"Specity the LDAP server to connect to by LDAP URI (requires OpenLDAP "
+"libraries).  Servers can also be specified last on the command line."
+msgstr ""
+"Spécifier un serveur LDAP, avec une connexion LDAP par URI (nécessite une "
+"bibliothèque OpenLDAP). Les serveurs peuvent également être spécifiée en "
+"dernier par ligne de commande."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:206
+msgid ""
+"Specify the LDAP server to connect to. Servers can also be specified last on "
+"the command line."
+msgstr ""
+"Spécifier un serveur LDAP pour se connecter à. Les serveurs peuvent "
+"également être spécifiée en dernier par ligne de commande."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:212
+msgid ""
+"Specify an alternate TCP port where the ldap server is listening if other "
+"than the default LDAP port 389. Can also be specified within the server "
+"specificiation by using servername:port syntax."
+msgstr ""
+"Spécifier un autre port TCP, sur lequel le serveur LDAP écoutera, le port "
+"par défaut du LDAP est 389. On peut également indiquer un serveur "
+"spécifique, en utilisant la syntaxe servername:port."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:216 helpers/external_acl/ldap_group/squid_ldap_group.8:204
+msgid "LDAP protocol version. Defaults to 2 if not specified."
+msgstr "Version du protocole LDAP. Par défaut 2 S'il n'est pas spécifié."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:220 helpers/external_acl/ldap_group/squid_ldap_group.8:208
+msgid "Use TLS encryption"
+msgstr "Utiliser le cryptage TLS"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:224 helpers/external_acl/ldap_group/squid_ldap_group.8:107
+msgid "Enable LDAP over SSL (requires Netscape LDAP API libraries)"
+msgstr ""
+"Activer le chiffrage SSL pour LDAP (nécessite une bibliothèque API avec "
+"Netscape LDAP)"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:231
+msgid ""
+"Specify B<timeout> used when connecting to LDAP servers (requires Netscape "
+"LDAP API libraries)"
+msgstr ""
+"Spécifier un B<timeout> pour la connexion à un serveur LDAP (nécessite une "
+"bibliothèque API avec Netscape LDAP)"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:235 helpers/external_acl/ldap_group/squid_ldap_group.8:192
+msgid "Specify time limit on LDAP search operations"
+msgstr "Spécifier une limite de temps pour des opérations de recherche LDAP"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:241 helpers/external_acl/ldap_group/squid_ldap_group.8:82
+msgid ""
+"Debug mode where each step taken will get reported in detail.  Useful for "
+"understanding what goes wrong if the results is not what is expected."
+msgstr ""
+"Mode Déboguage, chaque étape sera enregistrée en détail. S'utile pour "
+"comprendre ce qui a mal tourne ou si les résultats ne sont pas ceux attendus."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:246
+msgid ""
+"For directories using the RFC2307 layout with a single domain, all you need "
+"to specify is usually the base DN under where your users are located and the "
+"server name:"
+msgstr ""
+"Au sujet des annuaires utilisant la mise en page RFC2307 avec un seul "
+"domaine, en général tout se que vous devez spécifier dans la base DN sont, "
+"les utilisateurs et le nom du serveur :"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:252
+msgid ""
+"If you have sub-domains then you need to use a search filter approach to "
+"locate your user DNs as these can no longer be constructed direcly from the "
+"base DN and login name alone:"
+msgstr ""
+"Si vous avez des sous-domaines, vous devez utiliser une Méthode de filtre de "
+"recherche pour localiser vos utilisateurs DNs, car ils ne pourront plus "
+"être construits directement seulement à partir du nom de l'identifiant dans "
+"la base DN :"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:257
+msgid ""
+"And similarily if you only want to allow access to users having a specific "
+"attribute"
+msgstr ""
+"Même si vous voulez seulement permettre l'accès aux utilisateurs ayant un "
+"attribut spécifique"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:266
+msgid ""
+"Or if the user attribute of the user DN is B<cn> instead of B<uid> and you "
+"do not want to have to search for the users then you could use something "
+"like the following example for Active Directory:"
+msgstr ""
+"Ou si l'attribut de l'utilisateur, pour les utilisateurs DN est B<cn> au "
+"lieu de B<uid>, si vous ne devez pas rechercher les utilisateurs alors vous "
+"pouvez utiliser l'exemple suivant avec un annuaire actif :"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:276
+msgid ""
+"If you want to search for the user DN and your directory does not allow "
+"anonymous searches then you must also use the B<-D> and B<-w> flags to "
+"specify a user DN and password to log in as to perform the searches, as in "
+"the following complex Active Directory example"
+msgstr ""
+"Si vous souhaitez faire une recherche pour un utilisateur DN et si votre "
+"annuaire ne permet pas de recherches anonymes, vous devez utiliser l'option "
+"B<-D> avec l'indicateur B<-w> et spécifier un utilisateur DN avec un mot de "
+"passe pour vous connecter, ensuite vous pouvez effectuer des recherches, "
+"comme dans l'exemple complexe suivant avec un annuaire Actif."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:287
+msgid ""
+"B<NOTE:> When constructing search filters it is strongly recommended to test "
+"the filter using B<ldapsearch> before you attempt to use B<basic_ldap_auth.> "
+"This to verify that the filter matches what you expect."
+msgstr ""
+"B<NOTE:> Lors de la construction du filtre de recherche, il est fortement "
+"recommandé de tester le filtre en utilisant B<ldapsearch>, avant d'essayer "
+"d'utiliser B<basic_ldap_auth.> Ceci pour vérifier que le filtre correspond "
+"à ce que vous attendiez."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:290 helpers/basic_auth/RADIUS/basic_radius_auth.8:87
+msgid "This program is written by"
+msgstr "Ce programme est écrit par"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:294
+msgid "This manual is written by"
+msgstr "Ce manuel est écrit par"
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:308
+msgid ""
+"Or to your favorite LDAP list/friend if the question is more related to LDAP "
+"than Squid."
+msgstr ""
+"Ou à votre liste/amis LDAP préférée si les questions sont davantage liées à "
+"LDAP que Squid."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:324
+msgid "Your favorite LDAP documentation."
+msgstr "Votre documentation favoris LDAP."
+
+#. type: Plain text
+#: helpers/basic_auth/LDAP/basic_ldap_auth.8:325 helpers/external_acl/ldap_group/squid_ldap_group.8:275
+msgid "B<RFC2254> - The String Representation of LDAP Search Filters,"
+msgstr ""
+"B<RFC2254> - Représentation des chaînes pour le filtre de recherche LDAP,"
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:7
+msgid "NCSA httpd-style password file authentication helper for Squid"
+msgstr ""
+"Aide à l'authentification du fichier de mot de passe pour Squid pour le "
+"NCSA httpd-style"
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:11
+msgid "passwd file"
+msgstr "fichier de mot de passe"
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:16
+msgid ""
+"B<basic_ncsa_auth> allows Squid to read and authenticate user and password "
+"information from an NCSA/Apache httpd-style password file when using basic "
+"HTTP authentication."
+msgstr ""
+"B<basic_ncsa_auth> permet à Squid de lire les informations "
+"d'authentification de l'utilisateur et du mot de passe dans NCSA/Apache "
+"httpd/style à partir du fichier mot de passe, lorsque l'on utilise "
+"l'authentification de base avec HTTP."
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:19
+msgid "This password file can be manipulated using B<htpasswd.>"
+msgstr "Le fichier mot de passe peut être manipulées en utilisant B<htpasswd.>"
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:23
+msgid ""
+"The only parameter is the password file.  It must have permissions to be "
+"read by the user that Squid is running as."
+msgstr ""
+"Le seul paramètre pour le fichier mot de passe. C'est d'avoir les "
+"autorisations nécessaires pour que le fichier soit lu par l'utilisateur, "
+"quand il est exécuté avec Squid."
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:29
+msgid "B<basic_ncsa_auth> must have access to the password file to be executed."
+msgstr ""
+"B<basic_ncsa_auth> permet d'avoir accès au fichier mot de passe à exécuter."
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:35
+msgid "Based on original documentation by"
+msgstr "Basé sur la documentation originaux écrit par"
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:43
+msgid ""
+"This file is distributed in the hope that it will be useful, but WITHOUT ANY "
+"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS "
+"FOR A PARTICULAR PURPOSE. See the GNU General Public License for more "
+"details."
+msgstr ""
+"Ce fichier est distribué dans l'espoir qu'il sera utilisé, mais SANS AUCUNE "
+"GARANTIE, sans même la garantie implicite de COMMERCIALISATION ou "
+"D'ADAPTATION POUR UN USAGE PARTICULIER. Pour plus de détails voir la Licence "
+"Publique Générale GNU."
+
+#. type: Plain text
+#: helpers/basic_auth/NCSA/basic_ncsa_auth.8:48
+msgid ""
+"You should have received a copy of the GNU General Public License along with "
+"this file; if not, write to the Free Software Foundation, Inc., 59 Temple "
+"Place, Suite 330, Boston, MA 02111-1307 USA"
+msgstr ""
+"Vous devez avoir reçu une copie de la Licence Publique Générale GNU avec ce "
+"fichier, sinon, écrivez à Free Software Foundation, Inc, 59 Temple Place, "
+"Suite 330, Boston, MA 02111-1307 USA"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:7
+msgid "Squid PAM Basic authentication helper"
+msgstr "Aide à l'authentification de base pour Squid PAM"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:11
+msgid "service name"
+msgstr "Nom du service"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:13
+msgid "TTL"
+msgstr "TTL"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:20
+msgid ""
+"B<basic_pam_auth> allows Squid to connect to a mostly any available PAM "
+"database to validate the user name and password of Basic HTTP "
+"authentication."
+msgstr ""
+"B<basic_pam_auth> permet à Squid de se connecter sur n'importe quelle base "
+"de données PAM disponible, pour valider le nom d'utilisateur et le mot de "
+"passe pour l'authentification de base HTTP."
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:26
+msgid "Specifies the PAM service name Squid uses, defaults to B<squid>"
+msgstr ""
+"Spécifie le nom du service PAM qui sera utilisée avec Squid, par défaut "
+"B<squid>"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:35
+msgid ""
+"Enables persistent PAM connections where the connection to the PAM database "
+"is kept open and reused for new logins. The TTL specifies how long the "
+"connection will be kept open (in seconds).  Default is to not keep PAM "
+"connections open. Please note that the use of persistent PAM connections is "
+"slightly outside the PAM specification and may not work with all PAM "
+"configurations."
+msgstr ""
+"Valide les connexions persistants PAM où une connexion dans la base de "
+"données PAM qui sera gardé ouvert et réutilisé pour une nouvelle "
+"identification. Avec TTL on spécifie temps (en secondes) pour maintenir la "
+"connexion ouverte. Par défaut on ne doit pas garder les connexions PAM "
+"ouvertes. Notez s'il vous plaît que l'utilisation de la connexions PAM "
+"persistants, est légèrement en dehors de la spécification PAM et ne peut pas "
+"fonctionner avec toutes les configurations PAM."
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:40
+msgid "Do not perform the PAM account management group (account expiration etc)"
+msgstr ""
+"Ne pas produire des groupes de compte de gestion PAM (expiration de compte, etc)"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:46
+msgid ""
+"The program needs a PAM service to be configured in B</etc/pam.conf> or "
+"B</etc/pam.d/squid>"
+msgstr ""
+"Si le programme a besoin d'un service PAM, il doit être configuré dans "
+"B</etc/pam.conf> ou dans B</etc/pam.d/squid>"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:54
+msgid ""
+"The default service name is B<squid> , and the program makes use of the "
+"B<auth> and B<account> management groups to verify the password and the "
+"accounts validity."
+msgstr ""
+"Le nom du service par défaut est B<squid>, le programme utilise les groupes "
+"de gestion B<auth> et B<account> qui vérifie la validité du mot de passe et "
+"du comptes."
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:58
+msgid ""
+"For details on how to configure PAM services, see the PAM documentation for "
+"your system. This manual does not cover PAM configuration details."
+msgstr ""
+"Pour plus de détails sur la façon de configurer les services PAM dans votre "
+"système, consultez la documentation PAM. Car ce manuel ne couvre pas tous "
+"les détails de la configuration PAM."
+
+#. type: SH
+#: helpers/basic_auth/PAM/basic_pam_auth.8:59
+#, no-wrap
+msgid "NOTES"
+msgstr "NOTES"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:66
+msgid ""
+"When used for authenticating to local UNIX shadow password databases the "
+"program must be running as root or else it won't have sufficient permissions "
+"to access the user password database. Such use of this program is not "
+"recommended, but if you absolutely need to then make the program setuid root"
+msgstr ""
+"Quand vous utilisez la base de données d'authentification de mot de passe "
+"sous UNIX, vous devez exécuter le programme en tant que root, autrement vous "
+"n'aurez pas les autorisations suffisantes pour accéder à la base de données "
+"des mots de passes utilisateur. Une telle utilisation de ce programme n'est "
+"pas recommandée, mais si c'est absolument nécessaire, alors utiliser le "
+"programme B<setuid> sous B<root>"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:82 helpers/external_acl/session/squid_session.8:65
+msgid "This program and documentation was written by"
+msgstr "La documentation de ce programme a été écrite par"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:88
+msgid "Squid B<basic_pam_auth> and this manual is Copyright 1999,2002,2003"
+msgstr "Squid B<basic_pam_auth> et ce manuel a un Copyright depuis 1999,2002,2003"
+
+#. type: Plain text
+#: helpers/basic_auth/PAM/basic_pam_auth.8:114
+msgid "PAM Systems Administrator Guide"
+msgstr "Guide pour les administrateurs du Système PAM"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:7
+msgid "Squid RADIUS authentication helper"
+msgstr "Aide pour l'authentification Squid RADIUS"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:12
+msgid "config file"
+msgstr "fichier de configutation"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:16
+msgid "server name"
+msgstr "non du serveur"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:20
+msgid "identifier"
+msgstr "identifiant"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:22
+msgid "secret"
+msgstr "secret"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:24 helpers/external_acl/session/squid_session.8:14 tools/squidclient.1:34
+msgid "timeout"
+msgstr "temps de pause"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:30
+msgid ""
+"B<basic_radius_auth> allows Squid to connect to a RADIUS server to validate "
+"the user name and password of Basic HTTP authentication."
+msgstr ""
+"B<basic_radius_auth> permet à Squid de se connecter à un serveur RADIUS pour "
+"valider le nom d'utilisateur et le mot de passe d'authentification de base "
+"avec HTTP."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:36
+msgid ""
+"Specifies the path to a configuration file. See the CONFIGURATION section "
+"for details on the file content."
+msgstr ""
+"Spécifie le chemin du fichier de configuration. Voir la section CONFIGURATION "
+"pour plus de détails sur le contenu du fichier."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:40
+msgid "Alternative method of specifying the server to connect to"
+msgstr ""
+"Autre méthode pour spécifier un serveur, sur lequel nous devons nous "
+"connecter"
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:45
+msgid ""
+"Specify another server port where the RADIUS server listens for requests if "
+"different from the default RADIUS port.  Normally not specified."
+msgstr ""
+"Spécifier un autre port sur lequel le serveur RADIUS écoute s'il est "
+"différent du port RADIUS par défaut. Normalement ne rien spécifier."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:50
+msgid ""
+"Unique identifier identifying this Squid proxy to the RADIUS server.  If not "
+"specified the IP address is used to identify the proxy."
+msgstr ""
+"Identifiant unique, identification du proxy Squid pour le serveur RADIUS. "
+"S'il n'est pas spécifié l'adresse IP est utilisé pour identifier le proxy."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:56
+msgid ""
+"Alternative method of specifying the shared secret. Using the B<-f> option "
+"with a configuration file is generally more secure and recommended."
+msgstr ""
+"Autre méthode pour spécifier le secret de partage. Utiliser l'option B<-f> "
+"avec le fichier de configuration cela est généralement plus sûr et recommandé."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:60
+msgid "RADIUS request timeout. Default is 10 seconds."
+msgstr "Temps de pause pour une requête RADIUS. Par défaut 10 secondes."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:67
+msgid ""
+"The configuration specifies how the helper connects to RADIUS.  The file "
+"contains a list of directives (one per line). Lines beginning with a B<#> "
+"are ignored."
+msgstr ""
+"Configuration spécifique, aide pour vous connecter au serveur RADIUS. Le "
+"fichier contient une liste de directives (une par ligne). Les lignes "
+"commençant par le caractère B<#> sont à ignorées."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:71
+msgid "specifies the name or address of the RADIUS server to connect to."
+msgstr "Spécifie le nom ou l'adresse du serveur RADIUS pour se connecter."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:75
+msgid "specifies the shared RADIUS secret."
+msgstr "Spécifie le secret de partage RADIUS."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:80
+msgid ""
+"specifies what name the proxy should use to identify itself to the RADIUS "
+"server.  This directive is optional."
+msgstr ""
+"Spécifie le nom du proxy qui doit être utiliser pour s'identifier auprès du "
+"serveur RADIUS. Ce paramètre est optionnel."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:84
+msgid "Specifies the port number or service name where the helper should connect."
+msgstr ""
+"Spécifie le numéro de port ou le nom du service, pour se connecter à l'aide."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:91
+msgid "With contributions from many others."
+msgstr "Avec la contribution de beaucoup d'autres."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:107
+msgid ""
+"Or contact your favorite RADIUS list/friend if the question is more related "
+"to RADIUS than Squid."
+msgstr ""
+"Ou contactez votre liste/ami RADIUS préféré, si les questions sont davantage "
+"liées à RADIUS qu'à Squid."
+
+#. type: Plain text
+#: helpers/basic_auth/RADIUS/basic_radius_auth.8:121
+msgid "B<RFC2058> - Remote Authentication Dial In User Service (RADIUS)"
+msgstr ""
+"B<RFC2058> - connexion à distance au service d'authentification des "
+"utilisateurs (RADIUS)"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:7
+msgid "Squid LDAP external acl group helper"
+msgstr "aide à Squid LDAP externe avec le groupe acl"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:9
+msgid "Version 2.17"
+msgstr "Version 2.17"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:20
+msgid "ldap_server_name"
+msgstr "nom_serveur_ldap"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:33
+msgid ""
+"B<squid_ldap_group> allows Squid to connect to a LDAP directory to authorize "
+"users via LDAP groups.  LDAP options are specified as parameters on the "
+"command line, while the username(s) and group(s) to be checked against the "
+"LDAP directory are specified on subsequent lines of input to the helper, one "
+"username/group pair per line separated by a space."
+msgstr ""
+"B<squid_ldap_group> permet à Squid de se connecter à un annuaire LDAP pour "
+"l'autorisation les utilisateurs à travers des groupes LDAP. Les options LDAP "
+"sont spécifiées par des paramètres en ligne de commande, le nom(s) "
+"d'utilisateur(s) et le groupe(s), seront vérifiés depuis l'annuaire LDAP et "
+"précisés sur la ligne suivante après une Entrée, le couple nom "
+"d'utilisateur/groupe seront sur une même ligne et séparées par un espace."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:44
+msgid ""
+"As expected by the B<external_acl_type> construct of Squid, after specifying "
+"a username and group followed by a new line, this helper will produce either "
+"B<OK> or B<ERR> on the following line to show if the user is a member of the "
+"specified group."
+msgstr ""
+"Comme prévu, on utilise B<external_acl_type> pour a construction de Squid, "
+"on spécifie pour chaque nouvelle ligne le nom d'utilisateur et le groupe "
+"suivis d'une entrée, sur la ligne suivante sera alors indiqué soit B<OK> "
+"soit B<ERR>, pour aider l'utilisateur à vérifier si le membre appartient "
+"bien au groupe spécifié."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:48
+msgid ""
+"The program operates by searching with a search filter based on the users "
+"user name and requested group, and if a match is found it is determined that "
+"the user belongs to the group."
+msgstr ""
+"Le programme fonctionne avec un filtre de recherche, en recherchant dans la "
+"base des utilisateurs, le mon de l'utilisateur et le groupe, si une "
+"correspondance est trouvée il sera précisé que l'utilisateur appartient "
+"bien au groupe."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:53
+msgid "When to dereference aliases. Defaults to 'never'"
+msgstr "Lorsque il est suivi par un alias. Par défaut 'never' (ou jamais)"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:62
+msgid ""
+"B<never> dereference aliases (default), B<always> dereference aliases, only "
+"while B<search>ing or only to B<find> the base object"
+msgstr ""
+"B<never> Ne jamais résoudre les alias, par (défaut), B<always> résous en "
+"plus les alias, B<search> uniquement pendant une recherche ou B<find> "
+"uniquement pour une recherche dans une base d'objets."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:67
+msgid "B<REQUIRED.> Specifies the base DN under which the groups are located."
+msgstr "B<REQUIRED.> Spécifie la base DN sous laquel les groupes sont situés."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:71
+msgid "Specifies the base DN under which the users are located (if different)"
+msgstr ""
+"Spécifie la base DN sous laquel les utilisateurs sont situés (si différent)"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:76
+msgid ""
+"Specify timeout used when connecting to LDAP servers (requires Netscape LDAP "
+"API libraries)"
+msgstr ""
+"Spécifier le temps pause, lors d'une connecter aux serveurs LDAP "
+"(requies une bibliothèques API pour Netscape LDAP)"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:87
+msgid ""
+"The DN and password to bind as while performing searches. Required if the "
+"directory does not allow anonymous searches."
+msgstr ""
+"Le DN et le mot de passe doivent être liès pour des recherches, si "
+"l'annuaire ne permet pas de faire des recherches anonymes."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:93
+msgid ""
+"As the password needs to be printed in plain text in your Squid "
+"configuration and will be sent on the command line to the helper it is "
+"strongly recommended to use a account with minimal associated privileges.  "
+"This to limit the damage in case someone could get hold of a copy of your "
+"Squid configuration file or extracts the password used from a process "
+"listing."
+msgstr ""
+"Comme le mot de passe est enregistré en clair dans votre fichier de "
+"configuration Squid. Il est fortement recommandé d'utiliser un compte avec "
+"un minimum de privilèges associés. Afin de limiter les dommages au cas, où "
+"quelqu'un pourrait mettre la main sur la copie de votre fichier de "
+"configuration Squid ou extraire le mot de passe utilisation de la liste "
+"de processus."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:123
+msgid ""
+"LDAP search filter used to search the LDAP directory for any matching group "
+"memberships.  In the filter B<%u> will be replaced by the user name (or DN "
+"if the B<-F> or B<-u> options are used) and B<%g> by the requested group "
+"name."
+msgstr ""
+"Utiliser le filtre de recherche LDAP pour rechercher tous les membres du "
+"groupe correspondant dans l'annuaire LDAP. Le Filtre B<%u> sera remplacé "
+"par le nom d'utilisateur (ou utiliser le option B<-F> ou B<-u> pour les DN "
+"(Non de Domaine)) et B<%g> sera remplacé par le nom du groupe demandé."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:135
+msgid ""
+"LDAP search filter used to search the LDAP directory for any matching "
+"users.  In the filter B<%s> will be replaced by the user name. If B<%> is to "
+"be included literally in the filter then use B<%%>"
+msgstr ""
+"Utiliser le filtre de recherche LDAP pour rechercher tous les utilisateurs "
+"dans l'annuaire LDAP. Le filtre B<%s> sera remplacé par le nom d'utilisateur. "
+"Si le signe B<%> est inclu littéralement dans le filtre, utiliser alors B<%%>"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:141
+msgid ""
+"Specifies that the first query argument sent to the helper by Squid is a "
+"extension to the basedn and will be temporarily added in front of the global "
+"basedn for this query."
+msgstr ""
+"Spécifie que le premier argument de la requête est à envoyée à l'aide de "
+"Squid c'est un prolongement de la base DN et cette requête sera "
+"temporairement ajouté à l'en-tête de la base DN global."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:145
+msgid "Specify the LDAP server to connect to"
+msgstr "Spécifie le serveur LDAP pour se connecter à"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:149
+msgid ""
+"Specity the LDAP server to connect to by a LDAP URI (requires OpenLDAP "
+"libraries)"
+msgstr ""
+"Specifie le serveur LDAP pour se connecter avec URI LDAP (à besoin de la "
+"bibliothèque OpenLDAP)"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:153
+msgid "Strip Kerberos Realm component from user names (@ separated)"
+msgstr ""
+"Retirer le caractère (séparateur @) du nom d'utilisateur quant vous utilisez "
+"Kerberos Realm."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:158
+msgid ""
+"Specify an alternate TCP port where the ldap server is listening if other "
+"than the default LDAP port 389."
+msgstr ""
+"Spécifier un autre port TCP sur lequel le serveur LDAP écoute, s'il est "
+"différent du port 389 par défaut."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:166
+msgid ""
+"Use a persistent LDAP connection. Normally the LDAP connection is only open "
+"while verifying a users group membership to preserve resources at the LDAP "
+"server. This option causes the LDAP connection to be kept open, allowing it "
+"to be reused for further user validations. Recommended for larger "
+"installations."
+msgstr ""
+"Utilisation d'une connexion persistante LDAP. Normalement, la connexion LDAP "
+"est uniquement ouvert pendant la vérification de l'utilisateur appartenant "
+"à un groupe, ainsi les ressources au niveau du serveur LDAP sont préservées. "
+"Cette option provoque l'ouverture permanente de la connexion LDAP, lui "
+"permettant d'être réutilisé pour la validation de future utilisateur. "
+"Recommandé pour les installations importantes."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:175
+msgid "search scope. Defaults to B<sub>"
+msgstr "champ de recherche. Par défaut B<sub>"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:188 helpers/external_acl/unix_group/squid_unix_group.8:32
+msgid "Strip NT domain name component from user names (/ or \\e separated)"
+msgstr ""
+"Découper les éléments du nom de domaine NT du nom d'utilisateur (vous devez "
+"les séparer avec le caractère B</> ou B<\\>)"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:200
+msgid ""
+"LDAP attribute used to construct the user DN from the user name and base dn "
+"without needing to search for the user.  A maximum of 16 occurrences of "
+"B<%s> are supported."
+msgstr ""
+"Attribut LDAP pour la construction des utilisateurs DN, avec le nom "
+"d'utilisateur et la base DN, sans avoir besoin de rechercher un utilisateur. "
+"Un maximum de 16 entrées pour B<%s> sont pris en charge."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:214
+msgid ""
+"This helper is intended to be used as an B<external_acl_type> helper in "
+"B<squid.conf.>"
+msgstr ""
+"Cette aide est conçue pour être utilisée, comme l'aide de B<external_acl_type> "
+"dans B<squid.conf>."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:231
+msgid ""
+"B<NOTE:> When constructing search filters it is recommended to first test "
+"the filter using B<ldapsearch> to verify that the filter matches what you "
+"expect before you attempt to use B<squid_ldap_group>"
+msgstr ""
+"B<NOTE:> Lors de la construction du filtre de recherche, il est recommandé "
+"de tester d'abord le filtre à l'aide du paramètre B<ldapsearch> pour vérifier "
+"que le filtre correspond bien à vos attentent et avant de tenter d'utiliser "
+"le paramètre B<squid_ldap_group>"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:240
+msgid "Based on prior work in B<squid_ldap_auth> by"
+msgstr "Basé sur le travail préalable de B<squid_ldap_auth> par"
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:257
+msgid ""
+"Or contact your favorite LDAP list/friend if the question is more related to "
+"LDAP than Squid."
+msgstr ""
+"Ou contactez votre liste/ami favorite LDAP si les questions sont davantage "
+"liées à LDAP qu'à Squid."
+
+#. type: Plain text
+#: helpers/external_acl/ldap_group/squid_ldap_group.8:274
+msgid "Your favorite LDAP documentation"
+msgstr "Votre documentation favorite LDAP"
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:7
+msgid "Squid session tracking external acl group helper."
+msgstr "Session Squid de suivi externe pour l'aide au groupe acl."
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:9
+msgid "Version 1.0"
+msgstr "Version 1.0"
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:16
+msgid "database"
+msgstr "base de données"
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:23
+msgid ""
+"B<squid_session> maintains a concept of sessions by monitoring requests and "
+"timing out sessions if no requests have been seen for the idle timeout "
+"timer."
+msgstr ""
+"B<squid_session> permet de maintenir une méthode de sessions pour le suivi "
+"des requêtes et une synchronisation de session, pour savoir si aucune "
+"requête n'a été vu pendant un temps d'inactivité."
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:25
+msgid "Intended use is for displaying \"terms of use\" pages, ad popups etc."
+msgstr ""
+"Cette utilisation est prévue pour l'affichage des pages "
+"\"des conditions d'utilisations\", des fenêtre popups, etc."
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:31
+msgid "B<Timeout> for any session. If not specified the default is 3600 seconds."
+msgstr ""
+"B<Timeout> pour toutes les sessions. S'il n'est pas spécifié la valeur par "
+"défaut est 3600 secondes."
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:38
+msgid ""
+"B<Path> to persistent database. If not specified the session details will be "
+"kept in memory only and all sessions will reset each time Squid restarts "
+"it's helpers (Squid restart or rotation of logs)."
+msgstr ""
+"B<Path> pour la base de données persistantes. S'il n'est pas spécifié, "
+"le détail de session sera seulement gardé en mémoire et toutes les "
+"sessions seront remis à zéro à chaque redémarre de Squid, "
+"aide pour (le redémarrage de squid ou la rotation des logs)."
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:46
+msgid ""
+"Active mode. In this mode sessions are started by evaluating an acl with the "
+"argument B<LOGIN> , or terminated by the argument B<LOGOUT>"
+msgstr ""
+"Mode actif. Dans ce mode les sessions commences à évaluer les acl puis "
+"l'argument B<LOGIN> et terminé par l'argument B<LOGOUT>"
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:49
+msgid ""
+"Without this flag the helper automatically starts the session after the "
+"first request."
+msgstr ""
+"Sans ce repère l'aide démarre automatiquement la session après "
+"la première requête."
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:53
+msgid "Configuration example using the default automatic mode"
+msgstr "Exemple de configuration en utilisant le mode automatique par défaut"
+
+#. type: Plain text
+#: helpers/external_acl/session/squid_session.8:62
+msgid ""
+"Then set up http://your.server.example.com/bannerpage to display a session "
+"startup page and then redirect the user back to the requested URL given in "
+"the url query parameter."
+msgstr ""
+"Ensuite, vous créer un site web http://your.server.example.com/bannerpage "
+"qui affichera la page de démarrage de session, puis vous redirigerez "
+"l'utilisateur vers l'URL indiquée, avec le paramètre URL en question."
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:7
+msgid "Squid UNIX Group helper"
+msgstr "Aide pour les groupes Squid sous UNIX"
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:11 helpers/external_acl/unix_group/squid_unix_group.8:13
+msgid "group"
+msgstr "groupe"
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:18
+msgid ""
+"B<squid_unix_group> allows Squid to base access controls on users "
+"memberships in UNIX groups."
+msgstr ""
+"B<squid_unix_group> permet d'accéder à la base de contrôle Squid, pour faire "
+"appartenir des utilisateurs à un groupe sous UNIX."
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:23
+msgid "Specifies a group name to match."
+msgstr "Spécifie un nom de groupe pour vérification."
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:28
+msgid "Also match the users primary group from B</etc/passwd>"
+msgstr ""
+"Vérifie également les utilisateurs du groupe primaire avec le fichier "
+"B</etc/passwd>"
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:46
+msgid ""
+"This B<squid.conf> example defines two Squid acls.  I<usergroup1> matches "
+"users in I<group1> , and I<usergroup2> matches users in I<group2> or "
+"I<group3>"
+msgstr ""
+"Cet exemple définit deux acl dans B<squid.conf> pour Squid. I<usergroup1> "
+"vérifie les utilisateurs du I<group1> et I<usergroup2> vérifie les "
+"utilisateurs du I<group2> ou du I<group3>"
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:56
+msgid ""
+"By default up to 11 groups can be matched in one acl (including commandline "
+"specified groups). This limit is defined by B<MAX_GROUPS> in the source "
+"code."
+msgstr ""
+"Par défaut vous pouvez vérifier jusqu'à 11 groupes acl (vous pouvez indiquer "
+"les groupes en ligne de commande). Cette limite est définie par le "
+"paramètre B<MAX_GROUPS> du code source."
+
+#. type: SH
+#: helpers/external_acl/unix_group/squid_unix_group.8:57
+#, no-wrap
+msgid "KNOWN ISSUES"
+msgstr "PROBLÈMES CONNUS"
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:61
+msgid ""
+"Does not understand GID aliased groups sometimes used to work around groups "
+"size limitations. If you are using GID aliased groups then you must specify "
+"each alias by name."
+msgstr ""
+"Ne comprend pas les groupes d'alias GID, parfois utilisés pour contourner la "
+"limitation du nombre de groupes. Si vous utilisez des groupes d'alias GID, "
+"vous devez spécifier le nom de chaque alias."
+
+#. type: Plain text
+#: helpers/external_acl/unix_group/squid_unix_group.8:90
+msgid "Additionally bugs or bug-fixes can be reported to"
+msgstr ""
+"En outre, les bogues ou les corrections d'erreurs peuvent être signalées à"
+
+#. type: Plain text
+#: src/squid.8.in:7
+msgid "HTTP web proxy caching server"
+msgstr "Serveur de cache du proxy web HTTP"
+
+#. type: Plain text
+#: src/squid.8.in:13
+msgid "facility"
+msgstr "installation"
+
+#. type: Plain text
+#: src/squid.8.in:15
+msgid "config-file"
+msgstr "fichier de configuration"
+
+#. type: Plain text
+#: src/squid.8.in:19
+msgid "signal"
+msgstr "signal"
+
+#. type: Plain text
+#: src/squid.8.in:21
+msgid "service-name"
+msgstr "nom du service"
+
+#. type: Plain text
+#: src/squid.8.in:23
+msgid "command-line"
+msgstr "ligne de commande"
+
+#. type: Plain text
+#: src/squid.8.in:32
+msgid ""
+"B<squid> is a high-performance proxy caching server for web clients, "
+"supporting FTP, gopher, ICAP, ICP, HTCP and HTTP data objects.  Unlike "
+"traditional caching software, Squid handles all requests in a single, "
+"non-blocking process."
+msgstr ""
+"B<squid> est un serveur proxy de haute performance cachant les clients sur "
+"le web, il supporte les protocoles FTP, Gopher, ICAP, ICP, HTCP et HTTP pour "
+"les données. Contrairement aux logiciels de mise en cache traditionnelle, "
+"Squid gère toutes les requêtes en un seul processus non-bloquant."
+
+#. type: Plain text
+#: src/squid.8.in:36
+msgid ""
+"Squid keeps meta data and especially hot objects cached in RAM, caches DNS "
+"lookups, supports non-blocking DNS lookups, and implements negative caching "
+"of failed requests."
+msgstr ""
+"Squid conserve au chaud (la mis en cache) des meta-données et des données "
+"les plus utilisées cachées dans la RAM, il conserve aussi les DNS dans la "
+"mémoire, les DNS sont non bloquante et applique la mise en cache négative "
+"des requêtes ayant échouées."
+
+#. type: Plain text
+#: src/squid.8.in:41
+msgid ""
+"Squid supports SSL, extensive access controls, and full request logging.  By "
+"using the lightweight Internet Cache Protocols ICP, HTCP or CARP, Squid "
+"caches can be arranged in a hierarchy or mesh for additional bandwidth "
+"savings."
+msgstr ""
+"Squid supporte le SSL, il contrôle les accès étendus, et enregistre toutes "
+"les requêtes reçues. Le caches Squid peut être configuré pour une hiérarchie "
+"ou un maillage qui économisera de la bande passante supplémentaires. En "
+"utilisant un cache Internet léger avec les protocoles ICP, HTCP ou CARP."
+
+#. type: Plain text
+#: src/squid.8.in:49
+msgid ""
+"Squid consists of a main server program B<squid> , some optional programs "
+"for custom processing and authentication, and some management and client "
+"tools.  When squid starts up, it spawns a configurable number of helper "
+"processes, each of which can perform parallel lookups.  This reduces the "
+"amount of time the cache waits for results."
+msgstr ""
+"Le programme Squid se compose d'un serveur principal B<squid>, de programmes "
+"facultatifs pour le traitement personnalisé d'authentification et d'outils "
+"pour la gestion des clients. Lorsque squid démarre, il génère un nombre de "
+"processus configurable avec ca documentation, ainsi chaque processus peut "
+"exécuter des recherches en parallèle. Cela réduit le temps attend pour la "
+"recherche de résultats."
+
+#. type: Plain text
+#: src/squid.8.in:51
+msgid "Squid is derived from the ARPA-funded Harvest Project."
+msgstr "Squid est dérivé du Projet Harvest avec le financement d'ARPA."
+
+#. type: Plain text
+#: src/squid.8.in:57
+msgid ""
+"This manual page only lists the command line arguments.  For details on how "
+"to configure Squid see the file B<@SYSCONFDIR@/squid.conf.documented,> the "
+"Squid wiki FAQ and examples at http://wiki.squid-cache.org/ , or the "
+"configuration manual on the Squid home page"
+msgstr ""
+"Ce manuel répertorie uniquement la liste des arguments de commandes. Pour "
+"plus de détails sur la façon de configurer Squid, consulter le fichier "
+"B<@SYSCONFDIR@/squid.conf.documented>, vous pouvez aussi consulter le site "
+"wiki http://wiki.squid-cache.org/ pour les FAQ et les exemples Squid, "
+"ou consulter le manuel de configuration sur la Page d'accueil Squid."
+
+#. type: Plain text
+#: src/squid.8.in:66
+msgid ""
+"Specify HTTP port number where Squid should listen for requests, in addition "
+"to any B<http_port> specifications in B<squid.conf>"
+msgstr ""
+"Spécifier le numéro de port sur lequel Squid devra écouter les requêtes HTTP, "
+"en plus de tous les ports spécifié dans B<http_port> du fichier B<squid.conf>"
+
+#. type: Plain text
+#: src/squid.8.in:70
+msgid "Do not catch fatal signals."
+msgstr "Ne prends pas les messages d'erreur fatale."
+
+#. type: Plain text
+#: src/squid.8.in:74
+msgid "Write debugging to stderr also."
+msgstr "Enregistre les informations de débogage également les erreurs standard."
+
+#. type: Plain text
+#: src/squid.8.in:86
+msgid ""
+"Use the given config-file instead of B<@SYSCONFDIR@/squid.conf .> If the "
+"file name starts with a B<!> or B<|> then it is assumed to be an external "
+"command or command line.  Can for example be used to pre-process the "
+"configuration before it is being read by Squid.  To facilitate this Squid "
+"also understands the common #line notion to indicate the real source file."
+msgstr ""
+"Utilisez le fichier-config à la place de B<@SYSCONFDIR@/squid.conf>. Si le "
+"nom du fichier commence avec le caractère B<!> ou B<|> alors il sera "
+"interprété comme une commande externe ou une ligne de commande. cela peut "
+"par exemple être utilisée pour pré-traiter une configuration avant qu'elle "
+"ne soit lu par Squid. Pour faciliter la compréhension de Squid utiliser #une "
+"ligne de commentaire pour indiquer la source réelle du fichier."
+
+#. type: Plain text
+#: src/squid.8.in:90
+msgid "Don't serve any requests until store is rebuilt."
+msgstr "Ne vous servez pas des requêtes avant que le cache soit reconstruit."
+
+#. type: Plain text
+#: src/squid.8.in:94
+msgid "Print help message."
+msgstr "Imprimer le message d'aide."
+
+#. type: Plain text
+#: src/squid.8.in:100
+msgid "Install as a Windows Service (see B<-n> option)."
+msgstr "Installer Windows en tant que service (voir l'option B<-n)."
+
+#. type: Plain text
+#: src/squid.8.in:107
+msgid ""
+"Parse configuration file, then send signal to running copy (except B<-k "
+"parse> ) and exit."
+msgstr ""
+"Analyse du fichier de configuration, envoi ensuite un signal lors de "
+"l'exécution de la copie (sauf avec la commande B<-k parse>) et sortir."
+
+#. type: Plain text
+#: src/squid.8.in:112
+msgid "Use specified syslog facility. implies B<-s>"
+msgstr ""
+"Utiliser une spécification pour l'installation de syslog. Implique "
+"l'option B<-s>"
+
+#. type: Plain text
+#: src/squid.8.in:117
+msgid ""
+"Specify Windows Service name to use for service operations, default is: "
+"B<Squid>"
+msgstr ""
+"Indiquer le nom du service à utiliser sous Windows, par défaut: B<Squid>"
+
+#. type: Plain text
+#: src/squid.8.in:121
+msgid "No daemon mode."
+msgstr "Pas de mode démon."
+
+#. type: Plain text
+#: src/squid.8.in:125
+msgid "Set Windows Service Command line options in Registry."
+msgstr ""
+"Définir les options par ligne de commande des services dans le Registre "
+"Windows."
+
+#. type: Plain text
+#: src/squid.8.in:131
+msgid "Remove a Windows Service (see B<-n> option)."
+msgstr "Supprimer un service sous Windows (voir l'option B<-n)."
+
+#. type: Plain text
+#: src/squid.8.in:137
+msgid "Do not set B<REUSEADDR> on port."
+msgstr "Ne pas définir l'option B<REUSEADDR> sur le port."
+
+#. type: Plain text
+#: src/squid.8.in:142
+msgid "Enable logging to syslog. Also configurable in B<@SYSCONFDIR@/squid.conf>"
+msgstr ""
+"Activer l'enregistrement avec syslog. Il est également configurable dans "
+"B<@SYSCONFDIR@/squid.conf>"
+
+#. type: Plain text
+#: src/squid.8.in:146
+msgid "Double-check swap during rebuild."
+msgstr "Double-vérification de swap lors de la reconstruction."
+
+#. type: Plain text
+#: src/squid.8.in:150
+msgid "Specify ICP port number (default: 3130), disable with 0."
+msgstr "Spécifier le numéro de port ICP (par défaut: 3130), 0 pour désactiver."
+
+#. type: Plain text
+#: src/squid.8.in:154
+msgid "Print version and build details."
+msgstr "Imprime la version et les détails de la construction."
+
+#. type: Plain text
+#: src/squid.8.in:158
+msgid "Force full debugging."
+msgstr "Force le débogage complet."
+
+#. type: Plain text
+#: src/squid.8.in:166
+msgid "Only return B<UDP_HIT> or B<UDP_MISS_NOFETCH> during fast reload."
+msgstr ""
+"B<UDP_HIT> ou B<UDP_MISS_NOFETCH> permet de limiter les réponses lors d'un "
+"redémarrage rapide."
+
+#. type: Plain text
+#: src/squid.8.in:170
+msgid "Create swap directories"
+msgstr "Créer un répertoire swap pour le cache."
+
+#. type: SH
+#: src/squid.8.in:171
+#, no-wrap
+msgid "FILES"
+msgstr "FICHIERS"
+
+#. type: Plain text
+#: src/squid.8.in:173
+msgid "Squid configuration files located in @SYSCONFDIR@/:"
+msgstr "Les fichiers de configurations Squid sont dans @SYSCONFDIR@/:"
+
+#. type: Plain text
+#: src/squid.8.in:178
+msgid ""
+"The main configuration file. You must initially make changes to this file "
+"for B<squid> to work. For example, the default configuration does not allow "
+"access from any browser."
+msgstr ""
+"Fichier de configuration principal. Vous devez d'abord apporter des "
+"modifications à ce fichier pour travail avec B<squid>. Par exemple, la "
+"configuration par défaut ne permet pas l'accès à n'importe quel navigateur."
+
+#. type: Plain text
+#: src/squid.8.in:182 src/squid.8.in:188
+msgid ""
+"Reference copy of the configuration file. Always kept up to date with the "
+"version of Squid you are using."
+msgstr ""
+"La copie de référence du fichier de configuration. Doit toujours être mis à "
+"jour par rapport à la version Squid que vous utilisez."
+
+#. type: Plain text
+#: src/squid.8.in:184
+msgid ""
+"Use this to look up the default configuration settings and syntax after "
+"upgrading."
+msgstr ""
+"Utiliser cette fonction pour rechercher les paramètres de configuration et "
+"les syntaxes par défaut, après une mise à jour."
+
+#. type: Plain text
+#: src/squid.8.in:193
+msgid ""
+"Use this to read the documentation for configuration options available in "
+"your build of Squid. The online configuration manual is also available for a "
+"full reference of options.  B<see>http://www.squid-cache.org/Doc/config/"
+msgstr ""
+"Lire la documentation et utilisez les options disponibles pour la "
+"configuration et la construction de Squid. Le manuel de configuration est "
+"également disponible en ligne, pour le référencement complet des options. "
+"B<voir> http://www.squid-cache.org/Doc/config/"
+
+#. type: Plain text
+#: src/squid.8.in:198
+msgid "The main configuration file for the web B<cachemgr.cgi> tools."
+msgstr ""
+"B<cachemgr.cgi> est le fichier principal de configuration pour les outils "
+"web"
+
+#. type: Plain text
+#: src/squid.8.in:201
+msgid "The main configuration file for the Sample MSNT authenticator."
+msgstr "Fichier principal de configuration pour l'authentificateur MSNT."
+
+#. type: Plain text
+#: src/squid.8.in:206
+msgid ""
+"CSS Stylesheet to control the display of generated error pages.  Use this to "
+"set any company branding you need, it will apply to every language Squid "
+"provides error pages for."
+msgstr ""
+"Feuille de style CSS pour contrôler l'apparence des pages d'erreurs générées. "
+"Peut être utilisez pour définir l'apparence en fonction à la normes "
+"de l'entreprise, cela s'appliquera aux pages d'erreur généré par Squid et "
+"pour chaque langue prise en charge par celui-ci."
+
+#. type: Plain text
+#: src/squid.8.in:209
+msgid "Some files also located elsewhere:"
+msgstr "Certains fichiers sont situés ailleurs :"
+
+#. type: Plain text
+#: src/squid.8.in:212
+msgid "MIME type mappings for FTP gatewaying"
+msgstr "types de fichier d'application MIME pour la fonction gateway FTP."
+
+#. type: Plain text
+#: src/squid.8.in:215
+msgid "Location of Squid error pages and templates."
+msgstr "Localisation des pages d'erreur Squid et des modèles."
+
+#. type: Plain text
+#: src/squid.8.in:218
+msgid ""
+"Squid was written over many years by a changing team of developers and "
+"maintained in turn by"
+msgstr ""
+"Squid a été rédigé pendant de nombreuses années par une équipe de "
+"développeurs et son évolution a été maintenu à son tour"
+
+#. type: Plain text
+#: src/squid.8.in:225
+msgid ""
+"With contributions from many others in the Squid community.  see "
+"CONTRIBUTORS for a full list of individuals who contributed code.  see "
+"CREDITS for a list of major code contributing copyright holders."
+msgstr ""
+"Avec la contribution de nombreuse personnes qui crées la communauté Squid. "
+"La liste de tous ce qui ont CONTRIBUÉ le plus et ceux qui détiennent les "
+"droits d'auteur sont dans le fichier CREDITS."
+
+#. type: Plain text
+#: src/squid.8.in:233
+msgid ""
+"This software product, SQUID, is developed by a team of individuals, and "
+"copyrighted (C) 2001 by the Regents of the University of California, with "
+"all rights reserved.  UCSD administered the NLANR Cache grants, NCR 9616602 "
+"and NCR 9521745 under which most of this code was developed."
+msgstr ""
+"Le logiciel SQUID, est développé par une équipe de personnes, les droits "
+"d'auteur (C) 2001 sont détenues par les Régents de l'Université de "
+"Californie, tous droits réservés. L'UCSD administre et NLANR pour les dons "
+"en cache, voici les deux concessions NCR 9616602 et NCR 9521745, sous "
+"lesquelles la majeure partie des codes SQUID ont été développée."
+
+#. type: Plain text
+#: src/squid.8.in:240
+msgid ""
+"This program is free software; you can redistribute it and/or modify it "
+"under the terms of the GNU General Public License (version 2) as published "
+"by the Free Software Foundation.  It is distributed in the hope that it will "
+"be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of "
+"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General "
+"Public License for more details."
+msgstr ""
+"Ce programme est un logiciel libre, vous pouvez le redistribuer et/ou le "
+"modifier selon les termes de la Licence Publique Générale GNU (version 2), "
+"publiée par la Free Software Fondation. Il est distribué dans l'espoir qu'il "
+"sera utile, mais SANS AUCUNE GARANTIE, sans même la garantie implicite de "
+"la COMMERCIALISATION ou de L'ADAPTATION A UN USAGE PARTICULIER. Voir la "
+"Licence Publique Générale GNU pour plus de détails."
+
+#. type: Plain text
+#: src/squid.8.in:242
+msgid ""
+"see the CREDITS file for further copyright licensing of third-party code "
+"contributions."
+msgstr ""
+"Voir le fichier CREDITS pour plus d'informations sur des droits d'auteur et "
+"aussi pour des contributions de la troisième partie du code."
+
+#. type: Plain text
+#: src/squid.8.in:268
+msgid "The Squid FAQ wiki"
+msgstr "Wiki contient les FAQ de Squid"
+
+#. type: Plain text
+#: src/squid.8.in:271
+msgid "The Squid Configuration Manual"
+msgstr "Configuration manuel de Squid"
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:7
+msgid "Squid HTTP proxy manager CGI web interface"
+msgstr "Interface Web CGI, pour la gestion du proxy Squid sur HTTP"
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:18
+msgid ""
+"The cache manager ( B<cachemgr.cgi> ) is a CGI utility for displaying "
+"statistics about the Squid HTTP proxy process as it runs. The cache manager "
+"is a convenient way to manage the cache and view statistics without logging "
+"into the server."
+msgstr ""
+"Le gestionnaire de cache (B<cachemgr.cgi>) est un utilitaire CGI qui sert a "
+"afficher les statistiques des processus de fonctionnement du proxy Squid sur "
+"HTTP. Le gestionnaire de cache est un moyen pratique de gérer le cache et de "
+"consulter les statistiques sans se connecter au serveur."
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:22
+msgid ""
+"Configuration examples for many common web servers can be found in the Squid "
+"FAQ wiki."
+msgstr ""
+"Vous peuvez trouver sur wiki des exemples de configuration pour de nombreux "
+"serveurs web commun et des FAQ qui s’appliquer à Squid."
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:34
+msgid ""
+"The access configuration file defining which Squid servers may be managed "
+"via this B<cachemgr.cgi> program. Each line specifies a B<server>:B<port> "
+"followed by an optional description"
+msgstr ""
+"L'accès aux fichiers de configuration pour définir les serveurs Squid peut "
+"être géré via le programme B<cachemgr.cgi>. Chaque ligne spécifie un "
+"B<server>:B<port> suivie d'une description facultative"
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:38
+msgid ""
+"The server name may contain shell wildcard characters such as *, [] etc.  A "
+"quick selection dropdown menu is automatically constructed from the simple "
+"server names."
+msgstr ""
+"Le nom du serveur peut contenir des caractères génériques du shell, "
+"tels que *, [], etc. Dans le menu déroulant, on sélectionne rapidement et "
+"automatiquement la construction à partir d'un simple nom de serveur."
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:42
+msgid ""
+"Specifying :port is optional. If not specified then the default proxy port "
+"is assumed. :* or :any matches any port on the target server."
+msgstr ""
+"Spécification : le port est facultatif. S'il n'est pas spécifié alors le "
+"port par défaut du proxy sera utilisé. Ou spécifier :* tous les ports "
+"correspondant au serveur cible."
+
+#. type: SH
+#: tools/cachemgr.cgi.8.in:43
+#, no-wrap
+msgid "SECURITY"
+msgstr "SÉCURITÉ"
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:50
+msgid ""
+"B<cachemgr.cgi> calls the requested server on the requested port using HTTP "
+"and returns a formatted version of the response. To avoid abuse it is "
+"recommended to configure your web server to restrict access to the "
+"B<cachemgr.cgi> program."
+msgstr ""
+"B<cachemgr.cgi> permet d'appeller le serveur demandé avec le port spécifié "
+"en utilisant HTTP et renvois une version formatée de la réponse. Pour éviter "
+"tout abus, il est recommandé de configurer votre serveur web pour restreindre "
+"l'accès au programme avec B<cachemgr.cgi>."
+
+#. type: Plain text
+#: tools/cachemgr.cgi.8.in:56 tools/squidclient.1:168
+msgid ""
+"Derived from Harvest. Further developed by by numerous individuals from the "
+"internet community. Development is led by Duane Wessels of the National "
+"Laboratory for Applied Network Research and funded by the National Science "
+"Foundation."
+msgstr ""
+"Dérivé de Harvest et développée par de nombreuses personnes de la communauté "
+"Internet. Le développement de squid est dirigé par Duane Wessels du National "
+"Laboratory for Applied Network Research et financé par National Science Foundation."
+
+#. type: Plain text
+#: tools/squidclient.1:7
+msgid "A simple HTTP web client tool"
+msgstr "Outil web pour un simple client HTTP"
+
+#. type: Plain text
+#: tools/squidclient.1:12 tools/squidclient.1:32
+msgid "count"
+msgstr "compte"
+
+#. type: Plain text
+#: tools/squidclient.1:14
+msgid "remote host"
+msgstr "hôte distant"
+
+#. type: Plain text
+#: tools/squidclient.1:16
+msgid "string"
+msgstr "chaîne"
+
+#. type: Plain text
+#: tools/squidclient.1:18
+msgid "IMS"
+msgstr "IMS"
+
+#. type: Plain text
+#: tools/squidclient.1:20
+msgid "ping interval"
+msgstr "Intervalle du ping"
+
+#. type: Plain text
+#: tools/squidclient.1:22
+msgid "Host header"
+msgstr "En-tête de l'hôte"
+
+#. type: Plain text
+#: tools/squidclient.1:24
+msgid "local host"
+msgstr "hôte local"
+
+#. type: Plain text
+#: tools/squidclient.1:26
+msgid "method"
+msgstr "méthode"
+
+#. type: Plain text
+#: tools/squidclient.1:30
+msgid "file"
+msgstr "fichier"
+
+#. type: Plain text
+#: tools/squidclient.1:36 tools/squidclient.1:38
+msgid "user"
+msgstr "utilisateur"
+
+#. type: Plain text
+#: tools/squidclient.1:40
+msgid "version"
+msgstr "Version"
+
+#. type: Plain text
+#: tools/squidclient.1:42 tools/squidclient.1:44
+msgid "password"
+msgstr "mot de passe"
+
+#. type: Plain text
+#: tools/squidclient.1:46
+msgid "url"
+msgstr "url"
+
+#. type: Plain text
+#: tools/squidclient.1:55
+msgid ""
+"B<squidclient> is a tool providing a command line interface for retrieving "
+"URLs.  Designed for testing any HTTP 0.9, 1.0, or 1.1 web server or proxy.  "
+"This tool can be combined with scripts to perform any basic HTTP operation.  "
+"Some additional features for access to the B<squid> proxy object cache and "
+"management information are provided."
+msgstr ""
+"B<squidclient> est un outil avec une interface en ligne de commande, pour "
+"accéder aux URL. Il a été conçu pour tester le serveur Web suivant les "
+"versions HTTP 0.9, 1.0, 1.1 ou un serveur proxy. Cet outil peut être combiné "
+"avec un script pour effectuer des opérations de base HTTP. Certaines "
+"fonctionnalités supplémentaires sont fournis, pour accéder à la gestion des "
+"informations et aux objet du cache proxy B<squid>."
+
+#. type: Plain text
+#: tools/squidclient.1:60
+msgid "Do NOT include Accept: header."
+msgstr "Dans l'en-tête ne PAS inclure Accept :"
+
+#. type: Plain text
+#: tools/squidclient.1:66
+msgid "Ping mode, perform I<count> iterations (0 to loop until interrupted)."
+msgstr ""
+"Mode ping, I<count> permet une répétition (boucle de 0 à ..., jusqu'à "
+"l'interrompu)."
+
+#. type: Plain text
+#: tools/squidclient.1:71
+msgid "Retrieve URL from cache on hostname.  Default is B<localhost>"
+msgstr ""
+"Accéde à l'URL du nom d'hôte dans la mémoire cache. Par défaut B<localhost>"
+
+#. type: Plain text
+#: tools/squidclient.1:77
+msgid "Extra headers to send. Use B<'\\n'> for new lines."
+msgstr ""
+"En-têtes HTTP supplémentaires à envoyer. Utiliser B<'\\n'> pour ajouter une "
+"nouvelle ligne."
+
+#. type: Plain text
+#: tools/squidclient.1:81
+msgid "If-Modified-Since time (in Epoch seconds)."
+msgstr "Temps pour If-Modified-Since (en seconde depuis Epoch)."
+
+#. type: Plain text
+#: tools/squidclient.1:85
+msgid "Ping interval in seconds (default 1 second)."
+msgstr "Intervalle du ping en seconde (par défaut 1 seconde)."
+
+#. type: Plain text
+#: tools/squidclient.1:89
+msgid "Host header content"
+msgstr "Contenu de l'en-tête de l'hôte"
+
+#. type: Plain text
+#: tools/squidclient.1:93
+msgid "Specify a local IP address to bind to.  Default is none."
+msgstr "Spécifier une adresse IP locale pour se connecter à. Par défaut aucune."
+
+#. type: Plain text
+#: tools/squidclient.1:108
+#, no-wrap
+msgid ""
+"Request method, default is\n"
+"I<GET.>\n"
+"Squid also supports a non-standard method called\n"
+"I<PURGE.>\n"
+"You can use that to purge a specific URL from the cache.\n"
+"You need to have\n"
+"I<purge>\n"
+"access setup in\n"
+"B<squid.conf>\n"
+"similar to\n"
+"I<manager>\n"
+" access. Here is an example:\n"
+msgstr ""
+"Méthode de requête par défaut\n"
+"I<GET.>\n"
+"Squid prend également en charge une méthode non-standard appelé\n"
+"I<PURGE.>\n"
+"Vous pouvez l'utiliser avec purger une URL spécifique à partir du cache.\n"
+"Vous devez avoir\n"
+"I<purge>\n"
+"pour accéder au setup dans\n"
+"B<squid.conf>\n"
+"Similaire à\n"
+"I<manager>\n"
+"qui peut aussi y accéder. Voici un exemple:\n"
+
+#. type: Plain text
+#: tools/squidclient.1:116
+msgid "Port number of cache.  Default is 3128."
+msgstr "Numéro de port du cache. Par défaut 3128."
+
+#. type: Plain text
+#: tools/squidclient.1:120
+msgid "Request body. Using the named file as data."
+msgstr "Corps de la requête. Utilisation du fichier nommé en tant que données."
+
+#. type: Plain text
+#: tools/squidclient.1:124
+msgid "Force cache to reload URL."
+msgstr "Forcer le cache pour recharger l'URL."
+
+#. type: Plain text
+#: tools/squidclient.1:128
+msgid "Silent.  Do not print data to stdout."
+msgstr "Silencieux. Ne pas imprimer les données sur la sortie standard."
+
+#. type: Plain text
+#: tools/squidclient.1:134
+msgid "Trace I<count> HTTP relay or proxy hops"
+msgstr ""
+"I<count> permet de passer à travers un relais HTTP ou un proxy pour tracer "
+"une connexion"
+
+#. type: Plain text
+#: tools/squidclient.1:138
+msgid "Timeout value (seconds) for read/write opérations."
+msgstr ""
+"Valeur du temps d'attente (en seconde) pour les operations de lecture/écriture."
+
+#. type: Plain text
+#: tools/squidclient.1:142
+msgid "Proxy authentication username"
+msgstr "Nom d'utilisateur pour l'authentification sur le Proxy"
+
+#. type: Plain text
+#: tools/squidclient.1:146
+msgid "WWW authentication username"
+msgstr "Nom d'utilisateur pour l'authentification sur le Web"
+
+#. type: Plain text
+#: tools/squidclient.1:150
+msgid "Verbose. Print outgoing message to stderr."
+msgstr "Commentaire. Impression des messages sortant, des erreurs standard."
+
+#. type: Plain text
+#: tools/squidclient.1:154
+msgid "HTTP Version. Use '-' for HTTP/0.9 omitted case"
+msgstr ""
+"Version HTTP. Utiliser le caractère '-' pour passer le cas de la version HTTP/0.9"
+
+#. type: Plain text
+#: tools/squidclient.1:158
+msgid "Proxy authentication password"
+msgstr "Mot de passe pour l'authentification sur le Proxy"
+
+#. type: Plain text
+#: tools/squidclient.1:162
+msgid "WWW authentication password"
+msgstr "Mot de passe pour l'authentification sur le Web"
@@ -0,0 +1,13 @@
+TRANSLATE_LANGUAGES= \
+    ar.lang \
+    cs.lang \
+    de.lang \
+    en.lang \
+    en_AU.lang \
+    es.lang \
+    fr.lang \
+    it.lang \
+    oc.lang \
+    pt.lang \
+    ro.lang \
+    ru.lang 
@@ -14,9 +14,9 @@ $(DOC).ps: $(DOC).sgml
 %.txt: %.sgml
 	linuxdoc -B txt --filter $<
 
-$(DOC).html: $(DOC).sgml
+%.html: %.sgml
 	linuxdoc -B html -T 2 --split=0 $<
-	perl -i -p -e "s%$(DOC).html%%" $(DOC).html
+	perl -i -p -e "s%$@%%" $@
 
 %.man: %.sgml
 	linuxdoc -B txt -T 2 -m $(DOC)
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.12.1 release notes</title>
+<title>Squid 3.1.12.2 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.12.1
+The Squid Team are pleased to announce the release of Squid-3.1.12.2
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.7 release notes</title>
+<title>Squid 3.2.0.8 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.7 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.8 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <HTML>
 <HEAD>
- <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.65">
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
  <TITLE>Squid 3.3.0.0 release notes</TITLE>
 </HEAD>
 <BODY>
@@ -24,7 +24,7 @@ <H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
 <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.2</A></H2>
 
 <UL>
-<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">...</A>
+<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1"></A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.2</A></H2>
@@ -87,15 +87,15 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.2</A></
 
 <P>The most important of these new features are:
 <UL>
-<LI>...</LI>
+<LI></LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
 
-<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">...</A>
+<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1"></A>
 </H2>
 
-<P>...</P>
+
 
 
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.2</A></H2>
@@ -128,9 +128,7 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 
 <P>
 <DL>
-<DT><B>logformat</B><DD>
-<P><EM>%&gt;bs</EM> Number of HTTP-equivalent message body bytes received from the next hop.</P>
-<P><EM>icap::%&gt;bs</EM> Number of message body bytes received from the ICAP server.</P>
+
 </DL>
 </P>
 
@@ -344,7 +342,6 @@ <H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Missing squid.conf options availab
 <P>Not yet ported from 2.6</P>
 
 <DT><B>cache_dir</B><DD>
-<P><EM>min-size</EM> option not yet ported from Squid-2</P>
 <P><EM>COSS</EM> storage type is lacking stability fixes from 2.6</P>
 <P>COSS <EM>overwrite-percent=</EM> option not yet ported from 2.6</P>
 <P>COSS <EM>max-stripe-waste=</EM> option not yet ported from 2.6</P>
@@ -396,13 +393,9 @@ <H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Missing squid.conf options availab
 <DT><B>logformat</B><DD>
 <P><EM>%oa</EM> tag not yet ported from 2.7</P>
 
-<DT><B>max_stale</B><DD>
-<P>Not yet ported from 2.7</P>
-
 <DT><B>refresh_pattern</B><DD>
 <P><EM>stale-while-revalidate=</EM> not yet ported from 2.7</P>
 <P><EM>ignore-stale-while-revalidate=</EM> not yet ported from 2.7</P>
-<P><EM>max-stale=</EM> not yet ported from 2.7</P>
 <P><EM>negative-ttl=</EM> not yet ported from 2.7</P>
 
 <DT><B>refresh_stale_hit</B><DD>
@@ -40,6 +40,8 @@ The 3.3 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 Most user-facing changes are reflected in squid.conf (see below).
 
 <sect1>
+<p>
+
 
 <sect>Changes to squid.conf since Squid-3.2
 <p>
@@ -57,6 +59,7 @@ This section gives a thorough account of those changes in three categories:
 <sect1>New tags<label id="newtags">
 <p>
 <descrip>
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -251,7 +254,6 @@ This section gives an account of those changes in three categories:
 	<p>Not yet ported from 2.6
 
 	<tag>cache_dir</tag>
-	<p><em>min-size</em> option not yet ported from Squid-2
 	<p><em>COSS</em> storage type is lacking stability fixes from 2.6
 	<p>COSS <em>overwrite-percent=</em> option not yet ported from 2.6
 	<p>COSS <em>max-stripe-waste=</em> option not yet ported from 2.6
@@ -303,13 +305,9 @@ This section gives an account of those changes in three categories:
 	<tag>logformat</tag>
 	<p><em>%oa</em> tag not yet ported from 2.7
 
-	<tag>max_stale</tag>
-	<p>Not yet ported from 2.7
-
 	<tag>refresh_pattern</tag>
 	<p><em>stale-while-revalidate=</em> not yet ported from 2.7
 	<p><em>ignore-stale-while-revalidate=</em> not yet ported from 2.7
-	<p><em>max-stale=</em> not yet ported from 2.7
 	<p><em>negative-ttl=</em> not yet ported from 2.7
 
 	<tag>refresh_stale_hit</tag>
@@ -11,95 +11,14 @@ DEFAULT_ERROR_DIR	= $(errordir)
 DEFAULT_STYLESHEET	= $(sysconfdir)/errorpage.css
 
 ## List of automated translations possible:
-ERROR_TEMPLATES =  \
-	templates/ERR_ACCESS_DENIED \
-	templates/ERR_ACL_TIME_QUOTA_EXCEEDED \
-	templates/ERR_CACHE_ACCESS_DENIED \
-	templates/ERR_CACHE_MGR_ACCESS_DENIED \
-	templates/ERR_CANNOT_FORWARD \
-	templates/ERR_CONNECT_FAIL \
-	templates/ERR_DIR_LISTING \
-	templates/ERR_DNS_FAIL \
-	templates/ERR_ESI \
-	templates/ERR_FORWARDING_DENIED \
-	templates/ERR_FTP_DISABLED \
-	templates/ERR_FTP_FAILURE \
-	templates/ERR_FTP_FORBIDDEN \
-	templates/ERR_FTP_NOT_FOUND \
-	templates/ERR_FTP_PUT_CREATED \
-	templates/ERR_FTP_PUT_ERROR \
-	templates/ERR_FTP_PUT_MODIFIED \
-	templates/ERR_FTP_UNAVAILABLE \
-	templates/ERR_GATEWAY_FAILURE \
-	templates/ERR_ICAP_FAILURE \
-	templates/ERR_INVALID_REQ \
-	templates/ERR_INVALID_RESP \
-	templates/ERR_INVALID_URL \
-	templates/ERR_LIFETIME_EXP \
-	templates/ERR_NO_RELAY \
-	templates/ERR_ONLY_IF_CACHED_MISS \
-	templates/ERR_PRECONDITION_FAILED \
-	templates/ERR_READ_ERROR \
-	templates/ERR_READ_TIMEOUT \
-	templates/ERR_SECURE_CONNECT_FAIL \
-	templates/ERR_SHUTTING_DOWN \
-	templates/ERR_SOCKET_FAILURE \
-	templates/ERR_TOO_BIG \
-	templates/ERR_UNSUP_HTTPVERSION \
-	templates/ERR_UNSUP_REQ \
-	templates/ERR_URN_RESOLVE \
-	templates/ERR_WRITE_ERROR \
-	templates/ERR_ZERO_SIZE_OBJECT
-
-TRANSLATE_LANGUAGES = \
-	af.lang \
-	ar.lang \
-	az.lang \
-	bg.lang \
-	ca.lang \
-	cs.lang \
-	da.lang \
-	de.lang \
-	el.lang \
-	en.lang \
-	es.lang \
-	et.lang \
-	fa.lang \
-	fi.lang \
-	fr.lang \
-	he.lang \
-	hu.lang \
-	hy.lang \
-	id.lang \
-	it.lang \
-	ja.lang \
-	ko.lang \
-	lt.lang \
-	lv.lang \
-	ms.lang \
-	nl.lang \
-	oc.lang \
-	pl.lang \
-	pt-br.lang \
-	pt.lang \
-	ro.lang \
-	ru.lang \
-	sk.lang \
-	sl.lang \
-	sr-cyrl.lang \
-	sr-latn.lang \
-	sv.lang \
-	th.lang \
-	tr.lang \
-	uk.lang \
-	uz.lang \
-	vi.lang \
-	zh-cn.lang \
-	zh-tw.lang
+include $(srcdir)/template.list
+include $(srcdir)/language.list
 
 CLEANFILES = $(TRANSLATE_LANGUAGES) translate-warn
 EXTRA_DIST = \
 	$(ERROR_TEMPLATES) \
+	language.list \
+	template.list \
 	aliases alias-link.sh alias-upgrade errorpage.css TRANSLATORS COPYRIGHT
 
 all: all-am
@@ -3,52 +3,52 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2011-05-04 13:57+1300\n"
-"PO-Revision-Date: 2011-02-24 19:27+0200\n"
+"PO-Revision-Date: 2011-05-30 17:27+0200\n"
 "Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: fr\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n > 1);\n"
-"X-Generator: Pootle 2.0.5\n"
+"X-Generator: Pootle 2.0.6\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:30
 msgid "%F"
-msgstr ""
+msgstr "%F"
 
 #: templates/ERR_INVALID_REQ+html.body.div.blockquote.pre:23
 #: templates/ERR_INVALID_RESP+html.body.div.blockquote.pre:23
 msgid "%R"
-msgstr ""
+msgstr "%R"
 
 #: templates/ERR_ESI+html.body.div.blockquote.pre:28
 msgid "%Z"
-msgstr ""
+msgstr "%Z"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:25
 msgid "%f"
-msgstr ""
+msgstr "%f"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:31
 msgid "%g"
-msgstr ""
+msgstr "%g"
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
 msgid "%z"
-msgstr ""
+msgstr "%z"
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
@@ -321,7 +321,6 @@ msgstr "Le fichier a été mis à jour"
 msgid "For Firefox browsers go to: <ul>"
 msgstr "Pour configurer Firefox, allez à : <ul>"
 
-# Suggestion2 ok
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:34
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:34
 msgid "For Internet Explorer browsers go to: <ul>"
@@ -422,7 +421,7 @@ msgstr ""
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:33
 msgid "Illegal character in hostname; underscores are not allowed."
 msgstr ""
-"Caractère non valide dans le nom d'hôte; les Caractères soulignés "
+"Caractère non valide dans le nom d'hôte; Les caractères soulignés "
 "(underscores) ne sont pas autorisés."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
@@ -432,11 +431,10 @@ msgstr "Les double espaces ne sont pas valides dans une adresse URL"
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:46
-#, fuzzy
 msgid "In the HTTP proxy box type the proxy name %h and port %b."
 msgstr ""
-"Vous devez indiquer le nom du proxy %h et le port 3128 dans l'onglet proxy "
-"du HTTP"
+"Vous devez indiquer dans la fenêtre du proxy HTTP, le nom du proxy %h et le "
+"port 3128"
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
 msgid "Invalid URL"
@@ -515,9 +513,9 @@ msgid "Request is too large."
 msgstr "La requête est trop volumineuse"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
-#, fuzzy
 msgid "Select Auto-detect proxy settings for this network"
-msgstr "Sélectionnez la détection automatique des paramètres"
+msgstr ""
+"Sélectionnez détection automatique des paramètres de proxy pour ce réseau"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
@@ -0,0 +1,45 @@
+TRANSLATE_LANGUAGES= \
+    af.lang \
+    ar.lang \
+    az.lang \
+    bg.lang \
+    ca.lang \
+    cs.lang \
+    da.lang \
+    de.lang \
+    el.lang \
+    en.lang \
+    es.lang \
+    et.lang \
+    fa.lang \
+    fi.lang \
+    fr.lang \
+    he.lang \
+    hu.lang \
+    hy.lang \
+    id.lang \
+    it.lang \
+    ja.lang \
+    ko.lang \
+    lt.lang \
+    lv.lang \
+    ms.lang \
+    nl.lang \
+    oc.lang \
+    pl.lang \
+    pt-br.lang \
+    pt.lang \
+    ro.lang \
+    ru.lang \
+    sk.lang \
+    sl.lang \
+    sr-cyrl.lang \
+    sr-latn.lang \
+    sv.lang \
+    th.lang \
+    tr.lang \
+    uk.lang \
+    uz.lang \
+    vi.lang \
+    zh-cn.lang \
+    zh-tw.lang 
@@ -1,36 +0,0 @@
-ERR_ACCESS_DENIED
-ERR_CACHE_ACCESS_DENIED
-ERR_CACHE_MGR_ACCESS_DENIED
-ERR_CANNOT_FORWARD
-ERR_CONNECT_FAIL
-ERR_DIR_LISTING
-ERR_DNS_FAIL
-ERR_ESI
-ERR_FORWARDING_DENIED
-ERR_FTP_DISABLED
-ERR_FTP_FAILURE
-ERR_FTP_FORBIDDEN
-ERR_FTP_NOT_FOUND
-ERR_FTP_PUT_CREATED
-ERR_FTP_PUT_ERROR
-ERR_FTP_PUT_MODIFIED
-ERR_FTP_UNAVAILABLE
-ERR_ICAP_FAILURE
-ERR_INVALID_REQ
-ERR_INVALID_RESP
-ERR_INVALID_URL
-ERR_LIFETIME_EXP
-ERR_NO_RELAY
-ERR_ONLY_IF_CACHED_MISS
-ERR_PRECONDITION_FAILED
-ERR_READ_ERROR
-ERR_READ_TIMEOUT
-ERR_SECURE_CONNECT_FAIL
-ERR_SHUTTING_DOWN
-ERR_SOCKET_FAILURE
-ERR_TOO_BIG
-ERR_UNSUP_HTTPVERSION
-ERR_UNSUP_REQ
-ERR_URN_RESOLVE
-ERR_WRITE_ERROR
-ERR_ZERO_SIZE_OBJECT
@@ -3,16 +3,16 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2011-05-04 13:57+1300\n"
-"PO-Revision-Date: 2011-05-11 04:55+0200\n"
-"Last-Translator: Aleksa Šušulić <susulic@gmail.com>\n"
+"PO-Revision-Date: 2011-05-24 10:57+0200\n"
+"Last-Translator: Aleksa <susulic@gmail.com>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: sl\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=4; plural=(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || "
 "n%100==4 ? 2 : 3);\n"
-"X-Generator: Pootle 2.0.5\n"
+"X-Generator: Pootle 2.0.6\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -59,25 +59,25 @@ msgstr "<a href=\"../\">Nadrejeni imenik</a> (<a href=\"/\">Korenski imenik</a>)
 msgid ""
 "<b>Invalid Request</b> error was encountered while trying to process the "
 "request:"
-msgstr "<b>Neveljavna zahteva</b> prišlo je do napake med izvajanjem zahteve:"
+msgstr "Prišlo je do napake <b>neveljavna zahteva</b> med izvajanjem zahteve:"
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:20
 msgid ""
 "<b>Invalid Response</b> error was encountered while trying to process the "
 "request:"
-msgstr "<b>Neveljaven odgovor</b> prišlo je do napake med izvajanjem zahteve:"
+msgstr "Prišlo je do napake <b>neveljaven odgovor</b> med izvajanjem zahteve:"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
 msgid ""
 "A Timeout occurred while waiting to read data from the network. The network "
 "or server may be down or congested. Please retry your request."
 msgstr ""
 "Med čakanjem na branje podatkov iz omrežja je prišlo do zakasnitve. Morda "
-"sta omrežje ali strežnik preobremenjena. Ponovite zahtevo!"
+"omrežje ali strežnik ne delujeta ali sta preobremenjena. Ponovite zahtevo!"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.h2:15
 msgid "A URL for the requested URN could not be retrieved"
-msgstr "Ni bilo mogoče pridobiti naslova URL za zahtevani URN"
+msgstr "Ni bilo mogoče naložiti naslova URL za zahtevano ime URN"
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:26
 msgid ""
@@ -98,15 +98,15 @@ msgid ""
 "incorrect."
 msgstr ""
 "Vaša zahteva trenutno ni odobrena, ker to preprečujejo nastavitve nadzora "
-"dostopa. Obrnite se na svojega ponudnika storitev, če se vam to zdi "
-"neutemeljeno."
+"dostopa. Obrnite se na svojega ponudnika storitev, če se vam zdi, da "
+"je to neutemeljeno."
 
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:20
 msgid ""
 "An FTP authentication failure occurred while trying to retrieve the URL: <a "
 "href=\"%U\">%U</a>"
 msgstr ""
-"Spodletela je avtentikacija FTP med poskusom pridobivanja naslova URL: <a "
+"Spodletela je avtentikacija FTP med poskusom nalaganja naslova URL: <a "
 "href=\"%U\">%U</a>"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.p:20
@@ -115,7 +115,7 @@ msgid ""
 "An FTP protocol error occurred while trying to retrieve the URL: <a href=\"%U"
 "\">%U</a>"
 msgstr ""
-"Prišlo je do napake protokola FTP med poskusom pridobivanja naslova URL: <a "
+"Prišlo je do napake protokola FTP med poskusom nalaganja naslova URL: <a "
 "href=\"%U\">%U</a>"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:33
@@ -154,19 +154,19 @@ msgstr "Dostop do upravitelja predpomnilnika zavrnjen."
 
 #: templates/ERR_URN_RESOLVE+html.body.div.blockquote.p:23
 msgid "Cannot Resolve URN"
-msgstr "Ni mogoče razrešiti naslova URN"
+msgstr "Ni mogoče razrešiti imena URN"
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
 msgstr "Povezava je potekla"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Connection to %I failed."
-msgstr "Povezava na %I ni uspela."
+msgstr "Povezava z %I ni uspela."
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:32
 msgid "Content-Length missing for POST or PUT requests."
-msgstr "Manjka podatek o dolžini Content-Length za zahteve POST ali PUT."
+msgstr "Manjka podatek Content-Length za zahteve POST ali PUT."
 
 #: templates/ERR_DIR_LISTING+html.body.div.h4:19
 msgid "Directory Content:"
@@ -266,11 +266,11 @@ msgstr "NAPAKA: Pošiljanje prek FTP spodletelo"
 #: templates/ERR_WRITE_ERROR+html.head.title:4
 #: templates/ERR_ZERO_SIZE_OBJECT+html.head.title:4
 msgid "ERROR: The requested URL could not be retrieved"
-msgstr "NAPAKA: Zahtevanega naslova URL ni bilo mogoče pridobiti."
+msgstr "NAPAKA: Zahtevanega naslova URL ni bilo mogoče naložiti."
 
 #: templates/ERR_URN_RESOLVE+html.head.title:4
 msgid "ERROR: The requested URN could not be retrieved"
-msgstr "NAPAKA: Zahtevanega naslova URN ni bilo mogoče pridobiti"
+msgstr "NAPAKA: Zahtevanega imena URN ni bilo mogoče naložiti"
 
 #: templates/ERR_ESI+html.body.div.blockquote.p:23
 msgid "ESI Processing failed."
@@ -291,7 +291,7 @@ msgstr "FTP je onemogočen"
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Failed to establish a secure connection to %I"
-msgstr "Ni bilo mogoče vzpostaviti varne povezave do %I"
+msgstr "Ni bilo mogoče vzpostaviti varne povezave z %I"
 
 #: templates/ERR_FTP_PUT_CREATED+html.body.div.h2:15
 msgid "File created"
@@ -364,7 +364,7 @@ msgstr "Napaka posredniškega prehoda"
 #: templates/ERR_WRITE_ERROR+html.body.div.p:36
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.p:34
 msgid "Generated %T by %h (%s)"
-msgstr "Ustvaril %h (%s) %T"
+msgstr "Ustvaril %h (%s) dne %T"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:34
 msgid ""
@@ -373,7 +373,7 @@ msgstr "Prvina HTTP/1.1 <q>Expect:</q> se zahteva od programa HTTP/1.0."
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:26
 msgid "Hey, don't expect too much from URNs on %T :)"
-msgstr "Od naslovov URN na %T ne pričakujte preveč :)"
+msgstr "Od imen URN na %T ne pričakujte preveč :)"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.p:24
 #: templates/ERR_AGENT_WPAD+html.body.div.p:24
@@ -402,18 +402,18 @@ msgstr ""
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:33
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:33
 msgid "Illegal character in hostname; underscores are not allowed."
-msgstr "Neveljaven znak v imenu strežnika; podčrtaji niso dovoljeni."
+msgstr "Neveljaven znak v imenu gostitelja; podčrtaji niso dovoljeni."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
 msgid "Illegal double-escape in the URL-Path"
-msgstr "Neveljaven dvojni ubežni znak v naslovu URL-Path"
+msgstr "Neveljaven dvojni ubežni znak v poti URL-Path"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:46
 msgid "In the HTTP proxy box type the proxy name %h and port %b."
 msgstr ""
-"V okvir za posredniški strežnik HTTP vnesite ime posredniškega strežnika %h "
+"V polje za posredniški strežnik HTTP vnesite ime posredniškega strežnika %h "
 "in vrata %b."
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
@@ -430,7 +430,7 @@ msgstr "Manjka naslov URL."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:31
 msgid "Missing hostname"
-msgstr "Manjka ime strežnika"
+msgstr "Manjka ime gostitelja"
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:30
 msgid ""
@@ -471,7 +471,7 @@ msgstr ""
 "Obrnite se na <a href=\"mailto:%w%W\">skrbnika predpomnilnika</a>, če imate "
 "težave pri avtentikaciji; če pa ste skrbnik <em>vi</em>, se iz dokumentacije "
 "programa Squid poučite o vmesniku upravitelja predpomnilnika in v dnevniku "
-"predpomnilnika poiščite natančnejša sporočila o napakah."
+"predpomnilnika poiščite podrobnejša sporočila o napakah."
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:23
 msgid "Precondition Failed."
@@ -577,7 +577,7 @@ msgstr "Opravilnik ESI je odgovoril:"
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.p:20
 msgid "The FTP server was too busy to retrieve the URL: <a href=\"%U\">%U</a>"
 msgstr ""
-"Strežnik FTP je bil prezaseden, da bi pridobil naslov URL: <a href=\"%U\">%"
+"Strežnik FTP je bil prezaseden, da bi naložil naslov URL: <a href=\"%U\">%"
 "U</a>"
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:26
@@ -594,7 +594,7 @@ msgstr "Strežnik ICAP ni dosegljiv."
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:20
 msgid "The following URL could not be retrieved: <a href=\"%U\">%U</a>"
-msgstr "Naslednjega naslova URL ni bilo mogoče pridobiti: <a href=\"%U\">%U</a>"
+msgstr "Naslednjega naslova URL ni bilo mogoče naložiti: <a href=\"%U\">%U</a>"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:20
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.p:21
@@ -626,21 +626,21 @@ msgid ""
 "The following error was encountered while trying to retrieve the URL: <a "
 "href=\"%U\">%U</a>"
 msgstr ""
-"Prišlo je do napake med poskusom pridobivanja naslova URL: <a href=\"%U\">%"
+"Prišlo je do napake med poskusom nalaganja naslova URL: <a href=\"%U\">%"
 "U</a>"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:20
 msgid ""
 "The following error was encountered while trying to retrieve the URN: <a "
 "href=\"%U\">%U</a>"
 msgstr ""
-"Prišlo je do napake med poskusom pridobivanja naslova URN: <a href=\"%U\">%"
+"Prišlo je do napake med poskusom nalaganja URN: <a href=\"%U\">%"
 "U</a>"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.p:28
 msgid "The remote host or network may be down. Please try the request again."
 msgstr ""
-"Oddaljeni strežnik ali omrežje morda ne delujeta. Poskusite ponoviti "
+"Oddaljeni gostitelj ali omrežje morda ne delujeta. Poskusite ponoviti "
 "zahtevo!"
 
 #: templates/ERR_TOO_BIG+html.body.div.blockquote.p:23
@@ -677,7 +677,7 @@ msgstr "Zahteva ali odgovor sta preobsežna."
 #: templates/ERR_WRITE_ERROR+html.body.div.h2:15
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.h2:15
 msgid "The requested URL could not be retrieved"
-msgstr "Zahtevanega naslova URL ni bilo mogoče pridobiti"
+msgstr "Zahtevanega naslova URL ni bilo mogoče naložiti"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.p:27
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:27
@@ -738,7 +738,7 @@ msgid ""
 msgstr ""
 "Ta predpomnilnik ne bo posredoval vaše zahteve, ker skuša uveljaviti "
 "vrstniško povezavo. Odjemalec na naslovu %i je morda predpomnilnik, ki ni "
-"pravilno konfiguriran."
+"pravilno nastavljen."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:28
 msgid ""
@@ -812,9 +812,9 @@ msgid ""
 "all configured parent caches are currently unreachable."
 msgstr ""
 "Te zahteve ni bilo mogoče posredovati izvornemu strežniku ali nadrejenim "
-"predpomnilnikom. Vzrok za to napako je najverjetneje to, da skrbnik "
+"predpomnilnikom. Vzrok za napako je najverjetneje to, da skrbnik "
 "predpomnilnika ne dovoli, da bi ta predpomnilnik vzpostavljal neposredne "
-"povezave z izvornimi strežniki, konfigurirani nadrejeni predpomnilniki pa so "
+"povezave z izvornimi strežniki, nastavljeni nadrejeni predpomnilniki pa so "
 "trenutno vsi nedosegljivi."
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:37
@@ -862,7 +862,7 @@ msgid ""
 "Valid document was not found in the cache and <q>only-if-cached</q> "
 "directive was specified."
 msgstr ""
-"V predpomnilniku ni mogoče najti veljavnega dokumenta, podana pa je bila "
+"V predpomnilniku ni najti veljavnega dokumenta, podana pa je bila "
 "direktiva <q>only-if-cached</q>."
 
 #: templates/ERR_AGENT_CONFIGURE+html.head.title:4
@@ -934,8 +934,8 @@ msgid ""
 "Your cache administrator may be able to provide you with more details about "
 "the exact nature of the problem if needed."
 msgstr ""
-"Če je potrebno, vam lahko skrbnik vašega predpomnilnika postreže z "
-"natančnejšimi podatki o tem, za kakšne vrste težavo gre."
+"Po potrebi vam lahko skrbnik vašega predpomnilnika natančneje razloži, "
+"za kakšne vrste težavo gre."
 
 #: templates/ERR_ESI+html.body.div.p:33
 msgid "Your webmaster is <a href=\"mailto:%w\">%w</a>."
@@ -0,0 +1,41 @@
+ERROR_TEMPLATES= \
+    templates/ERR_ACCESS_DENIED \
+    templates/ERR_ACL_TIME_QUOTA_EXCEEDED \
+    templates/ERR_AGENT_CONFIGURE \
+    templates/ERR_AGENT_WPAD \
+    templates/ERR_CACHE_ACCESS_DENIED \
+    templates/ERR_CACHE_MGR_ACCESS_DENIED \
+    templates/ERR_CANNOT_FORWARD \
+    templates/ERR_CONNECT_FAIL \
+    templates/ERR_DIR_LISTING \
+    templates/ERR_DNS_FAIL \
+    templates/ERR_ESI \
+    templates/ERR_FORWARDING_DENIED \
+    templates/ERR_FTP_DISABLED \
+    templates/ERR_FTP_FAILURE \
+    templates/ERR_FTP_FORBIDDEN \
+    templates/ERR_FTP_NOT_FOUND \
+    templates/ERR_FTP_PUT_CREATED \
+    templates/ERR_FTP_PUT_ERROR \
+    templates/ERR_FTP_PUT_MODIFIED \
+    templates/ERR_FTP_UNAVAILABLE \
+    templates/ERR_GATEWAY_FAILURE \
+    templates/ERR_ICAP_FAILURE \
+    templates/ERR_INVALID_REQ \
+    templates/ERR_INVALID_RESP \
+    templates/ERR_INVALID_URL \
+    templates/ERR_LIFETIME_EXP \
+    templates/ERR_NO_RELAY \
+    templates/ERR_ONLY_IF_CACHED_MISS \
+    templates/ERR_PRECONDITION_FAILED \
+    templates/ERR_READ_ERROR \
+    templates/ERR_READ_TIMEOUT \
+    templates/ERR_SECURE_CONNECT_FAIL \
+    templates/ERR_SHUTTING_DOWN \
+    templates/ERR_SOCKET_FAILURE \
+    templates/ERR_TOO_BIG \
+    templates/ERR_UNSUP_HTTPVERSION \
+    templates/ERR_UNSUP_REQ \
+    templates/ERR_URN_RESOLVE \
+    templates/ERR_WRITE_ERROR \
+    templates/ERR_ZERO_SIZE_OBJECT 
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>Web Browser Configuration</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>Web Browser Configuration</h2>
@@ -7,10 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head>
-<body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>Cache Access Denied.</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>Cache Manager Access Denied.</h2>
@@ -7,10 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head>
-<body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h2>Directory: <a href="%U">%U</a>/</h2>
 </div>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1 id="ftpsuccess">Operation successful</h1>
 <h2>File created</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>FTP PUT upload failed</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1 id="ftpsuccess">Operation successful</h1>
 <h2>File updated</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -25,9 +25,9 @@ body
 
 <p>Some possible problems are:</p>
 <ul>
-<li><p>Missing or unknown request method.</p></li>
-<li><p>Missing URL.</p></li>
-<li><p>Missing HTTP Identifier (HTTP/1.0).</p></li>
+<li id="missing-method"><p>Missing or unknown request method.</p></li>
+<li id="missing-url"><p>Missing URL.</p></li>
+<li id="missing-protocol"><p>Missing HTTP Identifier (HTTP/1.0).</p></li>
 <li><p>Request is too large.</p></li>
 <li><p>Content-Length missing for POST or PUT requests.</p></li>
 <li><p>Illegal character in hostname; underscores are not allowed.</p></li>
@@ -38,6 +38,12 @@ body
 <br>
 </div>
 
+<script language="javascript">
+if ('%M' != '[unknown method]') document.getElementById('missing-method').style.display = 'none';
+if ('%u' != '[no URL]') document.getElementById('missing-url').style.display = 'none';
+if ('%P' != '[unknown protocol]') document.getElementById('missing-protocol').style.display = 'none';
+</script>
+
 <hr>
 <div id="footer">
 <p>Generated %T by %h (%s)</p>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>Unsupported HTTP version</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>A URL for the requested URN could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -7,9 +7,9 @@
 
 body
 :lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
-:lang(he) { direction: rtl; float: right; }
+:lang(he) { direction: rtl; }
  --></style>
-</head><body>
+</head><body id=%c>
 <div id="titles">
 <h1>ERROR</h1>
 <h2>The requested URL could not be retrieved</h2>
@@ -230,7 +230,6 @@ main(int argc, char **argv)
     int use_extension_dn = 0;
     int strip_nt_domain = 0;
     int strip_kerberos_realm = 0;
-    int err = 0;
 
     setbuf(stdout, NULL);
 
@@ -613,7 +612,6 @@ main(int argc, char **argv)
                 tryagain = 1;
             }
         }
-        err = 0;
     }
     if (ld)
         ldap_unbind(ld);
@@ -96,7 +96,8 @@ static void vlog(const char *level, const char *format, va_list args)
 {
     time_t now = time(NULL);
 
-    fprintf(logfile, "%ld %s| %s: ", now, program_name, level);
+    fprintf(logfile, "%ld %s| %s: ", static_cast<long int>(now),
+            program_name, level);
     vfprintf (logfile, format, args);
     fflush(logfile);
 }
@@ -57,7 +57,7 @@
 /// \ingroup MemPoolsAPI
 #define MEM_MIN_FREE  32
 /// \ingroup MemPoolsAPI
-#define MEM_MAX_FREE  65535	/* ushort is max number of items per chunk */
+#define MEM_MAX_FREE  65535	/* u_short is max number of items per chunk */
 
 class MemImplementingAllocator;
 class MemPoolStats;
@@ -12,7 +12,7 @@
 /// \ingroup MemPoolsAPI
 #define MEM_MIN_FREE  32
 /// \ingroup MemPoolsAPI
-#define MEM_MAX_FREE  65535	/* ushort is max number of items per chunk */
+#define MEM_MAX_FREE  65535	/* u_short is max number of items per chunk */
 
 class MemChunk;
 
@@ -127,7 +127,7 @@ echo "#endif" >>${ROOT}/lib/profiler/list
 echo "#endif" >>${ROOT}/lib/profiler/list
 mv ${ROOT}/lib/profiler/list ${ROOT}/lib/profiler/xprof_type.h
 
-# Build icons install include form current icons available
+# Build icons install include from current icons available
 (
 echo -n "ICONS="
 for f in `ls -1 ${ROOT}/icons/silk/*`
@@ -138,6 +138,39 @@ done
 echo " "
 )| sed s%${ROOT}/icons/%%g >${ROOT}/icons/list
 
+# Build templates install include from current templates available
+(
+echo -n "ERROR_TEMPLATES="
+for f in `ls -1 ${ROOT}/errors/templates/ERR_*`
+do
+	echo " \\"
+	echo -n "    ${f}"
+done
+echo " "
+)| sed s%${ROOT}/errors/%%g >${ROOT}/errors/template.list
+
+# Build errors translation install include from current .PO available
+(
+echo -n "TRANSLATE_LANGUAGES="
+for f in `ls -1 ${ROOT}/errors/*.po`
+do
+	echo " \\"
+	echo -n "    ${f}"
+done
+echo " "
+)| sed s%${ROOT}/errors/%%g | sed s%\.po%\.lang%g >${ROOT}/errors/language.list
+
+# Build manuals translation install include from current .PO available
+(
+echo -n "TRANSLATE_LANGUAGES="
+for f in `ls -1 ${ROOT}/doc/manuals/*.po`
+do
+	echo " \\"
+	echo -n "    ${f}"
+done
+echo " "
+)| sed s%${ROOT}/doc/manuals/%%g | sed s%\.po%\.lang%g >${ROOT}/doc/manuals/language.list
+
 # Run formating
 echo "" >${ROOT}/doc/debug-sections.tmp
 srcformat || exit 1
@@ -58,7 +58,7 @@ void ClientDelayConfig::parsePoolCount()
 
 void ClientDelayConfig::parsePoolRates()
 {
-    ushort pool;
+    u_short pool;
     ConfigParser::ParseUShort(&pool);
 
     if (pool < 1 || pool > pools.size()) {
@@ -74,7 +74,7 @@ void ClientDelayConfig::parsePoolRates()
 
 void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
 {
-    ushort pool;
+    u_short pool;
 
     ConfigParser::ParseUShort(&pool);
 
@@ -73,7 +73,9 @@ class CompositePoolNode : public RefCountable, public Updateable
         CompositeSelectionDetails() {}
 
         Ip::Address src_addr;
+#if USE_AUTH
         AuthUserRequest::Pointer user;
+#endif
         String tag;
     };
 
@@ -60,7 +60,7 @@ DelayConfig::parsePoolCount()
 void
 DelayConfig::parsePoolClass()
 {
-    ushort pool;
+    u_short pool;
 
     ConfigParser::ParseUShort(&pool);
 
@@ -69,7 +69,7 @@ DelayConfig::parsePoolClass()
         return;
     }
 
-    ushort delay_class_;
+    u_short delay_class_;
     ConfigParser::ParseUShort(&delay_class_);
 
     if (delay_class_ < 1 || delay_class_ > 5) {
@@ -85,7 +85,7 @@ DelayConfig::parsePoolClass()
 void
 DelayConfig::parsePoolRates()
 {
-    ushort pool;
+    u_short pool;
     ConfigParser::ParseUShort(&pool);
 
     if (pool < 1 || pool > DelayPools::pools()) {
@@ -106,7 +106,7 @@ DelayConfig::parsePoolRates()
 void
 DelayConfig::parsePoolAccess(ConfigParser &parser)
 {
-    ushort pool;
+    u_short pool;
 
     ConfigParser::ParseUShort(&pool);
 
@@ -131,7 +131,9 @@ DelayId::DelayClient(ClientHttpRequest * http)
             DelayId result (pool + 1);
             CompositePoolNode::CompositeSelectionDetails details;
             details.src_addr = ch.src_addr;
+#if USE_AUTH
             details.user = r->auth_user_request;
+#endif
             details.tag = r->tag;
             result.compositePosition(DelayPools::delay_data[pool].theComposite()->id(details));
             return result;
@@ -37,7 +37,7 @@
 
 #include "config.h"
 
-#if USE_DELAY_POOLS
+#if USE_DELAY_POOLS && USE_AUTH
 #include "squid.h"
 #include "DelayUser.h"
 #include "auth/UserRequest.h"
@@ -236,4 +236,4 @@ DelayUser::Id::bytesIn(int qty)
     theBucket->theBucket.bytesIn(qty);
 }
 
-#endif
+#endif /* USE_DELAY_POOLS && USE_AUTH */
@@ -36,7 +36,7 @@
 #ifndef DELAYUSER_H
 #define DELAYUSER_H
 
-#if USE_DELAY_POOLS
+#if USE_DELAY_POOLS && USE_AUTH
 
 #include "squid.h"
 #include "auth/Gadgets.h"
@@ -106,5 +106,5 @@ class DelayUser : public CompositePoolNode
     Splay<DelayUserBucket::Pointer> buckets;
 };
 
-#endif /* USE_DELAY_POOLS */
+#endif /* USE_DELAY_POOLS && USE_AUTH */
 #endif /* DELAYUSER_H */
@@ -123,7 +123,6 @@ AIODiskIOStrategy::callback()
     void *cbdata;
     int callback_valid;
     void *buf;
-    int filedescriptor;
     async_queue_entry_t *aqe;
     async_queue_entry_type_t type;
 
@@ -148,7 +147,6 @@ AIODiskIOStrategy::callback()
                 /* Get the callback parameters */
                 freefunc = aqe->aq_e_free;
                 buf = aqe->aq_e_buf;
-                filedescriptor = aqe->aq_e_fd;
                 type = aqe->aq_e_type;
                 callback_valid = cbdataReferenceValidDone(aqe->aq_e_callback_data, &cbdata);
                 AIODiskFile * theFile = NULL;
@@ -336,32 +336,64 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
     const char *end, *pos;
     val->clean();
     if (*start != '"') {
-        debugs(66, 2, "failed to parse a quoted-string header field near '" << start << "'");
+        debugs(66, 2, HERE << "failed to parse a quoted-string header field near '" << start << "'");
         return 0;
     }
     pos = start + 1;
 
     while (*pos != '"' && len > (pos-start)) {
+
+        if (*pos =='\r') {
+            pos++;
+            if ((pos-start) > len || *pos != '\n') {
+                debugs(66, 2, HERE << "failed to parse a quoted-string header field with '\\r' octet " << (start-pos)
+                       << " bytes into '" << start << "'");
+                val->clean();
+                return 0;
+            }
+        }
+
+        if (*pos == '\n') {
+            pos++;
+            if ( (pos-start) > len || (*pos != ' ' && *pos != '\t')) {
+                debugs(66, 2, HERE << "failed to parse multiline quoted-string header field '" << start << "'");
+                val->clean();
+                return 0;
+            }
+            // TODO: replace the entire LWS with a space
+            val->append(" ");
+            pos++;
+            debugs(66, 2, HERE << "len < pos-start => " << len << " < " << (pos-start));
+            continue;
+        }
+
         bool quoted = (*pos == '\\');
-        if (quoted)
+        if (quoted) {
             pos++;
-        if (!*pos || (pos-start) > len) {
-            debugs(66, 2, "failed to parse a quoted-string header field near '" << start << "'");
-            val->clean();
-            return 0;
+            if (!*pos || (pos-start) > len) {
+                debugs(66, 2, HERE << "failed to parse a quoted-string header field near '" << start << "'");
+                val->clean();
+                return 0;
+            }
         }
         end = pos;
-        while (end <= (start+len) && *end != '\\' && *end != '\"' && *end > 0x1F && *end != 0x7F)
+        while (end < (start+len) && *end != '\\' && *end != '\"' && *end > 0x1F && *end != 0x7F)
             end++;
-        if (*end <= 0x1F || *end == 0x7F) {
-            debugs(66, 2, "failed to parse a quoted-string header field with CTL octet " << (start-pos)
+        if ((*end <= 0x1F && *end != '\r' && *end != '\n') || *end == 0x7F) {
+            debugs(66, 2, HERE << "failed to parse a quoted-string header field with CTL octet " << (start-pos)
                    << " bytes into '" << start << "'");
             val->clean();
             return 0;
         }
         val->append(pos, end-pos);
         pos = end;
     }
+
+    if (*pos != '\"') {
+        debugs(66, 2, HERE << "failed to parse a quoted-string header field which did not end with \" ");
+        val->clean();
+        return 0;
+    }
     /* Make sure it's defined even if empty "" */
     if (!val->defined())
         val->limitInit("", 0);
@@ -374,299 +374,3 @@ HttpMsg::_unlock()
     if (0 == lock_count)
         delete this;
 }
-
-
-void
-HttpParserInit(HttpParser *hdr, const char *buf, int bufsiz)
-{
-    hdr->clear();
-    hdr->state = 1;
-    hdr->buf = buf;
-    hdr->bufsiz = bufsiz;
-    debugs(74, 5, "httpParseInit: Request buffer is " << buf);
-}
-
-#if MSGDODEBUG
-/* XXX This should eventually turn into something inlined or #define'd */
-int
-HttpParserReqSz(HttpParser *hp)
-{
-    assert(hp->state == 1);
-    assert(hp->req_start != -1);
-    assert(hp->req_end != -1);
-    return hp->req_end - hp->req_start + 1;
-}
-
-
-/*
- * This +1 makes it 'right' but won't make any sense if
- * there's a 0 byte header? This won't happen normally - a valid header
- * is at -least- a blank line (\n, or \r\n.)
- */
-int
-HttpParserHdrSz(HttpParser *hp)
-{
-    assert(hp->state == 1);
-    assert(hp->hdr_start != -1);
-    assert(hp->hdr_end != -1);
-    return hp->hdr_end - hp->hdr_start + 1;
-}
-
-const char *
-HttpParserHdrBuf(HttpParser *hp)
-{
-    assert(hp->state == 1);
-    assert(hp->hdr_start != -1);
-    assert(hp->hdr_end != -1);
-    return hp->buf + hp->hdr_start;
-}
-
-int
-HttpParserRequestLen(HttpParser *hp)
-{
-    return hp->hdr_end - hp->req_start + 1;
-}
-#endif
-
-HttpParser::HttpParser(const char *buf, int len)
-{
-    HttpParserInit(this, buf, len);
-}
-
-void
-HttpParser::clear()
-{
-    state = 0;
-    request_parse_status = HTTP_STATUS_NONE;
-    buf = NULL; // NP: we do not own the buffer, merely reference to it.
-    bufsiz = 0;
-    req_start = req_end = -1;
-    hdr_start = hdr_end = -1;
-    m_start = m_end = -1;
-    u_start = u_end = -1;
-    v_start = v_end = -1;
-    v_maj = v_min = 0;
-}
-
-int
-HttpParser::parseRequestFirstLine()
-{
-    int second_word = -1; // track the suspected URI start
-    int first_whitespace = -1, last_whitespace = -1; // track the first and last SP byte
-    int line_end = -1; // tracks the last byte BEFORE terminal \r\n or \n sequence
-
-    debugs(74, 5, HERE << "parsing possible request: " << buf);
-
-    // Single-pass parse: (provided we have the whole line anyways)
-
-    req_start = 0;
-    if (Config.onoff.relaxed_header_parser) {
-        if (Config.onoff.relaxed_header_parser < 0 && buf[req_start] == ' ')
-            debugs(74, DBG_IMPORTANT, "WARNING: Invalid HTTP Request: " <<
-                   "Whitespace bytes received ahead of method. " <<
-                   "Ignored due to relaxed_header_parser.");
-        // Be tolerant of prefix spaces (other bytes are valid method values)
-        for (; req_start < bufsiz && buf[req_start] == ' '; req_start++);
-    }
-    req_end = -1;
-    for (int i = 0; i < bufsiz; i++) {
-        // track first and last whitespace (SP only)
-        if (buf[i] == ' ') {
-            last_whitespace = i;
-            if (first_whitespace < req_start)
-                first_whitespace = i;
-        }
-
-        // track next non-SP/non-HT byte after first_whitespace
-        if (second_word < first_whitespace && buf[i] != ' ' && buf[i] != '\t') {
-            second_word = i;
-        }
-
-        // locate line terminator
-        if (buf[i] == '\n') {
-            req_end = i;
-            line_end = i - 1;
-            break;
-        }
-        if (i < bufsiz - 1 && buf[i] == '\r') {
-            if (Config.onoff.relaxed_header_parser) {
-                if (Config.onoff.relaxed_header_parser < 0 && buf[i + 1] == '\r')
-                    debugs(74, DBG_IMPORTANT, "WARNING: Invalid HTTP Request: " <<
-                           "Series of carriage-return bytes received prior to line terminator. " <<
-                           "Ignored due to relaxed_header_parser.");
-
-                // Be tolerant of invalid multiple \r prior to terminal \n
-                if (buf[i + 1] == '\n' || buf[i + 1] == '\r')
-                    line_end = i - 1;
-                while (i < bufsiz - 1 && buf[i + 1] == '\r')
-                    i++;
-
-                if (buf[i + 1] == '\n') {
-                    req_end = i + 1;
-                    break;
-                }
-            } else {
-                if (buf[i + 1] == '\n') {
-                    req_end = i + 1;
-                    line_end = i - 1;
-                    break;
-                }
-            }
-
-            // RFC 2616 section 5.1
-            // "No CR or LF is allowed except in the final CRLF sequence"
-            request_parse_status = HTTP_BAD_REQUEST;
-            return -1;
-        }
-    }
-    if (req_end == -1) {
-        debugs(74, 5, "Parser: retval 0: from " << req_start <<
-               "->" << req_end << ": needs more data to complete first line.");
-        return 0;
-    }
-
-    // NP: we have now seen EOL, more-data (0) cannot occur.
-    //     From here on any failure is -1, success is 1
-
-
-    // Input Validation:
-
-    // Process what we now know about the line structure into field offsets
-    // generating HTTP status for any aborts as we go.
-
-    // First non-whitespace = beginning of method
-    if (req_start > line_end) {
-        request_parse_status = HTTP_BAD_REQUEST;
-        return -1;
-    }
-    m_start = req_start;
-
-    // First whitespace = end of method
-    if (first_whitespace > line_end || first_whitespace < req_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // no method
-        return -1;
-    }
-    m_end = first_whitespace - 1;
-    if (m_end < m_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI?
-        return -1;
-    }
-
-    // First non-whitespace after first SP = beginning of URL+Version
-    if (second_word > line_end || second_word < req_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI
-        return -1;
-    }
-    u_start = second_word;
-
-    // RFC 1945: SP and version following URI are optional, marking version 0.9
-    // we identify this by the last whitespace being earlier than URI start
-    if (last_whitespace < second_word && last_whitespace >= req_start) {
-        v_maj = 0;
-        v_min = 9;
-        u_end = line_end;
-        request_parse_status = HTTP_OK; // HTTP/0.9
-        return 1;
-    } else {
-        // otherwise last whitespace is somewhere after end of URI.
-        u_end = last_whitespace;
-        // crop any trailing whitespace in the area we think of as URI
-        for (; u_end >= u_start && xisspace(buf[u_end]); u_end--);
-    }
-    if (u_end < u_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI
-        return -1;
-    }
-
-    // Last whitespace SP = before start of protocol/version
-    if (last_whitespace >= line_end) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing version
-        return -1;
-    }
-    v_start = last_whitespace + 1;
-    v_end = line_end;
-
-    // We only accept HTTP protocol requests right now.
-    // TODO: accept other protocols; RFC 2326 (RTSP protocol) etc
-    if ((v_end - v_start +1) < 5 || strncasecmp(&buf[v_start], "HTTP/", 5) != 0) {
-#if USE_HTTP_VIOLATIONS
-        // being lax; old parser accepted strange versions
-        // there is a LOT of cases which are ambiguous, therefore we cannot use relaxed_header_parser here.
-        v_maj = 0;
-        v_min = 9;
-        u_end = line_end;
-        request_parse_status = HTTP_OK; // treat as HTTP/0.9
-        return 1;
-#else
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED; // protocol not supported / implemented.
-        return -1;
-#endif
-    }
-
-    int i = v_start + sizeof("HTTP/") -1;
-
-    /* next should be 1 or more digits */
-    if (!isdigit(buf[i])) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
-        return -1;
-    }
-    int maj = 0;
-    for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; i++) {
-        maj = maj * 10;
-        maj = maj + (buf[i]) - '0';
-    }
-    // catch too-big values or missing remainders
-    if (maj >= 65536 || i > line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
-        return -1;
-    }
-    v_maj = maj;
-
-    /* next should be .; we -have- to have this as we have a whole line.. */
-    if (buf[i] != '.') {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
-        return -1;
-    }
-    // catch missing minor part
-    if (++i > line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
-        return -1;
-    }
-
-    /* next should be one or more digits */
-    if (!isdigit(buf[i])) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
-        return -1;
-    }
-    int min = 0;
-    for (; i <= line_end && (isdigit(buf[i])) && min < 65536; i++) {
-        min = min * 10;
-        min = min + (buf[i]) - '0';
-    }
-    // catch too-big values or trailing garbage
-    if (min >= 65536 || i < line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
-        return -1;
-    }
-    v_min = min;
-
-    /*
-     * Rightio - we have all the schtuff. Return true; we've got enough.
-     */
-    request_parse_status = HTTP_OK;
-    return 1;
-}
-
-int
-HttpParserParseReqLine(HttpParser *hmsg)
-{
-    PROF_start(HttpParserParseReqLine);
-    int retcode = hmsg->parseRequestFirstLine();
-    debugs(74, 5, "Parser: retval " << retcode << ": from " << hmsg->req_start <<
-           "->" << hmsg->req_end << ": method " << hmsg->m_start << "->" <<
-           hmsg->m_end << "; url " << hmsg->u_start << "->" << hmsg->u_end <<
-           "; version " << hmsg->v_start << "->" << hmsg->v_end << " (" << hmsg->v_maj <<
-           "/" << hmsg->v_min << ")");
-    PROF_stop(HttpParserParseReqLine);
-    return retcode;
-}
@@ -132,67 +132,6 @@ class HttpMsg
 
 };
 
-/* Temporary parsing state; might turn into the replacement parser later on */
-class HttpParser
-{
-public:
-    HttpParser() { clear(); }
-    HttpParser(const char *buf, int len);
-
-    /// Set this parser back to a default state.
-    /// Will DROP any reference to a buffer (does not free).
-    void clear();
-
-    /**
-     * Attempt to parse the first line of a new request message.
-     *
-     * Governed by:
-     *  RFC 1945 section 5.1
-     *  RFC 2616 section 5.1
-     *
-     * Parsing state is stored between calls. However the current implementation
-     * begins parsing from scratch on every call.
-     * The return value tells you whether the parsing state fields are valid or not.
-     *
-     * \retval -1  an error occurred. request_parse_status indicates HTTP status result.
-     * \retval  1  successful parse
-     * \retval  0  more data is needed to complete the parse
-     */
-    int parseRequestFirstLine();
-
-public:
-    char state;
-    const char *buf;
-    int bufsiz;
-    int req_start, req_end;
-    int hdr_start, hdr_end;
-    int m_start, m_end;
-    int u_start, u_end;
-    int v_start, v_end;
-    int v_maj, v_min;
-
-    /** HTTP status code to be used on the invalid-request error page
-     * HTTP_STATUS_NONE indicates incomplete parse, HTTP_OK indicates no error.
-     */
-    http_status request_parse_status;
-};
-
-extern void HttpParserInit(HttpParser *, const char *buf, int len);
-extern int HttpParserParseReqLine(HttpParser *hp);
-
-#define MSGDODEBUG 0
-#if MSGDODEBUG
-extern int HttpParserReqSz(HttpParser *);
-extern int HttpParserHdrSz(HttpParser *);
-extern const char * HttpParserHdrBuf(HttpParser *);
-extern int HttpParserRequestLen(HttpParser *hp);
-#else
-#define	HttpParserReqSz(hp)	( (hp)->req_end - (hp)->req_start + 1 )
-#define	HttpParserHdrSz(hp)	( (hp)->hdr_end - (hp)->hdr_start + 1 )
-#define	HttpParserHdrBuf(hp)	( (hp)->buf + (hp)->hdr_start )
-#define	HttpParserRequestLen(hp)	( (hp)->hdr_end - (hp)->req_start + 1 )
-#endif
-
 SQUIDCEXTERN int httpMsgIsolateHeaders(const char **parse_start, int len, const char **blk_start, const char **blk_end);
 
 #define HTTPMSGUNLOCK(a) if(a){(a)->_unlock();(a)=NULL;}
@@ -0,0 +1,293 @@
+#include "config.h"
+#include "Debug.h"
+#include "HttpParser.h"
+#include "structs.h"
+
+void
+HttpParser::clear()
+{
+    state = HTTP_PARSE_NONE;
+    request_parse_status = HTTP_STATUS_NONE;
+    buf = NULL;
+    bufsiz = 0;
+    req.start = req.end = -1;
+    hdr_start = hdr_end = -1;
+    req.m_start = req.m_end = -1;
+    req.u_start = req.u_end = -1;
+    req.v_start = req.v_end = -1;
+    req.v_maj = req.v_min = 0;
+}
+
+void
+HttpParser::reset(const char *aBuf, int len)
+{
+    clear(); // empty the state.
+    state = HTTP_PARSE_NEW;
+    buf = aBuf;
+    bufsiz = len;
+    debugs(74, 5, HERE << "Request buffer is " << buf);
+}
+
+int
+HttpParser::parseRequestFirstLine()
+{
+    int second_word = -1; // track the suspected URI start
+    int first_whitespace = -1, last_whitespace = -1; // track the first and last SP byte
+    int line_end = -1; // tracks the last byte BEFORE terminal \r\n or \n sequence
+
+    debugs(74, 5, HERE << "parsing possible request: " << buf);
+
+    // Single-pass parse: (provided we have the whole line anyways)
+
+    req.start = 0;
+    if (Config.onoff.relaxed_header_parser) {
+        if (Config.onoff.relaxed_header_parser < 0 && buf[req.start] == ' ')
+            debugs(74, DBG_IMPORTANT, "WARNING: Invalid HTTP Request: " <<
+                   "Whitespace bytes received ahead of method. " <<
+                   "Ignored due to relaxed_header_parser.");
+        // Be tolerant of prefix spaces (other bytes are valid method values)
+        for (; req.start < bufsiz && buf[req.start] == ' '; req.start++);
+    }
+    req.end = -1;
+    for (int i = 0; i < bufsiz; i++) {
+        // track first and last whitespace (SP only)
+        if (buf[i] == ' ') {
+            last_whitespace = i;
+            if (first_whitespace < req.start)
+                first_whitespace = i;
+        }
+
+        // track next non-SP/non-HT byte after first_whitespace
+        if (second_word < first_whitespace && buf[i] != ' ' && buf[i] != '\t') {
+            second_word = i;
+        }
+
+        // locate line terminator
+        if (buf[i] == '\n') {
+            req.end = i;
+            line_end = i - 1;
+            break;
+        }
+        if (i < bufsiz - 1 && buf[i] == '\r') {
+            if (Config.onoff.relaxed_header_parser) {
+                if (Config.onoff.relaxed_header_parser < 0 && buf[i + 1] == '\r')
+                    debugs(74, DBG_IMPORTANT, "WARNING: Invalid HTTP Request: " <<
+                           "Series of carriage-return bytes received prior to line terminator. " <<
+                           "Ignored due to relaxed_header_parser.");
+
+                // Be tolerant of invalid multiple \r prior to terminal \n
+                if (buf[i + 1] == '\n' || buf[i + 1] == '\r')
+                    line_end = i - 1;
+                while (i < bufsiz - 1 && buf[i + 1] == '\r')
+                    i++;
+
+                if (buf[i + 1] == '\n') {
+                    req.end = i + 1;
+                    break;
+                }
+            } else {
+                if (buf[i + 1] == '\n') {
+                    req.end = i + 1;
+                    line_end = i - 1;
+                    break;
+                }
+            }
+
+            // RFC 2616 section 5.1
+            // "No CR or LF is allowed except in the final CRLF sequence"
+            request_parse_status = HTTP_BAD_REQUEST;
+            return -1;
+        }
+    }
+    if (req.end == -1) {
+        debugs(74, 5, "Parser: retval 0: from " << req.start <<
+               "->" << req.end << ": needs more data to complete first line.");
+        return 0;
+    }
+
+    // NP: we have now seen EOL, more-data (0) cannot occur.
+    //     From here on any failure is -1, success is 1
+
+
+    // Input Validation:
+
+    // Process what we now know about the line structure into field offsets
+    // generating HTTP status for any aborts as we go.
+
+    // First non-whitespace = beginning of method
+    if (req.start > line_end) {
+        request_parse_status = HTTP_BAD_REQUEST;
+        return -1;
+    }
+    req.m_start = req.start;
+
+    // First whitespace = end of method
+    if (first_whitespace > line_end || first_whitespace < req.start) {
+        request_parse_status = HTTP_BAD_REQUEST; // no method
+        return -1;
+    }
+    req.m_end = first_whitespace - 1;
+    if (req.m_end < req.m_start) {
+        request_parse_status = HTTP_BAD_REQUEST; // missing URI?
+        return -1;
+    }
+
+    // First non-whitespace after first SP = beginning of URL+Version
+    if (second_word > line_end || second_word < req.start) {
+        request_parse_status = HTTP_BAD_REQUEST; // missing URI
+        return -1;
+    }
+    req.u_start = second_word;
+
+    // RFC 1945: SP and version following URI are optional, marking version 0.9
+    // we identify this by the last whitespace being earlier than URI start
+    if (last_whitespace < second_word && last_whitespace >= req.start) {
+        req.v_maj = 0;
+        req.v_min = 9;
+        req.u_end = line_end;
+        request_parse_status = HTTP_OK; // HTTP/0.9
+        return 1;
+    } else {
+        // otherwise last whitespace is somewhere after end of URI.
+        req.u_end = last_whitespace;
+        // crop any trailing whitespace in the area we think of as URI
+        for (; req.u_end >= req.u_start && xisspace(buf[req.u_end]); req.u_end--);
+    }
+    if (req.u_end < req.u_start) {
+        request_parse_status = HTTP_BAD_REQUEST; // missing URI
+        return -1;
+    }
+
+    // Last whitespace SP = before start of protocol/version
+    if (last_whitespace >= line_end) {
+        request_parse_status = HTTP_BAD_REQUEST; // missing version
+        return -1;
+    }
+    req.v_start = last_whitespace + 1;
+    req.v_end = line_end;
+
+    // We only accept HTTP protocol requests right now.
+    // TODO: accept other protocols; RFC 2326 (RTSP protocol) etc
+    if ((req.v_end - req.v_start +1) < 5 || strncasecmp(&buf[req.v_start], "HTTP/", 5) != 0) {
+#if USE_HTTP_VIOLATIONS
+        // being lax; old parser accepted strange versions
+        // there is a LOT of cases which are ambiguous, therefore we cannot use relaxed_header_parser here.
+        req.v_maj = 0;
+        req.v_min = 9;
+        req.u_end = line_end;
+        request_parse_status = HTTP_OK; // treat as HTTP/0.9
+        return 1;
+#else
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED; // protocol not supported / implemented.
+        return -1;
+#endif
+    }
+
+    int i = req.v_start + sizeof("HTTP/") -1;
+
+    /* next should be 1 or more digits */
+    if (!isdigit(buf[i])) {
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        return -1;
+    }
+    int maj = 0;
+    for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; i++) {
+        maj = maj * 10;
+        maj = maj + (buf[i]) - '0';
+    }
+    // catch too-big values or missing remainders
+    if (maj >= 65536 || i > line_end) {
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        return -1;
+    }
+    req.v_maj = maj;
+
+    /* next should be .; we -have- to have this as we have a whole line.. */
+    if (buf[i] != '.') {
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        return -1;
+    }
+    // catch missing minor part
+    if (++i > line_end) {
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        return -1;
+    }
+    /* next should be one or more digits */
+    if (!isdigit(buf[i])) {
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        return -1;
+    }
+    int min = 0;
+    for (; i <= line_end && (isdigit(buf[i])) && min < 65536; i++) {
+        min = min * 10;
+        min = min + (buf[i]) - '0';
+    }
+    // catch too-big values or trailing garbage
+    if (min >= 65536 || i < line_end) {
+        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        return -1;
+    }
+    req.v_min = min;
+
+    /*
+     * Rightio - we have all the schtuff. Return true; we've got enough.
+     */
+    request_parse_status = HTTP_OK;
+    return 1;
+}
+
+int
+HttpParserParseReqLine(HttpParser *hmsg)
+{
+    PROF_start(HttpParserParseReqLine);
+    int retcode = hmsg->parseRequestFirstLine();
+    debugs(74, 5, "Parser: retval " << retcode << ": from " << hmsg->req.start <<
+           "->" << hmsg->req.end << ": method " << hmsg->req.m_start << "->" <<
+           hmsg->req.m_end << "; url " << hmsg->req.u_start << "->" << hmsg->req.u_end <<
+           "; version " << hmsg->req.v_start << "->" << hmsg->req.v_end << " (" << hmsg->req.v_maj <<
+           "/" << hmsg->req.v_min << ")");
+    PROF_stop(HttpParserParseReqLine);
+    return retcode;
+}
+
+#if MSGDODEBUG
+/* XXX This should eventually turn into something inlined or #define'd */
+int
+HttpParserReqSz(HttpParser *hp)
+{
+    assert(hp->state == HTTP_PARSE_NEW);
+    assert(hp->req.start != -1);
+    assert(hp->req.end != -1);
+    return hp->req.end - hp->req.start + 1;
+}
+
+/*
+ * This +1 makes it 'right' but won't make any sense if
+ * there's a 0 byte header? This won't happen normally - a valid header
+ * is at -least- a blank line (\n, or \r\n.)
+ */
+int
+HttpParserHdrSz(HttpParser *hp)
+{
+    assert(hp->state == HTTP_PARSE_NEW);
+    assert(hp->hdr_start != -1);
+    assert(hp->hdr_end != -1);
+    return hp->hdr_end - hp->hdr_start + 1;
+}
+
+const char *
+HttpParserHdrBuf(HttpParser *hp)
+{
+    assert(hp->state == HTTP_PARSE_NEW);
+    assert(hp->hdr_start != -1);
+    assert(hp->hdr_end != -1);
+    return hp->buf + hp->hdr_start;
+}
+
+int
+HttpParserRequestLen(HttpParser *hp)
+{
+    return hp->hdr_end - hp->req.start + 1;
+}
+#endif
+
@@ -0,0 +1,98 @@
+#ifndef _SQUID_SRC_HTTPPARSER_H
+#define _SQUID_SRC_HTTPPARSER_H
+
+#include "HttpStatusCode.h"
+
+// Parser states
+#define HTTP_PARSE_NONE   0 // nothing. completely unset state.
+#define HTTP_PARSE_NEW    1 // initialized, but nothing usefully parsed yet.
+
+/** HTTP protocol parser.
+ *
+ * Works on a raw character I/O buffer and tokenizes the content into
+ * either an error state or, an HTTP procotol request major segments:
+ *
+ * \item Request Line (method, URL, protocol, version)
+ * \item Mime header block
+ */
+class HttpParser
+{
+public:
+    HttpParser() { clear(); }
+
+    /** Initialize a new parser.
+     * Presenting it a buffer to work on and the current length of available
+     * data.
+     * NOTE: This is *not* the buffer size, just the parse-able data length.
+     * The parse routines may be called again later with more data.
+     */
+    HttpParser(const char *aBuf, int len) { reset(aBuf,len); };
+
+    /// Set this parser back to a default state.
+    /// Will DROP any reference to a buffer (does not free).
+    void clear();
+
+    /// Reset the parser for use on a new buffer.
+    void reset(const char *aBuf, int len);
+
+    /**
+     * Attempt to parse the first line of a new request message.
+     *
+     * Governed by:
+     *  RFC 1945 section 5.1
+     *  RFC 2616 section 5.1
+     *
+     * Parsing state is stored between calls. However the current implementation
+     * begins parsing from scratch on every call.
+     * The return value tells you whether the parsing state fields are valid or not.
+     *
+     * \retval -1  an error occurred. request_parse_status indicates HTTP status result.
+     * \retval  1  successful parse. member fields contain the request-line items
+     * \retval  0  more data is needed to complete the parse
+     */
+    int parseRequestFirstLine();
+
+public:
+    uint8_t state;
+    const char *buf;
+    int bufsiz;
+
+    /// Offsets for pieces of the (HTTP request) Request-Line as per RFC 2616
+    struct request_offsets {
+        int start, end;
+        int m_start, m_end; // method
+        int u_start, u_end; // url
+        int v_start, v_end; // version (full text)
+        int v_maj, v_min;   // version numerics
+    } req;
+
+    // Offsets for pieces of the MiME Header segment
+    int hdr_start, hdr_end;
+
+    // TODO: Offsets for pieces of the (HTTP reply) Status-Line as per RFC 2616
+
+    /** HTTP status code to be used on the invalid-request error page
+     * HTTP_STATUS_NONE indicates incomplete parse, HTTP_OK indicates no error.
+     */
+    http_status request_parse_status;
+};
+
+// Legacy functions
+#define HttpParserInit(h,b,l) (h)->reset((b),(l))
+extern int HttpParserParseReqLine(HttpParser *hp);
+
+#define MSGDODEBUG 0
+#if MSGDODEBUG
+extern int HttpParserReqSz(HttpParser *);
+extern int HttpParserHdrSz(HttpParser *);
+extern const char * HttpParserHdrBuf(HttpParser *);
+extern int HttpParserRequestLen(HttpParser *hp);
+#else
+#define HttpParserReqSz(hp)     ( (hp)->req.end - (hp)->req.start + 1 )
+#define HttpParserHdrSz(hp)     ( (hp)->hdr_end - (hp)->hdr_start + 1 )
+#define HttpParserHdrBuf(hp)    ( (hp)->buf + (hp)->hdr_start )
+#define HttpParserRequestLen(hp)        ( (hp)->hdr_end - (hp)->req.start + 1 )
+#endif
+
+
+#endif /*  _SQUID_SRC_HTTPPARSER_H */
@@ -226,6 +226,43 @@ HttpRequest::clone() const
     return copy;
 }
 
+bool
+HttpRequest::inheritProperties(const HttpMsg *aMsg)
+{
+    const HttpRequest* aReq = dynamic_cast<const HttpRequest*>(aMsg);
+    if (!aReq)
+        return false;
+
+    client_addr = aReq->client_addr;
+#if FOLLOW_X_FORWARDED_FOR
+    indirect_client_addr = aReq->indirect_client_addr;
+#endif
+    my_addr = aReq->my_addr;
+
+    dnsWait = aReq->dnsWait;
+
+#if USE_ADAPTATION
+    adaptHistory_ = aReq->adaptHistory();
+#endif
+#if ICAP_CLIENT
+    icapHistory_ = aReq->icapHistory();
+#endif
+
+    // This may be too conservative for the 204 No Content case
+    // may eventually need cloneNullAdaptationImmune() for that.
+    flags = aReq->flags.cloneAdaptationImmune();
+
+    errType = aReq->errType;
+    errDetail = aReq->errDetail;
+#if USE_AUTH
+    auth_user_request = aReq->auth_user_request;
+#endif
+
+    // main property is which connection the request was received on (if any)
+    clientConnectionManager = aReq->clientConnectionManager;
+    return true;
+}
+
 /**
  * Checks the first line of an HTTP request is valid
  * currently just checks the request method is present.
@@ -601,44 +638,8 @@ HttpRequest::conditional() const
            header.has(HDR_IF_NONE_MATCH);
 }
 
-bool HttpRequest::inheritProperties(const HttpMsg *aMsg)
-{
-    const HttpRequest* aReq = dynamic_cast<const HttpRequest*>(aMsg);
-    if (!aReq)
-        return false;
-
-    // main property is which connection the request was received on (if any)
-    clientConnectionManager = aReq->clientConnectionManager;
-
-    client_addr = aReq->client_addr;
-#if FOLLOW_X_FORWARDED_FOR
-    indirect_client_addr = aReq->indirect_client_addr;
-#endif
-    my_addr = aReq->my_addr;
-
-    dnsWait = aReq->dnsWait;
-
-#if USE_ADAPTATION
-    adaptHistory_ = aReq->adaptHistory();
-#endif
-#if ICAP_CLIENT
-    icapHistory_ = aReq->icapHistory();
-#endif
-
-    // This may be too conservative for the 204 No Content case
-    // may eventually need cloneNullAdaptationImmune() for that.
-    flags = aReq->flags.cloneAdaptationImmune();
-
-    errType = aReq->errType;
-    errDetail = aReq->errDetail;
-#if USE_AUTH
-    auth_user_request = aReq->auth_user_request;
-#endif
-    clientConnectionManager = aReq->clientConnectionManager;
-    return true;
-}
-
-void HttpRequest::recordLookup(const DnsLookupDetails &dns)
+void
+HttpRequest::recordLookup(const DnsLookupDetails &dns)
 {
     if (dns.wait >= 0) { // known delay
         if (dnsWait >= 0) // have recorded DNS wait before
@@ -360,6 +360,8 @@ squid_SOURCES = \
 	HttpControlMsg.h \
 	HttpMsg.cc \
 	HttpMsg.h \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpReply.cc \
 	HttpReply.h \
 	HttpRequest.cc \
@@ -968,6 +970,7 @@ check_PROGRAMS+=\
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
+	tests/testHttpParser \
 	tests/testHttpReply \
 	tests/testHttpRequest \
 	tests/testStore \
@@ -1202,6 +1205,8 @@ tests_testBoilerplate_DEPENDENCIES = \
 tests_testCacheManager_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	debug.cc \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	mem.cc \
@@ -1566,6 +1571,8 @@ tests_testEvent_SOURCES = \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpReply.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
@@ -1741,6 +1748,8 @@ tests_testEventLoop_SOURCES = \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpReply.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
@@ -1914,6 +1923,8 @@ tests_test_http_range_SOURCES = \
 	HttpHeader.cc \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpReply.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
@@ -2027,9 +2038,41 @@ tests_test_http_range_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 
+tests_testHttpParser_SOURCES = \
+	Debug.h \
+	HttpParser.cc \
+	HttpParser.h \
+	MemBuf.cc \
+	MemBuf.h \
+	mem.cc \
+	structs.h \
+	tests/stub_cache_manager.cc \
+	tests/stub_debug.cc \
+	tests/stub_event.cc \
+	tests/stub_HelperChildConfig.cc \
+	tests/testHttpParser.cc \
+	tests/testHttpParser.h \
+	tests/testMain.cc \
+	time.cc
+nodist_tests_testHttpParser_SOURCES = \
+	$(TESTSOURCES)
+tests_testHttpParser_LDADD= \
+	SquidConfig.o \
+	base/libbase.la \
+	ip/libip.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+tests_testHttpParser_LDFLAGS = $(LIBADD_DL)
+tests_testHttpParser_DEPENDENCIES = \
+	$(SQUID_CPPUNIT_LA)
+
 ## Tests of the HttpRequest module.
 tests_testHttpRequest_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	mem.cc \
@@ -2825,6 +2868,8 @@ tests_testURL_SOURCES = \
 	HttpHeader.cc \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
+	HttpParser.cc \
+	HttpParser.h \
 	HttpReply.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
@@ -3,6 +3,7 @@
  */
 
 #include "config.h"
+#include "ip/Address.h"
 // just for the global definition of Config and Config2
 #include "structs.h"
 
@@ -33,7 +33,6 @@
 #ifndef SQUID_SRC_URL_H
 #define SQUID_SRC_URL_H
 
-#include "squid.h"
 #include "MemPool.h"
 #include "URLScheme.h"
 
@@ -134,8 +134,13 @@ aclParseRegexList(relist **curlist)
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
 
+    debugs(28,5, HERE << "Regex new line.");
+
     for (Tail = (relist **)curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = ConfigParser::strtokFile())) {
+
+        debugs(28,5, HERE << "Regex token: " << t);
+
         if (strcmp(t, "-i") == 0) {
             flags |= REG_ICASE;
             continue;
@@ -8,6 +8,7 @@ namespace Adaptation
 
 typedef enum { methodNone, methodReqmod, methodRespmod, methodOptions } Method;
 typedef enum { pointNone, pointPreCache, pointPostCache } VectPoint;
+typedef enum { srvBlock, srvBypass, srvWait, srvForce} SrvBehaviour;
 
 extern const char *crlf;
 extern const char *methodStr(Method); // TODO: make into a stream operator?
@@ -9,7 +9,8 @@
 
 Adaptation::ServiceConfig::ServiceConfig():
         port(-1), method(methodNone), point(pointNone),
-        bypass(false), routing(false), ipv6(false)
+        bypass(false), maxConn(-1), onOverload(srvWait),
+        routing(false), ipv6(false)
 {}
 
 const char *
@@ -70,6 +71,7 @@ Adaptation::ServiceConfig::parse()
     // handle optional service name=value parameters
     const char *lastOption = NULL;
     bool grokkedUri = false;
+    bool onOverloadSet = false;
     while (char *option = strtok(NULL, w_space)) {
         if (strcmp(option, "0") == 0) { // backward compatibility
             bypass = false;
@@ -91,23 +93,32 @@ Adaptation::ServiceConfig::parse()
 
         // TODO: warn if option is set twice?
         bool grokked = false;
-        if (strcmp(name, "bypass") == 0)
+        if (strcmp(name, "bypass") == 0) {
             grokked = grokBool(bypass, name, value);
-        else if (strcmp(name, "routing") == 0)
+        } else if (strcmp(name, "routing") == 0)
             grokked = grokBool(routing, name, value);
         else if (strcmp(name, "uri") == 0)
             grokked = grokkedUri = grokUri(value);
         else if (strcmp(name, "ipv6") == 0) {
             grokked = grokBool(ipv6, name, value);
             if (grokked && ipv6 && !Ip::EnableIpv6)
                 debugs(3, DBG_IMPORTANT, "WARNING: IPv6 is disabled. ICAP service option ignored.");
+        } else if (strcmp(name, "max-conn") == 0)
+            grokked = grokLong(maxConn, name, value);
+        else if (strcmp(name, "on-overload") == 0) {
+            grokked = grokOnOverload(onOverload, value);
+            onOverloadSet = true;
         } else
             grokked = grokExtension(name, value);
 
         if (!grokked)
             return false;
     }
 
+    // set default on-overload value if needed
+    if (!onOverloadSet)
+        onOverload = bypass ? srvBypass : srvWait;
+
     // what is left must be the service URI
     if (!grokkedUri && !grokUri(lastOption))
         return false;
@@ -246,6 +257,41 @@ Adaptation::ServiceConfig::grokBool(bool &var, const char *name, const char *val
     return true;
 }
 
+bool
+Adaptation::ServiceConfig::grokLong(long &var, const char *name, const char *value)
+{
+    char *bad = NULL;
+    const long p = strtol(value, &bad, 0);
+    if (p < 0 || bad == value) {
+        debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' <<
+               config_lineno << ": " << "wrong value for " << name << "; " <<
+               "a non-negative integer expected but got: " << value);
+        return false;
+    }
+    var = p;
+    return true;
+}
+
+bool
+Adaptation::ServiceConfig::grokOnOverload(SrvBehaviour &var, const char *value)
+{
+    if (strcmp(value, "block") == 0)
+        var = srvBlock;
+    else if (strcmp(value, "bypass") == 0)
+        var = srvBypass;
+    else if (strcmp(value, "wait") == 0)
+        var = srvWait;
+    else if (strcmp(value, "force") == 0)
+        var = srvForce;
+    else {
+        debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' <<
+               config_lineno << ": " << "wrong value for on-overload; " <<
+               "'block', 'bypass', 'wait' or 'force' expected but got: " << value);
+        return false;
+    }
+    return true;
+}
+
 bool
 Adaptation::ServiceConfig::grokExtension(const char *name, const char *value)
 {
@@ -32,6 +32,10 @@ class ServiceConfig: public RefCountable
     Method method;   // what is being adapted (REQMOD vs RESPMOD)
     VectPoint point; // where the adaptation happens (pre- or post-cache)
     bool bypass;
+
+    // options
+    long maxConn; ///< maximum number of concurrent service transactions
+    SrvBehaviour onOverload; ///< how to handle Max-Connections feature
     bool routing; ///< whether this service may determine the next service(s)
     bool ipv6;    ///< whether this service uses IPv6 transport (default IPv4)
 
@@ -42,6 +46,9 @@ class ServiceConfig: public RefCountable
     /// interpret parsed values
     bool grokBool(bool &var, const char *name, const char *value);
     bool grokUri(const char *value);
+    bool grokLong(long &var, const char *name, const char *value);
+    /// handle on-overload configuration option
+    bool grokOnOverload(SrvBehaviour &var, const char *value);
     /// handle name=value configuration option with name unknown to Squid
     virtual bool grokExtension(const char *name, const char *value);
 };
@@ -87,36 +87,81 @@ void Adaptation::Icap::ModXact::start()
     canStartBypass = service().cfg().bypass;
 
     // it is an ICAP violation to send request to a service w/o known OPTIONS
-
-    if (service().up())
+    // and the service may is too busy for us: honor Max-Connections and such
+    if (service().up() && service().availableForNew())
         startWriting();
     else
         waitForService();
 }
 
 void Adaptation::Icap::ModXact::waitForService()
 {
+    const char *comment;
     Must(!state.serviceWaiting);
-    debugs(93, 7, HERE << "will wait for the ICAP service" << status());
-    typedef NullaryMemFunT<ModXact> Dialer;
-    AsyncCall::Pointer call = JobCallback(93,5,
-                                          Dialer, this, Adaptation::Icap::ModXact::noteServiceReady);
-    service().callWhenReady(call);
+
+    if (!service().up()) {
+        AsyncCall::Pointer call = JobCallback(93,5,
+                                              ConnWaiterDialer, this, Adaptation::Icap::ModXact::noteServiceReady);
+
+        service().callWhenReady(call);
+        comment = "to be up";
+    } else {
+        //The service is unavailable because of max-connection or other reason
+
+        if (service().cfg().onOverload != srvWait) {
+            // The service is overloaded, but waiting to be available prohibited by
+            // user configuration (onOverload is set to "block" or "bypass")
+            if (service().cfg().onOverload == srvBlock)
+                disableBypass("not available", true);
+            else //if (service().cfg().onOverload == srvBypass)
+                canStartBypass = true;
+
+            disableRetries();
+            disableRepeats("ICAP service is not available");
+
+            debugs(93, 7, HERE << "will not wait for the service to be available" <<
+                   status());
+
+            throw TexcHere("ICAP service is not available");
+        }
+
+        AsyncCall::Pointer call = JobCallback(93,5,
+                                              ConnWaiterDialer, this, Adaptation::Icap::ModXact::noteServiceAvailable);
+        service().callWhenAvailable(call, state.waitedForService);
+        comment = "to be available";
+    }
+
+    debugs(93, 7, HERE << "will wait for the service " << comment <<  status());
     state.serviceWaiting = true; // after callWhenReady() which may throw
+    state.waitedForService = true;
 }
 
 void Adaptation::Icap::ModXact::noteServiceReady()
 {
     Must(state.serviceWaiting);
     state.serviceWaiting = false;
 
-    if (service().up()) {
-        startWriting();
-    } else {
+    if (!service().up()) {
         disableRetries();
         disableRepeats("ICAP service is unusable");
         throw TexcHere("ICAP service is unusable");
     }
+
+    if (service().availableForOld())
+        startWriting();
+    else
+        waitForService();
+}
+
+void Adaptation::Icap::ModXact::noteServiceAvailable()
+{
+    Must(state.serviceWaiting);
+    state.serviceWaiting = false;
+
+    if (service().up() && service().availableForOld())
+        startWriting();
+    else
+        waitForService();
 }
 
 void Adaptation::Icap::ModXact::startWriting()
@@ -1765,7 +1810,10 @@ void Adaptation::Icap::VirginBodyAct::disable()
 void Adaptation::Icap::VirginBodyAct::progress(size_t size)
 {
     Must(active());
+#if SIZEOF_SIZE_T > 4
+    /* always true for smaller size_t's */
     Must(static_cast<int64_t>(size) >= 0);
+#endif
     theStart += static_cast<int64_t>(size);
 }
 
@@ -157,6 +157,7 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
 
     // service waiting
     void noteServiceReady();
+    void noteServiceAvailable();
 
 public:
     InOut virgin;
@@ -303,6 +304,7 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
         bool allowedPostview206; // must handle 206 Partial Content outside preview
         bool allowedPreview206; // must handle 206 Partial Content inside preview
         bool readyForUob; ///< got a 206 response and expect a use-origin-body
+        bool waitedForService; ///< true if was queued at least once
 
         // will not write anything [else] to the ICAP server connection
         bool doneWriting() const { return writing == writingReallyDone; }
@@ -98,6 +98,8 @@ void Adaptation::Icap::Options::configure(const HttpReply *reply)
     }
 
     cfgIntHeader(h, "Max-Connections", max_connections);
+    if (max_connections == 0)
+        debugs(93, DBG_IMPORTANT, "WARNING: Max-Connections is set to zero! ");
 
     cfgIntHeader(h, "Options-TTL", theTTL);
 
@@ -10,20 +10,29 @@
 #include "adaptation/icap/OptXact.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "base/TextException.h"
+#include "comm/Connection.h"
 #include "ConfigParser.h"
+#include "ip/tools.h"
 #include "HttpReply.h"
 #include "SquidTime.h"
+#include "fde.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &svcCfg):
         AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(svcCfg),
         theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
+        theBusyConns(0),
+        theAllWaiters(0),
+        connOverloadReported(false),
+        theIdleConns("ICAP Service"),
         isSuspended(0), notifying(false),
         updateScheduled(false),
         wasAnnouncedUp(true), // do not announce an "up" service at startup
         isDetached(false)
-{}
+{
+    setMaxConnections();
+}
 
 Adaptation::Icap::ServiceRep::~ServiceRep()
 {
@@ -72,6 +81,155 @@ void Adaptation::Icap::ServiceRep::noteFailure()
     // should be configurable.
 }
 
+// returns a persistent or brand new connection; negative int on failures
+Comm::ConnectionPointer
+Adaptation::Icap::ServiceRep::getConnection(bool retriableXact, bool &reused)
+{
+    Comm::ConnectionPointer connection = new Comm::Connection;
+
+    /* NP: set these here because it applies whether a pconn or a new conn is used */
+
+    // TODO: Avoid blocking lookup if s.cfg().host is a hostname
+    connection->remote = cfg().host.termedBuf();
+    connection->remote.SetPort(cfg().port);
+
+    // TODO: check whether NULL domain is appropriate here
+    theIdleConns.pop(connection, NULL, retriableXact);
+    reused = connection->isOpen(); // reused a persistent connection
+
+    if (reused)
+        debugs(93,3, HERE << "reused pconn " << connection);
+    // else, return unopened Comm::Connection for caller to open.
+
+    if (connection->isOpen())
+        ++theBusyConns;
+
+    return connection;
+}
+
+// pools connection if it is reusable or closes it
+void Adaptation::Icap::ServiceRep::putConnection(const Comm::ConnectionPointer &conn, bool isReusable, const char *comment)
+{
+    Must(Comm::IsConnOpen(conn));
+    // do not pool an idle connection if we owe connections
+    if (isReusable && excessConnections() == 0) {
+        debugs(93, 3, HERE << "pushing pconn" << comment);
+        commUnsetConnTimeout(conn);
+        theIdleConns.push(conn, NULL);
+    } else {
+        debugs(93, 3, HERE << "closing pconn" << comment);
+        // comm_close will clear timeout
+        conn->close();
+    }
+
+    Must(theBusyConns > 0);
+    --theBusyConns;
+    // a connection slot released. Check if there are waiters....
+    busyCheckpoint();
+}
+
+// a wrapper to avoid exposing theIdleConns
+void Adaptation::Icap::ServiceRep::noteConnectionUse(const Comm::ConnectionPointer &conn)
+{
+    Must(Comm::IsConnOpen(conn));
+    fd_table[conn->fd].noteUse(&theIdleConns);
+}
+
+void Adaptation::Icap::ServiceRep::setMaxConnections()
+{
+    if (cfg().maxConn >= 0)
+        theMaxConnections = cfg().maxConn;
+    else if (theOptions && theOptions->max_connections >= 0)
+        theMaxConnections = theOptions->max_connections;
+    else {
+        theMaxConnections = -1;
+        return;
+    }
+
+    if (::Config.workers > 1 )
+        theMaxConnections /= ::Config.workers;
+}
+
+int Adaptation::Icap::ServiceRep::availableConnections() const
+{
+    if (theMaxConnections < 0)
+        return -1;
+
+    // we are available if we can open or reuse connections
+    // in other words, if we will not create debt
+    int available = max(0, theMaxConnections - theBusyConns);
+
+    if (!available && !connOverloadReported) {
+        debugs(93, DBG_IMPORTANT, "WARNING: ICAP Max-Connections limit " <<
+               "exceeded for service " << cfg().uri << ". Open connections now: " <<
+               theBusyConns + theIdleConns.count() << ", including " <<
+               theIdleConns.count() << " idle persistent connections.");
+        connOverloadReported = true;
+    }
+
+    if (cfg().onOverload == srvForce)
+        return -1;
+
+    return available;
+}
+
+// The number of connections which excess the Max-Connections limit
+int Adaptation::Icap::ServiceRep::excessConnections() const
+{
+    if (theMaxConnections < 0)
+        return 0;
+
+    // Waiters affect the number of needed connections but a needed
+    // connection may still be excessive from Max-Connections p.o.v.
+    // so we should not account for waiting transaction needs here.
+    const int debt =  theBusyConns + theIdleConns.count() - theMaxConnections;
+    if (debt > 0)
+        return debt;
+    else
+        return 0;
+}
+
+void Adaptation::Icap::ServiceRep::noteGoneWaiter()
+{
+    theAllWaiters--;
+
+    // in case the notified transaction did not take the connection slot
+    busyCheckpoint();
+}
+
+// called when a connection slot may become available
+void Adaptation::Icap::ServiceRep::busyCheckpoint()
+{
+    if (theNotificationWaiters.empty()) // nobody is waiting for a slot
+        return;
+
+    int freed = 0;
+    int available = availableConnections();
+
+    if (available < 0) {
+        // It is possible to have waiters when no limit on connections exist in
+        // case of reconfigure or because new Options received.
+        // In this case, notify all waiting transactions.
+        freed  = theNotificationWaiters.size();
+    } else {
+        // avoid notifying more waiters than there will be available slots
+        const int notifiedWaiters = theAllWaiters - theNotificationWaiters.size();
+        freed = available - notifiedWaiters;
+    }
+
+    debugs(93,7, HERE << "Available connections: " << available <<
+           " freed slots: " << freed <<
+           " waiting in queue: " << theNotificationWaiters.size());
+
+    while (freed > 0 && !theNotificationWaiters.empty()) {
+        Client i = theNotificationWaiters.front();
+        theNotificationWaiters.pop_front();
+        ScheduleCallHere(i.callback);
+        i.callback = NULL;
+        --freed;
+    }
+}
+
 void Adaptation::Icap::ServiceRep::suspend(const char *reason)
 {
     if (isSuspended) {
@@ -99,6 +257,25 @@ bool Adaptation::Icap::ServiceRep::up() const
     return !isSuspended && hasOptions();
 }
 
+bool Adaptation::Icap::ServiceRep::availableForNew() const
+{
+    Must(up());
+    int available = availableConnections();
+    if (available < 0)
+        return true;
+    else
+        return (available - theAllWaiters > 0);
+}
+
+bool Adaptation::Icap::ServiceRep::availableForOld() const
+{
+    Must(up());
+
+    int available = availableConnections();
+    return (available != 0); // it is -1 (no limit) or has available slots
+}
+
+
 bool Adaptation::Icap::ServiceRep::wantsUrl(const String &urlPath) const
 {
     Must(hasOptions());
@@ -187,6 +364,24 @@ void Adaptation::Icap::ServiceRep::noteTimeToNotify()
     notifying = false;
 }
 
+void Adaptation::Icap::ServiceRep::callWhenAvailable(AsyncCall::Pointer &cb, bool priority)
+{
+    debugs(93,8, "ICAPServiceRep::callWhenAvailable");
+    Must(cb!=NULL);
+    Must(up());
+    Must(!theIdleConns.count()); // or we should not be waiting
+
+    Client i;
+    i.service = Pointer(this);
+    i.callback = cb;
+    if (priority)
+        theNotificationWaiters.push_front(i);
+    else
+        theNotificationWaiters.push_back(i);
+
+    busyCheckpoint();
+}
+
 void Adaptation::Icap::ServiceRep::callWhenReady(AsyncCall::Pointer &cb)
 {
     Must(cb!=NULL);
@@ -351,6 +546,18 @@ void Adaptation::Icap::ServiceRep::handleNewOptions(Adaptation::Icap::Options *n
     debugs(93,3, HERE << "got new options and is now " << status());
 
     scheduleUpdate(optionsFetchTime());
+
+    // XXX: this whole feature bases on the false assumption a service only has one IP
+    setMaxConnections();
+    const int excess = excessConnections();
+    // if we owe connections and have idle pconns, close the latter
+    // XXX:  but ... idle pconn to *where*?
+    if (excess && theIdleConns.count() > 0) {
+        const int n = min(excess, theIdleConns.count());
+        debugs(93,5, HERE << "closing " << n << " pconns to relief debt");
+        theIdleConns.closeN(n, Comm::ConnectionPointer(), cfg().host.termedBuf());
+    }
+
     scheduleNotification();
 }
 
@@ -486,3 +693,22 @@ bool Adaptation::Icap::ServiceRep::detached() const
 {
     return isDetached;
 }
+
+Adaptation::Icap::ConnWaiterDialer::ConnWaiterDialer(const CbcPointer<ModXact> &xact,
+        Adaptation::Icap::ConnWaiterDialer::Parent::Method aHandler):
+        Parent(xact, aHandler)
+{
+    theService = &xact->service();
+    theService->noteNewWaiter();
+}
+
+Adaptation::Icap::ConnWaiterDialer::ConnWaiterDialer(const Adaptation::Icap::ConnWaiterDialer &aConnWaiter): Parent(aConnWaiter)
+{
+    theService = aConnWaiter.theService;
+    theService->noteNewWaiter();
+}
+
+Adaptation::Icap::ConnWaiterDialer::~ConnWaiterDialer()
+{
+    theService->noteGoneWaiter();
+}
@@ -40,7 +40,10 @@
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
 #include "adaptation/icap/Elements.h"
-
+#include "base/AsyncJobCalls.h"
+#include "comm.h"
+#include "pconn.h"
+#include <deque>
 
 namespace Adaptation
 {
@@ -94,19 +97,29 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
 
     virtual bool probed() const; // see comments above
     virtual bool up() const; // see comments above
+    bool availableForNew() const; ///< a new transaction may start communicating with the service
+    bool availableForOld() const; ///< a transaction notified about connection slot availability may start communicating with the service
 
     virtual Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause);
 
+    void callWhenAvailable(AsyncCall::Pointer &cb, bool priority = false);
     void callWhenReady(AsyncCall::Pointer &cb);
 
     // the methods below can only be called on an up() service
     bool wantsUrl(const String &urlPath) const;
     bool wantsPreview(const String &urlPath, size_t &wantedSize) const;
     bool allows204() const;
     bool allows206() const;
+    Comm::ConnectionPointer getConnection(bool isRetriable, bool &isReused);
+    void putConnection(const Comm::ConnectionPointer &conn, bool isReusable, const char *comment);
+    void noteConnectionUse(const Comm::ConnectionPointer &conn);
 
     void noteFailure(); // called by transactions to report service failure
 
+    void noteNewWaiter() {theAllWaiters++;} ///< New xaction waiting for service to be up or available
+    void noteGoneWaiter(); ///< An xaction is not waiting any more for service to be available
+    bool existWaiters() const {return (theAllWaiters > 0);} ///< if there are xactions waiting for the service to be available
+
     //AsyncJob virtual methods
     virtual bool doneAll() const { return Adaptation::Initiator::doneAll() && false;}
     virtual void callException(const std::exception &e);
@@ -130,12 +143,25 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     };
 
     typedef Vector<Client> Clients;
+    // TODO: rename to theUpWaiters
     Clients theClients; // all clients waiting for a call back
 
     Options *theOptions;
     CbcPointer<Adaptation::Initiate> theOptionsFetcher; // pending ICAP OPTIONS transaction
     time_t theLastUpdate; // time the options were last updated
 
+    /// FIFO queue of xactions waiting for a connection slot and not yet notified
+    /// about it; xaction is removed when notification is scheduled
+    std::deque<Client> theNotificationWaiters;
+    int theBusyConns;   ///< number of connections given to active transactions
+    /// number of xactions waiting for a connection slot (notified and not)
+    /// the number is decreased after the xaction receives notification
+    int theAllWaiters;
+    int theMaxConnections; ///< the maximum allowed connections to the service
+    // TODO: use a better type like the FadingCounter for connOverloadReported
+    mutable bool connOverloadReported; ///< whether we reported exceeding theMaxConnections
+    PconnPool theIdleConns; ///< idle persistent connection pool
+
     FadingCounter theSessionFailures;
     const char *isSuspended; // also stores suspension reason for debugging
 
@@ -162,13 +188,40 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
 
     void announceStatusChange(const char *downPhrase, bool important) const;
 
+    /// Set the maximum allowed connections for the service
+    void setMaxConnections();
+    /// The number of connections which excess the Max-Connections limit
+    int excessConnections() const;
+    /**
+     * The available connections slots to the ICAP server
+     \return the available slots, or -1 if there is no limit on allowed connections
+     */
+    int availableConnections() const;
+    /**
+     * If there are xactions waiting for the service to be available, notify
+     * as many xactions as the available connections slots.
+     */
+    void busyCheckpoint();
+
     const char *status() const;
 
     mutable bool wasAnnouncedUp; // prevent sequential same-state announcements
     bool isDetached;
     CBDATA_CLASS2(ServiceRep);
 };
 
+class ModXact;
+/// Custom dialer to call Service::noteNewWaiter and noteGoneWaiter
+/// to maintain Service idea of waiting and being-notified transactions.
+class ConnWaiterDialer: public NullaryMemFunT<ModXact>
+{
+public:
+    typedef NullaryMemFunT<ModXact> Parent;
+    ServiceRep::Pointer theService;
+    ConnWaiterDialer(const CbcPointer<ModXact> &xact, Parent::Method aHandler);
+    ConnWaiterDialer(const Adaptation::Icap::ConnWaiterDialer &aConnWaiter);
+    ~ConnWaiterDialer();
+};
 
 } // namespace Icap
 } // namespace Adaptation
@@ -22,8 +22,6 @@
 #include "SquidTime.h"
 #include "err_detail_type.h"
 
-static PconnPool *icapPconnPool = new PconnPool("ICAP Servers");
-
 
 //CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, Xaction);
 
@@ -93,23 +91,20 @@ Adaptation::Icap::Xaction::openConnection()
 {
     Must(!haveConnection());
 
-    const Adaptation::Service &s = service();
+    Adaptation::Icap::ServiceRep &s = service();
 
     if (!TheConfig.reuse_connections)
         disableRetries(); // this will also safely drain pconn pool
 
-    connection = new Comm::Connection;
-
-    /* NP: set these here because it applies whether a pconn or a new conn is used */
+    bool wasReused = false;
+    connection = s.getConnection(isRetriable, wasReused);
 
-    // TODO: Avoid blocking lookup if s.cfg().host is a hostname
-    connection->remote = s.cfg().host.termedBuf();
-    connection->remote.SetPort(s.cfg().port);
-
-    // TODO: check whether NULL domain is appropriate here
-    icapPconnPool->pop(connection, NULL, isRetriable);
-    if (connection->isOpen()) {
-        debugs(93,3, HERE << "reused pconn " << connection);
+    if (wasReused && Comm::IsConnOpen(connection)) {
+        // Set comm Close handler
+        typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommCloseCbParams> CloseDialer;
+        closer =  asyncCall(93, 5, "Adaptation::Icap::Xaction::noteCommClosed",
+                            CloseDialer(this,&Adaptation::Icap::Xaction::noteCommClosed));
+        comm_add_close_handler(connection->fd, closer);
 
         // fake the connect callback
         // TODO: can we sync call Adaptation::Icap::Xaction::noteCommConnected here instead?
@@ -126,6 +121,22 @@ Adaptation::Icap::Xaction::openConnection()
 
     disableRetries(); // we only retry pconn failures
 
+    // Attempt to open a new connection...
+    debugs(93,3, typeName << " opens connection to " << s.cfg().host.termedBuf() << ":" << s.cfg().port);
+
+    // TODO: service bypass status may differ from that of a transaction
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  asyncCall(93, 5, "Adaptation::Icap::Xaction::noteCommTimedout",
+                                      TimeoutDialer(this,&Adaptation::Icap::Xaction::noteCommTimedout));
+
+    commSetTimeout(connection->fd, TheConfig.connect_timeout(
+                       service().cfg().bypass), timeoutCall);
+
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommCloseCbParams> CloseDialer;
+    closer =  asyncCall(93, 5, "Adaptation::Icap::Xaction::noteCommClosed",
+                        CloseDialer(this,&Adaptation::Icap::Xaction::noteCommClosed));
+    comm_add_close_handler(connection->fd, closer);
+
     typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> ConnectDialer;
     connector = JobCallback(93,3, ConnectDialer, this, Adaptation::Icap::Xaction::noteCommConnected);
     Comm::ConnOpener *cs = new Comm::ConnOpener(connection, connector, TheConfig.connect_timeout(service().cfg().bypass));
@@ -164,17 +175,11 @@ void Adaptation::Icap::Xaction::closeConnection()
             reuseConnection = false;
         }
 
-        if (reuseConnection) {
-            //status() adds leading spaces.
-            debugs(93,3, HERE << "pushing pconn" << status());
-            commUnsetConnTimeout(connection);
-            icapPconnPool->push(connection, NULL);
+        if (reuseConnection)
             disableRetries();
-        } else {
-            //status() adds leading spaces.
-            debugs(93,3, HERE << "closing pconn" << status());
-            connection->close();
-        }
+
+        Adaptation::Icap::ServiceRep &s = service();
+        s.putConnection(connection, reuseConnection, status());
 
         writer = NULL;
         reader = NULL;
@@ -202,7 +207,8 @@ void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
                         CloseDialer(this,&Adaptation::Icap::Xaction::noteCommClosed));
     comm_add_close_handler(io.conn->fd, closer);
 
-    fd_table[io.conn->fd].noteUse(icapPconnPool);
+// ??    fd_table[io.conn->fd].noteUse(icapPconnPool);
+    service().noteConnectionUse(connection);
 
     handleCommConnected();
 }
@@ -139,6 +139,7 @@ class Xaction: public Adaptation::Initiate
     void setOutcome(const XactOutcome &xo);
     virtual void finalizeLogInfo();
 
+public:
     ServiceRep &service();
 
 private:
@@ -7,6 +7,8 @@
 #include "base/AsyncCallQueue.h"
 #include "cbdata.h"
 
+#include <ostream>
+
 InstanceIdDefinitions(AsyncCall, "call");
 
 
@@ -10,6 +10,8 @@
 #include "cbdata.h"
 #include "MemBuf.h"
 
+#include <ostream>
+
 InstanceIdDefinitions(AsyncJob, "job");
 
 AsyncJob::Pointer AsyncJob::Start(AsyncJob *j)
@@ -146,7 +146,7 @@ static void configDoConfigure(void);
 static void parse_refreshpattern(refresh_t **);
 static uint64_t parseTimeUnits(const char *unit,  bool allowMsec);
 static void parseTimeLine(time_msec_t * tptr, const char *units, bool allowMsec);
-static void parse_ushort(u_short * var);
+static void parse_u_short(u_short * var);
 static void parse_string(char **);
 static void default_all(void);
 static void defaults_if_none(void);
@@ -645,6 +645,16 @@ configDoConfigure(void)
     if (Config.errHtmlText == NULL)
         Config.errHtmlText = xstrdup(null_string);
 
+#if !HAVE_SETRLIMIT || !defined(RLIMIT_NOFILE)
+    if (Config.max_filedescriptors > 0) {
+        debugs(0, DBG_IMPORTANT, "WARNING: max_filedescriptors disabled. Operating System setrlimit(RLIMIT_NOFILE) is missing.");
+    }
+#elif USE_SELECT || USE_SELECT_WIN32
+    if (Config.max_filedescriptors > FD_SETSIZE) {
+        debugs(0, DBG_IMPORTANT, "WARNING: max_filedescriptors limited to " << FD_SETSIZE << " by select() algorithm.");
+    }
+#endif
+
     storeConfigure();
 
     snprintf(ThisCache, sizeof(ThisCache), "%s (%s)",
@@ -1584,7 +1594,7 @@ free_acl_b_size_t(acl_size_t ** head)
 #include "DelayPools.h"
 #include "DelayConfig.h"
 /* do nothing - free_delay_pool_count is the magic free function.
- * this is why delay_pool_count isn't just marked TYPE: ushort
+ * this is why delay_pool_count isn't just marked TYPE: u_short
  */
 #define free_delay_pool_class(X)
 #define free_delay_pool_access(X)
@@ -1634,7 +1644,7 @@ parse_delay_pool_access(DelayConfig * cfg)
 #if USE_DELAY_POOLS
 #include "ClientDelayConfig.h"
 /* do nothing - free_client_delay_pool_count is the magic free function.
- * this is why client_delay_pool_count isn't just marked TYPE: ushort
+ * this is why client_delay_pool_count isn't just marked TYPE: u_short
  */
 
 #define free_client_delay_pool_access(X)
@@ -3152,19 +3162,19 @@ free_b_int64_t(int64_t * var)
 #define free_kb_int64_t free_b_int64_t
 
 static void
-dump_ushort(StoreEntry * entry, const char *name, u_short var)
+dump_u_short(StoreEntry * entry, const char *name, u_short var)
 {
     storeAppendPrintf(entry, "%s %d\n", name, var);
 }
 
 static void
-free_ushort(u_short * u)
+free_u_short(u_short * u)
 {
     *u = 0;
 }
 
 static void
-parse_ushort(u_short * var)
+parse_u_short(u_short * var)
 {
     ConfigParser::ParseUShort(var);
 }
@@ -61,7 +61,7 @@ time_msec
 time_t
 tristate
 uri_whitespace
-ushort
+u_short
 wccp2_method
 wccp2_amethod
 wccp2_service
@@ -4768,7 +4768,7 @@ LOC: Config.Announce.file
 DOC_NONE
 
 NAME: announce_port
-TYPE: ushort
+TYPE: u_short
 DEFAULT: 3131
 LOC: Config.Announce.port
 DOC_START
@@ -5010,7 +5010,7 @@ DOC_END
 
 NAME: delay_initial_bucket_level
 COMMENT: (percent, 0-100)
-TYPE: ushort
+TYPE: u_short
 DEFAULT: 50
 IFDEF: USE_DELAY_POOLS
 LOC: Config.Delay.initial
@@ -5042,7 +5042,7 @@ DOC_END
 
 NAME: client_delay_initial_bucket_level
 COMMENT: (percent, 0-no_limit)
-TYPE: ushort
+TYPE: u_short
 DEFAULT: 50
 IFDEF: USE_DELAY_POOLS
 LOC: Config.ClientDelay.initial
@@ -5452,7 +5452,7 @@ COMMENT_START
 COMMENT_END
 
 NAME: snmp_port
-TYPE: ushort
+TYPE: u_short
 LOC: Config.Port.snmp
 DEFAULT: 0
 IFDEF: SQUID_SNMP
@@ -5524,7 +5524,7 @@ COMMENT_START
 COMMENT_END
 
 NAME: icp_port udp_port
-TYPE: ushort
+TYPE: u_short
 DEFAULT: 0
 LOC: Config.Port.icp
 DOC_START
@@ -5538,7 +5538,7 @@ DOC_END
 
 NAME: htcp_port
 IFDEF: USE_HTCP
-TYPE: ushort
+TYPE: u_short
 DEFAULT: 0
 LOC: Config.Port.htcp
 DOC_START
@@ -5799,7 +5799,7 @@ DOC_END
 
 NAME: mcast_miss_ttl
 IFDEF: MULTICAST_MISS_STREAM
-TYPE: ushort
+TYPE: u_short
 LOC: Config.mcast_miss.ttl
 DEFAULT: 16
 DOC_START
@@ -5810,7 +5810,7 @@ DOC_END
 
 NAME: mcast_miss_port
 IFDEF: MULTICAST_MISS_STREAM
-TYPE: ushort
+TYPE: u_short
 LOC: Config.mcast_miss.port
 DEFAULT: 3135
 DOC_START
@@ -6037,6 +6037,7 @@ DOC_START
 			  (HTTPS URLs terminate with *)
 		%u	- Full canonical URL from client
 		%w	- Admin email from squid.conf
+		%x	- Error name
 		%%	- Literal percent (%) code
 
 DOC_END
@@ -6549,6 +6550,26 @@ DOC_START
 		is to use IPv4-only connections. When set to 'on' this option will
 		make Squid use IPv6-only connections to contact this ICAP service.
 
+	on-overload=block|bypass|wait|force
+		If the service Max-Connections limit has been reached, do
+		one of the following for each new ICAP transaction:
+		  * block:  send an HTTP error response to the client
+		  * bypass: ignore the "over-connected" ICAP service
+		  * wait:   wait (in a FIFO queue) for an ICAP connection slot
+		  * force:  proceed, ignoring the Max-Connections limit 
+
+		In SMP mode with N workers, each worker assumes the service
+		connection limit is Max-Connections/N, even though not all
+		workers may use a given service.
+
+		The default value is "bypass" if service is bypassable,
+		otherwise it is set to "wait".
+		
+
+	max-conn=number
+		Use the given number as the Max-Connections limit, regardless
+		of the Max-Connections value given by the service, if any.
+
 	Older icap_service format without optional named parameters is
 	deprecated but supported for backward compatibility.
 
@@ -2120,10 +2120,10 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     }
 
     /* Request line is valid here .. */
-    *http_ver = HttpVersion(hp->v_maj, hp->v_min);
+    *http_ver = HttpVersion(hp->req.v_maj, hp->req.v_min);
 
     /* This call scans the entire request, not just the headers */
-    if (hp->v_maj > 0) {
+    if (hp->req.v_maj > 0) {
         if ((req_sz = headersEnd(hp->buf, hp->bufsiz)) == 0) {
             debugs(33, 5, "Incomplete request, waiting for end of headers");
             return NULL;
@@ -2143,7 +2143,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
 
     hp->hdr_end = req_sz - 1;
 
-    hp->hdr_start = hp->req_end + 1;
+    hp->hdr_start = hp->req.end + 1;
 
     /* Enforce max_request_size */
     if (req_sz >= Config.maxRequestHeaderSize) {
@@ -2153,7 +2153,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     }
 
     /* Set method_p */
-    *method_p = HttpRequestMethod(&hp->buf[hp->m_start], &hp->buf[hp->m_end]+1);
+    *method_p = HttpRequestMethod(&hp->buf[hp->req.m_start], &hp->buf[hp->req.m_end]+1);
 
     /* deny CONNECT via accelerated ports */
     if (*method_p == METHOD_CONNECT && csd && csd->port && csd->port->accel) {
@@ -2176,7 +2176,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
      * TODO: Use httpRequestParse here.
      */
     /* XXX this code should be modified to take a const char * later! */
-    req_hdr = (char *) hp->buf + hp->req_end + 1;
+    req_hdr = (char *) hp->buf + hp->req.end + 1;
 
     debugs(33, 3, "parseHttpRequest: req_hdr = {" << req_hdr << "}");
 
@@ -2209,11 +2209,11 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
      * XXX this should eventually not use a malloc'ed buffer; the transformation code
      * below needs to be modified to not expect a mutable nul-terminated string.
      */
-    char *url = (char *)xmalloc(hp->u_end - hp->u_start + 16);
+    char *url = (char *)xmalloc(hp->req.u_end - hp->req.u_start + 16);
 
-    memcpy(url, hp->buf + hp->u_start, hp->u_end - hp->u_start + 1);
+    memcpy(url, hp->buf + hp->req.u_start, hp->req.u_end - hp->req.u_start + 1);
 
-    url[hp->u_end - hp->u_start + 1] = '\0';
+    url[hp->req.u_end - hp->req.u_start + 1] = '\0';
 
 #if THIS_VIOLATES_HTTP_SPECS_ON_URL_TRANSFORMATION
 
@@ -41,15 +41,40 @@
 #include "comm.h"
 #include "CommCalls.h"
 #include "HttpControlMsg.h"
+#include "HttpParser.h"
 #include "RefCount.h"
 #include "StoreIOBuffer.h"
 
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
 class ChunkedCodingParser;
-class HttpParser;
 
+/**
+ * Badly named.
+ * This is in fact the processing context for a single HTTP request.
+ *
+ * Managing what has been done, and what happens next to the data buffer
+ * holding what we hope is an HTTP request.
+ *
+ * Parsing is still a mess of global functions done in conjunction with the
+ * real socket controller which generated ClientHttpRequest.
+ * It also generates one of us and passes us control from there based on
+ * the results of the parse.
+ *
+ * After that all the request interpretation and adaptation is in our scope.
+ * Then finally the reply fetcher is created by this and we get the result
+ * back. Which we then have to manage writing of it to the ConnStateData.
+ *
+ * The socket level management is done by a ConnStateData which owns us.
+ * The scope of this objects control over a socket consists of the data
+ * buffer received from ConnStateData with an initially unknown length.
+ * When that length is known it sets the end bounary of our acces to the
+ * buffer.
+ *
+ * The individual processing actions are done by other Jobs which we
+ * kick off as needed.
+ */
 class ClientSocketContext : public RefCountable
 {
 
@@ -134,7 +159,22 @@ class ClientSocketContext : public RefCountable
 };
 
 
-/** A connection to a socket */
+class ConnectionDetail;
+
+/**
+ * Manages a connection to a client.
+ *
+ * Multiple requests (up to 2) can be pipelined. This object is responsible for managing
+ * which one is currently being fulfilled and what happens to the queue if the current one
+ * causes the client connection to be closed early.
+ *
+ * Act as a manager for the connection and passes data in buffer to the current parser.
+ * the parser has ambiguous scope at present due to being made from global functions
+ * I believe this object uses the parser to identify boundaries and kick off the
+ * actual HTTP request handling objects (ClientSocketContext, ClientHttpRequest, HttpRequest)
+ *
+ * If the above can be confirmed accurate we can call this object PipelineManager or similar
+ */
 class ConnStateData : public BodyProducer, public HttpControlMsgSink
 {
 
@@ -1070,14 +1070,6 @@ clientReplyContext::storeNotOKTransferDone() const
         /* haven't found end of headers yet */
         return 0;
 
-    int sending = SENDING_BODY;
-
-    if (curReply->sline.status == HTTP_NO_CONTENT ||
-            curReply->sline.status == HTTP_NOT_MODIFIED ||
-            curReply->sline.status < HTTP_OK ||
-            http->request->method == METHOD_HEAD)
-        sending = SENDING_HDRSONLY;
-
     /*
      * Figure out how much data we are supposed to send.
      * If we are sending a body and we don't have a content-length,
@@ -1265,9 +1257,9 @@ clientReplyContext::buildReplyHeader()
         hdr->delById(HDR_SET_COOKIE);
     // TODO: RFC 2965 : Must honour Cache-Control: no-cache="set-cookie2" and remove header.
 
-    // if there is not configured a peer proxy with login=PASS option enabled
+    // if there is not configured a peer proxy with login=PASS or login=PASSTHRU option enabled
     // remove the Proxy-Authenticate header
-    if ( !(request->peer_login && strcmp(request->peer_login,"PASS") ==0))
+    if ( !request->peer_login || (strcmp(request->peer_login,"PASS") != 0 && strcmp(request->peer_login,"PASSTHRU") != 0))
         reply->header.delById(HDR_PROXY_AUTHENTICATE);
 
     reply->header.removeHopByHopEntries();
@@ -2061,13 +2053,10 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
 
     char *buf = next()->readBuffer.data;
 
-    char *body_buf = buf;
-
     if (buf != result.data) {
         /* we've got to copy some data */
         assert(result.length <= next()->readBuffer.length);
         memcpy(buf, result.data, result.length);
-        body_buf = buf;
     }
 
     if (reqofs==0 && !logTypeIsATcpHit(http->logType) && Comm::IsConnOpen(conn->clientConnection)) {
@@ -1021,7 +1021,6 @@ clientRedirectDoneWrapper(void *data, char *result)
 void
 ClientRequestContext::clientRedirectDone(char *result)
 {
-    HttpRequest *new_request = NULL;
     HttpRequest *old_request = http->request;
     debugs(85, 5, "clientRedirectDone: '" << http->uri << "' result=" << (result ? result : "NULL"));
     assert(redirect_state == REDIRECT_PENDING);
@@ -1047,42 +1046,35 @@ ClientRequestContext::clientRedirectDone(char *result)
                     debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid 303 redirect Location: " << result);
             }
         } else if (strcmp(result, http->uri)) {
-            if (!(new_request = HttpRequest::CreateFromUrlAndMethod(result, old_request->method)))
+            // XXX: validate the URL properly *without* generating a whole new request object right here.
+            // XXX: the clone() should be done only AFTER we know the new URL is valid.
+            HttpRequest *new_request = old_request->clone();
+            if (urlParse(old_request->method, result, new_request)) {
+                debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
+
+                // update the new request to flag the re-writing was done on it
+                new_request->flags.redirected = 1;
+
+                // unlink bodypipe from the old request. Not needed there any longer.
+                if (old_request->body_pipe != NULL) {
+                    old_request->body_pipe = NULL;
+                    debugs(61,2, HERE << "URL-rewriter diverts body_pipe " << new_request->body_pipe <<
+                           " from request " << old_request << " to " << new_request);
+                }
+
+                // update the current working ClientHttpRequest fields
+                safe_free(http->uri);
+                http->uri = xstrdup(urlCanonical(new_request));
+                HTTPMSGUNLOCK(old_request);
+                http->request = HTTPMSGLOCK(new_request);
+            } else {
                 debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
                        old_request->method << " " << result << " HTTP/1.1");
+                delete new_request;
+            }
         }
     }
 
-    if (new_request) {
-        safe_free(http->uri);
-        http->uri = xstrdup(urlCanonical(new_request));
-        new_request->http_ver = old_request->http_ver;
-        new_request->header.append(&old_request->header);
-        new_request->client_addr = old_request->client_addr;
-#if FOLLOW_X_FORWARDED_FOR
-        new_request->indirect_client_addr = old_request->indirect_client_addr;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-        new_request->my_addr = old_request->my_addr;
-        new_request->flags = old_request->flags;
-        new_request->flags.redirected = 1;
-#if USE_AUTH
-        new_request->auth_user_request = old_request->auth_user_request;
-#endif
-        if (old_request->body_pipe != NULL) {
-            new_request->body_pipe = old_request->body_pipe;
-            old_request->body_pipe = NULL;
-            debugs(61,2, HERE << "URL-rewriter diverts body_pipe " << new_request->body_pipe <<
-                   " from request " << old_request << " to " << new_request);
-        }
-
-        new_request->content_length = old_request->content_length;
-        new_request->extacl_user = old_request->extacl_user;
-        new_request->extacl_passwd = old_request->extacl_passwd;
-        new_request->flags.proxy_keepalive = old_request->flags.proxy_keepalive;
-        HTTPMSGUNLOCK(old_request);
-        http->request = HTTPMSGLOCK(new_request);
-    }
-
     /* FIXME PIPELINE: This is innacurate during pipelining */
 
     if (http->getConn() != NULL && Comm::IsConnOpen(http->getConn()->clientConnection))
@@ -1640,8 +1632,12 @@ ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
     repContext->setReplyToError(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR,
                                 request->method, NULL,
                                 (c != NULL ? c->clientConnection->remote : noAddr), request, NULL,
+#if USE_AUTH
                                 (c != NULL && c->auth_user_request != NULL ?
                                  c->auth_user_request : request->auth_user_request));
+#else
+                                NULL);
+#endif
 
     request->detailError(ERR_ICAP_FAILURE, errDetail);
 
@@ -1016,7 +1016,7 @@ comm_lingering_close(int fd)
 
 #endif
 
-/*
+/**
  * enable linger with time of 0 so that when the socket is
  * closed, TCP generates a RESET
  */
@@ -1157,7 +1157,7 @@ _comm_close(int fd, char const *file, int line)
     commCallCloseHandlers(fd);
 
     if (F->pconn.uses)
-        F->pconn.pool->count(F->pconn.uses);
+        F->pconn.pool->noteUses(F->pconn.uses);
 
     comm_empty_os_read_buffers(fd);
 
@@ -341,7 +341,9 @@ CommonPool::Factory(unsigned char _class, CompositePoolNode::Pointer& compositeC
             temp->push_back (new Aggregate);
             temp->push_back (new ClassCNetPool);
             temp->push_back (new ClassCHostPool);
+#if USE_AUTH
             temp->push_back (new DelayUser);
+#endif
         }
         break;
 
@@ -1482,8 +1482,6 @@ idnsInit(void)
     CBDATA_INIT_TYPE(idns_query);
 
     if (DnsSocketA < 0 && DnsSocketB < 0) {
-        int port;
-
         Ip::Address addrA; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
         if (!Config.Addrs.udp_outgoing.IsNoAddr())
@@ -1519,12 +1517,12 @@ idnsInit(void)
          * statement. Doing so messes up the internal Debug::level
          */
         if (DnsSocketB >= 0) {
-            port = comm_local_port(DnsSocketB);
+            comm_local_port(DnsSocketB);
             debugs(78, 1, "DNS Socket created at " << addrB << ", FD " << DnsSocketB);
             Comm::SetSelect(DnsSocketB, COMM_SELECT_READ, idnsRead, NULL, 0);
         }
         if (DnsSocketA >= 0) {
-            port = comm_local_port(DnsSocketA);
+            comm_local_port(DnsSocketA);
             debugs(78, 1, "DNS Socket created at " << addrA << ", FD " << DnsSocketA);
             Comm::SetSelect(DnsSocketA, COMM_SELECT_READ, idnsRead, NULL, 0);
         }
@@ -569,7 +569,6 @@ int
 ErrorState::Dump(MemBuf * mb)
 {
     MemBuf str;
-    const char *p = NULL;	/* takes priority over mb if set */
     char ntoabuf[MAX_IPSTRLEN];
 
     str.reset();
@@ -624,10 +623,6 @@ ErrorState::Dump(MemBuf * mb)
         packerToMemInit(&pck, &str);
         request->header.packInto(&pck);
         packerClean(&pck);
-    } else if (request_hdrs) {
-        p = request_hdrs;
-    } else {
-        p = "[none]";
     }
 
     str.Printf("\r\n");
@@ -923,6 +918,16 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         no_urlescape = 1;
         break;
 
+    case 'x':
+#if USE_SSL
+        if (detail)
+            mb.Printf("%s", detail->errorName());
+        else
+#endif
+            if (!building_deny_info_url)
+                p = "[Unknown Error Code]";
+        break;
+
     case 'z':
         if (building_deny_info_url) break;
         if (dnsError.size() > 0)
@@ -81,6 +81,7 @@
    u - URL with password                        x
    w - cachemgr email address                   x
    W - error data (to be included in the mailto links)
+   x - error name                               x
    z - dns server error message                 x
    Z - Preformatted error message               x
  \endverbatim
@@ -195,7 +196,7 @@ SQUIDCEXTERN void errorInitialize(void);
 SQUIDCEXTERN void errorClean(void);
 
 /**
- \ingroup ErrorPageAPI
+ * \ingroup ErrorPageAPI
  *
  * This function generates a error page from the info contained
  * by err and then sends it to the client.
@@ -801,12 +801,9 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 
             if (acl->def->theHelper->stats.queue_size <= (int)acl->def->theHelper->childs.n_active) {
                 debugs(82, 2, "aclMatchExternal: \"" << key << "\": queueing a call.");
-                ch->changeState (ExternalACLLookup::Instance());
-
-                if (entry == NULL) {
-                    debugs(82, 2, "aclMatchExternal: \"" << key << "\": return -1.");
-                    return -1;
-                }
+                ch->changeState(ExternalACLLookup::Instance());
+                debugs(82, 2, "aclMatchExternal: \"" << key << "\": return -1.");
+                return -1; // to get here we have to have an expired cache entry. MUST not use.
             } else {
                 if (!entry) {
                     debugs(82, 1, "aclMatchExternal: '" << acl->def->name <<
@@ -497,10 +497,9 @@ fqdncacheHandleReply(void *data, char *reply)
 fqdncacheHandleReply(void *data, rfc1035_rr * answers, int na, const char *error_message)
 #endif
 {
-    int n;
     fqdncache_entry *f;
     static_cast<generic_cbdata *>(data)->unwrap(&f);
-    n = ++FqdncacheStats.replies;
+    ++FqdncacheStats.replies;
     const int age = f->age();
     statHistCount(&statCounter.dns.svc_time, age);
 #if USE_DNSSERVERS
@@ -345,9 +345,9 @@ UFSStoreState::readCompleted(const char *buf, int len, int errflag, RefCount<Rea
 void
 UFSStoreState::writeCompleted(int errflag, size_t len, RefCount<WriteRequest> writeRequest)
 {
-    debugs(79, 3, "UFSStoreState::writeCompleted: dirno " << swap_dirn << ", fileno " <<
+    debugs(79, 3, HERE << "dirno " << swap_dirn << ", fileno " <<
            std::setfill('0') << std::hex << std::uppercase << std::setw(8) << swap_filen <<
-           ", len " << len );
+           ", len " << len);
     /*
      * DPW 2006-05-24
      * See doWrites() for why we don't update UFSStoreState::writing
@@ -357,8 +357,7 @@ UFSStoreState::writeCompleted(int errflag, size_t len, RefCount<WriteRequest> wr
     offset_ += len;
 
     if (theFile->error()) {
-        debugs(79,2,HERE << "UFSStoreState::writeCompleted" <<
-               " detected an error, will try to close");
+        debugs(79,2,HERE << " detected an error, will try to close");
         tryClosing();
     }
 
@@ -63,16 +63,6 @@
 		} printf("\n"); assert(b); \
 	}
 
-Ip::Address::Address()
-{
-    SetEmpty();
-}
-
-Ip::Address::~Address()
-{
-    memset(this,0,sizeof(Ip::Address));
-}
-
 int
 Ip::Address::GetCIDR() const
 {
@@ -75,7 +75,7 @@ class Address
 public:
     /** @name Constructors and Destructor */
     /*@{*/
-    Address();
+    Address() { SetEmpty(); }
     Address(const Address &);
 
     /**
@@ -94,8 +94,7 @@ class Address
     Address(const struct hostent &);
     Address(const struct addrinfo &);
     Address(const char*);
-    /// Default destructor.
-    ~Address();
+    ~Address() {}
     /*@}*/
 
     /** @name Assignment Operators */
@@ -583,9 +583,9 @@ neighbors_init(void)
                 if (thisPeer->http_port != s->s.GetPort())
                     continue;
 
-                debugs(15, 1, "WARNING: Peer looks like this host");
+                debugs(15, DBG_IMPORTANT, "WARNING: Peer looks like this host");
 
-                debugs(15, 1, "         Ignoring " <<
+                debugs(15, DBG_IMPORTANT, "         Ignoring " <<
                        neighborTypeStr(thisPeer) << " " << thisPeer->host <<
                        "/" << thisPeer->http_port << "/" <<
                        thisPeer->icp.port);
@@ -597,7 +597,7 @@ neighbors_init(void)
 
     peerRefreshDNS((void *) 1);
 
-    if (ICP_INVALID == echo_hdr.opcode) {
+    if (echo_hdr.opcode == ICP_INVALID) {
         echo_hdr.opcode = ICP_SECHO;
         echo_hdr.version = ICP_VERSION_CURRENT;
         echo_hdr.length = 0;
@@ -824,7 +824,6 @@ neighborsDigestSelect(HttpRequest * request)
     peer *best_p = NULL;
 #if USE_CACHE_DIGESTS
 
-    const cache_key *key;
     int best_rtt = 0;
     int choice_count = 0;
     int ichoice_count = 0;
@@ -835,7 +834,7 @@ neighborsDigestSelect(HttpRequest * request)
     if (!request->flags.hierarchical)
         return NULL;
 
-    key = storeKeyPublicByRequest(request);
+    storeKeyPublicByRequest(request);
 
     for (i = 0, p = first_ping; i++ < Config.npeers; p = p->next) {
         lookup_t lookup;
@@ -106,6 +106,9 @@ IdleConnList::removeAt(int index)
         theList_[index] = theList_[index + 1];
     theList_[size_-1] = NULL;
 
+    if (parent_)
+        parent_->noteConnectionRemoved();
+
     if (--size_ == 0) {
         debugs(48, 3, HERE << "deleting " << hashKeyStr(&hash));
         delete this;
@@ -140,6 +143,9 @@ IdleConnList::push(const Comm::ConnectionPointer &conn)
         delete[] oldList;
     }
 
+    if (parent_)
+        parent_->noteConnectionAdded();
+
     theList_[size_++] = conn;
     AsyncCall::Pointer readCall = commCbCall(5,4, "IdleConnList::Read",
                                              CommIoCbPtrFun(IdleConnList::Read, this));
@@ -283,7 +289,8 @@ PconnPool::dumpHash(StoreEntry *e) const
 
 /* ========== PconnPool PUBLIC FUNCTIONS ============================================ */
 
-PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr)
+PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
+        theCount(0)
 {
     int i;
     table = hash_create((HASHCMP *) strcmp, 229, hash_string);
@@ -355,13 +362,23 @@ PconnPool::pop(const Comm::ConnectionPointer &destLink, const char *domain, bool
 }
 
 void
-PconnPool::unlinkList(IdleConnList *list) const
+PconnPool::closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain)
+{
+    // TODO: optimize: we can probably do hash_lookup just once
+    for (int i = 0; i < n; ++i)
+        pop(destLink, domain, false); // may fail!
+}
+
+void
+PconnPool::unlinkList(IdleConnList *list)
 {
+    theCount -= list->count();
+    assert(theCount >= 0);
     hash_remove_link(table, &list->hash);
 }
 
 void
-PconnPool::count(int uses)
+PconnPool::noteUses(int uses)
 {
     if (uses >= PCONN_HIST_SZ)
         uses = PCONN_HIST_SZ - 1;
@@ -48,6 +48,8 @@ class IdleConnList
 
     void clearHandlers(const Comm::ConnectionPointer &conn);
 
+    int count() const { return size_; }
+
 private:
     bool removeAt(int index);
     int findIndexOf(const Comm::ConnectionPointer &conn) const;
@@ -120,7 +122,12 @@ class PconnPool
     void count(int uses);
     void dumpHist(StoreEntry *e) const;
     void dumpHash(StoreEntry *e) const;
-    void unlinkList(IdleConnList *list) const;
+    void unlinkList(IdleConnList *list);
+    void noteUses(int uses);
+    void closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain);
+    int count() const { return theCount; }
+    void noteConnectionAdded() { ++theCount; }
+    void noteConnectionRemoved() { assert(theCount > 0); --theCount; }
 
 private:
 
@@ -129,6 +136,7 @@ class PconnPool
     int hist[PCONN_HIST_SZ];
     hash_table *table;
     const char *descr;
+    int theCount; ///< the number of pooled connections
 };
 
 
@@ -419,10 +419,10 @@ peerSelectFoo(ps_state * ps)
 
 int peerAllowedToUse(const peer * p, HttpRequest * request);
 
-/*
+/**
  * peerSelectPinned
  *
- * Selects a pinned connection
+ * Selects a pinned connection.
  */
 static void
 peerSelectPinned(ps_state * ps)
@@ -444,7 +444,7 @@ peerSelectPinned(ps_state * ps)
     }
 }
 
-/*
+/**
  * peerGetSomeNeighbor
  *
  * Selects a neighbor (parent or sibling) based on one of the
@@ -8,7 +8,6 @@
 #ifndef SQUID_SNMPX_PDU_H
 #define SQUID_SNMPX_PDU_H
 
-#include "config.h"
 #include "ipc/forward.h"
 #include "Range.h"
 #include "snmp.h"
@@ -8,7 +8,6 @@
 #ifndef SQUID_SNMPX_SESSION_H
 #define SQUID_SNMPX_SESSION_H
 
-#include "config.h"
 #include "ipc/forward.h"
 #include "snmp.h"
 #include "snmp_session.h"
@@ -8,7 +8,6 @@
 #ifndef SQUID_SNMPX_VAR_H
 #define SQUID_SNMPX_VAR_H
 
-#include "config.h"
 #include "ipc/forward.h"
 #include "Range.h"
 #include "snmp_vars.h"
@@ -8,8 +8,6 @@
 #ifndef SQUID_SNMPX_FORWARD_H
 #define SQUID_SNMPX_FORWARD_H
 
-#include "config.h"
-
 namespace Snmp
 {
 
@@ -8,7 +8,6 @@
 #ifndef SQUID_SNMP_CORE_H
 #define SQUID_SNMP_CORE_H
 
-#include "config.h"
 #include "cache_snmp.h"
 #include "comm/forward.h"
 
@@ -19,133 +19,133 @@ SslErrorDetails TheSslDetail;
 static SslErrorDetailEntry TheSslDetailArray[] = {
     {X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT,
         "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT",
-        "%err_name: SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name",
+        "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name",
         "Unable to get issuer certificate"},
     {X509_V_ERR_UNABLE_TO_GET_CRL,
      "X509_V_ERR_UNABLE_TO_GET_CRL",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Unable to get certificate CRL"},
     {X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE,
      "X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Unable to decrypt certificate's signature"},
     {X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE,
      "X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Unable to decrypt CRL's signature"},
     {X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY,
      "X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
-     "%err_name: Unable to decode issuer (CA) public key: %ssl_ca_name",
+     "Unable to decode issuer (CA) public key: %ssl_ca_name",
      "Unable to decode issuer public key"},
     {X509_V_ERR_CERT_SIGNATURE_FAILURE,
      "X509_V_ERR_CERT_SIGNATURE_FAILURE",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Certificate signature failure"},
     {X509_V_ERR_CRL_SIGNATURE_FAILURE,
      "X509_V_ERR_CRL_SIGNATURE_FAILURE",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "CRL signature failure"},
     {X509_V_ERR_CERT_NOT_YET_VALID,
      "X509_V_ERR_CERT_NOT_YET_VALID",
-     "%err_name: SSL Certficate is not valid before: %ssl_notbefore",
+     "SSL Certficate is not valid before: %ssl_notbefore",
      "Certificate is not yet valid"},
     {X509_V_ERR_CERT_HAS_EXPIRED,
      "X509_V_ERR_CERT_HAS_EXPIRED",
-     "%err_name: SSL Certificate expired on: %ssl_notafter",
+     "SSL Certificate expired on: %ssl_notafter",
      "Certificate has expired"},
     {X509_V_ERR_CRL_NOT_YET_VALID,
      "X509_V_ERR_CRL_NOT_YET_VALID",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "CRL is not yet valid"},
     {X509_V_ERR_CRL_HAS_EXPIRED,
      "X509_V_ERR_CRL_HAS_EXPIRED",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "CRL has expired"},
     {X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD,
      "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD",
-     "%err_name: SSL Certificate has invalid start date (the 'not before' field): %ssl_subject",
+     "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject",
      "Format error in certificate's notBefore field"},
     {X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD,
      "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD",
-     "%err_name: SSL Certificate has invalid expiration date (the 'not after' field): %ssl_subject",
+     "SSL Certificate has invalid expiration date (the 'not after' field): %ssl_subject",
      "Format error in certificate's notAfter field"},
     {X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD,
      "X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Format error in CRL's lastUpdate field"},
     {X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD,
      "X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Format error in CRL's nextUpdate field"},
     {X509_V_ERR_OUT_OF_MEM,
      "X509_V_ERR_OUT_OF_MEM",
-     "%err_name: %ssl_error_descr",
+     "%ssl_error_descr",
      "Out of memory"},
     {X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT,
      "X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT",
-     "%err_name: Self-signed SSL Certificate: %ssl_subject",
+     "Self-signed SSL Certificate: %ssl_subject",
      "Self signed certificate"},
     {X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN,
      "X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN",
-     "%err_name: Self-signed SSL Certificate in chain: %ssl_subject",
+     "Self-signed SSL Certificate in chain: %ssl_subject",
      "Self signed certificate in certificate chain"},
     {X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
      "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
-     "%err_name: SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name",
+     "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name",
      "Unable to get local issuer certificate"},
     {X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE,
      "X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Unable to verify the first certificate"},
     {X509_V_ERR_CERT_CHAIN_TOO_LONG,
      "X509_V_ERR_CERT_CHAIN_TOO_LONG",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Certificate chain too long"},
     {X509_V_ERR_CERT_REVOKED,
      "X509_V_ERR_CERT_REVOKED",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Certificate revoked"},
     {X509_V_ERR_INVALID_CA,
      "X509_V_ERR_INVALID_CA",
-     "%err_name: %ssl_error_descr: %ssl_ca_name",
+     "%ssl_error_descr: %ssl_ca_name",
      "Invalid CA certificate"},
     {X509_V_ERR_PATH_LENGTH_EXCEEDED,
      "X509_V_ERR_PATH_LENGTH_EXCEEDED",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Path length constraint exceeded"},
     {X509_V_ERR_INVALID_PURPOSE,
      "X509_V_ERR_INVALID_PURPOSE",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Unsupported certificate purpose"},
     {X509_V_ERR_CERT_UNTRUSTED,
      "X509_V_ERR_CERT_UNTRUSTED",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Certificate not trusted"},
     {X509_V_ERR_CERT_REJECTED,
      "X509_V_ERR_CERT_REJECTED",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Certificate rejected"},
     {X509_V_ERR_SUBJECT_ISSUER_MISMATCH,
      "X509_V_ERR_SUBJECT_ISSUER_MISMATCH",
-     "%err_name: %ssl_error_descr: %ssl_ca_name",
+     "%ssl_error_descr: %ssl_ca_name",
      "Subject issuer mismatch"},
     {X509_V_ERR_AKID_SKID_MISMATCH,
      "X509_V_ERR_AKID_SKID_MISMATCH",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Authority and subject key identifier mismatch"},
     {X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH,
      "X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH",
-     "%err_name: %ssl_error_descr: %ssl_ca_name",
+     "%ssl_error_descr: %ssl_ca_name",
      "Authority and issuer serial number mismatch"},
     {X509_V_ERR_KEYUSAGE_NO_CERTSIGN,
      "X509_V_ERR_KEYUSAGE_NO_CERTSIGN",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Key usage does not include certificate signing"},
     {X509_V_ERR_APPLICATION_VERIFICATION,
      "X509_V_ERR_APPLICATION_VERIFICATION",
-     "%err_name: %ssl_error_descr: %ssl_subject",
+     "%ssl_error_descr: %ssl_subject",
      "Application verification failure"},
-    { SSL_ERROR_NONE, "SSL_ERROR_NONE", "%err_name: No error", "No error" },
+    { SSL_ERROR_NONE, "SSL_ERROR_NONE", "No error", "No error" },
     {SSL_ERROR_NONE, NULL, NULL, NULL }
 };
 
@@ -49,6 +49,8 @@ class ErrorDetail
     ErrorDetail(ssl_error_t err_no, X509 *cert);
     ErrorDetail(ErrorDetail const &);
     const String &toString() const;  ///< An error detail string to embed in squid error pages
+    /// The error name to embed in squid error pages
+    const char *errorName() const {return err_code();}
 
 private:
     typedef const char * (ErrorDetail::*fmt_action_t)() const;
@@ -0,0 +1,30 @@
+#include "config.h"
+#include "event.h"
+
+#define STUB_API "event.cc"
+#include "tests/STUB.h"
+
+void eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata) STUB
+void eventAddIsh(const char *name, EVH * func, void *arg, double delta_ish, int) STUB
+void eventDelete(EVH * func, void *arg) STUB
+void eventInit(void) STUB
+void eventFreeMemory(void) STUB
+int eventFind(EVH *, void *) STUB_RETVAL(-1)
+
+// ev_entry::ev_entry(char const * name, EVH * func, void *arg, double when, int weight, bool cbdata) STUB
+// ev_entry::~ev_entry() STUB
+//    MEMPROXY_CLASS(ev_entry);
+//    EVH *func;
+
+//MEMPROXY_CLASS_INLINE(ev_entry);
+
+EventScheduler::EventScheduler() STUB
+EventScheduler::~EventScheduler() STUB
+void EventScheduler::cancel(EVH * func, void * arg) STUB
+void EventScheduler::clean() STUB
+int EventScheduler::checkDelay() STUB_RETVAL(-1)
+void EventScheduler::dump(StoreEntry *) STUB
+bool EventScheduler::find(EVH * func, void * arg) STUB_RETVAL(false)
+void EventScheduler::schedule(const char *name, EVH * func, void *arg, double when, int weight, bool cbdata) STUB
+int EventScheduler::checkEvents(int timeout) STUB_RETVAL(-1)
+EventScheduler *EventScheduler::GetInstance() STUB_RETVAL(NULL)
@@ -70,6 +70,12 @@ PconnPool::count(int uses)
     fatal("pconn.cc required");
 }
 
+void
+PconnPool::noteUses(int)
+{
+    fatal("pconn.cc required");
+}
+
 void
 PconnPool::dumpHist(StoreEntry *e) const
 {
@@ -83,7 +89,7 @@ PconnPool::dumpHash(StoreEntry *e) const
 }
 
 void
-PconnPool::unlinkList(IdleConnList *list) const
+PconnPool::unlinkList(IdleConnList *list)
 {
     fatal("pconn.cc required");
 }
@@ -0,0 +1,912 @@
+#define SQUID_UNIT_TEST 1
+#include "config.h"
+
+#include <cppunit/TestAssert.h>
+
+#include "testHttpParser.h"
+#include "HttpParser.h"
+#include "Mem.h"
+#include "MemBuf.h"
+
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testHttpParser );
+
+void
+testHttpParser::globalSetup()
+{
+    static bool setup_done = false;
+    if (setup_done)
+        return;
+
+    Mem::Init();
+    setup_done = true;
+}
+
+void
+testHttpParser::testParseRequestLine()
+{
+    // ensure MemPools etc exist
+    globalSetup();
+
+    MemBuf input;
+    HttpParser output;
+    input.init();
+
+    // TEST: Do we comply with RFC 1945 section 5.1 ?
+    // TEST: Do we comply with RFC 2616 section 5.1 ?
+
+    // RFC 1945 : HTTP/0.9 simple-request
+    input.append("GET /\r\n", 7);
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET /\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start], (output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start], (output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+    input.reset();
+
+    // RFC 1945 and 2616 : HTTP/1.0 full-request
+    input.append("GET / HTTP/1.0\r\n", 16);
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.0\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.0", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+
+    // RFC 2616 : HTTP/1.1 full-request
+    input.append("GET / HTTP/1.1\r\n", 16);
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // RFC 2616 : future version full-request
+    input.append("GET / HTTP/10.12\r\n", 18);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/10.12\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(15, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/10.12", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(10, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_min);
+    input.reset();
+
+    // space padded URL
+    input.append("GET  /     HTTP/1.1\r\n", 21);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET  /     HTTP/1.1\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(18, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // space padded version
+    // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
+    // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
+    input.append("GET / HTTP/1.1 \n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1 \n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/ HTTP/1.1", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // whitespace inside URI. (nasty but happens)
+    input.append("GET /fo o/ HTTP/1.1\n", 20);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET /fo o/ HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/fo o/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(18, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // additional data in buffer
+    input.append("GET /     HTTP/1.1\nboo!", 23);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-5, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET /     HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end); // strangeness generated by following RFC
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(10, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(17, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // alternative EOL sequence: NL-only
+    input.append("GET / HTTP/1.1\n", 15);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // alternative EOL sequence: double-NL-only
+    input.append("GET / HTTP/1.1\n\n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-2, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // RELAXED alternative EOL sequence: multi-CR-NL
+    input.append("GET / HTTP/1.1\r\r\r\n", 18);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    Config.onoff.relaxed_header_parser = 1;
+    // Being tolerant we can ignore and elide these apparently benign CR
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\r\r\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // STRICT alternative EOL sequence: multi-CR-NL
+    input.append("GET / HTTP/1.1\r\r\r\n", 18);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    // strict mode treats these as several bare-CR in the request line which is explicitly invalid.
+    Config.onoff.relaxed_header_parser = 0;
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // RFC 2616 : . method
+    input.append(". / HTTP/1.1\n", 13);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp(". / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp(".", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // OPTIONS with * URL
+    input.append("OPTIONS * HTTP/1.1\n", 19);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("OPTIONS * HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("OPTIONS", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(8, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(8, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("*", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(10, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(17, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // unknown method
+    input.append("HELLOWORLD / HTTP/1.1\n", 22);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("HELLOWORLD / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("HELLOWORLD", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(20, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // This stage of the parser does not yet accept non-HTTP protocol names.
+    // violations mode treats them as HTTP/0.9 requests!
+    input.append("GET / FOO/1.0\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+#if USE_HTTP_VIOLATIONS
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/ FOO/1.0", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+#else
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+#endif
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / FOO/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("FOO/1.0", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    input.reset();
+
+    // RELAXED space padded method (in strict mode SP is reserved so invalid as a method byte)
+    input.append(" GET / HTTP/1.1\n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    Config.onoff.relaxed_header_parser = 1;
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // STRICT space padded method (in strict mode SP is reserved so invalid as a method byte)
+    input.append(" GET / HTTP/1.1\n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    Config.onoff.relaxed_header_parser = 0;
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp(" GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // tab padded method (NP: tab is not SP so treated as any other binary)
+    input.append("\tGET / HTTP/1.1\n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("\tGET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("\tGET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    input.append("GET", 3);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET ", 4);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET / HT", 8);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET / HTTP/1.1", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // method-only
+    input.append("A\n", 2);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("A\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // no method (but in a form which is ambiguous with HTTP/0.9 simple-request)
+    input.append("/ HTTP/1.0\n", 11);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("/ HTTP/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.0", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+    input.reset();
+
+    // RELAXED no method (an invalid format)
+    input.append(" / HTTP/1.0\n", 12);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
+    Config.onoff.relaxed_header_parser = 1;
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("/ HTTP/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(3, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(10, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.0", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+    input.reset();
+
+    // STRICT no method (an invalid format)
+    input.append(" / HTTP/1.0\n", 12);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
+    Config.onoff.relaxed_header_parser = 0;
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp(" / HTTP/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // binary code in method (strange but ...)
+    input.append("GET\x0B / HTTP/1.1\n", 16);
+    //printf("TEST: %d-%d/%d '%.*s'\n", output.req.start, output.req.end, input.contentSize(), 16, input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET\x0B / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET\x0B", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // CR in method
+    // RFC 2616 sec 5.1 prohibits CR other than in terminator.
+    input.append("GET\r / HTTP/1.1\r\n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // binary code NUL! in method (strange but ...)
+    input.append("GET\0 / HTTP/1.1\n", 16);
+    //printf("TEST: %d-%d/%d '%.*s'\n", output.req.start, output.req.end, input.contentSize(), 16, input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET\0 / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET\0", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
+    // no URL (grammer otherwise correct)
+    input.append("GET  HTTP/1.1\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET  HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+    input.reset();
+
+    // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
+    input.append("GET HTTP/1.1\n", 13);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+    input.reset();
+
+    // no version
+    input.append("GET / HTTP/\n", 12);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(10, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // no major version
+    input.append("GET / HTTP/.1\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // no version dot
+    input.append("GET / HTTP/11\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/11\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/11", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // negative major version (bug 3062)
+    input.append("GET / HTTP/-999999.1\n", 21);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/-999999.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/-999999.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // no minor version
+    input.append("GET / HTTP/1.\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // negative major version (bug 3062 corollary)
+    input.append("GET / HTTP/1.-999999\n", 21);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.-999999\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.-999999", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // binary line
+    input.append("\xB\xC\xE\xF\n", 5);
+    //printf("TEST: binary-line\n");
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("\xB\xC\xE\xF\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // mixed whitespace line
+    // We accept non-space binary bytes for method so first \t shows up as that
+    // but remaining space and tabs are skipped searching for URI-start
+    input.append("\t \t \t\n", 6);
+    //printf("TEST: mixed whitespace\n");
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("\t \t \t\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("\t", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // mixed whitespace line with CR middle
+    // CR aborts on sight, so even initial \t method is not marked as above
+    // (not when parsing clean with whole line available anyway)
+    input.append("\t  \r \n", 6);
+    //printf("TEST: mixed whitespace with CR\n");
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+}
@@ -0,0 +1,17 @@
+#ifndef SQUID_SRC_TESTS_TESTHTTPPARSER_H
+#define SQUID_SRC_TESTS_TESTHTTPPARSER_H
+
+#include <cppunit/extensions/HelperMacros.h>
+
+class testHttpParser : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testHttpParser );
+    CPPUNIT_TEST( testParseRequestLine );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    void globalSetup(); // MemPools init etc.
+    void testParseRequestLine();
+};
+
+#endif
@@ -33,7 +33,7 @@ void
 testHttpRequest::testCreateFromUrlAndMethod()
 {
     /* vanilla url */
-    ushort expected_port;
+    u_short expected_port;
     char * url = xstrdup("http://foo:90/bar");
     HttpRequest *aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_GET);
     expected_port = 90;
@@ -83,7 +83,7 @@ void
 testHttpRequest::testCreateFromUrl()
 {
     /* vanilla url */
-    ushort expected_port;
+    u_short expected_port;
     char * url = xstrdup("http://foo:90/bar");
     HttpRequest *aRequest = HttpRequest::CreateFromUrl(url);
     expected_port = 90;
@@ -102,7 +102,7 @@ testHttpRequest::testCreateFromUrl()
 void
 testHttpRequest::testIPv6HostColonBug()
 {
-    ushort expected_port;
+    u_short expected_port;
     char * url = NULL;
     HttpRequest *aRequest = NULL;
 
@@ -199,889 +199,3 @@ testHttpRequest::testSanityCheckStartLine()
     input.reset();
     error = HTTP_STATUS_NONE;
 }
-
-void
-testHttpRequest::testParseRequestLine()
-{
-    MemBuf input;
-    HttpParser output;
-    input.init();
-
-    // TEST: Do we comply with RFC 1945 section 5.1 ?
-    // TEST: Do we comply with RFC 2616 section 5.1 ?
-
-    // RFC 1945 : HTTP/0.9 simple-request
-    input.append("GET /\r\n", 7);
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET /\r\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start], (output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start], (output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.v_min);
-    input.reset();
-
-    // RFC 1945 and 2616 : HTTP/1.0 full-request
-    input.append("GET / HTTP/1.0\r\n", 16);
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.0\r\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.0", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-
-    // RFC 2616 : HTTP/1.1 full-request
-    input.append("GET / HTTP/1.1\r\n", 16);
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\r\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // RFC 2616 : future version full-request
-    input.append("GET / HTTP/10.12\r\n", 18);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/10.12\r\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(15, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/10.12", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(10, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(12, output.v_min);
-    input.reset();
-
-    // space padded URL
-    input.append("GET  /     HTTP/1.1\r\n", 21);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET  /     HTTP/1.1\r\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(11, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(18, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // space padded version
-    // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
-    // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
-    input.append("GET / HTTP/1.1 \n", 16);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1 \n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/ HTTP/1.1", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // whitespace inside URI. (nasty but happens)
-    input.append("GET /fo o/ HTTP/1.1\n", 20);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET /fo o/ HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(9, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/fo o/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(11, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(18, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // additional data in buffer
-    input.append("GET /     HTTP/1.1\nboo!", 23);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-5, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET /     HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end); // strangeness generated by following RFC
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(10, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(17, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // alternative EOL sequence: NL-only
-    input.append("GET / HTTP/1.1\n", 15);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // alternative EOL sequence: double-NL-only
-    input.append("GET / HTTP/1.1\n\n", 16);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-2, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // RELAXED alternative EOL sequence: multi-CR-NL
-    input.append("GET / HTTP/1.1\r\r\r\n", 18);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    Config.onoff.relaxed_header_parser = 1;
-    // Being tolerant we can ignore and elide these apparently benign CR
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\r\r\r\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // STRICT alternative EOL sequence: multi-CR-NL
-    input.append("GET / HTTP/1.1\r\r\r\n", 18);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    // strict mode treats these as several bare-CR in the request line which is explicitly invalid.
-    Config.onoff.relaxed_header_parser = 0;
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // RFC 2616 : . method
-    input.append(". / HTTP/1.1\n", 13);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp(". / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_end);
-    CPPUNIT_ASSERT(memcmp(".", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(2, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(11, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // OPTIONS with * URL
-    input.append("OPTIONS * HTTP/1.1\n", 19);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("OPTIONS * HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(6, output.m_end);
-    CPPUNIT_ASSERT(memcmp("OPTIONS", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(8, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(8, output.u_end);
-    CPPUNIT_ASSERT(memcmp("*", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(10, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(17, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // unknown method
-    input.append("HELLOWORLD / HTTP/1.1\n", 22);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("HELLOWORLD / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(9, output.m_end);
-    CPPUNIT_ASSERT(memcmp("HELLOWORLD", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(11, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(11, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(13, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(20, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // This stage of the parser does not yet accept non-HTTP protocol names.
-    // violations mode treats them as HTTP/0.9 requests!
-    input.append("GET / FOO/1.0\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-#if USE_HTTP_VIOLATIONS
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(12, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/ FOO/1.0", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.v_min);
-#else
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-#endif
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / FOO/1.0\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.v_end);
-    CPPUNIT_ASSERT(memcmp("FOO/1.0", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    input.reset();
-
-    // RELAXED space padded method (in strict mode SP is reserved so invalid as a method byte)
-    input.append(" GET / HTTP/1.1\n", 16);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    Config.onoff.relaxed_header_parser = 1;
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(1, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(3, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(7, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(14, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // STRICT space padded method (in strict mode SP is reserved so invalid as a method byte)
-    input.append(" GET / HTTP/1.1\n", 16);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    Config.onoff.relaxed_header_parser = 0;
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp(" GET / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // tab padded method (NP: tab is not SP so treated as any other binary)
-    input.append("\tGET / HTTP/1.1\n", 16);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("\tGET / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(3, output.m_end);
-    CPPUNIT_ASSERT(memcmp("\tGET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(7, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(14, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    input.append("GET", 3);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    input.append("GET ", 4);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    input.append("GET / HT", 8);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    input.append("GET / HTTP/1.1", 14);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // method-only
-    input.append("A\n", 2);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("A\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // no method (but in a form which is ambiguous with HTTP/0.9 simple-request)
-    input.append("/ HTTP/1.0\n", 11);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("/ HTTP/1.0\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(2, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(9, output.u_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.0", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.v_min);
-    input.reset();
-
-    // RELAXED no method (an invalid format)
-    input.append(" / HTTP/1.0\n", 12);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
-    Config.onoff.relaxed_header_parser = 1;
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(1, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("/ HTTP/1.0\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(1, output.m_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(3, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(10, output.u_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.0", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.v_min);
-    input.reset();
-
-    // STRICT no method (an invalid format)
-    input.append(" / HTTP/1.0\n", 12);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
-    Config.onoff.relaxed_header_parser = 0;
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp(" / HTTP/1.0\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // binary code in method (strange but ...)
-    input.append("GET\x0B / HTTP/1.1\n", 16);
-    //printf("TEST: %d-%d/%d '%.*s'\n", output.req_start, output.req_end, input.contentSize(), 16, input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET\x0B / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(3, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET\x0B", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(7, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(14, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // CR in method
-    // RFC 2616 sec 5.1 prohibits CR other than in terminator.
-    input.append("GET\r / HTTP/1.1\r\n", 16);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // binary code NUL! in method (strange but ...)
-    input.append("GET\0 / HTTP/1.1\n", 16);
-    //printf("TEST: %d-%d/%d '%.*s'\n", output.req_start, output.req_end, input.contentSize(), 16, input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET\0 / HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(3, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET\0", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(7, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(14, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_min);
-    input.reset();
-
-    // no URL (grammer otherwise correct)
-    input.append("GET  HTTP/1.1\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET  HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.v_min);
-    input.reset();
-
-    // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
-    input.append("GET HTTP/1.1\n", 13);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET HTTP/1.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(11, output.u_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.v_min);
-    input.reset();
-
-    // no version
-    input.append("GET / HTTP/\n", 12);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(10, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // no major version
-    input.append("GET / HTTP/.1\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // no version dot
-    input.append("GET / HTTP/11\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/11\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/11", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // negative major version (bug 3062)
-    input.append("GET / HTTP/-999999.1\n", 21);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/-999999.1\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(19, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/-999999.1", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // no minor version
-    input.append("GET / HTTP/1.\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // negative major version (bug 3062 corollary)
-    input.append("GET / HTTP/1.-999999\n", 21);
-    //printf("TEST: '%s'\n",input.content());
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.-999999\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.u_start],(output.u_end-output.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(19, output.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.-999999", &output.buf[output.v_start],(output.v_end-output.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // binary line
-    input.append("\xB\xC\xE\xF\n", 5);
-    //printf("TEST: binary-line\n");
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("\xB\xC\xE\xF\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // mixed whitespace line
-    // We accept non-space binary bytes for method so first \t shows up as that
-    // but remaining space and tabs are skipped searching for URI-start
-    input.append("\t \t \t\n", 6);
-    //printf("TEST: mixed whitespace\n");
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req_end);
-    CPPUNIT_ASSERT(memcmp("\t \t \t\n", &output.buf[output.req_start],(output.req_end-output.req_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(0, output.m_end);
-    CPPUNIT_ASSERT(memcmp("\t", &output.buf[output.m_start],(output.m_end-output.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-
-    // mixed whitespace line with CR middle
-    // CR aborts on sight, so even initial \t method is not marked as above
-    // (not when parsing clean with whole line available anyway)
-    input.append("\t  \r \n", 6);
-    //printf("TEST: mixed whitespace with CR\n");
-    HttpParserInit(&output, input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.v_min);
-    input.reset();
-}
@@ -15,7 +15,6 @@ class testHttpRequest : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testCreateFromUrl );
     CPPUNIT_TEST( testIPv6HostColonBug );
     CPPUNIT_TEST( testSanityCheckStartLine );
-    CPPUNIT_TEST( testParseRequestLine );
     CPPUNIT_TEST_SUITE_END();
 
 public:
@@ -26,7 +25,6 @@ class testHttpRequest : public CPPUNIT_NS::TestFixture
     void testCreateFromUrl();
     void testIPv6HostColonBug();
     void testSanityCheckStartLine();
-    void testParseRequestLine();
 };
 
 #endif
@@ -980,24 +980,25 @@ setMaxFD(void)
     } else if (Config.max_filedescriptors > 0) {
 #if USE_SELECT || USE_SELECT_WIN32
         /* select() breaks if this gets set too big */
-        if (Config.max_filedescriptors > FD_SETSIZE)
+        if (Config.max_filedescriptors > FD_SETSIZE) {
             rl.rlim_cur = FD_SETSIZE;
-        else
+            debugs(50, DBG_CRITICAL, "WARNING: 'max_filedescriptors " << Config.max_filedescriptors << "' does not work with select()");
+        } else
 #endif
             rl.rlim_cur = Config.max_filedescriptors;
         if (rl.rlim_cur > rl.rlim_max)
             rl.rlim_max = rl.rlim_cur;
         if (setrlimit(RLIMIT_NOFILE, &rl)) {
-            debugs(50, DBG_CRITICAL, "setrlimit: RLIMIT_NOFILE: " << xstrerror());
+            debugs(50, DBG_CRITICAL, "ERROR: setrlimit: RLIMIT_NOFILE: " << xstrerror());
             getrlimit(RLIMIT_NOFILE, &rl);
             rl.rlim_cur = rl.rlim_max;
             if (setrlimit(RLIMIT_NOFILE, &rl)) {
-                debugs(50, DBG_CRITICAL, "setrlimit: RLIMIT_NOFILE: " << xstrerror());
+                debugs(50, DBG_CRITICAL, "ERROR: setrlimit: RLIMIT_NOFILE: " << xstrerror());
             }
         }
     }
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
-        debugs(50, DBG_CRITICAL, "setrlimit: RLIMIT_NOFILE: " << xstrerror());
+        debugs(50, DBG_CRITICAL, "ERROR: getrlimit: RLIMIT_NOFILE: " << xstrerror());
     } else {
         Squid_MaxFD = rl.rlim_cur;
     }
@@ -46,7 +46,7 @@ static HttpRequest *urlParseFinish(const HttpRequestMethod& method,
                                    const char *const login,
                                    const int port,
                                    HttpRequest *request);
-static HttpRequest *urnParse(const HttpRequestMethod& method, char *urn);
+static HttpRequest *urnParse(const HttpRequestMethod& method, char *urn, HttpRequest *request);
 static const char valid_hostname_chars_u[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
     "abcdefghijklmnopqrstuvwxyz"
@@ -236,7 +236,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         port = urlDefaultPort(protocol);
         return urlParseFinish(method, protocol, url, host, login, port, request);
     } else if (!strncmp(url, "urn:", 4)) {
-        return urnParse(method, url);
+        return urnParse(method, url, request);
     } else {
         /* Parse the URL: */
         src = url;
@@ -442,6 +442,7 @@ urlParseFinish(const HttpRequestMethod& method,
         request = new HttpRequest(method, protocol, urlpath);
     else {
         request->initHTTP(method, protocol, urlpath);
+        safe_free(request->canonical);
     }
 
     request->SetHost(host);
@@ -451,9 +452,15 @@ urlParseFinish(const HttpRequestMethod& method,
 }
 
 static HttpRequest *
-urnParse(const HttpRequestMethod& method, char *urn)
+urnParse(const HttpRequestMethod& method, char *urn, HttpRequest *request)
 {
     debugs(50, 5, "urnParse: " << urn);
+    if (request) {
+        request->initHTTP(method, AnyP::PROTO_URN, urn + 4);
+        safe_free(request->canonical);
+        return request;
+    }
+
     return new HttpRequest(method, AnyP::PROTO_URN, urn + 4);
 }
 
@@ -131,7 +131,6 @@ wccpInit(void)
 void
 wccpConnectionOpen(void)
 {
-    struct addrinfo *router = NULL, *local = NULL;
     debugs(80, 5, "wccpConnectionOpen: Called");
 
     if (Config.Wccp.router.IsAnyAddr()) {
@@ -165,21 +164,21 @@ wccpConnectionOpen(void)
 
     debugs(80, 1, "Accepting WCCPv1 messages on " << Config.Wccp.address << ", FD " << theWccpConnection << ".");
 
-    Config.Wccp.router.GetAddrInfo(router,AF_INET);
 
-    if (connect(theWccpConnection, router->ai_addr, router->ai_addrlen))
-        fatal("Unable to connect WCCP out socket");
-
-    Config.Wccp.router.FreeAddrInfo(router);
+    // Sadly WCCP only does IPv4
 
-    Config.Wccp.address.InitAddrInfo(local);
+    struct sockaddr_in router;
+    Config.Wccp.router.GetSockAddr(router);
+    if (connect(theWccpConnection, (struct sockaddr*)&router, sizeof(router)))
+        fatal("Unable to connect WCCP out socket");
 
-    if (getsockname(theWccpConnection, local->ai_addr, &local->ai_addrlen))
+    struct sockaddr_in local;
+    memset(&local, '\0', sizeof(local));
+    socklen_t slen = sizeof(local);
+    if (getsockname(theWccpConnection, (struct sockaddr*)&local, &slen))
         fatal("Unable to getsockname on WCCP out socket");
 
-    local_ip = *local;
-
-    Config.Wccp.address.FreeAddrInfo(local);
+    local_ip = local;
 }
 
 
@@ -1268,6 +1268,7 @@ wccp2HandleUdp(int sock, void *not_used)
             /* Nothing to do for the types below */
 
         case WCCP2_ASSIGN_MAP:
+        case WCCP2_REDIRECT_ASSIGNMENT:
             break;
 
         default:
@@ -0,0 +1,114 @@
+#
+# All configuration options that can be enabled are enabled,
+# XXX: with the exception of those that depend on the environment.
+# TODO: Add environment-specific tests to enable more options.
+#
+# TEST: Disable auth and auth helpers. Every other possible feature enabled.
+#
+# Complete Check - everything is supposed to work at this level
+MAKETEST="distcheck"
+#
+#
+# The options for this level can be easily generated semi-automatically from configure.ac by:
+#	grep -E "^AC_ARG_ENABLE" ./configure.ac | grep -o -E "[0-9a-z\-]+[,]" | grep -o -E "[^,]+" >disable.opts
+# followed by insertion of '	--enable-' and '\' strings
+#
+# 	grep -E "^AC_ARG_WITH" ./configure.ac | grep -o -E "[0-9a-z\-]+[,]" | grep -o -E "[^,]+" >without.opts
+# followed by insertion of '	--with-' and ' \' strings
+#
+# sometimes it's just too automatic..
+#	Following options should be populated with local settings.
+#	We can't test them automatically everywhere
+#
+#   --with-default-user=NAME \
+#   --with-aufs-threads=N \
+#   --with-coss-membuf-size=N \
+#   --with-filedescriptors=N \
+#   --with-cppunit-basedir=PATH \
+#   --with-openssl=PATH \
+#   --with-po2html=PATH \
+#   --with-tags=TAGS \
+#
+#	Following features require special support from other optional packages.
+#	We can't test them automatically everywhere without detecting those
+#	optional packages first.
+#
+#   --enable-ecap \
+#   --enable-epoll \
+#   --enable-kqueue \
+#   --enable-win32-service \
+#   --with-valgrind-debug \
+#
+#   --enable-cpu-profiling \  Requires CPU support.
+#
+#
+# NP: DISTCHECK_CONFIGURE_FLAGS is a magic automake macro for the 
+#     distcheck target recursive tests beteen scripted runs.
+#     we use it to perform the same duty between our nested scripts.
+DISTCHECK_CONFIGURE_FLAGS=" \
+	--enable-loadable-modules \
+	--enable-gnuregex \
+	--enable-optimizations \
+	--enable-inline \
+	--enable-debug-cbdata \
+	--enable-xmalloc-statistics \
+	--enable-async-io \
+	--enable-storeio \
+	--enable-disk-io \
+	--enable-removal-policies \
+	--enable-icmp \
+	--enable-delay-pools \
+	--enable-icap-client \
+	--enable-useragent-log \
+	--enable-referer-log \
+	--enable-wccp \
+	--enable-wccpv2 \
+	--enable-kill-parent-hack \
+	--enable-snmp \
+	--enable-cachemgr-hostname \
+	--enable-eui \
+	--enable-htcp \
+	--enable-ssl \
+	--enable-forw-via-db \
+	--enable-cache-digests \
+	--enable-poll \
+	--enable-select \
+	--enable-http-violations \
+	--enable-ipfw-transparent \
+	--enable-leakfinder \
+	--enable-follow-x-forwarded-for \
+	--enable-ident-lookups \
+	--enable-internal-dns \
+	--enable-default-hostsfile \
+	--disable-auth \
+	--disable-basic-auth-helpers \
+	--disable-ntlm-auth-helpers \
+	--disable-negotiate-auth-helpers \
+	--disable-digest-auth-helpers \
+	--disable-ntlm-fail-open \
+	--enable-external-acl-helpers \
+	--enable-url-rewrite-helpers \
+	--enable-mempools \
+	--enable-unlinkd \
+	--enable-stacktraces \
+	--enable-vary \
+	--enable-x-accelerator-vary \
+	--enable-ipv6 \
+	--enable-auto-locale \
+	--enable-translation \
+	--enable-zph-qos \
+	--enable-esi \
+	--with-aio \
+	--with-build-environment=default \
+	--with-dl \
+	--with-dns-cname \
+	--with-gnu-ld \
+	--with-ipv6-split-stack \
+	--with-large-files \
+	--with-pic \
+	--with-pthreads \
+	--enable-build-info=squid\ test\ build \
+	"
+
+# Fix the distclean testing.
+export DISTCHECK_CONFIGURE_FLAGS