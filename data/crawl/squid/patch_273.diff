@@ -284,6 +284,7 @@ Thank you!
     Thomas-Martin Seck <tmseck@netcologne.de>
     Tianyin Xu <tixu@cs.ucsd.edu>
     Tim Starling <tstarling@wikimedia.org>
+    Todd C. Miller <Todd.Miller@courtesan.com>
     Tomas Hozza <thozza@redhat.com>
     Tony Lorimer <tlorimer@au.mdis.com>
     Unknown - NetBSD Project
@@ -465,6 +465,25 @@ compat/inet_pton.c:
 
 ==============================================================================
 
+compat/memrchr.cc,
+compat/memrchr.h:
+
+ * Copyright (c) 2007 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+==============================================================================
+
 compat/strtoll.c:
 
 /*-
@@ -1,3 +1,8 @@
+Changes to squid-3.4.8 (15 Sep 2014):
+
+	- Fix off by one in SNMP subsystem
+	- pinger: Fix various ICMP handling issues
+
 Changes to squid-3.4.7 (28 Aug 2014):
 
 	- Regression Fix: Kerberos LDAP authorizing groups with principle subdomain
@@ -248,12 +248,35 @@ fi
 dnl checks for existence of krb5 functions
 AC_DEFUN([SQUID_CHECK_KRB5_FUNCS],[
 
+  ac_com_error_message=no
+  if test "x$ac_cv_header_com_err_h" = "xyes" ; then
+    AC_EGREP_HEADER(error_message,com_err.h,ac_com_error_message=yes)
+  elif test "x$ac_cv_header_et_com_err_h" = "xyes" ; then
+    AC_EGREP_HEADER(error_message,et/com_err.h,ac_com_error_message=yes)
+  fi
+
+  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
+    AC_CHECK_LIB(com_err,error_message,
+      AC_DEFINE(HAVE_ERROR_MESSAGE,1,
+        [Define to 1 if you have error_message]),)
+  elif test  "x$ac_com_error_message" = "xyes" ; then
+    AC_CHECK_LIB(krb5,error_message,
+      AC_DEFINE(HAVE_ERROR_MESSAGE,1,
+        [Define to 1 if you have error_message]),)
+  fi
+
   AC_CHECK_LIB(krb5,krb5_get_err_text,
     AC_DEFINE(HAVE_KRB5_GET_ERR_TEXT,1,
       [Define to 1 if you have krb5_get_err_text]),)
   AC_CHECK_LIB(krb5,krb5_get_error_message,
     AC_DEFINE(HAVE_KRB5_GET_ERROR_MESSAGE,1,
       [Define to 1 if you have krb5_get_error_message]),)
+  AC_CHECK_LIB(krb5,krb5_free_error_message,
+    AC_DEFINE(HAVE_KRB5_FREE_ERROR_MESSAGE,1,
+      [Define to 1 if you have krb5_free_error_message]),)
+  AC_CHECK_LIB(krb5,krb5_free_error_string,
+    AC_DEFINE(HAVE_KRB5_FREE_ERROR_STRING,1,
+      [Define to 1 if you have krb5_free_error_string]),)
   AC_CHECK_DECLS(krb5_kt_free_entry,,,[#include <krb5.h>])
   AC_CHECK_TYPE(krb5_pac,
     AC_DEFINE(HAVE_KRB5_PAC,1,
@@ -297,7 +320,6 @@ AC_DEFUN([SQUID_CHECK_KRB5_FUNCS],[
 	AC_MSG_RESULT(yes)
     ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
 
-
   AC_CHECK_FUNCS(gss_map_name_to_any,
     AC_DEFINE(HAVE_GSS_MAP_ANY_TO_ANY,1,
       [Define to 1 if you have gss_map_name_to_any]),)
@@ -619,6 +619,27 @@ SQUID_DEFINE_BOOL(HAVE_STATVFS,$ac_cv_func_statvfs,[set to 1 if our system has s
 ])
 
 
+dnl Check whether this OS defines f_frsize as a member of struct statfs
+AC_DEFUN([SQUID_CHECK_F_FRSIZE_IN_STATFS],[
+AC_CACHE_CHECK([for f_frsize field in struct statfs],
+                ac_cv_have_f_frsize_in_struct_statfs, [
+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#if HAVE_SYS_STATFS_H
+#include <sts/statfs.h>
+#endif
+#if HAVE_SYS_STATVFS_H
+#include <sts/statvfs.h>
+#endif
+#if HAVE_SYS_VFS_H
+#include <sts/vfs.h>
+#endif
+                ]], [[ struct statfs s; s.f_frsize = 0; ]])],[ ac_cv_have_f_frsize_in_struct_statfs="yes" ],[ ac_cv_have_f_frsize_in_struct_statfs="no" 
+        ])
+])
+SQUID_DEFINE_BOOL(HAVE_F_FRSIZE_IN_STATFS,$ac_cv_have_f_frsize_in_struct_statfs,[Define if struct statfs has field f_frsize (Linux 2.6 or later)])
+])
+
+
 dnl check that we can use the libresolv _dns_ttl_ hack
 dnl sets the ac_cv_libresolv_dns_ttl_hack shell variable and defines LIBRESOLV_DNS_TTL_HACK
 
@@ -38,10 +38,14 @@ libcompat_squid_la_SOURCES = \
 	inet_ntop.h \
 	inet_pton.h \
 	initgroups.h \
+	memrchr.cc \
+	memrchr.h \
 	osdetect.h \
 	psignal.h \
 	shm.cc \
 	shm.h \
+	statvfs.h \
+	statvfs.cc \
 	stdio.h \
 	stdvarargs.h \
 	strnstr.cc \
@@ -18,7 +18,10 @@
 #include <sys/socket.h>
 #endif
 
-// WinSock2.h defines these for Windows
+// mswsock.h defines WSA_CMSG definitions
+#if HAVE_MSWSOCK_H
+#include <mswsock.h>
+#endif
 #if HAVE_WINSOCK2_H
 #include <winsock2.h>
 #endif
@@ -39,12 +42,17 @@ struct cmsghdr {
 #endif
 
 /* lifted off https://metacpan.org/source/SAMPO/Socket-PassAccessRights-0.03/passfd.c */
-#ifndef CMSG_DATA
-# define CMSG_DATA(cmsg) ((cmsg)->cmsg_data)
+// check for WSA_CMSG first because Windows defines CMSG_DATA for other uses
+#if defined(WSA_CMSG_DATA)
+# define SQUID_CMSG_DATA(cmsg) WSA_CMSG_DATA(cmsg)
+#elif defined(CMSG_DATA)
+# define SQUID_CMSG_DATA(cmsg) CMSG_DATA(cmsg)
+#else
+# define SQUID_CMSG_DATA(cmsg) ((cmsg)->cmsg_data)
 #endif
 
 #ifndef CMSG_NXTHDR
-# define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+# define CMSG_NXTHDR(mhdr, X) __cmsg_nxthdr (mhdr, X)
 #endif
 
 #ifndef CMSG_FIRSTHDR
@@ -92,6 +92,9 @@
 /* cstdio has a bunch of problems with 64-bit definitions */
 #include "compat/stdio.h"
 
+/* POSIX statvfs() is still not universal */
+#include "compat/statvfs.h"
+
 /*****************************************************/
 /* component-specific portabilities                  */
 /*****************************************************/
@@ -230,6 +230,9 @@ extern "C" {
  */
 #include "compat/strtoll.h"
 
+// memrchr() is a GNU extension. MinGW in particular does not define it.
+#include "compat/memrchr.h"
+
 #if !HAVE_MEMCPY
 #if HAVE_BCOPY
 #define memcpy(d,s,n) bcopy((s),(d),(n))
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/*
+ * Copyright (c) 2007 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "squid.h"
+
+#if !HAVE_MEMRCHR
+
+#include "compat/memrchr.h"
+
+/*
+ * Reverse memchr()
+ * Find the last occurrence of 'c' in the buffer 's' of size 'n'.
+ */
+void *
+memrchr(const void *s, int c, size_t n)
+{
+    const unsigned char *cp;
+
+    if (n != 0) {
+	cp = (unsigned char *)s + n;
+	do {
+	    if (*(--cp) == (unsigned char)c)
+		return((void *)cp);
+	} while (--n != 0);
+    }
+    return((void *)0);
+}
+
+#endif
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/*
+ * Copyright (c) 2007 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef SQUID_COMPAT_MEMRCHR_H
+#define SQUID_COMPAT_MEMRCHR_H
+
+#if !HAVE_MEMRCHR
+
+/**
+ * Reverse memchr()
+ * Find the last occurrence of 'c' in the buffer 's' of size 'n'.
+ */
+void *memrchr(const void *s, int c, size_t n);
+
+#endif
+#endif /* SQUID_COMPAT_MEMRCHR_H */
@@ -125,42 +125,6 @@ gettimeofday(struct timeval *pcur_time, void *tzp)
 }
 #endif /* !HAVE_GETTIMEOFDAY */
 
-#if !_SQUID_MINGW_
-int
-statfs(const char *path, struct statfs *sfs)
-{
-    char drive[4];
-    DWORD spc, bps, freec, totalc;
-    DWORD vsn, maxlen, flags;
-
-    if (!sfs) {
-        errno = EINVAL;
-        return -1;
-    }
-    strncpy(drive, path, 2);
-    drive[2] = '\0';
-    strcat(drive, "\\");
-
-    if (!GetDiskFreeSpace(drive, &spc, &bps, &freec, &totalc)) {
-        errno = ENOENT;
-        return -1;
-    }
-    if (!GetVolumeInformation(drive, NULL, 0, &vsn, &maxlen, &flags, NULL, 0)) {
-        errno = ENOENT;
-        return -1;
-    }
-    sfs->f_type = flags;
-    sfs->f_bsize = spc * bps;
-    sfs->f_blocks = totalc;
-    sfs->f_bfree = sfs->f_bavail = freec;
-    sfs->f_files = -1;
-    sfs->f_ffree = -1;
-    sfs->f_fsid = vsn;
-    sfs->f_namelen = maxlen;
-    return 0;
-}
-#endif
-
 #if !_SQUID_MINGW_
 int
 WIN32_ftruncate(int fd, off_t size)
@@ -32,6 +32,11 @@
 #endif
 #endif /* _SQUID_MINGW_ */
 
+#include "compat/initgroups.h"
+
+#if HAVE_DIRECT_H
+#include <direct.h>
+#endif
 #if HAVE_FCNTL_H
 #include <fcntl.h>
 #endif /* HAVE_FCNTL_H */
@@ -97,7 +102,6 @@ typedef unsigned long ino_t;
 #define fstat _fstati64
 #define lseek _lseeki64
 #define memccpy _memccpy
-#define mkdir(p,F) _mkdir((p))
 #define mktemp _mktemp
 #define snprintf _snprintf
 #define stat _stati64
@@ -108,26 +112,22 @@ typedef unsigned long ino_t;
 #define vsnprintf _vsnprintf
 #endif
 
-/* CygWin and MinGW compilers need these. Microsoft C Compiler does not. */
-#if _SQUID_MINGW_ || _SQUID_CYGWIN_
-#define mkdir(p,F) mkdir((p))
-#endif
-
 /*  Microsoft C Compiler and CygWin need these. MinGW does not */
 #if defined(_MSC_VER) || _SQUID_CYGWIN_
 SQUIDCEXTERN int WIN32_ftruncate(int fd, off_t size);
 #define ftruncate WIN32_ftruncate
 SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #define truncate WIN32_truncate
+#define chdir _chdir
 #endif
 
 /* All three compiler systems need these: */
-#define chdir _chdir
 #define dup _dup
 #define dup2 _dup2
 #define fdopen _fdopen
 #define getcwd _getcwd
 #define getpid _getpid
+#define mkdir(p,F) mkdir((p))
 #define pclose _pclose
 #define popen _popen
 #define putenv _putenv
@@ -207,15 +207,33 @@ SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #define S_IRWXO 007
 #endif
 
+/* There are no group protection bits like these in Windows.
+ * The values are used by umask() to remove permissions so
+ * mapping to user permission bits will break file accesses.
+ * Map group permissions to harmless zero instead.
+ */
+#ifndef S_IXGRP
+#define S_IXGRP 0
+#endif
+#ifndef S_IWGRP
+#define S_IWGRP 0
+#endif
+#ifndef S_IWOTH
+#define S_IWOTH 0
+#endif
+#ifndef S_IXOTH
+#define S_IXOTH 0
+#endif
+
 #if defined(_MSC_VER)
 #define	S_ISDIR(m) (((m) & _S_IFDIR) == _S_IFDIR)
 #endif
 
-#define	SIGHUP	1	/* hangup */
-#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
-#define	SIGBUS	10	/* bus error */
-#define	SIGPIPE	13	/* write on a pipe with no one to read it */
-#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define SIGHUP	1	/* hangup */
+#define SIGKILL	9	/* kill (cannot be caught or ignored) */
+#define SIGBUS	10	/* bus error */
+#define SIGPIPE	13	/* write on a pipe with no one to read it */
+#define SIGCHLD	20	/* to parent on child stop or exit */
 #define SIGUSR1 30	/* user defined signal 1 */
 #define SIGUSR2 31	/* user defined signal 2 */
 
@@ -247,21 +265,6 @@ struct group {
     char    **gr_mem;      /* group members */
 };
 
-#if !_SQUID_MINGW_
-struct statfs {
-    long    f_type;     /* type of filesystem (see below) */
-    long    f_bsize;    /* optimal transfer block size */
-    long    f_blocks;   /* total data blocks in file system */
-    long    f_bfree;    /* free blocks in fs */
-    long    f_bavail;   /* free blocks avail to non-superuser */
-    long    f_files;    /* total file nodes in file system */
-    long    f_ffree;    /* free file nodes in fs */
-    long    f_fsid;     /* file system id */
-    long    f_namelen;  /* maximum length of filenames */
-    long    f_spare[6]; /* spare for later */
-};
-#endif
-
 #if !HAVE_GETTIMEOFDAY
 struct timezone {
     int	tz_minuteswest;	/* minutes west of Greenwich */
@@ -527,7 +530,7 @@ accept(int s, struct sockaddr * a, socklen_t * l)
     } else
         return _open_osfhandle(result, 0);
 }
-#define accept(s,a,l) Squid::accept(s,a,l)
+#define accept(s,a,l) Squid::accept(s,a,reinterpret_cast<socklen_t*>(l))
 
 inline int
 bind(int s, const struct sockaddr * n, socklen_t l)
@@ -591,7 +594,7 @@ getsockname(int s, struct sockaddr * n, socklen_t * l)
     } else
         return 0;
 }
-#define getsockname(s,a,l) Squid::getsockname(s,a,l)
+#define getsockname(s,a,l) Squid::getsockname(s,a,reinterpret_cast<socklen_t*>(l))
 
 inline int
 gethostname(char * n, size_t l)
@@ -674,7 +677,7 @@ recvfrom(int s, void * b, size_t l, int f, struct sockaddr * fr, socklen_t * fl)
     } else
         return result;
 }
-#define recvfrom(s,b,l,f,r,n) Squid::recvfrom(s,b,l,f,r,n)
+#define recvfrom(s,b,l,f,r,n) Squid::recvfrom(s,b,l,f,r,reinterpret_cast<socklen_t*>(n))
 
 inline int
 select(int n, fd_set * r, fd_set * w, fd_set * e, struct timeval * t)
@@ -698,7 +701,7 @@ send(int s, const char * b, size_t l, int f)
     } else
         return result;
 }
-#define send(s,b,l,f) Squid::send(s,b,l,f)
+#define send(s,b,l,f) Squid::send(s,reinterpret_cast<const char*>(b),l,f)
 
 inline ssize_t
 sendto(int s, const void * b, size_t l, int f, const struct sockaddr * t, socklen_t tl)
@@ -867,9 +870,6 @@ struct rusage {
 
 SQUIDCEXTERN int chroot(const char *dirname);
 SQUIDCEXTERN int kill(pid_t, int);
-#if !_SQUID_MINGW_
-SQUIDCEXTERN int statfs(const char *, struct statfs *);
-#endif
 SQUIDCEXTERN struct passwd * getpwnam(char *unused);
 SQUIDCEXTERN struct group * getgrnam(char *unused);
 
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "compat/statvfs.h"
+
+#if !HAVE_STATVFS
+
+// struct statfs has some member differences between OS versions
+#if HAVE_F_FRSIZE_IN_STATFS
+#define STATFS_FRSIZE(x) (x).f_frsize
+#else
+#define STATFS_FRSIZE(x) (x).f_bsize
+#endif
+
+int
+xstatvfs(const char *path, struct statvfs *sfs)
+{
+#if !HAVE_STATFS && _SQUID_WINDOWS_
+    char drive[4];
+    DWORD spc, bps, freec, totalc;
+    DWORD vsn, maxlen, flags;
+
+    if (!sfs) {
+        errno = EINVAL;
+        return -1;
+    }
+    strncpy(drive, path, 2);
+    drive[2] = '\0';
+    strcat(drive, "\\");
+
+    if (!GetDiskFreeSpace(drive, &spc, &bps, &freec, &totalc)) {
+        errno = ENOENT;
+        return -1;
+    }
+    if (!GetVolumeInformation(drive, NULL, 0, &vsn, &maxlen, &flags, NULL, 0)) {
+        errno = ENOENT;
+        return -1;
+    }
+
+    memset(sfs, 0, sizeof(*sfs));
+
+    sfs->f_bsize = sfs->f_frsize = spc * bps;         /* file system block size, fragment size */
+    sfs->f_blocks = totalc;                           /* size of fs in f_frsize units */
+    sfs->f_bfree = sfs->f_bavail = freec;             /* # free blocks total, and available for unprivileged users */
+    sfs->f_files = sfs->f_ffree = sfs->f_favail = -1; /* # inodes total, free, and available for unprivileged users */
+    sfs->f_fsid = vsn;                                /* file system ID */
+    sfs->f_namemax = maxlen;                          /* maximum filename length */
+    return 0;
+
+#elif HAVE_STATFS
+    // use statfs() and map results from struct statfs to struct statvfs
+    struct statfs tmpSfs;
+
+    if (int x = statfs(path, &tmpSfs))
+        return x;
+
+    memset(sfs, 0, sizeof(*sfs));
+
+    sfs->f_bsize = tmpSfs.f_bsize;         /* file system block size */
+    sfs->f_frsize = STATFS_FRSIZE(tmpSfs); /* fragment size */
+    sfs->f_blocks = tmpSfs.f_blocks;       /* size of fs in f_frsize units */
+    sfs->f_bfree = tmpSfs.f_bfree;         /* # free blocks */
+    sfs->f_bavail = tmpSfs.f_bavail;       /* # free blocks for unprivileged users */
+    sfs->f_files = tmpSfs.f_files;         /* # inodes */
+    sfs->f_ffree = tmpSfs.f_ffree;         /* # free inodes */
+    sfs->f_favail = tmpSfs.f_ffree;        /* # free inodes for unprivileged users */
+    sfs->f_fsid = tmpSfs.f_fsid;           /* file system ID */
+    sfs->f_namemax = tmpSfs.f_namelen;     /* maximum filename length */
+
+#else
+#error Both statvfs() and statfs() system calls are missing.
+    errno = ENOSYS;
+    return -1;
+
+#endif
+}
+
+#endif /* HAVE_STATVFS */
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef _SQUID_COMPAT_XSTATVFS_H
+#define _SQUID_COMPAT_XSTATVFS_H
+
+#if HAVE_SYS_STATVFS_H && HAVE_STATVFS
+#include <sys/statvfs.h>
+#endif
+
+/* Windows and Linux use sys/vfs.h */
+#if HAVE_SYS_VFS_H
+#include <sys/vfs.h>
+#endif
+
+/* BSD and old Linux use sys/statfs.h */
+#if !HAVE_STATVFS
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+/* statfs() needs <sys/param.h> and <sys/mount.h> on BSD systems */
+#if HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#if HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+#endif /* !HAVE_STATVFS */
+
+
+#if HAVE_STATVFS
+#define xstatvfs statvfs
+
+#else
+
+typedef unsigned long fsblkcnt_t;
+typedef unsigned long fsfilcnt_t;
+
+struct statvfs {
+    unsigned long  f_bsize;    /* file system block size */
+    unsigned long  f_frsize;   /* fragment size */
+    fsblkcnt_t     f_blocks;   /* size of fs in f_frsize units */
+    fsblkcnt_t     f_bfree;    /* # free blocks */
+    fsblkcnt_t     f_bavail;   /* # free blocks for unprivileged users */
+    fsfilcnt_t     f_files;    /* # inodes */
+    fsfilcnt_t     f_ffree;    /* # free inodes */
+    fsfilcnt_t     f_favail;   /* # free inodes for unprivileged users */
+    unsigned long  f_fsid;     /* file system ID */
+    unsigned long  f_flag;     /* mount flags */
+    unsigned long  f_namemax;  /* maximum filename length */
+};
+
+#if defined(__cplusplus)
+extern "C"
+#endif
+int xstatvfs(const char *path, struct statvfs *buf);
+
+#endif
+
+#endif /* _SQUID_COMPAT_XSTATVFS_H */
@@ -1513,19 +1513,24 @@ if test "x$with_mit_krb5" = "xyes"; then
       ## For some OS pkg-config is broken or unavailable.
       ## Detect libraries the hard way.
 
+      SQUID_STATE_SAVE([squid_mit_save])
       AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
       AC_CHECK_LIB(com_err, [main], [LIB_KRB5_LIBS="-lcom_err $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'com_err' is required for MIT Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(k5crypto, [main], [LIB_KRB5_LIBS="-lk5crypto $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'k5crypto' is required for MIT Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(krb5, [main], [LIB_KRB5_LIBS="-lkrb5 $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'krb5' is required for MIT Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(gssapi_krb5, [main], [LIB_KRB5_LIBS="-lgssapi_krb5 $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'gssapi_krb5' is required for MIT Kerberos])
       ])
+      SQUID_STATE_ROLLBACK([squid_mit_save])
     fi
 
   ])
@@ -1546,16 +1551,6 @@ if test "x$with_mit_krb5" = "xyes"; then
     AC_CHECK_HEADERS(krb5.h com_err.h et/com_err.h)
     AC_CHECK_HEADERS(profile.h)
 
-    if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
-      AC_CHECK_LIB(com_err,error_message,
-        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
-          [Define to 1 if you have error_message]),)
-    elif test  "x$ac_com_error_message" = "xyes" ; then
-      AC_CHECK_LIB(krb5,error_message,
-        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
-          [Define to 1 if you have error_message]),)
-    fi
-
     SQUID_CHECK_KRB5_FUNCS
 
   fi
@@ -1596,13 +1591,16 @@ if test "x$with_solaris_krb5" = "xyes"; then
 
     CXXFLAGS="-I/usr/include/kerberosv5 $CXXFLAGS"
 
+    SQUID_STATE_SAVE([squid_solaris_save])
     AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
     AC_CHECK_LIB(krb5, [main], [LIB_KRB5_LIBS="-lkrb5 $LIB_KRB5_LIBS"],[
       AC_MSG_ERROR([library 'krb5' is required for Solaris Kerberos])
     ])
+    LIBS=$LIB_KRB5_LIBS
     AC_CHECK_LIB(gss, [main], [LIB_KRB5_LIBS="-lgss $LIB_KRB5_LIBS"],[
       AC_MSG_ERROR([library 'gss' is required for Solaris Kerberos])
     ])
+    SQUID_STATE_ROLLBACK([squid_solaris_save])
   fi
 
   if test "x$LIB_KRB5_LIBS" != "x"; then
@@ -1666,44 +1664,57 @@ if test "x$with_heimdal_krb5" = "xyes"; then
     else
       ## For some OS pkg-config is broken or unavailable.
       ## Detect libraries the hard way.
+      SQUID_STATE_SAVE([squid_heimdal_save])
 
       AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
       AC_CHECK_LIB(resolv, [main], [LIB_KRB5_LIBS="-lresolv $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'resolv' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(crypt, [main], [LIB_KRB5_LIBS="-lcrypt $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'crypt' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(roken, [main], [LIB_KRB5_LIBS="-lroken $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'roken' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(heimbase, [main], [LIB_KRB5_LIBS="-lheimbase $LIB_KRB5_LIBS"],[
         AC_MSG_WARN([library 'heimbase' may be required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(wind, [main], [LIB_KRB5_LIBS="-lwind $LIB_KRB5_LIBS"],[
         AC_MSG_WARN([library 'wind' may be required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(crypto, [main], [LIB_KRB5_LIBS="-lcrypto $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'crypto' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(com_err, [main], [LIB_KRB5_LIBS="-lcom_err $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'com_err' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(hx509, [main], [LIB_KRB5_LIBS="-lhx509 $LIB_KRB5_LIBS"],[
         AC_MSG_WARN([library 'hx509' may be required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(asn1, [main], [LIB_KRB5_LIBS="-lasn1 $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'asn1' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(krb5, [main], [LIB_KRB5_LIBS="-lkrb5 $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'krb5' is required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(heimntlm, [main], [LIB_KRB5_LIBS="-lheimntlm $LIB_KRB5_LIBS"],[
         AC_MSG_WARN([library 'heimntlm' may be required for Heimdal Kerberos])
       ])
+      LIBS=$LIB_KRB5_LIBS
       AC_CHECK_LIB(gssapi, [main], [LIB_KRB5_LIBS="-lgssapi $LIB_KRB5_LIBS"],[
         AC_MSG_ERROR([library 'gssapi' is required for Heimdal Kerberos])
       ])
+      SQUID_STATE_ROLLBACK([squid_heimdal_save])
     fi
 
   ])
@@ -1726,16 +1737,6 @@ if test "x$with_heimdal_krb5" = "xyes"; then
       AC_DEFINE(HAVE_BROKEN_HEIMDAL_KRB5_H, 1, [Define to 1 if Heimdal krb5.h is broken for C++])
     fi
 
-    if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
-      AC_CHECK_LIB(com_err,error_message,
-        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
-          [Define to 1 if you have error_message]),)
-    elif test  "x$ac_com_error_message" = "xyes" ; then
-      AC_CHECK_LIB(krb5,error_message,
-        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
-          [Define to 1 if you have error_message]),)
-    fi
-
     SQUID_CHECK_KRB5_FUNCS
 
   fi
@@ -2467,16 +2468,17 @@ AC_ARG_ENABLE(auth-basic,
 ])
 m4_include([helpers/basic_auth/modules.m4])
 
-AC_ARG_ENABLE(auth-ntlm,
-  AS_HELP_STRING([--enable-auth-ntlm="list of helpers"],
-     [Enable the NTLM authentication scheme, and build the specified helpers.
+AC_ARG_ENABLE(auth-digest,
+  AS_HELP_STRING([--enable-auth-digest="list of helpers"],
+     [Enable the Digest authentication scheme, and build the specified helpers.
       Not providing an explicit list of helpers will attempt build of
       all possible helpers. Default is to do so.
-      To disable the NTLM authentication scheme, use --disable-auth-ntlm.
+      To disable the Digest authentication scheme, use --disable-auth-digest.
       To enable but build no helpers, specify "none".
-      To see available helpers, see the helpers/ntlm_auth directory. ]),[
+      To see available helpers, see the helpers/digest_auth directory. ]),[
+#nothing to do, really
 ])
-m4_include([helpers/ntlm_auth/modules.m4])
+m4_include([helpers/digest_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-negotiate,
   AS_HELP_STRING([--enable-auth-negotiate="list of helpers"],
@@ -2492,17 +2494,16 @@ AC_ARG_ENABLE(auth-negotiate,
 ])
 m4_include([helpers/negotiate_auth/modules.m4])
 
-AC_ARG_ENABLE(auth-digest,
-  AS_HELP_STRING([--enable-auth-digest="list of helpers"],
-     [Enable the Digest authentication scheme, and build the specified helpers.
+AC_ARG_ENABLE(auth-ntlm,
+  AS_HELP_STRING([--enable-auth-ntlm="list of helpers"],
+     [Enable the NTLM authentication scheme, and build the specified helpers.
       Not providing an explicit list of helpers will attempt build of
       all possible helpers. Default is to do so.
-      To disable the Digest authentication scheme, use --disable-auth-digest.
+      To disable the NTLM authentication scheme, use --disable-auth-ntlm.
       To enable but build no helpers, specify "none".
-      To see available helpers, see the helpers/digest_auth directory. ]),[
-#nothing to do, really
+      To see available helpers, see the helpers/ntlm_auth directory. ]),[
 ])
-m4_include([helpers/digest_auth/modules.m4])
+m4_include([helpers/ntlm_auth/modules.m4])
 
 dnl Authentication libraries to build
 dnl This list will not be needed when each auth library has its own Makefile
@@ -2743,6 +2744,7 @@ AC_CHECK_HEADERS( \
   bstring.h \
   crypt.h \
   ctype.h \
+  direct.h \
   errno.h \
   execinfo.h \
   fcntl.h \
@@ -2802,7 +2804,6 @@ AC_CHECK_HEADERS( \
   sys/shm.h \
   sys/socket.h \
   sys/stat.h \
-  sys/statvfs.h \
   syscall.h \
   sys/syscall.h \
   sys/time.h \
@@ -3034,12 +3035,16 @@ if test "x$squid_host_os" = "xmingw" ; then
     windows.h \
     ws2tcpip.h \
     iphlpapi.h ,,,[
+#if HAVE_WINSOCK2_H
+#include <winsock2.h>
+#endif
 #if HAVE_WINDOWS_H
 #include <windows.h>
 #endif
-#if HAVE_WINSOCK2_H
-#include <winsock2.h>
-#endif])
+#if HAVE_WS2TCPIP_H
+#include <ws2tcpip.h>
+#endif
+])
 fi
 
 # check that we have unix sockets
@@ -3294,11 +3299,6 @@ if test "x$ac_cv_func_poll" = "x" ; then
   esac
 fi
 
-dnl Override statfs() detect on MinGW because it is emulated in source code
-if test "x$squid_host_os" = "xmingw" ; then
-  ac_cv_func_statfs='yes'
-fi
-
 dnl Check for library functions
 AC_CHECK_FUNCS(\
 	backtrace_symbols_fd \
@@ -3324,6 +3324,7 @@ AC_CHECK_FUNCS(\
 	mallopt \
 	memcpy \
 	memmove \
+	memrchr \
 	memset \
 	mkstemp \
 	mktime \
@@ -3354,7 +3355,6 @@ AC_CHECK_FUNCS(\
 	socketpair \
 	srand48 \
 	srandom \
-	statfs \
 	sysconf \
 	syslog \
 	timegm \
@@ -3425,11 +3425,15 @@ if test "x$squid_cv_resuid_works" = "xyes" ; then
   AC_DEFINE(HAVE_SETRESUID,1,[Yay! Another Linux brokenness. Knowing that setresuid() exists is not enough, because RedHat 5.0 declares setresuid() but does not implement it.])
 fi
 
+AC_CHECK_HEADERS(mswsock.h)
 AC_MSG_CHECKING([for constant CMSG_SPACE])
 AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
   #if HAVE_SYS_SOCKET_H
   #include <sys/socket.h>
   #endif
+  #if HAVE_MSWSOCK_H
+  #include <mswsock.h>
+  #endif
 
   int a[CMSG_SPACE(int)];
 ]])], [
@@ -3443,6 +3447,9 @@ AC_CHECK_TYPE(struct cmsghdr,AC_DEFINE(HAVE_CMSGHDR,1,[The system provides struc
   #if HAVE_SYS_SOCKET_H
   #include <sys/socket.h>
   #endif
+  #if HAVE_MSWSOCK_H
+  #include <mswsock.h>
+  #endif
   #if HAVE_WINSOCK2_H
   #include <winsock2.h>
   #endif
@@ -3464,6 +3471,9 @@ AC_CHECK_TYPE(struct msghdr,AC_DEFINE(HAVE_MSGHDR,1,[The system provides struct
   #if HAVE_SYS_SOCKET_H
   #include <sys/socket.h>
   #endif
+  #if HAVE_MSWSOCK_H
+  #include <mswsock.h>
+  #endif
   #if HAVE_WINSOCK2_H
   #include <winsock2.h>
   #endif
@@ -3649,10 +3659,15 @@ SQUID_CHECK_MAXPATHLEN
 SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
 SQUID_CHECK_RESOLVER_FIELDS
 
+AC_CHECK_HEADERS(sys/statvfs.h)
 if test "x$ac_cv_header_sys_statvfs_h" = "xyes" ; then
   SQUID_CHECK_WORKING_STATVFS
 fi
-
+if test "x$ac_cv_func_statvfs" != "xyes" ; then
+  AC_CHECK_HEADERS(sys/param.h sys/mount.h sys/vfs.h sys/statfs.h)
+  AC_CHECK_FUNCS(statfs)
+  SQUID_CHECK_F_FRSIZE_IN_STATFS
+fi
 
 dnl Squid will not usually attempt to translate templates when building
 AC_ARG_ENABLE(translation,
@@ -3766,6 +3781,7 @@ AC_CONFIG_FILES([
 	src/esi/Makefile
 	src/eui/Makefile
 	src/format/Makefile
+	src/helper/Makefile
 	src/http/Makefile
 	src/http/one/Makefile
 	src/icmp/Makefile
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.7 release notes</title>
+<title>Squid 3.4.8 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.7 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.8 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -90,6 +90,25 @@ krb5_create_cache(char *domain)
         retval = 1;
         goto cleanup;
     }
+    /*
+     * prepare memory credential cache
+     */
+#if  !HAVE_KRB5_MEMORY_CACHE || HAVE_SUN_LDAP_SDK
+    mem_cache = (char *) xmalloc(strlen("FILE:/tmp/squid_ldap_") + 16);
+    snprintf(mem_cache, strlen("FILE:/tmp/squid_ldap_") + 16, "FILE:/tmp/squid_ldap_%d", (int) getpid());
+#else
+    mem_cache = (char *) xmalloc(strlen("MEMORY:squid_ldap_") + 16);
+    snprintf(mem_cache, strlen("MEMORY:squid_ldap_") + 16, "MEMORY:squid_ldap_%d", (int) getpid());
+#endif
+
+    setenv("KRB5CCNAME", mem_cache, 1);
+    debug((char *) "%s| %s: DEBUG: Set credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
+    code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc);
+    if (code) {
+        error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+        retval = 1;
+        goto cleanup;
+    }
     /*
      * getting default keytab name
      */
@@ -151,8 +170,74 @@ krb5_create_cache(char *domain)
             retval = 1;
             break;
         }
-        if (found)
+        if (found) {
+            debug((char *) "%s| %s: DEBUG: Got principal name %s\n", LogTime(), PROGRAM, principal_name);
+            /*
+             * build principal
+             */
+            code = krb5_parse_name(kparam.context, principal_name, &principal);
+            if (code) {
+                error((char *) "%s| %s: ERROR: Error while parsing name %s : %s\n", LogTime(), PROGRAM, principal_name, error_message(code));
+                safe_free(principal_name);
+                if (principal)
+                    krb5_free_principal(kparam.context, principal);
+                found = 0;
+                continue;
+            }
+            creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
+
+            /*
+             * get credentials
+             */
+#if HAVE_GET_INIT_CREDS_KEYTAB
+            code = krb5_get_init_creds_keytab(kparam.context, creds, principal, keytab, 0, NULL, NULL);
+#else
+            service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
+            snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
+            creds->client = principal;
+            code = krb5_parse_name(kparam.context, service, &creds->server);
+            xfree(service);
+            code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
+#endif
+
+            if (code) {
+                error((char *) "%s| %s: ERROR: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+                safe_free(principal_name);
+                if (principal)
+                    krb5_free_principal(kparam.context, principal);
+                if (creds)
+                    krb5_free_creds(kparam.context, creds);
+                creds = NULL;
+                found = 0;
+                continue;
+            }
+            code = krb5_cc_initialize(kparam.context, kparam.cc, principal);
+            if (code) {
+                error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
+                safe_free(principal_name);
+                if (principal)
+                    krb5_free_principal(kparam.context, principal);
+                if (creds)
+                    krb5_free_creds(kparam.context, creds);
+                creds = NULL;
+                found = 0;
+                continue;
+            }
+            code = krb5_cc_store_cred(kparam.context, kparam.cc, creds);
+            if (code) {
+                error((char *) "%s| %s: ERROR: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                if (principal)
+                    krb5_free_principal(kparam.context, principal);
+                safe_free(principal_name);
+                if (creds)
+                    krb5_free_creds(kparam.context, creds);
+                creds = NULL;
+                found = 0;
+                continue;
+            }
+            debug((char *) "%s| %s: DEBUG: Stored credentials\n", LogTime(), PROGRAM);
             break;
+        }
     }
 
     if (code && code != KRB5_KT_END) {
@@ -166,25 +251,7 @@ krb5_create_cache(char *domain)
         retval = 1;
         goto cleanup;
     }
-    /*
-     * prepare memory credential cache
-     */
-#if  !HAVE_KRB5_MEMORY_CACHE || HAVE_SUN_LDAP_SDK
-    mem_cache = (char *) xmalloc(strlen("FILE:/tmp/squid_ldap_") + 16);
-    snprintf(mem_cache, strlen("FILE:/tmp/squid_ldap_") + 16, "FILE:/tmp/squid_ldap_%d", (int) getpid());
-#else
-    mem_cache = (char *) xmalloc(strlen("MEMORY:squid_ldap_") + 16);
-    snprintf(mem_cache, strlen("MEMORY:squid_ldap_") + 16, "MEMORY:squid_ldap_%d", (int) getpid());
-#endif
 
-    setenv("KRB5CCNAME", mem_cache, 1);
-    debug((char *) "%s| %s: DEBUG: Set credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
-    code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc);
-    if (code) {
-        error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
-        retval = 1;
-        goto cleanup;
-    }
     /*
      * if no principal name found in keytab for domain use the prinipal name which can get a TGT
      */
@@ -252,15 +319,17 @@ krb5_create_cache(char *domain)
                 goto loop_end;
             } else {
                 debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
+                if (tgt_creds)
+                    krb5_free_creds(kparam.context, tgt_creds);
+                tgt_creds = NULL;
                 break;
             }
 
 loop_end:
             safe_free(principal_name);
-            if (tgt_creds) {
+            if (tgt_creds)
                 krb5_free_creds(kparam.context, tgt_creds);
-                tgt_creds = NULL;
-            }
+            tgt_creds = NULL;
             if (creds)
                 krb5_free_creds(kparam.context, creds);
             creds = NULL;
@@ -271,53 +340,7 @@ krb5_create_cache(char *domain)
             krb5_free_creds(kparam.context, creds);
         creds = NULL;
     }
-    if (principal_name) {
-
-        debug((char *) "%s| %s: DEBUG: Got principal name %s\n", LogTime(), PROGRAM, principal_name);
-        /*
-         * build principal
-         */
-        code = krb5_parse_name(kparam.context, principal_name, &principal);
-        if (code) {
-            error((char *) "%s| %s: ERROR: Error while parsing name %s : %s\n", LogTime(), PROGRAM, principal_name, error_message(code));
-            retval = 1;
-            goto cleanup;
-        }
-        creds = (krb5_creds *) xmalloc(sizeof(*creds));
-        memset(creds, 0, sizeof(*creds));
-
-        /*
-         * get credentials
-         */
-#if HAVE_GET_INIT_CREDS_KEYTAB
-        code = krb5_get_init_creds_keytab(kparam.context, creds, principal, keytab, 0, NULL, NULL);
-#else
-        service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
-        snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
-        creds->client = principal;
-        code = krb5_parse_name(kparam.context, service, &creds->server);
-        xfree(service);
-        code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
-#endif
-        if (code) {
-            error((char *) "%s| %s: ERROR: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
-            retval = 1;
-            goto cleanup;
-        }
-        code = krb5_cc_initialize(kparam.context, kparam.cc, principal);
-        if (code) {
-            error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
-            retval = 1;
-            goto cleanup;
-        }
-        code = krb5_cc_store_cred(kparam.context, kparam.cc, creds);
-        if (code) {
-            error((char *) "%s| %s: ERROR: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
-            retval = 1;
-            goto cleanup;
-        }
-        debug((char *) "%s| %s: DEBUG: Stored credentials\n", LogTime(), PROGRAM);
-    } else {
+    if (!principal_name) {
         debug((char *) "%s| %s: DEBUG: Got no principal name\n", LogTime(), PROGRAM);
         retval = 1;
     }
@@ -894,7 +894,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         }
 #else
         kc = 1;
-        debug((char *) "%s| %s: DEBUG: Kerberos is not supported. Use username/passwaord with ldap url instead\n", LogTime(), PROGRAM);
+        debug((char *) "%s| %s: DEBUG: Kerberos is not supported. Use username/password with ldap url instead\n", LogTime(), PROGRAM);
 #endif
     }
 
@@ -57,7 +57,13 @@ check_k5_err(krb5_context context, const char *function, krb5_error_code code)
         errmsg = krb5_get_error_message(context, code);
         debug((char *) "%s| %s: ERROR: %s failed: %s\n", LogTime(), PROGRAM, function, errmsg);
         fprintf(stderr, "%s| %s: ERROR: %s: %s\n", LogTime(), PROGRAM, function, errmsg);
+#if HAVE_KRB5_FREE_ERROR_MESSAGE
         krb5_free_error_message(context, errmsg);
+#elif HAVE_KRB5_FREE_ERROR_STRING
+        krb5_free_error_string(context, (char *)errmsg);
+#else
+	xfree(errmsg);
+#endif
     }
     return code;
 }
@@ -99,9 +99,13 @@ =head1 COPYRIGHT
 
         print(STDERR logPrefix()."GOT ". "Code=".$code." $bodylen \n") if ($debug); #.$body;
         my $hostname;
-        parseRequest($body, \$hostname, \%errors, \%certs);
+        my $sslVersion = "-";
+        my $sslCipher = "-";
+        parseRequest($body, \$hostname, \$sslVersion, \$sslCipher, \%errors, \%certs);
         print(STDERR logPrefix()."Parse result: \n") if ($debug);
         print(STDERR logPrefix()."\tFOUND host:".$hostname."\n") if ($debug);
+        print(STDERR logPrefix()."\tFOUND ssl version:".$sslVersion."\n") if ($debug);
+        print(STDERR logPrefix()."\tFOUND ssl cipher:".$sslCipher."\n") if ($debug);
         print(STDERR logPrefix()."\tFOUND ERRORS:") if ($debug);
         foreach my $err (keys %errors) {
             print(STDERR logPrefix().$errors{$err}{"name"}."/".$errors{$err}{"cert"}." ,")  if ($debug);
@@ -173,6 +177,8 @@ sub parseRequest
 {
     my($request)=shift;
     my $hostname = shift;
+    my $sslVersion = shift;
+    my $sslCipher = shift;
     my $errors = shift;
     my $certs = shift;
     while ($request !~ /^\s*$/) {
@@ -183,6 +189,12 @@ sub parseRequest
             $$hostname = $host;
             $request =~ s/^host=.*$//m;
         }
+        if ($request =~ s/^proto_version=(.*?)$//m) {
+            $$sslVersion = $1;
+        }
+        if ($request =~ s/^cipher=(.*?)$//m) {
+            $$sslCipher = $1;
+        }
         if ($request =~ /^cert_(\d+)=/) {
             my $certId = "cert_".$1;
             my($vallen) = index($request, "-----END CERTIFICATE-----") + length("-----END CERTIFICATE-----");
@@ -147,8 +147,10 @@ class AccessLogEntry: public RefCountable
 #if USE_OPENSSL
                 ssluser(NULL),
 #endif
-                port(NULL) {
+                port(NULL)
+        {
             caddr.setNoAddr();
+            memset(&start_time, 0, sizeof(start_time));
         }
 
         Ip::Address caddr;
@@ -78,10 +78,9 @@ BodyProducerDialer::canDial(AsyncCall &call)
         return false;
 
     const BodyProducer::Pointer &producer = job;
-    BodyPipe::Pointer pipe = arg1;
-    if (!pipe->stillProducing(producer)) {
-        debugs(call.debugSection, call.debugLevel, HERE << producer <<
-               " no longer producing for " << pipe->status());
+    BodyPipe::Pointer aPipe = arg1;
+    if (!aPipe->stillProducing(producer)) {
+        debugs(call.debugSection, call.debugLevel, producer << " no longer producing for " << aPipe->status());
         return call.cancel("no longer producing");
     }
 
@@ -95,10 +94,9 @@ BodyConsumerDialer::canDial(AsyncCall &call)
         return false;
 
     const BodyConsumer::Pointer &consumer = job;
-    BodyPipe::Pointer pipe = arg1;
-    if (!pipe->stillConsuming(consumer)) {
-        debugs(call.debugSection, call.debugLevel, HERE << consumer <<
-               " no longer consuming from " << pipe->status());
+    BodyPipe::Pointer aPipe = arg1;
+    if (!aPipe->stillConsuming(consumer)) {
+        debugs(call.debugSection, call.debugLevel, consumer << " no longer consuming from " << aPipe->status());
         return call.cancel("no longer consuming");
     }
 
@@ -108,24 +106,23 @@ BodyConsumerDialer::canDial(AsyncCall &call)
 /* BodyProducer */
 
 // inform the pipe that we are done and clear the Pointer
-void BodyProducer::stopProducingFor(RefCount<BodyPipe> &pipe, bool atEof)
+void BodyProducer::stopProducingFor(RefCount<BodyPipe> &p, bool atEof)
 {
-    debugs(91,7, HERE << this << " will not produce for " << pipe <<
-           "; atEof: " << atEof);
-    assert(pipe != NULL); // be strict: the caller state may depend on this
-    pipe->clearProducer(atEof);
-    pipe = NULL;
+    debugs(91,7, this << " will not produce for " << p << "; atEof: " << atEof);
+    assert(p != NULL); // be strict: the caller state may depend on this
+    p->clearProducer(atEof);
+    p = NULL;
 }
 
 /* BodyConsumer */
 
 // inform the pipe that we are done and clear the Pointer
-void BodyConsumer::stopConsumingFrom(RefCount<BodyPipe> &pipe)
+void BodyConsumer::stopConsumingFrom(RefCount<BodyPipe> &p)
 {
-    debugs(91,7, HERE << this << " will not consume from " << pipe);
-    assert(pipe != NULL); // be strict: the caller state may depend on this
-    pipe->clearConsumer();
-    pipe = NULL;
+    debugs(91,7, this << " will not consume from " << p);
+    assert(p != NULL); // be strict: the caller state may depend on this
+    p->clearConsumer();
+    p = NULL;
 }
 
 /* BodyPipe */
@@ -479,7 +476,7 @@ const char *BodyPipe::status() const
 
 /* BodyPipeCheckout */
 
-BodyPipeCheckout::BodyPipeCheckout(BodyPipe &aPipe): pipe(aPipe),
+BodyPipeCheckout::BodyPipeCheckout(BodyPipe &aPipe): thePipe(aPipe),
         buf(aPipe.checkOut()), offset(aPipe.consumedSize()),
         checkedOutSize(buf.contentSize()), checkedIn(false)
 {
@@ -492,19 +489,19 @@ BodyPipeCheckout::~BodyPipeCheckout()
         // TODO: consider implementing the long-term solution discussed at
         // http://www.mail-archive.com/squid-dev@squid-cache.org/msg07910.html
         debugs(91,2, HERE << "Warning: cannot undo BodyPipeCheckout");
-        pipe.checkIn(*this);
+        thePipe.checkIn(*this);
     }
 }
 
 void
 BodyPipeCheckout::checkIn()
 {
     assert(!checkedIn);
-    pipe.checkIn(*this);
+    thePipe.checkIn(*this);
     checkedIn = true;
 }
 
-BodyPipeCheckout::BodyPipeCheckout(const BodyPipeCheckout &c): pipe(c.pipe),
+BodyPipeCheckout::BodyPipeCheckout(const BodyPipeCheckout &c): thePipe(c.thePipe),
         buf(c.buf), offset(c.offset), checkedOutSize(c.checkedOutSize),
         checkedIn(c.checkedIn)
 {
@@ -31,7 +31,7 @@ class BodyProducer: virtual public AsyncJob
     virtual void noteBodyConsumerAborted(RefCount<BodyPipe> bp) = 0;
 
 protected:
-    void stopProducingFor(RefCount<BodyPipe> &pipe, bool atEof);
+    void stopProducingFor(RefCount<BodyPipe> &, bool atEof);
 };
 
 /** Interface for those who want to consume body content from others.
@@ -52,7 +52,7 @@ class BodyConsumer: virtual public AsyncJob
     virtual void noteBodyProducerAborted(RefCount<BodyPipe> bp) = 0;
 
 protected:
-    void stopConsumingFrom(RefCount<BodyPipe> &pipe);
+    void stopConsumingFrom(RefCount<BodyPipe> &);
 };
 
 /** Makes raw buffer checkin/checkout interface efficient and exception-safe.
@@ -64,13 +64,13 @@ class BodyPipeCheckout
     friend class BodyPipe;
 
 public:
-    BodyPipeCheckout(BodyPipe &pipe); // checks out
+    BodyPipeCheckout(BodyPipe &); // checks out
     ~BodyPipeCheckout(); // aborts checkout unless checkedIn
 
     void checkIn();
 
 public:
-    BodyPipe &pipe;
+    BodyPipe &thePipe;
     MemBuf &buf;
     const uint64_t offset; // of current content, relative to the body start
 
@@ -11,6 +11,7 @@
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "helper/forward.h"
 #include "ipcache.h"
 
 #if USE_ADAPTATION
@@ -22,8 +23,6 @@ class ClientHttpRequest;
 class DnsLookupDetails;
 class ErrorState;
 
-class HelperReply;
-
 class ClientRequestContext : public RefCountable
 {
 
@@ -39,9 +38,9 @@ class ClientRequestContext : public RefCountable
     void clientAccessCheck2();
     void clientAccessCheckDone(const allow_t &answer);
     void clientRedirectStart();
-    void clientRedirectDone(const HelperReply &reply);
+    void clientRedirectDone(const Helper::Reply &reply);
     void clientStoreIdStart();
-    void clientStoreIdDone(const HelperReply &reply);
+    void clientStoreIdDone(const Helper::Reply &reply);
     void checkNoCache();
     void checkNoCacheDone(const allow_t &answer);
 #if USE_ADAPTATION
@@ -71,7 +71,7 @@ static OBJH fwdStats;
 #define MAX_FWD_STATS_IDX 9
 static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][Http::scInvalidHeader + 1];
 
-static PconnPool *fwdPconnPool = new PconnPool("server-side", NULL);
+static PconnPool *fwdPconnPool = new PconnPool("server-peers", NULL);
 CBDATA_CLASS_INIT(FwdState);
 
 #if USE_OPENSSL
@@ -447,7 +447,7 @@ FwdState::unregister(Comm::ConnectionPointer &conn)
     serverConn = NULL;
 }
 
-// Legacy method to be removed in favor of the above as soon as possible
+// \deprecated use unregister(Comm::ConnectionPointer &conn) instead
 void
 FwdState::unregister(int fd)
 {
@@ -457,7 +457,7 @@ FwdState::unregister(int fd)
 }
 
 /**
- * server-side modules call fwdComplete() when they are done
+ * FooClient modules call fwdComplete() when they are done
  * downloading an object.  Then, we either 1) re-forward the
  * request somewhere else if needed, or 2) call storeComplete()
  * to finish it off
@@ -532,7 +532,7 @@ fwdConnectDoneWrapper(const Comm::ConnectionPointer &conn, Comm::Flag status, in
  *
  * Return TRUE if the request SHOULD be retried.  This method is
  * called when the HTTP connection fails, or when the connection
- * is closed before server-side read the end of HTTP headers.
+ * is closed before reading the end of HTTP headers from the server.
  */
 bool
 FwdState::checkRetry()
@@ -1017,7 +1017,7 @@ FwdState::dispatch()
  *
  * returns TRUE if the transaction SHOULD be re-forwarded to the
  * next choice in the serverDestinations list.  This method is called when
- * server-side communication completes normally, or experiences
+ * peer communication completes normally, or experiences
  * some error after receiving the end of HTTP headers.
  */
 int
@@ -55,7 +55,7 @@ class HierarchyLogEntry
     Http::StatusCode peer_reply_status; ///< last HTTP status code received
     timeval peer_http_request_sent; ///< last peer finished writing req
     int64_t peer_response_time; ///< last peer response delay
-    Comm::ConnectionPointer tcpServer; ///< TCP/IP level details of the last server-side connection
+    Comm::ConnectionPointer tcpServer; ///< TCP/IP level details of the last peer/server connection
     int64_t bodyBytesRead;  ///< number of body bytes received from the next hop or -1
 
 private:
@@ -47,8 +47,8 @@ LOADABLE_MODULES_SOURCES = \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS	= base anyp ftp parser comm eui acl format clients servers fs repl
-DIST_SUBDIRS = base anyp ftp parser comm eui acl format clients servers fs repl
+SUBDIRS	= base anyp helper ftp parser comm eui acl format clients servers fs repl
+DIST_SUBDIRS = base anyp helper ftp parser comm eui acl format clients servers fs repl
 
 if ENABLE_AUTH
 SUBDIRS += auth
@@ -373,10 +373,6 @@ squid_SOURCES = \
 	gopher.cc \
 	helper.cc \
 	helper.h \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	hier_code.h \
 	HierarchyLogEntry.h \
 	$(HTCPSOURCE) \
@@ -534,8 +530,6 @@ squid_SOURCES = \
 	StoreStats.h \
 	StoreSwapLogData.cc \
 	StoreSwapLogData.h \
-	Server.cc \
-	Server.h \
 	swap_log_op.h \
 	SwapDir.cc \
 	SwapDir.h \
@@ -621,6 +615,7 @@ squid_LDADD = \
 	clients/libclients.la \
 	servers/libservers.la \
 	ftp/libftp.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	base/libbase.la \
@@ -744,7 +739,7 @@ ufsdump_SOURCES = \
 	ufsdump.cc \
 	dlink.h \
 	dlink.cc \
-	HelperChildConfig.h \
+	helper/ChildConfig.h \
 	tests/stub_HelperChildConfig.cc \
 	http/RequestMethod.cc \
 	RemovalPolicy.cc \
@@ -1245,8 +1240,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
@@ -1347,6 +1340,8 @@ tests_testACLMaxUserIP_SOURCES= \
 nodist_tests_testACLMaxUserIP_SOURCES= \
 	$(TESTSOURCES)
 tests_testACLMaxUserIP_LDADD= \
+	libsquid.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	$(AUTH_ACL_LIBS) \
@@ -1357,7 +1352,6 @@ tests_testACLMaxUserIP_LDADD= \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	base/libbase.la \
-	libsquid.la \
 	ip/libip.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
@@ -1471,10 +1465,6 @@ tests_testCacheManager_SOURCES = \
 	gopher.cc \
 	hier_code.h \
 	helper.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	$(HTCPSOURCE) \
 	HttpStateFlags.h \
 	http.cc \
@@ -1538,7 +1528,6 @@ tests_testCacheManager_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
-	Server.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
@@ -1602,17 +1591,18 @@ nodist_tests_testCacheManager_SOURCES = \
 	$(DISKIO_GEN_SOURCE)
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
+	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	ftp/libftp.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
-	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
@@ -1791,6 +1781,7 @@ nodist_tests_testDiskIO_SOURCES= \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
+	libsquid.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	SquidConfig.o \
@@ -1799,7 +1790,6 @@ tests_testDiskIO_LDADD = \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	libsquid.la \
 	comm/libcomm.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -1891,10 +1881,6 @@ tests_testEvent_SOURCES = \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
@@ -1963,7 +1949,6 @@ tests_testEvent_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
-	Server.cc \
 	StrList.h \
 	StrList.cc \
 	$(SBUF_SOURCE) \
@@ -2035,17 +2020,18 @@ nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEvent_LDADD = \
+	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	ftp/libftp.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
-	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
@@ -2140,10 +2126,6 @@ tests_testEventLoop_SOURCES = \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
@@ -2212,7 +2194,6 @@ tests_testEventLoop_SOURCES = \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
-	Server.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
@@ -2284,17 +2265,18 @@ nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEventLoop_LDADD = \
+	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	ftp/libftp.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
-	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
@@ -2385,10 +2367,6 @@ tests_test_http_range_SOURCES = \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
@@ -2457,7 +2435,6 @@ tests_test_http_range_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
-	Server.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
@@ -2526,16 +2503,18 @@ nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_test_http_range_LDADD = \
+	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	ftp/libftp.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
-	libsquid.la \
+	parser/libsquid-parser.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
@@ -2691,10 +2670,6 @@ tests_testHttpRequest_SOURCES = \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
@@ -2759,7 +2734,6 @@ tests_testHttpRequest_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
-	Server.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
@@ -2819,15 +2793,17 @@ tests_testHttpRequest_SOURCES = \
 nodist_tests_testHttpRequest_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testHttpRequest_LDADD = \
+	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
+	helper/libhelper.la \
 	ftp/libftp.la \
 	http/libsquid-http.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
-	libsquid.la \
+	parser/libsquid-parser.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(SSL_LIBS) \
@@ -3007,14 +2983,14 @@ nodist_tests_testStore_SOURCES= \
 	swap_log_op.cc
 
 tests_testStore_LDADD= \
+	libsquid.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
-	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
@@ -3513,10 +3489,6 @@ tests_testURL_SOURCES = \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
-	HelperChildConfig.h \
-	HelperChildConfig.cc \
-	HelperReply.cc \
-	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
@@ -3585,7 +3557,6 @@ tests_testURL_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
-	Server.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
@@ -3659,8 +3630,10 @@ tests_testURL_SOURCES = \
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
+	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
+	helper/libhelper.la \
 	http/libsquid-http.la \
 	ftp/libftp.la \
 	parser/libsquid-parser.la \
@@ -3671,7 +3644,6 @@ tests_testURL_LDADD = \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
-	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(SSL_LIBS) \
@@ -81,7 +81,7 @@ class Notes
     typedef NotesList::const_iterator const_iterator; ///< iterates over the notes list
 
     Notes(const char *aDescr, const char **metasBlacklist, bool allowFormatted = false): descr(aDescr), blacklisted(metasBlacklist), formattedValues(allowFormatted) {}
-    Notes(): descr(NULL), blacklisted(NULL) {}
+    Notes(): descr(NULL), blacklisted(NULL), formattedValues(false) {}
     ~Notes() { notes.clear(); }
     /**
      * Parse a notes line and returns a pointer to the
@@ -210,7 +210,7 @@ SBuf::append(const char * S, size_type Ssize)
 {
     if (S == NULL)
         return *this;
-    if (Ssize == npos)
+    if (Ssize == SBuf::npos)
         Ssize = strlen(S);
     debugs(24, 7, "from c-string to id " << id);
     // coverity[access_dbuff_in_call]
@@ -13,7 +13,7 @@
 #include "base/RefCount.h"
 #include "ClientDelayConfig.h"
 #include "DelayConfig.h"
-#include "HelperChildConfig.h"
+#include "helper/ChildConfig.h"
 #include "HttpHeaderTools.h"
 #include "icmp/IcmpConfig.h"
 #include "ip/Address.h"
@@ -184,8 +184,8 @@ class SquidConfig
 
     } Program;
 
-    HelperChildConfig redirectChildren;
-    HelperChildConfig storeIdChildren;
+    Helper::ChildConfig redirectChildren;
+    Helper::ChildConfig storeIdChildren;
     time_t authenticateGCInterval;
     time_t authenticateTTL;
     time_t authenticateIpTTL;
@@ -61,9 +61,16 @@ StoreMetaUnpacker::getBufferLength()
     memcpy(hdr_len, &buf[1], sizeof(int));
 }
 
-StoreMetaUnpacker::StoreMetaUnpacker (char const *aBuffer, ssize_t aLen, int *anInt) : buf (aBuffer), buflen(aLen), hdr_len(anInt), position(1 + sizeof(int))
+StoreMetaUnpacker::StoreMetaUnpacker(char const *aBuffer, ssize_t aLen, int *anInt) :
+        buf(aBuffer),
+        buflen(aLen),
+        hdr_len(anInt),
+        position(1 + sizeof(int)),
+        type('\0'),
+        length(0),
+        tail(NULL)
 {
-    assert (aBuffer != NULL);
+    assert(aBuffer != NULL);
 }
 
 void
@@ -13,9 +13,11 @@
 #include "globals.h"
 #include "protos.h"
 #include "SquidConfig.h"
+#include "tools.h"
+#include "WinSvc.h"
 
 #if _SQUID_WINDOWS_
-#ifndef _MSWSOCK_
+#if !defined(_MSWSOCK_)
 #include <mswsock.h>
 #endif
 #include <process.h>
@@ -654,7 +656,7 @@ WIN32_RemoveService()
     const char *service =  service_name.c_str();
     strcat(REGKEY, service);
 
-    keys[4] = service;
+    keys[4] = const_cast<char*>(service);
 
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
@@ -704,10 +706,10 @@ WIN32_SetServiceCommandLine()
     if (service_name.isEmpty())
         service_name = SBuf(APP_SHORTNAME);
 
-    const char *service = servie_name.c_str();
+    const char *service = service_name.c_str();
     strcat(REGKEY, service);
 
-    keys[4] = service;
+    keys[4] = const_cast<char*>(service);
 
     /* Now store the Service Command Line in the registry */
     WIN32_StoreKey(COMMANDLINE, REG_SZ, (unsigned char *) WIN32_Command_Line, strlen(WIN32_Command_Line) + 1);
@@ -728,7 +730,7 @@ WIN32_InstallService()
     const char *service = service_name.c_str();
     strcat(REGKEY, service);
 
-    keys[4] = service;
+    keys[4] = const_cast<char*>(service);
 
     if ((lenpath = GetModuleFileName(NULL, ServicePath, 512)) == 0) {
         fprintf(stderr, "Can't get executable path\n");
@@ -889,7 +891,7 @@ WIN32_sendSignal(int WIN32_signal)
     CloseServiceHandle(schSCManager);
 }
 
-int main(int argc, char **argv)
+int WIN32_StartService(int argc, char **argv)
 {
     SERVICE_TABLE_ENTRY DispatchTable[] = {
         {NULL, SquidWinSvcMain},
@@ -898,35 +900,26 @@ int main(int argc, char **argv)
     char *c;
     char stderr_path[256];
 
-    SetErrorMode(SEM_NOGPFAULTERRORBOX);
-    if ((argc == 2) && strstr(argv[1], _WIN_SQUID_SERVICE_OPTION)) {
-        strcpy(stderr_path, argv[0]);
-        strcat(stderr_path,".log");
-        freopen(stderr_path, "w", stderr);
-        setmode(fileno(stderr), O_TEXT);
-        WIN32_run_mode = _WIN_SQUID_RUN_MODE_SERVICE;
-
-        if (!(c=strchr(argv[1],':'))) {
-            fprintf(stderr, "Bad Service Parameter: %s\n", argv[1]);
-            return 1;
-        }
+    strcpy(stderr_path, argv[0]);
+    strcat(stderr_path,".log");
+    freopen(stderr_path, "w", stderr);
+    setmode(fileno(stderr), O_TEXT);
+    WIN32_run_mode = _WIN_SQUID_RUN_MODE_SERVICE;
 
-        service_name = SBuf(c+1);
-        const char *service = service_name.c_str();
-        DispatchTable[0].lpServiceName=service;
-        strcat(REGKEY, service);
-        keys[4] = service;
+    if (!(c=strchr(argv[1],':'))) {
+        fprintf(stderr, "Bad Service Parameter: %s\n", argv[1]);
+        return 1;
+    }
 
-        if (!StartServiceCtrlDispatcher(DispatchTable)) {
-            fprintf(stderr, "StartServiceCtrlDispatcher error = %ld\n",
-                    GetLastError());
-            return 1;
-        }
-    } else {
-        WIN32_run_mode = _WIN_SQUID_RUN_MODE_INTERACTIVE;
-        opt_no_daemon = 1;
+    service_name = SBuf(c+1);
+    const char *service = service_name.c_str();
+    DispatchTable[0].lpServiceName = const_cast<char*>(service);
+    strcat(REGKEY, service);
+    keys[4] = const_cast<char*>(service);
 
-        return SquidMain(argc, argv);
+    if (!StartServiceCtrlDispatcher(DispatchTable)) {
+        fprintf(stderr, "StartServiceCtrlDispatcher error = %ld\n", GetLastError());
+        return 1;
     }
 
     return 0;
@@ -10,12 +10,12 @@
 #define WINSVC_H_
 
 #if _SQUID_WINDOWS_
+int WIN32_StartService(int, char **);
 int WIN32_Subsystem_Init(int *, char ***);
 void WIN32_sendSignal(int);
 void WIN32_SetServiceCommandLine(void);
 void WIN32_InstallService(void);
 void WIN32_RemoveService(void);
-int SquidMain(int, char **);
 #else /* _SQUID_WINDOWS_ */
 inline int WIN32_Subsystem_Init(int *foo, char ***bar) {return 0; } /* NOP */
 inline void WIN32_sendSignal(int foo) { return; } /* NOP */
@@ -80,7 +80,9 @@ class ACL
     static ACL *FindByName(const char *name);
 
     ACL();
-    explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs) { memset(name, '\0', sizeof(name)); }
+    explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs), registered(false) {
+        *name = 0;
+    }
     virtual ~ACL();
 
     /// sets user-specified ACL name and squid.conf context
@@ -19,6 +19,7 @@
 Adaptation::Icap::Config Adaptation::Icap::TheConfig;
 
 Adaptation::Icap::Config::Config() :
+        default_options_ttl(0),
         preview_enable(0), preview_size(0), allow206_enable(0),
         connect_timeout_raw(0), io_timeout_raw(0), reuse_connections(0),
         client_username_header(NULL), client_username_encode(0), repeat(NULL),
@@ -13,9 +13,12 @@
 #include "SquidTime.h"
 
 Adaptation::Icap::History::History():
-        logType(LOG_TAG_NONE), req_sz(0),
-        pastTime(0), concurrencyLevel(0)
+        logType(LOG_TAG_NONE),
+        req_sz(0),
+        pastTime(0),
+        concurrencyLevel(0)
 {
+    memset(&currentStart, 0, sizeof(currentStart));
 }
 
 void Adaptation::Icap::History::start(const char *context)
@@ -15,10 +15,14 @@
 #include "StrList.h"
 #include "wordlist.h"
 
-Adaptation::Icap::Options::Options(): error("unconfigured"),
-        max_connections(-1), allow204(false),
+Adaptation::Icap::Options::Options() :
+        error("unconfigured"),
+        max_connections(-1),
+        allow204(false),
         allow206(false),
-        preview(-1), theTTL(-1)
+        preview(-1),
+        theTTL(-1),
+        theTimestamp(0)
 {
     theTransfers.preview.name = "Transfer-Preview";
     theTransfers.preview.kind = xferPreview;
@@ -32,8 +32,6 @@
 #include "SquidConfig.h"
 #include "SquidTime.h"
 
-//CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, Xaction);
-
 Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::ServiceRep::Pointer &aService):
         AsyncJob(aTypeName),
         Adaptation::Initiate(aTypeName),
@@ -42,13 +40,18 @@ Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::Serv
         attempts(0),
         connection(NULL),
         theService(aService),
-        commBuf(NULL), commBufSize(0),
+        commBuf(NULL),
+        commBufSize(0),
         commEof(false),
         reuseConnection(true),
         isRetriable(true),
         isRepeatable(true),
         ignoreLastWrite(false),
-        connector(NULL), reader(NULL), writer(NULL), closer(NULL),
+        stopReason(NULL),
+        connector(NULL),
+        reader(NULL),
+        writer(NULL),
+        closer(NULL),
         alep(new AccessLogEntry),
         al(*alep),
         cs(NULL)
@@ -58,6 +61,8 @@ Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::Serv
     icapRequest = new HttpRequest;
     HTTPMSGLOCK(icapRequest);
     icap_tr_start = current_time;
+    memset(&icap_tio_start, 0, sizeof(icap_tio_start));
+    memset(&icap_tio_finish, 0, sizeof(icap_tio_finish));
 }
 
 Adaptation::Icap::Xaction::~Xaction()
@@ -67,8 +67,8 @@ completed or replaced.
 
 Here is a typical adaptation code sequence:
 
-- Master caller (client- or server-side): Checks ACL and starts
-  Adaptation::Iterator for the ACL-selected ServiceGroup.
+- Master caller: Checks ACL and starts Adaptation::Iterator for the
+  ACL-selected ServiceGroup.
 
 - Adaptation::Iterator: Creates ServicePlan and executes it, launching one
   service adaptation per step. Abandons the original plan and builds a dynamic
@@ -21,7 +21,7 @@ namespace AnyP
 class TrafficMode
 {
 public:
-    TrafficMode() : accelSurrogate(false), natIntercept(false), tproxyIntercept(false), tunnelSslBumping(false) {}
+    TrafficMode() : accelSurrogate(false), proxySurrogate(false), natIntercept(false), tproxyIntercept(false), tunnelSslBumping(false) {}
     TrafficMode(const TrafficMode &rhs) { operator =(rhs); }
     TrafficMode &operator =(const TrafficMode &rhs) { memcpy(this, &rhs, sizeof(TrafficMode)); return *this; }
 
@@ -86,7 +86,7 @@ Auth::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 
         char *token = ConfigParser::NextQuotedOrToEol();
 
-        while (*token && xisspace(*token))
+        while (token && *token && xisspace(*token))
             ++token;
 
         if (!token || !*token) {
@@ -13,7 +13,7 @@
 
 #include "AccessLogEntry.h"
 #include "auth/UserRequest.h"
-#include "HelperChildConfig.h"
+#include "helper/ChildConfig.h"
 
 class StoreEntry;
 class HttpReply;
@@ -124,7 +124,7 @@ class Config
     virtual const char * type() const = 0;
 
 public:
-    HelperChildConfig authenticateChildren;
+    Helper::ChildConfig authenticateChildren;
     wordlist *authenticateProgram; ///< Helper program to run, includes all parameters
     String keyExtrasLine;  ///< The format of the request to the auth helper
     Format::Format *keyExtras; ///< The compiled request format
@@ -13,7 +13,6 @@
 
 #include "auth/UserRequest.h"
 #include "cbdata.h"
-#include "helper.h"
 
 namespace Auth
 {
@@ -21,9 +21,6 @@
 #include "SquidTime.h"
 #include "Store.h"
 
-// This should be converted into a pooled type. Does not need to be cbdata
-CBDATA_TYPE(AuthUserIP);
-
 time_t Auth::User::last_discard = 0;
 
 Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
@@ -84,7 +81,7 @@ Auth::User::absorb(Auth::User::Pointer from)
         if (new_ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the source list */
             dlinkDelete(&new_ipdata->node, &(from->ip_list));
-            cbdataFree(new_ipdata);
+            delete new_ipdata;
             /* catch incipient underflow */
             -- from->ipcount;
         } else {
@@ -103,7 +100,7 @@ Auth::User::absorb(Auth::User::Pointer from)
                 } else if (ipdata->ip_expiretime <= squid_curtime) {
                     /* This IP has expired - cleanup the destination list */
                     dlinkDelete(&ipdata->node, &ip_list);
-                    cbdataFree(ipdata);
+                    delete ipdata;
                     /* catch incipient underflow */
                     assert(ipcount);
                     -- ipcount;
@@ -229,7 +226,7 @@ Auth::User::clearIp()
         tempnode = (AuthUserIP *) ipdata->node.next;
         /* walk the ip list */
         dlinkDelete(&ipdata->node, &ip_list);
-        cbdataFree(ipdata);
+        delete ipdata;
         /* catch incipient underflow */
         assert(ipcount);
         -- ipcount;
@@ -251,7 +248,7 @@ Auth::User::removeIp(Ip::Address ipaddr)
         if (ipdata->ipaddr == ipaddr) {
             /* remove the node */
             dlinkDelete(&ipdata->node, &ip_list);
-            cbdataFree(ipdata);
+            delete ipdata;
             /* catch incipient underflow */
             assert(ipcount);
             -- ipcount;
@@ -269,8 +266,6 @@ Auth::User::addIp(Ip::Address ipaddr)
     AuthUserIP *ipdata = (AuthUserIP *) ip_list.head;
     int found = 0;
 
-    CBDATA_INIT_TYPE(AuthUserIP);
-
     /*
      * we walk the entire list to prevent the first item in the list
      * preventing old entries being flushed and locking a user out after
@@ -288,7 +283,7 @@ Auth::User::addIp(Ip::Address ipaddr)
         } else if (ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&ipdata->node, &ip_list);
-            cbdataFree(ipdata);
+            delete ipdata;
             /* catch incipient underflow */
             assert(ipcount);
             -- ipcount;
@@ -301,11 +296,7 @@ Auth::User::addIp(Ip::Address ipaddr)
         return;
 
     /* This ip is not in the seen list */
-    ipdata = cbdataAlloc(AuthUserIP);
-
-    ipdata->ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
-
-    ipdata->ipaddr = ipaddr;
+    ipdata = new AuthUserIP(ipaddr, squid_curtime + ::Config.authenticateIpTTL);
 
     dlinkAddTail(ipdata, &ipdata->node, &ip_list);
 
@@ -16,7 +16,7 @@
 #include "auth/Scheme.h"
 #include "auth/User.h"
 #include "dlink.h"
-#include "helper.h"
+#include "helper/forward.h"
 #include "HttpHeader.h"
 #include "ip/Address.h"
 
@@ -33,12 +33,12 @@ class HttpRequest;
 /**
  * Node used to link an IP address to some user credentials
  * for the max_user_ip ACL feature.
- *
- * \ingroup AuthAPI
  */
 class AuthUserIP
 {
 public:
+    AuthUserIP(const Ip::Address &ip, time_t t) : ipaddr(ip), ip_expiretime(t) {}
+
     dlink_node node;
 
     /// IP address this user authenticated from
@@ -49,8 +49,12 @@ class AuthUserIP
      * (user,IP) pair plus authenticate_ip_ttl seconds
      */
     time_t ip_expiretime;
+
+    MEMPROXY_CLASS(AuthUserIP);
 };
 
+MEMPROXY_CLASS_INLINE(AuthUserIP);
+
 // TODO: make auth schedule AsyncCalls?
 typedef void AUTHCB(void*);
 
@@ -13,14 +13,15 @@
  * See acl.c for access control and client_side.c for auditing */
 
 #include "squid.h"
-#include "auth/basic/auth_basic.h"
+#include "auth/basic/Config.h"
 #include "auth/basic/Scheme.h"
 #include "auth/basic/User.h"
 #include "auth/basic/UserRequest.h"
 #include "auth/Gadgets.h"
 #include "auth/State.h"
 #include "cache_cf.h"
 #include "charset.h"
+#include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "mgr/Registration.h"
@@ -6,20 +6,13 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-/*
- * auth_basic.h
- * Internal declarations for the basic auth module
- */
-
 #ifndef __AUTH_BASIC_H__
 #define __AUTH_BASIC_H__
 
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
-#include "helper.h"
-
-#define DefaultAuthenticateChildrenMax  32	/* 32 processes */
+#include "helper/forward.h"
 
 namespace Auth
 {
@@ -11,10 +11,10 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libbasic.la
 
 libbasic_la_SOURCES = \
+	Config.cc \
+	Config.h \
 	Scheme.cc \
 	Scheme.h \
-	auth_basic.cc \
-	auth_basic.h \
 	User.cc \
 	User.h \
 	UserRequest.cc \
@@ -7,13 +7,11 @@
  */
 
 #include "squid.h"
+#include "auth/basic/Config.h"
 #include "auth/basic/Scheme.h"
 #include "Debug.h"
 #include "helper.h"
 
-/* for Auth::Config */
-#include "auth/basic/auth_basic.h"
-
 Auth::Scheme::Pointer Auth::Basic::Scheme::_instance = NULL;
 
 Auth::Scheme::Pointer
@@ -9,7 +9,6 @@
 #ifndef SQUID_AUTH_BASIC_SCHEME_H
 #define SQUID_AUTH_BASIC_SCHEME_H
 
-#include "auth/basic/auth_basic.h"
 #include "auth/Scheme.h"
 
 namespace Auth
@@ -7,7 +7,7 @@
  */
 
 #include "squid.h"
-#include "auth/basic/auth_basic.h"
+#include "auth/basic/Config.h"
 #include "auth/basic/User.h"
 #include "Debug.h"
 #include "SquidConfig.h"
@@ -7,15 +7,16 @@
  */
 
 #include "squid.h"
-#include "auth/basic/auth_basic.h"
+#include "auth/basic/Config.h"
 #include "auth/basic/User.h"
 #include "auth/basic/UserRequest.h"
 #include "auth/QueueNode.h"
 #include "auth/State.h"
 #include "charset.h"
 #include "Debug.h"
 #include "format/Format.h"
-#include "HelperReply.h"
+#include "helper.h"
+#include "helper/Reply.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -159,7 +160,7 @@ Auth::Basic::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry
 }
 
 void
-Auth::Basic::UserRequest::HandleReply(void *data, const HelperReply &reply)
+Auth::Basic::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
     void *cbdata;
@@ -178,7 +179,7 @@ Auth::Basic::UserRequest::HandleReply(void *data, const HelperReply &reply)
 
     assert(basic_auth != NULL);
 
-    if (reply.result == HelperReply::Okay)
+    if (reply.result == Helper::Okay)
         basic_auth->credentials(Auth::Ok);
     else {
         basic_auth->credentials(Auth::Failed);
@@ -13,7 +13,7 @@
  * See acl.c for access control and client_side.c for auditing */
 
 #include "squid.h"
-#include "auth/digest/auth_digest.h"
+#include "auth/digest/Config.h"
 #include "auth/digest/Scheme.h"
 #include "auth/digest/User.h"
 #include "auth/digest/UserRequest.h"
@@ -22,6 +22,7 @@
 #include "base64.h"
 #include "cache_cf.h"
 #include "event.h"
+#include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -6,18 +6,13 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-/*
- * auth_digest.h
- * Internal declarations for the digest auth module
- */
-
 #ifndef __AUTH_DIGEST_H__
 #define __AUTH_DIGEST_H__
 
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
-#include "helper.h"
+#include "helper/forward.h"
 #include "rfc2617.h"
 
 namespace Auth
@@ -11,10 +11,10 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libdigest.la
 
 libdigest_la_SOURCES = \
+	Config.cc \
+	Config.h \
 	Scheme.cc \
 	Scheme.h \
-	auth_digest.cc \
-	auth_digest.h \
 	User.cc \
 	User.h \
 	UserRequest.cc \
@@ -7,6 +7,7 @@
  */
 
 #include "squid.h"
+#include "auth/digest/Config.h"
 #include "auth/digest/Scheme.h"
 #include "Debug.h"
 #include "globals.h"
@@ -9,7 +9,6 @@
 #ifndef SQUID_AUTH_DIGEST_SCHEME_H
 #define SQUID_AUTH_DIGEST_SCHEME_H
 
-#include "auth/digest/auth_digest.h"
 #include "auth/Scheme.h"
 
 namespace Auth
@@ -7,7 +7,7 @@
  */
 
 #include "squid.h"
-#include "auth/digest/auth_digest.h"
+#include "auth/digest/Config.h"
 #include "auth/digest/User.h"
 #include "Debug.h"
 #include "dlink.h"
@@ -8,12 +8,14 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "auth/digest/auth_digest.h"
+#include "auth/digest/Config.h"
 #include "auth/digest/User.h"
 #include "auth/digest/UserRequest.h"
 #include "auth/State.h"
 #include "charset.h"
 #include "format/Format.h"
+#include "helper.h"
+#include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -235,6 +237,9 @@ Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int acce
     if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->authenticateProgram) && authDigestNonceLastRequest(nonce)) {
         flags.authinfo_sent = true;
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(user().getRaw());
+        if (!digest_user)
+            return;
+
         digest_nonce_h *nextnonce = digest_user->currentNonce();
         if (!nextnonce || authDigestNonceLastRequest(nonce)) {
             nextnonce = authenticateDigestNonceNew();
@@ -313,7 +318,7 @@ Auth::Digest::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntr
 }
 
 void
-Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
+Auth::Digest::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
 {
     Auth::StateData *replyData = static_cast<Auth::StateData *>(data);
     debugs(29, 9, HERE << "reply=" << reply);
@@ -327,7 +332,7 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
 
     static bool oldHelperWarningDone = false;
     switch (reply.result) {
-    case HelperReply::Unknown: {
+    case Helper::Unknown: {
         // Squid 3.3 and older the digest helper only returns a HA1 hash (no "OK")
         // the HA1 will be found in content() for these responses.
         if (!oldHelperWarningDone) {
@@ -344,7 +349,7 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     break;
 
-    case HelperReply::Okay: {
+    case Helper::Okay: {
         /* allow this because the digest_request pointer is purely local */
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
         assert(digest_user != NULL);
@@ -359,15 +364,15 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     break;
 
-    case HelperReply::TT:
+    case Helper::TT:
         debugs(29, DBG_IMPORTANT, "ERROR: Digest auth does not support the result code received. Using the wrong helper program? received: " << reply);
         // fall through to next case. Handle this as an ERR response.
 
-    case HelperReply::BrokenHelper:
+    case Helper::BrokenHelper:
         // TODO retry the broken lookup on another helper?
         // fall through to next case for now. Handle this as an ERR response silently.
 
-    case HelperReply::Error: {
+    case Helper::Error: {
         /* allow this because the digest_request pointer is purely local */
         Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest *>(auth_user_request.getRaw());
         assert(digest_request);
@@ -9,7 +9,6 @@
 #ifndef _SQUID_SRC_AUTH_DIGEST_USERREQUEST_H
 #define _SQUID_SRC_AUTH_DIGEST_USERREQUEST_H
 
-#include "auth/digest/auth_digest.h"
 #include "auth/UserRequest.h"
 #include "MemPool.h"
 
@@ -14,13 +14,14 @@
 
 #include "squid.h"
 #include "auth/Gadgets.h"
-#include "auth/negotiate/auth_negotiate.h"
+#include "auth/negotiate/Config.h"
 #include "auth/negotiate/Scheme.h"
 #include "auth/negotiate/User.h"
 #include "auth/negotiate/UserRequest.h"
 #include "auth/State.h"
 #include "cache_cf.h"
 #include "client_side.h"
+#include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -46,12 +47,6 @@ static int authnegotiate_initialised = 0;
 /// \ingroup AuthNegotiateInternal
 static hash_table *proxy_auth_cache = NULL;
 
-/*
- *
- * Private Functions
- *
- */
-
 void
 Auth::Negotiate::Config::rotateHelpers()
 {
@@ -6,26 +6,13 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-/*
- * auth_negotiate.h
- * Internal declarations for the negotiate auth module
- */
-
 #ifndef __AUTH_NEGOTIATE_H__
 #define __AUTH_NEGOTIATE_H__
 
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
-#include "helper.h"
-
-/**
- \defgroup AuthNegotiateAPI Negotiate Authentication API
- \ingroup AuthAPI
- */
-
-/// \ingroup AuthNegotiateAPI
-#define DefaultAuthenticateChildrenMax  32	/* 32 processes */
+#include "helper/forward.h"
 
 namespace Auth
 {
@@ -13,8 +13,8 @@ noinst_LTLIBRARIES = libnegotiate.la
 libnegotiate_la_SOURCES = \
 	Scheme.cc \
 	Scheme.h \
-	auth_negotiate.cc \
-	auth_negotiate.h \
+	Config.cc \
+	Config.h \
 	User.cc \
 	User.h \
 	UserRequest.cc \
@@ -7,6 +7,7 @@
  */
 
 #include "squid.h"
+#include "auth/negotiate/Config.h"
 #include "auth/negotiate/Scheme.h"
 #include "Debug.h"
 #include "helper.h"
@@ -9,7 +9,6 @@
 #ifndef SQUID_AUTH_NEGOTIATE_SCHEME_H
 #define SQUID_AUTH_NEGOTIATE_SCHEME_H
 
-#include "auth/negotiate/auth_negotiate.h"
 #include "auth/Scheme.h"
 
 namespace Auth
@@ -8,14 +8,15 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "auth/negotiate/auth_negotiate.h"
+#include "auth/negotiate/Config.h"
 #include "auth/negotiate/UserRequest.h"
 #include "auth/State.h"
 #include "auth/User.h"
 #include "client_side.h"
 #include "format/Format.h"
 #include "globals.h"
 #include "helper.h"
+#include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -241,7 +242,7 @@ Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData
 }
 
 void
-Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
+Auth::Negotiate::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
 
@@ -276,7 +277,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         assert(reply.whichServer == lm_request->authserver);
 
     switch (reply.result) {
-    case HelperReply::TT:
+    case Helper::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
         lm_request->request->flags.mustKeepalive = true;
@@ -292,7 +293,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         }
         break;
 
-    case HelperReply::Okay: {
+    case Helper::Okay: {
         const char *userNote = reply.notes.findFirst("user");
         const char *tokenNote = reply.notes.findFirst("token");
         if (userNote == NULL || tokenNote == NULL) {
@@ -339,7 +340,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     break;
 
-    case HelperReply::Error: {
+    case Helper::Error: {
         const char *messageNote = reply.notes.find("message");
         const char *tokenNote = reply.notes.findFirst("token");
 
@@ -357,18 +358,18 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     break;
 
-    case HelperReply::Unknown:
+    case Helper::Unknown:
         debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication Helper '" << reply.whichServer << "' crashed!.");
         /* continue to the next case */
 
-    case HelperReply::BrokenHelper: {
+    case Helper::BrokenHelper: {
         /* TODO kick off a refresh process. This can occur after a YR or after
          * a KK. If after a YR release the helper and resubmit the request via
          * Authenticate Negotiate start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
         const char *errNote = reply.notes.find("message");
-        if (reply.result == HelperReply::Unknown)
+        if (reply.result == Helper::Unknown)
             auth_user_request->denyMessage("Internal Error");
         else if (errNote != NULL)
             auth_user_request->denyMessage(errNote);
@@ -10,12 +10,12 @@
 #define _SQUID_SRC_AUTH_NEGOTIATE_USERREQUEST_H
 
 #include "auth/UserRequest.h"
+#include "helper/forward.h"
 #include "MemPool.h"
 
 class ConnStateData;
 class HttpReply;
 class HttpRequest;
-class helper_stateful_server;
 
 namespace Auth
 {
@@ -14,13 +14,14 @@
 
 #include "squid.h"
 #include "auth/Gadgets.h"
-#include "auth/ntlm/auth_ntlm.h"
+#include "auth/ntlm/Config.h"
 #include "auth/ntlm/Scheme.h"
 #include "auth/ntlm/User.h"
 #include "auth/ntlm/UserRequest.h"
 #include "auth/State.h"
 #include "cache_cf.h"
 #include "client_side.h"
+#include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -37,12 +38,6 @@ static int authntlm_initialised = 0;
 
 static hash_table *proxy_auth_cache = NULL;
 
-/*
- *
- * Private Functions
- *
- */
-
 void
 Auth::Ntlm::Config::rotateHelpers()
 {
@@ -12,9 +12,7 @@
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
-#include "helper.h"
-
-#define DefaultAuthenticateChildrenMax  32	/* 32 processes */
+#include "helper/forward.h"
 
 class HttpRequest;
 class StoreEntry;
@@ -11,10 +11,10 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libntlm.la
 
 libntlm_la_SOURCES = \
+	Config.cc \
+	Config.h \
 	Scheme.cc \
 	Scheme.h \
-	auth_ntlm.cc \
-	auth_ntlm.h \
 	User.cc \
 	User.h \
 	UserRequest.cc \
@@ -7,7 +7,7 @@
  */
 
 #include "squid.h"
-#include "auth/ntlm/auth_ntlm.h"
+#include "auth/ntlm/Config.h"
 #include "auth/ntlm/Scheme.h"
 #include "Debug.h"
 #include "helper.h"
@@ -9,7 +9,6 @@
 #ifndef SQUID_AUTH_NTLM_SCHEME_H
 #define SQUID_AUTH_NTLM_SCHEME_H
 
-#include "auth/ntlm/auth_ntlm.h"
 #include "auth/Scheme.h"
 
 namespace Auth
@@ -8,13 +8,15 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "auth/ntlm/auth_ntlm.h"
+#include "auth/ntlm/Config.h"
 #include "auth/ntlm/UserRequest.h"
 #include "auth/State.h"
 #include "cbdata.h"
 #include "client_side.h"
 #include "format/Format.h"
 #include "globals.h"
+#include "helper.h"
+#include "helper/Reply.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -235,7 +237,7 @@ Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * co
 }
 
 void
-Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
+Auth::Ntlm::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
 
@@ -270,7 +272,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         assert(reply.whichServer == lm_request->authserver);
 
     switch (reply.result) {
-    case HelperReply::TT:
+    case Helper::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
         lm_request->request->flags.mustKeepalive = true;
@@ -286,7 +288,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         }
         break;
 
-    case HelperReply::Okay: {
+    case Helper::Okay: {
         /* we're finished, release the helper */
         const char *userLabel = reply.notes.findFirst("user");
         if (!userLabel) {
@@ -332,7 +334,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     break;
 
-    case HelperReply::Error: {
+    case Helper::Error: {
         /* authentication failure (wrong password, etc.) */
         const char *errNote = reply.notes.find("message");
         if (errNote != NULL)
@@ -346,18 +348,18 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     break;
 
-    case HelperReply::Unknown:
+    case Helper::Unknown:
         debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication Helper '" << reply.whichServer << "' crashed!.");
         /* continue to the next case */
 
-    case HelperReply::BrokenHelper: {
+    case Helper::BrokenHelper: {
         /* TODO kick off a refresh process. This can occur after a YR or after
          * a KK. If after a YR release the helper and resubmit the request via
          * Authenticate NTLM start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
         const char *errNote = reply.notes.find("message");
-        if (reply.result == HelperReply::Unknown)
+        if (reply.result == Helper::Unknown)
             auth_user_request->denyMessage("Internal Error");
         else if (errNote != NULL)
             auth_user_request->denyMessage(errNote);
@@ -9,14 +9,13 @@
 #ifndef _SQUID_SRC_AUTH_NTLM_USERREQUEST_H
 #define _SQUID_SRC_AUTH_NTLM_USERREQUEST_H
 
-#include "auth/ntlm/auth_ntlm.h"
 #include "auth/UserRequest.h"
+#include "helper/forward.h"
 #include "MemPool.h"
 
 class ConnStateData;
 class HttpReply;
 class HttpRequest;
-class helper_stateful_server;
 
 namespace Auth
 {
@@ -4028,7 +4028,7 @@ DOC_START
 		[http::]<pt	Peer response time in milliseconds. The timer starts
 				when the last request byte is sent to the next hop
 				and stops when the last response byte is received.
-		[http::]<tt	Total server-side time in milliseconds. The timer 
+		[http::]<tt	Total time in milliseconds. The timer 
 				starts with the first connect request (or write I/O)
 				sent to the first selected peer. The timer stops
 				with the last I/O with the last peer.
@@ -5978,11 +5978,13 @@ TYPE: time_t
 LOC: Config.Timeout.read
 DEFAULT: 15 minutes
 DOC_START
-	The read_timeout is applied on server-side connections.  After
-	each successful read(), the timeout will be extended by this
+	Applied on peer server connections.
+
+	After each successful read(), the timeout will be extended by this
 	amount.  If no data is read again after this amount of time,
-	the request is aborted and logged with ERR_READ_TIMEOUT.  The
-	default is 15 minutes.
+	the request is aborted and logged with ERR_READ_TIMEOUT.
+
+	The default is 15 minutes.
 DOC_END
 
 NAME: write_timeout
@@ -83,6 +83,8 @@
 #include "fqdncache.h"
 #include "FwdState.h"
 #include "globals.h"
+#include "helper.h"
+#include "helper/Reply.h"
 #include "http.h"
 #include "http/one/RequestParser.h"
 #include "HttpHdrContRange.h"
@@ -3336,7 +3338,7 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
     finishDechunkingRequest(false);
 
     // XXX: The code below works if we fail during initial request parsing,
-    // but if we fail when the server-side works already, the server may send
+    // but if we fail when the server connection is used already, the server may send
     // us its response too, causing various assertions. How to prevent that?
 #if WE_KNOW_HOW_TO_SEND_ERRORS
     ClientSocketContext::Pointer context = getCurrentContext();
@@ -3403,14 +3405,22 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
 
 ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
         AsyncJob("ConnStateData"), // kids overwrite
+        nrequests(0),
 #if USE_OPENSSL
         sslBumpMode(Ssl::bumpEnd),
+#endif
+        needProxyProtocolHeader_(false),
+#if USE_OPENSSL
         switchedToHttps_(false),
         sslServerBump(NULL),
+        signAlgorithm(Ssl::algSignTrusted),
 #endif
         stoppedSending_(NULL),
         stoppedReceiving_(NULL)
 {
+    flags.readMore = true; // kids may overwrite
+    flags.swanSang = false;
+
     pinning.host = NULL;
     pinning.port = -1;
     pinning.pinned = false;
@@ -3423,8 +3433,6 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
     port = xact->squidPort;
     log_addr = xact->tcpClient->remote;
     log_addr.applyMask(Config.Addrs.client_netmask);
-
-    flags.readMore = true; // kids may overwrite
 }
 
 void
@@ -3848,16 +3856,16 @@ ConnStateData::postHttpsAccept()
 }
 
 void
-ConnStateData::sslCrtdHandleReplyWrapper(void *data, const HelperReply &reply)
+ConnStateData::sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply)
 {
     ConnStateData * state_data = (ConnStateData *)(data);
     state_data->sslCrtdHandleReply(reply);
 }
 
 void
-ConnStateData::sslCrtdHandleReply(const HelperReply &reply)
+ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply)
 {
-    if (reply.result == HelperReply::BrokenHelper) {
+    if (reply.result == Helper::BrokenHelper) {
         debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply);
     } else if (!reply.other().hasContent()) {
         debugs(1, DBG_IMPORTANT, HERE << "\"ssl_crtd\" helper returned <NULL> reply.");
@@ -3866,11 +3874,11 @@ ConnStateData::sslCrtdHandleReply(const HelperReply &reply)
         if (reply_message.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK) {
             debugs(33, 5, HERE << "Reply from ssl_crtd for " << sslConnectHostOrIp << " is incorrect");
         } else {
-            if (reply.result != HelperReply::Okay) {
+            if (reply.result != Helper::Okay) {
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply_message.getBody());
             } else {
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " was successfully recieved from ssl_crtd");
-                if (sslServerBump && (sslServerBump->mode == Ssl::bumpPeek || sslServerBump->mode == Ssl::bumpStare)) {
+                if (sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare)) {
                     doPeekAndSpliceStep();
                     SSL *ssl = fd_table[clientConnection->fd].ssl;
                     bool ret = Ssl::configureSSLUsingPkeyAndCertFromMemory(ssl, reply_message.getBody().c_str(), *port);
@@ -3987,7 +3995,7 @@ ConnStateData::getSslContextStart()
         assert(sslBumpCertKey.size() > 0 && sslBumpCertKey[0] != '\0');
 
         // Disable caching for bumpPeekAndSplice mode
-        if (!(sslServerBump && (sslServerBump->mode == Ssl::bumpPeek || sslServerBump->mode == Ssl::bumpStare))) {
+        if (!(sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare))) {
             debugs(33, 5, "Finding SSL certificate for " << sslBumpCertKey << " in cache");
             Ssl::LocalContextStorage * ssl_ctx_cache = Ssl::TheGlobalContextStorage.getLocalStorage(port->s);
             SSL_CTX * dynCtx = NULL;
@@ -4027,7 +4035,7 @@ ConnStateData::getSslContextStart()
 #endif // USE_SSL_CRTD
 
         debugs(33, 5, HERE << "Generating SSL certificate for " << certProperties.commonName);
-        if (sslServerBump && (sslServerBump->mode == Ssl::bumpPeek || sslServerBump->mode == Ssl::bumpStare)) {
+        if (sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare)) {
             doPeekAndSpliceStep();
             SSL *ssl = fd_table[clientConnection->fd].ssl;
             if (!Ssl::configureSSL(ssl, certProperties, *port))
@@ -4196,16 +4204,25 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
         return;
 
     debugs(33, 5, "Answer: " << answer << " kind:" << answer.kind);
-    if (answer == ACCESS_ALLOWED && answer.kind != Ssl::bumpNone && answer.kind != Ssl::bumpSplice) {
-        if (answer.kind == Ssl::bumpTerminate)
-            comm_close(connState->clientConnection->fd);
-        else {
-            if (answer.kind != Ssl::bumpPeek && answer.kind != Ssl::bumpStare)
-                connState->sslBumpMode = Ssl::bumpBump;
-            else
-                connState->sslBumpMode = (Ssl::BumpMode)answer.kind;
-            connState->startPeekAndSpliceDone();
-        }
+    assert(connState->serverBump());
+    Ssl::BumpMode bumpAction;
+    if (answer == ACCESS_ALLOWED) {
+        if (answer.kind == Ssl::bumpNone)
+            bumpAction = Ssl::bumpSplice;
+        else if (answer.kind == Ssl::bumpClientFirst || answer.kind == Ssl::bumpServerFirst)
+            bumpAction = Ssl::bumpBump;
+        else
+            bumpAction = (Ssl::BumpMode)answer.kind;
+    } else
+        bumpAction = Ssl::bumpSplice;
+
+    connState->serverBump()->act.step2 = bumpAction;
+    connState->sslBumpMode = bumpAction;
+
+    if (bumpAction == Ssl::bumpTerminate) {
+        comm_close(connState->clientConnection->fd);
+    } else if (bumpAction != Ssl::bumpSplice) {
+        connState->startPeekAndSpliceDone();
     } else {
         //Normally we can splice here, because we just got client hello message
         SSL *ssl = fd_table[connState->clientConnection->fd].ssl;
@@ -4214,8 +4231,6 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
         MemBuf const &rbuf = bio->rBufData();
         debugs(83,5, "Bio for  " << connState->clientConnection << " read " << rbuf.contentSize() << " helo bytes");
         // Do splice:
-
-        connState->sslBumpMode = Ssl::bumpSplice;
         fd_table[connState->clientConnection->fd].read_method = &default_read_method;
         fd_table[connState->clientConnection->fd].write_method = &default_write_method;
 
@@ -13,6 +13,7 @@
 
 #include "clientStreamForward.h"
 #include "comm.h"
+#include "helper/forward.h"
 #include "HttpControlMsg.h"
 #include "http/forward.h"
 #include "ipc/FdNotes.h"
@@ -28,7 +29,6 @@ class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
 class ChunkedCodingParser;
-class HelperReply;
 namespace AnyP
 {
 class PortCfg;
@@ -282,7 +282,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     bool handleRequestBodyData();
 
     /// Forward future client requests using the given server connection.
-    /// Optionally, monitor pinned server connection for server-side closures.
+    /// Optionally, monitor pinned server connection for remote-end closures.
     void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth, bool monitor = true);
     /// Undo pinConnection() and, optionally, close the pinned connection.
     void unpinConnection(const bool andClose);
@@ -335,7 +335,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /// Called when the initialization of peek-and-splice negotiation finidhed
     void startPeekAndSpliceDone();
     /// Called when a peek-and-splice step finished. For example after
-    /// server-side SSL certificates received and client-side SSL certificates
+    /// server SSL certificates received and fake server SSL certificates
     /// generated
     void doPeekAndSpliceStep();
     /// called by FwdState when it is done bumping the server
@@ -350,9 +350,9 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
      */
     void getSslContextDone(SSL_CTX * sslContext, bool isNew = false);
     /// Callback function. It is called when squid receive message from ssl_crtd.
-    static void sslCrtdHandleReplyWrapper(void *data, const HelperReply &reply);
+    static void sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply);
     /// Proccess response from ssl_crtd.
-    void sslCrtdHandleReply(const HelperReply &reply);
+    void sslCrtdHandleReply(const Helper::Reply &reply);
 
     void switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode);
     bool switchedToHttps() const { return switchedToHttps_; }
@@ -35,6 +35,7 @@
 #include "format/Token.h"
 #include "gopher.h"
 #include "helper.h"
+#include "helper/Reply.h"
 #include "http.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
@@ -863,8 +864,8 @@ clientRedirectAccessCheckDone(allow_t answer, void *data)
     if (answer == ACCESS_ALLOWED)
         redirectStart(http, clientRedirectDoneWrapper, context);
     else {
-        HelperReply nilReply;
-        nilReply.result = HelperReply::Error;
+        Helper::Reply nilReply;
+        nilReply.result = Helper::Error;
         context->clientRedirectDone(nilReply);
     }
 }
@@ -896,8 +897,8 @@ clientStoreIdAccessCheckDone(allow_t answer, void *data)
         storeIdStart(http, clientStoreIdDoneWrapper, context);
     else {
         debugs(85, 3, "access denied expected ERR reply handling: " << answer);
-        HelperReply nilReply;
-        nilReply.result = HelperReply::Error;
+        Helper::Reply nilReply;
+        nilReply.result = Helper::Error;
         context->clientStoreIdDone(nilReply);
     }
 }
@@ -1178,7 +1179,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 }
 
 void
-clientRedirectDoneWrapper(void *data, const HelperReply &result)
+clientRedirectDoneWrapper(void *data, const Helper::Reply &result)
 {
     ClientRequestContext *calloutContext = (ClientRequestContext *)data;
 
@@ -1189,7 +1190,7 @@ clientRedirectDoneWrapper(void *data, const HelperReply &result)
 }
 
 void
-clientStoreIdDoneWrapper(void *data, const HelperReply &result)
+clientStoreIdDoneWrapper(void *data, const Helper::Reply &result)
 {
     ClientRequestContext *calloutContext = (ClientRequestContext *)data;
 
@@ -1200,7 +1201,7 @@ clientStoreIdDoneWrapper(void *data, const HelperReply &result)
 }
 
 void
-ClientRequestContext::clientRedirectDone(const HelperReply &reply)
+ClientRequestContext::clientRedirectDone(const Helper::Reply &reply)
 {
     HttpRequest *old_request = http->request;
     debugs(85, 5, HERE << "'" << http->uri << "' result=" << reply);
@@ -1215,14 +1216,14 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
     UpdateRequestNotes(http->getConn(), *old_request, reply.notes);
 
     switch (reply.result) {
-    case HelperReply::Unknown:
-    case HelperReply::TT:
+    case Helper::Unknown:
+    case Helper::TT:
         // Handler in redirect.cc should have already mapped Unknown
         // IF it contained valid entry for the old URL-rewrite helper protocol
         debugs(85, DBG_IMPORTANT, "ERROR: URL rewrite helper returned invalid result code. Wrong helper? " << reply);
         break;
 
-    case HelperReply::BrokenHelper:
+    case Helper::BrokenHelper:
         debugs(85, DBG_IMPORTANT, "ERROR: URL rewrite helper: " << reply << ", attempt #" << (redirect_fail_count+1) << " of 2");
         if (redirect_fail_count < 2) { // XXX: make this configurable ?
             ++redirect_fail_count;
@@ -1231,11 +1232,11 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
         }
         break;
 
-    case HelperReply::Error:
+    case Helper::Error:
         // no change to be done.
         break;
 
-    case HelperReply::Okay: {
+    case Helper::Okay: {
         // #1: redirect with a specific status code    OK status=NNN url="..."
         // #2: redirect with a default status code     OK url="..."
         // #3: re-write the URL                        OK rewrite-url="..."
@@ -1321,7 +1322,7 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
  * This method handles the different replies from StoreID helper.
  */
 void
-ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
+ClientRequestContext::clientStoreIdDone(const Helper::Reply &reply)
 {
     HttpRequest *old_request = http->request;
     debugs(85, 5, "'" << http->uri << "' result=" << reply);
@@ -1336,14 +1337,14 @@ ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
     UpdateRequestNotes(http->getConn(), *old_request, reply.notes);
 
     switch (reply.result) {
-    case HelperReply::Unknown:
-    case HelperReply::TT:
+    case Helper::Unknown:
+    case Helper::TT:
         // Handler in redirect.cc should have already mapped Unknown
         // IF it contained valid entry for the old helper protocol
         debugs(85, DBG_IMPORTANT, "ERROR: storeID helper returned invalid result code. Wrong helper? " << reply);
         break;
 
-    case HelperReply::BrokenHelper:
+    case Helper::BrokenHelper:
         debugs(85, DBG_IMPORTANT, "ERROR: storeID helper: " << reply << ", attempt #" << (store_id_fail_count+1) << " of 2");
         if (store_id_fail_count < 2) { // XXX: make this configurable ?
             ++store_id_fail_count;
@@ -1352,11 +1353,11 @@ ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
         }
         break;
 
-    case HelperReply::Error:
+    case Helper::Error:
         // no change to be done.
         break;
 
-    case HelperReply::Okay: {
+    case Helper::Okay: {
         const char *urlNote = reply.notes.findFirst("store-id");
 
         // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
@@ -10,6 +10,7 @@
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "base/TextException.h"
+#include "clients/Client.h"
 #include "comm/Connection.h"
 #include "comm/forward.h"
 #include "comm/Write.h"
@@ -19,7 +20,6 @@
 #include "HttpHdrContRange.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-#include "Server.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -37,7 +37,11 @@
 // implemented in client_side_reply.cc until sides have a common parent
 void purgeEntriesByUrl(HttpRequest * req, const char *url);
 
-ServerStateData::ServerStateData(FwdState *theFwdState): AsyncJob("ServerStateData"),
+Client::Client(FwdState *theFwdState): AsyncJob("Client"),
+        completed(false),
+        currentOffset(0),
+        responseBodyBuffer(NULL),
+        fwd(theFwdState),
         requestSender(NULL),
 #if USE_ADAPTATION
         adaptedHeadSource(NULL),
@@ -48,16 +52,14 @@ ServerStateData::ServerStateData(FwdState *theFwdState): AsyncJob("ServerStateDa
         theVirginReply(NULL),
         theFinalReply(NULL)
 {
-    fwd = theFwdState;
     entry = fwd->entry;
-
-    entry->lock("ServerStateData");
+    entry->lock("Client");
 
     request = fwd->request;
     HTTPMSGLOCK(request);
 }
 
-ServerStateData::~ServerStateData()
+Client::~Client()
 {
     // paranoid: check that swanSong has been called
     assert(!requestBodySource);
@@ -66,7 +68,7 @@ ServerStateData::~ServerStateData()
     assert(!adaptedBodySource);
 #endif
 
-    entry->unlock("ServerStateData");
+    entry->unlock("Client");
 
     HTTPMSGUNLOCK(request);
     HTTPMSGUNLOCK(theVirginReply);
@@ -81,7 +83,7 @@ ServerStateData::~ServerStateData()
 }
 
 void
-ServerStateData::swanSong()
+Client::swanSong()
 {
     // get rid of our piping obligations
     if (requestBodySource != NULL)
@@ -107,21 +109,21 @@ ServerStateData::swanSong()
 }
 
 HttpReply *
-ServerStateData::virginReply()
+Client::virginReply()
 {
     assert(theVirginReply);
     return theVirginReply;
 }
 
 const HttpReply *
-ServerStateData::virginReply() const
+Client::virginReply() const
 {
     assert(theVirginReply);
     return theVirginReply;
 }
 
 HttpReply *
-ServerStateData::setVirginReply(HttpReply *rep)
+Client::setVirginReply(HttpReply *rep)
 {
     debugs(11,5, HERE << this << " setting virgin reply to " << rep);
     assert(!theVirginReply);
@@ -132,14 +134,14 @@ ServerStateData::setVirginReply(HttpReply *rep)
 }
 
 HttpReply *
-ServerStateData::finalReply()
+Client::finalReply()
 {
     assert(theFinalReply);
     return theFinalReply;
 }
 
 HttpReply *
-ServerStateData::setFinalReply(HttpReply *rep)
+Client::setFinalReply(HttpReply *rep)
 {
     debugs(11,5, HERE << this << " setting final reply to " << rep);
 
@@ -160,7 +162,7 @@ ServerStateData::setFinalReply(HttpReply *rep)
 
 // called when no more server communication is expected; may quit
 void
-ServerStateData::serverComplete()
+Client::serverComplete()
 {
     debugs(11,5,HERE << "serverComplete " << this);
 
@@ -184,7 +186,7 @@ ServerStateData::serverComplete()
 }
 
 void
-ServerStateData::serverComplete2()
+Client::serverComplete2()
 {
     debugs(11,5,HERE << "serverComplete2 " << this);
 
@@ -199,7 +201,7 @@ ServerStateData::serverComplete2()
     completeForwarding();
 }
 
-bool ServerStateData::doneAll() const
+bool Client::doneAll() const
 {
     return  doneWithServer() &&
 #if USE_ADAPTATION
@@ -212,15 +214,15 @@ bool ServerStateData::doneAll() const
 
 // FTP side overloads this to work around multiple calls to fwd->complete
 void
-ServerStateData::completeForwarding()
+Client::completeForwarding()
 {
     debugs(11,5, HERE << "completing forwarding for "  << fwd);
     assert(fwd != NULL);
     fwd->complete();
 }
 
 // Register to receive request body
-bool ServerStateData::startRequestBodyFlow()
+bool Client::startRequestBodyFlow()
 {
     HttpRequest *r = originalRequest();
     assert(r->body_pipe != NULL);
@@ -239,7 +241,7 @@ bool ServerStateData::startRequestBodyFlow()
 
 // Entry-dependent callbacks use this check to quit if the entry went bad
 bool
-ServerStateData::abortOnBadEntry(const char *abortReason)
+Client::abortOnBadEntry(const char *abortReason)
 {
     if (entry->isAccepting())
         return false;
@@ -251,7 +253,7 @@ ServerStateData::abortOnBadEntry(const char *abortReason)
 
 // more request or adapted response body is available
 void
-ServerStateData::noteMoreBodyDataAvailable(BodyPipe::Pointer bp)
+Client::noteMoreBodyDataAvailable(BodyPipe::Pointer bp)
 {
 #if USE_ADAPTATION
     if (adaptedBodySource == bp) {
@@ -265,7 +267,7 @@ ServerStateData::noteMoreBodyDataAvailable(BodyPipe::Pointer bp)
 
 // the entire request or adapted response body was provided, successfully
 void
-ServerStateData::noteBodyProductionEnded(BodyPipe::Pointer bp)
+Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
 {
 #if USE_ADAPTATION
     if (adaptedBodySource == bp) {
@@ -279,7 +281,7 @@ ServerStateData::noteBodyProductionEnded(BodyPipe::Pointer bp)
 
 // premature end of the request or adapted response body production
 void
-ServerStateData::noteBodyProducerAborted(BodyPipe::Pointer bp)
+Client::noteBodyProducerAborted(BodyPipe::Pointer bp)
 {
 #if USE_ADAPTATION
     if (adaptedBodySource == bp) {
@@ -293,7 +295,7 @@ ServerStateData::noteBodyProducerAborted(BodyPipe::Pointer bp)
 
 // more origin request body data is available
 void
-ServerStateData::handleMoreRequestBodyAvailable()
+Client::handleMoreRequestBodyAvailable()
 {
     if (!requestSender)
         sendMoreRequestBody();
@@ -303,7 +305,7 @@ ServerStateData::handleMoreRequestBodyAvailable()
 
 // there will be no more handleMoreRequestBodyAvailable calls
 void
-ServerStateData::handleRequestBodyProductionEnded()
+Client::handleRequestBodyProductionEnded()
 {
     receivedWholeRequestBody = true;
     if (!requestSender)
@@ -314,7 +316,7 @@ ServerStateData::handleRequestBodyProductionEnded()
 
 // called when we are done sending request body; kids extend this
 void
-ServerStateData::doneSendingRequestBody()
+Client::doneSendingRequestBody()
 {
     debugs(9,3, HERE << "done sending request body");
     assert(requestBodySource != NULL);
@@ -325,7 +327,7 @@ ServerStateData::doneSendingRequestBody()
 
 // called when body producers aborts; kids extend this
 void
-ServerStateData::handleRequestBodyProducerAborted()
+Client::handleRequestBodyProducerAborted()
 {
     if (requestSender != NULL)
         debugs(9,3, HERE << "fyi: request body aborted while we were sending");
@@ -338,7 +340,7 @@ ServerStateData::handleRequestBodyProducerAborted()
 
 // called when we wrote request headers(!) or a part of the body
 void
-ServerStateData::sentRequestBody(const CommIoCbParams &io)
+Client::sentRequestBody(const CommIoCbParams &io)
 {
     debugs(11, 5, "sentRequestBody: FD " << io.fd << ": size " << io.size << ": errflag " << io.flag << ".");
     debugs(32,3,HERE << "sentRequestBody called");
@@ -383,7 +385,7 @@ ServerStateData::sentRequestBody(const CommIoCbParams &io)
 }
 
 void
-ServerStateData::sendMoreRequestBody()
+Client::sendMoreRequestBody()
 {
     assert(requestBodySource != NULL);
     assert(!requestSender);
@@ -398,8 +400,8 @@ ServerStateData::sendMoreRequestBody()
     MemBuf buf;
     if (getMoreRequestBody(buf) && buf.contentSize() > 0) {
         debugs(9,3, HERE << "will write " << buf.contentSize() << " request body bytes");
-        typedef CommCbMemFunT<ServerStateData, CommIoCbParams> Dialer;
-        requestSender = JobCallback(93,3, Dialer, this, ServerStateData::sentRequestBody);
+        typedef CommCbMemFunT<Client, CommIoCbParams> Dialer;
+        requestSender = JobCallback(93,3, Dialer, this, Client::sentRequestBody);
         Comm::Write(conn, &buf, requestSender);
     } else {
         debugs(9,3, HERE << "will wait for more request body bytes or eof");
@@ -409,7 +411,7 @@ ServerStateData::sendMoreRequestBody()
 
 /// either fill buf with available [encoded] request body bytes or return false
 bool
-ServerStateData::getMoreRequestBody(MemBuf &buf)
+Client::getMoreRequestBody(MemBuf &buf)
 {
     // default implementation does not encode request body content
     Must(requestBodySource != NULL);
@@ -480,7 +482,7 @@ purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hd
 
 // some HTTP methods should purge matching cache entries
 void
-ServerStateData::maybePurgeOthers()
+Client::maybePurgeOthers()
 {
     // only some HTTP methods should purge matching cache entries
     if (!request->method.purgesOthers())
@@ -500,7 +502,7 @@ ServerStateData::maybePurgeOthers()
 
 /// called when we have final (possibly adapted) reply headers; kids extend
 void
-ServerStateData::haveParsedReplyHeaders()
+Client::haveParsedReplyHeaders()
 {
     Must(theFinalReply);
     maybePurgeOthers();
@@ -513,7 +515,7 @@ ServerStateData::haveParsedReplyHeaders()
 
 /// whether to prevent caching of an otherwise cachable response
 bool
-ServerStateData::blockCaching()
+Client::blockCaching()
 {
     if (const Acl::Tree *acl = Config.accessList.storeMiss) {
         // This relatively expensive check is not in StoreEntry::checkCachable:
@@ -530,17 +532,17 @@ ServerStateData::blockCaching()
 }
 
 HttpRequest *
-ServerStateData::originalRequest()
+Client::originalRequest()
 {
     return request;
 }
 
 #if USE_ADAPTATION
 /// Initiate an asynchronous adaptation transaction which will call us back.
 void
-ServerStateData::startAdaptation(const Adaptation::ServiceGroupPointer &group, HttpRequest *cause)
+Client::startAdaptation(const Adaptation::ServiceGroupPointer &group, HttpRequest *cause)
 {
-    debugs(11, 5, "ServerStateData::startAdaptation() called");
+    debugs(11, 5, "Client::startAdaptation() called");
     // check whether we should be sending a body as well
     // start body pipe to feed ICAP transaction if needed
     assert(!virginBodyDestination);
@@ -564,7 +566,7 @@ ServerStateData::startAdaptation(const Adaptation::ServiceGroupPointer &group, H
 
 // properly cleans up ICAP-related state
 // may be called multiple times
-void ServerStateData::cleanAdaptation()
+void Client::cleanAdaptation()
 {
     debugs(11,5, HERE << "cleaning ICAP; ACL: " << adaptationAccessCheckPending);
 
@@ -581,15 +583,15 @@ void ServerStateData::cleanAdaptation()
 }
 
 bool
-ServerStateData::doneWithAdaptation() const
+Client::doneWithAdaptation() const
 {
     return !adaptationAccessCheckPending &&
            !virginBodyDestination && !adaptedHeadSource && !adaptedBodySource;
 }
 
 // sends virgin reply body to ICAP, buffering excesses if needed
 void
-ServerStateData::adaptVirginReplyBody(const char *data, ssize_t len)
+Client::adaptVirginReplyBody(const char *data, ssize_t len)
 {
     assert(startedAdaptation);
 
@@ -631,7 +633,7 @@ ServerStateData::adaptVirginReplyBody(const char *data, ssize_t len)
 
 // can supply more virgin response body data
 void
-ServerStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
+Client::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 {
     if (responseBodyBuffer) {
         addVirginReplyBody(NULL, 0); // kick the buffered fragment alive again
@@ -645,7 +647,7 @@ ServerStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 
 // the consumer of our virgin response body aborted
 void
-ServerStateData::noteBodyConsumerAborted(BodyPipe::Pointer)
+Client::noteBodyConsumerAborted(BodyPipe::Pointer)
 {
     stopProducingFor(virginBodyDestination, false);
 
@@ -657,7 +659,7 @@ ServerStateData::noteBodyConsumerAborted(BodyPipe::Pointer)
 
 // received adapted response headers (body may follow)
 void
-ServerStateData::noteAdaptationAnswer(const Adaptation::Answer &answer)
+Client::noteAdaptationAnswer(const Adaptation::Answer &answer)
 {
     clearAdaptation(adaptedHeadSource); // we do not expect more messages
 
@@ -677,7 +679,7 @@ ServerStateData::noteAdaptationAnswer(const Adaptation::Answer &answer)
 }
 
 void
-ServerStateData::handleAdaptedHeader(HttpMsg *msg)
+Client::handleAdaptedHeader(HttpMsg *msg)
 {
     if (abortOnBadEntry("entry went bad while waiting for adapted headers")) {
         // If the adapted response has a body, the ICAP side needs to know
@@ -711,7 +713,7 @@ ServerStateData::handleAdaptedHeader(HttpMsg *msg)
 }
 
 void
-ServerStateData::resumeBodyStorage()
+Client::resumeBodyStorage()
 {
     if (abortOnBadEntry("store entry aborted while kick producer callback"))
         return;
@@ -727,7 +729,7 @@ ServerStateData::resumeBodyStorage()
 
 // more adapted response body is available
 void
-ServerStateData::handleMoreAdaptedBodyAvailable()
+Client::handleMoreAdaptedBodyAvailable()
 {
     if (abortOnBadEntry("entry refuses adapted body"))
         return;
@@ -743,9 +745,9 @@ ServerStateData::handleMoreAdaptedBodyAvailable()
 
     if (spaceAvailable < contentSize ) {
         // No or partial body data consuming
-        typedef NullaryMemFunT<ServerStateData> Dialer;
-        AsyncCall::Pointer call = asyncCall(93, 5, "ServerStateData::resumeBodyStorage",
-                                            Dialer(this, &ServerStateData::resumeBodyStorage));
+        typedef NullaryMemFunT<Client> Dialer;
+        AsyncCall::Pointer call = asyncCall(93, 5, "Client::resumeBodyStorage",
+                                            Dialer(this, &Client::resumeBodyStorage));
         entry->deferProducer(call);
     }
 
@@ -774,7 +776,7 @@ ServerStateData::handleMoreAdaptedBodyAvailable()
 
 // the entire adapted response body was produced, successfully
 void
-ServerStateData::handleAdaptedBodyProductionEnded()
+Client::handleAdaptedBodyProductionEnded()
 {
     if (abortOnBadEntry("entry went bad while waiting for adapted body eof"))
         return;
@@ -786,22 +788,22 @@ ServerStateData::handleAdaptedBodyProductionEnded()
 }
 
 void
-ServerStateData::endAdaptedBodyConsumption()
+Client::endAdaptedBodyConsumption()
 {
     stopConsumingFrom(adaptedBodySource);
     handleAdaptationCompleted();
 }
 
 // premature end of the adapted response body
-void ServerStateData::handleAdaptedBodyProducerAborted()
+void Client::handleAdaptedBodyProducerAborted()
 {
     stopConsumingFrom(adaptedBodySource);
     handleAdaptationAborted();
 }
 
 // common part of noteAdaptationAnswer and handleAdaptedBodyProductionEnded
 void
-ServerStateData::handleAdaptationCompleted()
+Client::handleAdaptationCompleted()
 {
     debugs(11,5, HERE << "handleAdaptationCompleted");
     cleanAdaptation();
@@ -820,7 +822,7 @@ ServerStateData::handleAdaptationCompleted()
 
 // common part of noteAdaptation*Aborted and noteBodyConsumerAborted methods
 void
-ServerStateData::handleAdaptationAborted(bool bypassable)
+Client::handleAdaptationAborted(bool bypassable)
 {
     debugs(11,5, HERE << "handleAdaptationAborted; bypassable: " << bypassable <<
            ", entry empty: " << entry->isEmpty());
@@ -845,7 +847,7 @@ ServerStateData::handleAdaptationAborted(bool bypassable)
 
 // adaptation service wants us to deny HTTP client access to this response
 void
-ServerStateData::handleAdaptationBlocked(const Adaptation::Answer &answer)
+Client::handleAdaptationBlocked(const Adaptation::Answer &answer)
 {
     debugs(11,5, HERE << answer.ruleId);
 
@@ -875,20 +877,20 @@ ServerStateData::handleAdaptationBlocked(const Adaptation::Answer &answer)
 }
 
 void
-ServerStateData::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer group)
+Client::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer group)
 {
     adaptationAccessCheckPending = false;
 
     if (abortOnBadEntry("entry went bad while waiting for ICAP ACL check"))
         return;
 
-    // TODO: Should nonICAP and postICAP path check this on the server-side?
-    // That check now only happens on client-side, in processReplyAccess().
+    // TODO: Should non-ICAP and ICAP REPMOD pre-cache paths check this?
+    // That check now only happens on REQMOD pre-cache and REPMOD post-cache, in processReplyAccess().
     if (virginReply()->expectedBodyTooLarge(*request)) {
         sendBodyIsTooLargeError();
         return;
     }
-    // TODO: Should we check receivedBodyTooLarge on the server-side as well?
+    // TODO: Should we check receivedBodyTooLarge as well?
 
     if (!group) {
         debugs(11,3, HERE << "no adapation needed");
@@ -903,7 +905,7 @@ ServerStateData::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer grou
 #endif
 
 void
-ServerStateData::sendBodyIsTooLargeError()
+Client::sendBodyIsTooLargeError()
 {
     ErrorState *err = new ErrorState(ERR_TOO_BIG, Http::scForbidden, request);
     fwd->fail(err);
@@ -914,7 +916,7 @@ ServerStateData::sendBodyIsTooLargeError()
 // TODO: when HttpStateData sends all errors to ICAP,
 // we should be able to move this at the end of setVirginReply().
 void
-ServerStateData::adaptOrFinalizeReply()
+Client::adaptOrFinalizeReply()
 {
 #if USE_ADAPTATION
     // TODO: merge with client side and return void to hide the on/off logic?
@@ -932,7 +934,7 @@ ServerStateData::adaptOrFinalizeReply()
 
 /// initializes bodyBytesRead stats if needed and applies delta
 void
-ServerStateData::adjustBodyBytesRead(const int64_t delta)
+Client::adjustBodyBytesRead(const int64_t delta)
 {
     int64_t &bodyBytesRead = originalRequest()->hier.bodyBytesRead;
 
@@ -947,7 +949,7 @@ ServerStateData::adjustBodyBytesRead(const int64_t delta)
 }
 
 void
-ServerStateData::addVirginReplyBody(const char *data, ssize_t len)
+Client::addVirginReplyBody(const char *data, ssize_t len)
 {
     adjustBodyBytesRead(len);
 
@@ -963,15 +965,15 @@ ServerStateData::addVirginReplyBody(const char *data, ssize_t len)
 
 // writes virgin or adapted reply body to store
 void
-ServerStateData::storeReplyBody(const char *data, ssize_t len)
+Client::storeReplyBody(const char *data, ssize_t len)
 {
     // write even if len is zero to push headers towards the client side
     entry->write (StoreIOBuffer(len, currentOffset, (char*)data));
 
     currentOffset += len;
 }
 
-size_t ServerStateData::replyBodySpace(const MemBuf &readBuf,
+size_t Client::replyBodySpace(const MemBuf &readBuf,
                                        const size_t minSpace) const
 {
     size_t space = readBuf.spaceSize(); // available space w/o heroic measures
@@ -1001,7 +1003,7 @@ size_t ServerStateData::replyBodySpace(const MemBuf &readBuf,
         size_t adaptation_space =
             virginBodyDestination->buf().potentialSpaceSize();
 
-        debugs(11,9, "ServerStateData may read up to min(" <<
+        debugs(11,9, "Client may read up to min(" <<
                adaptation_space << ", " << space << ") bytes");
 
         if (adaptation_space < space)
@@ -6,8 +6,8 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SERVER_H
-#define SQUID_SERVER_H
+#ifndef SQUID_SRC_CLIENTS_CLIENT_H
+#define SQUID_SRC_CLIENTS_CLIENT_H
 
 #include "base/AsyncJob.h"
 #include "BodyPipe.h"
@@ -23,15 +23,12 @@ class HttpMsg;
 class HttpReply;
 
 /**
- * ServerStateData is a common base for server-side classes such as
- * HttpStateData and FtpStateData. All such classes must be able to
- * consume request bodies from the client-side or ICAP producer, adapt
- * virgin responses using ICAP, and provide the client-side consumer with
- * responses.
- *
- \todo TODO: Rename to ServerStateDataInfoRecordHandler.
+ * Client is a common base for classes such as HttpStateData and FtpStateData.
+ * All such classes must be able to consume request bodies from a BodyPipe
+ * or ICAP producer, adapt virgin responses using ICAP, and provide a
+ * consumer with responses.
  */
-class ServerStateData:
+class Client:
 #if USE_ADAPTATION
         public Adaptation::Initiator,
         public BodyProducer,
@@ -40,8 +37,8 @@ class ServerStateData:
 {
 
 public:
-    ServerStateData(FwdState *);
-    virtual ~ServerStateData();
+    Client(FwdState *);
+    virtual ~Client();
 
     /// \return primary or "request data connection"
     virtual const Comm::ConnectionPointer & dataConnection() const = 0;
@@ -181,4 +178,4 @@ class ServerStateData:
     HttpReply *theFinalReply;        /**< adapted reply from ICAP or virgin reply */
 };
 
-#endif /* SQUID_SERVER_H */
+#endif /* SQUID_SRC_CLIENTS_CLIENT_H */
@@ -163,7 +163,7 @@ Ftp::DataChannel::addr(const Ip::Address &import)
 
 Ftp::Client::Client(FwdState *fwdState):
         AsyncJob("Ftp::Client"),
-        ::ServerStateData(fwdState),
+        ::Client(fwdState),
         ctrl(),
         data(),
         state(BEGIN),
@@ -1020,7 +1020,7 @@ Ftp::Client::sentRequestBody(const CommIoCbParams &io)
 {
     if (io.size > 0)
         kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
-    ::ServerStateData::sentRequestBody(io);
+    ::Client::sentRequestBody(io);
 }
 
 /**
@@ -1029,7 +1029,7 @@ Ftp::Client::sentRequestBody(const CommIoCbParams &io)
 void
 Ftp::Client::doneSendingRequestBody()
 {
-    ::ServerStateData::doneSendingRequestBody();
+    ::Client::doneSendingRequestBody();
     debugs(9, 3, status());
     dataComplete();
     /* NP: RFC 959  3.3.  DATA CONNECTION MANAGEMENT
@@ -11,7 +11,7 @@
 #ifndef SQUID_FTP_CLIENT_H
 #define SQUID_FTP_CLIENT_H
 
-#include "Server.h"
+#include "clients/Client.h"
 
 class String;
 namespace Ftp
@@ -89,7 +89,7 @@ class DataChannel: public Ftp::Channel
 };
 
 /// FTP client functionality shared among FTP Gateway and Relay clients.
-class Client: public ::ServerStateData
+class Client: public ::Client
 {
 public:
     explicit Client(FwdState *fwdState);
@@ -101,7 +101,7 @@ class Client: public ::ServerStateData
     /// read timeout handler
     virtual void timeout(const CommTimeoutCbParams &io);
 
-    /* ServerStateData API */
+    /* Client API */
     virtual void maybeReadVirginBody();
 
     void writeCommand(const char *buf);
@@ -160,7 +160,7 @@ class Client: public ::ServerStateData
     /* AsyncJob API */
     virtual void start();
 
-    /* ServerStateData API */
+    /* Client API */
     virtual void closeServer();
     virtual bool doneWithServer() const;
     virtual const Comm::ConnectionPointer & dataConnection() const;
@@ -33,7 +33,6 @@
 #include "MemBuf.h"
 #include "mime.h"
 #include "rfc1738.h"
-#include "Server.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
@@ -332,12 +331,28 @@ Ftp::Gateway::dataClosed(const CommCloseCbParams &io)
 
 Ftp::Gateway::Gateway(FwdState *fwdState):
         AsyncJob("FtpStateData"),
-        Ftp::Client(fwdState)
-{
-    const char *url = entry->url();
-    debugs(9, 3, HERE << "'" << url << "'" );
-    theSize = -1;
-    mdtm = -1;
+        Ftp::Client(fwdState),
+        password_url(0),
+        reply_hdr(NULL),
+        reply_hdr_state(0),
+        conn_att(0),
+        login_att(0),
+        mdtm(-1),
+        theSize(-1),
+        pathcomps(NULL),
+        filepath(NULL),
+        dirpath(NULL),
+        restart_offset(0),
+        proxy_host(NULL),
+        list_width(0),
+        old_filepath(NULL),
+        typecode('\0')
+{
+    debugs(9, 3, entry->url());
+
+    *user = 0;
+    *password = 0;
+    memset(&flags, 0, sizeof(flags));
 
     if (Config.Ftp.passive && !flags.pasv_failed)
         flags.pasv_supported = 1;
@@ -352,7 +367,7 @@ Ftp::Gateway::Gateway(FwdState *fwdState):
 
 Ftp::Gateway::~Gateway()
 {
-    debugs(9, 3, HERE << entry->url()  );
+    debugs(9, 3, entry->url());
 
     if (Comm::IsConnOpen(ctrl.conn)) {
         debugs(9, DBG_IMPORTANT, "Internal bug: FTP Gateway left open " <<
@@ -368,16 +383,11 @@ Ftp::Gateway::~Gateway()
         wordlistDestroy(&pathcomps);
 
     cwd_message.clean();
-
-    safe_free(old_filepath);
-
+    xfree(old_filepath);
     title_url.clean();
-
     base_href.clean();
-
-    safe_free(filepath);
-
-    safe_free(dirpath);
+    xfree(filepath);
+    xfree(dirpath);
 }
 
 /**
@@ -1869,7 +1879,7 @@ ftpSendPORT(Ftp::Gateway * ftpState)
     ftpState->writeCommand(cbuf);
     ftpState->state = Ftp::Client::SENT_PORT;
 
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
 }
 
 static void
@@ -2320,7 +2330,7 @@ ftpReadTransferDone(Ftp::Gateway * ftpState)
 void
 Ftp::Gateway::handleRequestBodyProducerAborted()
 {
-    ServerStateData::handleRequestBodyProducerAborted();
+    Client::handleRequestBodyProducerAborted();
     debugs(9, 3, HERE << "ftpState=" << this);
     failed(ERR_READ_ERROR, 0);
 }
@@ -2622,7 +2632,7 @@ Ftp::Gateway::appendSuccessHeader()
 void
 Ftp::Gateway::haveParsedReplyHeaders()
 {
-    ServerStateData::haveParsedReplyHeaders();
+    Client::haveParsedReplyHeaders();
 
     StoreEntry *e = entry;
 
@@ -2713,7 +2723,7 @@ Ftp::Gateway::completeForwarding()
     }
 
     flags.completed_forwarding = true;
-    ServerStateData::completeForwarding();
+    Client::completeForwarding();
 }
 
 /**
@@ -18,7 +18,6 @@
 #include "HttpHdrCc.h"
 #include "HttpRequest.h"
 #include "SBuf.h"
-#include "Server.h"
 #include "servers/FtpServer.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -46,7 +45,7 @@ class Relay: public Ftp::Client
     virtual void failed(err_type error = ERR_NONE, int xerrno = 0);
     virtual void dataChannelConnected(const CommConnectCbParams &io);
 
-    /* ServerStateData API */
+    /* Client API */
     virtual void serverComplete();
     virtual void handleControlReply();
     virtual void processReplyBody();
@@ -138,6 +137,7 @@ const Ftp::Relay::SM_FUNC Ftp::Relay::SM_FUNCS[] = {
 Ftp::Relay::Relay(FwdState *const fwdState):
         AsyncJob("Ftp::Relay"),
         Ftp::Client(fwdState),
+        thePreliminaryCb(NULL),
         forwardingCompleted(false)
 {
     savedReply.message = NULL;
@@ -152,7 +152,7 @@ Ftp::Relay::Relay(FwdState *const fwdState):
 
 Ftp::Relay::~Relay()
 {
-    closeServer(); // TODO: move to Server.cc?
+    closeServer(); // TODO: move to clients/Client.cc?
     if (savedReply.message)
         wordlistDestroy(&savedReply.message);
 
@@ -327,7 +327,7 @@ Ftp::Relay::handleControlReply()
 void
 Ftp::Relay::handleRequestBodyProducerAborted()
 {
-    ::ServerStateData::handleRequestBodyProducerAborted();
+    ::Client::handleRequestBodyProducerAborted();
 
     failed(ERR_READ_ERROR);
 }
@@ -11,6 +11,8 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libclients.la
 
 libclients_la_SOURCES = \
+	Client.cc \
+	Client.h \
 	FtpClient.cc \
 	FtpClient.h \
 	FtpGateway.cc \
@@ -120,10 +120,10 @@ comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
     ++ statCounter.syscalls.sock.recvfroms;
     debugs(5,8, "comm_udp_recvfrom: FD " << fd << " from " << from);
     struct addrinfo *AI = NULL;
-    Ip::Address::InitAddrInfo(AI);
+    Ip::Address::InitAddr(AI);
     int x = recvfrom(fd, buf, len, flags, AI->ai_addr, &AI->ai_addrlen);
     from = *AI;
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
     return x;
 }
 
@@ -173,16 +173,16 @@ comm_local_port(int fd)
     if (F->sock_family == AF_INET)
         temp.setIPv4();
 
-    Ip::Address::InitAddrInfo(addr);
+    Ip::Address::InitAddr(addr);
 
     if (getsockname(fd, addr->ai_addr, &(addr->ai_addrlen)) ) {
         debugs(50, DBG_IMPORTANT, "comm_local_port: Failed to retrieve TCP/UDP port number for socket: FD " << fd << ": " << xstrerror());
-        Ip::Address::FreeAddrInfo(addr);
+        Ip::Address::FreeAddr(addr);
         return 0;
     }
     temp = *addr;
 
-    Ip::Address::FreeAddrInfo(addr);
+    Ip::Address::FreeAddr(addr);
 
     if (F->local_addr.isAnyAddr()) {
         /* save the whole local address, not just the port. */
@@ -347,7 +347,7 @@ comm_openex(int sock_type,
     /* try again as IPv4-native if possible */
     if ( new_socket < 0 && Ip::EnableIpv6 && addr.isIPv6() && addr.setIPv4() ) {
         /* attempt to open this IPv4-only. */
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
         /* Setup the socket addrinfo details for use */
         addr.getAddrInfo(AI);
         AI->ai_socktype = sock_type;
@@ -369,7 +369,7 @@ comm_openex(int sock_type,
             debugs(50, DBG_CRITICAL, "comm_open: socket failure: " << xstrerror());
         }
 
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
 
         PROF_stop(comm_open);
         return -1;
@@ -393,7 +393,7 @@ comm_openex(int sock_type,
     comm_init_opened(conn, note, AI);
     new_socket = comm_apply_flags(conn->fd, addr, flags, AI);
 
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
 
     PROF_stop(comm_open);
 
@@ -680,7 +680,7 @@ comm_connect_addr(int sock, const Ip::Address &address)
 
     }
 
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
 
     PROF_stop(comm_connect_addr);
 
@@ -951,7 +951,7 @@ comm_udp_sendto(int fd,
     struct addrinfo *AI = NULL;
     to_addr.getAddrInfo(AI, fd_table[fd].sock_family);
     int x = sendto(fd, buf, len, 0, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
 
     PROF_stop(comm_udp_sendto);
 
@@ -407,16 +407,16 @@ void
 Comm::ConnOpener::lookupLocalAddress()
 {
     struct addrinfo *addr = NULL;
-    Ip::Address::InitAddrInfo(addr);
+    Ip::Address::InitAddr(addr);
 
     if (getsockname(conn_->fd, addr->ai_addr, &(addr->ai_addrlen)) != 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: Failed to retrieve TCP/UDP details for socket: " << conn_ << ": " << xstrerror());
-        Ip::Address::FreeAddrInfo(addr);
+        Ip::Address::FreeAddr(addr);
         return;
     }
 
     conn_->local = *addr;
-    Ip::Address::FreeAddrInfo(addr);
+    Ip::Address::FreeAddr(addr);
     debugs(5, 6, HERE << conn_);
 }
 
@@ -336,13 +336,13 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     ++statCounter.syscalls.sock.accepts;
     int sock;
     struct addrinfo *gai = NULL;
-    Ip::Address::InitAddrInfo(gai);
+    Ip::Address::InitAddr(gai);
 
     errcode = 0; // reset local errno copy.
     if ((sock = accept(conn->fd, gai->ai_addr, &gai->ai_addrlen)) < 0) {
         errcode = errno; // store last accept errno locally.
 
-        Ip::Address::FreeAddrInfo(gai);
+        Ip::Address::FreeAddr(gai);
 
         PROF_stop(comm_accept);
 
@@ -365,21 +365,21 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     if ( Config.client_ip_max_connections >= 0) {
         if (clientdbEstablished(details->remote, 0) > Config.client_ip_max_connections) {
             debugs(50, DBG_IMPORTANT, "WARNING: " << details->remote << " attempting more than " << Config.client_ip_max_connections << " connections.");
-            Ip::Address::FreeAddrInfo(gai);
+            Ip::Address::FreeAddr(gai);
             return Comm::COMM_ERROR;
         }
     }
 
     // lookup the local-end details of this new connection
-    Ip::Address::InitAddrInfo(gai);
+    Ip::Address::InitAddr(gai);
     details->local.setEmpty();
     if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
-        Ip::Address::FreeAddrInfo(gai);
+        Ip::Address::FreeAddr(gai);
         return Comm::COMM_ERROR;
     }
     details->local = *gai;
-    Ip::Address::FreeAddrInfo(gai);
+    Ip::Address::FreeAddr(gai);
 
     /* fdstat update */
     // XXX : these are not all HTTP requests. use a note about type and ip:port details->
@@ -212,9 +212,7 @@ static void idnsAddPathComponent(const char *buf);
 static void idnsFreeNameservers(void);
 static void idnsFreeSearchpath(void);
 static bool idnsParseNameservers(void);
-#if _SQUID_WINDOWS_
 static bool idnsParseResolvConf(void);
-#endif
 #if _SQUID_WINDOWS_
 static bool idnsParseWIN32Registry(void);
 static void idnsParseWIN32SearchList(const char *);
@@ -379,15 +377,12 @@ idnsParseNameservers(void)
     return result;
 }
 
-#if !_SQUID_WINDOWS_
 static bool
 idnsParseResolvConf(void)
 {
-    FILE *fp;
-    char buf[RESOLV_BUFSZ];
-    const char *t;
     bool result = false;
-    fp = fopen(_PATH_RESCONF, "r");
+#if !_SQUID_WINDOWS_ || _SQUID_CYGWIN_
+    FILE *fp = fopen(_PATH_RESCONF, "r");
 
     if (fp == NULL) {
         debugs(78, DBG_IMPORTANT, "" << _PATH_RESCONF << ": " << xstrerror());
@@ -398,6 +393,8 @@ idnsParseResolvConf(void)
     setmode(fileno(fp), O_TEXT);
 #endif
 
+    char buf[RESOLV_BUFSZ];
+    const char *t = NULL;
     while (fgets(buf, RESOLV_BUFSZ, fp)) {
         t = strtok(buf, w_space);
 
@@ -460,11 +457,10 @@ idnsParseResolvConf(void)
     }
 
     fclose(fp);
+#endif
     return result;
 }
 
-#endif
-
 #if _SQUID_WINDOWS_
 static void
 idnsParseWIN32SearchList(const char * Separator)
@@ -1568,12 +1564,10 @@ dnsInit(void)
     assert(0 == nns);
     idnsAddMDNSNameservers();
     bool nsFound = idnsParseNameservers();
-#if !_SQUID_WINDOWS_
 
     if (!nsFound)
         nsFound = idnsParseResolvConf();
 
-#endif
 #if _SQUID_WINDOWS_
     if (!nsFound)
         nsFound = idnsParseWIN32Registry();
@@ -12,10 +12,10 @@
 typedef enum {
     ERR_DETAIL_NONE,
     ERR_DETAIL_START = 100000, // to avoid clashes with most OS error numbers
-    ERR_DETAIL_CLT_REQMOD_ABORT = ERR_DETAIL_START, // client-side detected transaction abort
-    ERR_DETAIL_CLT_REQMOD_REQ_BODY, // client-side detected REQMOD request body adaptation failure
-    ERR_DETAIL_CLT_REQMOD_RESP_BODY, // client-side detected REQMOD satisfaction reply body failure
-    ERR_DETAIL_SRV_REQMOD_REQ_BODY, // server-side detected REQMOD request body abort
+    ERR_DETAIL_CLT_REQMOD_ABORT = ERR_DETAIL_START, // client-facing code detected transaction abort
+    ERR_DETAIL_CLT_REQMOD_REQ_BODY, // client-facing code detected REQMOD request body adaptation failure
+    ERR_DETAIL_CLT_REQMOD_RESP_BODY, // client-facing code detected REQMOD satisfaction reply body failure
+    ERR_DETAIL_SRV_REQMOD_REQ_BODY, // server-facing code detected REQMOD request body abort
     ERR_DETAIL_ICAP_RESPMOD_EARLY, // RESPMOD failed w/o store entry
     ERR_DETAIL_ICAP_RESPMOD_LATE,  // RESPMOD failed with a store entry
     ERR_DETAIL_REQMOD_BLOCK, // REQMOD denied client access
@@ -20,6 +20,7 @@
 #include "fde.h"
 #include "format/ByteCode.h"
 #include "helper.h"
+#include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -54,8 +55,6 @@
 #define DEFAULT_EXTERNAL_ACL_CHILDREN 5
 #endif
 
-typedef struct _external_acl_format external_acl_format;
-
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, external_acl_entry * entry);
 static int external_acl_entry_expired(external_acl * def, external_acl_entry * entry);
@@ -67,6 +66,28 @@ static external_acl_entry *external_acl_cache_add(external_acl * def, const char
  * external_acl directive
  */
 
+class external_acl_format : public RefCountable
+{
+public:
+    typedef RefCount<external_acl_format> Pointer;
+    MEMPROXY_CLASS(external_acl_format);
+
+    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(HDR_BAD_HDR) {}
+    ~external_acl_format() {
+        xfree(header);
+        xfree(member);
+    }
+
+    Format::ByteCode_t type;
+    external_acl_format::Pointer next;
+    char *header;
+    char *member;
+    char separator;
+    http_hdr_type header_id;
+};
+
+MEMPROXY_CLASS_INLINE(external_acl_format);
+
 class external_acl
 {
 
@@ -85,11 +106,11 @@ class external_acl
 
     char *name;
 
-    external_acl_format *format;
+    external_acl_format::Pointer format;
 
     wordlist *cmdline;
 
-    HelperChildConfig children;
+    Helper::ChildConfig children;
 
     helper *theHelper;
 
@@ -121,39 +142,18 @@ class external_acl
     Ip::Address local_addr;
 };
 
-struct _external_acl_format {
-    Format::ByteCode_t type;
-    external_acl_format *next;
-    char *header;
-    char *member;
-    char separator;
-    http_hdr_type header_id;
-};
-
 /* FIXME: These are not really cbdata, but it is an easy way
  * to get them pooled, refcounted, accounted and freed properly...
  */
 CBDATA_TYPE(external_acl);
-CBDATA_TYPE(external_acl_format);
-
-static void
-free_external_acl_format(void *data)
-{
-    external_acl_format *p = static_cast<external_acl_format *>(data);
-    safe_free(p->header);
-}
 
 static void
 free_external_acl(void *data)
 {
     external_acl *p = static_cast<external_acl *>(data);
     safe_free(p->name);
 
-    while (p->format) {
-        external_acl_format *f = p->format;
-        p->format = f->next;
-        cbdataFree(f);
-    }
+    p->format = NULL;
 
     wordlistDestroy(&p->cmdline);
 
@@ -178,7 +178,7 @@ free_external_acl(void *data)
  \param format   - structure to contain all the info about this format element.
  */
 void
-parse_header_token(external_acl_format *format, char *header, const Format::ByteCode_t type)
+parse_header_token(external_acl_format::Pointer format, char *header, const Format::ByteCode_t type)
 {
     /* header format */
     char *member, *end;
@@ -224,10 +224,8 @@ parse_externalAclHelper(external_acl ** list)
 {
     external_acl *a;
     char *token;
-    external_acl_format **p;
 
     CBDATA_INIT_TYPE_FREECB(external_acl, free_external_acl);
-    CBDATA_INIT_TYPE_FREECB(external_acl_format, free_external_acl_format);
 
     a = cbdataAlloc(external_acl);
 
@@ -317,17 +315,15 @@ parse_externalAclHelper(external_acl ** list)
         a->negative_ttl = a->ttl;
 
     /* Parse format */
-    p = &a->format;
+    external_acl_format::Pointer *p = &a->format;
 
     while (token) {
-        external_acl_format *format;
-
         /* stop on first non-format token found */
 
         if (*token != '%')
             break;
 
-        format = cbdataAlloc(external_acl_format);
+        external_acl_format::Pointer format = new external_acl_format;
 
         if (strncmp(token, "%{", 2) == 0) {
             // deprecated. but assume the old configs all referred to request headers.
@@ -448,7 +444,6 @@ void
 dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl * list)
 {
     const external_acl *node;
-    const external_acl_format *format;
     const wordlist *word;
 
     for (node = list; node; node = node->next) {
@@ -486,7 +481,7 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
         if (node->quote == external_acl::QUOTE_METHOD_SHELL)
             storeAppendPrintf(sentry, " protocol=2.5");
 
-        for (format = node->format; format; format = format->next) {
+        for (external_acl_format::Pointer format = node->format; format!= NULL; format = format->next) {
             switch (format->type) {
 
             case Format::LFT_ADAPTED_REQUEST_HEADER:
@@ -880,13 +875,12 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
     char buf[256];
     int first = 1;
     wordlist *arg;
-    external_acl_format *format;
     HttpRequest *request = ch->request;
     HttpReply *reply = ch->reply;
     mb.reset();
     bool data_used = false;
 
-    for (format = acl_data->def->format; format; format = format->next) {
+    for (external_acl_format::Pointer format = acl_data->def->format; format != NULL; format = format->next) {
         const char *str = NULL;
         String sb;
 
@@ -1072,7 +1066,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             X509 *serverCert = NULL;
             if (ch->serverCert.get())
                 serverCert = ch->serverCert.get();
-            else if (ch->conn()->serverBump())
+            else if (ch->conn() && ch->conn()->serverBump())
                 serverCert = ch->conn()->serverBump()->serverCert.get();
 
             if (serverCert) {
@@ -1292,7 +1286,7 @@ free_externalAclState(void *data)
  * with \-escaping on any whitespace, quotes, or slashes (\).
  */
 static void
-externalAclHandleReply(void *data, const HelperReply &reply)
+externalAclHandleReply(void *data, const Helper::Reply &reply)
 {
     externalAclState *state = static_cast<externalAclState *>(data);
     externalAclState *next;
@@ -1302,11 +1296,11 @@ externalAclHandleReply(void *data, const HelperReply &reply)
 
     debugs(82, 2, HERE << "reply=" << reply);
 
-    if (reply.result == HelperReply::Okay)
+    if (reply.result == Helper::Okay)
         entryData.result = ACCESS_ALLOWED;
     // XXX: handle other non-DENIED results better
 
-    // XXX: make entryData store a proper HelperReply object instead of copying.
+    // XXX: make entryData store a proper Helper::Reply object instead of copying.
 
     entryData.notes.append(&reply.notes);
 
@@ -1336,7 +1330,7 @@ externalAclHandleReply(void *data, const HelperReply &reply)
 
     if (cbdataReferenceValid(state->def)) {
         // only cache OK and ERR results.
-        if (reply.result == HelperReply::Okay || reply.result == HelperReply::Error)
+        if (reply.result == Helper::Okay || reply.result == Helper::Error)
             entry = external_acl_cache_add(state->def, state->key, entryData);
         else {
             external_acl_entry *oldentry = (external_acl_entry *)hash_lookup(state->def->cache, state->key);
@@ -166,7 +166,7 @@ class fde
         dynamicSslContext = NULL;
 #endif
 #if _SQUID_WINDOWS_
-        win32.handle = NULL;
+        win32.handle = (long)NULL;
 #endif
         tosFromServer = '\0';
         nfmarkFromServer = 0;
@@ -13,7 +13,6 @@
 #include "DnsLookupDetails.h"
 #include "event.h"
 #include "helper.h"
-#include "HelperReply.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
@@ -304,7 +304,19 @@ Fs::Ufs::UFSSwapDir::create()
     createSwapSubDirs();
 }
 
-Fs::Ufs::UFSSwapDir::UFSSwapDir(char const *aType, const char *anIOType) : SwapDir(aType), IO(NULL), map(new FileMap()), suggest(0), swaplog_fd (-1), currentIOOptions(new ConfigOptionVector()), ioType(xstrdup(anIOType)), cur_size(0), n_disk_objects(0)
+Fs::Ufs::UFSSwapDir::UFSSwapDir(char const *aType, const char *anIOType) :
+        SwapDir(aType),
+        IO(NULL),
+        fsdata(NULL),
+        map(new FileMap()),
+        suggest(0),
+        l1(16),
+        l2(256),
+        swaplog_fd(-1),
+        currentIOOptions(new ConfigOptionVector()),
+        ioType(xstrdup(anIOType)),
+        cur_size(0),
+        n_disk_objects(0)
 {
     /* modulename is only set to disk modules that are built, by configure,
      * so the Find call should never return NULL here.
@@ -318,7 +330,7 @@ Fs::Ufs::UFSSwapDir::~UFSSwapDir()
         file_close(swaplog_fd);
         swaplog_fd = -1;
     }
-    safe_free(ioType);
+    xfree(ioType);
     delete map;
     delete IO;
     delete currentIOOptions;
@@ -18,6 +18,8 @@
 #include "fde.h"
 #include "format/Quoting.h"
 #include "helper.h"
+#include "helper/Reply.h"
+#include "helper/Request.h"
 #include "Mem.h"
 #include "MemBuf.h"
 #include "SquidIpc.h"
@@ -44,19 +46,17 @@ static IOCB helperHandleRead;
 static IOCB helperStatefulHandleRead;
 static void helperServerFree(helper_server *srv);
 static void helperStatefulServerFree(helper_stateful_server *srv);
-static void Enqueue(helper * hlp, helper_request *);
-static helper_request *Dequeue(helper * hlp);
-static helper_stateful_request *StatefulDequeue(statefulhelper * hlp);
+static void Enqueue(helper * hlp, Helper::Request *);
+static Helper::Request *Dequeue(helper * hlp);
+static Helper::Request *StatefulDequeue(statefulhelper * hlp);
 static helper_server *GetFirstAvailable(helper * hlp);
 static helper_stateful_server *StatefulGetFirstAvailable(statefulhelper * hlp);
-static void helperDispatch(helper_server * srv, helper_request * r);
-static void helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r);
+static void helperDispatch(helper_server * srv, Helper::Request * r);
+static void helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r);
 static void helperKickQueue(helper * hlp);
 static void helperStatefulKickQueue(statefulhelper * hlp);
 static void helperStatefulServerDone(helper_stateful_server * srv);
-static void helperRequestFree(helper_request * r);
-static void helperStatefulRequestFree(helper_stateful_request * r);
-static void StatefulEnqueue(statefulhelper * hlp, helper_stateful_request * r);
+static void StatefulEnqueue(statefulhelper * hlp, Helper::Request * r);
 static bool helperStartStats(StoreEntry *sentry, void *hlp, const char *label);
 
 CBDATA_CLASS_INIT(helper);
@@ -76,7 +76,7 @@ HelperServerBase::initStats()
 }
 
 void
-HelperServerBase::closePipesSafely()
+HelperServerBase::closePipesSafely(const char *id_name)
 {
 #if _SQUID_WINDOWS_
     shutdown(writePipe->fd, SD_BOTH);
@@ -93,17 +93,16 @@ HelperServerBase::closePipesSafely()
     if (hIpc) {
         if (WaitForSingleObject(hIpc, 5000) != WAIT_OBJECT_0) {
             getCurrentTime();
-            debugs(84, DBG_IMPORTANT, "WARNING: " << hlp->id_name <<
-                   " #" << index << " (" << hlp->cmdline->key << "," <<
-                   (long int)pid << ") didn't exit in 5 seconds");
+            debugs(84, DBG_IMPORTANT, "WARNING: " << id_name <<
+                   " #" << index << " (PID " << (long int)pid << ") didn't exit in 5 seconds");
         }
         CloseHandle(hIpc);
     }
 #endif
 }
 
 void
-HelperServerBase::closeWritePipeSafely()
+HelperServerBase::closeWritePipeSafely(const char *id_name)
 {
 #if _SQUID_WINDOWS_
     shutdown(writePipe->fd, (readPipe->fd == writePipe->fd ? SD_BOTH : SD_SEND));
@@ -118,9 +117,8 @@ HelperServerBase::closeWritePipeSafely()
     if (hIpc) {
         if (WaitForSingleObject(hIpc, 5000) != WAIT_OBJECT_0) {
             getCurrentTime();
-            debugs(84, DBG_IMPORTANT, "WARNING: " << hlp->id_name <<
-                   " #" << index << " (" << hlp->cmdline->key << "," <<
-                   (long int)pid << ") didn't exit in 5 seconds");
+            debugs(84, DBG_IMPORTANT, "WARNING: " << id_name <<
+                   " #" << index << " (PID " << (long int)pid << ") didn't exit in 5 seconds");
         }
         CloseHandle(hIpc);
     }
@@ -212,7 +210,7 @@ helperOpenServers(helper * hlp)
         srv->rbuf = (char *)memAllocBuf(ReadBufMinSize, &srv->rbuf_sz);
         srv->wqueue = new MemBuf;
         srv->roffset = 0;
-        srv->requests = (helper_request **)xcalloc(hlp->childs.concurrency ? hlp->childs.concurrency : 1, sizeof(*srv->requests));
+        srv->requests = (Helper::Request **)xcalloc(hlp->childs.concurrency ? hlp->childs.concurrency : 1, sizeof(*srv->requests));
         srv->parent = cbdataReference(hlp);
         dlinkAddTail(srv, &srv->link, &hlp->servers);
 
@@ -372,18 +370,14 @@ helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperSubmit: hlp == NULL");
-        HelperReply nilReply;
+        Helper::Reply nilReply;
         callback(data, nilReply);
         return;
     }
 
-    helper_request *r = new helper_request;
+    Helper::Request *r = new Helper::Request(callback, data, buf);
     helper_server *srv;
 
-    r->callback = callback;
-    r->data = cbdataReference(data);
-    r->buf = xstrdup(buf);
-
     if ((srv = GetFirstAvailable(hlp)))
         helperDispatch(srv, r);
     else
@@ -398,23 +392,12 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperStatefulSubmit: hlp == NULL");
-        HelperReply nilReply;
+        Helper::Reply nilReply;
         callback(data, nilReply);
         return;
     }
 
-    helper_stateful_request *r = new helper_stateful_request;
-
-    r->callback = callback;
-    r->data = cbdataReference(data);
-
-    if (buf != NULL) {
-        r->buf = xstrdup(buf);
-        r->placeholder = 0;
-    } else {
-        r->buf = NULL;
-        r->placeholder = 1;
-    }
+    Helper::Request *r = new Helper::Request(callback, data, buf);
 
     if ((buf != NULL) && lastserver) {
         debugs(84, 5, "StatefulSubmit with lastserver " << lastserver);
@@ -432,7 +415,7 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
     }
 
     debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
-           "', " << Raw("buf", buf, strlen(buf)));
+           "', " << Raw("buf", buf, (!buf?0:strlen(buf))));
 }
 
 /**
@@ -554,14 +537,14 @@ helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label
 
     for (dlink_node *link = hlp->servers.head; link; link = link->next) {
         helper_stateful_server *srv = (helper_stateful_server *)link->data;
-        double tt = 0.001 * tvSubMsec(srv->dispatch_time, srv->flags.busy ? current_time : srv->answer_time);
+        double tt = 0.001 * tvSubMsec(srv->dispatch_time, srv->stats.pending ? current_time : srv->answer_time);
         storeAppendPrintf(sentry, "%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
                           srv->index.value,
                           srv->readPipe->fd,
                           srv->pid,
                           srv->stats.uses,
                           srv->stats.replies,
-                          srv->flags.busy ? 'B' : ' ',
+                          srv->stats.pending ? 'B' : ' ',
                           srv->flags.closing ? 'C' : ' ',
                           srv->flags.reserved ? 'R' : ' ',
                           srv->flags.shutdown ? 'S' : ' ',
@@ -612,7 +595,7 @@ helperShutdown(helper * hlp)
         /* the rest of the details is dealt with in the helperServerFree
          * close handler
          */
-        srv->closePipesSafely();
+        srv->closePipesSafely(hlp->id_name);
     }
 }
 
@@ -635,7 +618,7 @@ helperStatefulShutdown(statefulhelper * hlp)
         -- hlp->childs.n_active;
         srv->flags.shutdown = true;	/* request it to shut itself down */
 
-        if (srv->flags.busy) {
+        if (srv->stats.pending) {
             debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " is BUSY.");
             continue;
         }
@@ -659,7 +642,7 @@ helperStatefulShutdown(statefulhelper * hlp)
         /* the rest of the details is dealt with in the helperStatefulServerFree
          * close handler
          */
-        srv->closePipesSafely();
+        srv->closePipesSafely(hlp->id_name);
     }
 }
 
@@ -679,7 +662,7 @@ static void
 helperServerFree(helper_server *srv)
 {
     helper *hlp = srv->parent;
-    helper_request *r;
+    Helper::Request *r;
     int i, concurrency = hlp->childs.concurrency;
 
     if (!concurrency)
@@ -700,7 +683,7 @@ helperServerFree(helper_server *srv)
     }
 
     if (Comm::IsConnOpen(srv->writePipe))
-        srv->closeWritePipeSafely();
+        srv->closeWritePipeSafely(hlp->id_name);
 
     dlinkDelete(&srv->link, &hlp->servers);
 
@@ -733,11 +716,11 @@ helperServerFree(helper_server *srv)
             void *cbdata;
 
             if (cbdataReferenceValidDone(r->data, &cbdata)) {
-                HelperReply nilReply;
+                Helper::Reply nilReply;
                 r->callback(cbdata, nilReply);
             }
 
-            helperRequestFree(r);
+            delete r;
 
             srv->requests[i] = NULL;
         }
@@ -752,7 +735,7 @@ static void
 helperStatefulServerFree(helper_stateful_server *srv)
 {
     statefulhelper *hlp = srv->parent;
-    helper_stateful_request *r;
+    Helper::Request *r;
 
     if (srv->rbuf) {
         memFreeBuf(srv->rbuf_sz, srv->rbuf);
@@ -768,7 +751,7 @@ helperStatefulServerFree(helper_stateful_server *srv)
 
     /* TODO: walk the local queue of requests and carry them all out */
     if (Comm::IsConnOpen(srv->writePipe))
-        srv->closeWritePipeSafely();
+        srv->closeWritePipeSafely(hlp->id_name);
 
     dlinkDelete(&srv->link, &hlp->servers);
 
@@ -799,12 +782,12 @@ helperStatefulServerFree(helper_stateful_server *srv)
         void *cbdata;
 
         if (cbdataReferenceValidDone(r->data, &cbdata)) {
-            HelperReply nilReply;
+            Helper::Reply nilReply;
             nilReply.whichServer = srv;
             r->callback(cbdata, nilReply);
         }
 
-        helperStatefulRequestFree(r);
+        delete r;
 
         srv->request = NULL;
     }
@@ -821,7 +804,7 @@ helperStatefulServerFree(helper_stateful_server *srv)
 static void
 helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char * msg, char * msg_end)
 {
-    helper_request *r = srv->requests[request_number];
+    Helper::Request *r = srv->requests[request_number];
     if (r) {
         HLPCB *callback = r->callback;
 
@@ -831,7 +814,7 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
 
         void *cbdata = NULL;
         if (cbdataReferenceValidDone(r->data, &cbdata)) {
-            HelperReply response(msg, (msg_end-msg));
+            Helper::Reply response(msg, (msg_end-msg));
             callback(cbdata, response);
         }
 
@@ -849,7 +832,7 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
                              tvSubMsec(r->dispatch_time, current_time),
                              hlp->stats.replies, REDIRECT_AV_FACTOR);
 
-        helperRequestFree(r);
+        delete r;
     } else {
         debugs(84, DBG_IMPORTANT, "helperHandleRead: unexpected reply on channel " <<
                request_number << " from " << hlp->id_name << " #" << srv->index <<
@@ -883,7 +866,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, Com
     debugs(84, 5, "helperHandleRead: " << len << " bytes from " << hlp->id_name << " #" << srv->index);
 
     if (flag != Comm::OK || len == 0) {
-        srv->closePipesSafely();
+        srv->closePipesSafely(hlp->id_name);
         return;
     }
 
@@ -948,7 +931,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, Com
             debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
                    "helper that overflowed " << srv->rbuf_sz << "-byte " <<
                    "Squid input buffer: " << hlp->id_name << " #" << srv->index);
-            srv->closePipesSafely();
+            srv->closePipesSafely(hlp->id_name);
             return;
         }
 
@@ -963,7 +946,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
 {
     char *t = NULL;
     helper_stateful_server *srv = (helper_stateful_server *)data;
-    helper_stateful_request *r;
+    Helper::Request *r;
     statefulhelper *hlp = srv->parent;
     assert(cbdataReferenceValid(data));
 
@@ -979,7 +962,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
            hlp->id_name << " #" << srv->index);
 
     if (flag != Comm::OK || len == 0) {
-        srv->closePipesSafely();
+        srv->closePipesSafely(hlp->id_name);
         return;
     }
 
@@ -1014,25 +997,24 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
         *t = '\0';
 
         if (r && cbdataReferenceValid(r->data)) {
-            HelperReply res(srv->rbuf, (t - srv->rbuf));
+            Helper::Reply res(srv->rbuf, (t - srv->rbuf));
             res.whichServer = srv;
             r->callback(r->data, res);
         } else {
             debugs(84, DBG_IMPORTANT, "StatefulHandleRead: no callback data registered");
             called = 0;
         }
-        // only skip off the \0's _after_ passing its location in HelperReply above
+        // only skip off the \0's _after_ passing its location in Helper::Reply above
         t += skip;
 
-        srv->flags.busy = false;
         /**
          * BUG: the below assumes that only one response per read() was received and discards any octets remaining.
          *      Doing this prohibits concurrency support with multiple replies per read().
          * TODO: check that read() setup on these buffers pays attention to roffest!=0
          * TODO: check that replies bigger than the buffer are discarded and do not to affect future replies
          */
         srv->roffset = 0;
-        helperStatefulRequestFree(r);
+        delete r;
         srv->request = NULL;
 
         -- srv->stats.pending;
@@ -1068,7 +1050,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
             debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
                    "helper that overflowed " << srv->rbuf_sz << "-byte " <<
                    "Squid input buffer: " << hlp->id_name << " #" << srv->index);
-            srv->closePipesSafely();
+            srv->closePipesSafely(hlp->id_name);
             return;
         }
 
@@ -1079,7 +1061,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
 }
 
 static void
-Enqueue(helper * hlp, helper_request * r)
+Enqueue(helper * hlp, Helper::Request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
@@ -1112,7 +1094,7 @@ Enqueue(helper * hlp, helper_request * r)
 }
 
 static void
-StatefulEnqueue(statefulhelper * hlp, helper_stateful_request * r)
+StatefulEnqueue(statefulhelper * hlp, Helper::Request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
@@ -1144,14 +1126,14 @@ StatefulEnqueue(statefulhelper * hlp, helper_stateful_request * r)
     debugs(84, DBG_CRITICAL, "WARNING: Consider increasing the number of " << hlp->id_name << " processes in your config file.");
 }
 
-static helper_request *
+static Helper::Request *
 Dequeue(helper * hlp)
 {
     dlink_node *link;
-    helper_request *r = NULL;
+    Helper::Request *r = NULL;
 
     if ((link = hlp->queue.head)) {
-        r = (helper_request *)link->data;
+        r = (Helper::Request *)link->data;
         dlinkDelete(link, &hlp->queue);
         memFree(link, MEM_DLINK_NODE);
         -- hlp->stats.queue_size;
@@ -1160,14 +1142,14 @@ Dequeue(helper * hlp)
     return r;
 }
 
-static helper_stateful_request *
+static Helper::Request *
 StatefulDequeue(statefulhelper * hlp)
 {
     dlink_node *link;
-    helper_stateful_request *r = NULL;
+    Helper::Request *r = NULL;
 
     if ((link = hlp->queue.head)) {
-        r = (helper_stateful_request *)link->data;
+        r = (Helper::Request *)link->data;
         dlinkDelete(link, &hlp->queue);
         memFree(link, MEM_DLINK_NODE);
         -- hlp->stats.queue_size;
@@ -1236,7 +1218,7 @@ StatefulGetFirstAvailable(statefulhelper * hlp)
     for (n = hlp->servers.head; n != NULL; n = n->next) {
         srv = (helper_stateful_server *)n->data;
 
-        if (srv->flags.busy)
+        if (srv->stats.pending)
             continue;
 
         if (srv->flags.reserved)
@@ -1283,15 +1265,15 @@ helperDispatchWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t l
 }
 
 static void
-helperDispatch(helper_server * srv, helper_request * r)
+helperDispatch(helper_server * srv, Helper::Request * r)
 {
     helper *hlp = srv->parent;
-    helper_request **ptr = NULL;
+    Helper::Request **ptr = NULL;
     unsigned int slot;
 
     if (!cbdataReferenceValid(r->data)) {
         debugs(84, DBG_IMPORTANT, "helperDispatch: invalid callback data");
-        helperRequestFree(r);
+        delete r;
         return;
     }
 
@@ -1339,13 +1321,13 @@ helperStatefulDispatchWriteDone(const Comm::ConnectionPointer &conn, char *buf,
 }
 
 static void
-helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r)
+helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
 {
     statefulhelper *hlp = srv->parent;
 
     if (!cbdataReferenceValid(r->data)) {
         debugs(84, DBG_IMPORTANT, "helperStatefulDispatch: invalid callback data");
-        helperStatefulRequestFree(r);
+        delete r;
         helperStatefulReleaseServer(srv);
         return;
     }
@@ -1356,11 +1338,11 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
         /* a callback is needed before this request can _use_ a helper. */
         /* we don't care about releasing this helper. The request NEVER
          * gets to the helper. So we throw away the return code */
-        HelperReply nilReply;
+        Helper::Reply nilReply;
         nilReply.whichServer = srv;
         r->callback(r->data, nilReply);
         /* throw away the placeholder */
-        helperStatefulRequestFree(r);
+        delete r;
         /* and push the queue. Note that the callback may have submitted a new
          * request to the helper which is why we test for the request */
 
@@ -1370,7 +1352,6 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
         return;
     }
 
-    srv->flags.busy = true;
     srv->flags.reserved = true;
     srv->request = r;
     srv->dispatch_time = current_time;
@@ -1389,7 +1370,7 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
 static void
 helperKickQueue(helper * hlp)
 {
-    helper_request *r;
+    Helper::Request *r;
     helper_server *srv;
 
     while ((srv = GetFirstAvailable(hlp)) && (r = Dequeue(hlp)))
@@ -1399,7 +1380,7 @@ helperKickQueue(helper * hlp)
 static void
 helperStatefulKickQueue(statefulhelper * hlp)
 {
-    helper_stateful_request *r;
+    Helper::Request *r;
     helper_stateful_server *srv;
 
     while ((srv = StatefulGetFirstAvailable(hlp)) && (r = StatefulDequeue(hlp)))
@@ -1411,30 +1392,12 @@ helperStatefulServerDone(helper_stateful_server * srv)
 {
     if (!srv->flags.shutdown) {
         helperStatefulKickQueue(srv->parent);
-    } else if (!srv->flags.closing && !srv->flags.reserved && !srv->flags.busy) {
-        srv->closeWritePipeSafely();
+    } else if (!srv->flags.closing && !srv->flags.reserved && !srv->stats.pending) {
+        srv->closeWritePipeSafely(srv->parent->id_name);
         return;
     }
 }
 
-static void
-helperRequestFree(helper_request * r)
-{
-    cbdataReferenceDone(r->data);
-    xfree(r->buf);
-    delete r;
-}
-
-static void
-helperStatefulRequestFree(helper_stateful_request * r)
-{
-    if (r) {
-        cbdataReferenceDone(r->data);
-        xfree(r->buf);
-        delete r;
-    }
-}
-
 // TODO: should helper_ and helper_stateful_ have a common parent?
 static bool
 helperStartStats(StoreEntry *sentry, void *hlp, const char *label)
@@ -16,14 +16,10 @@
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "dlink.h"
-#include "HelperChildConfig.h"
-#include "HelperReply.h"
+#include "helper/ChildConfig.h"
+#include "helper/forward.h"
 #include "ip/Address.h"
 
-class helper_request;
-
-typedef void HLPCB(void *, const HelperReply &reply);
-
 class helper
 {
 public:
@@ -43,7 +39,7 @@ class helper
     dlink_list servers;
     dlink_list queue;
     const char *id_name;
-    HelperChildConfig childs;    ///< Configuration settings for number running.
+    Helper::ChildConfig childs;    ///< Configuration settings for number running.
     int ipc_type;
     Ip::Address addr;
     time_t last_queue_warn;
@@ -84,14 +80,18 @@ class HelperServerBase
 public:
     /** Closes pipes to the helper safely.
      * Handles the case where the read and write pipes are the same FD.
+     *
+     * \param name displayed for the helper being shutdown if logging an error
      */
-    void closePipesSafely();
+    void closePipesSafely(const char *name);
 
     /** Closes the reading pipe.
      * If the read and write sockets are the same the write pipe will
      * also be closed. Otherwise its left open for later handling.
+     *
+     * \param name displayed for the helper being shutdown if logging an error
      */
-    void closeWritePipeSafely();
+    void closeWritePipeSafely(const char *name);
 
 public:
     /// Helper program identifier; does not change when contents do,
@@ -113,7 +113,6 @@ class HelperServerBase
     dlink_node link;
 
     struct _helper_flags {
-        bool busy;
         bool writing;
         bool closing;
         bool shutdown;
@@ -138,56 +137,27 @@ class helper_server : public HelperServerBase
     MemBuf *writebuf;
 
     helper *parent;
-    helper_request **requests;
+    Helper::Request **requests;
 
 private:
     CBDATA_CLASS2(helper_server);
 };
 
-class helper_stateful_request;
-
 class helper_stateful_server : public HelperServerBase
 {
 public:
     /* MemBuf wqueue; */
     /* MemBuf writebuf; */
 
     statefulhelper *parent;
-    helper_stateful_request *request;
+    Helper::Request *request;
 
     void *data;			/* State data used by the calling routines */
 
 private:
     CBDATA_CLASS2(helper_stateful_server);
 };
 
-class helper_request
-{
-
-public:
-    MEMPROXY_CLASS(helper_request);
-    char *buf;
-    HLPCB *callback;
-    void *data;
-
-    struct timeval dispatch_time;
-};
-
-MEMPROXY_CLASS_INLINE(helper_request);
-
-class helper_stateful_request
-{
-
-public:
-    MEMPROXY_CLASS(helper_stateful_request);
-    char *buf;
-    HLPCB *callback;
-    int placeholder;		/* if 1, this is a dummy request waiting for a stateful helper to become available */
-    void *data;
-};
-
-MEMPROXY_CLASS_INLINE(helper_stateful_request);
-
 /* helper.c */
 void helperOpenServers(helper * hlp);
 void helperStatefulOpenServers(statefulhelper * hlp);
@@ -11,12 +11,21 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "globals.h"
-#include "HelperChildConfig.h"
+#include "helper/ChildConfig.h"
 #include "Parsing.h"
 
 #include <cstring>
 
-HelperChildConfig::HelperChildConfig(const unsigned int m):
+Helper::ChildConfig::ChildConfig():
+        n_max(0),
+        n_startup(0),
+        n_idle(1),
+        concurrency(0),
+        n_running(0),
+        n_active(0)
+{}
+
+Helper::ChildConfig::ChildConfig(const unsigned int m):
         n_max(m),
         n_startup(0),
         n_idle(1),
@@ -25,8 +34,8 @@ HelperChildConfig::HelperChildConfig(const unsigned int m):
         n_active(0)
 {}
 
-HelperChildConfig &
-HelperChildConfig::updateLimits(const HelperChildConfig &rhs)
+Helper::ChildConfig &
+Helper::ChildConfig::updateLimits(const Helper::ChildConfig &rhs)
 {
     // Copy the limits only.
     // Preserve the local state values (n_running and n_active)
@@ -38,7 +47,7 @@ HelperChildConfig::updateLimits(const HelperChildConfig &rhs)
 }
 
 int
-HelperChildConfig::needNew() const
+Helper::ChildConfig::needNew() const
 {
     /* during the startup and reconfigure use our special amount... */
     if (starting_up || reconfiguring) return n_startup;
@@ -51,7 +60,7 @@ HelperChildConfig::needNew() const
 }
 
 void
-HelperChildConfig::parseConfig()
+Helper::ChildConfig::parseConfig()
 {
     char const *token = ConfigParser::NextToken();
 
@@ -6,19 +6,23 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef _SQUID_SRC_HELPERCHILDCONFIG_H
-#define _SQUID_SRC_HELPERCHILDCONFIG_H
+#ifndef _SQUID_SRC_HELPER_CHILDCONFIG_H
+#define _SQUID_SRC_HELPER_CHILDCONFIG_H
+
+namespace Helper
+{
 
 /**
  * Contains statistics of a particular type of child helper.
  *
  * Some derived from a helper children configuration option,
  * some from runtime stats on the currently active children.
  */
-class HelperChildConfig
+class ChildConfig
 {
 public:
-    explicit HelperChildConfig(const unsigned int m = 0);
+    ChildConfig();
+    explicit ChildConfig(const unsigned int m);
 
     /**
      * When new helpers are needed call this to find out how many more
@@ -35,7 +39,7 @@ class HelperChildConfig
      * This is for parsing new child settings into an object incrementally then updating
      * the running set without loosing any of the active state or causing races.
      */
-    HelperChildConfig &updateLimits(const HelperChildConfig &rhs);
+    ChildConfig &updateLimits(const ChildConfig &rhs);
 
     /* values from squid.conf */
 public:
@@ -82,9 +86,11 @@ class HelperChildConfig
     unsigned int n_active;
 };
 
+} // namespace Helper
+
 /* Legacy parser interface */
 #define parse_HelperChildConfig(c)     (c)->parseConfig()
 #define dump_HelperChildConfig(e,n,c)  storeAppendPrintf((e), "\n%s %d startup=%d idle=%d concurrency=%d\n", (n), (c).n_max, (c).n_startup, (c).n_idle, (c).concurrency)
 #define free_HelperChildConfig(dummy)  // NO.
 
-#endif /* _SQUID_SRC_HELPERCHILDCONFIG_H */
+#endif /* _SQUID_SRC_HELPER_CHILDCONFIG_H */
@@ -0,0 +1,20 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libhelper.la
+
+libhelper_la_SOURCES = \
+	ChildConfig.cc \
+	ChildConfig.h \
+	forward.h \
+	Reply.cc \
+	Reply.h \
+	Request.h \
+	ResultCode.h
@@ -12,25 +12,25 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "helper.h"
-#include "HelperReply.h"
+#include "helper/Reply.h"
 #include "rfc1738.h"
 #include "SquidString.h"
 
-HelperReply::HelperReply(char *buf, size_t len) :
-        result(HelperReply::Unknown),
+Helper::Reply::Reply(char *buf, size_t len) :
+        result(Helper::Unknown),
         whichServer(NULL)
 {
     parse(buf,len);
 }
 
 void
-HelperReply::parse(char *buf, size_t len)
+Helper::Reply::parse(char *buf, size_t len)
 {
     debugs(84, 3, "Parsing helper buffer");
     // check we have something to parse
     if (!buf || len < 1) {
         // empty line response was the old URL-rewriter interface ERR response.
-        result = HelperReply::Error;
+        result = Helper::Error;
         // for now ensure that legacy handlers are not presented with NULL strings.
         debugs(84, 3, "Reply length is smaller than 1 or none at all ");
         other_.init(1,1);
@@ -50,19 +50,19 @@ HelperReply::parse(char *buf, size_t len)
         // we must also check for the ' ' character after the response token (if anything)
         if (!strncmp(p,"OK",2) && (len == 2 || p[2] == ' ')) {
             debugs(84, 3, "helper Result = OK");
-            result = HelperReply::Okay;
+            result = Helper::Okay;
             p+=2;
         } else if (!strncmp(p,"ERR",3) && (len == 3 || p[3] == ' ')) {
             debugs(84, 3, "helper Result = ERR");
-            result = HelperReply::Error;
+            result = Helper::Error;
             p+=3;
         } else if (!strncmp(p,"BH",2) && (len == 2 || p[2] == ' ')) {
             debugs(84, 3, "helper Result = BH");
-            result = HelperReply::BrokenHelper;
+            result = Helper::BrokenHelper;
             p+=2;
         } else if (!strncmp(p,"TT ",3)) {
             // NTLM challenge token
-            result = HelperReply::TT;
+            result = Helper::TT;
             p+=3;
             // followed by an auth token
             char *w1 = strwordtok(NULL, &p);
@@ -73,13 +73,13 @@ HelperReply::parse(char *buf, size_t len)
                 notes.add("token",authToken.content());
             } else {
                 // token field is mandatory on this response code
-                result = HelperReply::BrokenHelper;
+                result = Helper::BrokenHelper;
                 notes.add("message","Missing 'token' data");
             }
 
         } else if (!strncmp(p,"AF ",3)) {
             // NTLM/Negotate OK response
-            result = HelperReply::Okay;
+            result = Helper::Okay;
             p+=3;
             // followed by:
             //  an optional auth token and user field
@@ -107,7 +107,7 @@ HelperReply::parse(char *buf, size_t len)
             }
         } else if (!strncmp(p,"NA ",3)) {
             // NTLM fail-closed ERR response
-            result = HelperReply::Error;
+            result = Helper::Error;
             p+=3;
             sawNA=true;
         }
@@ -127,7 +127,7 @@ HelperReply::parse(char *buf, size_t len)
         parseResponseKeys();
 
     // Hack for backward-compatibility: BH and NA used to be a text message...
-    if (other().hasContent() && (sawNA || result == HelperReply::BrokenHelper)) {
+    if (other().hasContent() && (sawNA || result == Helper::BrokenHelper)) {
         notes.add("message",other().content());
         modifiableOther().clean();
     }
@@ -154,7 +154,7 @@ isKeyNameChar(char c)
 }
 
 void
-HelperReply::parseResponseKeys()
+Helper::Reply::parseResponseKeys()
 {
     // parse a "key=value" pair off the 'other()' buffer.
     while (other().hasContent()) {
@@ -187,23 +187,23 @@ HelperReply::parseResponseKeys()
 }
 
 std::ostream &
-operator <<(std::ostream &os, const HelperReply &r)
+operator <<(std::ostream &os, const Helper::Reply &r)
 {
     os << "{result=";
     switch (r.result) {
-    case HelperReply::Okay:
+    case Helper::Okay:
         os << "OK";
         break;
-    case HelperReply::Error:
+    case Helper::Error:
         os << "ERR";
         break;
-    case HelperReply::BrokenHelper:
+    case Helper::BrokenHelper:
         os << "BH";
         break;
-    case HelperReply::TT:
+    case Helper::TT:
         os << "TT";
         break;
-    case HelperReply::Unknown:
+    case Helper::Unknown:
         os << "Unknown";
         break;
     }
@@ -6,38 +6,41 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef _SQUID_SRC_HELPERREPLY_H
-#define _SQUID_SRC_HELPERREPLY_H
+#ifndef _SQUID_SRC_HELPER_REPLY_H
+#define _SQUID_SRC_HELPER_REPLY_H
 
 #include "base/CbcPointer.h"
+#include "helper/forward.h"
+#include "helper/ResultCode.h"
 #include "MemBuf.h"
 #include "Notes.h"
 
 #include <ostream>
 
-class helper_stateful_server;
+namespace Helper
+{
 
 /**
  * This object stores the reply message from a helper lookup
  * It provides parser routing to accept a raw buffer and process the
  * helper reply into fields for easy access by callers
  */
-class HelperReply
+class Reply
 {
 private:
     // copy are prohibited for now
-    HelperReply(const HelperReply &r);
-    HelperReply &operator =(const HelperReply &r);
+    Reply(const Helper::Reply &r);
+    Reply &operator =(const Helper::Reply &r);
 
 public:
-    HelperReply() : result(HelperReply::Unknown), notes(), whichServer(NULL) {
+    Reply() : result(Helper::Unknown), notes(), whichServer(NULL) {
         other_.init(1,1);
         other_.terminate();
     }
 
     // create/parse details from the msg buffer provided
     // XXX: buf should be const but parse() needs non-const for now
-    HelperReply(char *buf, size_t len);
+    Reply(char *buf, size_t len);
 
     const MemBuf &other() const { return other_; }
 
@@ -59,16 +62,7 @@ class HelperReply
 
 public:
     /// The helper response 'result' field.
-    enum Result_ {
-        Unknown,      // no result code received, or unknown result code
-        Okay,         // "OK" indicating success/positive result
-        Error,        // "ERR" indicating success/negative result
-        BrokenHelper, // "BH" indicating failure due to helper internal problems.
-
-        // result codes for backward compatibility with NTLM/Negotiate
-        // TODO: migrate to a variant of the above results with kv-pair parameters
-        TT
-    } result;
+    Helper::ResultCode result;
 
     // list of key=value pairs the helper produced
     NotePairs notes;
@@ -83,6 +77,8 @@ class HelperReply
     MemBuf other_;
 };
 
-std::ostream &operator <<(std::ostream &os, const HelperReply &r);
+} // namespace Helper
+
+std::ostream &operator <<(std::ostream &os, const Helper::Reply &r);
 
-#endif /* _SQUID_SRC_HELPERREPLY_H */
+#endif /* _SQUID_SRC_HELPER_REPLY_H */
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef _SQUID_SRC_HELPER_REQUEST_H
+#define _SQUID_SRC_HELPER_REQUEST_H
+
+#include "helper/forward.h"
+
+namespace Helper
+{
+
+class Request
+{
+public:
+    Request(HLPCB *c, void *d, const char *b) :
+            buf(b ? xstrdup(b) : NULL),
+            callback(c),
+            data(cbdataReference(d)),
+            placeholder(b == NULL)
+    {
+        memset(&dispatch_time, 0, sizeof(dispatch_time));
+    }
+
+    ~Request() {
+        cbdataReferenceDone(data);
+        xfree(buf);
+    }
+
+    MEMPROXY_CLASS(Helper::Request);
+    char *buf;
+    HLPCB *callback;
+    void *data;
+
+    int placeholder;            /* if 1, this is a dummy request waiting for a stateful helper to become available */
+    struct timeval dispatch_time;
+};
+
+} // namespace Helper
+
+MEMPROXY_CLASS_INLINE(Helper::Request);
+
+#endif /* _SQUID_SRC_HELPER_REQUEST_H */
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef _SQUID_SRC_HELPER_RESULTCODE_H
+#define _SQUID_SRC_HELPER_RESULTCODE_H
+
+namespace Helper
+{
+
+/// enumeration value for the helper response 'result' field.
+enum ResultCode {
+    Unknown,      // no result code received, or unknown result code
+    Okay,         // "OK" indicating success/positive result
+    Error,        // "ERR" indicating success/negative result
+    BrokenHelper, // "BH" indicating failure due to helper internal problems.
+
+    // result codes for backward compatibility with NTLM/Negotiate
+    // TODO: migrate to a variant of the above results with kv-pair parameters
+    TT
+};
+
+} // namespace Helper
+
+#endif /* _SQUID_SRC_HELPER_RESULTCODE_H */
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_HELPER_FORWARD_H
+#define SQUID_SRC_HELPER_FORWARD_H
+
+class helper;
+class statefulhelper;
+
+class helper_server;
+class helper_stateful_server;
+
+/// helper protocol primitives
+namespace Helper
+{
+
+class Reply;
+class Request;
+
+} // namespace Helper
+
+typedef void HLPCB(void *, const Helper::Reply &);
+
+#endif /* SQUID_SRC_HELPER_FORWARD_H */
@@ -1067,7 +1067,9 @@ htcpHandleTst(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 
 HtcpReplyData::HtcpReplyData() :
         hit(0), hdr(hoHtcpReply), msg_id(0), version(0.0)
-{}
+{
+    memset(&cto, 0, sizeof(cto));
+}
 
 static void
 
@@ -82,7 +82,7 @@ static void copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeader
 //Declared in HttpHeaderTools.cc
 void httpHdrAdd(HttpHeader *heads, HttpRequest *request, const AccessLogEntryPointer &al, HeaderWithAclList &headers_add);
 
-HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"), ServerStateData(theFwdState),
+HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"), Client(theFwdState),
         lastChunk(0), header_bytes_read(0), reply_bytes_read(0),
         body_bytes_truncated(0), httpChunkDecoder(NULL)
 {
@@ -126,7 +126,7 @@ HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"),
 HttpStateData::~HttpStateData()
 {
     /*
-     * don't forget that ~ServerStateData() gets called automatically
+     * don't forget that ~Client() gets called automatically
      */
 
     if (!readBuf->isNull())
@@ -896,7 +896,7 @@ bool HttpStateData::peerSupportsConnectionPinning() const
 void
 HttpStateData::haveParsedReplyHeaders()
 {
-    ServerStateData::haveParsedReplyHeaders();
+    Client::haveParsedReplyHeaders();
 
     Ctx ctx = ctx_enter(entry->mem_obj->urlXXX());
     HttpReply *rep = finalReply();
@@ -1551,7 +1551,7 @@ HttpStateData::sendComplete()
     /*
      * Set the read timeout here because it hasn't been set yet.
      * We only set the read timeout after the request has been
-     * fully written to the server-side.  If we start the timeout
+     * fully written to the peer.  If we start the timeout
      * after connection establishment, then we are likely to hit
      * the timeout for POST/PUT requests that have very large
      * request bodies.
@@ -2224,7 +2224,7 @@ HttpStateData::getMoreRequestBody(MemBuf &buf)
 {
     // parent's implementation can handle the no-encoding case
     if (!flags.chunked_request)
-        return ServerStateData::getMoreRequestBody(buf);
+        return Client::getMoreRequestBody(buf);
 
     MemBuf raw;
 
@@ -2333,7 +2333,7 @@ HttpStateData::finishingChunkedRequest()
 void
 HttpStateData::doneSendingRequestBody()
 {
-    ServerStateData::doneSendingRequestBody();
+    Client::doneSendingRequestBody();
     debugs(11,5, HERE << serverConnection);
 
     // do we need to write something after the last body byte?
@@ -2380,7 +2380,7 @@ HttpStateData::handleMoreRequestBodyAvailable()
 void
 HttpStateData::handleRequestBodyProducerAborted()
 {
-    ServerStateData::handleRequestBodyProducerAborted();
+    Client::handleRequestBodyProducerAborted();
     if (entry->isEmpty()) {
         debugs(11, 3, "request body aborted: " << serverConnection);
         // We usually get here when ICAP REQMOD aborts during body processing.
@@ -2402,7 +2402,7 @@ HttpStateData::sentRequestBody(const CommIoCbParams &io)
     if (io.size > 0)
         kb_incr(&statCounter.server.http.kbytes_out, io.size);
 
-    ServerStateData::sentRequestBody(io);
+    Client::sentRequestBody(io);
 }
 
 // Quickly abort the transaction
@@ -9,15 +9,15 @@
 #ifndef SQUID_HTTP_H
 #define SQUID_HTTP_H
 
+#include "clients/Client.h"
 #include "comm.h"
 #include "HttpStateFlags.h"
-#include "Server.h"
 
 class ChunkedCodingParser;
 class FwdState;
 class HttpHeader;
 
-class HttpStateData : public ServerStateData
+class HttpStateData : public Client
 {
 
 public:
@@ -146,7 +146,7 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     }
 
     Log(to, ' ', NULL, 0, 0);
-    Ip::Address::FreeAddrInfo(S);
+    Ip::Address::FreeAddr(S);
 }
 
 void
@@ -170,7 +170,7 @@ Icmp4::Recv(void)
     if (pkt == NULL)
         pkt = (char *)xmalloc(MAX_PKT4_SZ);
 
-    Ip::Address::InitAddrInfo(from);
+    Ip::Address::InitAddr(from);
     n = recvfrom(icmp_sock,
                  (void *)pkt,
                  MAX_PKT4_SZ,
@@ -180,7 +180,7 @@ Icmp4::Recv(void)
 
     if (n <= 0) {
         debugs(42, DBG_CRITICAL, HERE << "Error when calling recvfrom() on ICMP socket.");
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
@@ -219,12 +219,12 @@ Icmp4::Recv(void)
     icmp = (struct icmphdr *) (void *) (pkt + iphdrlen);
 
     if (icmp->icmp_type != ICMP_ECHOREPLY) {
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
     if (icmp->icmp_id != icmp_ident) {
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
@@ -242,14 +242,14 @@ Icmp4::Recv(void)
 
     if (preply.psize < 0) {
         debugs(42, DBG_CRITICAL, HERE << "Malformed ICMP packet.");
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
     control.SendResult(preply, (sizeof(pingerReplyData) - MAX_PKT4_SZ + preply.psize) );
 
     Log(preply.from, icmp->icmp_type, IcmpPacketType(icmp->icmp_type), preply.rtt, preply.hops);
-    Ip::Address::FreeAddrInfo(from);
+    Ip::Address::FreeAddr(from);
 }
 
 #endif /* USE_ICMP */
@@ -183,7 +183,7 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     debugs(42,9, HERE << "x=" << x);
 
     Log(to, 0, NULL, 0, 0);
-    Ip::Address::FreeAddrInfo(S);
+    Ip::Address::FreeAddr(S);
 }
 
 /**
@@ -210,7 +210,7 @@ Icmp6::Recv(void)
         pkt = (char *)xmalloc(MAX_PKT6_SZ);
     }
 
-    Ip::Address::InitAddrInfo(from);
+    Ip::Address::InitAddr(from);
 
     n = recvfrom(icmp_sock,
                  (void *)pkt,
@@ -221,7 +221,7 @@ Icmp6::Recv(void)
 
     if (n <= 0) {
         debugs(42, DBG_CRITICAL, HERE << "Error when calling recvfrom() on ICMPv6 socket.");
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
@@ -282,13 +282,13 @@ Icmp6::Recv(void)
             debugs(42, 8, HERE << preply.from << " said: " << icmp6header->icmp6_type << "/" << (int)icmp6header->icmp6_code << " " <<
                    IcmpPacketType(icmp6header->icmp6_type));
         }
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
     if (icmp6header->icmp6_id != icmp_ident) {
         debugs(42, 8, HERE << "dropping Icmp6 read. IDENT check failed. ident=='" << icmp_ident << "'=='" << icmp6header->icmp6_id << "'");
-        Ip::Address::FreeAddrInfo(from);
+        Ip::Address::FreeAddr(from);
         return;
     }
 
@@ -325,7 +325,7 @@ Icmp6::Recv(void)
 
     /* send results of the lookup back to squid.*/
     control.SendResult(preply, (sizeof(pingerReplyData) - PINGER_PAYLOAD_SZ + preply.psize) );
-    Ip::Address::FreeAddrInfo(from);
+    Ip::Address::FreeAddr(from);
 }
 
 #endif /* USE_ICMP */
@@ -9,22 +9,18 @@
 #ifndef SQUID_IDENT_H
 #define SQUID_IDENT_H
 
-/**
- \defgroup IdentAPI Ident Lookup API
- \ingroup SquidComponents
- */
-
 #if USE_IDENT
 
 #include "cbdata.h"
 #include "comm/forward.h"
 
+typedef void IDCB(const char *ident, void *data);
+
+/// Ident Lookup API
 namespace Ident
 {
 
 /**
-  \ingroup IdentAPI
- *
  * Open a connection and request IDENT information from a peer machine.
  * Callack will be called whan the lookup is completed.
  * Self-registers with a global ident lookup manager,
@@ -33,15 +29,12 @@ namespace Ident
 void Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *cbdata);
 
 /**
- \ingroup IdentAPI
- *
  * Initialize IDENT lookup manager.
  * Currently a hash list of open ident requests.
- * \bug Will leak the hash list if called twice.
  */
 void Init(void);
 
-}
+} // namespace Ident
 
 #endif /* USE_IDENT */
 #endif /* SQUID_IDENT_H */
@@ -649,7 +649,7 @@ Ip::Address::getAddrInfo(struct addrinfo *&dst, int force) const
 }
 
 void
-Ip::Address::InitAddrInfo(struct addrinfo *&ai)
+Ip::Address::InitAddr(struct addrinfo *&ai)
 {
     if (ai == NULL) {
         ai = new addrinfo;
@@ -667,7 +667,7 @@ Ip::Address::InitAddrInfo(struct addrinfo *&ai)
 }
 
 void
-Ip::Address::FreeAddrInfo(struct addrinfo *&ai)
+Ip::Address::FreeAddr(struct addrinfo *&ai)
 {
     if (ai == NULL) return;
 
@@ -256,13 +256,13 @@ class Address
      *  Get RFC 3493 addrinfo structure from the Ip::Address data
      *  for protocol-neutral socket operations.
      *  Should be passed a NULL pointer of type struct addrinfo* it will
-     *  allocate memory for the structures involved. (see FreeAddrInfo to clear).
+     *  allocate memory for the structures involved. (see FreeAddr() to clear).
      *  Defaults to a TCP streaming socket, if other values (such as UDP) are needed
      *  the caller MUST override these default settings.
      *  Some situations may also require an actual call to the system getaddrinfo()
      *  to pull relevant OS details for the socket.
      \par
-     *  Ip::Address allocated objects MUST be destructed by Ip::Address::FreeAddrInfo
+     *  Ip::Address allocated objects MUST be destructed by Ip::Address::FreeAddr
      *  System getaddrinfo() allocated objects MUST be freed with system freeaddrinfo()
      *
      \param ai structure to be filled out.
@@ -273,15 +273,15 @@ class Address
     /**
      *  Equivalent to the sysem call freeaddrinfo() but for Ip::Address allocated data
      */
-    static void FreeAddrInfo(struct addrinfo *&ai);
+    static void FreeAddr(struct addrinfo *&ai);
 
     /**
      *  Initializes an empty addrinfo properly for use.
      *  It is intended for use in cases such as getsockopt() where the addrinfo is
      *  about to be changed and the stored details may not match the new ones coming.
      \param ai addrinfo struct to be initialized as AF_UNSPEC with large address buffer
      */
-    static void InitAddrInfo(struct addrinfo *&ai);
+    static void InitAddr(struct addrinfo *&ai);
 
     /**
      *  Lookup a Host by Name. Equivalent to system call gethostbyname(char*)
@@ -11,6 +11,7 @@
 #include "acl/Gadgets.h"
 #include "cache_cf.h"
 #include "comm/Connection.h"
+#include "compat/cmsg.h"
 #include "ConfigParser.h"
 #include "fde.h"
 #include "globals.h"
@@ -44,7 +45,7 @@ Ip::Qos::getTosFromServer(const Comm::ConnectionPointer &server, fde *clientFde)
                     break;
 
                 if (o->cmsg_level == SOL_IP && o->cmsg_type == IP_TOS) {
-                    int *tmp = (int*)CMSG_DATA(o);
+                    int *tmp = (int*)SQUID_CMSG_DATA(o);
                     clientFde->tosFromServer = (tos_t)*tmp;
                     break;
                 }
@@ -713,7 +713,7 @@ testIpAddress::testAddrInfo()
     CPPUNIT_ASSERT( memcmp( expect->ai_addr, ipval->ai_addr, expect->ai_addrlen ) == 0 );
 
     freeaddrinfo(expect);
-    Ip::Address::FreeAddrInfo(ipval);
+    Ip::Address::FreeAddr(ipval);
 }
 
 void
@@ -183,10 +183,10 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     debugs(54, 3, "ipcCreate: cwfd FD " << cwfd);
 
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
-        Ip::Address::InitAddrInfo(AI);
+        Ip::Address::InitAddr(AI);
 
         if (getsockname(pwfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
-            Ip::Address::FreeAddrInfo(AI);
+            Ip::Address::FreeAddr(AI);
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
@@ -195,19 +195,19 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 
         debugs(54, 3, "ipcCreate: FD " << pwfd << " sockaddr " << PaS);
 
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
 
-        Ip::Address::InitAddrInfo(AI);
+        Ip::Address::InitAddr(AI);
 
         if (getsockname(crfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
-            Ip::Address::FreeAddrInfo(AI);
+            Ip::Address::FreeAddr(AI);
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         ChS = *AI;
 
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
 
         debugs(54, 3, "ipcCreate: FD " << crfd << " sockaddr " << ChS );
 
@@ -152,7 +152,7 @@ void Ipc::SharedListenJoined(const SharedListenResponse &response)
         AI->ai_socktype = p.sock_type;
         AI->ai_protocol = p.proto;
         comm_import_opened(cbd->conn, FdNote(p.fdNote), AI);
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
     }
 
     cbd->errNo = response.errNo;
@@ -195,7 +195,7 @@ Ipc::TypedMsgHdr::putFd(int fd)
     cmsg->cmsg_type = SCM_RIGHTS;
     cmsg->cmsg_len = CMSG_LEN(sizeof(int) * fdCount);
 
-    int *fdStore = reinterpret_cast<int*>(CMSG_DATA(cmsg));
+    int *fdStore = reinterpret_cast<int*>(SQUID_CMSG_DATA(cmsg));
     memcpy(fdStore, &fd, fdCount * sizeof(int));
     msg_controllen = cmsg->cmsg_len;
 
@@ -213,7 +213,7 @@ Ipc::TypedMsgHdr::getFd() const
     Must(cmsg->cmsg_type == SCM_RIGHTS);
 
     const int fdCount = 1;
-    const int *fdStore = reinterpret_cast<const int*>(CMSG_DATA(cmsg));
+    const int *fdStore = reinterpret_cast<const int*>(SQUID_CMSG_DATA(cmsg));
     int fd = -1;
     memcpy(&fd, fdStore, fdCount * sizeof(int));
     return fd;
@@ -202,7 +202,7 @@ Ipc::ImportFdIntoComm(const Comm::ConnectionPointer &conn, int socktype, int pro
         addr_info->ai_socktype = socktype;
         addr_info->ai_protocol = protocol;
         comm_import_opened(conn, Ipc::FdNote(noteId), addr_info);
-        Ip::Address::FreeAddrInfo(addr_info);
+        Ip::Address::FreeAddr(addr_info);
     } else {
         debugs(54, DBG_CRITICAL, "ERROR: Ipc::ImportFdIntoComm: " << conn << ' ' << xstrerror());
         conn->close();
@@ -17,10 +17,18 @@
 #include "SBuf.h"
 #include "tools.h"
 
+#if HAVE_FCNTL_H
 #include <fcntl.h>
+#endif
+#if HAVE_SYS_MMAN_H
 #include <sys/mman.h>
+#endif
+#if HAVE_SYS_STAT_H
 #include <sys/stat.h>
+#endif
+#if HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 
 // test cases change this
 const char *Ipc::Mem::Segment::BasePath = DEFAULT_STATEDIR;
@@ -11,8 +11,10 @@
 #include "squid.h"
 #include "cache_cf.h"
 #include "comm.h"
+#include "comm/Connection.h"
 #include "fd.h"
 #include "fde.h"
+#include "globals.h"
 #include "ip/Address.h"
 #include "rfc1738.h"
 #include "SquidConfig.h"
@@ -21,7 +23,7 @@
 #include "tools.h"
 
 #include <cerrno>
-#ifndef _MSWSOCK_
+#if HAVE_MSWSOCK_H
 #include <mswsock.h>
 #endif
 #include <process.h>
@@ -178,30 +180,30 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 // AYJ: these flags should be neutral, but if not IPv6 version needs adding
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
 
-        Ip::Address::InitAddrInfo(aiPS);
+        Ip::Address::InitAddr(aiPS);
 
         if (getsockname(pwfd, aiPS->ai_addr, &(aiPS->ai_addrlen) ) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
-            Ip::Address::FreeAddrInfo(aiPS);
+            Ip::Address::FreeAddr(aiPS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         tmp_addr = *aiPS;
-        Ip::Address::FreeAddrInfo(aiPS);
+        Ip::Address::FreeAddr(aiPS);
 
         debugs(54, 3, "ipcCreate: FD " << pwfd << " sockaddr " << tmp_addr );
 
-        Ip::Address::InitAddrInfo(aiCS);
+        Ip::Address::InitAddr(aiCS);
 
         if (getsockname(crfd, aiCS->ai_addr, &(aiCS->ai_addrlen) ) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
-            Ip::Address::FreeAddrInfo(aiCS);
+            Ip::Address::FreeAddr(aiCS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         tmp_addr.setEmpty();
         tmp_addr = *aiCS;
-        Ip::Address::FreeAddrInfo(aiCS);
+        Ip::Address::FreeAddr(aiCS);
 
         debugs(54, 3, "ipcCreate: FD " << crfd << " sockaddr " << tmp_addr );
     }
@@ -375,7 +377,8 @@ ipc_thread_1(void *in_params)
     Ip::Address PS = params->PS;
     Ip::Address local_addr = params->local_addr;
 
-    buf1 = (char *)xcalloc(1, 8192);
+    const size_t bufSz = 8192;
+    buf1 = (char *)xcalloc(1, bufSz);
     strcpy(buf1, params->prog);
     prog = strtok(buf1, w_space);
 
@@ -397,7 +400,7 @@ ipc_thread_1(void *in_params)
 
         debugs(54, 3, "ipcCreate: CHILD accepted new FD " << fd);
         comm_close(crfd);
-        snprintf(buf1, 8191, "%s CHILD socket", prog);
+        snprintf(buf1, bufSz-1, "%s CHILD socket", prog);
         fd_open(fd, FD_SOCKET, buf1);
         fd_table[fd].flags.ipc = 1;
         cwfd = crfd = fd;
@@ -415,8 +418,8 @@ ipc_thread_1(void *in_params)
     }
 
     PutEnvironment();
-    memset(buf1, '\0', sizeof(buf1));
-    x = recv(crfd, (void *)buf1, 8191, 0);
+    memset(buf1, '\0', bufSz);
+    x = recv(crfd, (void *)buf1, bufSz-1, 0);
 
     if (x < 0) {
         debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: OK read test failed");
@@ -443,7 +446,7 @@ ipc_thread_1(void *in_params)
     }
 
     if (type == IPC_UDP_SOCKET) {
-        snprintf(buf1, 8192, "%s(%ld) <-> ipc CHILD socket", prog, -1L);
+        snprintf(buf1, bufSz, "%s(%ld) <-> ipc CHILD socket", prog, -1L);
         crfd_ipc = cwfd_ipc = comm_open(SOCK_DGRAM, IPPROTO_UDP, local_addr, 0, buf1);
 
         if (crfd_ipc < 0) {
@@ -452,7 +455,7 @@ ipc_thread_1(void *in_params)
             goto cleanup;
         }
 
-        snprintf(buf1, 8192, "%s(%ld) <-> ipc PARENT socket", prog, -1L);
+        snprintf(buf1, bufSz, "%s(%ld) <-> ipc PARENT socket", prog, -1L);
         prfd_ipc = pwfd_ipc = comm_open(SOCK_DGRAM, IPPROTO_UDP, local_addr, 0, buf1);
 
         if (pwfd_ipc < 0) {
@@ -461,31 +464,31 @@ ipc_thread_1(void *in_params)
             goto cleanup;
         }
 
-        Ip::Address::InitAddrInfo(aiPS_ipc);
+        Ip::Address::InitAddr(aiPS_ipc);
 
         if (getsockname(pwfd_ipc, aiPS_ipc->ai_addr, &(aiPS_ipc->ai_addrlen)) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             ipcSend(cwfd, err_string, strlen(err_string));
-            Ip::Address::FreeAddrInfo(aiPS_ipc);
+            Ip::Address::FreeAddr(aiPS_ipc);
             goto cleanup;
         }
 
         PS_ipc = *aiPS_ipc;
-        Ip::Address::FreeAddrInfo(aiPS_ipc);
+        Ip::Address::FreeAddr(aiPS_ipc);
 
         debugs(54, 3, "ipcCreate: FD " << pwfd_ipc << " sockaddr " << PS_ipc);
 
-        Ip::Address::InitAddrInfo(aiCS_ipc);
+        Ip::Address::InitAddr(aiCS_ipc);
 
         if (getsockname(crfd_ipc, aiCS_ipc->ai_addr, &(aiCS_ipc->ai_addrlen)) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             ipcSend(cwfd, err_string, strlen(err_string));
-            Ip::Address::FreeAddrInfo(aiCS_ipc);
+            Ip::Address::FreeAddr(aiCS_ipc);
             goto cleanup;
         }
 
         CS_ipc = *aiCS_ipc;
-        Ip::Address::FreeAddrInfo(aiCS_ipc);
+        Ip::Address::FreeAddr(aiCS_ipc);
 
         debugs(54, 3, "ipcCreate: FD " << crfd_ipc << " sockaddr " << CS_ipc);
 
@@ -603,7 +606,7 @@ ipc_thread_1(void *in_params)
             goto cleanup;
         }
 
-        x = read(p2c[0], buf1, 8192);
+        x = read(p2c[0], buf1, bufSz-1);
 
         if (x < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: read FD " << p2c[0] << ": " << xstrerror());
@@ -630,7 +633,7 @@ ipc_thread_1(void *in_params)
             goto cleanup;
         }
 
-        x = read(p2c[0], buf1, 8192);
+        x = read(p2c[0], buf1, bufSz-1);
 
         if (x < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: read FD " << p2c[0] << ": " << xstrerror());
@@ -648,19 +651,19 @@ ipc_thread_1(void *in_params)
         }
 
         x = send(pwfd_ipc, (const void *)ok_string, strlen(ok_string), 0);
-        x = recv(prfd_ipc, (void *)(buf1 + 200), 8191 - 200, 0);
+        x = recv(prfd_ipc, (void *)(buf1 + 200), bufSz -1 - 200, 0);
         assert((size_t) x == strlen(ok_string)
                && !strncmp(ok_string, buf1 + 200, strlen(ok_string)));
     }				/* IPC_UDP_SOCKET */
 
-    snprintf(buf1, 8191, "%s(%ld) CHILD socket", prog, (long int) pid);
+    snprintf(buf1, bufSz-1, "%s(%ld) CHILD socket", prog, (long int) pid);
 
     fd_note(fd, buf1);
 
     if (prfd_ipc != -1) {
-        snprintf(buf1, 8191, "%s(%ld) <-> ipc CHILD socket", prog, (long int) pid);
+        snprintf(buf1, bufSz-1, "%s(%ld) <-> ipc CHILD socket", prog, (long int) pid);
         fd_note(crfd_ipc, buf1);
-        snprintf(buf1, 8191, "%s(%ld) <-> ipc PARENT socket", prog, (long int) pid);
+        snprintf(buf1, bufSz-1, "%s(%ld) <-> ipc PARENT socket", prog, (long int) pid);
         fd_note(prfd_ipc, buf1);
     }
 
@@ -686,7 +689,7 @@ ipc_thread_1(void *in_params)
         goto cleanup;
     }
 
-    snprintf(buf1, 8191, "%ld\n", (long int) pid);
+    snprintf(buf1, bufSz-1, "%ld\n", (long int) pid);
 
     if (-1 == ipcSend(cwfd, buf1, strlen(buf1)))
         goto cleanup;
@@ -695,7 +698,7 @@ ipc_thread_1(void *in_params)
 
     /* cycle */
     for (;;) {
-        x = recv(crfd, (void *)buf1, 8192, 0);
+        x = recv(crfd, (void *)buf1, bufSz-1, 0);
 
         if (x <= 0) {
             debugs(54, 3, "ipc(" << prog << "," << pid << "): " << x << " bytes received from parent. Exiting...");
@@ -763,11 +766,8 @@ ipc_thread_1(void *in_params)
     if (!retval)
         debugs(54, 2, "ipc(" << prog << "," << pid << "): normal exit");
 
-    if (buf1)
-        xfree(buf1);
-
-    if (prog)
-        xfree(prog);
+    xfree(buf1);
+    xfree(prog);
 
     if (thread)
         CloseHandle(thread);
@@ -792,13 +792,14 @@ ipc_thread_2(void *in_params)
     int send_fd = params->send_fd;
     char *prog = xstrdup(params->prog);
     pid_t pid = params->pid;
-    char *buf2 = (char *)xcalloc(1, 8192);
+    const size_t bufSz = 8192;
+    char *buf2 = (char *)xcalloc(1, bufSz);
 
     for (;;) {
         if (type == IPC_TCP_SOCKET)
-            x = read(rfd, buf2, 8192);
+            x = read(rfd, buf2, bufSz-1);
         else
-            x = recv(rfd, (void *)buf2, 8192, 0);
+            x = recv(rfd, (void *)buf2, bufSz-1, 0);
 
         if ((x <= 0 && type == IPC_TCP_SOCKET) ||
                 (x < 0 && type == IPC_UDP_SOCKET)) {
@@ -811,7 +812,6 @@ ipc_thread_2(void *in_params)
 
         if (type == IPC_UDP_SOCKET && !strcmp(buf2, shutdown_string)) {
             debugs(54, 3, "ipc(" << prog << "," << pid << "): request for shutdown received. Exiting...");
-
             break;
         }
 
@@ -620,13 +620,12 @@ shut_down(int sig)
 {
     do_shutdown = sig == SIGINT ? -1 : 1;
     ShutdownSignal = sig;
-#ifdef SIGTTIN
-
+#if defined(SIGTTIN)
     if (SIGTTIN == sig)
         shutdown_status = 1;
-
 #endif
 
+#if !_SQUID_WINDOWS_
     const pid_t ppid = getppid();
 
     if (!IamMasterProcess() && ppid > 1) {
@@ -636,17 +635,15 @@ shut_down(int sig)
                    " pid " << ppid << ": " << xstrerror());
     }
 
-#if !_SQUID_WINDOWS_
 #if KILL_PARENT_OPT
-
     if (!IamMasterProcess() && ppid > 1) {
         debugs(1, DBG_IMPORTANT, "Killing master process, pid " << ppid);
 
         if (kill(ppid, sig) < 0)
             debugs(1, DBG_IMPORTANT, "kill " << ppid << ": " << xstrerror());
     }
-
 #endif /* KILL_PARENT_OPT */
+
 #if SA_RESETHAND == 0
     signal(SIGTERM, SIG_DFL);
 
@@ -1212,19 +1209,29 @@ int SquidMain(int argc, char **argv);
 static int SquidMainSafe(int argc, char **argv);
 
 #if USE_WIN32_SERVICE
-/* When USE_WIN32_SERVICE is defined, the main function is placed in win32.cc */
+/* Entry point for Windows services */
 extern "C" void WINAPI
 SquidWinSvcMain(int argc, char **argv)
 {
     SquidMainSafe(argc, argv);
 }
-#else
+#endif
+
 int
 main(int argc, char **argv)
 {
+#if USE_WIN32_SERVICE
+    SetErrorMode(SEM_NOGPFAULTERRORBOX);
+    if ((argc == 2) && strstr(argv[1], _WIN_SQUID_SERVICE_OPTION))
+        return WIN32_StartService(argc, argv);
+    else {
+        WIN32_run_mode = _WIN_SQUID_RUN_MODE_INTERACTIVE;
+        opt_no_daemon = 1;
+    }
+#endif
+
     return SquidMainSafe(argc, argv);
 }
-#endif
 
 static int
 SquidMainSafe(int argc, char **argv)
@@ -17,7 +17,7 @@
 namespace Mgr
 {
 
-/// store server-side network read() size histograms
+/// store size histograms of network read() from peer server
 class IoActionData
 {
 public:
@@ -62,13 +62,13 @@ extern "C" {
 #define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
 #endif
 
-#if !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERR_MESSAGE
+#if !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERROR_MESSAGE
 #define error_message(code) krb5_get_error_message(kparam.context,code)
-#elif !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERROR_TEXT
+#elif !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERR_TEXT
 #define error_message(code) krb5_get_err_text(kparam.context,code)
 #elif !HAVE_ERROR_MESSAGE
     static char err_code[17];
-    const char *KRB5_CALLCONV
+    const char *KRB5_CALLCONV 
     error_message(long code) {
         snprintf(err_code,16,"%ld",code);
         return err_code;
@@ -17,6 +17,8 @@
 #include "fde.h"
 #include "format/Format.h"
 #include "globals.h"
+#include "helper.h"
+#include "helper/Reply.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "redirect.h"
@@ -74,7 +76,7 @@ RedirectStateData::~RedirectStateData()
 }
 
 static void
-redirectHandleReply(void *data, const HelperReply &reply)
+redirectHandleReply(void *data, const Helper::Reply &reply)
 {
     RedirectStateData *r = static_cast<RedirectStateData *>(data);
     debugs(61, 5, HERE << "reply=" << reply);
@@ -83,7 +85,7 @@ redirectHandleReply(void *data, const HelperReply &reply)
     // and to map the old helper response format(s) into new format result code and key=value pairs
     // it can be removed when the helpers are all updated to the normalized "OK/ERR kv-pairs" format
 
-    if (reply.result == HelperReply::Unknown) {
+    if (reply.result == Helper::Unknown) {
         // BACKWARD COMPATIBILITY 2012-06-15:
         // Some nasty old helpers send back the entire input line including extra format keys.
         // This is especially bad for simple perl search-replace filter scripts.
@@ -111,12 +113,12 @@ redirectHandleReply(void *data, const HelperReply &reply)
                  */
                 char * result = reply.modifiableOther().content();
 
-                HelperReply newReply;
+                Helper::Reply newReply;
                 // BACKWARD COMPATIBILITY 2012-06-15:
-                // We got HelperReply::Unknown reply result but new
-                // RedirectStateData handlers require HelperReply::Okay,
+                // We got Helper::Unknown reply result but new
+                // RedirectStateData handlers require Helper::Okay,
                 // else will drop the helper reply
-                newReply.result = HelperReply::Okay;
+                newReply.result = Helper::Okay;
                 newReply.notes.append(&reply.notes);
 
                 // check and parse for obsoleted Squid-2 urlgroup feature
@@ -175,7 +177,7 @@ redirectHandleReply(void *data, const HelperReply &reply)
 }
 
 static void
-storeIdHandleReply(void *data, const HelperReply &reply)
+storeIdHandleReply(void *data, const Helper::Reply &reply)
 {
     RedirectStateData *r = static_cast<RedirectStateData *>(data);
     debugs(61, 5,"StoreId helper: reply=" << reply);
@@ -292,8 +294,8 @@ redirectStart(ClientHttpRequest * http, HLPCB * handler, void *data)
     if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
         /* Skip redirector if there is one request queued */
         ++redirectorBypassed;
-        HelperReply bypassReply;
-        bypassReply.result = HelperReply::Okay;
+        Helper::Reply bypassReply;
+        bypassReply.result = Helper::Okay;
         bypassReply.notes.add("message","URL rewrite/redirect queue too long. Bypassed.");
         handler(data, bypassReply);
         return;
@@ -316,9 +318,9 @@ storeIdStart(ClientHttpRequest * http, HLPCB * handler, void *data)
     if (Config.onoff.store_id_bypass && storeIds->stats.queue_size) {
         /* Skip StoreID Helper if there is one request queued */
         ++storeIdBypassed;
-        HelperReply bypassReply;
+        Helper::Reply bypassReply;
 
-        bypassReply.result = HelperReply::Okay;
+        bypassReply.result = Helper::Okay;
 
         bypassReply.notes.add("message","StoreId helper queue too long. Bypassed.");
         handler(data, bypassReply);
@@ -63,6 +63,7 @@ Ftp::Server::Server(const MasterXaction::Pointer &xact):
         reader()
 {
     flags.readMore = false; // we need to announce ourselves first
+    *uploadBuf = 0;
 }
 
 Ftp::Server::~Server()
@@ -604,6 +605,7 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
     clientStreamNode *node = context->getClientReplyContext();
     Must(node);
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+    Must(repContext);
 
     // We cannot relay FTP scode/reason via HTTP-specific ErrorState.
     // TODO: When/if ErrorState can handle native FTP errors, use it instead.
@@ -9,7 +9,7 @@
 #ifndef SQUID_SSL_CONFIG_H
 #define SQUID_SSL_CONFIG_H
 
-#include "HelperChildConfig.h"
+#include "helper/ChildConfig.h"
 
 namespace Ssl
 {
@@ -20,10 +20,10 @@ class Config
 #if USE_SSL_CRTD
     char *ssl_crtd; ///< Name of external ssl_crtd application.
     /// The number of processes spawn for ssl_crtd.
-    HelperChildConfig ssl_crtdChildren;
+    ::Helper::ChildConfig ssl_crtdChildren;
 #endif
     char *ssl_crt_validator;
-    HelperChildConfig ssl_crt_validator_Children;
+    ::Helper::ChildConfig ssl_crt_validator_Children;
     Config();
     ~Config();
 private:
@@ -17,6 +17,7 @@
 #include "errorpage.h"
 #include "fde.h"
 #include "globals.h"
+#include "helper/ResultCode.h"
 #include "HttpRequest.h"
 #include "neighbors.h"
 #include "SquidConfig.h"
@@ -286,14 +287,14 @@ Ssl::PeerConnector::negotiateSsl()
 void switchToTunnel(HttpRequest *request, int *status_ptr, Comm::ConnectionPointer & clientConn, Comm::ConnectionPointer &srvConn);
 
 void
-Ssl::PeerConnector::cbCheckForPeekAndSplice(allow_t answer, void *data)
+Ssl::PeerConnector::cbCheckForPeekAndSpliceDone(allow_t answer, void *data)
 {
     Ssl::PeerConnector *peerConnect = (Ssl::PeerConnector *) data;
-    peerConnect->checkForPeekAndSplice(true, (Ssl::BumpMode)answer.kind);
+    peerConnect->checkForPeekAndSpliceDone((Ssl::BumpMode)answer.kind);
 }
 
-bool
-Ssl::PeerConnector::checkForPeekAndSplice(bool checkDone, Ssl::BumpMode peekMode)
+void
+Ssl::PeerConnector::checkForPeekAndSplice()
 {
     SSL *ssl = fd_table[serverConn->fd].ssl;
     // Mark Step3 of bumping
@@ -305,44 +306,50 @@ Ssl::PeerConnector::checkForPeekAndSplice(bool checkDone, Ssl::BumpMode peekMode
         }
     }
 
-    if (!checkDone) {
-        ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(
-            ::Config.accessList.ssl_bump,
-            request.getRaw(), NULL);
-        acl_checklist->nonBlockingCheck(Ssl::PeerConnector::cbCheckForPeekAndSplice, this);
-        return false;
-    }
+    ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(
+        ::Config.accessList.ssl_bump,
+        request.getRaw(), NULL);
+    acl_checklist->nonBlockingCheck(Ssl::PeerConnector::cbCheckForPeekAndSpliceDone, this);
+}
 
+void
+Ssl::PeerConnector::checkForPeekAndSpliceDone(Ssl::BumpMode const action)
+{
+    SSL *ssl = fd_table[serverConn->fd].ssl;
     BIO *b = SSL_get_rbio(ssl);
     Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
     debugs(83,5, "Will check for peek and splice on FD " << serverConn->fd);
 
-    // bump, peek, stare, server-first,client-first are all mean bump the connection
-    if (peekMode < Ssl::bumpSplice)
-        peekMode = Ssl::bumpBump;
+    Ssl::BumpMode finalAction = action;
+    // adjust the final bumping mode if needed
+    if (finalAction < Ssl::bumpSplice)
+        finalAction = Ssl::bumpBump;
+
+    if (finalAction == Ssl::bumpSplice && !srvBio->canSplice())
+        finalAction = Ssl::bumpBump;
+    else if (finalAction == Ssl::bumpBump && !srvBio->canBump())
+        finalAction = Ssl::bumpSplice;
 
-    if (peekMode == Ssl::bumpSplice && !srvBio->canSplice())
-        peekMode = Ssl::bumpPeek;
-    else if (peekMode == Ssl::bumpBump && !srvBio->canBump())
-        peekMode = Ssl::bumpSplice;
+    // Record final decision
+    if (request->clientConnectionManager.valid()) {
+        request->clientConnectionManager->sslBumpMode = finalAction;
+        request->clientConnectionManager->serverBump()->act.step3 = finalAction;
+    }
 
-    if (peekMode == Ssl::bumpTerminate) {
+    if (finalAction == Ssl::bumpTerminate) {
         comm_close(serverConn->fd);
         comm_close(clientConn->fd);
-    } else if (peekMode != Ssl::bumpSplice) {
+    } else if (finalAction != Ssl::bumpSplice) {
         //Allow write, proceed with the connection
         srvBio->holdWrite(false);
         srvBio->recordInput(false);
         Comm::SetSelect(serverConn->fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
         debugs(83,5, "Retry the fwdNegotiateSSL on FD " << serverConn->fd);
-        return true;
     } else {
         static int status_code = 0;
         debugs(83,5, "Revert to tunnel FD " << clientConn->fd << " with FD " << serverConn->fd);
         switchToTunnel(request.getRaw(), &status_code, clientConn, serverConn);
-        return false;
     }
-    return false;
 }
 
 void
@@ -364,9 +371,9 @@ Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse const &valid
 
     debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
 
-    if (validationResponse.resultCode == HelperReply::Error)
+    if (validationResponse.resultCode == ::Helper::Error)
         errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
-    else if (validationResponse.resultCode != HelperReply::Okay)
+    else if (validationResponse.resultCode != ::Helper::Okay)
         validatorFailed = true;
 
     if (!errDetails && !validatorFailed) {
@@ -495,7 +502,7 @@ Ssl::PeerConnector::handleNegotiateError(const int ret)
     case SSL_ERROR_WANT_WRITE:
         if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
             debugs(81, DBG_IMPORTANT, "hold write on SSL connection on FD " << fd);
-            checkForPeekAndSplice(false, Ssl::bumpNone);
+            checkForPeekAndSplice();
             return;
         }
         Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
@@ -513,7 +520,7 @@ Ssl::PeerConnector::handleNegotiateError(const int ret)
 #if 1
         if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
             debugs(81, 3, "Error ("  << ERR_error_string(ssl_lib_error, NULL) <<  ") but, hold write on SSL connection on FD " << fd);
-            checkForPeekAndSplice(false, Ssl::bumpNone);
+            checkForPeekAndSplice();
             return;
         }
 #endif
@@ -116,7 +116,13 @@ class PeerConnector: virtual public AsyncJob
     /// It is called multiple times untill the negotiation finish or aborted.
     void negotiateSsl();
 
-    bool checkForPeekAndSplice(bool, Ssl::BumpMode);
+    /// Initiates the ssl_bump acl check in step3 SSL bump step to decide
+    /// about bumping, splicing or terminating the connection.
+    void checkForPeekAndSplice();
+
+    /// Callback function for ssl_bump acl check in step3  SSL bump step.
+    /// Handles the final bumping decision.
+    void checkForPeekAndSpliceDone(Ssl::BumpMode const);
 
     /// Called when the SSL negotiation step aborted because data needs to
     /// be transferred to/from SSL server or on error. In the first case
@@ -149,8 +155,8 @@ class PeerConnector: virtual public AsyncJob
     /// A wrapper function for negotiateSsl for use with Comm::SetSelect
     static void NegotiateSsl(int fd, void *data);
 
-    /// A wrapper function for checkForPeekAndSplice for use with acl
-    static void cbCheckForPeekAndSplice(allow_t answer, void *data);
+    /// A wrapper function for checkForPeekAndSpliceDone for use with acl
+    static void cbCheckForPeekAndSpliceDone(allow_t answer, void *data);
 
     HttpRequestPointer request; ///< peer connection trigger or cause
     Comm::ConnectionPointer serverConn; ///< TCP connection to the peer
@@ -22,10 +22,12 @@ CBDATA_NAMESPACED_CLASS_INIT(Ssl, ServerBump);
 Ssl::ServerBump::ServerBump(HttpRequest *fakeRequest, StoreEntry *e, Ssl::BumpMode md):
         request(fakeRequest),
         sslErrors(NULL),
-        mode(md),
         step(bumpStep1)
 {
     debugs(33, 4, HERE << "will peek at " << request->GetHost() << ':' << request->port);
+    act.step1 = md;
+    act.step2 = act.step3 = Ssl::bumpNone;
+
     const char *uri = urlCanonical(request.getRaw());
     if (e) {
         entry = e;
@@ -31,13 +31,17 @@ class ServerBump
     explicit ServerBump(HttpRequest *fakeRequest, StoreEntry *e = NULL, Ssl::BumpMode mode = Ssl::bumpServerFirst);
     ~ServerBump();
 
-    /// faked, minimal request; required by server-side API
+    /// faked, minimal request; required by Client API
     HttpRequest::Pointer request;
     StoreEntry *entry; ///< for receiving Squid-generated error messages
     Ssl::X509_Pointer serverCert; ///< HTTPS server certificate
     Ssl::CertErrors *sslErrors; ///< SSL [certificate validation] errors
-    Ssl::BumpMode mode; ///< The SSL server bump mode
-    Ssl::BumpStep step; ///< The SSL server bumping step
+    struct {
+        Ssl::BumpMode step1; ///< The SSL bump mode at step1
+        Ssl::BumpMode step2; ///< The SSL bump mode at step2
+        Ssl::BumpMode step3; ///< The SSL bump mode at step3
+    } act; ///< bumping actions at various bumping steps
+    Ssl::BumpStep step; ///< The SSL bumping step
     SBuf clientSni; ///< the SSL client SNI name
 
 private:
@@ -203,8 +203,8 @@ Ssl::ClientBio::read(char *buf, int size, BIO *table)
             return 0;
 
         int bytes = Ssl::Bio::read(buf, size, table);
-        if (!bytes)
-            return 0;
+        if (bytes <= 0)
+            return bytes;
         rbuf.append(buf, bytes);
         debugs(83, 7, "rbuf size: " << rbuf.contentSize());
     }
@@ -21,6 +21,12 @@ Ssl::CertValidationMsg::composeRequest(CertValidationRequest const &vcert)
     body += Ssl::CertValidationMsg::param_host + "=" + vcert.domainName;
     STACK_OF(X509) *peerCerts = static_cast<STACK_OF(X509) *>(SSL_get_ex_data(vcert.ssl, ssl_ex_index_ssl_cert_chain));
 
+    if (const char *sslVersion = SSL_get_version(vcert.ssl))
+        body += "\n" +  Ssl::CertValidationMsg::param_proto_version + "=" + sslVersion;
+
+    if (const char *cipherName = SSL_CIPHER_get_name(SSL_get_current_cipher(vcert.ssl)))
+        body += "\n" +  Ssl::CertValidationMsg::param_cipher + "=" + cipherName;
+
     if (!peerCerts)
         peerCerts = SSL_get_peer_cert_chain(vcert.ssl);
 
@@ -231,4 +237,5 @@ const std::string Ssl::CertValidationMsg::param_cert("cert_");
 const std::string Ssl::CertValidationMsg::param_error_name("error_name_");
 const std::string Ssl::CertValidationMsg::param_error_reason("error_reason_");
 const std::string Ssl::CertValidationMsg::param_error_cert("error_cert_");
-
+const std::string Ssl::CertValidationMsg::param_proto_version("proto_version");
+const std::string Ssl::CertValidationMsg::param_cipher("cipher");
@@ -9,7 +9,7 @@
 #ifndef SQUID_SSL_CERT_VALIDATE_MESSAGE_H
 #define SQUID_SSL_CERT_VALIDATE_MESSAGE_H
 
-#include "HelperReply.h"
+#include "helper/ResultCode.h"
 #include "ssl/crtd_message.h"
 #include "ssl/support.h"
 
@@ -61,7 +61,7 @@ class CertValidationResponse
     /// If none found a new RecvdError item added with the given id;
     RecvdError &getError(int errorId);
     RecvdErrors errors; ///< The list of parsed errors
-    HelperReply::Result_ resultCode; ///< The helper result code
+    Helper::ResultCode resultCode; ///< The helper result code
 };
 
 /**
@@ -113,6 +113,10 @@ class CertValidationMsg : public CrtdMessage
     static const std::string param_error_reason;
     /// Parameter name for passing the error cert ID
     static const std::string param_error_cert;
+    /// Parameter name for SSL version
+    static const std::string param_proto_version;
+    /// Parameter name for SSL cipher
+    static const std::string param_cipher;
 };
 
 }//namespace Ssl
@@ -8,6 +8,8 @@
 
 #include "squid.h"
 #include "anyp/PortCfg.h"
+#include "../helper.h"
+#include "helper/Reply.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
@@ -105,8 +107,8 @@ void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void
         if (squid_curtime - first_warn > 3 * 60)
             fatal("SSL servers not responding for 3 minutes");
         debugs(34, DBG_IMPORTANT, HERE << "Queue overload, rejecting");
-        HelperReply failReply;
-        failReply.result = HelperReply::BrokenHelper;
+        ::Helper::Reply failReply;
+        failReply.result = ::Helper::BrokenHelper;
         failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
         callback(data, failReply);
         return;
@@ -212,29 +214,29 @@ struct submitData {
 CBDATA_CLASS_INIT(submitData);
 
 static void
-sslCrtvdHandleReplyWrapper(void *data, const HelperReply &reply)
+sslCrtvdHandleReplyWrapper(void *data, const ::Helper::Reply &reply)
 {
     Ssl::CertValidationMsg replyMsg(Ssl::CrtdMessage::REPLY);
     Ssl::CertValidationResponse *validationResponse = new Ssl::CertValidationResponse;
     std::string error;
 
     submitData *crtdvdData = static_cast<submitData *>(data);
     STACK_OF(X509) *peerCerts = SSL_get_peer_cert_chain(crtdvdData->ssl);
-    if (reply.result == HelperReply::BrokenHelper) {
+    if (reply.result == ::Helper::BrokenHelper) {
         debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper error response: " << reply.other().content());
-        validationResponse->resultCode = HelperReply::BrokenHelper;
+        validationResponse->resultCode = ::Helper::BrokenHelper;
     } else if (replyMsg.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK ||
                !replyMsg.parseResponse(*validationResponse, peerCerts, error) ) {
         debugs(83, DBG_IMPORTANT, "WARNING: Reply from ssl_crtvd for " << " is incorrect");
         debugs(83, DBG_IMPORTANT, "Certificate cannot be validated. ssl_crtvd response: " << replyMsg.getBody());
-        validationResponse->resultCode = HelperReply::BrokenHelper;
+        validationResponse->resultCode = ::Helper::BrokenHelper;
     } else
         validationResponse->resultCode = reply.result;
 
     crtdvdData->callback(crtdvdData->data, *validationResponse);
 
     if (Ssl::CertValidationHelper::HelperCache &&
-            (validationResponse->resultCode == HelperReply::Okay || validationResponse->resultCode == HelperReply::Error)) {
+            (validationResponse->resultCode == ::Helper::Okay || validationResponse->resultCode == ::Helper::Error)) {
         Ssl::CertValidationHelper::HelperCache->add(crtdvdData->query.c_str(), validationResponse);
     } else
         delete validationResponse;
@@ -256,7 +258,7 @@ void Ssl::CertValidationHelper::sslSubmit(Ssl::CertValidationRequest const &requ
             fatal("ssl_crtvd queue being overloaded for long time");
         debugs(83, DBG_IMPORTANT, "WARNING: ssl_crtvd queue overload, rejecting");
         Ssl::CertValidationResponse resp;
-        resp.resultCode = HelperReply::BrokenHelper;
+        resp.resultCode = ::Helper::BrokenHelper;
         callback(data, resp);
         return;
     }
@@ -9,8 +9,8 @@
 #ifndef SQUID_SSL_HELPER_H
 #define SQUID_SSL_HELPER_H
 
-#include "../helper.h"
 #include "base/LruMap.h"
+#include "helper/forward.h"
 #include "ssl/cert_validate_message.h"
 #include "ssl/crtd_message.h"
 
@@ -604,7 +604,7 @@ DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
 #if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
         storeAppendPrintf(sentry,"\nRunning as " SQUIDSBUFPH " Windows System Service on %s\n",
-                          SQUIDBUFPRINT(service_name), WIN32_OS_string);
+                          SQUIDSBUFPRINT(service_name), WIN32_OS_string);
         storeAppendPrintf(sentry,"Service command line is: %s\n", WIN32_Service_Command_Line);
     } else
         storeAppendPrintf(sentry,"Running on %s\n",WIN32_OS_string);
@@ -1067,7 +1067,7 @@ StoreEntry::complete()
 
 /*
  * Someone wants to abort this transfer.  Set the reason in the
- * request structure, call the server-side callback and mark the
+ * request structure, call the callback and mark the
  * entry for releasing
  */
 void
@@ -299,8 +299,8 @@ storeClientCopy2(StoreEntry * e, store_client * sc)
     /*
      * We used to check for ENTRY_ABORTED here.  But there were some
      * problems.  For example, we might have a slow client (or two) and
-     * the server-side is reading far ahead and swapping to disk.  Even
-     * if the server-side aborts, we want to give the client(s)
+     * the peer server is reading far ahead and swapping to disk.  Even
+     * if the peer aborts, we want to give the client(s)
      * everything we got before the abort condition occurred.
      */
     /* Warning: doCopy may indirectly free itself in callbacks,
@@ -27,22 +27,6 @@
 
 #include <cerrno>
 #include <climits>
-#if HAVE_STATVFS
-#if HAVE_SYS_STATVFS_H
-#include <sys/statvfs.h>
-#endif
-#endif /* HAVE_STATVFS */
-/* statfs() needs <sys/param.h> and <sys/mount.h> on BSD systems */
-#if HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#if HAVE_SYS_MOUNT_H
-#include <sys/mount.h>
-#endif
-/* Windows and Linux use sys/vfs.h */
-#if HAVE_SYS_VFS_H
-#include <sys/vfs.h>
-#endif
 #if HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
@@ -556,33 +540,17 @@ StoreController::callback()
 int
 storeDirGetBlkSize(const char *path, int *blksize)
 {
-#if HAVE_STATVFS
-
     struct statvfs sfs;
 
-    if (statvfs(path, &sfs)) {
+    if (xstatvfs(path, &sfs)) {
         debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerror());
         *blksize = 2048;
         return 1;
     }
 
     *blksize = (int) sfs.f_frsize;
-#else
-
-    struct statfs sfs;
-
-    if (statfs(path, &sfs)) {
-        debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerror());
-        *blksize = 2048;
-        return 1;
-    }
-
-    *blksize = (int) sfs.f_bsize;
-#endif
-    /*
-     * Sanity check; make sure we have a meaningful value.
-     */
 
+    // Sanity check; make sure we have a meaningful value.
     if (*blksize < 512)
         *blksize = 2048;
 
@@ -595,11 +563,9 @@ storeDirGetBlkSize(const char *path, int *blksize)
 int
 storeDirGetUFSStats(const char *path, int *totl_kb, int *free_kb, int *totl_in, int *free_in)
 {
-#if HAVE_STATVFS
-
     struct statvfs sfs;
 
-    if (statvfs(path, &sfs)) {
+    if (xstatvfs(path, &sfs)) {
         debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerror());
         return 1;
     }
@@ -608,21 +574,6 @@ storeDirGetUFSStats(const char *path, int *totl_kb, int *free_kb, int *totl_in,
     *free_kb = (int) fsbtoblk(sfs.f_bfree, sfs.f_frsize, 1024);
     *totl_in = (int) sfs.f_files;
     *free_in = (int) sfs.f_ffree;
-#else
-
-    struct statfs sfs;
-
-    if (statfs(path, &sfs)) {
-        debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerror());
-        return 1;
-    }
-
-    *totl_kb = (int) fsbtoblk(sfs.f_blocks, sfs.f_bsize, 1024);
-    *free_kb = (int) fsbtoblk(sfs.f_bfree, sfs.f_bsize, 1024);
-    *totl_in = (int) sfs.f_files;
-    *free_in = (int) sfs.f_ffree;
-#endif
-
     return 0;
 }
 
@@ -233,7 +233,7 @@ StoreEntry::swapOut()
 
         /*
          * Wait until we are below the disk FD limit, only if the
-         * next server-side read won't be deferred.
+         * next read won't be deferred.
          */
         if (storeTooManyDiskFilesOpen() && !checkDeferRead(-1))
             return;
@@ -8,14 +8,23 @@
 
 #include "squid.h"
 #include "globals.h"
-#include "HelperChildConfig.h"
+#include "helper/ChildConfig.h"
 
 #define STUB_API "stub_HelperChildconfig.cc"
 #include "tests/STUB.h"
 
 #include <cstring>
 
-HelperChildConfig::HelperChildConfig(const unsigned int m):
+Helper::ChildConfig::ChildConfig():
+        n_max(0),
+        n_startup(0),
+        n_idle(1),
+        concurrency(0),
+        n_running(0),
+        n_active(0)
+{}
+
+Helper::ChildConfig::ChildConfig(const unsigned int m):
         n_max(m),
         n_startup(0),
         n_idle(1),
@@ -25,7 +34,7 @@ HelperChildConfig::HelperChildConfig(const unsigned int m):
 {}
 
 int
-HelperChildConfig::needNew() const
+Helper::ChildConfig::needNew() const
 {
     /* during the startup and reconfigure use our special amount... */
     if (starting_up || reconfiguring) return n_startup;
@@ -37,4 +46,4 @@ HelperChildConfig::needNew() const
     return (n_max - n_active);
 }
 
-void HelperChildConfig::parseConfig() STUB
+void Helper::ChildConfig::parseConfig() STUB
@@ -73,8 +73,8 @@ void ConnStateData::quitAfterError(HttpRequest *request) STUB
 void ConnStateData::httpsPeeked(Comm::ConnectionPointer serverConnection) STUB
 void ConnStateData::getSslContextStart() STUB
 void ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew) STUB
-void ConnStateData::sslCrtdHandleReplyWrapper(void *data, const HelperReply &reply) STUB
-void ConnStateData::sslCrtdHandleReply(const HelperReply &reply) STUB
+void ConnStateData::sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply) STUB
+void ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply) STUB
 void ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode) STUB
 void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &certProperties) STUB
 bool ConnStateData::serveDelayedError(ClientSocketContext *context) STUB_RETVAL(false)
@@ -481,13 +481,13 @@ getMyHostname(void)
 
             present = 1;
 
-            Ip::Address::FreeAddrInfo(AI);
+            Ip::Address::FreeAddr(AI);
 
             if (strchr(host, '.'))
                 return host;
         }
 
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
         debugs(50, 2, "WARNING: failed to resolve " << sa << " to a fully qualified hostname");
     }
 
@@ -46,7 +46,6 @@ typedef void DTCB(int errflag, void *data);	/* disk trunc CB */
 
 class DnsLookupDetails;
 typedef void FQDNH(const char *, const DnsLookupDetails &details, void *);
-typedef void IDCB(const char *ident, void *data);
 
 #include "anyp/ProtocolType.h"
 class CachePeer;
@@ -9,16 +9,19 @@
 /* Inspired by previous work by Romeo Anghelache & Eric Stern. */
 
 #include "squid.h"
-#include "win32.h"
 
 #if _SQUID_WINDOWS_
+
+#include "fde.h"
+#include "win32.h"
+
+#include <csignal>
 #if HAVE_WIN32_PSAPI
 #include <psapi.h>
 #endif
-#ifndef _MSWSOCK_
+#if HAVE_MSWSOCK_H
 #include <mswsock.h>
 #endif
-#include <fde.h>
 
 SQUIDCEXTERN LPCRITICAL_SECTION dbg_mutex;
 void WIN32_ExceptionHandlerCleanup(void);
@@ -50,7 +53,7 @@ LONG CALLBACK WIN32_ExceptionHandler(EXCEPTION_POINTERS* ep)
     case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
 
     case EXCEPTION_IN_PAGE_ERROR:
-        death(SIGBUS);
+        raise(SIGBUS);
         break;
 
     default:
@@ -822,7 +822,7 @@ process_request(cachemgr_request * req)
 #endif
         snprintf(buf, sizeof(buf), "socket: %s\n", xstrerror());
         error_html(buf);
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
         return 1;
     }
 
@@ -831,12 +831,12 @@ process_request(cachemgr_request * req)
                  S.toUrl(ipbuf,MAX_IPSTRLEN),
                  xstrerror());
         error_html(buf);
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
         close(s);
         return 1;
     }
 
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
 
     l = snprintf(buf, sizeof(buf),
                  "GET cache_object://%s/%s%s%s HTTP/1.0\r\n"
@@ -194,7 +194,10 @@ Ping::TheConfig::parseCommandOpts(int argc, char *argv[], int c, int &optIndex)
             break;
 
         case 'I':
-            if ((interval = atoi(optarg) * 1000) <= 0) {
+            if (!optarg) {
+                std::cerr << "ERROR: -I ping interval missing parameter." << std::endl;
+                usage();
+            } else if ((interval = atoi(optarg) * 1000) <= 0) {
                 std::cerr << "ERROR: -I ping interval out of range (0-" << (INT_MAX/1000) << ")." << std::endl;
                 usage();
             }
@@ -139,7 +139,7 @@ client_comm_bind(int sock, const Ip::Address &addr)
     static struct addrinfo *AI = NULL;
     addr.getAddrInfo(AI);
     int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
     return res;
 }
 
@@ -168,10 +168,10 @@ resolveDestination(Ip::Address &iaddr)
     iaddr.getAddrInfo(AI);
     if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
         std::cerr << "ERROR: could not open socket to " << iaddr << std::endl;
-        Ip::Address::FreeAddrInfo(AI);
+        Ip::Address::FreeAddr(AI);
         exit(1);
     }
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
 
     if (Transport::Config.localHost) {
         if (client_comm_bind(conn, iaddr) < 0) {
@@ -199,7 +199,7 @@ client_comm_connect(int sock, const Ip::Address &addr)
     static struct addrinfo *AI = NULL;
     addr.getAddrInfo(AI);
     int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
+    Ip::Address::FreeAddr(AI);
     Ping::TimerStart();
     return res;
 }