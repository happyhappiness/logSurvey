@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLReplyHeaderStrategy.h,v 1.8 2004/12/20 16:30:32 robertc Exp $
+ * $Id: ACLReplyHeaderStrategy.h,v 1.9 2006/05/06 22:13:18 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -67,7 +67,7 @@ template <http_hdr_type header>
 int
 ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
-    char const *theHeader = httpHeaderGetStr(&checklist->reply->header, header);
+    char const *theHeader = checklist->reply->header.getStr(header);
 
     if (NULL == theHeader)
         return 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLReplyMIMEType.h,v 1.7 2005/04/30 19:32:01 serassio Exp $
+ * $Id: ACLReplyMIMEType.h,v 1.8 2006/05/06 22:13:18 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -56,7 +56,7 @@ template <>
 int
 ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
-    char const *theHeader = httpHeaderGetStr(&checklist->reply->header, HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRequestHeaderStrategy.h,v 1.10 2004/12/20 16:30:32 robertc Exp $
+ * $Id: ACLRequestHeaderStrategy.h,v 1.11 2006/05/06 22:13:18 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -67,7 +67,7 @@ template <http_hdr_type header>
 int
 ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
-    char const *theHeader = httpHeaderGetStr(&checklist->request->header, header);
+    char const *theHeader = checklist->request->header.getStr(header);
 
     if (NULL == theHeader)
         return 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRequestMIMEType.h,v 1.3 2005/04/30 19:32:01 serassio Exp $
+ * $Id: ACLRequestMIMEType.h,v 1.4 2006/05/06 22:13:18 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -55,7 +55,7 @@ template <>
 int
 ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
-    char const *theHeader = httpHeaderGetStr(&checklist->request->header, HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
@@ -1,6 +1,6 @@
 
 /*
- * $Id: AuthUserRequest.cc,v 1.6 2005/10/23 11:55:31 hno Exp $
+ * $Id: AuthUserRequest.cc,v 1.7 2006/05/06 22:13:18 wessels Exp $
  *
  * DO NOT MODIFY NEXT 2 LINES:
  * arch-tag: 6803fde1-d5a2-4c29-9034-1c0c9f650eb4
@@ -408,7 +408,7 @@ AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr
     const char *proxy_auth;
     assert(headertype != 0);
 
-    proxy_auth = httpHeaderGetStr(&request->header, headertype);
+    proxy_auth = request->header.getStr(headertype);
 
     /*
      * a note on proxy_auth logix here:
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.116 2006/05/05 23:57:40 wessels Exp $
+ * $Id: HttpHeader.cc,v 1.117 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -355,7 +355,6 @@ HttpHeader::HttpHeader() : owner (hoNone), len (0)
 
 HttpHeader::HttpHeader(http_hdr_owner_type const &anOwner) : owner (anOwner), len (0)
 {
-    assert(this);
     assert(anOwner > hoNone && anOwner <= hoReply);
     debug(55, 7) ("init-ing hdr: %p owner: %d\n", this, owner);
     httpHeaderMaskInit(&mask, 0);
@@ -393,7 +392,7 @@ HttpHeader::clean()
 
     HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
 
-    while ((e = httpHeaderGetEntry(this, &pos))) {
+    while ((e = getEntry(&pos))) {
         /* tmp hack to try to avoid coredumps */
 
         if (e->id < 0 || e->id >= HDR_ENUM_END) {
@@ -412,16 +411,16 @@ HttpHeader::clean()
 
 /* append entries (also see httpHeaderUpdate) */
 void
-httpHeaderAppend(HttpHeader * dest, const HttpHeader * src)
+HttpHeader::append(const HttpHeader * src)
 {
     const HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
-    assert(src && dest);
-    assert(src != dest);
-    debug(55, 7) ("appending hdr: %p += %p\n", dest, src);
+    assert(src);
+    assert(src != this);
+    debug(55, 7) ("appending hdr: %p += %p\n", this, src);
 
-    while ((e = httpHeaderGetEntry(src, &pos))) {
-        httpHeaderAddEntry(dest, httpHeaderEntryClone(e));
+    while ((e = src->getEntry(&pos))) {
+        addEntry(httpHeaderEntryClone(e));
     }
 }
 
@@ -438,49 +437,47 @@ HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
 {
     const HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
-    assert(this && fresh);
+    assert(fresh);
     assert(this != fresh);
     debug(55, 7) ("updating hdr: %p <- %p\n", this, fresh);
 
-    while ((e = httpHeaderGetEntry(fresh, &pos))) {
+    while ((e = fresh->getEntry(&pos))) {
         /* deny bad guys (ok to check for HDR_OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        httpHeaderDelByName(this, e->name.buf());
+        delByName(e->name.buf());
 
-        httpHeaderAddEntry(this, httpHeaderEntryClone(e));
+        addEntry(httpHeaderEntryClone(e));
     }
 }
 
 /* just handy in parsing: resets and returns false */
 int
-httpHeaderReset(HttpHeader * hdr)
+HttpHeader::reset()
 {
     http_hdr_owner_type ho;
-    assert(hdr);
-    ho = hdr->owner;
-    hdr->clean();
-    *hdr = HttpHeader(ho);
+    ho = owner;
+    clean();
+    *this = HttpHeader(ho);
     return 0;
 }
 
 int
-httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_end)
+HttpHeader::parse(const char *header_start, const char *header_end)
 {
     const char *field_ptr = header_start;
     HttpHeaderEntry *e, *e2;
 
-    assert(hdr);
     assert(header_start && header_end);
-    debug(55, 7) ("parsing hdr: (%p)\n%s\n", hdr, getStringPrefix(header_start, header_end));
-    HttpHeaderStats[hdr->owner].parsedCount++;
+    debug(55, 7) ("parsing hdr: (%p)\n%s\n", this, getStringPrefix(header_start, header_end));
+    HttpHeaderStats[owner].parsedCount++;
 
     if (memchr(header_start, '\0', header_end - header_start)) {
         debug(55, 1) ("WARNING: HTTP header contains NULL characters {%s}\n",
                       getStringPrefix(header_start, header_end));
-        return httpHeaderReset(hdr);
+        return reset();
     }
 
     /* common format headers are "<name>:[ws]<value>" lines delimited by <CRLF>.
@@ -494,7 +491,7 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
             field_ptr = (const char *)memchr(field_ptr, '\n', header_end - field_ptr);
 
             if (!field_ptr)
-                return httpHeaderReset(hdr);	/* missing <LF> */
+                return reset();	/* missing <LF> */
 
             field_end = field_ptr;
 
@@ -522,21 +519,21 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
                     while ((p = (char *)memchr(p, '\r', field_end - p)) != NULL)
                         *p++ = ' ';
                 } else
-                    return httpHeaderReset(hdr);
+                    return reset();
             }
 
             if (this_line + 1 == field_end && this_line > field_start) {
                 debug(55, 1) ("WARNING: Blank continuation line in HTTP header {%s}\n",
                               getStringPrefix(header_start, header_end));
-                return httpHeaderReset(hdr);
+                return reset();
             }
         } while (field_ptr < header_end && (*field_ptr == ' ' || *field_ptr == '\t'));
 
         if (field_start == field_end) {
             if (field_ptr < header_end) {
                 debug(55, 1) ("WARNING: unparseable HTTP header field near {%s}\n",
                               getStringPrefix(field_start, header_end));
-                return httpHeaderReset(hdr);
+                return reset();
             }
 
             break;		/* terminating blank line */
@@ -553,17 +550,17 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
             if (Config.onoff.relaxed_header_parser)
                 continue;
             else
-                return httpHeaderReset(hdr);
+                return reset();
         }
 
-        if (e->id == HDR_CONTENT_LENGTH && (e2 = httpHeaderFindEntry(hdr, e->id)) != NULL) {
+        if (e->id == HDR_CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
             if (e->value.cmp(e2->value.buf()) != 0) {
                 ssize_t l1, l2;
                 debug(55, Config.onoff.relaxed_header_parser <= 0 ? 1 : 2) ("WARNING: found two conflicting content-length headers in {%s}\n", getStringPrefix(header_start, header_end));
 
                 if (!Config.onoff.relaxed_header_parser) {
                     httpHeaderEntryDestroy(e);
-                    return httpHeaderReset(hdr);
+                    return reset();
                 }
 
                 if (!httpHeaderParseSize(e->value.buf(), &l1)) {
@@ -572,9 +569,9 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
                     continue;
                 } else if (!httpHeaderParseSize(e2->value.buf(), &l2)) {
                     debug(55, 1)("WARNING: Unparseable content-length '%s'\n", e2->value.buf());
-                    httpHeaderDelById(hdr, e2->id);
+                    delById(e2->id);
                 } else if (l1 > l2) {
-                    httpHeaderDelById(hdr, e2->id);
+                    delById(e2->id);
                 } else {
                     httpHeaderEntryDestroy(e);
                     continue;
@@ -588,7 +585,7 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
                     continue;
                 } else {
                     httpHeaderEntryDestroy(e);
-                    return httpHeaderReset(hdr);
+                    return reset();
                 }
             }
         }
@@ -599,40 +596,40 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
 
             if (!Config.onoff.relaxed_header_parser) {
                 httpHeaderEntryDestroy(e);
-                return httpHeaderReset(hdr);
+                return reset();
             }
         }
 
-        httpHeaderAddEntry(hdr, e);
+        addEntry(e);
     }
 
     return 1;			/* even if no fields where found, it is a valid header */
 }
 
 /* packs all the entries using supplied packer */
 void
-httpHeaderPackInto(const HttpHeader * hdr, Packer * p)
+HttpHeader::packInto(Packer * p) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     const HttpHeaderEntry *e;
-    assert(hdr && p);
-    debug(55, 7) ("packing hdr: (%p)\n", hdr);
+    assert(p);
+    debug(55, 7) ("packing hdr: (%p)\n", this);
     /* pack all entries one by one */
 
-    while ((e = httpHeaderGetEntry(hdr, &pos)))
+    while ((e = getEntry(&pos)))
         httpHeaderEntryPackInto(e, p);
 }
 
 /* returns next valid entry */
 HttpHeaderEntry *
-httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
+HttpHeader::getEntry(HttpHeaderPos * pos) const
 {
-    assert(hdr && pos);
-    assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)hdr->entries.count);
+    assert(pos);
+    assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)entries.count);
 
-    for ((*pos)++; *pos < (ssize_t)hdr->entries.count; (*pos)++) {
-        if (hdr->entries.items[*pos])
-            return (HttpHeaderEntry*)hdr->entries.items[*pos];
+    for ((*pos)++; *pos < (ssize_t)entries.count; (*pos)++) {
+        if (entries.items[*pos])
+            return (HttpHeaderEntry*)entries.items[*pos];
     }
 
     return NULL;
@@ -644,21 +641,20 @@ httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
  * "list" headers
  */
 HttpHeaderEntry *
-httpHeaderFindEntry(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::findEntry(http_hdr_type id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
-    assert(hdr);
     assert_eid(id);
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
 
-    if (!CBIT_TEST(hdr->mask, id))
+    if (!CBIT_TEST(mask, id))
         return NULL;
 
     /* looks like we must have it, do linear search */
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
+    while ((e = getEntry(&pos))) {
         if (e->id == id)
             return e;
     }
@@ -672,23 +668,22 @@ httpHeaderFindEntry(const HttpHeader * hdr, http_hdr_type id)
 /*
  * same as httpHeaderFindEntry
  */
-static HttpHeaderEntry *
-httpHeaderFindLastEntry(const HttpHeader * hdr, http_hdr_type id)
+HttpHeaderEntry *
+HttpHeader::findLastEntry(http_hdr_type id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
     HttpHeaderEntry *result = NULL;
-    assert(hdr);
     assert_eid(id);
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
 
-    if (!CBIT_TEST(hdr->mask, id))
+    if (!CBIT_TEST(mask, id))
         return NULL;
 
     /* looks like we must have it, do linear search */
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
+    while ((e = getEntry(&pos))) {
         if (e->id == id)
             result = e;
     }
@@ -701,48 +696,47 @@ httpHeaderFindLastEntry(const HttpHeader * hdr, http_hdr_type id)
  * deletes all fields with a given name if any, returns #fields deleted; 
  */
 int
-httpHeaderDelByName(HttpHeader * hdr, const char *name)
+HttpHeader::delByName(const char *name)
 {
     int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
-    httpHeaderMaskInit(&hdr->mask, 0);	/* temporal inconsistency */
-    debug(55, 9) ("deleting '%s' fields in hdr %p\n", name, hdr);
+    httpHeaderMaskInit(&mask, 0);	/* temporal inconsistency */
+    debug(55, 9) ("deleting '%s' fields in hdr %p\n", name, this);
 
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
+    while ((e = getEntry(&pos))) {
         if (!e->name.caseCmp(name)) {
-            httpHeaderDelAt(hdr, pos);
+            delAt(pos);
             count++;
         } else
-            CBIT_SET(hdr->mask, e->id);
+            CBIT_SET(mask, e->id);
     }
 
     return count;
 }
 
 /* deletes all entries with a given id, returns the #entries deleted */
 int
-httpHeaderDelById(HttpHeader * hdr, http_hdr_type id)
+HttpHeader::delById(http_hdr_type id)
 {
     int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
-    debug(55, 8) ("%p del-by-id %d\n", hdr, id);
-    assert(hdr);
+    debug(55, 8) ("%p del-by-id %d\n", this, id);
     assert_eid(id);
     assert(id != HDR_OTHER);		/* does not make sense */
 
-    if (!CBIT_TEST(hdr->mask, id))
+    if (!CBIT_TEST(mask, id))
         return 0;
 
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
+    while ((e = getEntry(&pos))) {
         if (e->id == id) {
-            httpHeaderDelAt(hdr, pos);
+            delAt(pos);
             count++;
         }
     }
 
-    CBIT_CLR(hdr->mask, id);
+    CBIT_CLR(mask, id);
     assert(count);
     return count;
 }
@@ -752,15 +746,15 @@ httpHeaderDelById(HttpHeader * hdr, http_hdr_type id)
  * possible to iterate(search) and delete fields at the same time
  */
 void
-httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos)
+HttpHeader::delAt(HttpHeaderPos pos)
 {
     HttpHeaderEntry *e;
-    assert(pos >= HttpHeaderInitPos && pos < (ssize_t)hdr->entries.count);
-    e = (HttpHeaderEntry*)hdr->entries.items[pos];
-    hdr->entries.items[pos] = NULL;
+    assert(pos >= HttpHeaderInitPos && pos < (ssize_t)entries.count);
+    e = (HttpHeaderEntry*)entries.items[pos];
+    entries.items[pos] = NULL;
     /* decrement header length, allow for ": " and crlf */
-    hdr->len -= e->name.size() + 2 + e->value.size() + 2;
-    assert(hdr->len >= 0);
+    len -= e->name.size() + 2 + e->value.size() + 2;
+    assert(len >= 0);
     httpHeaderEntryDestroy(e);
 }
 
@@ -769,64 +763,64 @@ httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos)
  * does not call httpHeaderEntryClone() so one should not reuse "*e"
  */
 void
-httpHeaderAddEntry(HttpHeader * hdr, HttpHeaderEntry * e)
+HttpHeader::addEntry(HttpHeaderEntry * e)
 {
-    assert(hdr && e);
+    assert(e);
     assert_eid(e->id);
 
-    debugs(55, 9, hdr << " adding entry: " << e->id << " at " <<
-           hdr->entries.count);
+    debugs(55, 9, this << " adding entry: " << e->id << " at " <<
+           entries.count);
 
-    if (CBIT_TEST(hdr->mask, e->id))
+    if (CBIT_TEST(mask, e->id))
         Headers[e->id].stat.repCount++;
     else
-        CBIT_SET(hdr->mask, e->id);
+        CBIT_SET(mask, e->id);
 
-    hdr->entries.push_back(e);
+    entries.push_back(e);
 
     /* increment header length, allow for ": " and crlf */
-    hdr->len += e->name.size() + 2 + e->value.size() + 2;
+    len += e->name.size() + 2 + e->value.size() + 2;
 }
 
 /* inserts an entry;
  * does not call httpHeaderEntryClone() so one should not reuse "*e"
  */
 void
-httpHeaderInsertEntry(HttpHeader * hdr, HttpHeaderEntry * e)
+HttpHeader::insertEntry(HttpHeaderEntry * e)
 {
-    assert(hdr && e);
+    assert(e);
     assert_eid(e->id);
 
-    debugs(55, 7, hdr << " adding entry: " << e->id << " at " <<
-           hdr->entries.count);
+    debugs(55, 7, this << " adding entry: " << e->id << " at " <<
+           entries.count);
 
-    if (CBIT_TEST(hdr->mask, e->id))
+    if (CBIT_TEST(mask, e->id))
         Headers[e->id].stat.repCount++;
     else
-        CBIT_SET(hdr->mask, e->id);
+        CBIT_SET(mask, e->id);
 
-    hdr->entries.insert(e);
+    entries.insert(e);
 
     /* increment header length, allow for ": " and crlf */
-    hdr->len += e->name.size() + 2 + e->value.size() + 2;
+    len += e->name.size() + 2 + e->value.size() + 2;
 }
 
 /* return a list of entries with the same id separated by ',' and ws */
 String
-httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getList(http_hdr_type id) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
-    debug(55, 9) ("%p: joining for id %d\n", hdr, id);
+    debug(55, 9) ("%p: joining for id %d\n", this, id);
     /* only fields from ListHeaders array can be "listed" */
     assert(CBIT_TEST(ListHeadersMask, id));
 
-    if (!CBIT_TEST(hdr->mask, id))
+    if (!CBIT_TEST(mask, id))
         return String();
 
     String s;
 
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
+    while ((e = getEntry(&pos))) {
         if (e->id == id)
             strListAdd(&s, e->value.buf(), ',');
     }
@@ -841,21 +835,21 @@ httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
     if (!s.size())
         debug(55, 3) ("empty list header: %s (%d)\n", Headers[id].name.buf(), id);
 
-    debug(55, 6) ("%p: joined for id %d: %s\n", hdr, id, s.buf());
+    debug(55, 6) ("%p: joined for id %d: %s\n", this, id, s.buf());
 
     return s;
 }
 
 /* return a string or list of entries with the same id separated by ',' and ws */
 String
-httpHeaderGetStrOrList(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getStrOrList(http_hdr_type id) const
 {
     HttpHeaderEntry *e;
 
     if (CBIT_TEST(ListHeadersMask, id))
-        return httpHeaderGetList(hdr, id);
+        return getList(id);
 
-    if ((e = httpHeaderFindEntry(hdr, id)))
+    if ((e = findEntry(id)))
         return e->value;
 
     return String();
@@ -865,25 +859,24 @@ httpHeaderGetStrOrList(const HttpHeader * hdr, http_hdr_type id)
  * Returns the value of the specified header.
  */
 String
-httpHeaderGetByName(const HttpHeader * hdr, const char *name)
+HttpHeader::getByName(const char *name) const
 {
     http_hdr_type id;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
 
-    assert(hdr);
     assert(name);
 
     /* First try the quick path */
     id = httpHeaderIdByNameDef(name, strlen(name));
 
     if (id != -1)
-        return httpHeaderGetStrOrList(hdr, id);
+        return getStrOrList(id);
 
     String result;
 
     /* Sorry, an unknown header name. Do linear search */
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
+    while ((e = getEntry(&pos))) {
         if (e->id == HDR_OTHER && e->name.caseCmp(name) == 0) {
             strListAdd(&result, e->value.buf(), ',');
         }
@@ -896,18 +889,17 @@ httpHeaderGetByName(const HttpHeader * hdr, const char *name)
  * Returns a the value of the specified list member, if any.
  */
 String
-httpHeaderGetByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator)
+HttpHeader::getByNameListMember(const char *name, const char *member, const char separator) const
 {
     String header;
     const char *pos = NULL;
     const char *item;
     int ilen;
     int mlen = strlen(member);
 
-    assert(hdr);
     assert(name);
 
-    header = httpHeaderGetByName(hdr, name);
+    header = getByName(name);
 
     String result;
 
@@ -925,18 +917,17 @@ httpHeaderGetByNameListMember(const HttpHeader * hdr, const char *name, const ch
  * returns a the value of the specified list member, if any.
  */
 String
-httpHeaderGetListMember(const HttpHeader * hdr, http_hdr_type id, const char *member, const char separator)
+HttpHeader::getListMember(http_hdr_type id, const char *member, const char separator) const
 {
     String header;
     const char *pos = NULL;
     const char *item;
     int ilen;
     int mlen = strlen(member);
 
-    assert(hdr);
     assert(id >= 0);
 
-    header = httpHeaderGetStrOrList(hdr, id);
+    header = getStrOrList(id);
     String result;
 
     while (strListGetItem(&header, separator, &item, &ilen, &pos)) {
@@ -952,141 +943,140 @@ httpHeaderGetListMember(const HttpHeader * hdr, http_hdr_type id, const char *me
 
 /* test if a field is present */
 int
-httpHeaderHas(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::has(http_hdr_type id) const
 {
-    assert(hdr);
     assert_eid(id);
     assert(id != HDR_OTHER);
-    debug(55, 9) ("%p lookup for %d\n", hdr, id);
-    return CBIT_TEST(hdr->mask, id);
+    debug(55, 9) ("%p lookup for %d\n", this, id);
+    return CBIT_TEST(mask, id);
 }
 
 void
-httpHeaderPutInt(HttpHeader * hdr, http_hdr_type id, int number)
+HttpHeader::putInt(http_hdr_type id, int number)
 {
     assert_eid(id);
     assert(Headers[id].type == ftInt);	/* must be of an appropriate type */
     assert(number >= 0);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, xitoa(number)));
+    addEntry(httpHeaderEntryCreate(id, NULL, xitoa(number)));
 }
 
 void
-httpHeaderPutTime(HttpHeader * hdr, http_hdr_type id, time_t htime)
+HttpHeader::putTime(http_hdr_type id, time_t htime)
 {
     assert_eid(id);
     assert(Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
     assert(htime >= 0);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, mkrfc1123(htime)));
+    addEntry(httpHeaderEntryCreate(id, NULL, mkrfc1123(htime)));
 }
 
 void
-httpHeaderInsertTime(HttpHeader * hdr, http_hdr_type id, time_t htime)
+HttpHeader::insertTime(http_hdr_type id, time_t htime)
 {
     assert_eid(id);
     assert(Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
     assert(htime >= 0);
-    httpHeaderInsertEntry(hdr, httpHeaderEntryCreate(id, NULL, mkrfc1123(htime)));
+    insertEntry(httpHeaderEntryCreate(id, NULL, mkrfc1123(htime)));
 }
 
 void
-httpHeaderPutStr(HttpHeader * hdr, http_hdr_type id, const char *str)
+HttpHeader::putStr(http_hdr_type id, const char *str)
 {
     assert_eid(id);
     assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
     assert(str);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, str));
+    addEntry(httpHeaderEntryCreate(id, NULL, str));
 }
 
 void
-httpHeaderPutAuth(HttpHeader * hdr, const char *auth_scheme, const char *realm)
+HttpHeader::putAuth(const char *auth_scheme, const char *realm)
 {
-    assert(hdr && auth_scheme && realm);
-    httpHeaderPutStrf(hdr, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
+    assert(auth_scheme && realm);
+    httpHeaderPutStrf(this, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
 }
 
 void
-httpHeaderPutCc(HttpHeader * hdr, const HttpHdrCc * cc)
+HttpHeader::putCc(const HttpHdrCc * cc)
 {
     MemBuf mb;
     Packer p;
-    assert(hdr && cc);
+    assert(cc);
     /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_CACHE_CONTROL);
+    delById(HDR_CACHE_CONTROL);
     /* pack into mb */
     mb.init();
     packerToMemInit(&p, &mb);
     httpHdrCcPackInto(cc, &p);
     /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_CACHE_CONTROL, NULL, mb.buf));
+    addEntry(httpHeaderEntryCreate(HDR_CACHE_CONTROL, NULL, mb.buf));
     /* cleanup */
     packerClean(&p);
     mb.clean();
 }
 
 void
-httpHeaderPutContRange(HttpHeader * hdr, const HttpHdrContRange * cr)
+HttpHeader::putContRange(const HttpHdrContRange * cr)
 {
     MemBuf mb;
     Packer p;
-    assert(hdr && cr);
+    assert(cr);
     /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_CONTENT_RANGE);
+    delById(HDR_CONTENT_RANGE);
     /* pack into mb */
     mb.init();
     packerToMemInit(&p, &mb);
     httpHdrContRangePackInto(cr, &p);
     /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_CONTENT_RANGE, NULL, mb.buf));
+    addEntry(httpHeaderEntryCreate(HDR_CONTENT_RANGE, NULL, mb.buf));
     /* cleanup */
     packerClean(&p);
     mb.clean();
 }
 
 void
-httpHeaderPutRange(HttpHeader * hdr, const HttpHdrRange * range)
+HttpHeader::putRange(const HttpHdrRange * range)
 {
     MemBuf mb;
     Packer p;
-    assert(hdr && range);
+    assert(range);
     /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_RANGE);
+    delById(HDR_RANGE);
     /* pack into mb */
     mb.init();
     packerToMemInit(&p, &mb);
     range->packInto(&p);
     /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_RANGE, NULL, mb.buf));
+    addEntry(httpHeaderEntryCreate(HDR_RANGE, NULL, mb.buf));
     /* cleanup */
     packerClean(&p);
     mb.clean();
 }
 
 void
-httpHeaderPutSc(HttpHeader *hdr, const HttpHdrSc *sc)
+HttpHeader::putSc(HttpHdrSc *sc)
 {
     MemBuf mb;
     Packer p;
-    assert(hdr && sc);
+    assert(sc);
     /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_RANGE);
+    delById(HDR_RANGE);
     /* pack into mb */
     mb.init();
     packerToMemInit(&p, &mb);
     httpHdrScPackInto(sc, &p);
     /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_SURROGATE_CONTROL, NULL, mb.buf));
+    addEntry(httpHeaderEntryCreate(HDR_SURROGATE_CONTROL, NULL, mb.buf));
     /* cleanup */
     packerClean(&p);
     mb.clean();
 }
 
 /* add extension header (these fields are not parsed/analyzed/joined, etc.) */
 void
-httpHeaderPutExt(HttpHeader * hdr, const char *name, const char *value)
+HttpHeader::putExt(const char *name, const char *value)
 {
     assert(name && value);
-    debug(55, 8) ("%p adds ext entry '%s: %s'\n", hdr, name, value);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_OTHER, name, value));
+    debug(55, 8) ("%p adds ext entry '%s: %s'\n", this, name, value);
+    addEntry(httpHeaderEntryCreate(HDR_OTHER, name, value));
 }
 
 int
@@ -1106,27 +1096,27 @@ httpHeaderEntryGetInt (const HttpHeaderEntry * e)
 }
 
 int
-httpHeaderGetInt(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getInt(http_hdr_type id) const
 {
     assert_eid(id);
     assert(Headers[id].type == ftInt);	/* must be of an appropriate type */
     HttpHeaderEntry *e;
 
-    if ((e = httpHeaderFindEntry(hdr, id)))
+    if ((e = findEntry(id)))
         return httpHeaderEntryGetInt (e);
 
     return -1;
 }
 
 time_t
-httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getTime(http_hdr_type id) const
 {
     HttpHeaderEntry *e;
     time_t value = -1;
     assert_eid(id);
     assert(Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
 
-    if ((e = httpHeaderFindEntry(hdr, id))) {
+    if ((e = findEntry(id))) {
         value = parse_rfc1123(e->value.buf());
         httpHeaderNoteParsedEntry(e->id, e->value, value < 0);
     }
@@ -1136,13 +1126,13 @@ httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id)
 
 /* sync with httpHeaderGetLastStr */
 const char *
-httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getStr(http_hdr_type id) const
 {
     HttpHeaderEntry *e;
     assert_eid(id);
     assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
 
-    if ((e = httpHeaderFindEntry(hdr, id))) {
+    if ((e = findEntry(id))) {
         httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
         return e->value.buf();
     }
@@ -1152,13 +1142,13 @@ httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id)
 
 /* unusual */
 const char *
-httpHeaderGetLastStr(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getLastStr(http_hdr_type id) const
 {
     HttpHeaderEntry *e;
     assert_eid(id);
     assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
 
-    if ((e = httpHeaderFindLastEntry(hdr, id))) {
+    if ((e = findLastEntry(id))) {
         httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
         return e->value.buf();
     }
@@ -1167,22 +1157,22 @@ httpHeaderGetLastStr(const HttpHeader * hdr, http_hdr_type id)
 }
 
 HttpHdrCc *
-httpHeaderGetCc(const HttpHeader * hdr)
+HttpHeader::getCc() const
 {
     HttpHdrCc *cc;
     String s;
 
-    if (!CBIT_TEST(hdr->mask, HDR_CACHE_CONTROL))
+    if (!CBIT_TEST(mask, HDR_CACHE_CONTROL))
         return NULL;
 
-    s = httpHeaderGetList(hdr, HDR_CACHE_CONTROL);
+    s = getList(HDR_CACHE_CONTROL);
 
     cc = httpHdrCcParseCreate(&s);
 
-    HttpHeaderStats[hdr->owner].ccParsedCount++;
+    HttpHeaderStats[owner].ccParsedCount++;
 
     if (cc)
-        httpHdrCcUpdateStats(cc, &HttpHeaderStats[hdr->owner].ccTypeDistr);
+        httpHdrCcUpdateStats(cc, &HttpHeaderStats[owner].ccTypeDistr);
 
     httpHeaderNoteParsedEntry(HDR_CACHE_CONTROL, s, !cc);
 
@@ -1192,7 +1182,7 @@ httpHeaderGetCc(const HttpHeader * hdr)
 }
 
 HttpHdrRange *
-httpHeaderGetRange(const HttpHeader * hdr)
+HttpHeader::getRange() const
 {
     HttpHdrRange *r = NULL;
     HttpHeaderEntry *e;
@@ -1201,8 +1191,8 @@ httpHeaderGetRange(const HttpHeader * hdr)
      * this "if" should work correctly in both cases;
      * hopefully no clients send mismatched headers! */
 
-    if ((e = httpHeaderFindEntry(hdr, HDR_RANGE)) ||
-            (e = httpHeaderFindEntry(hdr, HDR_REQUEST_RANGE))) {
+    if ((e = findEntry(HDR_RANGE)) ||
+            (e = findEntry(HDR_REQUEST_RANGE))) {
         r = HttpHdrRange::ParseCreate(&e->value);
         httpHeaderNoteParsedEntry(e->id, e->value, !r);
     }
@@ -1211,32 +1201,32 @@ httpHeaderGetRange(const HttpHeader * hdr)
 }
 
 HttpHdrSc *
-httpHeaderGetSc(const HttpHeader *hdr)
+HttpHeader::getSc() const
 {
-    if (!CBIT_TEST(hdr->mask, HDR_SURROGATE_CONTROL))
+    if (!CBIT_TEST(mask, HDR_SURROGATE_CONTROL))
         return NULL;
 
-    String s (httpHeaderGetList(hdr, HDR_SURROGATE_CONTROL));
+    String s (getList(HDR_SURROGATE_CONTROL));
 
     HttpHdrSc *sc = httpHdrScParseCreate(&s);
 
-    HttpHeaderStats[hdr->owner].ccParsedCount++;
+    HttpHeaderStats[owner].ccParsedCount++;
 
     if (sc)
-        httpHdrScUpdateStats(sc, &HttpHeaderStats[hdr->owner].scTypeDistr);
+        httpHdrScUpdateStats(sc, &HttpHeaderStats[owner].scTypeDistr);
 
     httpHeaderNoteParsedEntry(HDR_SURROGATE_CONTROL, s, !sc);
 
     return sc;
 }
 
 HttpHdrContRange *
-httpHeaderGetContRange(const HttpHeader * hdr)
+HttpHeader::getContRange() const
 {
     HttpHdrContRange *cr = NULL;
     HttpHeaderEntry *e;
 
-    if ((e = httpHeaderFindEntry(hdr, HDR_CONTENT_RANGE))) {
+    if ((e = findEntry(HDR_CONTENT_RANGE))) {
         cr = httpHdrContRangeParseCreate(e->value.buf());
         httpHeaderNoteParsedEntry(e->id, e->value, !cr);
     }
@@ -1245,12 +1235,12 @@ httpHeaderGetContRange(const HttpHeader * hdr)
 }
 
 const char *
-httpHeaderGetAuth(const HttpHeader * hdr, http_hdr_type id, const char *auth_scheme)
+HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
 {
     const char *field;
     int l;
-    assert(hdr && auth_scheme);
-    field = httpHeaderGetStr(hdr, id);
+    assert(auth_scheme);
+    field = getStr(id);
 
     if (!field)			/* no authorization field */
         return NULL;
@@ -1275,28 +1265,28 @@ httpHeaderGetAuth(const HttpHeader * hdr, http_hdr_type id, const char *auth_sch
 }
 
 ETag
-httpHeaderGetETag(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getETag(http_hdr_type id) const
 {
     ETag etag =
         {NULL, -1};
     HttpHeaderEntry *e;
     assert(Headers[id].type == ftETag);		/* must be of an appropriate type */
 
-    if ((e = httpHeaderFindEntry(hdr, id)))
+    if ((e = findEntry(id)))
         etagParseInit(&etag, e->value.buf());
 
     return etag;
 }
 
 TimeOrTag
-httpHeaderGetTimeOrTag(const HttpHeader * hdr, http_hdr_type id)
+HttpHeader::getTimeOrTag(http_hdr_type id) const
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
     assert(Headers[id].type == ftDate_1123_or_ETag);	/* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
 
-    if ((e = httpHeaderFindEntry(hdr, id))) {
+    if ((e = findEntry(id))) {
         const char *str = e->value.buf();
         /* try as an ETag */
 
@@ -1621,18 +1611,17 @@ httpHeaderNameById(int id)
 }
 
 int
-httpHeaderHasListMember(const HttpHeader * hdr, http_hdr_type id, const char *member, const char separator)
+HttpHeader::hasListMember(http_hdr_type id, const char *member, const char separator) const
 {
     int result = 0;
     const char *pos = NULL;
     const char *item;
     int ilen;
     int mlen = strlen(member);
 
-    assert(hdr);
     assert(id >= 0);
 
-    String header (httpHeaderGetStrOrList(hdr, id));
+    String header (getStrOrList(id));
 
     while (strListGetItem(&header, separator, &item, &ilen, &pos)) {
         if (strncmp(item, member, mlen) == 0
@@ -1646,18 +1635,17 @@ httpHeaderHasListMember(const HttpHeader * hdr, http_hdr_type id, const char *me
 }
 
 int
-httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator)
+HttpHeader::hasByNameListMember(const char *name, const char *member, const char separator) const
 {
     int result = 0;
     const char *pos = NULL;
     const char *item;
     int ilen;
     int mlen = strlen(member);
 
-    assert(hdr);
     assert(name);
 
-    String header (httpHeaderGetByName(hdr, name));
+    String header (getByName(name));
 
     while (strListGetItem(&header, separator, &item, &ilen, &pos)) {
         if (strncmp(item, member, mlen) == 0
@@ -1673,9 +1661,9 @@ httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const ch
 void
 HttpHeader::removeConnectionHeaderEntries()
 {
-    if (httpHeaderHas(this, HDR_CONNECTION)) {
+    if (has(HDR_CONNECTION)) {
         /* anything that matches Connection list member will be deleted */
-        String strConnection = httpHeaderGetList(this, HDR_CONNECTION);
+        String strConnection = getList(HDR_CONNECTION);
         const HttpHeaderEntry *e;
         HttpHeaderPos pos = HttpHeaderInitPos;
         /*
@@ -1687,12 +1675,12 @@ HttpHeader::removeConnectionHeaderEntries()
          * from strConnection first?
          */
 
-        while ((e = httpHeaderGetEntry(this, &pos))) {
+        while ((e = getEntry(&pos))) {
             if (strListIsMember(&strConnection, e->name.buf(), ','))
-                httpHeaderDelAt(this, pos);
+                delAt(pos);
         }
 
-        httpHeaderDelById(this, HDR_CONNECTION);
+        delById(HDR_CONNECTION);
         strConnection.clean();
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.h,v 1.10 2006/05/05 23:57:40 wessels Exp $
+ * $Id: HttpHeader.h,v 1.11 2006/05/06 22:13:18 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -149,6 +149,10 @@ class HttpVersion;
 
 class HttpHeaderEntry;
 
+class HttpHdrContRange;
+
+class HttpHdrSc;
+
 class HttpHeader
 {
 
@@ -157,18 +161,60 @@ class HttpHeader
     HttpHeader(http_hdr_owner_type const &owner);
     ~HttpHeader();
     /* Interface functions */
-    void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
     void clean();
+    void append(const HttpHeader * src);
+    void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
+    int reset();
+    int parse(const char *header_start, const char *header_end);
+    void packInto(Packer * p) const;
+    HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
+    HttpHeaderEntry *findEntry(http_hdr_type id) const;
+    int delByName(const char *name);
+    int delById(http_hdr_type id);
+    void delAt(HttpHeaderPos pos);
+    void addEntry(HttpHeaderEntry * e);
+    void insertEntry(HttpHeaderEntry * e);
+    String getList(http_hdr_type id) const;
+    String getStrOrList(http_hdr_type id) const;
+    String getByName(const char *name) const;
+    String getByNameListMember(const char *name, const char *member, const char separator) const;
+    String getListMember(http_hdr_type id, const char *member, const char separator) const;
+    int has(http_hdr_type id) const;
+    void putInt(http_hdr_type id, int number);
+    void putTime(http_hdr_type id, time_t htime);
+    void insertTime(http_hdr_type id, time_t htime);
+    void putStr(http_hdr_type id, const char *str);
+    void putAuth(const char *auth_scheme, const char *realm);
+    void putCc(const HttpHdrCc * cc);
+    void putContRange(const HttpHdrContRange * cr);
+    void putRange(const HttpHdrRange * range);
+    void putSc(HttpHdrSc *sc);
+    void putExt(const char *name, const char *value);
+    int getInt(http_hdr_type id) const;
+    time_t getTime(http_hdr_type id) const;
+    const char *getStr(http_hdr_type id) const;
+    const char *getLastStr(http_hdr_type id) const;
+    HttpHdrCc *getCc() const;
+    HttpHdrRange *getRange() const;
+    HttpHdrSc *getSc() const;
+    HttpHdrContRange *getContRange() const;
+    const char *getAuth(http_hdr_type id, const char *auth_scheme) const;
+    ETag getETag(http_hdr_type id) const;
+    TimeOrTag getTimeOrTag(http_hdr_type id) const;
+    int hasListMember(http_hdr_type id, const char *member, const char separator) const;
+    int hasByNameListMember(const char *name, const char *member, const char separator) const;
     void removeConnectionHeaderEntries();
     /* protected, do not use these, use interface functions instead */
     Vector<HttpHeaderEntry *> entries;		/* parsed fields in raw format */
     HttpHeaderMask mask;	/* bit set <=> entry present */
     http_hdr_owner_type owner;	/* request or reply */
     int len;			/* length when packed, not counting terminating '\0' */
+
+private:
+    HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
 };
 
 extern int httpHeaderParseQuotedString (const char *start, String *val);
-extern int httpHeaderHasListMember(const HttpHeader * hdr, http_hdr_type id, const char *member, const char separator);
 SQUIDCEXTERN int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
 SQUIDCEXTERN void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
 int httpMsgIsPersistent(HttpVersion const &http_ver, const HttpHeader * hdr);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeaderTools.cc,v 1.54 2006/05/05 23:57:40 wessels Exp $
+ * $Id: HttpHeaderTools.cc,v 1.55 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 66    HTTP Header Tools
  * AUTHOR: Alex Rousskov
@@ -139,7 +139,7 @@ httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list
     MemBuf mb;
     mb.init();
     mb.vPrintf(fmt, vargs);
-    httpHeaderPutStr(hdr, id, mb.buf);
+    hdr->putStr(id, mb.buf);
     mb.clean();
 }
 
@@ -151,7 +151,7 @@ httpHeaderAddContRange(HttpHeader * hdr, HttpHdrRangeSpec spec, ssize_t ent_len)
     HttpHdrContRange *cr = httpHdrContRangeCreate();
     assert(hdr && ent_len >= 0);
     httpHdrContRangeSet(cr, spec, ent_len);
-    httpHeaderPutContRange(hdr, cr);
+    hdr->putContRange(cr);
     httpHdrContRangeDestroy(cr);
 }
 
@@ -169,14 +169,14 @@ httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
     int res;
     /* what type of header do we have? */
 
-    if (httpHeaderHas(hdr, HDR_PROXY_CONNECTION))
+    if (hdr->has(HDR_PROXY_CONNECTION))
         ht = HDR_PROXY_CONNECTION;
-    else if (httpHeaderHas(hdr, HDR_CONNECTION))
+    else if (hdr->has(HDR_CONNECTION))
         ht = HDR_CONNECTION;
     else
         return 0;
 
-    list = httpHeaderGetList(hdr, ht);
+    list = hdr->getList(ht);
 
     res = strListIsMember(&list, directive, ',');
 
@@ -552,9 +552,9 @@ httpHdrMangleList(HttpHeader * l, HttpRequest * request, int req_or_rep)
     HttpHeaderEntry *e;
     HttpHeaderPos p = HttpHeaderInitPos;
 
-    while ((e = httpHeaderGetEntry(l, &p)))
+    while ((e = l->getEntry(&p)))
         if (0 == httpHdrMangle(e, request, req_or_rep))
-            httpHeaderDelAt(l, p);
+            l->delAt(p);
 }
 
 /*
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpMsg.cc,v 1.28 2006/05/05 19:57:32 wessels Exp $
+ * $Id: HttpMsg.cc,v 1.29 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 74    HTTP Message
  * AUTHOR: Alex Rousskov
@@ -269,7 +269,7 @@ HttpMsg::httpMsgParseStep(const char *buf, int atEnd)
                 return 0;
         }
 
-        if (!httpHeaderParse(&header, blk_start, blk_end))
+        if (!header.parse(blk_start, blk_end))
             return httpMsgParseError();
 
         hdrCacheInit();
@@ -314,9 +314,9 @@ httpMsgIsPersistent(HttpVersion const &http_ver, const HttpHeader * hdr)
          * return false if it is a browser connection.  If there is a
          * VIA header, then we assume this is NOT a browser connection.
          */
-        const char *agent = httpHeaderGetStr(hdr, HDR_USER_AGENT);
+        const char *agent = hdr->getStr(HDR_USER_AGENT);
 
-    if (agent && !httpHeaderHas(hdr, HDR_VIA)) {
+    if (agent && !hdr->has(HDR_VIA)) {
         if (!strncasecmp(agent, "Mozilla/3.", 10))
             return 0;
 
@@ -332,15 +332,15 @@ httpMsgIsPersistent(HttpVersion const &http_ver, const HttpHeader * hdr)
 void HttpMsg::packInto(Packer *p, bool full_uri) const
 {
     packFirstLineInto(p, full_uri);
-    httpHeaderPackInto(&header, p);
+    header.packInto(p);
     packerAppend(p, "\r\n", 2);
 }
 
 void HttpMsg::hdrCacheInit()
 {
-    content_length = httpHeaderGetInt(&header, HDR_CONTENT_LENGTH);
+    content_length = header.getInt(HDR_CONTENT_LENGTH);
     assert(NULL == cache_control);
-    cache_control = httpHeaderGetCc(&header);
+    cache_control = header.getCc();
 }
 
 /*
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpReply.cc,v 1.85 2006/05/05 23:57:40 wessels Exp $
+ * $Id: HttpReply.cc,v 1.86 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 58    HTTP Reply (Response)
  * AUTHOR: Alex Rousskov
@@ -124,7 +124,7 @@ void
 HttpReply::packHeadersInto(Packer * p) const
 {
     httpStatusLinePackInto(&sline, p);
-    httpHeaderPackInto(&header, p);
+    header.packInto(p);
     packerAppend(p, "\r\n", 2);
 }
 
@@ -182,8 +182,8 @@ HttpReply::make304 () const
                       HTTP_NOT_MODIFIED, "");
 
     for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
-        if ((e = httpHeaderFindEntry(&header, ImsEntries[t])))
-            httpHeaderAddEntry(&rv->header, httpHeaderEntryClone(e));
+        if ((e = header.findEntry(ImsEntries[t])))
+            rv->header.addEntry(httpHeaderEntryClone(e));
 
     /* rv->body */
     return rv;
@@ -208,24 +208,24 @@ HttpReply::setHeaders(HttpVersion ver, http_status status, const char *reason,
     HttpHeader *hdr;
     httpStatusLineSet(&sline, ver, status, reason);
     hdr = &header;
-    httpHeaderPutStr(hdr, HDR_SERVER, visible_appname_string);
-    httpHeaderPutStr(hdr, HDR_MIME_VERSION, "1.0");
-    httpHeaderPutTime(hdr, HDR_DATE, squid_curtime);
+    hdr->putStr(HDR_SERVER, visible_appname_string);
+    hdr->putStr(HDR_MIME_VERSION, "1.0");
+    hdr->putTime(HDR_DATE, squid_curtime);
 
     if (ctype) {
-        httpHeaderPutStr(hdr, HDR_CONTENT_TYPE, ctype);
+        hdr->putStr(HDR_CONTENT_TYPE, ctype);
         content_type = ctype;
     } else
         content_type = String();
 
     if (clen >= 0)
-        httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, clen);
+        hdr->putInt(HDR_CONTENT_LENGTH, clen);
 
     if (expires >= 0)
-        httpHeaderPutTime(hdr, HDR_EXPIRES, expires);
+        hdr->putTime(HDR_EXPIRES, expires);
 
     if (lmt > 0)		/* this used to be lmt != 0 @?@ */
-        httpHeaderPutTime(hdr, HDR_LAST_MODIFIED, lmt);
+        hdr->putTime(HDR_LAST_MODIFIED, lmt);
 
     date = squid_curtime;
 
@@ -243,10 +243,10 @@ HttpReply::redirect(http_status status, const char *loc)
     HttpVersion ver(1,0);
     httpStatusLineSet(&sline, ver, status, httpStatusString(status));
     hdr = &header;
-    httpHeaderPutStr(hdr, HDR_SERVER, full_appname_string);
-    httpHeaderPutTime(hdr, HDR_DATE, squid_curtime);
-    httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, 0);
-    httpHeaderPutStr(hdr, HDR_LOCATION, loc);
+    hdr->putStr(HDR_SERVER, full_appname_string);
+    hdr->putTime(HDR_DATE, squid_curtime);
+    hdr->putInt(HDR_CONTENT_LENGTH, 0);
+    hdr->putStr(HDR_LOCATION, loc);
     date = squid_curtime;
     content_length = 0;
 }
@@ -270,9 +270,9 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
         return 0;
 
     /* ETag */
-    one = httpHeaderGetStrOrList(&header, HDR_ETAG);
+    one = header.getStrOrList(HDR_ETAG);
 
-    two = httpHeaderGetStrOrList(&otherRep->header, HDR_ETAG);
+    two = otherRep->header.getStrOrList(HDR_ETAG);
 
     if (!one.buf() || !two.buf() || strcasecmp (one.buf(), two.buf())) {
         one.clean();
@@ -284,9 +284,9 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
         return 0;
 
     /* MD5 */
-    one = httpHeaderGetStrOrList(&header, HDR_CONTENT_MD5);
+    one = header.getStrOrList(HDR_CONTENT_MD5);
 
-    two = httpHeaderGetStrOrList(&otherRep->header, HDR_CONTENT_MD5);
+    two = otherRep->header.getStrOrList(HDR_CONTENT_MD5);
 
     if (!one.buf() || !two.buf() || strcasecmp (one.buf(), two.buf())) {
         one.clean();
@@ -306,8 +306,8 @@ HttpReply::updateOnNotModified(HttpReply const * freshRep)
     /* clean cache */
     hdrCacheClean();
     /* update raw headers */
-    httpHeaderUpdate(&header, &freshRep->header,
-                     (const HttpHeaderMask *) &Denied304HeadersMask);
+    header.update(&freshRep->header,
+                  (const HttpHeaderMask *) &Denied304HeadersMask);
     /* init cache */
     hdrCacheInit();
 }
@@ -341,16 +341,16 @@ HttpReply::hdrExpirationTime()
     }
 
     if (Config.onoff.vary_ignore_expire &&
-            httpHeaderHas(&header, HDR_VARY)) {
-        const time_t d = httpHeaderGetTime(&header, HDR_DATE);
-        const time_t e = httpHeaderGetTime(&header, HDR_EXPIRES);
+            header.has(HDR_VARY)) {
+        const time_t d = header.getTime(HDR_DATE);
+        const time_t e = header.getTime(HDR_EXPIRES);
 
         if (d == e)
             return -1;
     }
 
-    if (httpHeaderHas(&header, HDR_EXPIRES)) {
-        const time_t e = httpHeaderGetTime(&header, HDR_EXPIRES);
+    if (header.has(HDR_EXPIRES)) {
+        const time_t e = header.getTime(HDR_EXPIRES);
         /*
          * HTTP/1.0 says that robust implementations should consider
          * bad or malformed Expires header as equivalent to "expires
@@ -368,13 +368,13 @@ HttpReply::hdrCacheInit()
 {
     HttpMsg::hdrCacheInit();
 
-    content_length = httpHeaderGetInt(&header, HDR_CONTENT_LENGTH);
-    date = httpHeaderGetTime(&header, HDR_DATE);
-    last_modified = httpHeaderGetTime(&header, HDR_LAST_MODIFIED);
-    surrogate_control = httpHeaderGetSc(&header);
-    content_range = httpHeaderGetContRange(&header);
+    content_length = header.getInt(HDR_CONTENT_LENGTH);
+    date = header.getTime(HDR_DATE);
+    last_modified = header.getTime(HDR_LAST_MODIFIED);
+    surrogate_control = header.getSc();
+    content_range = header.getContRange();
     keep_alive = httpMsgIsPersistent(sline.version, &header);
-    const char *str = httpHeaderGetStr(&header, HDR_CONTENT_TYPE);
+    const char *str = header.getStr(HDR_CONTENT_TYPE);
 
     if (str)
         content_type.limitInit(str, strcspn(str, ";\t "));
@@ -481,7 +481,7 @@ HttpReply::expectingBody(method_t req_method, ssize_t& theSize) const
         expectBody = true;
 
     if (expectBody) {
-        if (httpHeaderHasListMember(&header, HDR_TRANSFER_ENCODING, "chunked", ','))
+        if (header.hasListMember(HDR_TRANSFER_ENCODING, "chunked", ','))
             theSize = -1;
         else if (content_length >= 0)
             theSize = content_length;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpRequest.cc,v 1.64 2006/05/05 23:57:40 wessels Exp $
+ * $Id: HttpRequest.cc,v 1.65 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 73    HTTP Request
  * AUTHOR: Duane Wessels
@@ -215,7 +215,7 @@ HttpRequest::parseHeader(const char *parse_start)
     if (!httpMsgIsolateHeaders(&parse_start, &blk_start, &blk_end))
         return 0;
 
-    int result = httpHeaderParse(&header, blk_start, blk_end);
+    int result = header.parse(blk_start, blk_end);
 
     if (result)
         hdrCacheInit();
@@ -243,7 +243,7 @@ HttpRequest::pack(Packer * p)
     packerPrintf(p, "%s %s HTTP/1.0\r\n",
                  RequestMethodStr[method], urlpath.buf());
     /* headers */
-    httpHeaderPackInto(&header, p);
+    header.packInto(p);
     /* trailer */
     packerAppend(p, "\r\n", 2);
 }
@@ -290,7 +290,7 @@ HttpRequest::hdrCacheInit()
 {
     HttpMsg::hdrCacheInit();
 
-    range = httpHeaderGetRange(&header);
+    range = header.getRange();
 }
 
 /* request_flags */
@@ -370,15 +370,15 @@ HttpRequest::expectingBody(method_t unused, ssize_t& theSize) const
         expectBody = Config.onoff.request_entities ? true : false;
     else if (method == METHOD_PUT || method == METHOD_POST)
         expectBody = true;
-    else if (httpHeaderHasListMember(&header, HDR_TRANSFER_ENCODING, "chunked", ','))
+    else if (header.hasListMember(HDR_TRANSFER_ENCODING, "chunked", ','))
         expectBody = true;
     else if (content_length >= 0)
         expectBody = true;
     else
         expectBody = false;
 
     if (expectBody) {
-        if (httpHeaderHasListMember(&header, HDR_TRANSFER_ENCODING, "chunked", ','))
+        if (header.hasListMember(HDR_TRANSFER_ENCODING, "chunked", ','))
             theSize = -1;
         else if (content_length >= 0)
             theSize = content_length;
@@ -1119,8 +1119,8 @@ void ICAPModXact::fillDoneStatus(MemBuf &buf) const
 
 bool ICAPModXact::gotEncapsulated(const char *section) const
 {
-    return httpHeaderGetByNameListMember(&icapReply->header, "Encapsulated",
-                                         section, ',').size() > 0;
+    return icapReply->header.getByNameListMember("Encapsulated",
+            section, ',').size() > 0;
 }
 
 // calculate whether there is a virgin HTTP body and
@@ -66,7 +66,7 @@ void ICAPOptions::insertTransferExt(const char *t, transfer_type t_type)
 
 void ICAPOptions::cfgTransferListHeader(const HttpHeader *h, const char *fname, transfer_type t_type)
 {
-    const String s = httpHeaderGetByName(h, fname);
+    const String s = h->getByName(fname);
 
     if (!s.size())
         return;
@@ -134,19 +134,19 @@ void ICAPOptions::configure(const HttpReply *reply)
         error = "unsupported status code of OPTIONS response";
 
     // Methods
-    if (httpHeaderHasByNameListMember(h, "Methods", "REQMOD", ','))
+    if (h->hasByNameListMember("Methods", "REQMOD", ','))
         cfgMethod(ICAP::methodReqmod);
 
-    if (httpHeaderHasByNameListMember(h, "Methods", "RESPMOD", ','))
+    if (h->hasByNameListMember("Methods", "RESPMOD", ','))
         cfgMethod(ICAP::methodRespmod);
 
-    service = httpHeaderGetByName(h, "Service");
+    service = h->getByName("Service");
 
-    serviceId = httpHeaderGetByName(h, "ServiceId");
+    serviceId = h->getByName("ServiceId");
 
-    istag = httpHeaderGetByName(h, "ISTag");
+    istag = h->getByName("ISTag");
 
-    if (httpHeaderGetByName(h, "Opt-body-type").size())
+    if (h->getByName("Opt-body-type").size())
         error = "ICAP service returns unsupported OPTIONS body";
 
     cfgIntHeader(h, "Max-Connections", max_connections);
@@ -156,12 +156,12 @@ void ICAPOptions::configure(const HttpReply *reply)
     if (theTTL < 0)
         theTTL = TheICAPConfig.default_options_ttl;
 
-    theTimestamp = httpHeaderGetTime(h, HDR_DATE);
+    theTimestamp = h->getTime(HDR_DATE);
 
     if (theTimestamp < 0)
         theTimestamp = squid_curtime;
 
-    if (httpHeaderHasListMember(h, HDR_ALLOW, "204", ','))
+    if (h->hasListMember(HDR_ALLOW, "204", ','))
         allow204 = true;
 
     cfgIntHeader(h, "Preview", preview);
@@ -182,7 +182,7 @@ void ICAPOptions::cfgMethod(ICAP::Method m)
 // TODO: HttpHeader should provide a general method for this type of conversion
 void ICAPOptions::cfgIntHeader(const HttpHeader *h, const char *fname, int &value)
 {
-    const String s = httpHeaderGetByName(h, fname);
+    const String s = h->getByName(fname);
 
     if (s.size() && xisdigit(*s.buf()))
         value = atoi(s.buf());
@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.110 2006/02/19 11:21:07 serassio Exp $
+ * $Id: access_log.cc,v 1.111 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -611,7 +611,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
         case LFT_REQUEST_HEADER:
 
             if (al->request)
-                sb = httpHeaderGetByName(&al->request->header, fmt->data.header.header);
+                sb = al->request->header.getByName(fmt->data.header.header);
 
             out = sb.buf();
 
@@ -621,7 +621,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_REPLY_HEADER:
             if (al->reply)
-                sb = httpHeaderGetByName(&al->reply->header, fmt->data.header.header);
+                sb = al->request->header.getByName(fmt->data.header.header);
 
             out = sb.buf();
 
@@ -631,7 +631,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_REQUEST_HEADER_ELEM:
             if (al->request)
-                sb = httpHeaderGetByNameListMember(&al->request->header, fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
+                sb = al->request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.buf();
 
@@ -641,7 +641,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_REPLY_HEADER_ELEM:
             if (al->reply)
-                sb = httpHeaderGetByNameListMember(&al->reply->header, fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
+                sb = al->request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.buf();
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_digest.cc,v 1.44 2006/04/23 11:10:33 robertc Exp $
+ * $Id: auth_digest.cc,v 1.45 2006/05/06 22:13:19 wessels Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Robert Collins
@@ -639,7 +639,7 @@ AuthDigestUserRequest::authenticate(HttpRequest * request, ConnStateData::Pointe
                 digest_request->setDenyMessage("Incorrect password");
                 return;
             } else {
-                const char *useragent = httpHeaderGetStr(&request->header, HDR_USER_AGENT);
+                const char *useragent = request->header.getStr(HDR_USER_AGENT);
 
                 static struct IN_ADDR last_broken_addr;
                 static int seen_broken_client = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_negotiate.cc,v 1.7 2006/04/23 11:10:33 robertc Exp $
+ * $Id: auth_negotiate.cc,v 1.8 2006/05/06 22:13:19 wessels Exp $
  *
  * DEBUG: section 29    Negotiate Authenticator
  * AUTHOR: Robert Collins, Henrik Nordstrom, Francesco Chemolli
@@ -311,7 +311,7 @@ AuthNegotiateConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply
 
         if (!keep_alive) {
             /* drop the connection */
-            httpHeaderDelByName(&rep->header, "keep-alive");
+            rep->header.delByName("keep-alive");
             request->flags.proxy_keepalive = 0;
         }
     } else {
@@ -322,7 +322,7 @@ AuthNegotiateConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply
         case AUTHENTICATE_STATE_FAILED:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            httpHeaderDelByName(&rep->header, "keep-alive");
+            rep->header.delByName("keep-alive");
             request->flags.proxy_keepalive = 0;
             /* fall through */
 
@@ -675,7 +675,7 @@ AuthNegotiateUserRequest::authenticate(HttpRequest * request, ConnStateData::Poi
     }
 
     /* get header */
-    proxy_auth = httpHeaderGetStr(&request->header, type);
+    proxy_auth = request->header.getStr(type);
 
     /* locate second word */
     blob = proxy_auth;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_ntlm.cc,v 1.56 2006/04/23 11:10:34 robertc Exp $
+ * $Id: auth_ntlm.cc,v 1.57 2006/05/06 22:13:19 wessels Exp $
  *
  * DEBUG: section 29    NTLM Authenticator
  * AUTHOR: Robert Collins, Henrik Nordstrom, Francesco Chemolli
@@ -286,7 +286,7 @@ AuthNTLMConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply *rep
 
         if (!keep_alive) {
             /* drop the connection */
-            httpHeaderDelByName(&rep->header, "keep-alive");
+            rep->header.delByName("keep-alive");
             request->flags.proxy_keepalive = 0;
         }
     } else {
@@ -297,7 +297,7 @@ AuthNTLMConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply *rep
         case AUTHENTICATE_STATE_FAILED:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            httpHeaderDelByName(&rep->header, "keep-alive");
+            rep->header.delByName("keep-alive");
             request->flags.proxy_keepalive = 0;
             /* fall through */
 
@@ -605,7 +605,7 @@ AuthNTLMUserRequest::authenticate(HttpRequest * request, ConnStateData::Pointer
     }
 
     /* get header */
-    proxy_auth = httpHeaderGetStr(&request->header, type);
+    proxy_auth = request->header.getStr(type);
 
     /* locate second word */
     blob = proxy_auth;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_manager.cc,v 1.38 2006/04/23 11:10:31 robertc Exp $
+ * $Id: cache_manager.cc,v 1.39 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 16    Cache Manager Objects
  * AUTHOR: Duane Wessels
@@ -181,7 +181,7 @@ cachemgrParseHeaders(cachemgrStateData * mgr, const HttpRequest * request)
     const char *basic_cookie;	/* base 64 _decoded_ user:passwd pair */
     const char *passwd_del;
     assert(mgr && request);
-    basic_cookie = httpHeaderGetAuth(&request->header, HDR_AUTHORIZATION, "Basic");
+    basic_cookie = request->header.getAuth(HDR_AUTHORIZATION, "Basic");
 
     if (!basic_cookie)
         return;
@@ -293,7 +293,7 @@ cachemgrStart(int fd, HttpRequest * request, StoreEntry * entry)
          * add Authenticate header, use 'action' as a realm because
          * password depends on action
          */
-        httpHeaderPutAuth(&rep->header, "Basic", mgr->action);
+        rep->header.putAuth("Basic", mgr->action);
 
         /* store the reply */
         entry->replaceHttpReply(rep);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.721 2006/05/05 23:57:40 wessels Exp $
+ * $Id: client_side.cc,v 1.722 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -456,7 +456,7 @@ clientPrepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogE
         MemBuf mb;
         mb.init();
         packerToMemInit(&p, &mb);
-        httpHeaderPackInto(&request->header, &p);
+        request->header.packInto(&p);
         aLogEntry->headers.request = xstrdup(mb.buf);
         packerClean(&p);
         mb.clean();
@@ -854,14 +854,14 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
 
     /* stuff the header with required entries and pack it */
 
-    if (httpHeaderHas(&rep->header, HDR_CONTENT_TYPE))
-        httpHeaderPutStr(&hdr, HDR_CONTENT_TYPE, httpHeaderGetStr(&rep->header, HDR_CONTENT_TYPE));
+    if (rep->header.has(HDR_CONTENT_TYPE))
+        hdr.putStr(HDR_CONTENT_TYPE, rep->header.getStr(HDR_CONTENT_TYPE));
 
     httpHeaderAddContRange(&hdr, *spec, rep->content_length);
 
     packerToMemInit(&p, mb);
 
-    httpHeaderPackInto(&hdr, &p);
+    hdr.packInto(&p);
 
     packerClean(&p);
 
@@ -1009,15 +1009,15 @@ ClientHttpRequest::mRangeCLen()
 static int
 clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
 {
-    const TimeOrTag spec = httpHeaderGetTimeOrTag(&http->request->header, HDR_IF_RANGE);
+    const TimeOrTag spec = http->request->header.getTimeOrTag(HDR_IF_RANGE);
     /* check for parsing falure */
 
     if (!spec.valid)
         return 0;
 
     /* got an ETag? */
     if (spec.tag.str) {
-        ETag rep_tag = httpHeaderGetETag(&rep->header, HDR_ETAG);
+        ETag rep_tag = rep->header.getETag(HDR_ETAG);
         debug(33, 3) ("clientIfRangeMatch: ETags: %s and %s\n",
                       spec.tag.str, rep_tag.str ? rep_tag.str : "<none>");
 
@@ -1073,7 +1073,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
 
 #if 0
 
-    else if (httpHeaderHas(hdr, HDR_CONTENT_RANGE))
+    else if (hdr->has(HDR_CONTENT_RANGE))
         range_err = "origin server does ranges";
 
 #endif
@@ -1086,7 +1086,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     /* hits only - upstream peer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates 
      */
-    else if (logTypeIsATcpHit(http->logType) && httpHeaderHas(&http->request->header, HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
+    else if (logTypeIsATcpHit(http->logType) && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
         range_err = "If-Range match failed";
     else if (!http->request->range->canonize(rep))
         range_err = "canonization failed";
@@ -1120,15 +1120,15 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
                       spec_count, rep->content_length);
         assert(spec_count > 0);
         /* ETags should not be returned with Partial Content replies? */
-        httpHeaderDelById(hdr, HDR_ETAG);
+        hdr->delById(HDR_ETAG);
         /* append appropriate header(s) */
 
         if (spec_count == 1) {
             HttpHdrRange::iterator pos = http->request->range->begin();
             assert(*pos);
             /* append Content-Range */
 
-            if (!httpHeaderHas(hdr, HDR_CONTENT_RANGE)) {
+            if (!hdr->has(HDR_CONTENT_RANGE)) {
                 /* No content range, so this was a full object we are
                  * sending parts of.
                  */
@@ -1143,7 +1143,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
             /* generate boundary string */
             http->range_iter.boundary = http->rangeBoundaryStr();
             /* delete old Content-Type, add ours */
-            httpHeaderDelById(hdr, HDR_CONTENT_TYPE);
+            hdr->delById(HDR_CONTENT_TYPE);
             httpHeaderPutStrf(hdr, HDR_CONTENT_TYPE,
                               "multipart/byteranges; boundary=\"%s\"",
                               http->range_iter.boundary.buf());
@@ -1157,9 +1157,9 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         /* replace Content-Length header */
         assert(actual_clen >= 0);
 
-        httpHeaderDelById(hdr, HDR_CONTENT_LENGTH);
+        hdr->delById(HDR_CONTENT_LENGTH);
 
-        httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, actual_clen);
+        hdr->putInt(HDR_CONTENT_LENGTH, actual_clen);
 
         debug(33, 3) ("clientBuildRangeHeader: actual content length: %d\n", actual_clen);
 
@@ -2270,7 +2270,7 @@ clientProcessRequest(ConnStateData::Pointer &conn, ClientSocketContext *context,
     request->http_ver = http_ver;
 
     if (!urlCheckRequest(request) ||
-            httpHeaderHas(&request->header, HDR_TRANSFER_ENCODING)) {
+            request->header.has(HDR_TRANSFER_ENCODING)) {
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
@@ -3119,11 +3119,11 @@ int
 varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
 {
     const char *vary = request->vary_headers;
-    int has_vary = httpHeaderHas(&entry->getReply()->header, HDR_VARY);
+    int has_vary = entry->getReply()->header.has(HDR_VARY);
 #if X_ACCELERATOR_VARY
 
     has_vary |=
-        httpHeaderHas(&entry->getReply()->header, HDR_X_ACCELERATOR_VARY);
+        entry->getReply()->header.has(HDR_X_ACCELERATOR_VARY);
 #endif
 
     if (!has_vary || !entry->mem_obj->vary_headers) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_reply.cc,v 1.102 2006/05/05 23:36:40 wessels Exp $
+ * $Id: client_side_reply.cc,v 1.103 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 88    Client-side Reply Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -1304,17 +1304,17 @@ clientReplyContext::buildReplyHeader()
     HttpRequest *request = http->request;
 #if DONT_FILTER_THESE
     /* but you might want to if you run Squid as an HTTP accelerator */
-    /* httpHeaderDelById(hdr, HDR_ACCEPT_RANGES); */
-    httpHeaderDelById(hdr, HDR_ETAG);
+    /* hdr->delById(HDR_ACCEPT_RANGES); */
+    hdr->delById(HDR_ETAG);
 #endif
 
-    httpHeaderDelById(hdr, HDR_PROXY_CONNECTION);
+    hdr->delById(HDR_PROXY_CONNECTION);
     /* here: Keep-Alive is a field-name, not a connection directive! */
-    httpHeaderDelByName(hdr, "Keep-Alive");
+    hdr->delByName("Keep-Alive");
     /* remove Set-Cookie if a hit */
 
     if (is_hit)
-        httpHeaderDelById(hdr, HDR_SET_COOKIE);
+        hdr->delById(HDR_SET_COOKIE);
 
     /*
      * Be sure to obey the Connection header 
@@ -1332,7 +1332,7 @@ clientReplyContext::buildReplyHeader()
          * (note that the existing header is passed along unmodified
          * on cache misses)
          */
-        httpHeaderDelById(hdr, HDR_AGE);
+        hdr->delById(HDR_AGE);
         /*
          * This adds the calculated object age. Note that the details of the
          * age calculation is performed by adjusting the timestamp in
@@ -1351,11 +1351,11 @@ clientReplyContext::buildReplyHeader()
             (void) 0;
 
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
-            httpHeaderDelById(hdr, HDR_DATE);
-            httpHeaderInsertTime(hdr, HDR_DATE, squid_curtime);
+            hdr->delById(HDR_DATE);
+            hdr->insertTime(HDR_DATE, squid_curtime);
         } else if (http->storeEntry()->timestamp < squid_curtime) {
-            httpHeaderPutInt(hdr, HDR_AGE,
-                             squid_curtime - http->storeEntry()->timestamp);
+            hdr->putInt(HDR_AGE,
+                        squid_curtime - http->storeEntry()->timestamp);
             /* Signal old objects.  NB: rfc 2616 is not clear,
              * by implication, on whether we should do this to all
              * responses, or only cache hits.
@@ -1370,19 +1370,19 @@ clientReplyContext::buildReplyHeader()
                 snprintf (tempbuf, sizeof(tempbuf), "%s %s %s",
                           "113", ThisCache,
                           "This cache hit is still fresh and more than 1 day old");
-                httpHeaderPutStr(hdr, HDR_WARNING, tempbuf);
+                hdr->putStr(HDR_WARNING, tempbuf);
             }
         }
 
     }
 
     /* Filter unproxyable authentication types */
     if (http->logType != LOG_TCP_DENIED &&
-            (httpHeaderHas(hdr, HDR_WWW_AUTHENTICATE) || httpHeaderHas(hdr, HDR_PROXY_AUTHENTICATE))) {
+            (hdr->has(HDR_WWW_AUTHENTICATE) || hdr->has(HDR_PROXY_AUTHENTICATE))) {
         HttpHeaderPos pos = HttpHeaderInitPos;
         HttpHeaderEntry *e;
 
-        while ((e = httpHeaderGetEntry(hdr, &pos))) {
+        while ((e = hdr->getEntry(&pos))) {
             if (e->id == HDR_WWW_AUTHENTICATE || e->id == HDR_PROXY_AUTHENTICATE) {
                 const char *value = e->value.buf();
 
@@ -1391,7 +1391,7 @@ clientReplyContext::buildReplyHeader()
                         ||
                         (strncasecmp(value, "Negotiate", 9) == 0 &&
                          (value[9] == '\0' || value[9] == ' ')))
-                    httpHeaderDelAt(hdr, pos);
+                    hdr->delAt(pos);
             }
         }
     }
@@ -1436,20 +1436,19 @@ clientReplyContext::buildReplyHeader()
     /* Append VIA */
     {
         LOCAL_ARRAY(char, bbuf, MAX_URL + 32);
-        String strVia = httpHeaderGetList(hdr, HDR_VIA);
+        String strVia = hdr->getList(HDR_VIA);
         snprintf(bbuf, sizeof(bbuf), "%d.%d %s",
                  reply->sline.version.major,
                  reply->sline.version.minor,
                  ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        httpHeaderDelById(hdr, HDR_VIA);
-        httpHeaderPutStr(hdr, HDR_VIA, strVia.buf());
+        hdr->delById(HDR_VIA);
+        hdr->putStr(HDR_VIA, strVia.buf());
         strVia.clean();
     }
     /* Signal keep-alive if needed */
-    httpHeaderPutStr(hdr,
-                     http->flags.accel ? HDR_CONNECTION : HDR_PROXY_CONNECTION,
-                     request->flags.proxy_keepalive ? "keep-alive" : "close");
+    hdr->putStr(http->flags.accel ? HDR_CONNECTION : HDR_PROXY_CONNECTION,
+                request->flags.proxy_keepalive ? "keep-alive" : "close");
 
 #if ADD_X_REQUEST_URI
     /*
@@ -1458,8 +1457,8 @@ clientReplyContext::buildReplyHeader()
      * but X-Request-URI is likely to be the very last header to ease use from a
      * debugger [hdr->entries.count-1].
      */
-    httpHeaderPutStr(hdr, HDR_X_REQUEST_URI,
-                     http->memOjbect()->url ? http->memObject()->url : http->uri);
+    hdr->putStr(HDR_X_REQUEST_URI,
+                http->memOjbect()->url ? http->memObject()->url : http->uri);
 
 #endif
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_request.cc,v 1.63 2006/05/03 14:04:44 robertc Exp $
+ * $Id: client_side_request.cc,v 1.64 2006/05/06 22:13:18 wessels Exp $
  * 
  * DEBUG: section 85    Client-side Request Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -317,7 +317,7 @@ clientBeginRequest(method_t method, char const *url, CSCB * streamcallback,
      * correctness.
      */
     if (header)
-        httpHeaderUpdate(&request->header, header, NULL);
+        request->header.update(header, NULL);
 
     http->log_uri = xstrdup(urlCanonicalClean(request));
 
@@ -661,7 +661,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 #endif
 
     request->imslen = -1;
-    request->ims = httpHeaderGetTime(req_hdr, HDR_IF_MODIFIED_SINCE);
+    request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
         request->flags.ims = 1;
@@ -673,8 +673,8 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
      */
 #else
 
-    if (httpHeaderHas(req_hdr, HDR_PRAGMA)) {
-        String s = httpHeaderGetList(req_hdr, HDR_PRAGMA);
+    if (req_hdr->has(HDR_PRAGMA)) {
+        String s = req_hdr->getList(HDR_PRAGMA);
 
         if (strListIsMember(&s, "no-cache", ','))
             no_cache++;
@@ -695,7 +695,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     */
     if (Config.onoff.ie_refresh) {
         if (http->flags.accel && request->flags.ims) {
-            if ((str = httpHeaderGetStr(req_hdr, HDR_USER_AGENT))) {
+            if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
                 if (strstr(str, "MSIE 5.01") != NULL)
                     no_cache++;
                 else if (strstr(str, "MSIE 5.0") != NULL)
@@ -724,7 +724,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 
     /* ignore range header in non-GETs */
     if (request->method == METHOD_GET) {
-        request->range = httpHeaderGetRange(req_hdr);
+        request->range = req_hdr->getRange();
 
         if (request->range) {
             request->flags.range = 1;
@@ -742,14 +742,14 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         }
     }
 
-    if (httpHeaderHas(req_hdr, HDR_AUTHORIZATION))
+    if (req_hdr->has(HDR_AUTHORIZATION))
         request->flags.auth = 1;
 
     if (request->login[0] != '\0')
         request->flags.auth = 1;
 
-    if (httpHeaderHas(req_hdr, HDR_VIA)) {
-        String s = httpHeaderGetList(req_hdr, HDR_VIA);
+    if (req_hdr->has(HDR_VIA)) {
+        String s = req_hdr->getList(HDR_VIA);
         /*
          * ThisCache cannot be a member of Via header, "1.0 ThisCache" can.
          * Note ThisCache2 has a space prepended to the hostname so we don't
@@ -771,27 +771,27 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     }
 
 #if USE_USERAGENT_LOG
-    if ((str = httpHeaderGetStr(req_hdr, HDR_USER_AGENT)))
+    if ((str = req_hdr->getStr(HDR_USER_AGENT)))
         logUserAgent(fqdnFromAddr(http->getConn().getRaw() ? http->getConn()->log_addr : no_addr), str);
 
 #endif
 #if USE_REFERER_LOG
 
-    if ((str = httpHeaderGetStr(req_hdr, HDR_REFERER)))
+    if ((str = req_hdr->getStr(HDR_REFERER)))
         logReferer(fqdnFromAddr(http->getConn().getRaw() ? http->getConn()->log_addr : no_addr), str, http->log_uri);
 
 #endif
 #if FORW_VIA_DB
 
-    if (httpHeaderHas(req_hdr, HDR_X_FORWARDED_FOR)) {
-        String s = httpHeaderGetList(req_hdr, HDR_X_FORWARDED_FOR);
+    if (req_hdr->has(HDR_X_FORWARDED_FOR)) {
+        String s = req_hdr->getList(HDR_X_FORWARDED_FOR);
         fvdbCountForw(s.buf());
         s.clean();
     }
 
 #endif
     if (request->method == METHOD_TRACE) {
-        request->max_forwards = httpHeaderGetInt(req_hdr, HDR_MAX_FORWARDS);
+        request->max_forwards = req_hdr->getInt(HDR_MAX_FORWARDS);
     }
 
     if (clientCachable(http))
@@ -854,7 +854,7 @@ ClientRequestContext::clientRedirectDone(char *result)
         safe_free(http->uri);
         http->uri = xstrdup(urlCanonical(new_request));
         new_request->http_ver = old_request->http_ver;
-        httpHeaderAppend(&new_request->header, &old_request->header);
+        new_request->header.append(&old_request->header);
         new_request->client_addr = old_request->client_addr;
         new_request->client_port = old_request->client_port;
         new_request->my_addr = old_request->my_addr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.210 2006/04/23 11:10:31 robertc Exp $
+ * $Id: errorpage.cc,v 1.211 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -530,7 +530,7 @@ errorDump(ErrorState * err, MemBuf * mb)
                    r->urlpath.size() ? r->urlpath.buf() : "/",
                    r->http_ver.major, r->http_ver.minor);
         packerToMemInit(&p, &str);
-        httpHeaderPackInto(&r->header, &p);
+        r->header.packInto(&p);
         packerClean(&p);
     } else if (err->request_hdrs) {
         p = err->request_hdrs;
@@ -735,7 +735,7 @@ errorConvert(char token, ErrorState * err)
                       r->urlpath.size() ? r->urlpath.buf() : "/",
                       r->http_ver.major, r->http_ver.minor);
             packerToMemInit(&p, &mb);
-            httpHeaderPackInto(&r->header, &p);
+            r->header.packInto(&p);
             packerClean(&p);
         } else if (err->request_hdrs) {
             p = err->request_hdrs;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: external_acl.cc,v 1.68 2006/04/23 11:10:31 robertc Exp $
+ * $Id: external_acl.cc,v 1.69 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 82    External ACL
  * AUTHOR: Henrik Nordstrom, MARA Systems AB
@@ -807,22 +807,22 @@ makeExternalAclKey(ACLChecklist * ch, external_acl_data * acl_data)
             break;
 
         case _external_acl_format::EXT_ACL_HEADER:
-            sb = httpHeaderGetByName(&request->header, format->header);
+            sb = request->header.getByName(format->header);
             str = sb.buf();
             break;
 
         case _external_acl_format::EXT_ACL_HEADER_ID:
-            sb = httpHeaderGetStrOrList(&request->header, format->header_id);
+            sb = request->header.getStrOrList(format->header_id);
             str = sb.buf();
             break;
 
         case _external_acl_format::EXT_ACL_HEADER_MEMBER:
-            sb = httpHeaderGetByNameListMember(&request->header, format->header, format->member, format->separator);
+            sb = request->header.getByNameListMember(format->header, format->member, format->separator);
             str = sb.buf();
             break;
 
         case _external_acl_format::EXT_ACL_HEADER_ID_MEMBER:
-            sb = httpHeaderGetListMember(&request->header, format->header_id, format->member, format->separator);
+            sb = request->header.getListMember(format->header_id, format->member, format->separator);
             str = sb.buf();
             break;
 #if USE_SSL
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.393 2006/05/05 23:12:11 wessels Exp $
+ * $Id: ftp.cc,v 1.394 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -1349,7 +1349,7 @@ FtpStateData::checkAuth(const HttpHeader * req_hdr)
         return 1;		/* passwd provided in URL */
 
     /* URL has name, but no passwd */
-    if (!(auth = httpHeaderGetAuth(req_hdr, HDR_AUTHORIZATION, "Basic")))
+    if (!(auth = req_hdr->getAuth(HDR_AUTHORIZATION, "Basic")))
         return 0;		/* need auth header */
 
     flags.authenticated = 1;
@@ -2541,7 +2541,7 @@ ftpSendStor(FtpStateData * ftpState)
         snprintf(cbuf, 1024, "STOR %s\r\n", ftpState->filepath);
         ftpState->writeCommand(cbuf);
         ftpState->state = SENT_STOR;
-    } else if (httpHeaderGetInt(&ftpState->request->header, HDR_CONTENT_LENGTH) > 0) {
+    } else if (ftpState->request->header.getInt(HDR_CONTENT_LENGTH) > 0) {
         /* File upload without a filename. use STOU to generate one */
         snprintf(cbuf, 1024, "STOU\r\n");
         ftpState->writeCommand(cbuf);
@@ -3143,7 +3143,7 @@ FtpStateData::appendSuccessHeader()
 
     /* additional info */
     if (mime_enc)
-        httpHeaderPutStr(&reply->header, HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
 
 #if ICAP_CLIENT
 
@@ -3186,7 +3186,7 @@ FtpStateData::ftpAuthRequired(HttpRequest * request, const char *realm)
     HttpReply *newrep = errorBuildReply(err);
     errorStateFree(err);
     /* add Authenticate header */
-    httpHeaderPutAuth(&newrep->header, "Basic", realm);
+    newrep->header.putAuth("Basic", realm);
     return newrep;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.494 2006/05/05 23:57:40 wessels Exp $
+ * $Id: http.cc,v 1.495 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -445,8 +445,8 @@ HttpStateData::cacheableReply()
 
     /* Pragma: no-cache in _replies_ is not documented in HTTP,
      * but servers like "Active Imaging Webcast/2.0" sure do use it */
-    if (httpHeaderHas(hdr, HDR_PRAGMA)) {
-        String s = httpHeaderGetList(hdr, HDR_PRAGMA);
+    if (hdr->has(HDR_PRAGMA)) {
+        String s = hdr->getList(HDR_PRAGMA);
         const int no_cache = strListIsMember(&s, "no-cache", ',');
         s.clean();
 
@@ -468,7 +468,7 @@ HttpStateData::cacheableReply()
      * continuous push replies.  These are generally dynamic and
      * probably should not be cachable
      */
-    if ((v = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE)))
+    if ((v = hdr->getStr(HDR_CONTENT_TYPE)))
         if (!strncasecmp(v, "multipart/x-mixed-replace", 25))
             return 0;
 
@@ -596,7 +596,7 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
     static String vstr;
 
     vstr.clean();
-    vary = httpHeaderGetList(&reply->header, HDR_VARY);
+    vary = reply->header.getList(HDR_VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -611,7 +611,7 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
         }
 
         strListAdd(&vstr, name, ',');
-        hdr = httpHeaderGetByName(&request->header, name);
+        hdr = request->header.getByName(name);
         safe_free(name);
         value = hdr.buf();
 
@@ -629,14 +629,14 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
 #if X_ACCELERATOR_VARY
 
     pos = NULL;
-    vary = httpHeaderGetList(&reply->header, HDR_X_ACCELERATOR_VARY);
+    vary = reply->header.getList(HDR_X_ACCELERATOR_VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
         xstrncpy(name, item, ilen + 1);
         Tolower(name);
         strListAdd(&vstr, name, ',');
-        hdr = httpHeaderGetByName(&request->header, name);
+        hdr = request->header.getByName(name);
         safe_free(name);
         value = hdr.buf();
 
@@ -804,9 +804,9 @@ HttpStateData::haveParsedReplyHeaders()
     if (neighbors_do_private_keys)
         httpMaybeRemovePublic(entry, getReply()->sline.status);
 
-    if (httpHeaderHas(&getReply()->header, HDR_VARY)
+    if (getReply()->header.has(HDR_VARY)
 #if X_ACCELERATOR_VARY
-            || httpHeaderHas(&getReply()->header, HDR_X_ACCELERATOR_VARY)
+            || getReply()->header.has(HDR_X_ACCELERATOR_VARY)
 #endif
        ) {
         const char *vary = httpMakeVaryMark(orig_request, getReply());
@@ -1360,13 +1360,13 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     /* append our IMS header */
 
     if (request->lastmod > -1)
-        httpHeaderPutTime(hdr_out, HDR_IF_MODIFIED_SINCE, request->lastmod);
+        hdr_out->putTime(HDR_IF_MODIFIED_SINCE, request->lastmod);
 
     bool we_do_ranges = decideIfWeDoRanges (orig_request);
 
-    String strConnection (httpHeaderGetList(hdr_in, HDR_CONNECTION));
+    String strConnection (hdr_in->getList(HDR_CONNECTION));
 
-    while ((e = httpHeaderGetEntry(hdr_in, &pos)))
+    while ((e = hdr_in->getEntry(&pos)))
         copyOneHeaderFromClientsideRequestToUpstreamRequest(e, strConnection, request, orig_request, hdr_out, we_do_ranges, flags);
 
     /* Abstraction break: We should interpret multipart/byterange responses
@@ -1384,53 +1384,53 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     /* append Via */
     if (Config.onoff.via) {
         String strVia;
-        strVia = httpHeaderGetList(hdr_in, HDR_VIA);
+        strVia = hdr_in->getList(HDR_VIA);
         snprintf(bbuf, BBUF_SZ, "%d.%d %s",
                  orig_request->http_ver.major,
                  orig_request->http_ver.minor, ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        httpHeaderPutStr(hdr_out, HDR_VIA, strVia.buf());
+        hdr_out->putStr(HDR_VIA, strVia.buf());
         strVia.clean();
     }
 
 #if ESI
     {
         /* Append Surrogate-Capabilities */
-        String strSurrogate (httpHeaderGetList(hdr_in, HDR_SURROGATE_CAPABILITY));
+        String strSurrogate (hdr_in->getList(HDR_SURROGATE_CAPABILITY));
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0 ESI/1.0\"",
                  Config.Accel.surrogate_id);
         strListAdd(&strSurrogate, bbuf, ',');
-        httpHeaderPutStr(hdr_out, HDR_SURROGATE_CAPABILITY, strSurrogate.buf());
+        hdr_out->putStr(HDR_SURROGATE_CAPABILITY, strSurrogate.buf());
     }
 #endif
 
     /* append X-Forwarded-For */
-    strFwd = httpHeaderGetList(hdr_in, HDR_X_FORWARDED_FOR);
+    strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
 
     if (opt_forwarded_for && orig_request->client_addr.s_addr != no_addr.s_addr)
         strListAdd(&strFwd, inet_ntoa(orig_request->client_addr), ',');
     else
         strListAdd(&strFwd, "unknown", ',');
 
-    httpHeaderPutStr(hdr_out, HDR_X_FORWARDED_FOR, strFwd.buf());
+    hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.buf());
 
     strFwd.clean();
 
     /* append Host if not there already */
-    if (!httpHeaderHas(hdr_out, HDR_HOST)) {
+    if (!hdr_out->has(HDR_HOST)) {
         if (orig_request->peer_domain) {
-            httpHeaderPutStr(hdr_out, HDR_HOST, orig_request->peer_domain);
+            hdr_out->putStr(HDR_HOST, orig_request->peer_domain);
         } else if (orig_request->port == urlDefaultPort(orig_request->protocol)) {
             /* use port# only if not default */
-            httpHeaderPutStr(hdr_out, HDR_HOST, orig_request->host);
+            hdr_out->putStr(HDR_HOST, orig_request->host);
         } else {
             httpHeaderPutStrf(hdr_out, HDR_HOST, "%s:%d",
                               orig_request->host, (int) orig_request->port);
         }
     }
 
     /* append Authorization if known in URL, not in header and going direct */
-    if (!httpHeaderHas(hdr_out, HDR_AUTHORIZATION)) {
+    if (!hdr_out->has(HDR_AUTHORIZATION)) {
         if (!request->flags.proxying && *request->login) {
             httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
                               base64_encode(request->login));
@@ -1439,7 +1439,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Proxy-Authorization if configured for peer, and proxying */
     if (request->flags.proxying && orig_request->peer_login &&
-            !httpHeaderHas(hdr_out, HDR_PROXY_AUTHORIZATION)) {
+            !hdr_out->has(HDR_PROXY_AUTHORIZATION)) {
         if (*orig_request->peer_login == '*') {
             /* Special mode, to pass the username to the upstream cache */
             char loginbuf[256];
@@ -1471,17 +1471,17 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append WWW-Authorization if configured for peer */
     if (flags.originpeer && orig_request->peer_login &&
-            !httpHeaderHas(hdr_out, HDR_AUTHORIZATION)) {
+            !hdr_out->has(HDR_AUTHORIZATION)) {
         if (strcmp(orig_request->peer_login, "PASS") == 0) {
             /* No credentials to forward.. (should have been done above if available) */
         } else if (strcmp(orig_request->peer_login, "PROXYPASS") == 0) {
             /* Special mode, convert proxy authentication to WWW authentication
             * (also applies to authentication provided by external acl)
              */
-            const char *auth = httpHeaderGetStr(hdr_in, HDR_PROXY_AUTHORIZATION);
+            const char *auth = hdr_in->getStr(HDR_PROXY_AUTHORIZATION);
 
             if (auth && strncasecmp(auth, "basic ", 6) == 0) {
-                httpHeaderPutStr(hdr_out, HDR_AUTHORIZATION, auth);
+                hdr_out->putStr(HDR_AUTHORIZATION, auth);
             } else if (orig_request->extacl_user.size() && orig_request->extacl_passwd.size()) {
                 char loginbuf[256];
                 snprintf(loginbuf, sizeof(loginbuf), "%s:%s", orig_request->extacl_user.buf(), orig_request->extacl_passwd.buf());
@@ -1510,7 +1510,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     }
 
     /* append Cache-Control, add max-age if not there already */ {
-        HttpHdrCc *cc = httpHeaderGetCc(hdr_in);
+        HttpHdrCc *cc = hdr_in->getCc();
 
         if (!cc)
             cc = httpHdrCcCreate();
@@ -1525,31 +1525,31 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
         }
 
         /* Set no-cache if determined needed but not found */
-        if (orig_request->flags.nocache && !httpHeaderHas(hdr_in, HDR_PRAGMA))
+        if (orig_request->flags.nocache && !hdr_in->has(HDR_PRAGMA))
             EBIT_SET(cc->mask, CC_NO_CACHE);
 
         /* Enforce sibling relations */
         if (flags.only_if_cached)
             EBIT_SET(cc->mask, CC_ONLY_IF_CACHED);
 
-        httpHeaderPutCc(hdr_out, cc);
+        hdr_out->putCc(cc);
 
         httpHdrCcDestroy(cc);
     }
 
     /* maybe append Connection: keep-alive */
     if (flags.keepalive) {
         if (flags.proxying) {
-            httpHeaderPutStr(hdr_out, HDR_PROXY_CONNECTION, "keep-alive");
+            hdr_out->putStr(HDR_PROXY_CONNECTION, "keep-alive");
         } else {
-            httpHeaderPutStr(hdr_out, HDR_CONNECTION, "keep-alive");
+            hdr_out->putStr(HDR_CONNECTION, "keep-alive");
         }
     }
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
         if (flags.front_end_https == 1 || request->protocol == PROTO_HTTPS)
-            httpHeaderPutStr(hdr_out, HDR_FRONT_END_HTTPS, "On");
+            hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
     }
 
     /* Now mangle the headers. */
@@ -1580,7 +1580,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
         if (flags.proxying && orig_request->peer_login &&
                 (strcmp(orig_request->peer_login, "PASS") == 0 ||
                  strcmp(orig_request->peer_login, "PROXYPASS") == 0)) {
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+            hdr_out->addEntry(httpHeaderEntryClone(e));
         }
 
         break;
@@ -1589,7 +1589,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
         /* Pass on WWW authentication */
 
         if (!flags.originpeer) {
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+            hdr_out->addEntry(httpHeaderEntryClone(e));
         } else {
             /* In accelerators, only forward authentication if enabled
              * (see also below for proxy->server authentication)
@@ -1598,7 +1598,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
             if (orig_request->peer_login &&
                     (strcmp(orig_request->peer_login, "PASS") == 0 ||
                      strcmp(orig_request->peer_login, "PROXYPASS") == 0)) {
-                httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+                hdr_out->addEntry(httpHeaderEntryClone(e));
             }
         }
 
@@ -1613,12 +1613,12 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
          */
 
         if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+            hdr_out->addEntry(httpHeaderEntryClone(e));
         else {
             /* use port# only if not default */
 
             if (orig_request->port == urlDefaultPort(orig_request->protocol)) {
-                httpHeaderPutStr(hdr_out, HDR_HOST, orig_request->host);
+                hdr_out->putStr(HDR_HOST, orig_request->host);
             } else {
                 httpHeaderPutStrf(hdr_out, HDR_HOST, "%s:%d",
                                   orig_request->host, (int) orig_request->port);
@@ -1631,8 +1631,8 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
         /* append unless we added our own;
          * note: at most one client's ims header can pass through */
 
-        if (!httpHeaderHas(hdr_out, HDR_IF_MODIFIED_SINCE))
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+        if (!hdr_out->has(HDR_IF_MODIFIED_SINCE))
+            hdr_out->addEntry(httpHeaderEntryClone(e));
 
         break;
 
@@ -1641,7 +1641,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
             const int hops = httpHeaderEntryGetInt(e);
 
             if (hops > 0)
-                httpHeaderPutInt(hdr_out, HDR_MAX_FORWARDS, hops - 1);
+                hdr_out->putInt(HDR_MAX_FORWARDS, hops - 1);
         }
 
         break;
@@ -1650,7 +1650,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
         /* If Via is disabled then forward any received header as-is */
 
         if (!Config.onoff.via)
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+            hdr_out->addEntry(httpHeaderEntryClone(e));
 
         break;
 
@@ -1660,7 +1660,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
 
     case HDR_REQUEST_RANGE:
         if (!we_do_ranges)
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+            hdr_out->addEntry(httpHeaderEntryClone(e));
 
         break;
 
@@ -1676,13 +1676,13 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
 
     case HDR_FRONT_END_HTTPS:
         if (!flags.front_end_https)
-            httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+            hdr_out->addEntry(httpHeaderEntryClone(e));
 
         break;
 
     default:
         /* pass on all other header fields */
-        httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+        hdr_out->addEntry(httpHeaderEntryClone(e));
     }
 }
 
@@ -1732,7 +1732,7 @@ HttpStateData::buildRequestPrefix(HttpRequest * request,
         Packer p;
         httpBuildRequestHeader(request, orig_request, entry, &hdr, flags);
         packerToMemInit(&p, mb);
-        httpHeaderPackInto(&hdr, &p);
+        hdr.packInto(&p);
         hdr.clean();
         packerClean(&p);
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.125 2006/05/03 14:04:44 robertc Exp $
+ * $Id: mime.cc,v 1.126 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -589,7 +589,7 @@ MimeIcon::created (StoreEntry *newEntry)
 
     httpHdrCcSetMaxAge(reply->cache_control, 86400);
 
-    httpHeaderPutCc(&reply->header, reply->cache_control);
+    reply->header.putCc(reply->cache_control);
 
     e->replaceHttpReply(reply);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.111 2006/05/03 14:04:44 robertc Exp $
+ * $Id: peer_digest.cc,v 1.112 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -325,9 +325,9 @@ peerDigestRequest(PeerDigest * pd)
     /* add custom headers */
     assert(!req->header.len);
 
-    httpHeaderPutStr(&req->header, HDR_ACCEPT, StoreDigestMimeStr);
+    req->header.putStr(HDR_ACCEPT, StoreDigestMimeStr);
 
-    httpHeaderPutStr(&req->header, HDR_ACCEPT, "text/html");
+    req->header.putStr(HDR_ACCEPT, "text/html");
 
     if (p->login)
         xstrncpy(req->login, p->login, MAX_LOGIN_SZ);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.527 2006/05/05 23:57:40 wessels Exp $
+ * $Id: protos.h,v 1.528 2006/05/06 22:13:18 wessels Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -314,7 +314,6 @@ SQUIDCEXTERN int strListGetItem(const String * str, char del, const char **item,
 SQUIDCEXTERN const char *getStringPrefix(const char *str, const char *end);
 SQUIDCEXTERN int httpHeaderParseInt(const char *start, int *val);
 SQUIDCEXTERN int httpHeaderParseSize(const char *start, ssize_t * sz);
-SQUIDCEXTERN int httpHeaderReset(HttpHeader * hdr);
 #if STDC_HEADERS
 SQUIDCEXTERN void
 httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
@@ -326,50 +325,9 @@ SQUIDCEXTERN void httpHeaderPutStrf();
 /* Http Header */
 SQUIDCEXTERN void httpHeaderInitModule(void);
 SQUIDCEXTERN void httpHeaderCleanModule(void);
-/* append/update */
-SQUIDCEXTERN void httpHeaderAppend(HttpHeader * dest, const HttpHeader * src);
-/* parse/pack */
-SQUIDCEXTERN int httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_end);
-SQUIDCEXTERN void httpHeaderPackInto(const HttpHeader * hdr, Packer * p);
-/* field manipulation */
-SQUIDCEXTERN int httpHeaderHas(const HttpHeader * hdr, http_hdr_type type);
-SQUIDCEXTERN void httpHeaderPutInt(HttpHeader * hdr, http_hdr_type type, int number);
-SQUIDCEXTERN void httpHeaderPutTime(HttpHeader * hdr, http_hdr_type type, time_t htime);
-SQUIDCEXTERN void httpHeaderInsertTime(HttpHeader * hdr, http_hdr_type type, time_t htime);
-SQUIDCEXTERN void httpHeaderPutStr(HttpHeader * hdr, http_hdr_type type, const char *str);
-SQUIDCEXTERN void httpHeaderPutAuth(HttpHeader * hdr, const char *auth_scheme, const char *realm);
-SQUIDCEXTERN void httpHeaderPutCc(HttpHeader * hdr, const HttpHdrCc * cc);
-
-class HttpHdrContRange;
-SQUIDCEXTERN void httpHeaderPutContRange(HttpHeader * hdr, const HttpHdrContRange * cr);
-
-class HttpHdrRange;
-SQUIDCEXTERN void httpHeaderPutRange(HttpHeader * hdr, const HttpHdrRange * range);
-SQUIDCEXTERN void httpHeaderPutExt(HttpHeader * hdr, const char *name, const char *value);
-SQUIDCEXTERN int httpHeaderGetInt(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN time_t httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN TimeOrTag httpHeaderGetTimeOrTag(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN HttpHdrCc *httpHeaderGetCc(const HttpHeader * hdr);
-SQUIDCEXTERN ETag httpHeaderGetETag(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN HttpHdrRange *httpHeaderGetRange(const HttpHeader * hdr);
-SQUIDCEXTERN HttpHdrContRange *httpHeaderGetContRange(const HttpHeader * hdr);
-SQUIDCEXTERN const char *httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN const char *httpHeaderGetLastStr(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN const char *httpHeaderGetAuth(const HttpHeader * hdr, http_hdr_type id, const char *auth_scheme);
-extern String httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id);
-extern String httpHeaderGetStrOrList(const HttpHeader * hdr, http_hdr_type id);
-extern String httpHeaderGetByName(const HttpHeader * hdr, const char *name);
-extern String httpHeaderGetListMember(const HttpHeader * hdr, http_hdr_type id, const char *member, const char separator);
-extern String httpHeaderGetByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-SQUIDCEXTERN int httpHeaderDelByName(HttpHeader * hdr, const char *name);
-SQUIDCEXTERN int httpHeaderDelById(HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN void httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos);
+
 extern int httpHeaderEntryGetInt(const HttpHeaderEntry * e);
 /* avoid using these low level routines */
-SQUIDCEXTERN HttpHeaderEntry *httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos);
-SQUIDCEXTERN HttpHeaderEntry *httpHeaderFindEntry(const HttpHeader * hdr, http_hdr_type id);
-SQUIDCEXTERN void httpHeaderAddEntry(HttpHeader * hdr, HttpHeaderEntry * e);
-SQUIDCEXTERN void httpHeaderInsertEntry(HttpHeader * hdr, HttpHeaderEntry * e);
 SQUIDCEXTERN HttpHeaderEntry *httpHeaderEntryClone(const HttpHeaderEntry * e);
 SQUIDCEXTERN void httpHeaderEntryPackInto(const HttpHeaderEntry * e, Packer * p);
 /* store report about current header usage and other stats */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.587 2006/05/03 14:04:44 robertc Exp $
+ * $Id: store.cc,v 1.588 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -730,20 +730,20 @@ storeSetPublicKey(StoreEntry * e)
             /* We are allowed to do this typecast */
             HttpReply *rep = (HttpReply *) pe->getReply();      // bypass const
             rep->setHeaders(version, HTTP_OK, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
-            vary = httpHeaderGetList(&mem->getReply()->header, HDR_VARY);
+            vary = mem->getReply()->header.getList(HDR_VARY);
 
             if (vary.size()) {
                 /* Again, we own this structure layout */
-                httpHeaderPutStr((HttpHeader *)&pe->getReply()->header, HDR_VARY, vary.buf());
+                ((HttpHeader) pe->getReply()->header).putStr(HDR_VARY, vary.buf());
                 vary.clean();
             }
 
 #if X_ACCELERATOR_VARY
-            vary = httpHeaderGetList(&mem->getReply()->header, HDR_X_ACCELERATOR_VARY);
+            vary = mem->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
 
             if (vary.buf()) {
                 /* Again, we own this structure layout */
-                httpHeaderPutStr((HttpHeader *)&pe->getReply()->header, HDR_X_ACCELERATOR_VARY, vary.buf());
+                ((HttpHeader) pe->getReply()->header).putStr(HDR_X_ACCELERATOR_VARY, vary.buf());
                 vary.clean();
             }
 
@@ -1559,7 +1559,7 @@ storeTimestampsSet(StoreEntry * entry)
 {
     const HttpReply *reply = entry->getReply();
     time_t served_date = reply->date;
-    int age = httpHeaderGetInt(&reply->header, HDR_AGE);
+    int age = reply->header.getInt(HDR_AGE);
     /*
      * The timestamp calculations below tries to mimic the properties
      * of the age calculation in RFC2616 section 13.2.3. The implementaion
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.161 2006/05/05 23:57:40 wessels Exp $
+ * $Id: tunnel.cc,v 1.162 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -693,7 +693,7 @@ sslProxyConnected(int fd, void *data)
                                           &hdr_out,
                                           flags);			/* flags */
     packerToMemInit(&p, &mb);
-    httpHeaderPackInto(&hdr_out, &p);
+    hdr_out.packInto(&p);
     hdr_out.clean();
     packerClean(&p);
     mb.append("\r\n", 2);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: urn.cc,v 1.97 2006/05/03 14:04:44 robertc Exp $
+ * $Id: urn.cc,v 1.98 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 52    URN Parsing
  * AUTHOR: Kostas Anagnostakis
@@ -235,7 +235,7 @@ UrnState::setUriResFromRequest(HttpRequest *r)
     }
 
     HTTPMSGLOCK(urlres_r);
-    httpHeaderPutStr(&urlres_r->header, HDR_ACCEPT, "text/plain");
+    urlres_r->header.putStr(HDR_ACCEPT, "text/plain");
 }
 
 void
@@ -443,7 +443,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
     if (urnState->flags.force_menu) {
         debug(51, 3) ("urnHandleReply: forcing menu\n");
     } else if (min_u) {
-        httpHeaderPutStr(&rep->header, HDR_LOCATION, min_u->url);
+        rep->header.putStr(HDR_LOCATION, min_u->url);
     }
 
     httpBodySet(&rep->body, mb);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.156 2006/02/17 18:10:59 wessels Exp $
+ * $Id: wais.cc,v 1.157 2006/05/06 22:13:18 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -227,7 +227,7 @@ waisSendRequest(int fd, void *data)
     if (waisState->request_hdr) {
         Packer p;
         packerToMemInit(&p, &mb);
-        httpHeaderPackInto(waisState->request_hdr, &p);
+        waisState->request_hdr->packInto(&p);
         packerClean(&p);
     }
 