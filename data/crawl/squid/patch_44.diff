----++++src/Debug.h
@@ -52,36 +52,51 @@ class Debug
 {
 
 public:
+    /// meta-information for debugs() or a similar debugging call
+    class Context
+    {
+    public:
+        Context(const int aSectionLevel, const int aLevel);
+
+        int level; ///&lt; minimum debugging level required by the debugs() call
+        int sectionLevel; ///&lt; maximum debugging level allowed during the call
+
+    private:
+        friend class Debug;
+        void rewind(const int aSection, const int aLevel);
+        void formatStream();
+        Context *upper; ///&lt; previous or parent record in nested debugging calls
+        std::ostringstream buf; ///&lt; debugs() output sink
+    };
+
+    /// whether debugging the given section and the given level produces output
+    static bool Enabled(const int section, const int level)
+    {
+        return level &lt;= Debug::Levels[section];
+    }
+
     static char *debugOptions;
     static char *cache_log;
     static int rotateNumber;
     static int Levels[MAX_DEBUG_SECTIONS];
-    static int level; ///&lt; minimum debugging level required by debugs() call
-    static int sectionLevel; ///&lt; maximum debugging level allowed now
     static int override_X;
     static int log_stderr;
     static bool log_syslog;
 
-    static std::ostream &amp;getDebugOut();
-    static void finishDebug();
     static void parseOptions(char const *);
 
-private:
-    // Hack: replaces global ::xassert() to debug debugging assertions
-    static void xassert(const char *msg, const char *file, int line);
+    /// minimum level required by the current debugs() call
+    static int Level() { return Current ? Current-&gt;level : 1; }
+    /// maximum level currently allowed
+    static int SectionLevel() { return Current ? Current-&gt;sectionLevel : 1; }
 
-    /// Wrapper class to prevent SquidNew.h overrides getting confused
-    /// with the libc++6 std::ostringstream definitions
-    class OutStream : public std::ostringstream
-    {
-        MEMPROXY_CLASS(OutStream);
-    public:
-        void *operator new[] (size_t size) throw(std::bad_alloc) = delete; //{return xmalloc(size);}
-        void operator delete[] (void *address) throw() = delete; // {xfree(address);}
-    };
+    /// opens debugging context and returns output buffer
+    static std::ostringstream &amp;Start(const int section, const int level);
+    /// logs output buffer created in Start() and closes debugging context
+    static void Finish();
 
-    static OutStream *CurrentDebug;
-    static int TheDepth; // level of nested debugging calls
+private:
+    static Context *Current; ///&lt; deepest active context; nil outside debugs()
 };
 
 extern FILE *debug_log;
@@ -97,15 +112,15 @@ const char * SkipBuildPrefix(const char* path);
  */
 #define debugs(SECTION, LEVEL, CONTENT) \
    do { \
-        if ((Debug::level = (LEVEL)) &lt;= Debug::Levels[SECTION]) { \
-            Debug::sectionLevel = Debug::Levels[SECTION]; \
-            std::ostream &amp;_dbo=Debug::getDebugOut(); \
-            if (Debug::level &gt; DBG_IMPORTANT) { \
-                _dbo &lt;&lt; (SECTION) &lt;&lt; ',' &lt;&lt; (LEVEL) &lt;&lt; "| " \
+        const int _dbg_level = (LEVEL); \
+        if (Debug::Enabled((SECTION), _dbg_level)) { \
+            std::ostream &amp;_dbo = Debug::Start((SECTION), _dbg_level); \
+            if (_dbg_level &gt; DBG_IMPORTANT) { \
+                _dbo &lt;&lt; (SECTION) &lt;&lt; ',' &lt;&lt; _dbg_level &lt;&lt; "| " \
                      &lt;&lt; SkipBuildPrefix(__FILE__)&lt;&lt;&quot;(&quot;&lt;&lt;__LINE__&lt;&lt;&quot;) &quot;&lt;&lt;__FUNCTION__&lt;&lt;&quot;: &quot;; \
             } \
             _dbo &lt;&lt; CONTENT; \
-            Debug::finishDebug(); \
+            Debug::Finish(); \
         } \
    } while (/*CONSTCOND*/ 0)
 
@@ -141,10 +156,6 @@ inline std::ostream&amp; operator &lt;&lt;(std::ostream &amp;os, const uint8_t d)
     return (os &lt;&lt; (int)d);
 }
 
-/* Legacy debug style. Still used in some places. needs to die... */
-#define do_debug(SECTION, LEVEL)   ((Debug::level = (LEVEL)) &lt;= Debug::Levels[SECTION])
-#define old_debug(SECTION, LEVEL)  if do_debug((SECTION), (LEVEL)) _db_print
-
 /* Legacy debug function definitions */
 void _db_init(const char *logfile, const char *options);
 void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
----++++src/adaptation/ecap/Host.cc
@@ -147,18 +147,16 @@ Adaptation::Ecap::Host::openDebug(libecap::LogVerbosity lv)
 {
     const int squidLevel = SquidLogLevel(lv);
     const int squidSection = 93; // XXX: this should be a global constant
-    // XXX: Debug.h should provide this to us
-    if ((Debug::level = squidLevel) &lt;= Debug::Levels[squidSection])
-        return &amp;Debug::getDebugOut();
-    else
-        return NULL;
+    return Debug::Enabled(squidSection, squidLevel) ?
+           &amp;Debug::Start(squidSection, squidLevel) :
+           nullptr;
 }
 
 void
 Adaptation::Ecap::Host::closeDebug(std::ostream *debug)
 {
     if (debug)
-        Debug::finishDebug();
+        Debug::Finish();
 }
 
 Adaptation::Ecap::Host::MessagePtr
----++++src/base/Lock.h
@@ -33,7 +33,7 @@ class Lock
     /// All locks must be cleared before it may be destroyed.
     void lock() const {
 #if defined(LOCKCOUNT_DEBUG)
-        old_debug(0,1)("Incrementing this %p from count %u\n",this,count_);
+        debugs(0,1, "Incrementing this " &lt;&lt; static_cast&lt;void*&gt;(this) &lt;&lt; " from count " &lt;&lt; count_);
 #endif
         assert(count_ &lt; UINT32_MAX);
         ++count_;
@@ -43,7 +43,7 @@ class Lock
     /// All locks must be cleared before it may be destroyed.
     uint32_t unlock() const {
 #if defined(LOCKCOUNT_DEBUG)
-        old_debug(0,1)("Decrementing this %p from count %u\n",this,count_);
+        debugs(0,1, "Decrementing this " &lt;&lt; static_cast&lt;void*&gt;(this) &lt;&lt; " from count " &lt;&lt; count_);
 #endif
         assert(count_ &gt; 0);
         return --count_;
----++++src/client_side.cc
@@ -2661,7 +2661,7 @@ clientNegotiateSSL(int fd, void *data)
         debugs(83, 2, &quot;clientNegotiateSSL: Session &quot; &lt;&lt; SSL_get_session(ssl) &lt;&lt;
                &quot; reused on FD &quot; &lt;&lt; fd &lt;&lt; &quot; (&quot; &lt;&lt; fd_table[fd].ipaddr &lt;&lt; &quot;:&quot; &lt;&lt; (int)fd_table[fd].remote_port &lt;&lt; &quot;)&quot;);
     } else {
-        if (do_debug(83, 4)) {
+        if (Debug::Enabled(83, 4)) {
             /* Write out the SSL session details.. actually the call below, but
              * OpenSSL headers do strange typecasts confusing GCC.. */
             /* PEM_write_SSL_SESSION(debug_log, SSL_get_session(ssl)); */
----++++src/debug.cc
@@ -24,8 +24,6 @@ int Debug::override_X = 0;
 int Debug::log_stderr = -1;
 bool Debug::log_syslog = false;
 int Debug::Levels[MAX_DEBUG_SECTIONS];
-int Debug::level;
-int Debug::sectionLevel;
 char *Debug::cache_log = NULL;
 int Debug::rotateNumber = -1;
 FILE *debug_log = NULL;
@@ -136,7 +134,7 @@ _db_print_file(const char *format, va_list args)
 static void
 _db_print_stderr(const char *format, va_list args)
 {
-    if (Debug::log_stderr &lt; Debug::level)
+    if (Debug::log_stderr &lt; Debug::Level())
         return;
 
     if (debug_log == stderr)
@@ -151,7 +149,7 @@ _db_print_syslog(const char *format, va_list args)
 {
     /* level 0,1 go to syslog */
 
-    if (Debug::level &gt; 1)
+    if (Debug::Level() &gt; 1)
         return;
 
     if (!Debug::log_syslog)
@@ -164,7 +162,7 @@ _db_print_syslog(const char *format, va_list args)
 
     tmpbuf[BUFSIZ - 1] = &#39;\0&#39;;
 
-    syslog(Debug::level == 0 ? LOG_WARNING : LOG_NOTICE, "%s", tmpbuf);
+    syslog(Debug::Level() == 0 ? LOG_WARNING : LOG_NOTICE, "%s", tmpbuf);
 }
 #endif /* HAVE_SYSLOG */
 
@@ -526,7 +524,7 @@ debugLogTime(void)
     static char buf[128];
     static time_t last_t = 0;
 
-    if (Debug::level &gt; 1) {
+    if (Debug::Level() &gt; 1) {
         char buf2[128];
         tm = localtime(&amp;t);
         strftime(buf2, 127, &quot;%Y/%m/%d %H:%M:%S&quot;, tm);
@@ -728,55 +726,75 @@ ctx_get_descr(Ctx ctx)
     return Ctx_Descrs[ctx] ? Ctx_Descrs[ctx] : &quot;&lt;null&gt;&quot;;
 }
 
-int Debug::TheDepth = 0;
+Debug::Context *Debug::Current = nullptr;
 
-Debug::OutStream *Debug::CurrentDebug(NULL);
+Debug::Context::Context(const int aSection, const int aLevel):
+    level(aLevel),
+    sectionLevel(Levels[aSection]),
+    upper(Current)
+{
+    formatStream();
+}
 
-std::ostream &amp;
-Debug::getDebugOut()
+/// Optimization: avoids new Context creation for every debugs().
+void
+Debug::Context::rewind(const int aSection, const int aLevel)
 {
-    assert(TheDepth &gt;= 0);
-    ++TheDepth;
-    if (TheDepth &gt; 1) {
-        assert(CurrentDebug);
-        *CurrentDebug &lt;&lt; std::endl &lt;&lt; &quot;reentrant debuging &quot; &lt;&lt; TheDepth &lt;&lt; &quot;-{&quot;;
-    } else {
-        assert(!CurrentDebug);
-        CurrentDebug = new Debug::OutStream;
-        // set default formatting flags
-        CurrentDebug-&gt;setf(std::ios::fixed);
-        CurrentDebug-&gt;precision(2);
-    }
-    return *CurrentDebug;
+    level = aLevel;
+    sectionLevel = Levels[aSection];
+    assert(upper == Current);
+
+    buf.str(std::string());
+    buf.clear();
+    // debugs() users are supposed to preserve format, but
+    // some do not, so we have to waste cycles resetting it for all.
+    formatStream();
 }
 
+/// configures default formatting for the debugging stream
 void
-Debug::finishDebug()
+Debug::Context::formatStream()
+{
+    const static std::ostringstream cleanStream;
+    buf.flags(cleanStream.flags() | std::ios::fixed);
+    buf.width(cleanStream.width());
+    buf.precision(2);
+    buf.fill(&#39; &#39;);
+    // If this is not enough, use copyfmt(cleanStream) which is ~10% slower.
+}
+
+std::ostringstream &amp;
+Debug::Start(const int section, const int level)
 {
-    assert(TheDepth &gt;= 0);
-    assert(CurrentDebug);
-    if (TheDepth &gt; 1) {
-        *CurrentDebug &lt;&lt; &quot;}-&quot; &lt;&lt; TheDepth &lt;&lt; std::endl;
+    Context *future = nullptr;
+
+    // prepare future context
+    if (Current) {
+        // all reentrant debugs() calls get here; create a dedicated context
+        future = new Context(section, level);
     } else {
-        assert(TheDepth == 1);
-        _db_print("%s\n", CurrentDebug-&gt;str().c_str());
-        delete CurrentDebug;
-        CurrentDebug = NULL;
+        // Optimization: Nearly all debugs() calls get here; avoid allocations
+        static Context *topContext = new Context(1, 1);
+        topContext-&gt;rewind(section, level);
+        future = topContext;
     }
-    --TheDepth;
+
+    Current = future;
+
+    return future-&gt;buf;
 }
 
-// Hack: replaces global ::xassert() to debug debugging assertions
-// Relies on assert macro calling xassert() without a specific scope.
 void
-Debug::xassert(const char *msg, const char *file, int line)
+Debug::Finish()
 {
-
-    if (CurrentDebug) {
-        *CurrentDebug &lt;&lt; &quot;assertion failed: &quot; &lt;&lt; file &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt;
-                      &quot;: \&quot;&quot; &lt;&lt; msg &lt;&lt; &quot;\&quot;&quot;;
-    }
-    abort();
+    // TODO: Optimize to remove at least one extra copy.
+    _db_print(&quot;%s\n&quot;, Current-&gt;buf.str().c_str());
+
+    Context *past = Current;
+    Current = past-&gt;upper;
+    if (Current)
+        delete past;
+    // else it was a static topContext from Debug::Start()
 }
 
 size_t
@@ -826,8 +844,8 @@ Raw::print(std::ostream &amp;os) const
 
     // finalize debugging level if no level was set explicitly via minLevel()
     const int finalLevel = (level &gt;= 0) ? level :
-                           (size_ &gt; 40 ? DBG_DATA : Debug::sectionLevel);
-    if (finalLevel &lt;= Debug::sectionLevel) {
+                           (size_ &gt; 40 ? DBG_DATA : Debug::SectionLevel());
+    if (finalLevel &lt;= Debug::SectionLevel()) {
         os &lt;&lt; (label_ ? &#39;=&#39; : &#39; &#39;);
         if (data_) {
             if (useHex_)
----++++GitHub