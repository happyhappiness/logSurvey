@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.70 2001/04/14 00:25:17 hno Exp $
+ * $Id: HttpHeader.cc,v 1.71 2001/10/17 10:59:08 adrian Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -66,69 +66,69 @@
  */
 static const HttpHeaderFieldAttrs HeadersAttrs[] =
 {
-    {"Accept", HDR_ACCEPT, ftStr},
-    {"Accept-Charset", HDR_ACCEPT_CHARSET, ftStr},
-    {"Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr},
-    {"Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr},
-    {"Accept-Ranges", HDR_ACCEPT_RANGES, ftStr},
-    {"Age", HDR_AGE, ftInt},
-    {"Allow", HDR_ALLOW, ftStr},
-    {"Authorization", HDR_AUTHORIZATION, ftStr},	/* for now */
-    {"Cache-Control", HDR_CACHE_CONTROL, ftPCc},
-    {"Connection", HDR_CONNECTION, ftStr},
-    {"Content-Base", HDR_CONTENT_BASE, ftStr},
-    {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
-    {"Content-Language", HDR_CONTENT_LANGUAGE, ftStr},
-    {"Content-Length", HDR_CONTENT_LENGTH, ftInt},
-    {"Content-Location", HDR_CONTENT_LOCATION, ftStr},
-    {"Content-MD5", HDR_CONTENT_MD5, ftStr},	/* for now */
-    {"Content-Range", HDR_CONTENT_RANGE, ftPContRange},
-    {"Content-Type", HDR_CONTENT_TYPE, ftStr},
-    {"Cookie", HDR_COOKIE, ftStr},
-    {"Date", HDR_DATE, ftDate_1123},
-    {"ETag", HDR_ETAG, ftETag},
-    {"Expires", HDR_EXPIRES, ftDate_1123},
-    {"From", HDR_FROM, ftStr},
-    {"Host", HDR_HOST, ftStr},
-    {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
-    {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
-    {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
-    {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
-    {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
-    {"Link", HDR_LINK, ftStr},
-    {"Location", HDR_LOCATION, ftStr},
-    {"Max-Forwards", HDR_MAX_FORWARDS, ftInt},
-    {"Mime-Version", HDR_MIME_VERSION, ftStr},	/* for now */
-    {"Pragma", HDR_PRAGMA, ftStr},
-    {"Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftStr},
-    {"Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, ftStr},
-    {"Proxy-Authorization", HDR_PROXY_AUTHORIZATION, ftStr},
-    {"Proxy-Connection", HDR_PROXY_CONNECTION, ftStr},
-    {"Public", HDR_PUBLIC, ftStr},
-    {"Range", HDR_RANGE, ftPRange},
-    {"Referer", HDR_REFERER, ftStr},
-    {"Request-Range", HDR_REQUEST_RANGE, ftPRange},	/* usually matches HDR_RANGE */
-    {"Retry-After", HDR_RETRY_AFTER, ftStr},	/* for now (ftDate_1123 or ftInt!) */
-    {"Server", HDR_SERVER, ftStr},
-    {"Set-Cookie", HDR_SET_COOKIE, ftStr},
-    {"Title", HDR_TITLE, ftStr},
-    {"Upgrade", HDR_UPGRADE, ftStr},	/* for now */
-    {"User-Agent", HDR_USER_AGENT, ftStr},
-    {"Vary", HDR_VARY, ftStr},	/* for now */
-    {"Via", HDR_VIA, ftStr},	/* for now */
-    {"Warning", HDR_WARNING, ftStr},	/* for now */
-    {"WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftStr},
-    {"Authentication-Info", HDR_AUTHENTICATION_INFO, ftStr},
-    {"X-Cache", HDR_X_CACHE, ftStr},
-    {"X-Cache-Lookup", HDR_X_CACHE_LOOKUP, ftStr},
-    {"X-Forwarded-For", HDR_X_FORWARDED_FOR, ftStr},
-    {"X-Request-URI", HDR_X_REQUEST_URI, ftStr},
-    {"X-Squid-Error", HDR_X_SQUID_ERROR, ftStr},
-    {"Negotiate", HDR_NEGOTIATE, ftStr},
+  {"Accept", HDR_ACCEPT, ftStr},
+  {"Accept-Charset", HDR_ACCEPT_CHARSET, ftStr},
+  {"Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr},
+  {"Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr},
+  {"Accept-Ranges", HDR_ACCEPT_RANGES, ftStr},
+  {"Age", HDR_AGE, ftInt},
+  {"Allow", HDR_ALLOW, ftStr},
+  {"Authorization", HDR_AUTHORIZATION, ftStr},	/* for now */
+  {"Cache-Control", HDR_CACHE_CONTROL, ftPCc},
+  {"Connection", HDR_CONNECTION, ftStr},
+  {"Content-Base", HDR_CONTENT_BASE, ftStr},
+  {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
+  {"Content-Language", HDR_CONTENT_LANGUAGE, ftStr},
+  {"Content-Length", HDR_CONTENT_LENGTH, ftInt},
+  {"Content-Location", HDR_CONTENT_LOCATION, ftStr},
+  {"Content-MD5", HDR_CONTENT_MD5, ftStr},	/* for now */
+  {"Content-Range", HDR_CONTENT_RANGE, ftPContRange},
+  {"Content-Type", HDR_CONTENT_TYPE, ftStr},
+  {"Cookie", HDR_COOKIE, ftStr},
+  {"Date", HDR_DATE, ftDate_1123},
+  {"ETag", HDR_ETAG, ftETag},
+  {"Expires", HDR_EXPIRES, ftDate_1123},
+  {"From", HDR_FROM, ftStr},
+  {"Host", HDR_HOST, ftStr},
+  {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
+  {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
+  {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
+  {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
+  {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
+  {"Link", HDR_LINK, ftStr},
+  {"Location", HDR_LOCATION, ftStr},
+  {"Max-Forwards", HDR_MAX_FORWARDS, ftInt},
+  {"Mime-Version", HDR_MIME_VERSION, ftStr},	/* for now */
+  {"Pragma", HDR_PRAGMA, ftStr},
+  {"Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftStr},
+  {"Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, ftStr},
+  {"Proxy-Authorization", HDR_PROXY_AUTHORIZATION, ftStr},
+  {"Proxy-Connection", HDR_PROXY_CONNECTION, ftStr},
+  {"Public", HDR_PUBLIC, ftStr},
+  {"Range", HDR_RANGE, ftPRange},
+  {"Referer", HDR_REFERER, ftStr},
+  {"Request-Range", HDR_REQUEST_RANGE, ftPRange},	/* usually matches HDR_RANGE */
+  {"Retry-After", HDR_RETRY_AFTER, ftStr},	/* for now (ftDate_1123 or ftInt!) */
+  {"Server", HDR_SERVER, ftStr},
+  {"Set-Cookie", HDR_SET_COOKIE, ftStr},
+  {"Title", HDR_TITLE, ftStr},
+  {"Upgrade", HDR_UPGRADE, ftStr},	/* for now */
+  {"User-Agent", HDR_USER_AGENT, ftStr},
+  {"Vary", HDR_VARY, ftStr},	/* for now */
+  {"Via", HDR_VIA, ftStr},	/* for now */
+  {"Warning", HDR_WARNING, ftStr},	/* for now */
+  {"WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftStr},
+  {"Authentication-Info", HDR_AUTHENTICATION_INFO, ftStr},
+  {"X-Cache", HDR_X_CACHE, ftStr},
+  {"X-Cache-Lookup", HDR_X_CACHE_LOOKUP, ftStr},
+  {"X-Forwarded-For", HDR_X_FORWARDED_FOR, ftStr},
+  {"X-Request-URI", HDR_X_REQUEST_URI, ftStr},
+  {"X-Squid-Error", HDR_X_SQUID_ERROR, ftStr},
+  {"Negotiate", HDR_NEGOTIATE, ftStr},
 #if X_ACCELERATOR_VARY
-    {"X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, ftStr},
+  {"X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, ftStr},
 #endif
-    {"Other:", HDR_OTHER, ftStr}	/* ':' will not allow matches */
+  {"Other:", HDR_OTHER, ftStr}	/* ':' will not allow matches */
 };
 static HttpHeaderFieldInfo *Headers = NULL;
 
@@ -139,88 +139,88 @@ static HttpHeaderFieldInfo *Headers = NULL;
 static HttpHeaderMask ListHeadersMask;	/* set run-time using  ListHeadersArr */
 static http_hdr_type ListHeadersArr[] =
 {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES, HDR_ALLOW,
-    HDR_CACHE_CONTROL,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONNECTION,
-    HDR_IF_MATCH, HDR_IF_NONE_MATCH,
-    HDR_LINK, HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
+  HDR_ACCEPT,
+  HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
+  HDR_ACCEPT_RANGES, HDR_ALLOW,
+  HDR_CACHE_CONTROL,
+  HDR_CONTENT_ENCODING,
+  HDR_CONTENT_LANGUAGE,
+  HDR_CONNECTION,
+  HDR_IF_MATCH, HDR_IF_NONE_MATCH,
+  HDR_LINK, HDR_PRAGMA,
+  HDR_PROXY_CONNECTION,
     /* HDR_TRANSFER_ENCODING, */
-    HDR_UPGRADE,
-    HDR_VARY,
-    HDR_VIA,
+  HDR_UPGRADE,
+  HDR_VARY,
+  HDR_VIA,
     /* HDR_WARNING, */
-    HDR_WWW_AUTHENTICATE,
-    HDR_AUTHENTICATION_INFO,
-    HDR_PROXY_AUTHENTICATION_INFO,
+  HDR_WWW_AUTHENTICATE,
+  HDR_AUTHENTICATION_INFO,
+  HDR_PROXY_AUTHENTICATION_INFO,
     /* HDR_EXPECT, HDR_TE, HDR_TRAILER */
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+  HDR_X_ACCELERATOR_VARY,
 #endif
-    HDR_X_FORWARDED_FOR
+  HDR_X_FORWARDED_FOR
 };
 
 /* general-headers */
 static http_hdr_type GeneralHeadersArr[] =
 {
-    HDR_CACHE_CONTROL, HDR_CONNECTION, HDR_DATE, HDR_PRAGMA,
+  HDR_CACHE_CONTROL, HDR_CONNECTION, HDR_DATE, HDR_PRAGMA,
     /* HDR_TRANSFER_ENCODING, */
-    HDR_UPGRADE,
+  HDR_UPGRADE,
     /* HDR_TRAILER, */
-    HDR_VIA
+  HDR_VIA
 };
 
 /* entity-headers */
 static http_hdr_type EntityHeadersArr[] =
 {
-    HDR_ALLOW, HDR_CONTENT_BASE, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE,
-    HDR_CONTENT_LENGTH, HDR_CONTENT_LOCATION, HDR_CONTENT_MD5,
-    HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_ETAG, HDR_EXPIRES, HDR_LAST_MODIFIED, HDR_LINK,
-    HDR_OTHER
+  HDR_ALLOW, HDR_CONTENT_BASE, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE,
+  HDR_CONTENT_LENGTH, HDR_CONTENT_LOCATION, HDR_CONTENT_MD5,
+  HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_ETAG, HDR_EXPIRES, HDR_LAST_MODIFIED, HDR_LINK,
+  HDR_OTHER
 };
 
 static HttpHeaderMask ReplyHeadersMask;		/* set run-time using ReplyHeaders */
 static http_hdr_type ReplyHeadersArr[] =
 {
-    HDR_ACCEPT, HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES, HDR_AGE,
-    HDR_LOCATION, HDR_MAX_FORWARDS,
-    HDR_MIME_VERSION, HDR_PUBLIC, HDR_RETRY_AFTER, HDR_SERVER, HDR_SET_COOKIE,
-    HDR_VARY,
-    HDR_WARNING, HDR_PROXY_CONNECTION, HDR_X_CACHE,
-    HDR_X_CACHE_LOOKUP,
-    HDR_X_REQUEST_URI,
+  HDR_ACCEPT, HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
+  HDR_ACCEPT_RANGES, HDR_AGE,
+  HDR_LOCATION, HDR_MAX_FORWARDS,
+  HDR_MIME_VERSION, HDR_PUBLIC, HDR_RETRY_AFTER, HDR_SERVER, HDR_SET_COOKIE,
+  HDR_VARY,
+  HDR_WARNING, HDR_PROXY_CONNECTION, HDR_X_CACHE,
+  HDR_X_CACHE_LOOKUP,
+  HDR_X_REQUEST_URI,
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+  HDR_X_ACCELERATOR_VARY,
 #endif
-    HDR_X_SQUID_ERROR
+  HDR_X_SQUID_ERROR
 };
 
 static HttpHeaderMask RequestHeadersMask;	/* set run-time using RequestHeaders */
 static http_hdr_type RequestHeadersArr[] =
 {
-    HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
-    HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
-    HDR_IF_RANGE, HDR_MAX_FORWARDS, HDR_PROXY_CONNECTION,
-    HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
-    HDR_USER_AGENT, HDR_X_FORWARDED_FOR
+  HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
+  HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
+  HDR_IF_RANGE, HDR_MAX_FORWARDS, HDR_PROXY_CONNECTION,
+  HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
+  HDR_USER_AGENT, HDR_X_FORWARDED_FOR
 };
 
 /* header accounting */
 static HttpHeaderStat HttpHeaderStats[] =
 {
-    {"all"},
+  {"all"},
 #if USE_HTCP
-    {"HTCP reply"},
+  {"HTCP reply"},
 #endif
-    {"request"},
-    {"reply"}
+  {"request"},
+  {"reply"}
 };
-static int HttpHeaderStatCount = countof(HttpHeaderStats);
+static int HttpHeaderStatCount = countof (HttpHeaderStats);
 
 static int HeaderEntryParsedCount = 0;
 
@@ -230,227 +230,237 @@ static int HeaderEntryParsedCount = 0;
 
 #define assert_eid(id) assert((id) >= 0 && (id) < HDR_ENUM_END)
 
-static HttpHeaderEntry *httpHeaderEntryCreate(http_hdr_type id, const char *name, const char *value);
-static void httpHeaderEntryDestroy(HttpHeaderEntry * e);
-static HttpHeaderEntry *httpHeaderEntryParseCreate(const char *field_start, const char *field_end);
-static void httpHeaderNoteParsedEntry(http_hdr_type id, String value, int error);
+static HttpHeaderEntry *httpHeaderEntryCreate (http_hdr_type id, const char *name, const char *value);
+static void httpHeaderEntryDestroy (HttpHeaderEntry * e);
+static HttpHeaderEntry *httpHeaderEntryParseCreate (const char *field_start, const char *field_end);
+static void httpHeaderNoteParsedEntry (http_hdr_type id, String value, int error);
 
-static void httpHeaderStatInit(HttpHeaderStat * hs, const char *label);
-static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
+static void httpHeaderStatInit (HttpHeaderStat * hs, const char *label);
+static void httpHeaderStatDump (const HttpHeaderStat * hs, StoreEntry * e);
 
 /*
  * Module initialization routines
  */
 
 void
-httpHeaderInitModule(void)
+httpHeaderInitModule (void)
 {
-    int i;
-    /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= HDR_ENUM_END);
-    /* all headers must be described */
-    assert(countof(HeadersAttrs) == HDR_ENUM_END);
-    if (!Headers)
-	Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-    /* create masks */
-    httpHeaderMaskInit(&ListHeadersMask, 0);
-    httpHeaderCalcMask(&ListHeadersMask, (const int *) ListHeadersArr, countof(ListHeadersArr));
-    httpHeaderMaskInit(&ReplyHeadersMask, 0);
-    httpHeaderCalcMask(&ReplyHeadersMask, (const int *) ReplyHeadersArr, countof(ReplyHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, (const int *) GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, (const int *) EntityHeadersArr, countof(EntityHeadersArr));
-    httpHeaderMaskInit(&RequestHeadersMask, 0);
-    httpHeaderCalcMask(&RequestHeadersMask, (const int *) RequestHeadersArr, countof(RequestHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, (const int *) GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, (const int *) EntityHeadersArr, countof(EntityHeadersArr));
-    /* init header stats */
-    assert(HttpHeaderStatCount == hoReply + 1);
-    for (i = 0; i < HttpHeaderStatCount; i++)
-	httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
-    HttpHeaderStats[hoRequest].owner_mask = &RequestHeadersMask;
-    HttpHeaderStats[hoReply].owner_mask = &ReplyHeadersMask;
+  int i;
+  /* check that we have enough space for masks */
+  assert (8 * sizeof (HttpHeaderMask) >= HDR_ENUM_END);
+  /* all headers must be described */
+  assert (countof (HeadersAttrs) == HDR_ENUM_END);
+  if (!Headers)
+    Headers = httpHeaderBuildFieldsInfo (HeadersAttrs, HDR_ENUM_END);
+  /* create masks */
+  httpHeaderMaskInit (&ListHeadersMask, 0);
+  httpHeaderCalcMask (&ListHeadersMask, (const int *) ListHeadersArr, countof (ListHeadersArr));
+  httpHeaderMaskInit (&ReplyHeadersMask, 0);
+  httpHeaderCalcMask (&ReplyHeadersMask, (const int *) ReplyHeadersArr, countof (ReplyHeadersArr));
+  httpHeaderCalcMask (&ReplyHeadersMask, (const int *) GeneralHeadersArr, countof (GeneralHeadersArr));
+  httpHeaderCalcMask (&ReplyHeadersMask, (const int *) EntityHeadersArr, countof (EntityHeadersArr));
+  httpHeaderMaskInit (&RequestHeadersMask, 0);
+  httpHeaderCalcMask (&RequestHeadersMask, (const int *) RequestHeadersArr, countof (RequestHeadersArr));
+  httpHeaderCalcMask (&RequestHeadersMask, (const int *) GeneralHeadersArr, countof (GeneralHeadersArr));
+  httpHeaderCalcMask (&RequestHeadersMask, (const int *) EntityHeadersArr, countof (EntityHeadersArr));
+  /* init header stats */
+  assert (HttpHeaderStatCount == hoReply + 1);
+  for (i = 0; i < HttpHeaderStatCount; i++)
+    httpHeaderStatInit (HttpHeaderStats + i, HttpHeaderStats[i].label);
+  HttpHeaderStats[hoRequest].owner_mask = &RequestHeadersMask;
+  HttpHeaderStats[hoReply].owner_mask = &ReplyHeadersMask;
 #if USE_HTCP
-    HttpHeaderStats[hoHtcpReply].owner_mask = &ReplyHeadersMask;
+  HttpHeaderStats[hoHtcpReply].owner_mask = &ReplyHeadersMask;
 #endif
-    /* init dependent modules */
-    httpHdrCcInitModule();
-    /* register with cache manager */
-    cachemgrRegister("http_headers",
-	"HTTP Header Statistics", httpHeaderStoreReport, 0, 1);
+  /* init dependent modules */
+  httpHdrCcInitModule ();
+  /* register with cache manager */
+  cachemgrRegister ("http_headers",
+		    "HTTP Header Statistics", httpHeaderStoreReport, 0, 1);
 }
 
 void
-httpHeaderCleanModule(void)
+httpHeaderCleanModule (void)
 {
-    httpHeaderDestroyFieldsInfo(Headers, HDR_ENUM_END);
-    Headers = NULL;
-    httpHdrCcCleanModule();
+  httpHeaderDestroyFieldsInfo (Headers, HDR_ENUM_END);
+  Headers = NULL;
+  httpHdrCcCleanModule ();
 }
 
 static void
-httpHeaderStatInit(HttpHeaderStat * hs, const char *label)
+httpHeaderStatInit (HttpHeaderStat * hs, const char *label)
 {
-    assert(hs);
-    assert(label);
-    memset(hs, 0, sizeof(HttpHeaderStat));
-    hs->label = label;
-    statHistEnumInit(&hs->hdrUCountDistr, 32);	/* not a real enum */
-    statHistEnumInit(&hs->fieldTypeDistr, HDR_ENUM_END);
-    statHistEnumInit(&hs->ccTypeDistr, CC_ENUM_END);
+  assert (hs);
+  assert (label);
+  memset (hs, 0, sizeof (HttpHeaderStat));
+  hs->label = label;
+  statHistEnumInit (&hs->hdrUCountDistr, 32);	/* not a real enum */
+  statHistEnumInit (&hs->fieldTypeDistr, HDR_ENUM_END);
+  statHistEnumInit (&hs->ccTypeDistr, CC_ENUM_END);
 }
 
 /*
  * HttpHeader Implementation
  */
 
 void
-httpHeaderInit(HttpHeader * hdr, http_hdr_owner_type owner)
+httpHeaderInit (HttpHeader * hdr, http_hdr_owner_type owner)
 {
-    assert(hdr);
-    assert(owner > hoNone && owner <= hoReply);
-    debug(55, 7) ("init-ing hdr: %p owner: %d\n", hdr, owner);
-    memset(hdr, 0, sizeof(*hdr));
-    hdr->owner = owner;
-    arrayInit(&hdr->entries);
+  assert (hdr);
+  assert (owner > hoNone && owner <= hoReply);
+  debug (55, 7) ("init-ing hdr: %p owner: %d\n", hdr, owner);
+  memset (hdr, 0, sizeof (*hdr));
+  hdr->owner = owner;
+  arrayInit (&hdr->entries);
 }
 
 void
-httpHeaderClean(HttpHeader * hdr)
+httpHeaderClean (HttpHeader * hdr)
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-
-    assert(hdr);
-    assert(hdr->owner > hoNone && hdr->owner <= hoReply);
-    debug(55, 7) ("cleaning hdr: %p owner: %d\n", hdr, hdr->owner);
-
-    statHistCount(&HttpHeaderStats[hdr->owner].hdrUCountDistr, hdr->entries.count);
-    HttpHeaderStats[hdr->owner].destroyedCount++;
-    HttpHeaderStats[hdr->owner].busyDestroyedCount += hdr->entries.count > 0;
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	/* tmp hack to try to avoid coredumps */
-	if (e->id < 0 || e->id >= HDR_ENUM_END) {
-	    debug(55, 0) ("httpHeaderClean BUG: entry[%d] is invalid (%d). Ignored.\n",
-		pos, e->id);
-	} else {
-	    statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
-	    /* yes, this destroy() leaves us in an incosistent state */
-	    httpHeaderEntryDestroy(e);
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  HttpHeaderEntry *e;
+
+  assert (hdr);
+  assert (hdr->owner > hoNone && hdr->owner <= hoReply);
+  debug (55, 7) ("cleaning hdr: %p owner: %d\n", hdr, hdr->owner);
+
+  statHistCount (&HttpHeaderStats[hdr->owner].hdrUCountDistr, hdr->entries.count);
+  HttpHeaderStats[hdr->owner].destroyedCount++;
+  HttpHeaderStats[hdr->owner].busyDestroyedCount += hdr->entries.count > 0;
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      /* tmp hack to try to avoid coredumps */
+      if (e->id < 0 || e->id >= HDR_ENUM_END)
+	{
+	  debug (55, 0) ("httpHeaderClean BUG: entry[%d] is invalid (%d). Ignored.\n",
+			 pos, e->id);
+	}
+      else
+	{
+	  statHistCount (&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
+	  /* yes, this destroy() leaves us in an incosistent state */
+	  httpHeaderEntryDestroy (e);
 	}
     }
-    arrayClean(&hdr->entries);
+  arrayClean (&hdr->entries);
 }
 
 /* append entries (also see httpHeaderUpdate) */
 void
-httpHeaderAppend(HttpHeader * dest, const HttpHeader * src)
+httpHeaderAppend (HttpHeader * dest, const HttpHeader * src)
 {
-    const HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    assert(src && dest);
-    assert(src != dest);
-    debug(55, 7) ("appending hdr: %p += %p\n", dest, src);
-
-    while ((e = httpHeaderGetEntry(src, &pos))) {
-	httpHeaderAddEntry(dest, httpHeaderEntryClone(e));
+  const HttpHeaderEntry *e;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  assert (src && dest);
+  assert (src != dest);
+  debug (55, 7) ("appending hdr: %p += %p\n", dest, src);
+
+  while ((e = httpHeaderGetEntry (src, &pos)))
+    {
+      httpHeaderAddEntry (dest, httpHeaderEntryClone (e));
     }
 }
 
 /* use fresh entries to replace old ones */
 void
-httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask)
+httpHeaderUpdate (HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask)
 {
-    const HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    assert(old && fresh);
-    assert(old != fresh);
-    debug(55, 7) ("updating hdr: %p <- %p\n", old, fresh);
-
-    while ((e = httpHeaderGetEntry(fresh, &pos))) {
-	/* deny bad guys (ok to check for HDR_OTHER) here */
-	if (denied_mask && CBIT_TEST(*denied_mask, e->id))
-	    continue;
-	httpHeaderDelByName(old, strBuf(e->name));
-	httpHeaderAddEntry(old, httpHeaderEntryClone(e));
+  const HttpHeaderEntry *e;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  assert (old && fresh);
+  assert (old != fresh);
+  debug (55, 7) ("updating hdr: %p <- %p\n", old, fresh);
+
+  while ((e = httpHeaderGetEntry (fresh, &pos)))
+    {
+      /* deny bad guys (ok to check for HDR_OTHER) here */
+      if (denied_mask && CBIT_TEST (*denied_mask, e->id))
+	continue;
+      httpHeaderDelByName (old, strBuf (e->name));
+      httpHeaderAddEntry (old, httpHeaderEntryClone (e));
     }
 }
 
 /* just handy in parsing: resets and returns false */
 int
-httpHeaderReset(HttpHeader * hdr)
+httpHeaderReset (HttpHeader * hdr)
 {
-    http_hdr_owner_type ho = hdr->owner;
-    assert(hdr);
-    ho = hdr->owner;
-    httpHeaderClean(hdr);
-    httpHeaderInit(hdr, ho);
-    return 0;
+  http_hdr_owner_type ho = hdr->owner;
+  assert (hdr);
+  ho = hdr->owner;
+  httpHeaderClean (hdr);
+  httpHeaderInit (hdr, ho);
+  return 0;
 }
 
 int
-httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_end)
+httpHeaderParse (HttpHeader * hdr, const char *header_start, const char *header_end)
 {
-    const char *field_start = header_start;
-    HttpHeaderEntry *e;
-
-    assert(hdr);
-    assert(header_start && header_end);
-    debug(55, 7) ("parsing hdr: (%p)\n%s\n", hdr, getStringPrefix(header_start, header_end));
-    HttpHeaderStats[hdr->owner].parsedCount++;
-    /* commonn format headers are "<name>:[ws]<value>" lines delimited by <CRLF> */
-    while (field_start < header_end) {
-	const char *field_end;
-	const char *field_ptr = field_start;
-	do {
-	    field_end = field_ptr = field_ptr + strcspn(field_ptr, "\r\n");
-	    /* skip CRLF */
-	    if (*field_ptr == '\r')
-		field_ptr++;
-	    if (*field_ptr == '\n')
-		field_ptr++;
-	} while (*field_ptr == ' ' || *field_ptr == '\t');
-	if (!*field_end || field_end > header_end)
-	    return httpHeaderReset(hdr);	/* missing <CRLF> */
-	e = httpHeaderEntryParseCreate(field_start, field_end);
-	if (e != NULL)
-	    httpHeaderAddEntry(hdr, e);
-	else
-	    debug(55, 2) ("warning: ignoring unparseable http header field near '%s'\n",
-		getStringPrefix(field_start, field_end));
-	field_start = field_end;
-	/* skip CRLF */
-	if (*field_start == '\r')
-	    field_start++;
-	if (*field_start == '\n')
-	    field_start++;
+  const char *field_start = header_start;
+  HttpHeaderEntry *e;
+
+  assert (hdr);
+  assert (header_start && header_end);
+  debug (55, 7) ("parsing hdr: (%p)\n%s\n", hdr, getStringPrefix (header_start, header_end));
+  HttpHeaderStats[hdr->owner].parsedCount++;
+  /* commonn format headers are "<name>:[ws]<value>" lines delimited by <CRLF> */
+  while (field_start < header_end)
+    {
+      const char *field_end;
+      const char *field_ptr = field_start;
+      do
+	{
+	  field_end = field_ptr = field_ptr + strcspn (field_ptr, "\r\n");
+	  /* skip CRLF */
+	  if (*field_ptr == '\r')
+	    field_ptr++;
+	  if (*field_ptr == '\n')
+	    field_ptr++;
+	}
+      while (*field_ptr == ' ' || *field_ptr == '\t');
+      if (!*field_end || field_end > header_end)
+	return httpHeaderReset (hdr);	/* missing <CRLF> */
+      e = httpHeaderEntryParseCreate (field_start, field_end);
+      if (e != NULL)
+	httpHeaderAddEntry (hdr, e);
+      else
+	debug (55, 2) ("warning: ignoring unparseable http header field near '%s'\n",
+		       getStringPrefix (field_start, field_end));
+      field_start = field_end;
+      /* skip CRLF */
+      if (*field_start == '\r')
+	field_start++;
+      if (*field_start == '\n')
+	field_start++;
     }
-    return 1;			/* even if no fields where found, it is a valid header */
+  return 1;			/* even if no fields where found, it is a valid header */
 }
 
 /* packs all the entries using supplied packer */
 void
-httpHeaderPackInto(const HttpHeader * hdr, Packer * p)
+httpHeaderPackInto (const HttpHeader * hdr, Packer * p)
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    const HttpHeaderEntry *e;
-    assert(hdr && p);
-    debug(55, 7) ("packing hdr: (%p)\n", hdr);
-    /* pack all entries one by one */
-    while ((e = httpHeaderGetEntry(hdr, &pos)))
-	httpHeaderEntryPackInto(e, p);
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  const HttpHeaderEntry *e;
+  assert (hdr && p);
+  debug (55, 7) ("packing hdr: (%p)\n", hdr);
+  /* pack all entries one by one */
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    httpHeaderEntryPackInto (e, p);
 }
 
 /* returns next valid entry */
 HttpHeaderEntry *
-httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
+httpHeaderGetEntry (const HttpHeader * hdr, HttpHeaderPos * pos)
 {
-    assert(hdr && pos);
-    assert(*pos >= HttpHeaderInitPos && *pos < hdr->entries.count);
-    for ((*pos)++; *pos < hdr->entries.count; (*pos)++) {
-	if (hdr->entries.items[*pos])
-	    return hdr->entries.items[*pos];
+  assert (hdr && pos);
+  assert (*pos >= HttpHeaderInitPos && *pos < hdr->entries.count);
+  for ((*pos)++; *pos < hdr->entries.count; (*pos)++)
+    {
+      if (hdr->entries.items[*pos])
+	return hdr->entries.items[*pos];
     }
-    return NULL;
+  return NULL;
 }
 
 /*
@@ -459,177 +469,186 @@ httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
  * "list" headers
  */
 HttpHeaderEntry *
-httpHeaderFindEntry(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderFindEntry (const HttpHeader * hdr, http_hdr_type id)
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    assert(hdr);
-    assert_eid(id);
-    assert(!CBIT_TEST(ListHeadersMask, id));
-
-    /* check mask first */
-    if (!CBIT_TEST(hdr->mask, id))
-	return NULL;
-    /* looks like we must have it, do linear search */
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id)
-	    return e;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  HttpHeaderEntry *e;
+  assert (hdr);
+  assert_eid (id);
+  assert (!CBIT_TEST (ListHeadersMask, id));
+
+  /* check mask first */
+  if (!CBIT_TEST (hdr->mask, id))
+    return NULL;
+  /* looks like we must have it, do linear search */
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      if (e->id == id)
+	return e;
     }
-    /* hm.. we thought it was there, but it was not found */
-    assert(0);
-    return NULL;		/* not reached */
+  /* hm.. we thought it was there, but it was not found */
+  assert (0);
+  return NULL;			/* not reached */
 }
 
 /*
  * same as httpHeaderFindEntry
  */
 static HttpHeaderEntry *
-httpHeaderFindLastEntry(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderFindLastEntry (const HttpHeader * hdr, http_hdr_type id)
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    HttpHeaderEntry *result = NULL;
-    assert(hdr);
-    assert_eid(id);
-    assert(!CBIT_TEST(ListHeadersMask, id));
-
-    /* check mask first */
-    if (!CBIT_TEST(hdr->mask, id))
-	return NULL;
-    /* looks like we must have it, do linear search */
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id)
-	    result = e;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  HttpHeaderEntry *e;
+  HttpHeaderEntry *result = NULL;
+  assert (hdr);
+  assert_eid (id);
+  assert (!CBIT_TEST (ListHeadersMask, id));
+
+  /* check mask first */
+  if (!CBIT_TEST (hdr->mask, id))
+    return NULL;
+  /* looks like we must have it, do linear search */
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      if (e->id == id)
+	result = e;
     }
-    assert(result);		/* must be there! */
-    return result;
+  assert (result);		/* must be there! */
+  return result;
 }
 
 /*
  * deletes all fields with a given name if any, returns #fields deleted; 
  */
 int
-httpHeaderDelByName(HttpHeader * hdr, const char *name)
+httpHeaderDelByName (HttpHeader * hdr, const char *name)
 {
-    int count = 0;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    httpHeaderMaskInit(&hdr->mask, 0);	/* temporal inconsistency */
-    debug(55, 7) ("deleting '%s' fields in hdr %p\n", name, hdr);
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (!strCaseCmp(e->name, name)) {
-	    httpHeaderDelAt(hdr, pos);
-	    count++;
-	} else
-	    CBIT_SET(hdr->mask, e->id);
+  int count = 0;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  HttpHeaderEntry *e;
+  httpHeaderMaskInit (&hdr->mask, 0);	/* temporal inconsistency */
+  debug (55, 7) ("deleting '%s' fields in hdr %p\n", name, hdr);
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      if (!strCaseCmp (e->name, name))
+	{
+	  httpHeaderDelAt (hdr, pos);
+	  count++;
+	}
+      else
+	CBIT_SET (hdr->mask, e->id);
     }
-    return count;
+  return count;
 }
 
 /* deletes all entries with a given id, returns the #entries deleted */
 int
-httpHeaderDelById(HttpHeader * hdr, http_hdr_type id)
+httpHeaderDelById (HttpHeader * hdr, http_hdr_type id)
 {
-    int count = 0;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    debug(55, 8) ("%p del-by-id %d\n", hdr, id);
-    assert(hdr);
-    assert_eid(id);
-    assert_eid(id != HDR_OTHER);	/* does not make sense */
-    if (!CBIT_TEST(hdr->mask, id))
-	return 0;
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id) {
-	    httpHeaderDelAt(hdr, pos);
-	    count++;
+  int count = 0;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  HttpHeaderEntry *e;
+  debug (55, 8) ("%p del-by-id %d\n", hdr, id);
+  assert (hdr);
+  assert_eid (id);
+  assert_eid (id != HDR_OTHER);	/* does not make sense */
+  if (!CBIT_TEST (hdr->mask, id))
+    return 0;
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      if (e->id == id)
+	{
+	  httpHeaderDelAt (hdr, pos);
+	  count++;
 	}
     }
-    CBIT_CLR(hdr->mask, id);
-    assert(count);
-    return count;
+  CBIT_CLR (hdr->mask, id);
+  assert (count);
+  return count;
 }
 
 /*
  * deletes an entry at pos and leaves a gap; leaving a gap makes it
  * possible to iterate(search) and delete fields at the same time
  */
 void
-httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos)
+httpHeaderDelAt (HttpHeader * hdr, HttpHeaderPos pos)
 {
-    HttpHeaderEntry *e;
-    assert(pos >= HttpHeaderInitPos && pos < hdr->entries.count);
-    e = hdr->entries.items[pos];
-    hdr->entries.items[pos] = NULL;
-    /* decrement header length, allow for ": " and crlf */
-    hdr->len -= strLen(e->name) + 2 + strLen(e->value) + 2;
-    assert(hdr->len >= 0);
-    httpHeaderEntryDestroy(e);
+  HttpHeaderEntry *e;
+  assert (pos >= HttpHeaderInitPos && pos < hdr->entries.count);
+  e = hdr->entries.items[pos];
+  hdr->entries.items[pos] = NULL;
+  /* decrement header length, allow for ": " and crlf */
+  hdr->len -= strLen (e->name) + 2 + strLen (e->value) + 2;
+  assert (hdr->len >= 0);
+  httpHeaderEntryDestroy (e);
 }
 
 
 /* appends an entry; 
  * does not call httpHeaderEntryClone() so one should not reuse "*e"
  */
 void
-httpHeaderAddEntry(HttpHeader * hdr, HttpHeaderEntry * e)
+httpHeaderAddEntry (HttpHeader * hdr, HttpHeaderEntry * e)
 {
-    assert(hdr && e);
-    assert_eid(e->id);
-
-    debug(55, 7) ("%p adding entry: %d at %d\n",
-	hdr, e->id, hdr->entries.count);
-    if (CBIT_TEST(hdr->mask, e->id))
-	Headers[e->id].stat.repCount++;
-    else
-	CBIT_SET(hdr->mask, e->id);
-    arrayAppend(&hdr->entries, e);
-    /* increment header length, allow for ": " and crlf */
-    hdr->len += strLen(e->name) + 2 + strLen(e->value) + 2;
+  assert (hdr && e);
+  assert_eid (e->id);
+
+  debug (55, 7) ("%p adding entry: %d at %d\n",
+		 hdr, e->id, hdr->entries.count);
+  if (CBIT_TEST (hdr->mask, e->id))
+    Headers[e->id].stat.repCount++;
+  else
+    CBIT_SET (hdr->mask, e->id);
+  arrayAppend (&hdr->entries, e);
+  /* increment header length, allow for ": " and crlf */
+  hdr->len += strLen (e->name) + 2 + strLen (e->value) + 2;
 }
 
 /* return a list of entries with the same id separated by ',' and ws */
 String
-httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetList (const HttpHeader * hdr, http_hdr_type id)
 {
-    String s = StringNull;
-    HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    debug(55, 6) ("%p: joining for id %d\n", hdr, id);
-    /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
-    if (!CBIT_TEST(hdr->mask, id))
-	return s;
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id)
-	    strListAdd(&s, strBuf(e->value), ',');
-    }
-    /*
-     * note: we might get an empty (len==0) string if there was an "empty"
-     * header; we must not get a NULL string though.
-     */
-    assert(strBuf(s));
-    /* temporary warning: remove it! @?@ @?@ @?@ */
-    if (!strLen(s))
-	debug(55, 3) ("empty list header: %s (%d)\n", strBuf(Headers[id].name), id);
-    debug(55, 6) ("%p: joined for id %d: %s\n", hdr, id, strBuf(s));
+  String s = StringNull;
+  HttpHeaderEntry *e;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  debug (55, 6) ("%p: joining for id %d\n", hdr, id);
+  /* only fields from ListHeaders array can be "listed" */
+  assert (CBIT_TEST (ListHeadersMask, id));
+  if (!CBIT_TEST (hdr->mask, id))
     return s;
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      if (e->id == id)
+	strListAdd (&s, strBuf (e->value), ',');
+    }
+  /*
+   * note: we might get an empty (len==0) string if there was an "empty"
+   * header; we must not get a NULL string though.
+   */
+  assert (strBuf (s));
+  /* temporary warning: remove it! @?@ @?@ @?@ */
+  if (!strLen (s))
+    debug (55, 3) ("empty list header: %s (%d)\n", strBuf (Headers[id].name), id);
+  debug (55, 6) ("%p: joined for id %d: %s\n", hdr, id, strBuf (s));
+  return s;
 }
 
 /* return a string or list of entries with the same id separated by ',' and ws */
 String
-httpHeaderGetStrOrList(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetStrOrList (const HttpHeader * hdr, http_hdr_type id)
 {
-    const char *str;
-    String s;
-
-    if (CBIT_TEST(ListHeadersMask, id))
-	s = httpHeaderGetList(hdr, id);
-    else {
-	str = httpHeaderGetStr(hdr, id);
-	stringInit(&s, str);
+  const char *str;
+  String s;
+
+  if (CBIT_TEST (ListHeadersMask, id))
+    s = httpHeaderGetList (hdr, id);
+  else
+    {
+      str = httpHeaderGetStr (hdr, id);
+      stringInit (&s, str);
     }
-    return s;
+  return s;
 }
 
 /*
@@ -638,419 +657,434 @@ httpHeaderGetStrOrList(const HttpHeader * hdr, http_hdr_type id)
  * "list" headers
  */
 String
-httpHeaderGetByName(const HttpHeader * hdr, const char *name)
+httpHeaderGetByName (const HttpHeader * hdr, const char *name)
 {
-    http_hdr_type id;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    String result = StringNull;
-
-    assert(hdr);
-    assert(name);
-
-    /* First try the quick path */
-    id = httpHeaderIdByNameDef(name, strlen(name));
-    if (id != -1)
-	return httpHeaderGetStrOrList(hdr, id);
-
-    /* Sorry, an unknown header name. Do linear search */
-    while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == HDR_OTHER && strCaseCmp(e->name, name) == 0) {
-	    strListAdd(&result, strBuf(e->value), ',');
+  http_hdr_type id;
+  HttpHeaderPos pos = HttpHeaderInitPos;
+  HttpHeaderEntry *e;
+  String result = StringNull;
+
+  assert (hdr);
+  assert (name);
+
+  /* First try the quick path */
+  id = httpHeaderIdByNameDef (name, strlen (name));
+  if (id != -1)
+    return httpHeaderGetStrOrList (hdr, id);
+
+  /* Sorry, an unknown header name. Do linear search */
+  while ((e = httpHeaderGetEntry (hdr, &pos)))
+    {
+      if (e->id == HDR_OTHER && strCaseCmp (e->name, name) == 0)
+	{
+	  strListAdd (&result, strBuf (e->value), ',');
 	}
     }
-    return result;
+  return result;
 }
 
 /* test if a field is present */
 int
-httpHeaderHas(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderHas (const HttpHeader * hdr, http_hdr_type id)
 {
-    assert(hdr);
-    assert_eid(id);
-    assert(id != HDR_OTHER);
-    debug(55, 7) ("%p lookup for %d\n", hdr, id);
-    return CBIT_TEST(hdr->mask, id);
+  assert (hdr);
+  assert_eid (id);
+  assert (id != HDR_OTHER);
+  debug (55, 7) ("%p lookup for %d\n", hdr, id);
+  return CBIT_TEST (hdr->mask, id);
 }
 
 void
-httpHeaderPutInt(HttpHeader * hdr, http_hdr_type id, int number)
+httpHeaderPutInt (HttpHeader * hdr, http_hdr_type id, int number)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt);	/* must be of an appropriate type */
-    assert(number >= 0);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, xitoa(number)));
+  assert_eid (id);
+  assert (Headers[id].type == ftInt);	/* must be of an appropriate type */
+  assert (number >= 0);
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (id, NULL, xitoa (number)));
 }
 
 void
-httpHeaderPutTime(HttpHeader * hdr, http_hdr_type id, time_t time)
+httpHeaderPutTime (HttpHeader * hdr, http_hdr_type id, time_t htime)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
-    assert(time >= 0);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, mkrfc1123(time)));
+  assert_eid (id);
+  assert (Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
+  assert (time >= 0);
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (id, NULL, mkrfc1123 (htime)));
 }
 
 void
-httpHeaderPutStr(HttpHeader * hdr, http_hdr_type id, const char *str)
+httpHeaderPutStr (HttpHeader * hdr, http_hdr_type id, const char *str)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
-    assert(str);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, str));
+  assert_eid (id);
+  assert (Headers[id].type == ftStr);	/* must be of an appropriate type */
+  assert (str);
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (id, NULL, str));
 }
 
 void
-httpHeaderPutAuth(HttpHeader * hdr, const char *authScheme, const char *realm)
+httpHeaderPutAuth (HttpHeader * hdr, const char *auth_scheme, const char *realm)
 {
-    assert(hdr && authScheme && realm);
-    httpHeaderPutStrf(hdr, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", authScheme, realm);
+  assert (hdr && auth_scheme && realm);
+  httpHeaderPutStrf (hdr, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
 }
 
 void
-httpHeaderPutCc(HttpHeader * hdr, const HttpHdrCc * cc)
+httpHeaderPutCc (HttpHeader * hdr, const HttpHdrCc * cc)
 {
-    MemBuf mb;
-    Packer p;
-    assert(hdr && cc);
-    /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_CACHE_CONTROL);
-    /* pack into mb */
-    memBufDefInit(&mb);
-    packerToMemInit(&p, &mb);
-    httpHdrCcPackInto(cc, &p);
-    /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_CACHE_CONTROL, NULL, mb.buf));
-    /* cleanup */
-    packerClean(&p);
-    memBufClean(&mb);
+  MemBuf mb;
+  Packer p;
+  assert (hdr && cc);
+  /* remove old directives if any */
+  httpHeaderDelById (hdr, HDR_CACHE_CONTROL);
+  /* pack into mb */
+  memBufDefInit (&mb);
+  packerToMemInit (&p, &mb);
+  httpHdrCcPackInto (cc, &p);
+  /* put */
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (HDR_CACHE_CONTROL, NULL, mb.buf));
+  /* cleanup */
+  packerClean (&p);
+  memBufClean (&mb);
 }
 
 void
-httpHeaderPutContRange(HttpHeader * hdr, const HttpHdrContRange * cr)
+httpHeaderPutContRange (HttpHeader * hdr, const HttpHdrContRange * cr)
 {
-    MemBuf mb;
-    Packer p;
-    assert(hdr && cr);
-    /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_CONTENT_RANGE);
-    /* pack into mb */
-    memBufDefInit(&mb);
-    packerToMemInit(&p, &mb);
-    httpHdrContRangePackInto(cr, &p);
-    /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_CONTENT_RANGE, NULL, mb.buf));
-    /* cleanup */
-    packerClean(&p);
-    memBufClean(&mb);
+  MemBuf mb;
+  Packer p;
+  assert (hdr && cr);
+  /* remove old directives if any */
+  httpHeaderDelById (hdr, HDR_CONTENT_RANGE);
+  /* pack into mb */
+  memBufDefInit (&mb);
+  packerToMemInit (&p, &mb);
+  httpHdrContRangePackInto (cr, &p);
+  /* put */
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (HDR_CONTENT_RANGE, NULL, mb.buf));
+  /* cleanup */
+  packerClean (&p);
+  memBufClean (&mb);
 }
 
 void
-httpHeaderPutRange(HttpHeader * hdr, const HttpHdrRange * range)
+httpHeaderPutRange (HttpHeader * hdr, const HttpHdrRange * range)
 {
-    MemBuf mb;
-    Packer p;
-    assert(hdr && range);
-    /* remove old directives if any */
-    httpHeaderDelById(hdr, HDR_RANGE);
-    /* pack into mb */
-    memBufDefInit(&mb);
-    packerToMemInit(&p, &mb);
-    httpHdrRangePackInto(range, &p);
-    /* put */
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_RANGE, NULL, mb.buf));
-    /* cleanup */
-    packerClean(&p);
-    memBufClean(&mb);
+  MemBuf mb;
+  Packer p;
+  assert (hdr && range);
+  /* remove old directives if any */
+  httpHeaderDelById (hdr, HDR_RANGE);
+  /* pack into mb */
+  memBufDefInit (&mb);
+  packerToMemInit (&p, &mb);
+  httpHdrRangePackInto (range, &p);
+  /* put */
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (HDR_RANGE, NULL, mb.buf));
+  /* cleanup */
+  packerClean (&p);
+  memBufClean (&mb);
 }
 
 /* add extension header (these fields are not parsed/analyzed/joined, etc.) */
 void
-httpHeaderPutExt(HttpHeader * hdr, const char *name, const char *value)
+httpHeaderPutExt (HttpHeader * hdr, const char *name, const char *value)
 {
-    assert(name && value);
-    debug(55, 8) ("%p adds ext entry '%s: %s'\n", hdr, name, value);
-    httpHeaderAddEntry(hdr, httpHeaderEntryCreate(HDR_OTHER, name, value));
+  assert (name && value);
+  debug (55, 8) ("%p adds ext entry '%s: %s'\n", hdr, name, value);
+  httpHeaderAddEntry (hdr, httpHeaderEntryCreate (HDR_OTHER, name, value));
 }
 
 int
-httpHeaderGetInt(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetInt (const HttpHeader * hdr, http_hdr_type id)
 {
-    HttpHeaderEntry *e;
-    int value = -1;
-    int ok;
-    assert_eid(id);
-    assert(Headers[id].type == ftInt);	/* must be of an appropriate type */
-    if ((e = httpHeaderFindEntry(hdr, id))) {
-	ok = httpHeaderParseInt(strBuf(e->value), &value);
-	httpHeaderNoteParsedEntry(e->id, e->value, !ok);
+  HttpHeaderEntry *e;
+  int value = -1;
+  int ok;
+  assert_eid (id);
+  assert (Headers[id].type == ftInt);	/* must be of an appropriate type */
+  if ((e = httpHeaderFindEntry (hdr, id)))
+    {
+      ok = httpHeaderParseInt (strBuf (e->value), &value);
+      httpHeaderNoteParsedEntry (e->id, e->value, !ok);
     }
-    return value;
+  return value;
 }
 
 time_t
-httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetTime (const HttpHeader * hdr, http_hdr_type id)
 {
-    HttpHeaderEntry *e;
-    time_t value = -1;
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
-    if ((e = httpHeaderFindEntry(hdr, id))) {
-	value = parse_rfc1123(strBuf(e->value));
-	httpHeaderNoteParsedEntry(e->id, e->value, value < 0);
+  HttpHeaderEntry *e;
+  time_t value = -1;
+  assert_eid (id);
+  assert (Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
+  if ((e = httpHeaderFindEntry (hdr, id)))
+    {
+      value = parse_rfc1123 (strBuf (e->value));
+      httpHeaderNoteParsedEntry (e->id, e->value, value < 0);
     }
-    return value;
+  return value;
 }
 
 /* sync with httpHeaderGetLastStr */
 const char *
-httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetStr (const HttpHeader * hdr, http_hdr_type id)
 {
-    HttpHeaderEntry *e;
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
-    if ((e = httpHeaderFindEntry(hdr, id))) {
-	httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
-	return strBuf(e->value);
+  HttpHeaderEntry *e;
+  assert_eid (id);
+  assert (Headers[id].type == ftStr);	/* must be of an appropriate type */
+  if ((e = httpHeaderFindEntry (hdr, id)))
+    {
+      httpHeaderNoteParsedEntry (e->id, e->value, 0);	/* no errors are possible */
+      return strBuf (e->value);
     }
-    return NULL;
+  return NULL;
 }
 
 /* unusual */
 const char *
-httpHeaderGetLastStr(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetLastStr (const HttpHeader * hdr, http_hdr_type id)
 {
-    HttpHeaderEntry *e;
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
-    if ((e = httpHeaderFindLastEntry(hdr, id))) {
-	httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
-	return strBuf(e->value);
+  HttpHeaderEntry *e;
+  assert_eid (id);
+  assert (Headers[id].type == ftStr);	/* must be of an appropriate type */
+  if ((e = httpHeaderFindLastEntry (hdr, id)))
+    {
+      httpHeaderNoteParsedEntry (e->id, e->value, 0);	/* no errors are possible */
+      return strBuf (e->value);
     }
-    return NULL;
+  return NULL;
 }
 
 HttpHdrCc *
-httpHeaderGetCc(const HttpHeader * hdr)
+httpHeaderGetCc (const HttpHeader * hdr)
 {
-    HttpHdrCc *cc;
-    String s;
-    if (!CBIT_TEST(hdr->mask, HDR_CACHE_CONTROL))
-	return NULL;
-    s = httpHeaderGetList(hdr, HDR_CACHE_CONTROL);
-    cc = httpHdrCcParseCreate(&s);
-    HttpHeaderStats[hdr->owner].ccParsedCount++;
-    if (cc)
-	httpHdrCcUpdateStats(cc, &HttpHeaderStats[hdr->owner].ccTypeDistr);
-    httpHeaderNoteParsedEntry(HDR_CACHE_CONTROL, s, !cc);
-    stringClean(&s);
-    return cc;
+  HttpHdrCc *cc;
+  String s;
+  if (!CBIT_TEST (hdr->mask, HDR_CACHE_CONTROL))
+    return NULL;
+  s = httpHeaderGetList (hdr, HDR_CACHE_CONTROL);
+  cc = httpHdrCcParseCreate (&s);
+  HttpHeaderStats[hdr->owner].ccParsedCount++;
+  if (cc)
+    httpHdrCcUpdateStats (cc, &HttpHeaderStats[hdr->owner].ccTypeDistr);
+  httpHeaderNoteParsedEntry (HDR_CACHE_CONTROL, s, !cc);
+  stringClean (&s);
+  return cc;
 }
 
 HttpHdrRange *
-httpHeaderGetRange(const HttpHeader * hdr)
+httpHeaderGetRange (const HttpHeader * hdr)
 {
-    HttpHdrRange *r = NULL;
-    HttpHeaderEntry *e;
-    /* some clients will send "Request-Range" _and_ *matching* "Range"
-     * who knows, some clients might send Request-Range only;
-     * this "if" should work correctly in both cases;
-     * hopefully no clients send mismatched headers! */
-    if ((e = httpHeaderFindEntry(hdr, HDR_RANGE)) ||
-	(e = httpHeaderFindEntry(hdr, HDR_REQUEST_RANGE))) {
-	r = httpHdrRangeParseCreate(&e->value);
-	httpHeaderNoteParsedEntry(e->id, e->value, !r);
+  HttpHdrRange *r = NULL;
+  HttpHeaderEntry *e;
+  /* some clients will send "Request-Range" _and_ *matching* "Range"
+   * who knows, some clients might send Request-Range only;
+   * this "if" should work correctly in both cases;
+   * hopefully no clients send mismatched headers! */
+  if ((e = httpHeaderFindEntry (hdr, HDR_RANGE)) ||
+      (e = httpHeaderFindEntry (hdr, HDR_REQUEST_RANGE)))
+    {
+      r = httpHdrRangeParseCreate (&e->value);
+      httpHeaderNoteParsedEntry (e->id, e->value, !r);
     }
-    return r;
+  return r;
 }
 
 HttpHdrContRange *
-httpHeaderGetContRange(const HttpHeader * hdr)
+httpHeaderGetContRange (const HttpHeader * hdr)
 {
-    HttpHdrContRange *cr = NULL;
-    HttpHeaderEntry *e;
-    if ((e = httpHeaderFindEntry(hdr, HDR_CONTENT_RANGE))) {
-	cr = httpHdrContRangeParseCreate(strBuf(e->value));
-	httpHeaderNoteParsedEntry(e->id, e->value, !cr);
+  HttpHdrContRange *cr = NULL;
+  HttpHeaderEntry *e;
+  if ((e = httpHeaderFindEntry (hdr, HDR_CONTENT_RANGE)))
+    {
+      cr = httpHdrContRangeParseCreate (strBuf (e->value));
+      httpHeaderNoteParsedEntry (e->id, e->value, !cr);
     }
-    return cr;
+  return cr;
 }
 
 const char *
-httpHeaderGetAuth(const HttpHeader * hdr, http_hdr_type id, const char *authScheme)
+httpHeaderGetAuth (const HttpHeader * hdr, http_hdr_type id, const char *auth_scheme)
 {
-    const char *field;
-    int l;
-    assert(hdr && authScheme);
-    field = httpHeaderGetStr(hdr, id);
-    if (!field)			/* no authorization field */
-	return NULL;
-    l = strlen(authScheme);
-    if (!l || strncasecmp(field, authScheme, l))	/* wrong scheme */
-	return NULL;
-    field += l;
-    if (!xisspace(*field))	/* wrong scheme */
-	return NULL;
-    /* skip white space */
-    field += xcountws(field);
-    if (!*field)		/* no authorization cookie */
-	return NULL;
-    return base64_decode(field);
+  const char *field;
+  int l;
+  assert (hdr && auth_scheme);
+  field = httpHeaderGetStr (hdr, id);
+  if (!field)			/* no authorization field */
+    return NULL;
+  l = strlen (auth_scheme);
+  if (!l || strncasecmp (field, auth_scheme, l))	/* wrong scheme */
+    return NULL;
+  field += l;
+  if (!xisspace (*field))	/* wrong scheme */
+    return NULL;
+  /* skip white space */
+  field += xcountws (field);
+  if (!*field)			/* no authorization cookie */
+    return NULL;
+  return base64_decode (field);
 }
 
 ETag
-httpHeaderGetETag(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetETag (const HttpHeader * hdr, http_hdr_type id)
 {
-    ETag etag =
-    {NULL, -1};
-    HttpHeaderEntry *e;
-    assert(Headers[id].type == ftETag);		/* must be of an appropriate type */
-    if ((e = httpHeaderFindEntry(hdr, id)))
-	etagParseInit(&etag, strBuf(e->value));
-    return etag;
+  ETag etag =
+  {NULL, -1};
+  HttpHeaderEntry *e;
+  assert (Headers[id].type == ftETag);	/* must be of an appropriate type */
+  if ((e = httpHeaderFindEntry (hdr, id)))
+    etagParseInit (&etag, strBuf (e->value));
+  return etag;
 }
 
 TimeOrTag
-httpHeaderGetTimeOrTag(const HttpHeader * hdr, http_hdr_type id)
+httpHeaderGetTimeOrTag (const HttpHeader * hdr, http_hdr_type id)
 {
-    TimeOrTag tot;
-    HttpHeaderEntry *e;
-    assert(Headers[id].type == ftDate_1123_or_ETag);	/* must be of an appropriate type */
-    memset(&tot, 0, sizeof(tot));
-    if ((e = httpHeaderFindEntry(hdr, id))) {
-	const char *str = strBuf(e->value);
-	/* try as an ETag */
-	if (etagParseInit(&tot.tag, str)) {
-	    tot.valid = tot.tag.str != NULL;
-	    tot.time = -1;
-	} else {
-	    /* or maybe it is time? */
-	    tot.time = parse_rfc1123(str);
-	    tot.valid = tot.time >= 0;
-	    tot.tag.str = NULL;
+  TimeOrTag tot;
+  HttpHeaderEntry *e;
+  assert (Headers[id].type == ftDate_1123_or_ETag);	/* must be of an appropriate type */
+  memset (&tot, 0, sizeof (tot));
+  if ((e = httpHeaderFindEntry (hdr, id)))
+    {
+      const char *str = strBuf (e->value);
+      /* try as an ETag */
+      if (etagParseInit (&tot.tag, str))
+	{
+	  tot.valid = tot.tag.str != NULL;
+	  tot.time = -1;
+	}
+      else
+	{
+	  /* or maybe it is time? */
+	  tot.time = parse_rfc1123 (str);
+	  tot.valid = tot.time >= 0;
+	  tot.tag.str = NULL;
 	}
     }
-    assert(tot.time < 0 || !tot.tag.str);	/* paranoid */
-    return tot;
+  assert (tot.time < 0 || !tot.tag.str);	/* paranoid */
+  return tot;
 }
 
 /*
  * HttpHeaderEntry
  */
 
 static HttpHeaderEntry *
-httpHeaderEntryCreate(http_hdr_type id, const char *name, const char *value)
+httpHeaderEntryCreate (http_hdr_type id, const char *name, const char *value)
 {
-    HttpHeaderEntry *e;
-    assert_eid(id);
-    e = memAllocate(MEM_HTTP_HDR_ENTRY);
-    e->id = id;
-    if (id != HDR_OTHER)
-	e->name = Headers[id].name;
-    else
-	stringInit(&e->name, name);
-    stringInit(&e->value, value);
-    Headers[id].stat.aliveCount++;
-    debug(55, 9) ("created entry %p: '%s: %s'\n", e, strBuf(e->name), strBuf(e->value));
-    return e;
+  HttpHeaderEntry *e;
+  assert_eid (id);
+  e = memAllocate (MEM_HTTP_HDR_ENTRY);
+  e->id = id;
+  if (id != HDR_OTHER)
+    e->name = Headers[id].name;
+  else
+    stringInit (&e->name, name);
+  stringInit (&e->value, value);
+  Headers[id].stat.aliveCount++;
+  debug (55, 9) ("created entry %p: '%s: %s'\n", e, strBuf (e->name), strBuf (e->value));
+  return e;
 }
 
 static void
-httpHeaderEntryDestroy(HttpHeaderEntry * e)
+httpHeaderEntryDestroy (HttpHeaderEntry * e)
 {
-    assert(e);
-    assert_eid(e->id);
-    debug(55, 9) ("destroying entry %p: '%s: %s'\n", e, strBuf(e->name), strBuf(e->value));
-    /* clean name if needed */
-    if (e->id == HDR_OTHER)
-	stringClean(&e->name);
-    stringClean(&e->value);
-    assert(Headers[e->id].stat.aliveCount);
-    Headers[e->id].stat.aliveCount--;
-    e->id = -1;
-    memFree(e, MEM_HTTP_HDR_ENTRY);
+  assert (e);
+  assert_eid (e->id);
+  debug (55, 9) ("destroying entry %p: '%s: %s'\n", e, strBuf (e->name), strBuf (e->value));
+  /* clean name if needed */
+  if (e->id == HDR_OTHER)
+    stringClean (&e->name);
+  stringClean (&e->value);
+  assert (Headers[e->id].stat.aliveCount);
+  Headers[e->id].stat.aliveCount--;
+  e->id = -1;
+  memFree (e, MEM_HTTP_HDR_ENTRY);
 }
 
 /* parses and inits header entry, returns new entry on success */
 static HttpHeaderEntry *
-httpHeaderEntryParseCreate(const char *field_start, const char *field_end)
+httpHeaderEntryParseCreate (const char *field_start, const char *field_end)
 {
-    HttpHeaderEntry *e;
-    int id;
-    /* note: name_start == field_start */
-    const char *name_end = strchr(field_start, ':');
-    const int name_len = name_end ? name_end - field_start : 0;
-    const char *value_start = field_start + name_len + 1;	/* skip ':' */
-    /* note: value_end == field_end */
-
-    HeaderEntryParsedCount++;
-
-    /* do we have a valid field name within this field? */
-    if (!name_len || name_end > field_end)
-	return NULL;
-    if (name_len > 65536) {
-	/* String has a 64K limit */
-	debug(55, 1) ("WARNING: ignoring header name of %d bytes\n", name_len);
-	return NULL;
+  HttpHeaderEntry *e;
+  int id;
+  /* note: name_start == field_start */
+  const char *name_end = strchr (field_start, ':');
+  const int name_len = name_end ? name_end - field_start : 0;
+  const char *value_start = field_start + name_len + 1;		/* skip ':' */
+  /* note: value_end == field_end */
+
+  HeaderEntryParsedCount++;
+
+  /* do we have a valid field name within this field? */
+  if (!name_len || name_end > field_end)
+    return NULL;
+  if (name_len > 65536)
+    {
+      /* String has a 64K limit */
+      debug (55, 1) ("WARNING: ignoring header name of %d bytes\n", name_len);
+      return NULL;
     }
-    /* now we know we can parse it */
-    e = memAllocate(MEM_HTTP_HDR_ENTRY);
-    debug(55, 9) ("creating entry %p: near '%s'\n", e, getStringPrefix(field_start, field_end));
-    /* is it a "known" field? */
-    id = httpHeaderIdByName(field_start, name_len, Headers, HDR_ENUM_END);
-    if (id < 0)
-	id = HDR_OTHER;
-    assert_eid(id);
-    e->id = id;
-    /* set field name */
-    if (id == HDR_OTHER)
-	stringLimitInit(&e->name, field_start, name_len);
-    else
-	e->name = Headers[id].name;
-    /* trim field value */
-    while (value_start < field_end && xisspace(*value_start))
-	value_start++;
-    if (field_end - value_start > 65536) {
-	/* String has a 64K limit */
-	debug(55, 1) ("WARNING: ignoring '%s' header of %d bytes\n",
-	    strBuf(e->name), field_end - value_start);
-	if (e->id == HDR_OTHER)
-	    stringClean(&e->name);
-	memFree(e, MEM_HTTP_HDR_ENTRY);
-	return NULL;
+  /* now we know we can parse it */
+  e = memAllocate (MEM_HTTP_HDR_ENTRY);
+  debug (55, 9) ("creating entry %p: near '%s'\n", e, getStringPrefix (field_start, field_end));
+  /* is it a "known" field? */
+  id = httpHeaderIdByName (field_start, name_len, Headers, HDR_ENUM_END);
+  if (id < 0)
+    id = HDR_OTHER;
+  assert_eid (id);
+  e->id = id;
+  /* set field name */
+  if (id == HDR_OTHER)
+    stringLimitInit (&e->name, field_start, name_len);
+  else
+    e->name = Headers[id].name;
+  /* trim field value */
+  while (value_start < field_end && xisspace (*value_start))
+    value_start++;
+  if (field_end - value_start > 65536)
+    {
+      /* String has a 64K limit */
+      debug (55, 1) ("WARNING: ignoring '%s' header of %d bytes\n",
+		     strBuf (e->name), field_end - value_start);
+      if (e->id == HDR_OTHER)
+	stringClean (&e->name);
+      memFree (e, MEM_HTTP_HDR_ENTRY);
+      return NULL;
     }
-    /* set field value */
-    stringLimitInit(&e->value, value_start, field_end - value_start);
-    Headers[id].stat.seenCount++;
-    Headers[id].stat.aliveCount++;
-    debug(55, 9) ("created entry %p: '%s: %s'\n", e, strBuf(e->name), strBuf(e->value));
-    return e;
+  /* set field value */
+  stringLimitInit (&e->value, value_start, field_end - value_start);
+  Headers[id].stat.seenCount++;
+  Headers[id].stat.aliveCount++;
+  debug (55, 9) ("created entry %p: '%s: %s'\n", e, strBuf (e->name), strBuf (e->value));
+  return e;
 }
 
 HttpHeaderEntry *
-httpHeaderEntryClone(const HttpHeaderEntry * e)
+httpHeaderEntryClone (const HttpHeaderEntry * e)
 {
-    return httpHeaderEntryCreate(e->id, strBuf(e->name), strBuf(e->value));
+  return httpHeaderEntryCreate (e->id, strBuf (e->name), strBuf (e->value));
 }
 
 void
-httpHeaderEntryPackInto(const HttpHeaderEntry * e, Packer * p)
+httpHeaderEntryPackInto (const HttpHeaderEntry * e, Packer * p)
 {
-    assert(e && p);
-    packerAppend(p, strBuf(e->name), strLen(e->name));
-    packerAppend(p, ": ", 2);
-    packerAppend(p, strBuf(e->value), strLen(e->value));
-    packerAppend(p, "\r\n", 2);
+  assert (e && p);
+  packerAppend (p, strBuf (e->name), strLen (e->name));
+  packerAppend (p, ": ", 2);
+  packerAppend (p, strBuf (e->value), strLen (e->value));
+  packerAppend (p, "\r\n", 2);
 }
 
 static void
-httpHeaderNoteParsedEntry(http_hdr_type id, String context, int error)
+httpHeaderNoteParsedEntry (http_hdr_type id, String context, int error)
 {
-    Headers[id].stat.parsCount++;
-    if (error) {
-	Headers[id].stat.errCount++;
-	debug(55, 2) ("cannot parse hdr field: '%s: %s'\n",
-	    strBuf(Headers[id].name), strBuf(context));
+  Headers[id].stat.parsCount++;
+  if (error)
+    {
+      Headers[id].stat.errCount++;
+      debug (55, 2) ("cannot parse hdr field: '%s: %s'\n",
+		     strBuf (Headers[id].name), strBuf (context));
     }
 }
 
@@ -1063,117 +1097,120 @@ extern const HttpHeaderStat *dump_stat;		/* argh! */
 const HttpHeaderStat *dump_stat = NULL;
 
 static void
-httpHeaderFieldStatDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHeaderFieldStatDumper (StoreEntry * sentry, int idx, double val, double size, int count)
 {
-    const int id = (int) val;
-    const int valid_id = id >= 0 && id < HDR_ENUM_END;
-    const char *name = valid_id ? strBuf(Headers[id].name) : "INVALID";
-    int visible = count > 0;
-    /* for entries with zero count, list only those that belong to current type of message */
-    if (!visible && valid_id && dump_stat->owner_mask)
-	visible = CBIT_TEST(*dump_stat->owner_mask, id);
-    if (visible)
-	storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
-	    id, name, count, xdiv(count, dump_stat->busyDestroyedCount));
+  const int id = (int) val;
+  const int valid_id = id >= 0 && id < HDR_ENUM_END;
+  const char *name = valid_id ? strBuf (Headers[id].name) : "INVALID";
+  int visible = count > 0;
+  /* for entries with zero count, list only those that belong to current type of message */
+  if (!visible && valid_id && dump_stat->owner_mask)
+    visible = CBIT_TEST (*dump_stat->owner_mask, id);
+  if (visible)
+    storeAppendPrintf (sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
+	      id, name, count, xdiv (count, dump_stat->busyDestroyedCount));
 }
 
 static void
-httpHeaderFldsPerHdrDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHeaderFldsPerHdrDumper (StoreEntry * sentry, int idx, double val, double size, int count)
 {
-    if (count)
-	storeAppendPrintf(sentry, "%2d\t %5d\t %5d\t %6.2f\n",
-	    idx, (int) val, count,
-	    xpercent(count, dump_stat->destroyedCount));
+  if (count)
+    storeAppendPrintf (sentry, "%2d\t %5d\t %5d\t %6.2f\n",
+		       idx, (int) val, count,
+		       xpercent (count, dump_stat->destroyedCount));
 }
 
 
 static void
-httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
+httpHeaderStatDump (const HttpHeaderStat * hs, StoreEntry * e)
 {
-    assert(hs && e);
-
-    dump_stat = hs;
-    storeAppendPrintf(e, "\nHeader Stats: %s\n", hs->label);
-    storeAppendPrintf(e, "\nField type distribution\n");
-    storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\n",
-	"id", "name", "count", "#/header");
-    statHistDump(&hs->fieldTypeDistr, e, httpHeaderFieldStatDumper);
-    storeAppendPrintf(e, "\nCache-control directives distribution\n");
-    storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\n",
-	"id", "name", "count", "#/cc_field");
-    statHistDump(&hs->ccTypeDistr, e, httpHdrCcStatDumper);
-    storeAppendPrintf(e, "\nNumber of fields per header distribution\n");
-    storeAppendPrintf(e, "%2s\t %-5s\t %5s\t %6s\n",
-	"id", "#flds", "count", "%total");
-    statHistDump(&hs->hdrUCountDistr, e, httpHeaderFldsPerHdrDumper);
-    dump_stat = NULL;
+  assert (hs && e);
+
+  dump_stat = hs;
+  storeAppendPrintf (e, "\nHeader Stats: %s\n", hs->label);
+  storeAppendPrintf (e, "\nField type distribution\n");
+  storeAppendPrintf (e, "%2s\t %-20s\t %5s\t %6s\n",
+		     "id", "name", "count", "#/header");
+  statHistDump (&hs->fieldTypeDistr, e, httpHeaderFieldStatDumper);
+  storeAppendPrintf (e, "\nCache-control directives distribution\n");
+  storeAppendPrintf (e, "%2s\t %-20s\t %5s\t %6s\n",
+		     "id", "name", "count", "#/cc_field");
+  statHistDump (&hs->ccTypeDistr, e, httpHdrCcStatDumper);
+  storeAppendPrintf (e, "\nNumber of fields per header distribution\n");
+  storeAppendPrintf (e, "%2s\t %-5s\t %5s\t %6s\n",
+		     "id", "#flds", "count", "%total");
+  statHistDump (&hs->hdrUCountDistr, e, httpHeaderFldsPerHdrDumper);
+  dump_stat = NULL;
 }
 
 void
-httpHeaderStoreReport(StoreEntry * e)
+httpHeaderStoreReport (StoreEntry * e)
 {
-    int i;
-    http_hdr_type ht;
-    assert(e);
-
-    HttpHeaderStats[0].parsedCount =
-	HttpHeaderStats[hoRequest].parsedCount + HttpHeaderStats[hoReply].parsedCount;
-    HttpHeaderStats[0].ccParsedCount =
-	HttpHeaderStats[hoRequest].ccParsedCount + HttpHeaderStats[hoReply].ccParsedCount;
-    HttpHeaderStats[0].destroyedCount =
-	HttpHeaderStats[hoRequest].destroyedCount + HttpHeaderStats[hoReply].destroyedCount;
-    HttpHeaderStats[0].busyDestroyedCount =
-	HttpHeaderStats[hoRequest].busyDestroyedCount + HttpHeaderStats[hoReply].busyDestroyedCount;
-
-    for (i = 1; i < HttpHeaderStatCount; i++) {
-	httpHeaderStatDump(HttpHeaderStats + i, e);
-	storeAppendPrintf(e, "%s\n", "<br>");
+  int i;
+  http_hdr_type ht;
+  assert (e);
+
+  HttpHeaderStats[0].parsedCount =
+    HttpHeaderStats[hoRequest].parsedCount + HttpHeaderStats[hoReply].parsedCount;
+  HttpHeaderStats[0].ccParsedCount =
+    HttpHeaderStats[hoRequest].ccParsedCount + HttpHeaderStats[hoReply].ccParsedCount;
+  HttpHeaderStats[0].destroyedCount =
+    HttpHeaderStats[hoRequest].destroyedCount + HttpHeaderStats[hoReply].destroyedCount;
+  HttpHeaderStats[0].busyDestroyedCount =
+    HttpHeaderStats[hoRequest].busyDestroyedCount + HttpHeaderStats[hoReply].busyDestroyedCount;
+
+  for (i = 1; i < HttpHeaderStatCount; i++)
+    {
+      httpHeaderStatDump (HttpHeaderStats + i, e);
+      storeAppendPrintf (e, "%s\n", "<br>");
     }
-    /* field stats for all messages */
-    storeAppendPrintf(e, "\nHttp Fields Stats (replies and requests)\n");
-    storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\t %6s\n",
-	"id", "name", "#alive", "%err", "%repeat");
-    for (ht = 0; ht < HDR_ENUM_END; ht++) {
-	HttpHeaderFieldInfo *f = Headers + ht;
-	storeAppendPrintf(e, "%2d\t %-20s\t %5d\t %6.3f\t %6.3f\n",
-	    f->id, strBuf(f->name), f->stat.aliveCount,
-	    xpercent(f->stat.errCount, f->stat.parsCount),
-	    xpercent(f->stat.repCount, f->stat.seenCount));
+  /* field stats for all messages */
+  storeAppendPrintf (e, "\nHttp Fields Stats (replies and requests)\n");
+  storeAppendPrintf (e, "%2s\t %-20s\t %5s\t %6s\t %6s\n",
+		     "id", "name", "#alive", "%err", "%repeat");
+  for (ht = 0; ht < HDR_ENUM_END; ht++)
+    {
+      HttpHeaderFieldInfo *f = Headers + ht;
+      storeAppendPrintf (e, "%2d\t %-20s\t %5d\t %6.3f\t %6.3f\n",
+			 f->id, strBuf (f->name), f->stat.aliveCount,
+			 xpercent (f->stat.errCount, f->stat.parsCount),
+			 xpercent (f->stat.repCount, f->stat.seenCount));
     }
-    storeAppendPrintf(e, "Headers Parsed: %d + %d = %d\n",
-	HttpHeaderStats[hoRequest].parsedCount,
-	HttpHeaderStats[hoReply].parsedCount,
-	HttpHeaderStats[0].parsedCount);
-    storeAppendPrintf(e, "Hdr Fields Parsed: %d\n", HeaderEntryParsedCount);
+  storeAppendPrintf (e, "Headers Parsed: %d + %d = %d\n",
+		     HttpHeaderStats[hoRequest].parsedCount,
+		     HttpHeaderStats[hoReply].parsedCount,
+		     HttpHeaderStats[0].parsedCount);
+  storeAppendPrintf (e, "Hdr Fields Parsed: %d\n", HeaderEntryParsedCount);
 }
 
 int
-httpHeaderIdByName(const char *name, int name_len, const HttpHeaderFieldInfo * info, int end)
+httpHeaderIdByName (const char *name, int name_len, const HttpHeaderFieldInfo * info, int end)
 {
-    int i;
-    for (i = 0; i < end; ++i) {
-	if (name_len >= 0 && name_len != strLen(info[i].name))
-	    continue;
-	if (!strncasecmp(name, strBuf(info[i].name),
-		name_len < 0 ? strLen(info[i].name) + 1 : name_len))
-	    return i;
+  int i;
+  for (i = 0; i < end; ++i)
+    {
+      if (name_len >= 0 && name_len != strLen (info[i].name))
+	continue;
+      if (!strncasecmp (name, strBuf (info[i].name),
+			name_len < 0 ? strLen (info[i].name) + 1 : name_len))
+	return i;
     }
-    return -1;
+  return -1;
 }
 
 int
-httpHeaderIdByNameDef(const char *name, int name_len)
+httpHeaderIdByNameDef (const char *name, int name_len)
 {
-    if (!Headers)
-	Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-    return httpHeaderIdByName(name, name_len, Headers, HDR_ENUM_END);
+  if (!Headers)
+    Headers = httpHeaderBuildFieldsInfo (HeadersAttrs, HDR_ENUM_END);
+  return httpHeaderIdByName (name, name_len, Headers, HDR_ENUM_END);
 }
 
 const char *
-httpHeaderNameById(int id)
+httpHeaderNameById (int id)
 {
-    if (!Headers)
-	Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-    assert(id >= 0 && id < HDR_ENUM_END);
-    return HeadersAttrs[id].name;
+  if (!Headers)
+    Headers = httpHeaderBuildFieldsInfo (HeadersAttrs, HDR_ENUM_END);
+  assert (id >= 0 && id < HDR_ENUM_END);
+  return HeadersAttrs[id].name;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.69 2001/08/22 23:26:05 robertc Exp $
+ * $Id: access_log.cc,v 1.70 2001/10/17 10:59:08 adrian Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -36,8 +36,8 @@
 
 #include "squid.h"
 
-static void accessLogSquid(AccessLogEntry * al);
-static void accessLogCommon(AccessLogEntry * al);
+static void accessLogSquid (AccessLogEntry * al);
+static void accessLogCommon (AccessLogEntry * al);
 static Logfile *logfile = NULL;
 #if HEADERS_LOG
 static Logfile *headerslog = NULL;
@@ -46,50 +46,52 @@ static Logfile *headerslog = NULL;
 #if MULTICAST_MISS_STREAM
 static int mcast_miss_fd = -1;
 static struct sockaddr_in mcast_miss_to;
-static void mcast_encode(unsigned int *, size_t, const unsigned int *);
+static void mcast_encode (unsigned int *, size_t, const unsigned int *);
 #endif
 
 const char *log_tags[] =
 {
-    "NONE",
-    "TCP_HIT",
-    "TCP_MISS",
-    "TCP_REFRESH_HIT",
-    "TCP_REF_FAIL_HIT",
-    "TCP_REFRESH_MISS",
-    "TCP_CLIENT_REFRESH_MISS",
-    "TCP_IMS_HIT",
-    "TCP_SWAPFAIL_MISS",
-    "TCP_NEGATIVE_HIT",
-    "TCP_MEM_HIT",
-    "TCP_DENIED",
-    "TCP_OFFLINE_HIT",
+  "NONE",
+  "TCP_HIT",
+  "TCP_MISS",
+  "TCP_REFRESH_HIT",
+  "TCP_REF_FAIL_HIT",
+  "TCP_REFRESH_MISS",
+  "TCP_CLIENT_REFRESH_MISS",
+  "TCP_IMS_HIT",
+  "TCP_SWAPFAIL_MISS",
+  "TCP_NEGATIVE_HIT",
+  "TCP_MEM_HIT",
+  "TCP_DENIED",
+  "TCP_OFFLINE_HIT",
 #if LOG_TCP_REDIRECTS
-    "TCP_REDIRECT",
+  "TCP_REDIRECT",
 #endif
-    "UDP_HIT",
-    "UDP_MISS",
-    "UDP_DENIED",
-    "UDP_INVALID",
-    "UDP_MISS_NOFETCH",
-    "ICP_QUERY",
-    "LOG_TYPE_MAX"
+  "UDP_HIT",
+  "UDP_MISS",
+  "UDP_DENIED",
+  "UDP_INVALID",
+  "UDP_MISS_NOFETCH",
+  "ICP_QUERY",
+  "LOG_TYPE_MAX"
 };
 
 #if FORW_VIA_DB
-typedef struct {
+typedef struct
+  {
     hash_link hash;
     int n;
-} fvdb_entry;
+  }
+fvdb_entry;
 static hash_table *via_table = NULL;
 static hash_table *forw_table = NULL;
-static void fvdbInit(void);
-static void fvdbDumpTable(StoreEntry * e, hash_table * hash);
-static void fvdbCount(hash_table * hash, const char *key);
+static void fvdbInit (void);
+static void fvdbDumpTable (StoreEntry * e, hash_table * hash);
+static void fvdbCount (hash_table * hash, const char *key);
 static OBJH fvdbDumpVia;
 static OBJH fvdbDumpForw;
 static FREE fvdbFreeEntry;
-static void fvdbClear(void);
+static void fvdbClear (void);
 #endif
 
 static int LogfileStatus = LOG_DISABLE;
@@ -116,401 +118,429 @@ static const char c2x[] =
 /* log_quote -- URL-style encoding on MIME headers. */
 
 char *
-log_quote(const char *header)
+log_quote (const char *header)
 {
-    int c;
-    int i;
-    char *buf;
-    char *buf_cursor;
-    if (header == NULL) {
-	buf = xcalloc(1, 1);
-	*buf = '\0';
-	return buf;
+  int c;
+  int i;
+  char *buf;
+  char *buf_cursor;
+  if (header == NULL)
+    {
+      buf = xcalloc (1, 1);
+      *buf = '\0';
+      return buf;
     }
-    buf = xcalloc((strlen(header) * 3) + 1, 1);
-    buf_cursor = buf;
-    /*
-     * We escape: \x00-\x1F"#%;<>?{}|\\\\^~`\[\]\x7F-\xFF 
-     * which is the default escape list for the CPAN Perl5 URI module
-     * modulo the inclusion of space (x40) to make the raw logs a bit
-     * more readable.
-     */
-    while ((c = *(const unsigned char *) header++) != '\0') {
+  buf = xcalloc (1, (strlen (header) * 3) + 1);
+  buf_cursor = buf;
+  /*
+   * We escape: \x00-\x1F"#%;<>?{}|\\\\^~`\[\]\x7F-\xFF 
+   * which is the default escape list for the CPAN Perl5 URI module
+   * modulo the inclusion of space (x40) to make the raw logs a bit
+   * more readable.
+   */
+  while ((c = *(const unsigned char *) header++) != '\0')
+    {
 #if !OLD_LOG_MIME
-	if (c == '\r') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'r';
-	} else if (c == '\n') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'n';
-	} else
+      if (c == '\r')
+	{
+	  *buf_cursor++ = '\\';
+	  *buf_cursor++ = 'r';
+	}
+      else if (c == '\n')
+	{
+	  *buf_cursor++ = '\\';
+	  *buf_cursor++ = 'n';
+	}
+      else
 #endif
-	    if (c <= 0x1F
-		|| c >= 0x7F
+	if (c <= 0x1F
+	    || c >= 0x7F
 #if OLD_LOG_MIME
-		|| c == '"'
-		|| c == '#'
-		|| c == '%'
-		|| c == ';'
-		|| c == '<'
-		|| c == '>'
-		|| c == '?'
-		|| c == '{'
-		|| c == '}'
-		|| c == '|'
-		|| c == '\\'
-		|| c == '^'
-		|| c == '~'
-		|| c == '`'
+	    || c == '"'
+	    || c == '#'
+	    || c == '%'
+	    || c == ';'
+	    || c == '<'
+	    || c == '>'
+	    || c == '?'
+	    || c == '{'
+	    || c == '}'
+	    || c == '|'
+	    || c == '\\'
+	    || c == '^'
+	    || c == '~'
+	    || c == '`'
 #endif
-		|| c == '['
-	    || c == ']') {
-	    *buf_cursor++ = '%';
-	    i = c * 2;
-	    *buf_cursor++ = c2x[i];
-	    *buf_cursor++ = c2x[i + 1];
+	    || c == '['
+	    || c == ']')
+	{
+	  *buf_cursor++ = '%';
+	  i = c * 2;
+	  *buf_cursor++ = c2x[i];
+	  *buf_cursor++ = c2x[i + 1];
 #if !OLD_LOG_MIME
-	} else if (c == '\\') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = '\\';
+	}
+      else if (c == '\\')
+	{
+	  *buf_cursor++ = '\\';
+	  *buf_cursor++ = '\\';
 #endif
-	} else {
-	    *buf_cursor++ = (char) c;
+	}
+      else
+	{
+	  *buf_cursor++ = (char) c;
 	}
     }
-    *buf_cursor = '\0';
-    return buf;
+  *buf_cursor = '\0';
+  return buf;
 }
 
 static char *
-username_quote(const char *header)
+username_quote (const char *header)
 /* copy of log_quote. Bugs there will be found here */
 {
-    int c;
-    int i;
-    char *buf;
-    char *buf_cursor;
-    if (header == NULL) {
-	buf = xcalloc(1, 1);
-	*buf = '\0';
-	return buf;
+  int c;
+  int i;
+  char *buf;
+  char *buf_cursor;
+  if (header == NULL)
+    {
+      buf = xcalloc (1, 1);
+      *buf = '\0';
+      return buf;
     }
-    buf = xcalloc((strlen(header) * 3) + 1, 1);
-    buf_cursor = buf;
-    /*
-     * We escape: space \x00-\x1F and space (0x40) and \x7F-\xFF
-     * to prevent garbage in the logs. CR and LF are also there just in case. 
-     */
-    while ((c = *(const unsigned char *) header++) != '\0') {
-	if (c == '\r') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'r';
-	} else if (c == '\n') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'n';
-	} else if (c <= 0x1F
-		|| c >= 0x7F
-	    || c == ' ') {
-	    *buf_cursor++ = '%';
-	    i = c * 2;
-	    *buf_cursor++ = c2x[i];
-	    *buf_cursor++ = c2x[i + 1];
-	} else {
-	    *buf_cursor++ = (char) c;
+  buf = xcalloc (1, (strlen (header) * 3) + 1);
+  buf_cursor = buf;
+  /*
+   * We escape: space \x00-\x1F and space (0x40) and \x7F-\xFF
+   * to prevent garbage in the logs. CR and LF are also there just in case. 
+   */
+  while ((c = *(const unsigned char *) header++) != '\0')
+    {
+      if (c == '\r')
+	{
+	  *buf_cursor++ = '\\';
+	  *buf_cursor++ = 'r';
+	}
+      else if (c == '\n')
+	{
+	  *buf_cursor++ = '\\';
+	  *buf_cursor++ = 'n';
+	}
+      else if (c <= 0x1F
+	       || c >= 0x7F
+	       || c == ' ')
+	{
+	  *buf_cursor++ = '%';
+	  i = c * 2;
+	  *buf_cursor++ = c2x[i];
+	  *buf_cursor++ = c2x[i + 1];
+	}
+      else
+	{
+	  *buf_cursor++ = (char) c;
 	}
     }
-    *buf_cursor = '\0';
-    return buf;
+  *buf_cursor = '\0';
+  return buf;
 }
 
 static char *
-accessLogFormatName(const char *name)
+accessLogFormatName (const char *name)
 {
-    if (NULL == name)
-	return NULL;
-    return username_quote(name);
+  if (NULL == name)
+    return NULL;
+  return username_quote (name);
 }
 
 static void
-accessLogSquid(AccessLogEntry * al)
+accessLogSquid (AccessLogEntry * al)
 {
-    const char *client = NULL;
-    char *user = NULL;
-    if (Config.onoff.log_fqdn)
-	client = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
-    if (client == NULL)
-	client = inet_ntoa(al->cache.caddr);
-    user = accessLogFormatName(al->cache.authuser ?
-	al->cache.authuser : al->cache.rfc931);
-    logfilePrintf(logfile, "%9d.%03d %6d %s %s/%03d %d %s %s %s %s%s/%s %s",
-	(int) current_time.tv_sec,
-	(int) current_time.tv_usec / 1000,
-	al->cache.msec,
-	client,
-	log_tags[al->cache.code],
-	al->http.code,
-	al->cache.size,
-	al->private.method_str,
-	al->url,
-	user ? user : dash_str,
-	al->hier.ping.timedout ? "TIMEOUT_" : "",
-	hier_strings[al->hier.code],
-	al->hier.host,
-	al->http.content_type);
-    safe_free(user);
+  const char *client = NULL;
+  char *user = NULL;
+  if (Config.onoff.log_fqdn)
+    client = fqdncache_gethostbyaddr (al->cache.caddr, FQDN_LOOKUP_IF_MISS);
+  if (client == NULL)
+    client = inet_ntoa (al->cache.caddr);
+  user = accessLogFormatName (al->cache.authuser ?
+			      al->cache.authuser : al->cache.rfc931);
+  logfilePrintf (logfile, "%9d.%03d %6d %s %s/%03d %d %s %s %s %s%s/%s %s",
+		 (int) current_time.tv_sec,
+		 (int) current_time.tv_usec / 1000,
+		 al->cache.msec,
+		 client,
+		 log_tags[al->cache.code],
+		 al->http.code,
+		 al->cache.size,
+		 al->private.method_str,
+		 al->url,
+		 user ? user : dash_str,
+		 al->hier.ping.timedout ? "TIMEOUT_" : "",
+		 hier_strings[al->hier.code],
+		 al->hier.host,
+		 al->http.content_type);
+  safe_free (user);
 }
 
 static void
-accessLogCommon(AccessLogEntry * al)
+accessLogCommon (AccessLogEntry * al)
 {
-    const char *client = NULL;
-    char *user1 = NULL, *user2 = NULL;
-    if (Config.onoff.log_fqdn)
-	client = fqdncache_gethostbyaddr(al->cache.caddr, 0);
-    if (client == NULL)
-	client = inet_ntoa(al->cache.caddr);
-    user1 = accessLogFormatName(al->cache.authuser);
-    user2 = accessLogFormatName(al->cache.rfc931);
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s HTTP/%d.%d\" %d %d %s:%s",
-	client,
-	user2 ? user2 : dash_str,
-	user1 ? user1 : dash_str,
-	mkhttpdlogtime(&squid_curtime),
-	al->private.method_str,
-	al->url,
-	al->http.version.major, al->http.version.minor,
-	al->http.code,
-	al->cache.size,
-	log_tags[al->cache.code],
-	hier_strings[al->hier.code]);
-    safe_free(user1);
-    safe_free(user2);
+  const char *client = NULL;
+  char *user1 = NULL, *user2 = NULL;
+  if (Config.onoff.log_fqdn)
+    client = fqdncache_gethostbyaddr (al->cache.caddr, 0);
+  if (client == NULL)
+    client = inet_ntoa (al->cache.caddr);
+  user1 = accessLogFormatName (al->cache.authuser);
+  user2 = accessLogFormatName (al->cache.rfc931);
+  logfilePrintf (logfile, "%s %s %s [%s] \"%s %s HTTP/%d.%d\" %d %d %s:%s",
+		 client,
+		 user2 ? user2 : dash_str,
+		 user1 ? user1 : dash_str,
+		 mkhttpdlogtime (&squid_curtime),
+		 al->private.method_str,
+		 al->url,
+		 al->http.version.major, al->http.version.minor,
+		 al->http.code,
+		 al->cache.size,
+		 log_tags[al->cache.code],
+		 hier_strings[al->hier.code]);
+  safe_free (user1);
+  safe_free (user2);
 }
 
 void
-accessLogLog(AccessLogEntry * al)
+accessLogLog (AccessLogEntry * al)
 {
-    if (LogfileStatus != LOG_ENABLE)
-	return;
-    if (al->url == NULL)
-	al->url = dash_str;
-    if (!al->http.content_type || *al->http.content_type == '\0')
-	al->http.content_type = dash_str;
-    if (al->icp.opcode)
-	al->private.method_str = icp_opcode_str[al->icp.opcode];
-    else
-	al->private.method_str = RequestMethodStr[al->http.method];
-    if (al->hier.host[0] == '\0')
-	xstrncpy(al->hier.host, dash_str, SQUIDHOSTNAMELEN);
-
-    if (Config.onoff.common_log)
-	accessLogCommon(al);
-    else
-	accessLogSquid(al);
-    if (Config.onoff.log_mime_hdrs) {
-	char *ereq = log_quote(al->headers.request);
-	char *erep = log_quote(al->headers.reply);
-	logfilePrintf(logfile, " [%s] [%s]\n", ereq, erep);
-	safe_free(ereq);
-	safe_free(erep);
-    } else {
-	logfilePrintf(logfile, "\n");
+  if (LogfileStatus != LOG_ENABLE)
+    return;
+  if (al->url == NULL)
+    al->url = dash_str;
+  if (!al->http.content_type || *al->http.content_type == '\0')
+    al->http.content_type = dash_str;
+  if (al->icp.opcode)
+    al->private.method_str = icp_opcode_str[al->icp.opcode];
+  else
+    al->private.method_str = RequestMethodStr[al->http.method];
+  if (al->hier.host[0] == '\0')
+    xstrncpy (al->hier.host, dash_str, SQUIDHOSTNAMELEN);
+
+  if (Config.onoff.common_log)
+    accessLogCommon (al);
+  else
+    accessLogSquid (al);
+  if (Config.onoff.log_mime_hdrs)
+    {
+      char *ereq = log_quote (al->headers.request);
+      char *erep = log_quote (al->headers.reply);
+      logfilePrintf (logfile, " [%s] [%s]\n", ereq, erep);
+      safe_free (ereq);
+      safe_free (erep);
+    }
+  else
+    {
+      logfilePrintf (logfile, "\n");
     }
-    logfileFlush(logfile);
+  logfileFlush (logfile);
 #if MULTICAST_MISS_STREAM
-    if (al->cache.code != LOG_TCP_MISS)
-	(void) 0;
-    else if (al->http.method != METHOD_GET)
-	(void) 0;
-    else if (mcast_miss_fd < 0)
-	(void) 0;
-    else {
-	unsigned int ibuf[365];
-	size_t isize;
-	xstrncpy((char *) ibuf, al->url, 364 * sizeof(int));
-	isize = ((strlen(al->url) + 8) / 8) * 2;
-	if (isize > 364)
-	    isize = 364;
-	mcast_encode((unsigned int *) ibuf, isize,
-	    (const unsigned int *) Config.mcast_miss.encode_key);
-	comm_udp_sendto(mcast_miss_fd,
-	    &mcast_miss_to, sizeof(mcast_miss_to),
-	    ibuf, isize * sizeof(int));
+  if (al->cache.code != LOG_TCP_MISS)
+    (void) 0;
+  else if (al->http.method != METHOD_GET)
+    (void) 0;
+  else if (mcast_miss_fd < 0)
+    (void) 0;
+  else
+    {
+      unsigned int ibuf[365];
+      size_t isize;
+      xstrncpy ((char *) ibuf, al->url, 364 * sizeof (int));
+      isize = ((strlen (al->url) + 8) / 8) * 2;
+      if (isize > 364)
+	isize = 364;
+      mcast_encode ((unsigned int *) ibuf, isize,
+		    (const unsigned int *) Config.mcast_miss.encode_key);
+      comm_udp_sendto (mcast_miss_fd,
+		       &mcast_miss_to, sizeof (mcast_miss_to),
+		       ibuf, isize * sizeof (int));
     }
 #endif
 }
 
 void
-accessLogRotate(void)
+accessLogRotate (void)
 {
 #if FORW_VIA_DB
-    fvdbClear();
+  fvdbClear ();
 #endif
-    if (NULL == logfile)
-	return;
-    logfileRotate(logfile);
+  if (NULL == logfile)
+    return;
+  logfileRotate (logfile);
 #if HEADERS_LOG
-    logfileRotate(headerslog);
+  logfileRotate (headerslog);
 #endif
 }
 
 void
-accessLogClose(void)
+accessLogClose (void)
 {
-    logfileClose(logfile);
-    logfile = NULL;
+  logfileClose (logfile);
+  logfile = NULL;
 #if HEADERS_LOG
-    logfileClose(headerslog);
-    headerslog = NULL;
+  logfileClose (headerslog);
+  headerslog = NULL;
 #endif
 }
 
 void
-hierarchyNote(HierarchyLogEntry * hl,
-    hier_code code,
-    const char *cache_peer)
+hierarchyNote (HierarchyLogEntry * hl,
+	       hier_code code,
+	       const char *cache_peer)
 {
-    assert(hl != NULL);
-    hl->code = code;
-    xstrncpy(hl->host, cache_peer, SQUIDHOSTNAMELEN);
+  assert (hl != NULL);
+  hl->code = code;
+  xstrncpy (hl->host, cache_peer, SQUIDHOSTNAMELEN);
 }
 
 void
-accessLogInit(void)
+accessLogInit (void)
 {
-    assert(sizeof(log_tags) == (LOG_TYPE_MAX + 1) * sizeof(char *));
-    if (strcasecmp(Config.Log.access, "none") == 0)
-	return;
-    logfile = logfileOpen(Config.Log.access, MAX_URL << 1, 1);
-    LogfileStatus = LOG_ENABLE;
+  assert (sizeof (log_tags) == (LOG_TYPE_MAX + 1) * sizeof (char *));
+  if (strcasecmp (Config.Log.access, "none") == 0)
+    return;
+  logfile = logfileOpen (Config.Log.access, MAX_URL << 1, 1);
+  LogfileStatus = LOG_ENABLE;
 #if HEADERS_LOG
-    headerslog = logfileOpen("/usr/local/squid/logs/headers.log", 512);
-    assert(NULL != headerslog);
+  headerslog = logfileOpen ("/usr/local/squid/logs/headers.log", 512);
+  assert (NULL != headerslog);
 #endif
 #if FORW_VIA_DB
-    fvdbInit();
+  fvdbInit ();
 #endif
 #if MULTICAST_MISS_STREAM
-    if (Config.mcast_miss.addr.s_addr != no_addr.s_addr) {
-	memset(&mcast_miss_to, '\0', sizeof(mcast_miss_to));
-	mcast_miss_to.sin_family = AF_INET;
-	mcast_miss_to.sin_port = htons(Config.mcast_miss.port);
-	mcast_miss_to.sin_addr.s_addr = Config.mcast_miss.addr.s_addr;
-	mcast_miss_fd = comm_open(SOCK_DGRAM,
-	    0,
-	    Config.Addrs.udp_incoming,
-	    Config.mcast_miss.port,
-	    COMM_NONBLOCKING,
-	    "Multicast Miss Stream");
-	if (mcast_miss_fd < 0)
-	    fatal("Cannot open Multicast Miss Stream Socket");
-	debug(46, 1) ("Multicast Miss Stream Socket opened on FD %d\n",
-	    mcast_miss_fd);
-	mcastSetTtl(mcast_miss_fd, Config.mcast_miss.ttl);
-	if (strlen(Config.mcast_miss.encode_key) < 16)
-	    fatal("mcast_encode_key is too short, must be 16 characters");
+  if (Config.mcast_miss.addr.s_addr != no_addr.s_addr)
+    {
+      memset (&mcast_miss_to, '\0', sizeof (mcast_miss_to));
+      mcast_miss_to.sin_family = AF_INET;
+      mcast_miss_to.sin_port = htons (Config.mcast_miss.port);
+      mcast_miss_to.sin_addr.s_addr = Config.mcast_miss.addr.s_addr;
+      mcast_miss_fd = comm_open (SOCK_DGRAM,
+				 0,
+				 Config.Addrs.udp_incoming,
+				 Config.mcast_miss.port,
+				 COMM_NONBLOCKING,
+				 "Multicast Miss Stream");
+      if (mcast_miss_fd < 0)
+	fatal ("Cannot open Multicast Miss Stream Socket");
+      debug (46, 1) ("Multicast Miss Stream Socket opened on FD %d\n",
+		     mcast_miss_fd);
+      mcastSetTtl (mcast_miss_fd, Config.mcast_miss.ttl);
+      if (strlen (Config.mcast_miss.encode_key) < 16)
+	fatal ("mcast_encode_key is too short, must be 16 characters");
     }
 #endif
 }
 
 const char *
-accessLogTime(time_t t)
+accessLogTime (time_t t)
 {
-    struct tm *tm;
-    static char buf[128];
-    static time_t last_t = 0;
-    if (t != last_t) {
-	tm = localtime(&t);
-	strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
-	last_t = t;
+  struct tm *tm;
+  static char buf[128];
+  static time_t last_t = 0;
+  if (t != last_t)
+    {
+      tm = localtime (&t);
+      strftime (buf, 127, "%Y/%m/%d %H:%M:%S", tm);
+      last_t = t;
     }
-    return buf;
+  return buf;
 }
 
 
 #if FORW_VIA_DB
 
 static void
-fvdbInit(void)
+fvdbInit (void)
 {
-    via_table = hash_create((HASHCMP *) strcmp, 977, hash4);
-    forw_table = hash_create((HASHCMP *) strcmp, 977, hash4);
-    cachemgrRegister("via_headers", "Via Request Headers", fvdbDumpVia, 0, 1);
-    cachemgrRegister("forw_headers", "X-Forwarded-For Request Headers",
-	fvdbDumpForw, 0, 1);
+  via_table = hash_create ((HASHCMP *) strcmp, 977, hash4);
+  forw_table = hash_create ((HASHCMP *) strcmp, 977, hash4);
+  cachemgrRegister ("via_headers", "Via Request Headers", fvdbDumpVia, 0, 1);
+  cachemgrRegister ("forw_headers", "X-Forwarded-For Request Headers",
+		    fvdbDumpForw, 0, 1);
 }
 
 static void
-fvdbCount(hash_table * hash, const char *key)
+fvdbCount (hash_table * hash, const char *key)
 {
-    fvdb_entry *fv;
-    if (NULL == hash)
-	return;
-    fv = hash_lookup(hash, key);
-    if (NULL == fv) {
-	fv = xcalloc(1, sizeof(fvdb_entry));
-	fv->hash.key = xstrdup(key);
-	hash_join(hash, &fv->hash);
+  fvdb_entry *fv;
+  if (NULL == hash)
+    return;
+  fv = hash_lookup (hash, key);
+  if (NULL == fv)
+    {
+      fv = xcalloc (1, sizeof (fvdb_entry));
+      fv->hash.key = xstrdup (key);
+      hash_join (hash, &fv->hash);
     }
-    fv->n++;
+  fv->n++;
 }
 
 void
-fvdbCountVia(const char *key)
+fvdbCountVia (const char *key)
 {
-    fvdbCount(via_table, key);
+  fvdbCount (via_table, key);
 }
 
 void
-fvdbCountForw(const char *key)
+fvdbCountForw (const char *key)
 {
-    fvdbCount(forw_table, key);
+  fvdbCount (forw_table, key);
 }
 
 static void
-fvdbDumpTable(StoreEntry * e, hash_table * hash)
+fvdbDumpTable (StoreEntry * e, hash_table * hash)
 {
-    hash_link *h;
-    fvdb_entry *fv;
-    if (hash == NULL)
-	return;
-    hash_first(hash);
-    while ((h = hash_next(hash))) {
-	fv = (fvdb_entry *) h;
-	storeAppendPrintf(e, "%9d %s\n", fv->n, hashKeyStr(&fv->hash));
+  hash_link *h;
+  fvdb_entry *fv;
+  if (hash == NULL)
+    return;
+  hash_first (hash);
+  while ((h = hash_next (hash)))
+    {
+      fv = (fvdb_entry *) h;
+      storeAppendPrintf (e, "%9d %s\n", fv->n, hashKeyStr (&fv->hash));
     }
 }
 
 static void
-fvdbDumpVia(StoreEntry * e)
+fvdbDumpVia (StoreEntry * e)
 {
-    fvdbDumpTable(e, via_table);
+  fvdbDumpTable (e, via_table);
 }
 
 static void
-fvdbDumpForw(StoreEntry * e)
+fvdbDumpForw (StoreEntry * e)
 {
-    fvdbDumpTable(e, forw_table);
+  fvdbDumpTable (e, forw_table);
 }
 
 static
 void
-fvdbFreeEntry(void *data)
+fvdbFreeEntry (void *data)
 {
-    fvdb_entry *fv = data;
-    xfree(fv->hash.key);
-    xfree(fv);
+  fvdb_entry *fv = data;
+  xfree (fv->hash.key);
+  xfree (fv);
 }
 
 static void
-fvdbClear(void)
+fvdbClear (void)
 {
-    hashFreeItems(via_table, fvdbFreeEntry);
-    hashFreeMemory(via_table);
-    via_table = hash_create((HASHCMP *) strcmp, 977, hash4);
-    hashFreeItems(forw_table, fvdbFreeEntry);
-    hashFreeMemory(forw_table);
-    forw_table = hash_create((HASHCMP *) strcmp, 977, hash4);
+  hashFreeItems (via_table, fvdbFreeEntry);
+  hashFreeMemory (via_table);
+  via_table = hash_create ((HASHCMP *) strcmp, 977, hash4);
+  hashFreeItems (forw_table, fvdbFreeEntry);
+  hashFreeMemory (forw_table);
+  forw_table = hash_create ((HASHCMP *) strcmp, 977, hash4);
 }
 
 #endif
@@ -525,81 +555,89 @@ fvdbClear(void)
  * network byte order.
  */
 static void
-mcast_encode(unsigned int *ibuf, size_t isize, const unsigned int *key)
+mcast_encode (unsigned int *ibuf, size_t isize, const unsigned int *key)
 {
-    unsigned int y;
-    unsigned int z;
-    unsigned int sum;
-    const unsigned int delta = 0x9e3779b9;
-    unsigned int n = 32;
-    const unsigned int k0 = htonl(key[0]);
-    const unsigned int k1 = htonl(key[1]);
-    const unsigned int k2 = htonl(key[2]);
-    const unsigned int k3 = htonl(key[3]);
-    int i;
-    for (i = 0; i < isize; i += 2) {
-	y = htonl(ibuf[i]);
-	z = htonl(ibuf[i + 1]);
-	sum = 0;
-	for (n = 32; n; n--) {
-	    sum += delta;
-	    y += (z << 4) + (k0 ^ z) + (sum ^ (z >> 5)) + k1;
-	    z += (y << 4) + (k2 ^ y) + (sum ^ (y >> 5)) + k3;
+  unsigned int y;
+  unsigned int z;
+  unsigned int sum;
+  const unsigned int delta = 0x9e3779b9;
+  unsigned int n = 32;
+  const unsigned int k0 = htonl (key[0]);
+  const unsigned int k1 = htonl (key[1]);
+  const unsigned int k2 = htonl (key[2]);
+  const unsigned int k3 = htonl (key[3]);
+  int i;
+  for (i = 0; i < isize; i += 2)
+    {
+      y = htonl (ibuf[i]);
+      z = htonl (ibuf[i + 1]);
+      sum = 0;
+      for (n = 32; n; n--)
+	{
+	  sum += delta;
+	  y += (z << 4) + (k0 ^ z) + (sum ^ (z >> 5)) + k1;
+	  z += (y << 4) + (k2 ^ y) + (sum ^ (y >> 5)) + k3;
 	}
-	ibuf[i] = htonl(y);
-	ibuf[i + 1] = htonl(z);
+      ibuf[i] = htonl (y);
+      ibuf[i + 1] = htonl (z);
     }
 }
 
 #endif
 
 #if HEADERS_LOG
 void
-headersLog(int cs, int pq, method_t m, void *data)
+headersLog (int cs, int pq, method_t m, void *data)
 {
-    HttpReply *rep;
-    request_t *req;
-    unsigned short magic = 0;
-    unsigned char M = (unsigned char) m;
-    unsigned short S;
-    char *hmask;
-    int ccmask = 0;
-    if (0 == pq) {
-	/* reply */
-	rep = data;
-	req = NULL;
-	magic = 0x0050;
-	hmask = rep->header.mask;
-	if (rep->cache_control)
-	    ccmask = rep->cache_control->mask;
-    } else {
-	/* request */
-	req = data;
-	rep = NULL;
-	magic = 0x0051;
-	hmask = req->header.mask;
-	if (req->cache_control)
-	    ccmask = req->cache_control->mask;
+  HttpReply *rep;
+  request_t *req;
+  unsigned short magic = 0;
+  unsigned char M = (unsigned char) m;
+  unsigned short S;
+  char *hmask;
+  int ccmask = 0;
+  if (0 == pq)
+    {
+      /* reply */
+      rep = data;
+      req = NULL;
+      magic = 0x0050;
+      hmask = rep->header.mask;
+      if (rep->cache_control)
+	ccmask = rep->cache_control->mask;
+    }
+  else
+    {
+      /* request */
+      req = data;
+      rep = NULL;
+      magic = 0x0051;
+      hmask = req->header.mask;
+      if (req->cache_control)
+	ccmask = req->cache_control->mask;
+    }
+  if (0 == cs)
+    {
+      /* client */
+      magic |= 0x4300;
     }
-    if (0 == cs) {
-	/* client */
-	magic |= 0x4300;
-    } else {
-	/* server */
-	magic |= 0x5300;
+  else
+    {
+      /* server */
+      magic |= 0x5300;
     }
-    magic = htons(magic);
-    ccmask = htonl(ccmask);
-    if (0 == pq)
-	S = (unsigned short) rep->sline.status;
-    else
-	S = (unsigned short) HTTP_STATUS_NONE;
-    logfileWrite(headerslog, &magic, sizeof(magic));
-    logfileWrite(headerslog, &M, sizeof(M));
-    logfileWrite(headerslog, &S, sizeof(S));
-    logfileWrite(headerslog, hmask, sizeof(HttpHeaderMask));
-    logfileWrite(headerslog, &ccmask, sizeof(int));
-    logfileFlush(headerslog);
+  magic = htons (magic);
+  ccmask = htonl (ccmask);
+  if (0 == pq)
+    S = (unsigned short) rep->sline.status;
+  else
+    S = (unsigned short) HTTP_STATUS_NONE;
+  logfileWrite (headerslog, &magic, sizeof (magic));
+  logfileWrite (headerslog, &M, sizeof (M));
+  logfileWrite (headerslog, &S, sizeof (S));
+  logfileWrite (headerslog, hmask, sizeof (HttpHeaderMask));
+  logfileWrite (headerslog, &ccmask, sizeof (int));
+  logfileFlush (headerslog);
 }
 
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: asn.cc,v 1.71 2001/03/03 10:39:30 hno Exp $
+ * $Id: asn.cc,v 1.72 2001/10/17 10:59:08 adrian Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -40,7 +40,7 @@
 /* BEGIN of definitions for radix tree entries */
 
 /* int in memory with length */
-typedef u_char m_int[1 + sizeof(unsigned int)];
+typedef u_char m_int[1 + sizeof (unsigned int)];
 #define store_m_int(i, m) \
     (i = htonl(i), m[0] = sizeof(m_int), xmemcpy(m+1, &i, sizeof(unsigned int)))
 #define get_m_int(i, m) \
@@ -56,389 +56,423 @@ struct radix_node_head *AS_tree_head;
  * an intlist but it's coded as a structure for future
  * enhancements (e.g. expires)
  */
-struct _as_info {
+struct _as_info
+  {
     intlist *as_number;
     time_t expires;		/* NOTUSED */
-};
+  };
 
-struct _ASState {
+struct _ASState
+  {
     StoreEntry *entry;
     store_client *sc;
     request_t *request;
     int as_number;
     off_t seen;
     off_t offset;
-};
+  };
 
 typedef struct _ASState ASState;
 typedef struct _as_info as_info;
 
 /* entry into the radix tree */
-struct _rtentry {
+struct _rtentry
+  {
     struct radix_node e_nodes[2];
     as_info *e_info;
     m_int e_addr;
     m_int e_mask;
-};
+  };
 
 typedef struct _rtentry rtentry;
 
-static int asnAddNet(char *, int);
-static void asnCacheStart(int as);
+static int asnAddNet (char *, int);
+static void asnCacheStart (int as);
 static STCB asHandleReply;
-static int destroyRadixNode(struct radix_node *rn, void *w);
-static int printRadixNode(struct radix_node *rn, void *w);
-static void asnAclInitialize(acl * acls);
-static void asStateFree(void *data);
-static void destroyRadixNodeInfo(as_info *);
+static int destroyRadixNode (struct radix_node *rn, void *w);
+static int printRadixNode (struct radix_node *rn, void *w);
+static void asnAclInitialize (acl * acls);
+static void asStateFree (void *data);
+static void destroyRadixNodeInfo (as_info *);
 static OBJH asnStats;
 
 /* PUBLIC */
 
 int
-asnMatchIp(void *data, struct in_addr addr)
+asnMatchIp (void *data, struct in_addr addr)
 {
-    unsigned long lh;
-    struct radix_node *rn;
-    as_info *e;
-    m_int m_addr;
-    intlist *a = NULL;
-    intlist *b = NULL;
-    lh = ntohl(addr.s_addr);
-    debug(53, 3) ("asnMatchIp: Called for %s.\n", inet_ntoa(addr));
-
-    if (AS_tree_head == NULL)
-	return 0;
-    if (addr.s_addr == no_addr.s_addr)
-	return 0;
-    if (addr.s_addr == any_addr.s_addr)
-	return 0;
-    store_m_int(lh, m_addr);
-    rn = rn_match(m_addr, AS_tree_head);
-    if (rn == NULL) {
-	debug(53, 3) ("asnMatchIp: Address not in as db.\n");
-	return 0;
-    }
-    debug(53, 3) ("asnMatchIp: Found in db!\n");
-    e = ((rtentry *) rn)->e_info;
-    assert(e);
-    for (a = (intlist *) data; a; a = a->next)
-	for (b = e->as_number; b; b = b->next)
-	    if (a->i == b->i) {
-		debug(53, 5) ("asnMatchIp: Found a match!\n");
-		return 1;
-	    }
-    debug(53, 5) ("asnMatchIp: AS not in as db.\n");
+  unsigned long lh;
+  struct radix_node *rn;
+  as_info *e;
+  m_int m_addr;
+  intlist *a = NULL;
+  intlist *b = NULL;
+  lh = ntohl (addr.s_addr);
+  debug (53, 3) ("asnMatchIp: Called for %s.\n", inet_ntoa (addr));
+
+  if (AS_tree_head == NULL)
+    return 0;
+  if (addr.s_addr == no_addr.s_addr)
     return 0;
+  if (addr.s_addr == any_addr.s_addr)
+    return 0;
+  store_m_int (lh, m_addr);
+  rn = rn_match (m_addr, AS_tree_head);
+  if (rn == NULL)
+    {
+      debug (53, 3) ("asnMatchIp: Address not in as db.\n");
+      return 0;
+    }
+  debug (53, 3) ("asnMatchIp: Found in db!\n");
+  e = ((rtentry *) rn)->e_info;
+  assert (e);
+  for (a = (intlist *) data; a; a = a->next)
+    for (b = e->as_number; b; b = b->next)
+      if (a->i == b->i)
+	{
+	  debug (53, 5) ("asnMatchIp: Found a match!\n");
+	  return 1;
+	}
+  debug (53, 5) ("asnMatchIp: AS not in as db.\n");
+  return 0;
 }
 
 static void
-asnAclInitialize(acl * acls)
+asnAclInitialize (acl * acls)
 {
-    acl *a;
-    intlist *i;
-    debug(53, 3) ("asnAclInitialize\n");
-    for (a = acls; a; a = a->next) {
-	if (a->type != ACL_DST_ASN && a->type != ACL_SRC_ASN)
-	    continue;
-	for (i = a->data; i; i = i->next)
-	    asnCacheStart(i->i);
+  acl *a;
+  intlist *i;
+  debug (53, 3) ("asnAclInitialize\n");
+  for (a = acls; a; a = a->next)
+    {
+      if (a->type != ACL_DST_ASN && a->type != ACL_SRC_ASN)
+	continue;
+      for (i = a->data; i; i = i->next)
+	asnCacheStart (i->i);
     }
 }
 
 /* initialize the radix tree structure */
 
-CBDATA_TYPE(ASState);
+CBDATA_TYPE (ASState);
 void
-asnInit(void)
+asnInit (void)
 {
-    extern int max_keylen;
-    static int inited = 0;
-    max_keylen = 40;
-    CBDATA_INIT_TYPE(ASState);
-    if (0 == inited++)
-	rn_init();
-    rn_inithead((void **) &AS_tree_head, 8);
-    asnAclInitialize(Config.aclList);
-    cachemgrRegister("asndb", "AS Number Database", asnStats, 0, 1);
+  extern int max_keylen;
+  static int inited = 0;
+  max_keylen = 40;
+  CBDATA_INIT_TYPE (ASState);
+  if (0 == inited++)
+    rn_init ();
+  rn_inithead ((void **) &AS_tree_head, 8);
+  asnAclInitialize (Config.aclList);
+  cachemgrRegister ("asndb", "AS Number Database", asnStats, 0, 1);
 }
 
 void
-asnFreeMemory(void)
+asnFreeMemory (void)
 {
-    rn_walktree(AS_tree_head, destroyRadixNode, AS_tree_head);
-    destroyRadixNode((struct radix_node *) 0, (void *) AS_tree_head);
+  rn_walktree (AS_tree_head, destroyRadixNode, AS_tree_head);
+  destroyRadixNode ((struct radix_node *) 0, (void *) AS_tree_head);
 }
 
 static void
-asnStats(StoreEntry * sentry)
+asnStats (StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Address    \tAS Numbers\n");
-    rn_walktree(AS_tree_head, printRadixNode, sentry);
+  storeAppendPrintf (sentry, "Address    \tAS Numbers\n");
+  rn_walktree (AS_tree_head, printRadixNode, sentry);
 }
 
 /* PRIVATE */
 
 
 static void
-asnCacheStart(int as)
+asnCacheStart (int as)
 {
-    LOCAL_ARRAY(char, asres, 4096);
-    StoreEntry *e;
-    request_t *req;
-    ASState *asState;
-    asState = cbdataAlloc(ASState);
-    debug(53, 3) ("asnCacheStart: AS %d\n", as);
-    snprintf(asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
-    asState->as_number = as;
-    req = urlParse(METHOD_GET, asres);
-    assert(NULL != req);
-    asState->request = requestLink(req);
-    if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
-	e = storeCreateEntry(asres, asres, null_request_flags, METHOD_GET);
-	asState->sc = storeClientListAdd(e, asState);
-	fwdStart(-1, e, asState->request);
-    } else {
-	storeLockObject(e);
-	asState->sc = storeClientListAdd(e, asState);
+  LOCAL_ARRAY (char, asres, 4096);
+  StoreEntry *e;
+  request_t *req;
+  ASState *asState;
+  asState = cbdataAlloc (ASState);
+  debug (53, 3) ("asnCacheStart: AS %d\n", as);
+  snprintf (asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
+  asState->as_number = as;
+  req = urlParse (METHOD_GET, asres);
+  assert (NULL != req);
+  asState->request = requestLink (req);
+  if ((e = storeGetPublic (asres, METHOD_GET)) == NULL)
+    {
+      e = storeCreateEntry (asres, asres, null_request_flags, METHOD_GET);
+      asState->sc = storeClientListAdd (e, asState);
+      fwdStart (-1, e, asState->request);
+    }
+  else
+    {
+      storeLockObject (e);
+      asState->sc = storeClientListAdd (e, asState);
     }
-    asState->entry = e;
-    asState->seen = 0;
-    asState->offset = 0;
-    storeClientCopy(asState->sc,
-	e,
-	asState->seen,
-	asState->offset,
-	4096,
-	memAllocate(MEM_4K_BUF),
-	asHandleReply,
-	asState);
+  asState->entry = e;
+  asState->seen = 0;
+  asState->offset = 0;
+  storeClientCopy (asState->sc,
+		   e,
+		   asState->seen,
+		   asState->offset,
+		   4096,
+		   memAllocate (MEM_4K_BUF),
+		   asHandleReply,
+		   asState);
 }
 
 static void
-asHandleReply(void *data, char *buf, ssize_t size)
+asHandleReply (void *data, char *buf, ssize_t size)
 {
-    ASState *asState = data;
-    StoreEntry *e = asState->entry;
-    char *s;
-    char *t;
-    debug(53, 3) ("asHandleReply: Called with size=%d\n", size);
-    if (EBIT_TEST(e->flags, ENTRY_ABORTED)) {
-	memFree(buf, MEM_4K_BUF);
-	asStateFree(asState);
-	return;
+  ASState *asState = data;
+  StoreEntry *e = asState->entry;
+  char *s;
+  char *t;
+  debug (53, 3) ("asHandleReply: Called with size=%d\n", size);
+  if (EBIT_TEST (e->flags, ENTRY_ABORTED))
+    {
+      memFree (buf, MEM_4K_BUF);
+      asStateFree (asState);
+      return;
     }
-    if (size == 0 && e->mem_obj->inmem_hi > 0) {
-	memFree(buf, MEM_4K_BUF);
-	asStateFree(asState);
-	return;
-    } else if (size < 0) {
-	debug(53, 1) ("asHandleReply: Called with size=%d\n", size);
-	memFree(buf, MEM_4K_BUF);
-	asStateFree(asState);
-	return;
-    } else if (HTTP_OK != e->mem_obj->reply->sline.status) {
-	debug(53, 1) ("WARNING: AS %d whois request failed\n",
-	    asState->as_number);
-	memFree(buf, MEM_4K_BUF);
-	asStateFree(asState);
-	return;
+  if (size == 0 && e->mem_obj->inmem_hi > 0)
+    {
+      memFree (buf, MEM_4K_BUF);
+      asStateFree (asState);
+      return;
     }
-    s = buf;
-    while (s - buf < size && *s != '\0') {
-	while (*s && xisspace(*s))
-	    s++;
-	for (t = s; *t; t++) {
-	    if (xisspace(*t))
-		break;
-	}
-	if (*t == '\0') {
-	    /* oof, word should continue on next block */
+  else if (size < 0)
+    {
+      debug (53, 1) ("asHandleReply: Called with size=%d\n", size);
+      memFree (buf, MEM_4K_BUF);
+      asStateFree (asState);
+      return;
+    }
+  else if (HTTP_OK != e->mem_obj->reply->sline.status)
+    {
+      debug (53, 1) ("WARNING: AS %d whois request failed\n",
+		     asState->as_number);
+      memFree (buf, MEM_4K_BUF);
+      asStateFree (asState);
+      return;
+    }
+  s = buf;
+  while (s - buf < size && *s != '\0')
+    {
+      while (*s && xisspace (*s))
+	s++;
+      for (t = s; *t; t++)
+	{
+	  if (xisspace (*t))
 	    break;
 	}
-	*t = '\0';
-	debug(53, 3) ("asHandleReply: AS# %s (%d)\n", s, asState->as_number);
-	asnAddNet(s, asState->as_number);
-	s = t + 1;
+      if (*t == '\0')
+	{
+	  /* oof, word should continue on next block */
+	  break;
+	}
+      *t = '\0';
+      debug (53, 3) ("asHandleReply: AS# %s (%d)\n", s, asState->as_number);
+      asnAddNet (s, asState->as_number);
+      s = t + 1;
+    }
+  asState->seen = asState->offset + size;
+  asState->offset += (s - buf);
+  debug (53, 3) ("asState->seen = %d, asState->offset = %d\n",
+		 asState->seen, asState->offset);
+  if (e->store_status == STORE_PENDING)
+    {
+      debug (53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", storeUrl (e));
+      storeClientCopy (asState->sc,
+		       e,
+		       asState->seen,
+		       asState->offset,
+		       4096,
+		       buf,
+		       asHandleReply,
+		       asState);
+    }
+  else if (asState->seen < e->mem_obj->inmem_hi)
+    {
+      debug (53, 3) ("asHandleReply: asState->seen < e->mem_obj->inmem_hi %s\n", storeUrl (e));
+      storeClientCopy (asState->sc,
+		       e,
+		       asState->seen,
+		       asState->offset,
+		       4096,
+		       buf,
+		       asHandleReply,
+		       asState);
     }
-    asState->seen = asState->offset + size;
-    asState->offset += (s - buf);
-    debug(53, 3) ("asState->seen = %d, asState->offset = %d\n",
-	asState->seen, asState->offset);
-    if (e->store_status == STORE_PENDING) {
-	debug(53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", storeUrl(e));
-	storeClientCopy(asState->sc,
-	    e,
-	    asState->seen,
-	    asState->offset,
-	    4096,
-	    buf,
-	    asHandleReply,
-	    asState);
-    } else if (asState->seen < e->mem_obj->inmem_hi) {
-	debug(53, 3) ("asHandleReply: asState->seen < e->mem_obj->inmem_hi %s\n", storeUrl(e));
-	storeClientCopy(asState->sc,
-	    e,
-	    asState->seen,
-	    asState->offset,
-	    4096,
-	    buf,
-	    asHandleReply,
-	    asState);
-    } else {
-	debug(53, 3) ("asHandleReply: Done: %s\n", storeUrl(e));
-	memFree(buf, MEM_4K_BUF);
-	asStateFree(asState);
+  else
+    {
+      debug (53, 3) ("asHandleReply: Done: %s\n", storeUrl (e));
+      memFree (buf, MEM_4K_BUF);
+      asStateFree (asState);
     }
 }
 
 static void
-asStateFree(void *data)
+asStateFree (void *data)
 {
-    ASState *asState = data;
-    debug(53, 3) ("asnStateFree: %s\n", storeUrl(asState->entry));
-    storeUnregister(asState->sc, asState->entry, asState);
-    storeUnlockObject(asState->entry);
-    requestUnlink(asState->request);
-    cbdataFree(asState);
+  ASState *asState = data;
+  debug (53, 3) ("asnStateFree: %s\n", storeUrl (asState->entry));
+  storeUnregister (asState->sc, asState->entry, asState);
+  storeUnlockObject (asState->entry);
+  requestUnlink (asState->request);
+  cbdataFree (asState);
 }
 
 
 /* add a network (addr, mask) to the radix tree, with matching AS
  * number */
 
 static int
-asnAddNet(char *as_string, int as_number)
+asnAddNet (char *as_string, int as_number)
 {
-    rtentry *e = xmalloc(sizeof(rtentry));
-    struct radix_node *rn;
-    char dbg1[32], dbg2[32];
-    intlist **Tail = NULL;
-    intlist *q = NULL;
-    as_info *asinfo = NULL;
-    struct in_addr in_a, in_m;
-    long mask, addr;
-    char *t;
-    int bitl;
-
-    t = strchr(as_string, '/');
-    if (t == NULL) {
-	debug(53, 3) ("asnAddNet: failed, invalid response from whois server.\n");
-	return 0;
+  rtentry *e = xmalloc (sizeof (rtentry));
+  struct radix_node *rn;
+  char dbg1[32], dbg2[32];
+  intlist **Tail = NULL;
+  intlist *q = NULL;
+  as_info *asinfo = NULL;
+  struct in_addr in_a, in_m;
+  long mask, addr;
+  char *t;
+  int bitl;
+
+  t = strchr (as_string, '/');
+  if (t == NULL)
+    {
+      debug (53, 3) ("asnAddNet: failed, invalid response from whois server.\n");
+      return 0;
     }
-    *t = '\0';
-    addr = inet_addr(as_string);
-    bitl = atoi(t + 1);
-    if (bitl < 0)
-	bitl = 0;
-    if (bitl > 32)
-	bitl = 32;
-    mask = bitl ? 0xfffffffful << (32 - bitl) : 0;
-
-    in_a.s_addr = addr;
-    in_m.s_addr = mask;
-    xstrncpy(dbg1, inet_ntoa(in_a), 32);
-    xstrncpy(dbg2, inet_ntoa(in_m), 32);
-    addr = ntohl(addr);
-    /*mask = ntohl(mask); */
-    debug(53, 3) ("asnAddNet: called for %s/%s\n", dbg1, dbg2);
-    memset(e, '\0', sizeof(rtentry));
-    store_m_int(addr, e->e_addr);
-    store_m_int(mask, e->e_mask);
-    rn = rn_lookup(e->e_addr, e->e_mask, AS_tree_head);
-    if (rn != NULL) {
-	asinfo = ((rtentry *) rn)->e_info;
-	if (intlistFind(asinfo->as_number, as_number)) {
-	    debug(53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
-		dbg1, bitl, as_number);
-	} else {
-	    debug(53, 3) ("asnAddNet: Warning: Found a network with multiple AS numbers!\n");
-	    for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next);
-	    q = xcalloc(1, sizeof(intlist));
-	    q->i = as_number;
-	    *(Tail) = q;
-	    e->e_info = asinfo;
+  *t = '\0';
+  addr = inet_addr (as_string);
+  bitl = atoi (t + 1);
+  if (bitl < 0)
+    bitl = 0;
+  if (bitl > 32)
+    bitl = 32;
+  mask = bitl ? 0xfffffffful << (32 - bitl) : 0;
+
+  in_a.s_addr = addr;
+  in_m.s_addr = mask;
+  xstrncpy (dbg1, inet_ntoa (in_a), 32);
+  xstrncpy (dbg2, inet_ntoa (in_m), 32);
+  addr = ntohl (addr);
+  /*mask = ntohl(mask); */
+  debug (53, 3) ("asnAddNet: called for %s/%s\n", dbg1, dbg2);
+  memset (e, '\0', sizeof (rtentry));
+  store_m_int (addr, e->e_addr);
+  store_m_int (mask, e->e_mask);
+  rn = rn_lookup (e->e_addr, e->e_mask, AS_tree_head);
+  if (rn != NULL)
+    {
+      asinfo = ((rtentry *) rn)->e_info;
+      if (intlistFind (asinfo->as_number, as_number))
+	{
+	  debug (53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
+			 dbg1, bitl, as_number);
 	}
-    } else {
-	q = xcalloc(1, sizeof(intlist));
-	q->i = as_number;
-	asinfo = xmalloc(sizeof(asinfo));
-	asinfo->as_number = q;
-	rn = rn_addroute(e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
-	rn = rn_match(e->e_addr, AS_tree_head);
-	assert(rn != NULL);
-	e->e_info = asinfo;
+      else
+	{
+	  debug (53, 3) ("asnAddNet: Warning: Found a network with multiple AS numbers!\n");
+	  for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next);
+	  q = xcalloc (1, sizeof (intlist));
+	  q->i = as_number;
+	  *(Tail) = q;
+	  e->e_info = asinfo;
+	}
+    }
+  else
+    {
+      q = xcalloc (1, sizeof (intlist));
+      q->i = as_number;
+      asinfo = xmalloc (sizeof (asinfo));
+      asinfo->as_number = q;
+      rn = rn_addroute (e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
+      rn = rn_match (e->e_addr, AS_tree_head);
+      assert (rn != NULL);
+      e->e_info = asinfo;
     }
-    if (rn == 0) {
-	xfree(e);
-	debug(53, 3) ("asnAddNet: Could not add entry.\n");
-	return 0;
+  if (rn == 0)
+    {
+      xfree (e);
+      debug (53, 3) ("asnAddNet: Could not add entry.\n");
+      return 0;
     }
-    e->e_info = asinfo;
-    return 1;
+  e->e_info = asinfo;
+  return 1;
 }
 
 static int
-destroyRadixNode(struct radix_node *rn, void *w)
+destroyRadixNode (struct radix_node *rn, void *w)
 {
-    struct radix_node_head *rnh = (struct radix_node_head *) w;
-
-    if (rn && !(rn->rn_flags & RNF_ROOT)) {
-	rtentry *e = (rtentry *) rn;
-	rn = rn_delete(rn->rn_key, rn->rn_mask, rnh);
-	if (rn == 0)
-	    debug(53, 3) ("destroyRadixNode: internal screwup\n");
-	destroyRadixNodeInfo(e->e_info);
-	xfree(rn);
+  struct radix_node_head *rnh = (struct radix_node_head *) w;
+
+  if (rn && !(rn->rn_flags & RNF_ROOT))
+    {
+      rtentry *e = (rtentry *) rn;
+      rn = rn_delete (rn->rn_key, rn->rn_mask, rnh);
+      if (rn == 0)
+	debug (53, 3) ("destroyRadixNode: internal screwup\n");
+      destroyRadixNodeInfo (e->e_info);
+      xfree (rn);
     }
-    return 1;
+  return 1;
 }
 
 static void
-destroyRadixNodeInfo(as_info * e_info)
+destroyRadixNodeInfo (as_info * e_info)
 {
-    intlist *prev = NULL;
-    intlist *data = e_info->as_number;
-    while (data) {
-	prev = data;
-	data = data->next;
-	xfree(prev);
+  intlist *prev = NULL;
+  intlist *data = e_info->as_number;
+  while (data)
+    {
+      prev = data;
+      data = data->next;
+      xfree (prev);
     }
-    xfree(data);
+  xfree (data);
 }
 
 static int
-mask_len(int mask)
+mask_len (u_long mask)
 {
-    int len = 32;
-    if (mask == 0)
-	return 0;
-    while ((mask & 1) == 0) {
-	len--;
-	mask >>= 1;
+  int len = 32;
+  if (mask == 0)
+    return 0;
+  while ((mask & 1) == 0)
+    {
+      len--;
+      mask >>= 1;
     }
-    return len;
+  return len;
 }
 
 static int
-printRadixNode(struct radix_node *rn, void *w)
+printRadixNode (struct radix_node *rn, void *w)
 {
-    StoreEntry *sentry = w;
-    rtentry *e = (rtentry *) rn;
-    intlist *q;
-    as_info *asinfo;
-    struct in_addr addr;
-    struct in_addr mask;
-    assert(e);
-    assert(e->e_info);
-    (void) get_m_int(addr.s_addr, e->e_addr);
-    (void) get_m_int(mask.s_addr, e->e_mask);
-    storeAppendPrintf(sentry, "%15s/%d\t",
-	inet_ntoa(addr), mask_len(ntohl(mask.s_addr)));
-    asinfo = e->e_info;
-    assert(asinfo->as_number);
-    for (q = asinfo->as_number; q; q = q->next)
-	storeAppendPrintf(sentry, " %d", q->i);
-    storeAppendPrintf(sentry, "\n");
-    return 0;
+  StoreEntry *sentry = w;
+  rtentry *e = (rtentry *) rn;
+  intlist *q;
+  as_info *asinfo;
+  struct in_addr addr;
+  struct in_addr mask;
+  assert (e);
+  assert (e->e_info);
+  (void) get_m_int (addr.s_addr, e->e_addr);
+  (void) get_m_int (mask.s_addr, e->e_mask);
+  storeAppendPrintf (sentry, "%15s/%d\t",
+		     inet_ntoa (addr), mask_len (ntohl (mask.s_addr)));
+  asinfo = e->e_info;
+  assert (asinfo->as_number);
+  for (q = asinfo->as_number; q; q = q->next)
+    storeAppendPrintf (sentry, " %d", q->i);
+  storeAppendPrintf (sentry, "\n");
+  return 0;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.196 2001/10/08 16:18:32 hno Exp $
+ * $Id: enums.h,v 1.197 2001/10/17 10:59:08 adrian Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -34,7 +34,8 @@
 #ifndef SQUID_ENUMS_H
 #define SQUID_ENUMS_H
 
-typedef enum {
+typedef enum
+  {
     LOG_TAG_NONE,
     LOG_TCP_HIT,
     LOG_TCP_MISS,
@@ -58,9 +59,11 @@ typedef enum {
     LOG_UDP_MISS_NOFETCH,
     LOG_ICP_QUERY,
     LOG_TYPE_MAX
-} log_type;
+  }
+log_type;
 
-typedef enum {
+typedef enum
+  {
     ERR_NONE,
     ERR_READ_TIMEOUT,
     ERR_LIFETIME_EXP,
@@ -93,9 +96,11 @@ typedef enum {
     ERR_ONLY_IF_CACHED_MISS,	/* failure to satisfy only-if-cached request */
     ERR_TOO_BIG,
     ERR_MAX
-} err_type;
+  }
+err_type;
 
-typedef enum {
+typedef enum
+  {
     ACL_NONE,
     ACL_SRC_IP,
     ACL_DST_IP,
@@ -134,52 +139,64 @@ typedef enum {
     ACL_REP_MIME_TYPE,
     ACL_MAX_USER_IP,
     ACL_ENUM_MAX
-} squid_acl;
+  }
+squid_acl;
 
-typedef enum {
+typedef enum
+  {
     ACL_LOOKUP_NONE,
     ACL_LOOKUP_NEEDED,
     ACL_LOOKUP_PENDING,
     ACL_LOOKUP_DONE,
-    ACL_PROXY_AUTH_NEEDED,
-} acl_lookup_state;
+    ACL_PROXY_AUTH_NEEDED
+  }
+acl_lookup_state;
 
-enum {
+enum
+  {
     FD_NONE,
     FD_LOG,
     FD_FILE,
     FD_SOCKET,
     FD_PIPE,
     FD_UNKNOWN
-};
+  };
 
-enum {
+enum
+  {
     FD_READ,
     FD_WRITE
-};
+  };
 
-typedef enum {
+typedef enum
+  {
     PEER_NONE,
     PEER_SIBLING,
     PEER_PARENT,
     PEER_MULTICAST
-} peer_t;
+  }
+peer_t;
 
-typedef enum {
+typedef enum
+  {
     PEER_SA_NONE,
     PEER_SA_DIGEST,
     PEER_SA_ICP,
     PEER_SA_NETDB
-} peer_select_alg_t;
+  }
+peer_select_alg_t;
 
-typedef enum {
+typedef enum
+  {
     LOOKUP_NONE,
     LOOKUP_HIT,
     LOOKUP_MISS
-} lookup_t;
+  }
+lookup_t;
 
 /* recognized or "known" header fields; @?@ add more! */
-typedef enum {
+typedef enum
+  {
     HDR_ACCEPT,
     HDR_ACCEPT_CHARSET,
     HDR_ACCEPT_ENCODING,
@@ -244,9 +261,11 @@ typedef enum {
 #endif
     HDR_OTHER,
     HDR_ENUM_END
-} http_hdr_type;
+  }
+http_hdr_type;
 
-typedef enum {
+typedef enum
+  {
     CC_PUBLIC,
     CC_PRIVATE,
     CC_NO_CACHE,
@@ -260,10 +279,12 @@ typedef enum {
     CC_ONLY_IF_CACHED,
     CC_OTHER,
     CC_ENUM_END
-} http_hdr_cc_type;
+  }
+http_hdr_cc_type;
 
 /* possible types for http header fields */
-typedef enum {
+typedef enum
+  {
     ftInvalid = HDR_ENUM_END,	/* to catch nasty errors with hdr_id<->fld_type clashes */
     ftInt,
     ftStr,
@@ -273,19 +294,23 @@ typedef enum {
     ftPContRange,
     ftPRange,
     ftDate_1123_or_ETag
-} field_type;
+  }
+field_type;
 
 /* possible owners of http header */
-typedef enum {
+typedef enum
+  {
     hoNone,
 #if USE_HTCP
     hoHtcpReply,
 #endif
     hoRequest,
     hoReply
-} http_hdr_owner_type;
+  }
+http_hdr_owner_type;
 
-typedef enum {
+typedef enum
+  {
     HIER_NONE,
     DIRECT,
     SIBLING_HIT,
@@ -309,9 +334,11 @@ typedef enum {
 #endif
     ANY_OLD_PARENT,
     HIER_MAX
-} hier_code;
+  }
+hier_code;
 
-typedef enum {
+typedef enum
+  {
     ICP_INVALID,
     ICP_QUERY,
     ICP_HIT,
@@ -337,37 +364,45 @@ typedef enum {
     ICP_DENIED,
     ICP_HIT_OBJ,
     ICP_END
-} icp_opcode;
+  }
+icp_opcode;
 
-enum {
+enum
+  {
     NOT_IN_MEMORY,
     IN_MEMORY
-};
+  };
 
-enum {
+enum
+  {
     PING_NONE,
     PING_WAITING,
     PING_DONE
-};
+  };
 
-enum {
+enum
+  {
     STORE_OK,
     STORE_PENDING
-};
+  };
 
-enum {
+enum
+  {
     SWAPOUT_NONE,
     SWAPOUT_WRITING,
     SWAPOUT_DONE
-};
+  };
 
-typedef enum {
+typedef enum
+  {
     STORE_NON_CLIENT,
     STORE_MEM_CLIENT,
     STORE_DISK_CLIENT
-} store_client_t;
+  }
+store_client_t;
 
-enum {
+enum
+  {
     METHOD_NONE,		/* 000 */
     METHOD_GET,			/* 001 */
     METHOD_POST,		/* 010 */
@@ -409,10 +444,11 @@ enum {
     METHOD_EXT18,
     METHOD_EXT19,
     METHOD_ENUM_END
-};
+  };
 typedef unsigned int method_t;
 
-typedef enum {
+typedef enum
+  {
     PROTO_NONE,
     PROTO_HTTP,
     PROTO_FTP,
@@ -428,9 +464,11 @@ typedef enum {
     PROTO_INTERNAL,
     PROTO_HTTPS,
     PROTO_MAX
-} protocol_t;
+  }
+protocol_t;
 
-typedef enum {
+typedef enum
+  {
     HTTP_STATUS_NONE = 0,
     HTTP_CONTINUE = 100,
     HTTP_SWITCHING_PROTOCOLS = 101,
@@ -476,15 +514,17 @@ typedef enum {
     HTTP_HTTP_VERSION_NOT_SUPPORTED = 505,
     HTTP_INSUFFICIENT_STORAGE = 507,	/* RFC2518 section 10.6 */
     HTTP_INVALID_HEADER = 600	/* Squid header parsing error */
-} http_status;
+  }
+http_status;
 
 /*
  * These are for StoreEntry->flag, which is defined as a SHORT
  *
  * NOTE: These flags are written to swap.state, so think very carefully
  * about deleting or re-assigning!
  */
-enum {
+enum
+  {
     ENTRY_SPECIAL,
     ENTRY_REVALIDATE,
     DELAY_SENDING,
@@ -501,63 +541,77 @@ enum {
 #if UNUSED_CODE
     ENTRY_DONT_LOG
 #endif
-};
+  };
 
-typedef enum {
+typedef enum
+  {
     ACCESS_DENIED,
     ACCESS_ALLOWED,
     ACCESS_REQ_PROXY_AUTH
-} allow_t;
+  }
+allow_t;
 
-typedef enum {
+typedef enum
+  {
     AUTH_ACL_CHALLENGE = -2,
     AUTH_ACL_HELPER = -1,
     AUTH_ACL_CANNOT_AUTHENTICATE = 0,
-    AUTH_AUTHENTICATED = 1,
-} auth_acl_t;
+    AUTH_AUTHENTICATED = 1
+  }
+auth_acl_t;
 
-typedef enum {
+typedef enum
+  {
     AUTH_UNKNOWN,		/* default */
     AUTH_BASIC,
     AUTH_NTLM,
     AUTH_DIGEST,
     AUTH_BROKEN			/* known type, but broken data */
-} auth_type_t;
+  }
+auth_type_t;
 
-typedef enum {
+typedef enum
+  {
     AUTHENTICATE_STATE_NONE,
     AUTHENTICATE_STATE_NEGOTIATE,
     AUTHENTICATE_STATE_CHALLENGE,
     AUTHENTICATE_STATE_RESPONSE,
     AUTHENTICATE_STATE_DONE
-} auth_state_t;			/* connection level auth state */
+  }
+auth_state_t;			/* connection level auth state */
 
 /* stateful helper callback response codes */
-typedef enum {
+typedef enum
+  {
     S_HELPER_UNKNOWN,
     S_HELPER_RESERVE,
     S_HELPER_RELEASE,
     S_HELPER_DEFER
-} stateful_helper_callback_t;
+  }
+stateful_helper_callback_t;
 
 /* stateful helper reservation info */
-typedef enum {
+typedef enum
+  {
     S_HELPER_FREE,		/* available for requests */
     S_HELPER_RESERVED,		/* in a reserved state - no active request, but state data in the helper shouldn't be disturbed */
     S_HELPER_DEFERRED		/* available for requests, and at least one more will come from a previous caller with the server pointer */
-} stateful_helper_reserve_t;
+  }
+stateful_helper_reserve_t;
 
 
 #if SQUID_SNMP
-enum {
+enum
+  {
     SNMP_C_VIEW,
     SNMP_C_USER,
     SNMP_C_COMMUNITY
-};
+  };
 
 #endif
 
-typedef enum {
+typedef enum
+  {
     MEM_NONE,
     MEM_2K_BUF,
     MEM_4K_BUF,
@@ -618,12 +672,14 @@ typedef enum {
     MEM_SWAP_LOG_DATA,
     MEM_CLIENT_REQ_BUF,
     MEM_MAX
-} mem_type;
+  }
+mem_type;
 
 /*
  * NOTE!  We must preserve the order of this list!
  */
-enum {
+enum
+  {
     STORE_META_VOID,		/* should not come up */
     STORE_META_KEY_URL,		/* key w/ keytype */
     STORE_META_KEY_SHA,
@@ -634,34 +690,40 @@ enum {
     STORE_META_VALID,
     STORE_META_VARY_HEADERS,	/* Stores Vary request headers */
     STORE_META_END
-};
+  };
 
-enum {
+enum
+  {
     STORE_LOG_CREATE,
     STORE_LOG_SWAPIN,
     STORE_LOG_SWAPOUT,
     STORE_LOG_RELEASE,
     STORE_LOG_SWAPOUTFAIL
-};
+  };
 
-typedef enum {
+typedef enum
+  {
     SWAP_LOG_NOP,
     SWAP_LOG_ADD,
     SWAP_LOG_DEL,
     SWAP_LOG_MAX
-} swap_log_op;
+  }
+swap_log_op;
 
 
 /* parse state of HttpReply or HttpRequest */
-typedef enum {
+typedef enum
+  {
     psReadyToParseStartLine = 0,
     psReadyToParseHeaders,
     psParsed,
     psError
-} HttpMsgParseState;
+  }
+HttpMsgParseState;
 
 
-enum {
+enum
+  {
     MEDIAN_HTTP,
     MEDIAN_ICP_QUERY,
     MEDIAN_DNS,
@@ -670,30 +732,33 @@ enum {
     MEDIAN_NM,
     MEDIAN_NH,
     MEDIAN_ICP_REPLY
-};
+  };
 
-enum {
+enum
+  {
     SENT,
     RECV
-};
+  };
 
 /*
  * These are field indicators for raw cache-cache netdb transfers
  */
-enum {
+enum
+  {
     NETDB_EX_NONE,
     NETDB_EX_NETWORK,
     NETDB_EX_RTT,
     NETDB_EX_HOPS
-};
+  };
 
 /*
  * cbdata types. similar to the MEM_* types above, but managed
  * in cbdata.c. A big difference is that these types are dynamically
  * allocated. This list is only a list of predefined types. Other types
  * are added runtime
  */
-typedef enum {
+typedef enum
+  {
     CBDATA_UNKNOWN = 0,
     CBDATA_UNDEF = 0,
     CBDATA_acl_access,
@@ -715,16 +780,18 @@ typedef enum {
     CBDATA_RemovalPurgeWalker,
     CBDATA_store_client,
     CBDATA_FIRST_CUSTOM_TYPE = 1000
-} cbdata_type;
+  }
+cbdata_type;
 
 /*
  * Return codes from checkVary(request)
  */
-enum {
+enum
+  {
     VARY_NONE,
     VARY_MATCH,
     VARY_OTHER,
     VARY_CANCEL
-};
+  };
 
 #endif /* SQUID_ENUMS_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_rebuild.cc,v 1.75 2001/01/12 00:37:22 wessels Exp $
+ * $Id: store_rebuild.cc,v 1.76 2001/10/17 10:59:09 adrian Exp $
  *
  * DEBUG: section 20    Store Rebuild Routines
  * AUTHOR: Duane Wessels
@@ -37,114 +37,119 @@
 
 static struct _store_rebuild_data counts;
 static struct timeval rebuild_start;
-static void storeCleanup(void *);
+static void storeCleanup (void *);
 
-typedef struct {
+typedef struct
+  {
     /* total number of "swap.state" entries that will be read */
     int total;
     /* number of entries read so far */
     int scanned;
-} store_rebuild_progress;
+  }
+store_rebuild_progress;
 
 static store_rebuild_progress *RebuildProgress = NULL;
 
 static int
-storeCleanupDoubleCheck(StoreEntry * e)
+storeCleanupDoubleCheck (StoreEntry * e)
 {
-    SwapDir *SD = &Config.cacheSwap.swapDirs[e->swap_dirn];
-    return (SD->dblcheck(SD, e));
+  SwapDir *SD = &Config.cacheSwap.swapDirs[e->swap_dirn];
+  return (SD->dblcheck (SD, e));
 }
 
 static void
-storeCleanup(void *datanotused)
+storeCleanup (void *datanotused)
 {
-    static int bucketnum = -1;
-    static int validnum = 0;
-    static int store_errors = 0;
-    int validnum_start;
-    StoreEntry *e;
-    hash_link *link_ptr = NULL;
-    hash_link *link_next = NULL;
-    validnum_start = validnum;
-    while (validnum - validnum_start < 500) {
-	if (++bucketnum >= store_hash_buckets) {
-	    debug(20, 1) ("  Completed Validation Procedure\n");
-	    debug(20, 1) ("  Validated %d Entries\n", validnum);
-	    debug(20, 1) ("  store_swap_size = %dk\n", store_swap_size);
-	    store_dirs_rebuilding--;
-	    assert(0 == store_dirs_rebuilding);
-	    if (opt_store_doublecheck)
-		assert(store_errors == 0);
-	    if (store_digest)
-		storeDigestNoteStoreReady();
-	    return;
+  static int bucketnum = -1;
+  static int validnum = 0;
+  static int store_errors = 0;
+  int validnum_start;
+  StoreEntry *e;
+  hash_link *link_ptr = NULL;
+  hash_link *link_next = NULL;
+  validnum_start = validnum;
+  while (validnum - validnum_start < 500)
+    {
+      if (++bucketnum >= store_hash_buckets)
+	{
+	  debug (20, 1) ("  Completed Validation Procedure\n");
+	  debug (20, 1) ("  Validated %d Entries\n", validnum);
+	  debug (20, 1) ("  store_swap_size = %dk\n", store_swap_size);
+	  store_dirs_rebuilding--;
+	  assert (0 == store_dirs_rebuilding);
+	  if (opt_store_doublecheck)
+	    assert (store_errors == 0);
+	  if (store_digest)
+	    storeDigestNoteStoreReady ();
+	  return;
 	}
-	link_next = hash_get_bucket(store_table, bucketnum);
-	while (NULL != (link_ptr = link_next)) {
-	    link_next = link_ptr->next;
-	    e = (StoreEntry *) link_ptr;
-	    if (EBIT_TEST(e->flags, ENTRY_VALIDATED))
-		continue;
-	    /*
-	     * Calling storeRelease() has no effect because we're
-	     * still in 'store_rebuilding' state
-	     */
-	    if (e->swap_filen < 0)
-		continue;
-	    if (opt_store_doublecheck)
-		if (storeCleanupDoubleCheck(e))
-		    store_errors++;
-	    EBIT_SET(e->flags, ENTRY_VALIDATED);
-	    /*
-	     * Only set the file bit if we know its a valid entry
-	     * otherwise, set it in the validation procedure
-	     */
-	    storeDirUpdateSwapSize(&Config.cacheSwap.swapDirs[e->swap_dirn], e->swap_file_sz, 1);
-	    if ((++validnum & 0x3FFFF) == 0)
-		debug(20, 1) ("  %7d Entries Validated so far.\n", validnum);
+      link_next = hash_get_bucket (store_table, bucketnum);
+      while (NULL != (link_ptr = link_next))
+	{
+	  link_next = link_ptr->next;
+	  e = (StoreEntry *) link_ptr;
+	  if (EBIT_TEST (e->flags, ENTRY_VALIDATED))
+	    continue;
+	  /*
+	   * Calling storeRelease() has no effect because we're
+	   * still in 'store_rebuilding' state
+	   */
+	  if (e->swap_filen < 0)
+	    continue;
+	  if (opt_store_doublecheck)
+	    if (storeCleanupDoubleCheck (e))
+	      store_errors++;
+	  EBIT_SET (e->flags, ENTRY_VALIDATED);
+	  /*
+	   * Only set the file bit if we know its a valid entry
+	   * otherwise, set it in the validation procedure
+	   */
+	  storeDirUpdateSwapSize (&Config.cacheSwap.swapDirs[e->swap_dirn], e->swap_file_sz, 1);
+	  if ((++validnum & 0x3FFFF) == 0)
+	    debug (20, 1) ("  %7d Entries Validated so far.\n", validnum);
 	}
     }
-    eventAdd("storeCleanup", storeCleanup, NULL, 0.0, 1);
+  eventAdd ("storeCleanup", storeCleanup, NULL, 0.0, 1);
 }
 
 /* meta data recreated from disk image in swap directory */
 void
-storeRebuildComplete(struct _store_rebuild_data *dc)
+storeRebuildComplete (struct _store_rebuild_data *dc)
 {
-    double dt;
-    counts.objcount += dc->objcount;
-    counts.expcount += dc->expcount;
-    counts.scancount += dc->scancount;
-    counts.clashcount += dc->clashcount;
-    counts.dupcount += dc->dupcount;
-    counts.cancelcount += dc->cancelcount;
-    counts.invalid += dc->invalid;
-    counts.badflags += dc->badflags;
-    counts.bad_log_op += dc->bad_log_op;
-    counts.zero_object_sz += dc->zero_object_sz;
-    /*
-     * When store_dirs_rebuilding == 1, it means we are done reading
-     * or scanning all cache_dirs.  Now report the stats and start
-     * the validation (storeCleanup()) thread.
-     */
-    if (store_dirs_rebuilding > 1)
-	return;
-    dt = tvSubDsec(rebuild_start, current_time);
-    debug(20, 1) ("Finished rebuilding storage from disk.\n");
-    debug(20, 1) ("  %7d Entries scanned\n", counts.scancount);
-    debug(20, 1) ("  %7d Invalid entries.\n", counts.invalid);
-    debug(20, 1) ("  %7d With invalid flags.\n", counts.badflags);
-    debug(20, 1) ("  %7d Objects loaded.\n", counts.objcount);
-    debug(20, 1) ("  %7d Objects expired.\n", counts.expcount);
-    debug(20, 1) ("  %7d Objects cancelled.\n", counts.cancelcount);
-    debug(20, 1) ("  %7d Duplicate URLs purged.\n", counts.dupcount);
-    debug(20, 1) ("  %7d Swapfile clashes avoided.\n", counts.clashcount);
-    debug(20, 1) ("  Took %3.1f seconds (%6.1f objects/sec).\n", dt,
-	(double) counts.objcount / (dt > 0.0 ? dt : 1.0));
-    debug(20, 1) ("Beginning Validation Procedure\n");
-    eventAdd("storeCleanup", storeCleanup, NULL, 0.0, 1);
-    xfree(RebuildProgress);
-    RebuildProgress = NULL;
+  double dt;
+  counts.objcount += dc->objcount;
+  counts.expcount += dc->expcount;
+  counts.scancount += dc->scancount;
+  counts.clashcount += dc->clashcount;
+  counts.dupcount += dc->dupcount;
+  counts.cancelcount += dc->cancelcount;
+  counts.invalid += dc->invalid;
+  counts.badflags += dc->badflags;
+  counts.bad_log_op += dc->bad_log_op;
+  counts.zero_object_sz += dc->zero_object_sz;
+  /*
+   * When store_dirs_rebuilding == 1, it means we are done reading
+   * or scanning all cache_dirs.  Now report the stats and start
+   * the validation (storeCleanup()) thread.
+   */
+  if (store_dirs_rebuilding > 1)
+    return;
+  dt = tvSubDsec (rebuild_start, current_time);
+  debug (20, 1) ("Finished rebuilding storage from disk.\n");
+  debug (20, 1) ("  %7d Entries scanned\n", counts.scancount);
+  debug (20, 1) ("  %7d Invalid entries.\n", counts.invalid);
+  debug (20, 1) ("  %7d With invalid flags.\n", counts.badflags);
+  debug (20, 1) ("  %7d Objects loaded.\n", counts.objcount);
+  debug (20, 1) ("  %7d Objects expired.\n", counts.expcount);
+  debug (20, 1) ("  %7d Objects cancelled.\n", counts.cancelcount);
+  debug (20, 1) ("  %7d Duplicate URLs purged.\n", counts.dupcount);
+  debug (20, 1) ("  %7d Swapfile clashes avoided.\n", counts.clashcount);
+  debug (20, 1) ("  Took %3.1f seconds (%6.1f objects/sec).\n", dt,
+		 (double) counts.objcount / (dt > 0.0 ? dt : 1.0));
+  debug (20, 1) ("Beginning Validation Procedure\n");
+  eventAdd ("storeCleanup", storeCleanup, NULL, 0.0, 1);
+  xfree (RebuildProgress);
+  RebuildProgress = NULL;
 }
 
 /*
@@ -153,44 +158,45 @@ storeRebuildComplete(struct _store_rebuild_data *dc)
  * actually started by the filesystem "fooDirInit" function.
  */
 void
-storeRebuildStart(void)
+storeRebuildStart (void)
 {
-    memset(&counts, '\0', sizeof(counts));
-    rebuild_start = current_time;
-    /*
-     * Note: store_dirs_rebuilding is initialized to 1 in globals.c.
-     * This prevents us from trying to write clean logs until we
-     * finished rebuilding for sure.  The corresponding decrement
-     * occurs in storeCleanup(), when it is finished.
-     */
-    RebuildProgress = xcalloc(Config.cacheSwap.n_configured,
-	sizeof(store_rebuild_progress));
+  memset (&counts, '\0', sizeof (counts));
+  rebuild_start = current_time;
+  /*
+   * Note: store_dirs_rebuilding is initialized to 1 in globals.c.
+   * This prevents us from trying to write clean logs until we
+   * finished rebuilding for sure.  The corresponding decrement
+   * occurs in storeCleanup(), when it is finished.
+   */
+  RebuildProgress = xcalloc (Config.cacheSwap.n_configured,
+			     sizeof (store_rebuild_progress));
 }
 
 /*
  * A fs-specific rebuild procedure periodically reports its
  * progress.
  */
 void
-storeRebuildProgress(int index, int total, int sofar)
+storeRebuildProgress (int sd_index, int total, int sofar)
 {
-    static time_t last_report = 0;
-    double n = 0.0;
-    double d = 0.0;
-    if (index < 0)
-	return;
-    if (index >= Config.cacheSwap.n_configured)
-	return;
-    if (NULL == RebuildProgress)
-	return;
-    RebuildProgress[index].total = total;
-    RebuildProgress[index].scanned = sofar;
-    if (squid_curtime - last_report < 15)
-	return;
-    for (index = 0; index < Config.cacheSwap.n_configured; index++) {
-	n += (double) RebuildProgress[index].scanned;
-	d += (double) RebuildProgress[index].total;
+  static time_t last_report = 0;
+  double n = 0.0;
+  double d = 0.0;
+  if (sd_index < 0)
+    return;
+  if (sd_index >= Config.cacheSwap.n_configured)
+    return;
+  if (NULL == RebuildProgress)
+    return;
+  RebuildProgress[sd_index].total = total;
+  RebuildProgress[sd_index].scanned = sofar;
+  if (squid_curtime - last_report < 15)
+    return;
+  for (sd_index = 0; sd_index < Config.cacheSwap.n_configured; sd_index++)
+    {
+      n += (double) RebuildProgress[sd_index].scanned;
+      d += (double) RebuildProgress[sd_index].total;
     }
-    debug(20, 1) ("Store rebuilding is %4.1f%% complete\n", 100.0 * n / d);
-    last_report = squid_curtime;
+  debug (20, 1) ("Store rebuilding is %4.1f%% complete\n", 100.0 * n / d);
+  last_report = squid_curtime;
 }