@@ -86,6 +86,15 @@ AC_DEFUN([SQUID_CC_GUESS_VARIANT], [
 #endif
     ]])],[squid_cv_compiler="sunstudio"],[])
   fi
+  dnl Intel CC
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(__ICC)
+#error "not Intel(R) C++ Compiler"
+#endif
+    ]])],[squid_cv_compiler="icc"],[])
+  fi
   dnl end of block to be repeated
   if test -z "$squid_cv_compiler" ; then
    squid_cv_compiler="none"
@@ -122,6 +131,13 @@ AC_DEFUN([SQUID_CC_GUESS_OPTIONS], [
    squid_cv_cc_option_optimize="-fast"
    squid_cv_cc_arg_pipe=""
    ;;
+  icc) 
+   squid_cv_cxx_option_werror="-Werror"
+   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
+   squid_cv_cc_option_wall="-Wall"
+   squid_cv_cc_option_optimize="-O2"
+   squid_cv_cc_arg_pipe=""
+   ;;
   *) 
    squid_cv_cxx_option_werror="" 
    squid_cv_cc_option_werror="" 
@@ -34,7 +34,7 @@
 #ifndef SQUID_OS_MSWIN_H
 #define SQUID_OS_MSWIN_H
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 
 #define ACL WindowsACL
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
@@ -758,5 +758,5 @@ SQUIDCEXTERN size_t getpagesize(void);
 #define PRINTF_FORMAT_ARG3
 #endif
 
-#endif /* _SQUID_WIN32_ */
+#endif /* _SQUID_WINDOWS_ */
 #endif /* SQUID_OS_MSWIN_H */
@@ -33,7 +33,7 @@
 #ifndef SQUID_OS_WINDOWS_H
 #define SQUID_OS_WINDOWS_H
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 
 #ifndef ACL
 #define ACL WindowsACL
@@ -45,5 +45,5 @@
 #undef _MSWIN_ACL_WAS_NOT_DEFINED
 #endif
 
-#endif /* _SQUID_WIN32_ */
+#endif /* _SQUID_WINDOWS_ */
 #endif /* SQUID_OS_WINDOWS_H */
@@ -65,16 +65,20 @@
 #elif defined(__DragonFly__)
 #define _SQUID_DRAGONFLY_ 1
 
-#elif defined(__CYGWIN32__)  || defined(__CYGWIN__)
+#elif defined(__CYGWIN32__) || defined(__CYGWIN__)
 #define _SQUID_CYGWIN_ 1
-#define _SQUID_WIN32_ 1
+#define _SQUID_WINDOWS_ 1
+
+#elif defined(__MINGW32__) || defined(__MINGW__)
+#define _SQUID_MINGW_ 1
+#define _SQUID_WINDOWS_ 1
 
 #elif defined(WIN32) || defined(WINNT) || defined(__WIN32__) || defined(__WIN32)
 /* We are using _SQUID_MSWIN_ define in cf.data.pre, so
    it must be defined to 1 to avoid the build failure of cfgen.
  */
 #define _SQUID_MSWIN_ 1
-#define _SQUID_WIN32_ 1
+#define _SQUID_WINDOWS_ 1
 
 #elif defined(__APPLE__)
 #define _SQUID_APPLE_ 1
@@ -709,7 +709,7 @@ for fs in $squid_storeio_module_candidates none; do
       if ! test "x$squid_disk_module_candidates_AIO" = "xyes"; then
         AC_MSG_ERROR([COSS requires POSIX AIO which is not available.])
       fi
-      # Automake om MinGW needs explicit exe extension
+      # Automake on MinGW needs explicit exe extension
       # for STORE_TESTS substition
       STORE_TESTS="$STORE_TESTS tests/testCoss$EXEEXT"
       ;;
@@ -1189,7 +1189,13 @@ AC_ARG_ENABLE(select,
   AS_HELP_STRING([--disable-select],[Disable select(2) support.]),
 [
 SQUID_YESNO($enableval,[--disable-select takes no extra argument])
-test "x$enableval" = "xyes" && squid_opt_io_loop_engine="select"
+if test "x$enableval" = "xyes"; then
+  if test "x$squid_host_os" = "xmingw"; then
+    squid_opt_io_loop_engine="select_win32"
+  else
+    squid_opt_io_loop_engine="select"
+  fi
+fi
 ])
 AC_MSG_NOTICE([enabling select syscall for net I/O: ${enable_select:=auto}])
 
@@ -2056,7 +2062,7 @@ if test "x$squid_require_sasl" = "xyes"; then
       AC_MSG_ERROR(Neither SASL nor SASL2 found)
     ])
   ])
-  case "$host_os" in
+  case "$squid_host_os" in
     Darwin)
       if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
         AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
@@ -3102,11 +3108,10 @@ elif test "x$enable_devpoll" != "xno" ; then
   squid_opt_io_loop_engine="devpoll"
 elif test "x$enable_poll" != "xno" -a "x$ac_cv_func_poll" = "xyes" ; then
   squid_opt_io_loop_engine="poll"
-elif test "x$enable_select" != "xno" -a "x$ac_cv_func_select" = "xyes" ; then
+elif test "x$enable_select" != "xno" -a "x$ac_cv_func_select" = "xyes"; then
   squid_opt_io_loop_engine="select"
-  if test "x$squid_host_os" = "xmingw" ; then
-    squid_opt_io_loop_engine="select_win32"
-  fi
+elif test "x$enable_select" != "xno" -a "x$squid_host_os" = "xmingw"; then
+  squid_opt_io_loop_engine="select_win32"
 else
   AC_MSG_WARN([Eep!  Cannot find epoll, kqueue, /dev/poll, poll or select!])
   AC_MSG_WARN([Will try select and hope for the best.])
@@ -3118,7 +3123,6 @@ AC_MSG_NOTICE([Using ${squid_opt_io_loop_engine} for the IO loop.])
 AM_CONDITIONAL([USE_POLL], [test $squid_opt_io_loop_engine = poll])
 AM_CONDITIONAL([USE_EPOLL], [test $squid_opt_io_loop_engine = epoll])
 AM_CONDITIONAL([USE_SELECT], [test $squid_opt_io_loop_engine = select])
-AM_CONDITIONAL([USE_SELECT_SIMPLE], [test $squid_opt_io_loop_engine = select_simple])
 AM_CONDITIONAL([USE_SELECT_WIN32], [test $squid_opt_io_loop_engine = select_win32])
 AM_CONDITIONAL([USE_KQUEUE], [test $squid_opt_io_loop_engine = kqueue])
 AM_CONDITIONAL([USE_DEVPOLL], [test $squid_opt_io_loop_engine = devpoll])
@@ -29,6 +29,7 @@ ERROR_TEMPLATES =  \
 	templates/ERR_FTP_PUT_ERROR \
 	templates/ERR_FTP_PUT_MODIFIED \
 	templates/ERR_FTP_UNAVAILABLE \
+	templates/ERR_GATEWAY_FAILURE \
 	templates/ERR_ICAP_FAILURE \
 	templates/ERR_INVALID_REQ \
 	templates/ERR_INVALID_RESP \
@@ -3,7 +3,7 @@
 az	Azerbaijani
 bg	Bulgarian
 ca	Catalan
-cz	Czech
+cs	Czech
 da	Danish
 de	German
 el	Greek
@@ -20,7 +20,7 @@ ja	Japanese
 ko	Korean
 lt	Lithuanian
 nl	Dutch
-po	Polish
+pl	Polish
 pt	Portuguese
 ro	Romanian
 ru	Russian-1251 Russian-koi8-r
@@ -3,15 +3,15 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2010-11-06 03:26+1300\n"
-"PO-Revision-Date: 2010-08-21 17:08+0200\n"
+"PO-Revision-Date: 2011-01-20 21:35+0200\n"
 "Last-Translator: Arthur <arthurtumanyan@yahoo.com>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: hy\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Pootle 2.0.1\n"
+"X-Generator: Pootle 2.0.5\n"
 
 #: templates/ERR_DIR_LISTING:6
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
@@ -100,7 +100,7 @@ msgstr ""
 msgid ""
 "At least one precondition specified by the HTTP client in the request header "
 "has failed."
-msgstr ""
+msgstr "HTTP հարցումի նախապայմաններից առնվազն մեկը անհնար է մշակել"
 
 #: templates/ERR_CACHE_ACCESS_DENIED:3 templates/ERR_CACHE_ACCESS_DENIED:5
 msgid "Cache Access Denied."
@@ -112,17 +112,16 @@ msgid "Cache Manager Access Denied."
 msgstr "Քեշի կառավառման մուտքն արգելված է."
 
 #: templates/ERR_URN_RESOLVE:5
-#, fuzzy
 msgid "Cannot Resolve URN"
-msgstr "Cannot Resolve URN"
+msgstr "Չհաջողվեց մշակել URN հարցումը"
 
 #: templates/ERR_LIFETIME_EXP:5
 msgid "Connection Lifetime Expired"
 msgstr "Կապի հաստատման ժամանակը սպառվեց"
 
 #: templates/ERR_CONNECT_FAIL:5
 msgid "Connection to %I failed."
-msgstr ""
+msgstr "Չհաջողվեց կապ հաստատել %I -ի հետ"
 
 #: templates/ERR_INVALID_REQ:10
 msgid "Content-Length missing for POST or PUT requests."
@@ -134,7 +133,7 @@ msgstr "Դիրեկտորիայի պարունակությունը:"
 
 #: templates/ERR_DIR_LISTING:4
 msgid "Directory Listing"
-msgstr ""
+msgstr "Դիրեկտորիայի պարունակությունը"
 
 #: templates/ERR_DIR_LISTING:1
 msgid "Directory: %U"
@@ -199,7 +198,7 @@ msgstr "ՍԽԱԼ: Պահանջվող URL-ն հնարավոր չէ ստանալ"
 
 #: templates/ERR_ESI:5
 msgid "ESI Processing failed."
-msgstr ""
+msgstr "Չհաջողվեց մշակել ESI հարցումը"
 
 #: templates/ERR_FTP_PUT_CREATED:1 templates/ERR_FTP_PUT_MODIFIED:1
 msgid "FTP PUT Successful."
@@ -281,25 +280,19 @@ msgstr "Ինչպես փնտրել այս կարգաբերումները քո բ
 
 #: templates/ERR_ICAP_FAILURE:5
 msgid "ICAP protocol error."
-msgstr ""
+msgstr "ICAP արձանարության սխալ"
 
 #: templates/ERR_TOO_BIG:7
-#, fuzzy
 msgid ""
 "If you are making a GET request, then the item you are trying to download is "
 "too large."
-msgstr ""
-"Եթե Դուք GET հարցում եք ձևակերպում, ապա տարրը ,որը Դուք փորձում եք "
-"բեռնավորել, շատ մեծ ծավալ ունի."
+msgstr "GET հարցման օբյեկտը շատ մեծ ծավալ ունի."
 
 #: templates/ERR_TOO_BIG:6
-#, fuzzy
 msgid ""
 "If you are making a POST or PUT request, then the item you are trying to "
 "upload is too large."
-msgstr ""
-"Եթե Դուք POST կամ PUT  հարցում եք ձևակերպում, ապա տարրը ,որը Դուք փորձում եք "
-"բեռնավորել, շատ մեծ ծավալ ունի"
+msgstr "POST հարցման օբյեկտը շատ մեծ ծավալ ունի."
 
 #: templates/ERR_INVALID_REQ:11 templates/ERR_INVALID_URL:11
 msgid "Illegal character in hostname; underscores are not allowed."
@@ -376,7 +369,7 @@ msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED:5
 msgid "Precondition Failed."
-msgstr ""
+msgstr "Չհաջողվեց մշակել նախապայմանը"
 
 #: templates/ERR_READ_ERROR:5
 msgid "Read Error"
@@ -466,9 +459,8 @@ msgid "The DNS server returned:"
 msgstr "DNS սերվերի պատասխանը:"
 
 #: templates/ERR_ESI:6
-#, fuzzy
 msgid "The ESI processor returned:"
-msgstr "ESI պրոցեսորը պատասխանեց:"
+msgstr "ESI հարցման պատասխանն է։"
 
 #: templates/ERR_FTP_UNAVAILABLE:4
 msgid "The FTP server was too busy to retrieve the URL: <a href=\"%U\">%U</a>"
@@ -0,0 +1,39 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html><head>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>ERROR: The requested URL could not be retrieved</title>
+<style type="text/css"><!-- 
+ %l
+
+body
+:lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
+:lang(he) { direction: rtl; float: right; }
+ --></style>
+</head><body>
+<div id="titles">
+<h1>ERROR</h1>
+<h2>The requested URL could not be retrieved</h2>
+</div>
+<hr>
+
+<div id="content">
+<p>The following error was encountered while trying to retrieve the URL: <a href="%U">%U</a></p>
+
+<blockquote id="error">
+<p><b>Gateway Proxy Failure</b></p>
+</blockquote>
+
+<p>A non-recoverable internal failure or configuration problem prevents this request from being completed.</p>
+
+<p>This may be due to limits established by the Internet Service Provider who operates this cache. Please contact them directly for more information.</p>
+
+<p>Your cache administrator is <a href="mailto:%w%W">%w</a>.</p>
+<br>
+</div>
+
+<hr>
+<div id="footer">
+<p>Generated %T by %h (%s)</p>
+<!-- %c -->
+</div>
+</body></html>
@@ -63,7 +63,7 @@
 #if HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 #include <io.h>
 #endif
 #if HAVE_CTYPE_H
@@ -36,7 +36,10 @@
 #endif
 
 /* Check if we try to compile on a Windows Platform */
-#if defined(_SQUID_CYGWIN_) || defined(_SQUID_MSWIN_)
+#if !_SQUID_WINDOWS_
+/* NON Windows Platform !!! */
+#error NON WINDOWS PLATFORM
+#endif
 
 #include "valid.h"
 
@@ -174,9 +177,3 @@ main(int argc, char **argv)
     }
     return 0;
 }
-
-#else  /* NON Windows Platform !!! */
-
-#error NON WINDOWS PLATFORM
-
-#endif
@@ -30,9 +30,12 @@
 #include "util.h"
 
 /* Check if we try to compile on a Windows Platform */
-#if defined(_SQUID_CYGWIN_) || defined(_SQUID_MSWIN_)
+#if !_SQUID_WINDOWS_
+/* NON Windows Platform !!! */
+#error NON WINDOWS PLATFORM
+#endif
 
-#if defined(_SQUID_CYGWIN_)
+#if _SQUID_CYGWIN_
 #include <wchar.h>
 #endif
 #include "valid.h"
@@ -175,8 +178,3 @@ Valid_User(char *UserName, char *Password, char *Group)
     }
     return result;
 }
-#else  /* NON Windows Platform !!! */
-
-#error NON WINDOWS PLATFORM
-
-#endif
@@ -28,7 +28,7 @@
 #ifndef _VALID_H_
 #define _VALID_H_
 
-#ifdef _SQUID_CYGWIN_
+#if _SQUID_CYGWIN_
 #include <windows.h>
 #endif
 #include <lm.h>
@@ -61,7 +61,7 @@
 #include "helpers/defines.h"
 #include "include/util.h"
 
-#ifdef _SQUID_CYGWIN_
+#if _SQUID_CYGWIN_
 #include <wchar.h>
 int _wcsicmp(const wchar_t *, const wchar_t *);
 #endif
@@ -72,7 +72,7 @@
 #include "include/util.h"
 
 
-#ifdef _SQUID_CYGWIN_
+#if _SQUID_CYGWIN_
 #include <wchar.h>
 int _wcsicmp(const wchar_t *, const wchar_t *);
 #endif
@@ -56,14 +56,14 @@ rotate(const char *path, int rotate_count)
         i--;
         snprintf(from, MAXPATHLEN, "%s.%d", path, i - 1);
         snprintf(to, MAXPATHLEN, "%s.%d", path, i);
-#if defined(_SQUID_OS2_) || defined(_SQUID_WIN32_)
+#if _SQUID_OS2_ || _SQUID_WINDOWS_
         remove(to);
 #endif
         rename(from, to);
     }
     if (rotate_count > 0) {
         snprintf(to, MAXPATHLEN, "%s.%d", path, 0);
-#if defined(_SQUID_OS2_) || defined(_SQUID_WIN32_)
+#if _SQUID_OS2_ || _SQUID_WINDOWS_
         remove(to);
 #endif
         rename(path, to);
@@ -84,7 +84,7 @@
 #else
 /* no gcc, no debugging. varargs macros are a gcc extension */
 #define SEND2(X,Y) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
-#define SEND4(X,Y,Z,W) debug("sending '" X "' to squid\n",Y,Z); printf(X "\n",Y,Z);
+#define SEND4(X,Y,Z,W) debug("sending '" X "' to squid\n",Y,Z,W); printf(X "\n",Y,Z,W);
 #endif
 
 const char *authenticate_ntlm_domain = "WORKGROUP";
@@ -42,7 +42,7 @@
 
 /* represents [start, end) */
 
-template <class C>
+template <class C, class S = size_t>
 class Range
 {
 
@@ -52,35 +52,35 @@ class Range
     C start;
     C end;
     Range intersection (Range const &) const;
-    size_t size() const;
+    S size() const;
 };
 
-template <class C>
-std::ostream& operator << (std::ostream &os, Range<C> const &aRange)
+template <class C, class S>
+std::ostream& operator << (std::ostream &os, Range<C, S> const &aRange)
 {
     os << "[" << aRange.start << "," << aRange.end << ")";
     return os;
 }
 
-template<class C>
-Range<C>::Range () : start(), end() {}
+template<class C, class S>
+Range<C, S>::Range () : start(), end() {}
 
-template<class C>
-Range<C>::Range (C start_, C end_) : start(start_), end(end_) {}
+template<class C, class S>
+Range<C, S>::Range (C start_, C end_) : start(start_), end(end_) {}
 
-template<class C>
-Range<C>
-Range<C>::intersection (Range const &rhs) const
+template<class C, class S>
+Range<C, S>
+Range<C, S>::intersection (Range const &rhs) const
 {
-    Range<C> result (max(start, rhs.start), min(end, rhs.end));
+    Range<C, S> result (max(start, rhs.start), min(end, rhs.end));
     return result;
 }
 
-template<class C>
-size_t
-Range<C>::size() const
+template<class C, class S>
+S
+Range<C, S>::size() const
 {
-    return end > start ? end - start : 0;
+    return (S) (end > start ? end - start : 0);
 }
 
 #endif /* SQUID_RANGE_H */
@@ -33,7 +33,7 @@
 #ifndef _INC_SQUID_WINDOWS_H
 #define _INC_SQUID_WINDOWS_H
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 
 #ifndef ACL
 #define ACL WindowsACL
@@ -45,6 +45,5 @@
 #undef _MSWIN_ACL_WAS_NOT_DEFINED
 #endif
 
-#endif /* _SQUID_WIN32_ */
-
+#endif /* _SQUID_WINDOWS_ */
 #endif /* _INC_SQUID_WINDOWS_H */
@@ -34,13 +34,13 @@
 #ifndef _LIBSSPWIN32_H_
 #define _LIBSSPWIN32_H_
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 
 #define SECURITY_WIN32
 #define NTLM_PACKAGE_NAME "NTLM"
 #define NEGOTIATE_PACKAGE_NAME "Negotiate"
 
-#ifdef _SQUID_CYGWIN_
+#if _SQUID_CYGWIN_
 #include <wchar.h>
 #define _T(x) TEXT(x)
 #else
@@ -77,6 +77,5 @@ const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
 extern BOOL Use_Unicode;
 extern BOOL NTLM_LocalCall;
 
-#endif /* _SQUID_WIN32_ */
-
+#endif /* _SQUID_WINDOWS_ */
 #endif /* LIBSSPWIN32_H_ */
@@ -430,12 +430,15 @@ MemImplementingAllocator::~MemImplementingAllocator()
 {
     MemImplementingAllocator *find_pool, *prev_pool;
 
-    assert(MemPools::GetInstance().pools != NULL && "Called MemImplementingAllocator::~MemImplementingAllocator, but no pool exists!");
+    /* Abort if the associated pool doesn't exist */
+    assert(MemPools::GetInstance().pools != NULL );
 
     /* Pool clean, remove it from List and free */
     for (find_pool = MemPools::GetInstance().pools, prev_pool = NULL; (find_pool && this != find_pool); find_pool = find_pool->next)
         prev_pool = find_pool;
-    assert(find_pool != NULL && "pool to destroy not found");
+
+    /* make sure that we found the pool to destroy */
+    assert(find_pool != NULL);
 
     if (prev_pool)
         prev_pool->next = next;
@@ -321,7 +321,7 @@ MemPoolChunked::~MemPoolChunked()
 
     flushMetersFull();
     clean(0);
-    assert(meter.inuse.level == 0 && "While trying to destroy pool");
+    assert(meter.inuse.level == 0);
 
     chunk = Chunks;
     while ( (fchunk = chunk) != NULL) {
@@ -120,7 +120,7 @@ MemPoolMalloc::MemPoolMalloc(char const *aLabel, size_t aSize) : MemImplementing
 
 MemPoolMalloc::~MemPoolMalloc()
 {
-    assert(meter.inuse.level == 0 && "While trying to destroy pool");
+    assert(meter.inuse.level == 0);
     clean(0);
 }
 
@@ -209,22 +209,16 @@ parse_rfc1123(const char *str)
     t = mktime(tm);
     if (t != -1) {
         time_t dst = 0;
-#if defined (_TIMEZONE)
-#elif defined (_timezone)
-#elif defined(_SQUID_AIX_)
-#elif defined(_SQUID_CYGWIN_)
-#elif defined(_SQUID_MSWIN_)
-#elif defined(_SQUID_SGI_)
-#else
-    extern long timezone;
+#if !(defined(_TIMEZONE) || defined(_timezone) || _SQUID_AIX_ || _SQUID_WINDOWS_ || _SQUID_SGI_)
+        extern long timezone;
 #endif
         /*
          * The following assumes a fixed DST offset of 1 hour,
          * which is probably wrong.
          */
         if (tm->tm_isdst > 0)
             dst = -3600;
-#if defined ( _timezone) || defined(_SQUID_WIN32_)
+#if defined(_timezone) || _SQUID_WINDOWS_
         t -= (_timezone + dst);
 #else
     t -= (timezone + dst);
@@ -38,7 +38,6 @@
 
 #include "smblib/smblib-priv.h"
 #define uchar unsigned char
-extern int DEBUGLEVEL;
 
 #include "rfcnb/byteorder.h"
 
@@ -48,11 +48,13 @@ int SMB_Types[] = {SMB_P_Core,
                    -1
                   };
 
+#if UNDEFINED
 char *SMB_DOSTimToStr(int DOS_time);
 char *SMB_AtrToStr(int attribs, BOOL verbose);
 int SMB_Get_Tree_MBS(SMB_Tree_Handle tree);
 int SMB_Get_Max_Buf_Siz(SMB_Handle_Type Con_Handle);
 int SMB_Get_Protocol_IDX(SMB_Handle_Type Con_Handle);
+#endif /* UNDEFINED */
 int SMB_Get_Protocol(SMB_Handle_Type Con_Handle);
 int SMB_Figure_Protocol(const char *dialects[], int prot_index);
 int SMB_TreeDisconnect(SMB_Tree_Handle Tree_Handle, BOOL discard);
@@ -80,6 +82,7 @@ void SMB_Print_Pkt(FILE fd, RFCNB_Pkt *pkt, BOOL command, int Offset, int Len)
 
 /* Convert a DOS Date_Time to a local host type date time for printing */
 
+#if UNDEFINED
 char *SMB_DOSTimToStr(int DOS_time)
 
 {
@@ -172,6 +175,7 @@ int SMB_Get_Protocol_IDX(SMB_Handle_Type Con_Handle)
     }
 
 }
+#endif /* UNDEFINED */
 
 /* Pick up the protocol from the connection structure                       */
 
@@ -202,13 +202,14 @@ ($$)
 my (@chained);
 
 my $in_options = 0;
-sub start_option($)
+sub start_option($$)
 {
-    my ($name) = @_;
+    my ($name, $type) = @_;
     if (!$in_options) {
 	print $index "<ul>\n";
 	$in_options = 1;
     }
+    return if $type eq "obsolete";
     print $index '    <li><a href="' . htmlescape(section_link($name)) . '" name="toc_' . htmlescape($name) . '">' . htmlescape($name) . "</a></li>\n";
 }
 sub end_options()
@@ -241,12 +242,12 @@ ($)
 		$data->{'name'} = $name;
 		$data->{'aliases'} = \@aliases;
 
-		start_option($name);
 		print "DEBUG: new option: $name\n" if $verbose;
 	} elsif ($_ =~ /^COMMENT: (.*)$/) {
 		$data->{"comment"} = $1;
 	} elsif ($_ =~ /^TYPE: (.*)$/) {
 		$data->{"type"} = $1;
+		start_option($data->{"name"}, $data->{"type"});
 	} elsif ($_ =~ /^DEFAULT: (.*)$/) {
 		if ($1 eq "none") {
 		    $data->{"default"} = "$1";
@@ -176,6 +176,7 @@ class CommAcceptCbPtrFun: public CallDialer,
 {
 public:
     typedef CommAcceptCbParams Params;
+    typedef RefCount<CommAcceptCbPtrFun> Pointer;
 
     CommAcceptCbPtrFun(IOACB *aHandler, const CommAcceptCbParams &aParams);
     void dial();
@@ -259,11 +260,18 @@ template <class Dialer>
 class CommCbFunPtrCallT: public AsyncCall
 {
 public:
+    typedef RefCount<CommCbFunPtrCallT<Dialer> > Pointer;
     typedef typename Dialer::Params Params;
 
     inline CommCbFunPtrCallT(int debugSection, int debugLevel,
                              const char *callName, const Dialer &aDialer);
 
+    inline CommCbFunPtrCallT(const CommCbFunPtrCallT &o) :
+            AsyncCall(o.debugSection, o.debugLevel, o.name),
+            dialer(o.dialer) {}
+
+    ~CommCbFunPtrCallT() {}
+
     virtual CallDialer* getDialer() { return &dialer; }
 
 public:
@@ -272,6 +280,9 @@ class CommCbFunPtrCallT: public AsyncCall
 protected:
     inline virtual bool canFire();
     inline virtual void fire();
+
+private:
+    CommCbFunPtrCallT & operator=(const CommCbFunPtrCallT &); // not defined. not permitted.
 };
 
 // Conveninece wrapper: It is often easier to call a templated function than
@@ -75,9 +75,8 @@ ConfigParser::strtokFile(void)
                     return (NULL);
                 }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
                 setmode(fileno(wordFile), O_TEXT);
-
 #endif
 
                 fromFile = 1;
@@ -100,7 +100,7 @@ class Debug
 
 extern FILE *debug_log;
 
-const size_t BuildPrefixInit();
+size_t BuildPrefixInit();
 const char * SkipBuildPrefix(const char* path);
 
 /* Debug stream */
@@ -86,7 +86,7 @@ void
 AIODiskFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
 {
     /* Simulate async calls */
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     fd = aio_open(path.termedBuf(), flags);
 #else
     fd = file_open(path.termedBuf() , flags);
@@ -232,11 +232,9 @@ void
 AIODiskFile::close ()
 {
     assert (!closed);
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     aio_close(fd);
 #else
-
     file_close(fd);
 #endif
 
@@ -37,7 +37,7 @@
 #include "comm.h"
 #include "aio_win32.h"
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 VOID CALLBACK IoCompletionRoutine(DWORD dwErrorCode,
                                   DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
 {
@@ -351,4 +351,4 @@ ssize_t aio_return64(struct aiocb64 * aiocbp)
 {
     return aiocbp->aio_sigevent.sigev_signo;
 }
-#endif /* _SQUID_WIN32_ */
+#endif /* _SQUID_WINDOWS_ */
@@ -36,7 +36,7 @@
 
 #if USE_DISKIO_AIO
 
-#ifdef _SQUID_CYGWIN_
+#if _SQUID_CYGWIN_
 #include "squid_windows.h"
 #endif
 
@@ -3,7 +3,7 @@
 
 #if USE_DISKIO_AIO
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 #include "aio_win32.h"
 #else
 #if HAVE_AIO_H
@@ -23,7 +23,7 @@ HelperChildConfig::operator =(const HelperChildConfig &rhs)
     return *this;
 }
 
-const int
+int
 HelperChildConfig::needNew() const
 {
     /* during the startup and reconfigure use our special amount... */
@@ -21,7 +21,7 @@ class HelperChildConfig
      * \retval N < 0   Error. No more helpers may be started.
      * \retval N       N more helpers may be started immediately.
      */
-    const int needNew() const;
+    int needNew() const;
     void parseConfig();
 
     /* values from squid.conf */
@@ -48,7 +48,7 @@ class HttpHdrRangeSpec
 
 public:
     MEMPROXY_CLASS(HttpHdrRangeSpec);
-    typedef Range<int64_t> HttpRange;
+    typedef Range<int64_t, uint64_t> HttpRange;
     static int64_t const UnknownPosition;
 
     HttpHdrRangeSpec();
@@ -326,21 +326,6 @@ HttpMsg::persistent() const
          */
         return !httpHeaderHasConnDir(&header, "close");
     } else {
-        /*
-         * Persistent connections in Netscape 3.x are allegedly broken,
-         * return false if it is a browser connection.  If there is a
-         * VIA header, then we assume this is NOT a browser connection.
-         */
-        const char *agent = header.getStr(HDR_USER_AGENT);
-
-        if (agent && !header.has(HDR_VIA)) {
-            if (!strncasecmp(agent, "Mozilla/3.", 10))
-                return 0;
-
-            if (!strncasecmp(agent, "Netscape/3.", 11))
-                return 0;
-        }
-
         /* for old versions of HTTP: persistent if has "keep-alive" */
         return httpHeaderHasConnDir(&header, "keep-alive");
     }
@@ -502,7 +502,7 @@ void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const
 }
 
 /*
- * Indicate whether or not we would usually expect an entity-body
+ * Indicate whether or not we would expect an entity-body
  * along with this request
  */
 bool
@@ -511,28 +511,18 @@ HttpRequest::expectingBody(const HttpRequestMethod& unused, int64_t& theSize) co
     bool expectBody = false;
 
     /*
-     * GET and HEAD don't usually have bodies, but we should be prepared
-     * to accept one if the request_entities directive is set
+     * Note: Checks for message validity is in clientIsContentLengthValid().
+     * this just checks if a entity-body is expected based on HTTP message syntax
      */
-
-    if (method == METHOD_GET || method == METHOD_HEAD)
-        expectBody = Config.onoff.request_entities ? true : false;
-    else if (method == METHOD_PUT || method == METHOD_POST)
-        expectBody = true;
-    else if (header.chunked())
+    if (header.chunked()) {
         expectBody = true;
-    else if (content_length >= 0)
+        theSize = -1;
+    } else if (content_length >= 0) {
         expectBody = true;
-    else
+        theSize = content_length;
+    } else {
         expectBody = false;
-
-    if (expectBody) {
-        if (header.chunked())
-            theSize = -1;
-        else if (content_length >= 0)
-            theSize = content_length;
-        else
-            theSize = -1;
+        // theSize undefined
     }
 
     return expectBody;
@@ -207,10 +207,12 @@ struct StoreClientStats : public unary_function<store_client, void> {
 };
 
 void
-MemObject::stat (MemBuf * mb) const
+MemObject::stat(MemBuf * mb) const
 {
     mb->Printf("\t%s %s\n",
                RequestMethodStr(method), log_url);
+    if (vary_headers)
+        mb->Printf("\tvary_headers: %s\n", vary_headers);
     mb->Printf("\tinmem_lo: %"PRId64"\n", inmem_lo);
     mb->Printf("\tinmem_hi: %"PRId64"\n", data_hdr.endOffset());
     mb->Printf("\tswapout: %"PRId64" bytes queued\n",
@@ -100,13 +100,11 @@ xprof_comp(xprof_stats_node ** ii, xprof_stats_node ** jj)
 static void
 xprof_sorthist(TimersArray * xprof_list)
 {
-    int i;
-
-    for (i = 0; i < XPROF_LAST; i++) {
+    for (int i = 0; i < XPROF_LAST; i++) {
         sortlist[i] = xprof_list[i];
     }
 
-    qsort(&sortlist[XPROF_hash_lookup], XPROF_LAST - XPROF_hash_lookup, sizeof(xprof_stats_node *), (QS *) xprof_comp);
+    qsort(&sortlist[XPROF_PROF_UNACCOUNTED+1], XPROF_LAST - XPROF_PROF_UNACCOUNTED+1, sizeof(xprof_stats_node *), (QS *) xprof_comp);
 }
 
 static double time_frame;
@@ -3,23 +3,28 @@
  */
 
 #include "squid.h"
+#include "comm.h"
 #include "ProtoPort.h"
 #if HAVE_LIMITS
 #include <limits>
 #endif
 
-http_port_list::http_port_list(const char *aProtocol)
+http_port_list::http_port_list(const char *aProtocol) :
+        listenFd(-1)
 #if USE_SSL
-        :
-        http(*this), dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
+        , http(*this)
+        , dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
 #endif
 {
     protocol = xstrdup(aProtocol);
 }
 
 http_port_list::~http_port_list()
 {
-    delete listener;
+    if (listenFd >= 0) {
+        comm_close(listenFd);
+        listenFd = -1;
+    }
 
     safe_free(name);
     safe_free(defaultsite);
@@ -4,9 +4,7 @@
 #ifndef SQUID_PROTO_PORT_H
 #define SQUID_PROTO_PORT_H
 
-//#include "typedefs.h"
 #include "cbdata.h"
-#include "comm/ListenStateData.h"
 
 #if USE_SSL
 #include "ssl/gadgets.h"
@@ -43,11 +41,11 @@ struct http_port_list {
     } tcp_keepalive;
 
     /**
-     * The FD listening socket handler.
-     * If not NULL we are actively listening for client requests.
-     * delete to close the socket.
+     * The FD listening socket.
+     * If >= 0 we are actively listening for client requests.
+     * use comm_close(listenFd) to stop.
      */
-    Comm::ListenStateData *listener;
+    int listenFd;
 
 #if USE_SSL
     // XXX: temporary hack to ease move of SSL options to http_port
@@ -174,7 +174,8 @@ String::set(char const *loc, char const ch)
 void
 String::cut(String::size_type newLength)
 {
-    if (newLength < 0 || newLength > len_) return;
+    // size_type is size_t, unsigned. No need to check for newLength <0
+    if (newLength > len_) return;
 
     len_ = newLength;
 
@@ -35,7 +35,7 @@
  */
 
 #include "config.h"
-#ifdef _SQUID_CYGWIN_
+#if _SQUID_CYGWIN_
 #include <squid_windows.h>
 #endif
 #include "squid.h"
@@ -84,6 +84,10 @@ class AsyncCall: public RefCountable
 
 private:
     const char *isCanceled; // set to the cancelation reason by cancel()
+
+    // not implemented to prevent nil calls from being passed around and unknowingly scheduled, for now.
+    AsyncCall();
+    AsyncCall(const AsyncCall &);
 };
 
 inline
@@ -122,6 +126,12 @@ class AsyncCallT: public AsyncCall
                const Dialer &aDialer): AsyncCall(aDebugSection, aDebugLevel, aName),
             dialer(aDialer) {}
 
+    AsyncCallT(const AsyncCallT<Dialer> &o):
+            AsyncCall(o.debugSection, o.debugLevel, o.name),
+            dialer(o.dialer) {}
+
+    ~AsyncCallT() {}
+
     CallDialer *getDialer() { return &dialer; }
 
 protected:
@@ -132,6 +142,9 @@ class AsyncCallT: public AsyncCall
     virtual void fire() { dialer.dial(*this); }
 
     Dialer dialer;
+
+private:
+    AsyncCallT & operator=(const AsyncCallT &); // not defined. call assignments not permitted.
 };
 
 template <class Dialer>
@@ -42,7 +42,7 @@ class CallSubscription: public Subscription
 public:
     /// Must be passed an object. nil pointers are not permitted.
     explicit CallSubscription(const RefCount<Call_> &aCall) : call(aCall) { assert(aCall != NULL); }
-    virtual AsyncCall::Pointer callback() const { return new Call_(call); }
+    virtual AsyncCall::Pointer callback() const { return new Call_(*call); }
 
 private:
     const RefCount<Call_> call; ///< gets copied to create callback calls
@@ -419,10 +419,8 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
     if (fp == NULL)
         fatalf("Unable to open configuration file: %s: %s", file_name, xstrerror());
 
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
-
 #endif
 
     SetConfigFilename(file_name, bool(is_pipe));
@@ -146,9 +146,8 @@ cacheIndexAddLog(CacheIndex * idx, const char *fname)
         return 0;
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(file), O_BINARY);
-
 #endif
 
     scanned_count = cacheIndexScan(idx, fname, file);
@@ -770,7 +770,9 @@ DOC_START
 
 	acl aclname maxconn number
 	  # This will be matched when the client's IP address has
-	  # more than <number> HTTP connections established. [fast]
+	  # more than <number> TCP connections established. [fast]
+	  # NOTE: This only measures direct TCP links so X-Forwarded-For
+	  # indirect clients are not counted.
 
 	acl aclname max_user_ip [-s] number
 	  # This will be matched when the user attempts to log in from more
@@ -943,6 +945,9 @@ DOC_START
 	Controls whether the indirect client address
 	(see follow_x_forwarded_for) is used instead of the
 	direct client address in acl matching.
+
+	NOTE: maxconn ACL considers direct TCP links and indirect
+	      clients will always have zero. So no match.
 DOC_END
 
 NAME: delay_pool_uses_indirect_client
@@ -1765,14 +1770,18 @@ DOC_START
 	an additional ACL needs to be used which ensures the IPv6-bound traffic
 	is never forced or permitted out the IPv4 interface.
 
+	# IPv6 destination test along with a dummy access control to perofrm the required DNS
+	# This MUST be place before any ALLOW rules.
 	acl to_ipv6 dst ipv6
-	tcp_outgoing_address 2002::c001 good_service_net to_ipv6
+	http_access deny ipv6 !all
+
+	tcp_outgoing_address 2001:db8::c001 good_service_net to_ipv6
 	tcp_outgoing_address 10.1.0.2 good_service_net !to_ipv6
 
-	tcp_outgoing_address 2002::beef normal_service_net to_ipv6
+	tcp_outgoing_address 2001:db8::beef normal_service_net to_ipv6
 	tcp_outgoing_address 10.1.0.1 normal_service_net !to_ipv6
 
-	tcp_outgoing_address 2002::1 to_ipv6
+	tcp_outgoing_address 2001:db8::1 to_ipv6
 	tcp_outgoing_address 10.1.0.3 !to_ipv6
 
 	WARNING:
@@ -239,7 +239,7 @@ main(int argc, char *argv[])
         exit(1);
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
 
 #endif
@@ -465,9 +465,8 @@ main(int argc, char *argv[])
         exit(1);
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
-
 #endif
 
     fprintf(fp,
@@ -501,9 +500,8 @@ main(int argc, char *argv[])
         exit(1);
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
-
 #endif
 
     gen_conf(entries, fp, 1);
@@ -514,7 +512,7 @@ main(int argc, char *argv[])
         perror(conf_filename_short);
         exit(1);
     }
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
 #endif
     gen_conf(entries, fp, 0);
@@ -96,9 +96,10 @@
 #include "ClientRequestContext.h"
 #include "clientStream.h"
 #include "comm.h"
-#include "comm/Write.h"
-#include "comm/ListenStateData.h"
+#include "CommCalls.h"
 #include "comm/Loops.h"
+#include "comm/Write.h"
+#include "comm/TcpAcceptor.h"
 #include "ConnectionDetail.h"
 #include "eui/Config.h"
 #include "fde.h"
@@ -108,6 +109,7 @@
 #include "ident/Config.h"
 #include "ident/Ident.h"
 #include "ip/Intercept.h"
+#include "ipc/FdNotes.h"
 #include "ipc/StartListening.h"
 #include "MemBuf.h"
 #include "MemObject.h"
@@ -134,34 +136,33 @@
 #define comm_close comm_lingering_close
 #endif
 
-/// dials clientHttpConnectionOpened or clientHttpsConnectionOpened call
+/// dials clientListenerConnectionOpened call
 class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
 {
 public:
-    typedef void (*Handler)(int fd, int errNo, http_port_list *portCfg);
-    ListeningStartedDialer(Handler aHandler, http_port_list *aPortCfg):
-            handler(aHandler), portCfg(aPortCfg) {}
+    typedef void (*Handler)(int fd, int flags, int errNo, http_port_list *portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
+    ListeningStartedDialer(Handler aHandler, int openFlags, http_port_list *aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
+            handler(aHandler), portCfg(aPortCfg), portTypeNote(note), commOpenListenerFlags(openFlags), sub(aSub) {}
 
     virtual void print(std::ostream &os) const {
         startPrint(os) <<
         ", port=" << (void*)portCfg << ')';
     }
 
     virtual bool canDial(AsyncCall &) const { return true; }
-    virtual void dial(AsyncCall &) { (handler)(fd, errNo, portCfg); }
+    virtual void dial(AsyncCall &) { (handler)(fd, commOpenListenerFlags, errNo, portCfg, portTypeNote, sub); }
 
 public:
     Handler handler;
 
 private:
-    http_port_list *portCfg; ///< from Config.Sockaddr.http
+    http_port_list *portCfg;   ///< from Config.Sockaddr.http
+    Ipc::FdNoteId portTypeNote;    ///< Type of IPC socket being opened
+    int commOpenListenerFlags; ///< flags used by comm_open_listener
+    Subscription::Pointer sub; ///< The handler to be subscribed for this connetion listener
 };
 
-
-static void clientHttpConnectionOpened(int fd, int errNo, http_port_list *s);
-#if USE_SSL
-static void clientHttpsConnectionOpened(int fd, int errNo, http_port_list *s);
-#endif
+static void clientListenerConnectionOpened(int fd, int flags, int errNo, http_port_list *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
 
 /* our socket-related context */
 
@@ -825,12 +826,6 @@ clientIsContentLengthValid(HttpRequest * r)
 {
     switch (r->method.id()) {
 
-    case METHOD_PUT:
-
-    case METHOD_POST:
-        /* PUT/POST requires a request entity */
-        return (r->content_length >= 0);
-
     case METHOD_GET:
 
     case METHOD_HEAD:
@@ -1060,7 +1055,7 @@ ClientSocketContext::packRange(StoreIOBuffer const &source, MemBuf * mb)
              * intersection of "have" and "need" ranges must not be empty
              */
             assert(http->out.offset < i->currentSpec()->offset + i->currentSpec()->length);
-            assert(http->out.offset + available.size() > (uint64_t)i->currentSpec()->offset);
+            assert(http->out.offset + (int64_t)available.size() > i->currentSpec()->offset);
 
             /*
              * put boundary and headers at the beginning of a range in a
@@ -3121,14 +3116,14 @@ connStateCreate(const Ip::Address &peer, const Ip::Address &me, int fd, http_por
 
 /** Handle a new connection on HTTP socket. */
 void
-httpAccept(int sock, int newfd, ConnectionDetail *details,
-           comm_err_t flag, int xerrno, void *data)
+httpAccept(int, int newfd, ConnectionDetail *details, comm_err_t flag, int xerrno, void *data)
 {
     http_port_list *s = (http_port_list *)data;
     ConnStateData *connState = NULL;
 
     if (flag != COMM_OK) {
-        debugs(33, 1, "httpAccept: FD " << sock << ": accept failure: " << xstrerr(xerrno));
+        // Its possible the call was still queued when the client disconnected
+        debugs(33, 2, "httpAccept: FD " << s->listenFd << ": accept failure: " << xstrerr(xerrno));
         return;
     }
 
@@ -3367,15 +3362,14 @@ clientNegotiateSSL(int fd, void *data)
 
 /** handle a new HTTPS connection */
 static void
-httpsAccept(int sock, int newfd, ConnectionDetail *details,
-            comm_err_t flag, int xerrno, void *data)
+httpsAccept(int, int newfd, ConnectionDetail *details, comm_err_t flag, int xerrno, void *data)
 {
     https_port_list *s = (https_port_list *)data;
     SSL_CTX *sslContext = s->staticSslContext.get();
 
     if (flag != COMM_OK) {
-        errno = xerrno;
-        debugs(33, 1, "httpsAccept: FD " << sock << ": accept failure: " << xstrerr(xerrno));
+        // Its possible the call was still queued when the client disconnected
+        debugs(33, 2, "httpsAccept: FD " << s->listenFd << ": accept failure: " << xstrerr(xerrno));
         return;
     }
 
@@ -3558,15 +3552,15 @@ ConnStateData::switchToHttps(const char *host)
 
 /// check FD after clientHttp[s]ConnectionOpened, adjust HttpSockets as needed
 static bool
-OpenedHttpSocket(int fd, const char *msgIfFail)
+OpenedHttpSocket(int fd, const Ipc::FdNoteId portType)
 {
     if (fd < 0) {
         Must(NHttpSockets > 0); // we tried to open some
         --NHttpSockets; // there will be fewer sockets than planned
         Must(HttpSockets[NHttpSockets] < 0); // no extra fds received
 
         if (!NHttpSockets) // we could not open any listen sockets at all
-            fatal(msgIfFail);
+            fatalf("Unable to open %s",FdNote(portType));
 
         return false;
     }
@@ -3622,13 +3616,16 @@ clientHttpConnectionsOpen(void)
         const int openFlags = COMM_NONBLOCKING |
                               (s->spoof_client_ip ? COMM_TRANSPARENT : 0);
 
-        AsyncCall::Pointer callback = asyncCall(33,2,
-                                                "clientHttpConnectionOpened",
-                                                ListeningStartedDialer(&clientHttpConnectionOpened, s));
-        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->s, openFlags,
-                            Ipc::fdnHttpSocket, callback);
+        // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
+        typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
+        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpAccept", CommAcceptCbPtrFun(httpAccept, s));
+        Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
 
-        HttpSockets[NHttpSockets++] = -1; // set in clientHttpConnectionOpened
+        AsyncCall::Pointer listenCall = asyncCall(33,2, "clientListenerConnectionOpened",
+                                        ListeningStartedDialer(&clientListenerConnectionOpened, openFlags, s, Ipc::fdnHttpSocket, sub));
+        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->s, openFlags, Ipc::fdnHttpSocket, listenCall);
+
+        HttpSockets[NHttpSockets++] = -1; // set in clientListenerConnectionOpened
     }
 
 #if USE_SSL
@@ -3641,27 +3638,27 @@ clientHttpConnectionsOpen(void)
 
 /// process clientHttpConnectionsOpen result
 static void
-clientHttpConnectionOpened(int fd, int, http_port_list *s)
+clientListenerConnectionOpened(int fd, int flags, int errNo, http_port_list *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
 {
-    if (!OpenedHttpSocket(fd, "Cannot open HTTP Port"))
+    s->listenFd = fd;
+    if (!OpenedHttpSocket(s->listenFd, portTypeNote))
         return;
 
     Must(s);
+    Must(s->listenFd >= 0);
 
-    AsyncCall::Pointer call = commCbCall(5,5, "SomeCommAcceptHandler(httpAccept)",
-                                         CommAcceptCbPtrFun(httpAccept, s));
-
-    s->listener = new Comm::ListenStateData(fd, call, true);
+    // TCP: setup a job to handle accept() with subscribed handler
+    AsyncJob::Start(new Comm::TcpAcceptor(s->listenFd, s->s, flags, FdNote(portTypeNote), sub));
 
-    debugs(1, 1, "Accepting " <<
+    debugs(1, 1, "Accepting" <<
            (s->intercepted ? " intercepted" : "") <<
            (s->spoof_client_ip ? " spoofing" : "") <<
            (s->sslBump ? " bumpy" : "") <<
            (s->accel ? " accelerated" : "")
-           << " HTTP connections at " << s->s
-           << ", FD " << fd << "." );
+           << FdNote(portTypeNote) << " connections at "
+           << " FD " << s->listenFd << " on " << s->s);
 
-    Must(AddOpenedHttpSocket(fd)); // otherwise, we have received a fd we did not ask for
+    Must(AddOpenedHttpSocket(s->listenFd)); // otherwise, we have received a fd we did not ask for
 }
 
 #if USE_SSL
@@ -3683,35 +3680,23 @@ clientHttpsConnectionsOpen(void)
             continue;
         }
 
-        AsyncCall::Pointer call = asyncCall(33, 2, "clientHttpsConnectionOpened",
-                                            ListeningStartedDialer(&clientHttpsConnectionOpened, &s->http));
-
-        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->http.s, COMM_NONBLOCKING,
-                            Ipc::fdnHttpsSocket, call);
-
-        HttpSockets[NHttpSockets++] = -1;
-    }
-}
-
-/// process clientHttpsConnectionsOpen result
-static void
-clientHttpsConnectionOpened(int fd, int, http_port_list *s)
-{
-    if (!OpenedHttpSocket(fd, "Cannot open HTTPS Port"))
-        return;
-
-    Must(s);
+        const int openFlags = COMM_NONBLOCKING |
+                              (s->spoof_client_ip ? COMM_TRANSPARENT : 0);
 
-    AsyncCall::Pointer call = commCbCall(5,5, "SomeCommAcceptHandler(httpsAccept)",
-                                         CommAcceptCbPtrFun(httpsAccept, s));
+        // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
+        typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
+        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpsAccept", CommAcceptCbPtrFun(httpsAccept, s));
+        Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
 
-    s->listener = new Comm::ListenStateData(fd, call, true);
+        AsyncCall::Pointer listenCall = asyncCall(33, 2, "clientListenerConnectionOpened",
+                                        ListeningStartedDialer(&clientListenerConnectionOpened, openFlags,
+                                                               &s->http, Ipc::fdnHttpsSocket, sub));
 
-    debugs(1, 1, "Accepting HTTPS connections at " << s->s << ", FD " << fd << ".");
+        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->s, openFlags, Ipc::fdnHttpsSocket, listenCall);
 
-    Must(AddOpenedHttpSocket(fd)); // otherwise, we have received a fd we did not ask for
+        HttpSockets[NHttpSockets++] = -1;
+    }
 }
-
 #endif
 
 void
@@ -3730,19 +3715,19 @@ void
 clientHttpConnectionsClose(void)
 {
     for (http_port_list *s = Config.Sockaddr.http; s; s = s->next) {
-        if (s->listener) {
-            debugs(1, 1, "FD " << s->listener->fd << " Closing HTTP connection");
-            delete s->listener;
-            s->listener = NULL;
+        if (s->listenFd >= 0) {
+            debugs(1, 1, "FD " << s->listenFd << " Closing HTTP connection");
+            comm_close(s->listenFd);
+            s->listenFd = -1;
         }
     }
 
 #if USE_SSL
     for (http_port_list *s = Config.Sockaddr.https; s; s = s->next) {
-        if (s->listener) {
-            debugs(1, 1, "FD " << s->listener->fd << " Closing HTTPS connection");
-            delete s->listener;
-            s->listener = NULL;
+        if (s->listenFd >= 0) {
+            debugs(1, 1, "FD " << s->listenFd << " Closing HTTPS connection");
+            comm_close(s->listenFd);
+            s->listenFd = -1;
         }
     }
 #endif
@@ -50,9 +50,6 @@ class clientStreamNode;
 class ChunkedCodingParser;
 class HttpParser;
 
-template <class T>
-class Range;
-
 class ClientSocketContext : public RefCountable
 {
 
@@ -40,9 +40,9 @@
 #include "comm/AcceptLimiter.h"
 #include "comm/comm_internal.h"
 #include "comm/IoCallback.h"
-#include "comm/Write.h"
-#include "comm/ListenStateData.h"
 #include "comm/Loops.h"
+#include "comm/Write.h"
+#include "comm/TcpAcceptor.h"
 #include "CommIO.h"
 #include "CommRead.h"
 #include "ConnectionDetail.h"
@@ -62,7 +62,7 @@
 #endif
 
 #include "cbdata.h"
-#if defined(_SQUID_CYGWIN_)
+#if _SQUID_CYGWIN_
 #include <sys/ioctl.h>
 #endif
 #ifdef HAVE_NETINET_TCP_H
@@ -144,7 +144,7 @@ fd_debug_t *fdd_table = NULL;
 bool
 isOpen(const int fd)
 {
-    return fd_table[fd].flags.open != 0;
+    return fd >= 0 && fd_table[fd].flags.open != 0;
 }
 
 /**
@@ -1661,12 +1661,10 @@ commSetNonBlocking(int fd)
     int flags;
     int dummy = 0;
 #endif
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     int nonblocking = TRUE;
 
-#ifdef _SQUID_CYGWIN_
-
+#if _SQUID_CYGWIN_
     if (fd_table[fd].type != FD_PIPE) {
 #endif
 
@@ -1675,8 +1673,7 @@ commSetNonBlocking(int fd)
             return COMM_ERROR;
         }
 
-#ifdef _SQUID_CYGWIN_
-
+#if _SQUID_CYGWIN_
     } else {
 #endif
 #endif
@@ -1693,10 +1690,8 @@ commSetNonBlocking(int fd)
         }
 
 #endif
-#ifdef _SQUID_CYGWIN_
-
+#if _SQUID_CYGWIN_
     }
-
 #endif
     fd_table[fd].flags.nonblocking = 1;
 
@@ -1,6 +1,6 @@
 #include "config.h"
 #include "comm/AcceptLimiter.h"
-#include "comm/ListenStateData.h"
+#include "comm/TcpAcceptor.h"
 #include "fde.h"
 
 Comm::AcceptLimiter Comm::AcceptLimiter::Instance_;
@@ -11,22 +11,41 @@ Comm::AcceptLimiter &Comm::AcceptLimiter::Instance()
 }
 
 void
-Comm::AcceptLimiter::defer(Comm::ListenStateData *afd)
+Comm::AcceptLimiter::defer(Comm::TcpAcceptor *afd)
 {
     afd->isLimited++;
     debugs(5, 5, HERE << "FD " << afd->fd << " x" << afd->isLimited);
     deferred.push_back(afd);
 }
 
+void
+Comm::AcceptLimiter::removeDead(const Comm::TcpAcceptor *afd)
+{
+    for (unsigned int i = 0; i < deferred.size() && afd->isLimited > 0; i++) {
+        if (deferred[i] == afd) {
+            deferred[i]->isLimited--;
+            deferred[i] = NULL; // fast. kick() will skip empty entries later.
+            debugs(5, 5, HERE << "FD " << afd->fd << " x" << afd->isLimited);
+        }
+    }
+}
+
 void
 Comm::AcceptLimiter::kick()
 {
+    // TODO: this could be optimized further with an iterator to search
+    //       looking for first non-NULL, followed by dumping the first N
+    //       with only one shift()/pop_front operation
+
     debugs(5, 5, HERE << " size=" << deferred.size());
-    if (deferred.size() > 0 && fdNFree() >= RESERVED_FD) {
-        debugs(5, 5, HERE << " doing one.");
+    while (deferred.size() > 0 && fdNFree() >= RESERVED_FD) {
         /* NP: shift() is equivalent to pop_front(). Giving us a FIFO queue. */
-        ListenStateData *temp = deferred.shift();
-        temp->isLimited--;
-        temp->acceptNext();
+        TcpAcceptor *temp = deferred.shift();
+        if (temp != NULL) {
+            debugs(5, 5, HERE << " doing one.");
+            temp->isLimited--;
+            temp->acceptNext();
+            break;
+        }
     }
 }
@@ -6,7 +6,7 @@
 namespace Comm
 {
 
-class ListenStateData;
+class TcpAcceptor;
 
 /**
  * FIFO Queue holding listener socket handlers which have been activated
@@ -25,7 +25,10 @@ class AcceptLimiter
     static AcceptLimiter &Instance();
 
     /** delay accepting a new client connection. */
-    void defer(Comm::ListenStateData *afd);
+    void defer(Comm::TcpAcceptor *afd);
+
+    /** remove all records of an acceptor. Only to be called by the ConnAcceptor::swanSong() */
+    void removeDead(const Comm::TcpAcceptor *afd);
 
     /** try to accept and begin processing any delayed client connections. */
     void kick();
@@ -34,7 +37,7 @@ class AcceptLimiter
     static AcceptLimiter Instance_;
 
     /** FIFO queue */
-    Vector<Comm::ListenStateData*> deferred;
+    Vector<Comm::TcpAcceptor*> deferred;
 };
 
 }; // namepace Comm
@@ -1,54 +0,0 @@
-#ifndef SQUID_LISTENERSTATEDATA_H
-#define SQUID_LISTENERSTATEDATA_H
-
-#include "base/AsyncCall.h"
-#include "comm.h"
-#if HAVE_MAP
-#include <map>
-#endif
-
-class ConnectionDetail;
-
-namespace Comm
-{
-
-class ListenStateData
-{
-
-public:
-    ListenStateData(int fd, AsyncCall::Pointer &call, bool accept_many);
-    ListenStateData(const ListenStateData &r); // not implemented.
-    ~ListenStateData();
-
-    void subscribe(AsyncCall::Pointer &call);
-    void acceptNext();
-    void notify(int newfd, comm_err_t flag, const ConnectionDetail &details);
-
-    int fd;
-
-    /// errno code of the last accept() or listen() action if one occurred.
-    int errcode;
-
-    /// whether this socket is delayed and on the AcceptLimiter queue.
-    int32_t isLimited;
-
-private:
-    /// Method to test if there are enough file escriptors to open a new client connection
-    /// if not the accept() will be postponed
-    static bool okToAccept();
-
-    /// Method callback for whenever an FD is ready to accept a client connection.
-    static void doAccept(int fd, void *data);
-
-    void acceptOne();
-    int oldAccept(ConnectionDetail &details);
-
-    AsyncCall::Pointer theCallback;
-    bool mayAcceptMore;
-
-    void setListen();
-};
-
-} // namespace Comm
-
-#endif /* SQUID_LISTENERSTATEDATA_H */
@@ -7,15 +7,15 @@ noinst_LTLIBRARIES = libcomm.la
 libcomm_la_SOURCES= \
 	AcceptLimiter.cc \
 	AcceptLimiter.h \
-	ListenStateData.cc \
-	ListenStateData.h \
 	Loops.h \
 	ModDevPoll.cc \
 	ModEpoll.cc \
 	ModKqueue.cc \
 	ModPoll.cc \
 	ModSelect.cc \
 	ModSelectWin32.cc \
+	TcpAcceptor.cc \
+	TcpAcceptor.h \
 	\
 	IoCallback.cc \
 	IoCallback.h \
@@ -240,7 +240,7 @@ Comm::ResetSelect(int fd)
  */
 
 comm_err_t
-Comm::Select(int msec)
+Comm::DoSelect(int msec)
 {
     int num, i;
 
@@ -33,16 +33,105 @@
  */
 
 #include "squid.h"
+#include "base/TextException.h"
 #include "CommCalls.h"
 #include "comm/AcceptLimiter.h"
 #include "comm/comm_internal.h"
-#include "comm/ListenStateData.h"
 #include "comm/Loops.h"
+#include "comm/TcpAcceptor.h"
 #include "ConnectionDetail.h"
 #include "fde.h"
 #include "protos.h"
 #include "SquidTime.h"
 
+namespace Comm
+{
+CBDATA_CLASS_INIT(TcpAcceptor);
+};
+
+Comm::TcpAcceptor::TcpAcceptor(const int listenFd, const Ip::Address &laddr, int flags,
+                               const char *note, const Subscription::Pointer &aSub) :
+        AsyncJob("Comm::TcpAcceptor"),
+        errcode(0),
+        fd(listenFd),
+        isLimited(0),
+        theCallSub(aSub),
+        local_addr(laddr)
+{}
+
+void
+Comm::TcpAcceptor::subscribe(const Subscription::Pointer &aSub)
+{
+    debugs(5, 5, HERE << status() << " AsyncCall Subscription: " << aSub);
+    unsubscribe("subscription change");
+    theCallSub = aSub;
+}
+
+void
+Comm::TcpAcceptor::unsubscribe(const char *reason)
+{
+    debugs(5, 5, HERE << status() << " AsyncCall Subscription " << theCallSub << " removed: " << reason);
+    theCallSub = NULL;
+}
+
+void
+Comm::TcpAcceptor::start()
+{
+    debugs(5, 5, HERE << status() << " AsyncCall Subscription: " << theCallSub);
+
+    Must(isOpen(fd));
+
+    setListen();
+
+    // if no error so far start accepting connections.
+    if (errcode == 0)
+        SetSelect(fd, COMM_SELECT_READ, doAccept, this, 0);
+}
+
+bool
+Comm::TcpAcceptor::doneAll() const
+{
+    // stop when FD is closed
+    if (!isOpen(fd)) {
+        return AsyncJob::doneAll();
+    }
+
+    // stop when handlers are gone
+    if (theCallSub == NULL) {
+        return AsyncJob::doneAll();
+    }
+
+    // open FD with handlers...keep accepting.
+    return false;
+}
+
+void
+Comm::TcpAcceptor::swanSong()
+{
+    debugs(5,5, HERE);
+    unsubscribe("swanSong");
+    fd = -1;
+    AcceptLimiter::Instance().removeDead(this);
+    AsyncJob::swanSong();
+}
+
+const char *
+Comm::TcpAcceptor::status() const
+{
+    static char ipbuf[MAX_IPSTRLEN] = {'\0'};
+    if (ipbuf[0] == '\0')
+        local_addr.ToHostname(ipbuf, MAX_IPSTRLEN);
+
+    static MemBuf buf;
+    buf.reset();
+    buf.Printf(" FD %d, %s",fd, ipbuf);
+
+    const char *jobStatus = AsyncJob::status();
+    buf.append(jobStatus, strlen(jobStatus));
+
+    return buf.content();
+}
+
 /**
  * New-style listen and accept routines
  *
@@ -51,11 +140,11 @@
  * accept()ed some time later.
  */
 void
-Comm::ListenStateData::setListen()
+Comm::TcpAcceptor::setListen()
 {
     errcode = 0; // reset local errno copy.
     if (listen(fd, Squid_MaxFD >> 2) < 0) {
-        debugs(50, 0, HERE << "listen(FD " << fd << ", " << (Squid_MaxFD >> 2) << "): " << xstrerror());
+        debugs(50, DBG_CRITICAL, "ERROR: listen(" << status() << ", " << (Squid_MaxFD >> 2) << "): " << xstrerror());
         errcode = errno;
         return;
     }
@@ -67,37 +156,19 @@ Comm::ListenStateData::setListen()
         debugs(5, DBG_IMPORTANT, "Installing accept filter '" << Config.accept_filter << "' on FD " << fd);
         xstrncpy(afa.af_name, Config.accept_filter, sizeof(afa.af_name));
         if (setsockopt(fd, SOL_SOCKET, SO_ACCEPTFILTER, &afa, sizeof(afa)) < 0)
-            debugs(5, DBG_CRITICAL, "SO_ACCEPTFILTER '" << Config.accept_filter << "': '" << xstrerror());
+            debugs(5, DBG_CRITICAL, "WARNING: SO_ACCEPTFILTER '" << Config.accept_filter << "': '" << xstrerror());
 #elif defined(TCP_DEFER_ACCEPT)
         int seconds = 30;
         if (strncmp(Config.accept_filter, "data=", 5) == 0)
             seconds = atoi(Config.accept_filter + 5);
         if (setsockopt(fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &seconds, sizeof(seconds)) < 0)
-            debugs(5, DBG_CRITICAL, "TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerror());
+            debugs(5, DBG_CRITICAL, "WARNING: TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerror());
 #else
-        debugs(5, DBG_CRITICAL, "accept_filter not supported on your OS");
+        debugs(5, DBG_CRITICAL, "WARNING: accept_filter not supported on your OS");
 #endif
     }
 }
 
-Comm::ListenStateData::ListenStateData(int aFd, AsyncCall::Pointer &call, bool accept_many) :
-        fd(aFd),
-        theCallback(call),
-        mayAcceptMore(accept_many)
-{
-    assert(aFd >= 0);
-    debugs(5, 5, HERE << "FD " << fd << " AsyncCall: " << call);
-    assert(isOpen(aFd));
-    setListen();
-    SetSelect(fd, COMM_SELECT_READ, doAccept, this, 0);
-}
-
-Comm::ListenStateData::~ListenStateData()
-{
-    comm_close(fd);
-    fd = -1;
-}
-
 /**
  * This private callback is called whenever a filedescriptor is ready
  * to dupe itself and fob off an accept()ed connection
@@ -108,23 +179,30 @@ Comm::ListenStateData::~ListenStateData()
  * done later when enough sockets become available.
  */
 void
-Comm::ListenStateData::doAccept(int fd, void *data)
+Comm::TcpAcceptor::doAccept(int fd, void *data)
 {
-    debugs(5, 2, HERE << "New connection on FD " << fd);
+    try {
+        debugs(5, 2, HERE << "New connection on FD " << fd);
 
-    assert(isOpen(fd));
-    ListenStateData *afd = static_cast<ListenStateData*>(data);
+        Must(isOpen(fd));
+        TcpAcceptor *afd = static_cast<TcpAcceptor*>(data);
+
+        if (!okToAccept()) {
+            AcceptLimiter::Instance().defer(afd);
+        } else {
+            afd->acceptNext();
+        }
+        SetSelect(fd, COMM_SELECT_READ, Comm::TcpAcceptor::doAccept, afd, 0);
 
-    if (!okToAccept()) {
-        AcceptLimiter::Instance().defer(afd);
-    } else {
-        afd->acceptNext();
+    } catch (const std::exception &e) {
+        fatalf("FATAL: error while accepting new client connection: %s\n", e.what());
+    } catch (...) {
+        fatal("FATAL: error while accepting new client connection: [unkown]\n");
     }
-    SetSelect(fd, COMM_SELECT_READ, Comm::ListenStateData::doAccept, afd, 0);
 }
 
 bool
-Comm::ListenStateData::okToAccept()
+Comm::TcpAcceptor::okToAccept()
 {
     static time_t last_warn = 0;
 
@@ -140,7 +218,7 @@ Comm::ListenStateData::okToAccept()
 }
 
 void
-Comm::ListenStateData::acceptOne()
+Comm::TcpAcceptor::acceptOne()
 {
     /*
      * We don't worry about running low on FDs here.  Instead,
@@ -149,69 +227,75 @@ Comm::ListenStateData::acceptOne()
      */
 
     /* Accept a new connection */
-    ConnectionDetail connDetails;
-    int newfd = oldAccept(connDetails);
+    ConnectionDetail newConnDetails;
+    int newFd = -1;
+    const comm_err_t flag = oldAccept(newConnDetails, &newFd);
 
     /* Check for errors */
-    if (newfd < 0) {
+    if (!isOpen(newFd)) {
 
-        if (newfd == COMM_NOMESSAGE) {
+        if (flag == COMM_NOMESSAGE) {
             /* register interest again */
-            debugs(5, 5, HERE << "try later: FD " << fd << " handler: " << theCallback);
+            debugs(5, 5, HERE << "try later: FD " << fd << " handler Subscription: " << theCallSub);
             SetSelect(fd, COMM_SELECT_READ, doAccept, this, 0);
             return;
         }
 
         // A non-recoverable error; notify the caller */
-        debugs(5, 5, HERE << "non-recoverable error: FD " << fd << " handler: " << theCallback);
-        notify(-1, COMM_ERROR, connDetails);
-        mayAcceptMore = false;
+        debugs(5, 5, HERE << "non-recoverable error:" << status() << " handler Subscription: " << theCallSub);
+        notify(flag, newConnDetails, newFd);
+        mustStop("Listener socket closed");
         return;
     }
 
-    debugs(5, 5, HERE << "accepted: FD " << fd <<
-           " newfd: " << newfd << " from: " << connDetails.peer <<
-           " handler: " << theCallback);
-    notify(newfd, COMM_OK, connDetails);
+    debugs(5, 5, HERE << "Listener: FD " << fd <<
+           " accepted new connection from " << newConnDetails.peer <<
+           " handler Subscription: " << theCallSub);
+    notify(flag, newConnDetails, newFd);
 }
 
 void
-Comm::ListenStateData::acceptNext()
+Comm::TcpAcceptor::acceptNext()
 {
-    assert(isOpen(fd));
+    Must(isOpen(fd));
     debugs(5, 2, HERE << "connection on FD " << fd);
     acceptOne();
 }
 
+// XXX: obsolete comment?
+// NP: can't be a const function because syncWithComm() side effects hit theCallSub->callback().
 void
-Comm::ListenStateData::notify(int newfd, comm_err_t flag, const ConnectionDetail &connDetails)
+Comm::TcpAcceptor::notify(const comm_err_t flag, const ConnectionDetail &connDetails, int newFd) const
 {
     // listener socket handlers just abandon the port with COMM_ERR_CLOSING
     // it should only happen when this object is deleted...
     if (flag == COMM_ERR_CLOSING) {
         return;
     }
 
-    if (theCallback != NULL) {
-        typedef CommAcceptCbParams Params;
-        Params &params = GetCommParams<Params>(theCallback);
+    if (theCallSub != NULL) {
+        AsyncCall::Pointer call = theCallSub->callback();
+        CommAcceptCbParams &params = GetCommParams<CommAcceptCbParams>(call);
         params.fd = fd;
-        params.nfd = newfd;
+        params.nfd = newFd;
         params.details = connDetails;
         params.flag = flag;
         params.xerrno = errcode;
-        ScheduleCallHere(theCallback);
-        if (!mayAcceptMore)
-            theCallback = NULL;
+        ScheduleCallHere(call);
     }
 }
 
 /**
  * accept() and process
- * Wait for an incoming connection on FD.
+ * Wait for an incoming connection on our listener socket.
+ *
+ * \retval COMM_OK         success. details parameter filled.
+ * \retval COMM_NOMESSAGE  attempted accept() but nothing useful came in.
+ * \retval COMM_ERROR      an outright failure occured.
+ *                         Or if this client has too many connections already.
  */
-int
-Comm::ListenStateData::oldAccept(ConnectionDetail &details)
+comm_err_t
+Comm::TcpAcceptor::oldAccept(ConnectionDetail &details, int *newFd)
 {
     PROF_start(comm_accept);
     statCounter.syscalls.sock.accepts++;
@@ -228,17 +312,19 @@ Comm::ListenStateData::oldAccept(ConnectionDetail &details)
         PROF_stop(comm_accept);
 
         if (ignoreErrno(errno)) {
-            debugs(50, 5, HERE << "FD " << fd << ": " << xstrerror());
+            debugs(50, 5, HERE << status() << ": " << xstrerror());
             return COMM_NOMESSAGE;
         } else if (ENFILE == errno || EMFILE == errno) {
-            debugs(50, 3, HERE << "FD " << fd << ": " << xstrerror());
+            debugs(50, 3, HERE << status() << ": " << xstrerror());
             return COMM_ERROR;
         } else {
-            debugs(50, 1, HERE << "FD " << fd << ": " << xstrerror());
+            debugs(50, 1, HERE << status() << ": " << xstrerror());
             return COMM_ERROR;
         }
     }
 
+    Must(sock >= 0);
+    *newFd = sock;
     details.peer = *gai;
 
     if ( Config.client_ip_max_connections >= 0) {
@@ -249,15 +335,16 @@ Comm::ListenStateData::oldAccept(ConnectionDetail &details)
         }
     }
 
+    // lookup the local-end details of this new connection
     details.me.InitAddrInfo(gai);
-
     details.me.SetEmpty();
     getsockname(sock, gai->ai_addr, &gai->ai_addrlen);
     details.me = *gai;
-
-    commSetCloseOnExec(sock);
+    details.me.FreeAddrInfo(gai);
 
     /* fdstat update */
+    // XXX : these are not all HTTP requests. use a note about type and ip:port details->
+    // so we end up with a uniform "(HTTP|FTP-data|HTTPS|...) remote-ip:remote-port"
     fd_open(sock, FD_SOCKET, "HTTP Request");
 
     fdd_table[sock].close_file = NULL;
@@ -266,15 +353,16 @@ Comm::ListenStateData::oldAccept(ConnectionDetail &details)
     fde *F = &fd_table[sock];
     details.peer.NtoA(F->ipaddr,MAX_IPSTRLEN);
     F->remote_port = details.peer.GetPort();
-    F->local_addr.SetPort(details.me.GetPort());
+    F->local_addr = details.me;
     F->sock_family = details.me.IsIPv6()?AF_INET6:AF_INET;
-    details.me.FreeAddrInfo(gai);
 
+    // set socket flags
+    commSetCloseOnExec(sock);
     commSetNonBlocking(sock);
 
     /* IFF the socket is (tproxy) transparent, pass the flag down to allow spoofing */
     F->flags.transparent = fd_table[fd].flags.transparent;
 
     PROF_stop(comm_accept);
-    return sock;
+    return COMM_OK;
 }
@@ -0,0 +1,99 @@
+#ifndef SQUID_COMM_TCPACCEPTOR_H
+#define SQUID_COMM_TCPACCEPTOR_H
+
+#include "base/AsyncCall.h"
+#include "base/Subscription.h"
+#include "CommCalls.h"
+#include "comm_err_t.h"
+#include "comm/TcpAcceptor.h"
+#include "ip/Address.h"
+
+#if HAVE_MAP
+#include <map>
+#endif
+
+namespace Comm
+{
+
+class AcceptLimiter;
+
+/**
+ * Listens on an FD for new incoming connections and
+ * emits an active FD descriptor for the new client.
+ *
+ * Handles all event limiting required to quash inbound connection
+ * floods within the global FD limits of available Squid_MaxFD and
+ * client_ip_max_connections.
+ *
+ * Fills the emitted connection with all connection details able to
+ * be looked up. Currently these are the local/remote IP:port details
+ * and the listening socket transparent-mode flag.
+ */
+class TcpAcceptor : public AsyncJob
+{
+private:
+    virtual void start();
+    virtual bool doneAll() const;
+    virtual void swanSong();
+    virtual const char *status() const;
+
+    TcpAcceptor(const TcpAcceptor &); // not implemented.
+
+public:
+    TcpAcceptor(const int listenFd, const Ip::Address &laddr, int flags,
+                const char *note, const Subscription::Pointer &aSub);
+
+    /** Subscribe a handler to receive calls back about new connections.
+     * Unsubscribes any existing subscribed handler.
+     */
+    void subscribe(const Subscription::Pointer &aSub);
+
+    /** Remove the currently waiting callback subscription.
+     * Already scheduled callbacks remain scheduled.
+     */
+    void unsubscribe(const char *reason);
+
+    /** Try and accept another connection (synchronous).
+     * If one is pending already the subscribed callback handler will be scheduled
+     * to handle it before this method returns.
+     */
+    void acceptNext();
+
+    /// Call the subscribed callback handler with details about a new connection.
+    void notify(const comm_err_t flags, const ConnectionDetail &newConnDetails, const int newFd) const;
+
+    /// errno code of the last accept() or listen() action if one occurred.
+    int errcode;
+
+    /// conn being listened on for new connections
+    /// Reserved for read-only use.
+    // NP: public only until we can hide it behind connection handles
+    int fd;
+
+protected:
+    friend class AcceptLimiter;
+    int32_t isLimited;                   ///< whether this socket is delayed and on the AcceptLimiter queue.
+
+private:
+    Subscription::Pointer theCallSub;    ///< used to generate AsyncCalls handling our events.
+
+    /// IP Address and port being listened on
+    Ip::Address local_addr;
+
+    /// Method to test if there are enough file descriptors to open a new client connection
+    /// if not the accept() will be postponed
+    static bool okToAccept();
+
+    /// Method callback for whenever an FD is ready to accept a client connection.
+    static void doAccept(int fd, void *data);
+
+    void acceptOne();
+    comm_err_t oldAccept(ConnectionDetail &newConnDetails, int *fd);
+    void setListen();
+
+    CBDATA_CLASS2(TcpAcceptor);
+};
+
+} // namespace Comm
+
+#endif /* SQUID_COMM_TCPACCEPTOR_H */
@@ -255,9 +255,8 @@ debugOpenLog(const char *logfile)
         debug_log = stderr;
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(debug_log), O_TEXT);
-
 #endif
 }
 
@@ -783,7 +782,7 @@ Debug::xassert(const char *msg, const char *file, int line)
 
 std::ostringstream (*Debug::CurrentDebug)(NULL);
 
-const size_t
+size_t
 BuildPrefixInit()
 {
     // XXX: This must be kept in sync with the actual debug.cc location
@@ -272,7 +272,7 @@
 #define	HTTP_REQBUF_SZ	4096
 
 /* CygWin & Windows NT Port */
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 #define _WIN_SQUID_SERVICE_CONTROL_STOP SERVICE_CONTROL_STOP
 #define _WIN_SQUID_SERVICE_CONTROL_SHUTDOWN SERVICE_CONTROL_SHUTDOWN
 #define _WIN_SQUID_SERVICE_CONTROL_INTERROGATE SERVICE_CONTROL_INTERROGATE
@@ -40,7 +40,7 @@
 static PF diskHandleRead;
 static PF diskHandleWrite;
 
-#if defined(_SQUID_WIN32_) || defined(_SQUID_OS2_)
+#if _SQUID_WINDOWS_ || _SQUID_OS2_
 static int
 diskWriteIsComplete(int fd)
 {
@@ -110,25 +110,18 @@ file_close(int fd)
     }
 
     if (F->flags.write_daemon) {
-#if defined(_SQUID_WIN32_) || defined(_SQUID_OS2_)
+#if _SQUID_WINDOWS_ || _SQUID_OS2_
         /*
          * on some operating systems, you can not delete or rename
          * open files, so we won't allow delayed close.
          */
-
         while (!diskWriteIsComplete(fd))
             diskHandleWrite(fd, NULL);
-
 #else
-
         F->flags.close_request = 1;
-
         debugs(6, 2, "file_close: FD " << fd << ", delaying close");
-
         PROF_stop(file_close);
-
         return;
-
 #endif
 
     }
@@ -522,7 +515,7 @@ int
 xrename(const char *from, const char *to)
 {
     debugs(21, 2, "xrename: renaming " << from << " to " << to);
-#if defined (_SQUID_OS2_) || defined (_SQUID_WIN32_)
+#if _SQUID_OS2_ || _SQUID_WINDOWS_
     remove(to);
 #endif
 
@@ -59,7 +59,7 @@
    using external DNS process.
  */
 #if !USE_DNSSERVERS
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 #include "squid_windows.h"
 #define REG_TCPIP_PARA_INTERFACES "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"
 #define REG_TCPIP_PARA "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters"
@@ -226,7 +226,7 @@ static void idnsParseNameservers(void);
 #ifndef _SQUID_MSWIN_
 static void idnsParseResolvConf(void);
 #endif
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 static void idnsParseWIN32Registry(void);
 static void idnsParseWIN32SearchList(const char *);
 #endif
@@ -364,9 +364,8 @@ idnsParseResolvConf(void)
         return;
     }
 
-#if defined(_SQUID_CYGWIN_)
+#if _SQUID_CYGWIN_
     setmode(fileno(fp), O_TEXT);
-
 #endif
 
     while (fgets(buf, RESOLV_BUFSZ, fp)) {
@@ -434,7 +433,7 @@ idnsParseResolvConf(void)
 
 #endif
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 static void
 idnsParseWIN32SearchList(const char * Separator)
 {
@@ -1512,20 +1511,16 @@ idnsInit(void)
         idnsParseResolvConf();
 
 #endif
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     if (0 == nns)
         idnsParseWIN32Registry();
-
 #endif
 
     if (0 == nns) {
         debugs(78, 1, "Warning: Could not find any nameservers. Trying to use localhost");
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
         debugs(78, 1, "Please check your TCP-IP settings or /etc/resolv.conf file");
 #else
-
         debugs(78, 1, "Please check your /etc/resolv.conf file");
 #endif
 
@@ -326,7 +326,7 @@ enum {
 
 
 /* CygWin & Windows NT Port */
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 /*
  * Supported Windows OS types codes
  */
@@ -1057,6 +1057,7 @@ ErrorState::BuildContent()
     String hdr;
     char dir[256];
     int l = 0;
+    const char *freePage = NULL;
 
     /** error_directory option in squid.conf overrides translations.
      * Custom errors are always found either in error_directory or the templates directory.
@@ -1130,6 +1131,7 @@ ErrorState::BuildContent()
                 if (m) {
                     /* store the language we found for the Content-Language reply header */
                     err_language = xstrdup(reset);
+                    freePage = m;
                     break;
                 } else if (Config.errorLogMissingLanguages) {
                     debugs(4, DBG_IMPORTANT, "WARNING: Error Pages Missing Language: " << reset);
@@ -1166,7 +1168,12 @@ ErrorState::BuildContent()
         debugs(4, 2, HERE << "No existing error page language negotiated for " << errorPageName(page_id) << ". Using default error file.");
     }
 
-    return ConvertText(m, true);
+    MemBuf *result = ConvertText(m, true);
+#if USE_ERR_LOCALES
+    safe_free(freePage);
+#endif
+
+    return result;
 }
 
 MemBuf *ErrorState::ConvertText(const char *text, bool allowRecursion)
@@ -52,8 +52,7 @@
          and can be wrapped
  */
 
-#if _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
 struct arpreq {
 
     Ip::Address arp_pa;   /* protocol address */
@@ -160,9 +159,9 @@ bool
 Eui::Eui48::lookup(Ip::Address &c)
 {
     struct arpreq arpReq;
-#if !_SQUID_WIN32_
+#if !_SQUID_WINDOWS_
     struct sockaddr_in *sa = NULL;
-#endif /* !_SQUID_WIN32_ */
+#endif /* !_SQUID_WINDOWS_ */
 
     Ip::Address ipAddr = c;
     ipAddr.SetPort(0);
@@ -451,7 +450,7 @@ Eui::Eui48::lookup(Ip::Address &c)
     set(arpReq.arp_ha.sa_data, 6);
     return true;
 
-#elif _SQUID_WIN32_
+#elif _SQUID_WINDOWS_
 
     DWORD           dwNetTable = 0;
 
@@ -1104,7 +1104,7 @@ external_acl_grace_expired(external_acl * def, external_acl_entry * entry)
     ttl = entry->result == 1 ? def->ttl : def->negative_ttl;
     ttl = (ttl * (100 - def->grace)) / 100;
 
-    if (entry->date + ttl < squid_curtime)
+    if (entry->date + ttl <= squid_curtime)
         return 1;
     else
         return 0;
@@ -152,6 +152,9 @@ static long fqdncache_low = 180;
 /// \ingroup FQDNCacheInternal
 static long fqdncache_high = 200;
 
+/// \ingroup FQDNCacheInternal
+inline int fqdncacheCount() { return fqdn_table ? fqdn_table->count : 0; }
+
 int
 fqdncache_entry::age() const
 {
@@ -229,7 +232,7 @@ fqdncache_purgelru(void *notused)
     eventAdd("fqdncache_purgelru", fqdncache_purgelru, NULL, 10.0, 1);
 
     for (m = lru_list.tail; m; m = prev) {
-        if (memInUse(MEM_FQDNCACHE_ENTRY) < fqdncache_low)
+        if (fqdncacheCount() < fqdncache_low)
             break;
 
         prev = m->prev;
@@ -698,9 +701,12 @@ fqdnStats(StoreEntry * sentry)
 
     storeAppendPrintf(sentry, "FQDN Cache Statistics:\n");
 
-    storeAppendPrintf(sentry, "FQDNcache Entries: %d\n",
+    storeAppendPrintf(sentry, "FQDNcache Entries In Use: %d\n",
                       memInUse(MEM_FQDNCACHE_ENTRY));
 
+    storeAppendPrintf(sentry, "FQDNcache Entries Cached: %d\n",
+                      fqdncacheCount());
+
     storeAppendPrintf(sentry, "FQDNcache Requests: %d\n",
                       FqdncacheStats.requests);
 
@@ -882,7 +888,7 @@ snmp_netFqdnFn(variable_list * Var, snint * ErrP)
 
     case FQDN_ENT:
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
-                                      memInUse(MEM_FQDNCACHE_ENTRY),
+                                      fqdncacheCount(),
                                       SMI_GAUGE32);
         break;
 
@@ -836,10 +836,9 @@ CossSwapDir::writeCleanDone()
     /* rename */
 
     if (state->fd >= 0) {
-#if defined(_SQUID_OS2_) || defined(_SQUID_WIN32_)
+#if _SQUID_OS2_ || _SQUID_WINDOWS_
         file_close(state->fd);
         state->fd = -1;
-
 #endif
 
         xrename(state->newLog, state->cur);
@@ -986,10 +986,9 @@ UFSSwapDir::writeCleanDone()
     /* rename */
 
     if (state->fd >= 0) {
-#if defined(_SQUID_OS2_) || defined (_SQUID_WIN32_)
+#if _SQUID_OS2_ || _SQUID_WINDOWS_
         file_close(state->fd);
         state->fd = -1;
-
 #endif
 
         xrename(state->newLog, state->cur);
@@ -34,8 +34,9 @@
 
 #include "squid.h"
 #include "comm.h"
+#include "CommCalls.h"
+#include "comm/TcpAcceptor.h"
 #include "comm/Write.h"
-#include "comm/ListenStateData.h"
 #include "compat/strtoll.h"
 #include "ConnectionDetail.h"
 #include "errorpage.h"
@@ -153,13 +154,11 @@ class FtpChannel
 
     void clear(); /// just resets fd and close handler. does not close active connections.
 
-    int fd; /// channel descriptor; \todo: remove because the closer has it
+    int fd; /// channel descriptor
 
-    /** Current listening socket handler. delete on shutdown or abort.
-     * FTP stores a copy of the FD in the field fd above.
-     * Use close() to properly close the channel.
-     */
-    Comm::ListenStateData *listener;
+    Ip::Address local; ///< The local IP address:port this channel is using
+
+    int flags; ///< socket flags used when opening.
 
 private:
     AsyncCall::Pointer closer; /// Comm close handler callback
@@ -245,6 +244,12 @@ class FtpStateData : public ServerStateData
     void completedListing(void);
     void dataComplete();
     void dataRead(const CommIoCbParams &io);
+
+    /// ignore timeout on CTRL channel. set read timeout on DATA channel.
+    void switchTimeoutToDataChannel();
+    /// create a data channel acceptor and start listening.
+    void listenForDataChannel(const int fd, const char *note);
+
     int checkAuth(const HttpHeader * req_hdr);
     void checkUrlpath();
     void buildTitleUrl();
@@ -443,6 +448,7 @@ FTPSM *FTP_SM_FUNCS[] = {
 void
 FtpStateData::ctrlClosed(const CommCloseCbParams &io)
 {
+    debugs(9, 4, HERE);
     ctrl.clear();
     deleteThis("FtpStateData::ctrlClosed");
 }
@@ -451,10 +457,10 @@ FtpStateData::ctrlClosed(const CommCloseCbParams &io)
 void
 FtpStateData::dataClosed(const CommCloseCbParams &io)
 {
-    if (data.listener) {
-        delete data.listener;
-        data.listener = NULL;
-        data.fd = -1;
+    debugs(9, 4, HERE);
+    if (data.fd >= 0) {
+        comm_close(data.fd);
+        // NP clear() does the: data.fd = -1;
     }
     data.clear();
     failed(ERR_FTP_FAILURE, 0);
@@ -605,6 +611,46 @@ FtpStateData::loginParser(const char *login, int escaped)
     debugs(9, 9, HERE << ": OUT: login='" << login << "', escaped=" << escaped << ", user=" << user << ", password=" << password);
 }
 
+void
+FtpStateData::switchTimeoutToDataChannel()
+{
+    commSetTimeout(ctrl.fd, -1, NULL, NULL);
+
+    typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall = JobCallback(9, 5, TimeoutDialer, this, FtpStateData::ftpTimeout);
+    commSetTimeout(data.fd, Config.Timeout.read, timeoutCall);
+}
+
+void
+FtpStateData::listenForDataChannel(const int fd, const char *note)
+{
+    assert(data.fd < 0);
+
+    typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> AcceptDialer;
+    typedef AsyncCallT<AcceptDialer> AcceptCall;
+    RefCount<AcceptCall> call = static_cast<AcceptCall*>(JobCallback(11, 5, AcceptDialer, this, FtpStateData::ftpAcceptDataConnection));
+    Subscription::Pointer sub = new CallSubscription<AcceptCall>(call);
+
+    /* open the conn if its not already open */
+    int newFd = fd;
+    if (newFd < 0) {
+        newFd = comm_open_listener(SOCK_STREAM, IPPROTO_TCP, data.local, data.flags, note);
+        if (newFd < 0) {
+            debugs(5, DBG_CRITICAL, HERE << "comm_open_listener failed:" << data.local << " error: " << errno);
+            return;
+        }
+        debugs(9, 3, HERE << "Unconnected data socket created on FD " << newFd << ", " << data.local);
+    }
+
+    assert(newFd >= 0);
+    Comm::TcpAcceptor *tmp = new Comm::TcpAcceptor(newFd, data.local, data.flags, note, sub);
+    AsyncJob::Start(tmp);
+
+    // Ensure we have a copy of the FD opened for listening and a close handler on it.
+    data.opened(newFd, dataCloser());
+    switchTimeoutToDataChannel();
+}
+
 void
 FtpStateData::ftpTimeout(const CommTimeoutCbParams &io)
 {
@@ -1066,10 +1112,16 @@ FtpStateData::parseListing()
 
     usable = end - sbuf;
 
-    debugs(9, 3, HERE << "usable = " << usable);
+    debugs(9, 3, HERE << "usable = " << usable << " of " << len << " bytes.");
 
     if (usable == 0) {
-        debugs(9, 3, HERE << "didn't find end for " << entry->url()  );
+        if (buf[0] == '\0' && len == 1) {
+            debugs(9, 3, HERE << "NIL ends data from " << entry->url() << " transfer problem?");
+            data.readBuf->consume(len);
+        } else {
+            debugs(9, 3, HERE << "didn't find end for " << entry->url());
+            debugs(9, 3, HERE << "buffer remains (" << len << " bytes) '" << rfc1738_do_escape(buf,0) << "'");
+        }
         xfree(sbuf);
         return;
     }
@@ -1138,7 +1190,14 @@ FtpStateData::dataComplete()
      * status code after the data command.  FtpStateData was being
      * deleted in the middle of dataRead().
      */
-    scheduleReadControlReply(0);
+    /* AYJ: 2011-01-13: Bug 2581.
+     * 226 status is possibly waiting in the ctrl buffer.
+     * The connection will hang if we DONT send buffered_ok.
+     * This happens on all transfers which can be completly sent by the
+     * server before the 150 started status message is read in by Squid.
+     * ie all transfers of about one packet hang.
+     */
+    scheduleReadControlReply(1);
 }
 
 void
@@ -1674,7 +1733,7 @@ FtpStateData::scheduleReadControlReply(int buffered_ok)
          * establish one on the control socket.
          */
 
-        if (data.fd > -1) {
+        if (data.fd >= 0) {
             AsyncCall::Pointer nullCall =  NULL;
             commSetTimeout(data.fd, -1, nullCall);
         }
@@ -2722,27 +2781,24 @@ FtpStateData::ftpPasvCallback(int fd, const DnsLookupDetails &dns, comm_err_t st
 static int
 ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
 {
-    int fd;
-    Ip::Address addr;
     struct addrinfo *AI = NULL;
-    int on = 1;
     int x = 0;
 
     /// Close old data channels, if any. We may open a new one below.
-    ftpState->data.close();
+    if ((ftpState->data.flags & COMM_REUSEADDR))
+        // NP: in fact it points to the control channel. just clear it.
+        ftpState->data.clear();
+    else
+        ftpState->data.close();
 
     /*
      * Set up a listen socket on the same local address as the
      * control connection.
      */
-
-    addr.InitAddrInfo(AI);
-
+    ftpState->data.local.InitAddrInfo(AI);
     x = getsockname(ftpState->ctrl.fd, AI->ai_addr, &AI->ai_addrlen);
-
-    addr = *AI;
-
-    addr.FreeAddrInfo(AI);
+    ftpState->data.local = *AI;
+    ftpState->data.local.FreeAddrInfo(AI);
 
     if (x) {
         debugs(9, DBG_CRITICAL, HERE << "getsockname(" << ftpState->ctrl.fd << ",..): " << xstrerror());
@@ -2754,38 +2810,18 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
      * used for both control and data.
      */
     if (fallback) {
+        int on = 1;
         setsockopt(ftpState->ctrl.fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));
+        ftpState->ctrl.flags |= COMM_REUSEADDR;
+        ftpState->data.flags |= COMM_REUSEADDR;
     } else {
         /* if not running in fallback mode a new port needs to be retrieved */
-        addr.SetPort(0);
-    }
-
-    fd = comm_open(SOCK_STREAM,
-                   IPPROTO_TCP,
-                   addr,
-                   COMM_NONBLOCKING | (fallback ? COMM_REUSEADDR : 0),
-                   ftpState->entry->url());
-    debugs(9, 3, HERE << "Unconnected data socket created on FD " << fd  );
-
-    if (fd < 0) {
-        debugs(9, DBG_CRITICAL, HERE << "comm_open failed");
-        return -1;
-    }
-
-    typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-    AsyncCall::Pointer acceptCall = JobCallback(11, 5,
-                                    acceptDialer, ftpState, FtpStateData::ftpAcceptDataConnection);
-    ftpState->data.listener = new Comm::ListenStateData(fd, acceptCall, false);
-
-    if (!ftpState->data.listener || ftpState->data.listener->errcode != 0) {
-        comm_close(fd);
-        return -1;
+        ftpState->data.local.SetPort(0);
+        ftpState->data.flags = COMM_NONBLOCKING;
     }
 
-    ftpState->data.opened(fd, ftpState->dataCloser());
-    ftpState->data.port = comm_local_port(fd);
-    ftpState->data.host = NULL;
-    return fd;
+    ftpState->listenForDataChannel((fallback?ftpState->ctrl.fd:-1), ftpState->entry->url());
+    return ftpState->data.fd;
 }
 
 /// \ingroup ServerProtocolFTPInternal
@@ -2881,6 +2917,7 @@ ftpSendEPRT(FtpStateData * ftpState)
     debugs(9, 3, HERE);
     ftpState->flags.pasv_supported = 0;
     fd = ftpOpenListenSocket(ftpState, 0);
+    debugs(9, 3, "Listening for FTP data connection with FD " << fd);
 
     Ip::Address::InitAddrInfo(AI);
 
@@ -2933,77 +2970,68 @@ ftpReadEPRT(FtpStateData * ftpState)
  */
 void FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
 {
-    char ntoapeer[MAX_IPSTRLEN];
-    debugs(9, 3, "ftpAcceptDataConnection");
-
-    // one connection accepted. the handler has stopped listening. drop our local pointer to it.
-    data.listener = NULL;
+    debugs(9, 3, HERE);
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
         abortTransaction("entry aborted when accepting data conn");
         return;
     }
 
+    if (io.flag != COMM_OK) {
+        data.close();
+        debugs(9, DBG_IMPORTANT, "FTP AcceptDataConnection: FD " << io.fd << ": " << xstrerr(io.xerrno));
+        /** \todo Need to send error message on control channel*/
+        ftpFail(this);
+        return;
+    }
+
+    /* data listening conn is no longer even open. abort. */
+    if (data.fd <= 0 || fd_table[data.fd].flags.open == 0) {
+        data.clear(); // ensure that it's cleared and not just closed.
+        return;
+    }
+
     /** \par
      * When squid.conf ftp_sanitycheck is enabled, check the new connection is actually being
      * made by the remote client which is connected to the FTP control socket.
+     * Or the one which we were told to listen for by control channel messages (may differ under NAT).
      * This prevents third-party hacks, but also third-party load balancing handshakes.
      */
     if (Config.Ftp.sanitycheck) {
+        char ntoapeer[MAX_IPSTRLEN];
         io.details.peer.NtoA(ntoapeer,MAX_IPSTRLEN);
 
-        if (strcmp(fd_table[ctrl.fd].ipaddr, ntoapeer) != 0) {
+        if (strcmp(fd_table[ctrl.fd].ipaddr, ntoapeer) != 0 &&
+                strcmp(fd_table[data.fd].ipaddr, ntoapeer) != 0) {
             debugs(9, DBG_IMPORTANT,
                    "FTP data connection from unexpected server (" <<
                    io.details.peer << "), expecting " <<
-                   fd_table[ctrl.fd].ipaddr);
+                   fd_table[ctrl.fd].ipaddr << " or " << fd_table[data.fd].ipaddr);
 
-            /* close the bad soures connection down ASAP. */
+            /* close the bad sources connection down ASAP. */
             comm_close(io.nfd);
 
-            /* we are ony accepting once, so need to re-open the listener socket. */
-            typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-            AsyncCall::Pointer acceptCall = JobCallback(11, 5,
-                                            acceptDialer, this, FtpStateData::ftpAcceptDataConnection);
-            data.listener = new Comm::ListenStateData(data.fd, acceptCall, false);
+            /* drop the bad connection (io) by ignoring the attempt. */
             return;
         }
     }
 
-    if (io.flag != COMM_OK) {
-        debugs(9, DBG_IMPORTANT, "ftpHandleDataAccept: FD " << io.nfd << ": " << xstrerr(io.xerrno));
-        /** \todo XXX Need to set error message */
-        ftpFail(this);
-        return;
-    }
-
     /**\par
-     * Replace the Listen socket with the accepted data socket */
+     * Replace the Listening socket with the accepted data socket */
     data.close();
     data.opened(io.nfd, dataCloser());
     data.port = io.details.peer.GetPort();
-    io.details.peer.NtoA(data.host,SQUIDHOSTNAMELEN);
+    data.host = xstrdup(fd_table[io.nfd].ipaddr);
 
     debugs(9, 3, "ftpAcceptDataConnection: Connected data socket on " <<
            "FD " << io.nfd << " to " << io.details.peer << " FD table says: " <<
            "ctrl-peer= " << fd_table[ctrl.fd].ipaddr << ", " <<
            "data-peer= " << fd_table[data.fd].ipaddr);
 
+    assert(haveControlChannel("ftpAcceptDataConnection"));
+    assert(ctrl.message == NULL);
 
-    AsyncCall::Pointer nullCall = NULL;
-    commSetTimeout(ctrl.fd, -1, nullCall);
-
-    typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-    AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
-                                      TimeoutDialer, this, FtpStateData::ftpTimeout);
-    commSetTimeout(data.fd, Config.Timeout.read, timeoutCall);
-
-    /*\todo XXX We should have a flag to track connect state...
-     *    host NULL -> not connected, port == local port
-     *    host set  -> connected, port == remote port
-     */
-    /* Restart state (SENT_NLST/LIST/RETR) */
-    FTP_SM_FUNCS[state] (this);
+    // Ctrl channel operations will determine what happens to this data connection
 }
 
 /// \ingroup ServerProtocolFTPInternal
@@ -3075,34 +3103,17 @@ void FtpStateData::readStor()
             return;
         }
 
-        /*\par
-         * When client status is 125, or 150 without a hostname, Begin data transfer. */
+        /* When client status is 125, or 150 without a hostname, Begin data transfer. */
         debugs(9, 3, HERE << "starting data transfer");
+        switchTimeoutToDataChannel();
         sendMoreRequestBody();
-        /** \par
-         * Cancel the timeout on the Control socket and
-         * establish one on the data socket.
-         */
-        AsyncCall::Pointer nullCall = NULL;
-        commSetTimeout(ctrl.fd, -1, nullCall);
-
-        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
-                                          TimeoutDialer, this, FtpStateData::ftpTimeout);
-
-        commSetTimeout(data.fd, Config.Timeout.read, timeoutCall);
-
         state = WRITING_DATA;
         debugs(9, 3, HERE << "writing data channel");
     } else if (code == 150) {
         /*\par
-         * When client code is 150 with a hostname, Accept data channel. */
+         * When client code is 150 without a hostname, Accept data channel. */
         debugs(9, 3, "ftpReadStor: accepting data channel");
-        typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-        AsyncCall::Pointer acceptCall = JobCallback(11, 5,
-                                        acceptDialer, this, FtpStateData::ftpAcceptDataConnection);
-
-        data.listener = new Comm::ListenStateData(data.fd, acceptCall, false);
+        listenForDataChannel(data.fd, data.host);
     } else {
         debugs(9, DBG_IMPORTANT, HERE << "Unexpected reply code "<< std::setfill('0') << std::setw(3) << code);
         ftpFail(this);
@@ -3222,34 +3233,15 @@ ftpReadList(FtpStateData * ftpState)
 
     if (code == 125 || (code == 150 && ftpState->data.host)) {
         /* Begin data transfer */
-        /* XXX what about Config.Timeout.read? */
+        debugs(9, 3, HERE << "begin data transfer from " << ftpState->data.host << " (" << ftpState->data.local << ")");
+        ftpState->switchTimeoutToDataChannel();
         ftpState->maybeReadVirginBody();
         ftpState->state = READING_DATA;
-        /*
-         * Cancel the timeout on the Control socket and establish one
-         * on the data socket
-         */
-        AsyncCall::Pointer nullCall = NULL;
-        commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
         return;
     } else if (code == 150) {
         /* Accept data channel */
-        typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-        AsyncCall::Pointer acceptCall = JobCallback(11, 5,
-                                        acceptDialer, ftpState, FtpStateData::ftpAcceptDataConnection);
-
-        ftpState->data.listener = new Comm::ListenStateData(ftpState->data.fd, acceptCall, false);
-        /*
-         * Cancel the timeout on the Control socket and establish one
-         * on the data socket
-         */
-        AsyncCall::Pointer nullCall = NULL;
-        commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
-
-        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
-                                          TimeoutDialer, ftpState,FtpStateData::ftpTimeout);
-        commSetTimeout(ftpState->data.fd, Config.Timeout.read, timeoutCall);
+        debugs(9, 3, HERE << "accept data channel from " << ftpState->data.host << " (" << ftpState->data.local << ")");
+        ftpState->listenForDataChannel(ftpState->data.fd, ftpState->data.host);
         return;
     } else if (!ftpState->flags.tried_nlst && code > 300) {
         ftpSendNlst(ftpState);
@@ -3285,32 +3277,12 @@ ftpReadRetr(FtpStateData * ftpState)
     if (code == 125 || (code == 150 && ftpState->data.host)) {
         /* Begin data transfer */
         debugs(9, 3, HERE << "reading data channel");
-        /* XXX what about Config.Timeout.read? */
+        ftpState->switchTimeoutToDataChannel();
         ftpState->maybeReadVirginBody();
         ftpState->state = READING_DATA;
-        /*
-         * Cancel the timeout on the Control socket and establish one
-         * on the data socket
-         */
-        AsyncCall::Pointer nullCall = NULL;
-        commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
     } else if (code == 150) {
         /* Accept data channel */
-        typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-        AsyncCall::Pointer acceptCall = JobCallback(11, 5,
-                                        acceptDialer, ftpState, FtpStateData::ftpAcceptDataConnection);
-        ftpState->data.listener = new Comm::ListenStateData(ftpState->data.fd, acceptCall, false);
-        /*
-         * Cancel the timeout on the Control socket and establish one
-         * on the data socket
-         */
-        AsyncCall::Pointer nullCall = NULL;
-        commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
-
-        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
-                                          TimeoutDialer, ftpState,FtpStateData::ftpTimeout);
-        commSetTimeout(ftpState->data.fd, Config.Timeout.read, timeoutCall);
+        ftpState->listenForDataChannel(ftpState->data.fd, ftpState->data.host);
     } else if (code >= 300) {
         if (!ftpState->flags.try_slash_hack) {
             /* Try this as a directory missing trailing slash... */
@@ -3965,22 +3937,25 @@ FtpChannel::opened(int aFd, const AsyncCall::Pointer &aCloser)
     fd = aFd;
     closer = aCloser;
     comm_add_close_handler(fd, closer);
+
+    // grab the local IP address:port details for this connection
+    struct addrinfo *AI = NULL;
+    local.InitAddrInfo(AI);
+    getsockname(aFd, AI->ai_addr, &AI->ai_addrlen);
+    local = *AI;
+    local.FreeAddrInfo(AI);
 }
 
 /// planned close: removes the close handler and calls comm_close
 void
 FtpChannel::close()
 {
     // channels with active listeners will be closed when the listener handler dies.
-    if (listener) {
-        delete listener;
-        listener = NULL;
-        comm_remove_close_handler(fd, closer);
-        closer = NULL;
-        fd = -1;
-    } else if (fd >= 0) {
-        comm_remove_close_handler(fd, closer);
-        closer = NULL;
+    if (fd >= 0) {
+        if (closer != NULL) {
+            comm_remove_close_handler(fd, closer);
+            closer = NULL;
+        }
         comm_close(fd); // we do not expect to be called back
         fd = -1;
     }
@@ -148,8 +148,7 @@ extern "C" {
 
     extern unsigned int WIN32_Socks_initialized;	/* 0 */
 #endif
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     extern unsigned int WIN32_OS_version;	/* 0 */
     extern char *WIN32_OS_string;           /* NULL */
     extern char *WIN32_Service_name;        /* NULL */
@@ -46,14 +46,10 @@
 #include <netinet/ip_icmp.h>
 #endif
 
-#ifndef _SQUID_LINUX_
-#ifndef _SQUID_CYGWIN_
-#ifndef _SQUID_MSWIN_
+#if !_SQUID_LINUX_ && !_SQUID_WINDOWS_
 #define icmphdr icmp
 #define iphdr ip
 #endif
-#endif
-#endif
 
 /* Linux uses its own field names. */
 #if defined (_SQUID_LINUX_)
@@ -87,8 +83,7 @@
    to use the native Windows port definitions.
  */
 
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
 #include "fde.h"
 
 #ifdef _SQUID_MSWIN_
@@ -116,7 +116,7 @@ Ip::Address::GetCIDR() const
     return len;
 }
 
-const int
+int
 Ip::Address::ApplyMask(Ip::Address const &mask_addr)
 {
     uint32_t *p1 = (uint32_t*)(&m_SocketAddr.sin6_addr);
@@ -228,7 +228,7 @@ class Address
     /** Apply a mask to the stored address.
      \param mask Netmask format to be bit-mask-AND'd over the stored address.
      */
-    const int ApplyMask(const Address &mask);
+    int ApplyMask(const Address &mask);
 
     /** Apply a mask to the stored address.
      *  CIDR will be converted appropriate to map the stored content.
@@ -6,8 +6,8 @@
  */
 
 #include "config.h"
-#include "comm.h"
 #include "base/TextException.h"
+#include "comm.h"
 #include "ipc/SharedListen.h"
 #include "ipc/StartListening.h"
 
@@ -25,34 +25,29 @@ std::ostream &Ipc::StartListeningCb::startPrint(std::ostream &os) const
     return os << "(FD " << fd << ", err=" << errNo;
 }
 
-
-void Ipc::StartListening(int sock_type, int proto, Ip::Address &addr,
-                         int flags, FdNoteId fdNote, AsyncCall::Pointer &callback)
+void
+Ipc::StartListening(int sock_type, int proto, Ip::Address &addr, int flags,
+                    FdNoteId fdNote, AsyncCall::Pointer &callback)
 {
-    OpenListenerParams p;
-    p.sock_type = sock_type;
-    p.proto = proto;
-    p.addr = addr;
-    p.flags = flags;
-    p.fdNote = fdNote;
-
     if (UsingSmp()) { // if SMP is on, share
+        OpenListenerParams p;
+        p.sock_type = sock_type;
+        p.proto = proto;
+        p.addr = addr;
+        p.flags = flags;
+        p.fdNote = fdNote;
         Ipc::JoinSharedListen(p, callback);
         return; // wait for the call back
     }
 
+    StartListeningCb *cbd = dynamic_cast<StartListeningCb*>(callback->getDialer());
+    Must(cbd);
+
     enter_suid();
-    const int sock = comm_open_listener(p.sock_type, p.proto, p.addr, p.flags,
-                                        FdNote(p.fdNote));
-    const int errNo = (sock >= 0) ? 0 : errno;
+    cbd->fd = comm_open_listener(sock_type, proto, addr, flags, FdNote(fdNote));
+    cbd->errNo = cbd->fd >= 0 ? 0 : errno;
     leave_suid();
 
-    debugs(54, 3, HERE << "opened listen FD " << sock << " for " << p.addr);
-
-    StartListeningCb *cbd =
-        dynamic_cast<StartListeningCb*>(callback->getDialer());
-    Must(cbd);
-    cbd->fd = sock;
-    cbd->errNo = errNo;
+    debugs(54, 3, HERE << "opened listen FD " << cbd->fd << " on " << addr);
     ScheduleCallHere(callback);
 }
@@ -113,7 +113,7 @@ void Ipc::UdsSender::write()
 
 void Ipc::UdsSender::wrote(const CommIoCbParams& params)
 {
-    debugs(54, 5, HERE << "FD " << params.fd << " flag " << params.flag << " [" << this << ']');
+    debugs(54, 5, HERE << "FD " << params.fd << " flag " << params.flag << " retries " << retries << " [" << this << ']');
     writing = false;
     if (params.flag != COMM_OK && retries-- > 0) {
         sleep(1); // do not spend all tries at once; XXX: use an async timed event instead of blocking here; store the time when we started writing so that we do not sleep if not needed?
@@ -161,6 +161,9 @@ static long ipcache_high = 200;
 extern int _dns_ttl_;
 #endif
 
+/// \ingroup IPCacheInternal
+inline int ipcacheCount() { return ip_table ? ip_table->count : 0; }
+
 int
 ipcache_entry::age() const
 {
@@ -235,7 +238,7 @@ ipcache_purgelru(void *voidnotused)
     eventAdd("ipcache_purgelru", ipcache_purgelru, NULL, 10.0, 1);
 
     for (m = lru_list.tail; m; m = prev) {
-        if (memInUse(MEM_IPCACHE_ENTRY) < ipcache_low)
+        if (ipcacheCount() < ipcache_low)
             break;
 
         prev = m->prev;
@@ -855,8 +858,10 @@ stat_ipcache_get(StoreEntry * sentry)
     dlink_node *m;
     assert(ip_table != NULL);
     storeAppendPrintf(sentry, "IP Cache Statistics:\n");
-    storeAppendPrintf(sentry, "IPcache Entries:  %d\n",
+    storeAppendPrintf(sentry, "IPcache Entries In Use:  %d\n",
                       memInUse(MEM_IPCACHE_ENTRY));
+    storeAppendPrintf(sentry, "IPcache Entries Cached:  %d\n",
+                      ipcacheCount());
     storeAppendPrintf(sentry, "IPcache Requests: %d\n",
                       IpcacheStats.requests);
     storeAppendPrintf(sentry, "IPcache Hits:            %d\n",
@@ -1231,7 +1236,7 @@ snmp_netIpFn(variable_list * Var, snint * ErrP)
 
     case IP_ENT:
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
-                                      memInUse(MEM_IPCACHE_ENTRY),
+                                      ipcacheCount(),
                                       SMI_GAUGE32);
         break;
 
@@ -966,14 +966,12 @@ mainInitialize(void)
 
     debugs(1, 0, "Starting Squid Cache version " << version_string << " for " << CONFIG_HOST_TYPE << "...");
 
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
         debugs(1, 0, "Running as " << WIN32_Service_name << " Windows System Service on " << WIN32_OS_string);
         debugs(1, 0, "Service command line is: " << WIN32_Service_Command_Line);
     } else
         debugs(1, 0, "Running on " << WIN32_OS_string);
-
 #endif
 
     debugs(1, 1, "Process ID " << getpid());
@@ -1240,8 +1238,7 @@ SquidMain(int argc, char **argv)
 {
     ConfigureCurrentKid(argv[0]);
 
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     int WIN32_init_err;
 #endif
 
@@ -1260,11 +1257,9 @@ SquidMain(int argc, char **argv)
 
 #endif
 
-#ifdef _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     if ((WIN32_init_err = WIN32_Subsystem_Init(&argc, &argv)))
         return WIN32_init_err;
-
 #endif
 
     /* call mallopt() before anything else */
@@ -279,9 +279,8 @@ mimeInit(char *filename)
         return;
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
-
 #endif
 
     mimeFreeMemory();
@@ -14,9 +14,17 @@ BEGIN {
 	print "/*"
 	print " * Auto-Generated File. Changes will be destroyed."
 	print " */"
-	print "#include \"squid.h\""
+	print "#include \"config.h\""
         codeSkip = 1
         e = 0
+        nspath = ""
+}
+
+# when namespace is encountered store it
+/^namespace [a-zA-Z]+/	{
+	nspath = tolower($2) "/"		# nested folder
+	namespace = $2				# code namespace reconstruct
+	next
 }
 
 # Skip all lines outside of typedef {}
@@ -34,11 +42,17 @@ codeSkip == 1		{ next }
 	type = t[1]
         codeSkip = 1
 
-	print "#include \"" type ".h\""
+	print "#include \"" nspath type ".h\""
+
+	# if namesapce is not empty ??
+	if (namespace) print "namespace " namespace
+	if (namespace) print "{"
+
 	print "\nconst char *" type "_str[] = {"
 	for ( i = 1; i < e; ++i)
 		print "\t\"" Element[i] "\","
 	print "\t\"" Element[i] "\""
 	print "};"
+	if (namespace) print "}; // namespace " namespace
 	next
 }
@@ -732,7 +732,7 @@ SQUIDCEXTERN int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
 
 /* CygWin & Windows NT Port */
 /* win32.c */
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 SQUIDCEXTERN int WIN32_Subsystem_Init(int *, char ***);
 SQUIDCEXTERN void WIN32_sendSignal(int);
 SQUIDCEXTERN void WIN32_Abort(int);
@@ -741,7 +741,7 @@ SQUIDCEXTERN void WIN32_SetServiceCommandLine(void);
 SQUIDCEXTERN void WIN32_InstallService(void);
 SQUIDCEXTERN void WIN32_RemoveService(void);
 SQUIDCEXTERN int SquidMain(int, char **);
-#endif /* _SQUID_WIN32_ */
+#endif /* _SQUID_WINDOWS_ */
 #ifdef _SQUID_MSWIN_
 
 SQUIDCEXTERN int WIN32_pipe(int[2]);
@@ -42,12 +42,16 @@
 #include "acl/Checklist.h"
 #include "HttpRequest.h"
 #include "client_side.h"
+#include "client_side_reply.h"
 #include "helper.h"
 #include "rfc1738.h"
 #if USE_SSL
 #include "ssl/support.h"
 #endif
 
+/// url maximum lengh + extra informations passed to redirector
+#define MAX_REDIRECTOR_REQUEST_STRLEN (MAX_URL + 1024)
+
 typedef struct {
     void *data;
     char *orig_url;
@@ -117,7 +121,9 @@ redirectStart(ClientHttpRequest * http, RH * handler, void *data)
     ConnStateData * conn = http->getConn();
     redirectStateData *r = NULL;
     const char *fqdn;
-    char buf[8192];
+    char buf[MAX_REDIRECTOR_REQUEST_STRLEN];
+    int sz;
+    http_status status;
     char claddr[MAX_IPSTRLEN];
     char myaddr[MAX_IPSTRLEN];
     assert(http);
@@ -167,14 +173,41 @@ redirectStart(ClientHttpRequest * http, RH * handler, void *data)
     if ((fqdn = fqdncache_gethostbyaddr(r->client_addr, 0)) == NULL)
         fqdn = dash_str;
 
-    snprintf(buf, 8192, "%s %s/%s %s %s myip=%s myport=%d\n",
-             r->orig_url,
-             r->client_addr.NtoA(claddr,MAX_IPSTRLEN),
-             fqdn,
-             r->client_ident[0] ? rfc1738_escape(r->client_ident) : dash_str,
-             r->method_s,
-             http->request->my_addr.NtoA(myaddr,MAX_IPSTRLEN),
-             http->request->my_addr.GetPort());
+    sz = snprintf(buf, MAX_REDIRECTOR_REQUEST_STRLEN, "%s %s/%s %s %s myip=%s myport=%d\n",
+		  r->orig_url,
+		  r->client_addr.NtoA(claddr,MAX_IPSTRLEN),
+		  fqdn,
+		  r->client_ident[0] ? rfc1738_escape(r->client_ident) : dash_str,
+		  r->method_s,
+		  http->request->my_addr.NtoA(myaddr,MAX_IPSTRLEN),
+		  http->request->my_addr.GetPort());
+
+    if ((sz<=0) || (sz>=MAX_REDIRECTOR_REQUEST_STRLEN)) {
+      if (sz<=0) {
+	status = HTTP_INTERNAL_SERVER_ERROR;
+	debugs(61, DBG_CRITICAL, "ERROR: Gateway Failure. Can not build request to be passed to redirector. Request ABORTED.");
+      } else {
+	status = HTTP_REQUEST_URI_TOO_LARGE;
+	debugs(61, DBG_CRITICAL, "ERROR: Gateway Failure. Request passed to redirector exceeds MAX_REDIRECTOR_REQUEST_STRLEN (" << MAX_REDIRECTOR_REQUEST_STRLEN << "). Request ABORTED.");
+      }
+
+      clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
+      clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+      assert (repContext);
+      IpAddress tmpnoaddr;
+      tmpnoaddr.SetNoAddr();
+      repContext->setReplyToError(ERR_GATEWAY_FAILURE, status,
+				  http->request->method, NULL,
+				  http->getConn() != NULL ? http->getConn()->peer : tmpnoaddr,
+				  http->request,
+				  NULL,
+				  http->getConn() != NULL && http->getConn()->auth_user_request ?
+				  http->getConn()->auth_user_request : http->request->auth_user_request);
+
+      node = (clientStreamNode *)http->client_stream.tail->data;
+      clientStreamRead(node, http, node->readBuffer);
+      return;
+    }
 
     helperSubmit(redirectors, buf, redirectHandleReply, r);
 }
@@ -126,7 +126,7 @@ using namespace Squid;
 #if HAVE_LIMITS_H
 #include <limits.h>
 #endif
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 #include <io.h>
 #endif
 #if HAVE_SYS_MOUNT_H
@@ -673,15 +673,13 @@ DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "Squid Object Cache: Version %s\n",
                       version_string);
 
-#if _SQUID_WIN32_
-
+#if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
         storeAppendPrintf(sentry,"\nRunning as %s Windows System Service on %s\n",
                           WIN32_Service_name, WIN32_OS_string);
         storeAppendPrintf(sentry,"Service command line is: %s\n", WIN32_Service_Command_Line);
     } else
         storeAppendPrintf(sentry,"Running on %s\n",WIN32_OS_string);
-
 #endif
 
     storeAppendPrintf(sentry, "Start Time:\t%s\n",
@@ -749,7 +747,7 @@ DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
                       stats.request_hit_disk_ratio60 / fct);
 
     storeAppendPrintf(sentry, "\tStorage Swap size:\t%.0f KB\n",
-                      stats.store_swap_size / 1024);
+                      stats.store_swap_size);
 
     storeAppendPrintf(sentry, "\tStorage Swap capacity:\t%4.1f%% used, %4.1f%% free\n",
                       Math::doublePercent(stats.store_swap_size, stats.store_swap_max_size),
@@ -23,7 +23,7 @@ HelperChildConfig::operator =(const HelperChildConfig &rhs)
     return *this;
 }
 
-const int
+int
 HelperChildConfig::needNew() const
 {
     /* during the startup and reconfigure use our special amount... */
@@ -997,7 +997,7 @@ setMaxFD(void)
 void
 setSystemLimits(void)
 {
-#if HAVE_SETRLIMIT && defined(RLIMIT_NOFILE) && !defined(_SQUID_CYGWIN_)
+#if HAVE_SETRLIMIT && defined(RLIMIT_NOFILE) && !_SQUID_CYGWIN_
     /* limit system filedescriptors to our own limit */
     struct rlimit rl;
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
@@ -1149,9 +1149,8 @@ parseEtcHosts(void)
         return;
     }
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
-
 #endif
 
     while (fgets(buf, 1024, fp)) {	/* for each line */
@@ -47,12 +47,6 @@ typedef struct {
     size_t kb;
 } kb_t;
 
-//UNUSED		typedef struct _acl_time_data acl_time_data;
-//UNUSED		typedef struct _acl_name_list acl_name_list;
-//UNUSED		typedef struct _acl_deny_info_list acl_deny_info_list;
-//UNUSED		typedef class AuthUser auth_user_t;
-
-
 /// \ingroup AuthAPI
 /// \deprecated Use AuthUserHashPointer instead.
 typedef struct AuthUserHashPointer auth_user_hash_pointer;
@@ -63,21 +57,9 @@ typedef struct AuthUserHashPointer auth_user_hash_pointer;
 class AuthConfig;
 typedef Vector<AuthConfig *> authConfig;
 
-//UNUSED		typedef struct _acl_snmp_comm acl_snmp_comm;
-//UNUSED		typedef class ACLList acl_list;
-//UNUSED		typedef struct _acl_address acl_address;
-//UNUSED		typedef struct _acl_tos acl_tos;
-//UNUSED		typedef struct _acl_size_t acl_size_t;
-//UNUSED		class ACLChecklist;
-//UNUSED		typedef struct _ushortlist ushortlist;
-//UNUSED		typedef struct _relist relist;
-
 struct http_port_list;
 struct https_port_list;
 
-//UNUSED	typedef struct _SquidConfig SquidConfig;
-//UNUSED	typedef struct _SquidConfig2 SquidConfig2;
-
 typedef struct _close_handler close_handler;
 
 typedef struct _dread_ctrl dread_ctrl;
@@ -86,26 +68,16 @@ typedef struct _dwrite_q dwrite_q;
 
 typedef struct _ETag ETag;
 
-//UNUSED		class fde;
-
 typedef struct _fileMap fileMap;
 
 typedef struct _HttpHeaderFieldAttrs HttpHeaderFieldAttrs;
 
-//UNUSED		class HttpHeaderFieldInfo;
-//UNUSED		class HttpHeader;
-//UNUSED		class HttpHdrCc;
-
 typedef struct _TimeOrTag TimeOrTag;
 
-//UNUSED		class HttpHeaderFieldStat;
-
 typedef struct _HttpHeaderStat HttpHeaderStat;
 
 typedef struct _HttpBody HttpBody;
 
-//UNUSED		class HttpReply;
-
 typedef struct _ConnCloseHelperData ConnCloseHelperData;
 
 typedef struct _ipcache_addrs ipcache_addrs;
@@ -118,10 +90,6 @@ typedef struct _DynPool DynPool;
 
 typedef struct _DigestFetchState DigestFetchState;
 
-//UNUSED		class PeerDigest;
-
-//UNUSED typedef struct _peer peer;
-
 typedef struct _net_db_name net_db_name;
 
 typedef struct _net_db_peer net_db_peer;
@@ -134,20 +102,12 @@ typedef struct _Meta_data Meta_data;
 
 typedef struct _iostats iostats;
 
-//UNUSED		class MemBuf;
-
-//UNUSED		class store_client;
-
-//UNUSED		class SwapDir;
-
 typedef struct _http_state_flags http_state_flags;
 
 typedef struct _header_mangler header_mangler;
 
 typedef struct _body_size body_size;
 
-//UNUSED		class HttpRequest;
-
 typedef struct _cachemgr_passwd cachemgr_passwd;
 
 typedef struct _refresh_t refresh_t;
@@ -156,7 +116,6 @@ typedef struct _CommWriteStateData CommWriteStateData;
 
 typedef struct _StatCounters StatCounters;
 
-/// \todo DROP: deprecated and no longer used.
 typedef struct _storeSwapLogData storeSwapLogData;
 
 typedef struct _StatHist StatHist;
@@ -53,7 +53,7 @@ fi
 # do not build any of the install's ...
 #
 # eval is need to correctly handle quoted arguments
-	eval "$base/../configure ${SQUID_CONFIGURE_FLAGS} ${configcache}" \
+	eval "$base/../configure ${DISTCHECK_CONFIGURE_FLAGS} ${configcache}" \
 		2>&1 && \
 	make ${pjobs} ${MAKETEST} 2>&1
 
@@ -24,6 +24,7 @@ for f in $@; do
     if [ ! -f "$t.o" -o $f -nt "$t.o" ]; then
         echo >$t.cc <<EOF
 /* This file is AUTOMATICALLY GENERATED. DO NOT ALTER IT */
+#include "config.h"
 #include "${f}"
 int main( int argc, char* argv[] ) { return 0; }
 EOF
@@ -44,7 +44,7 @@ using namespace Squid;
 /** \endcond */
 #endif
 
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
 #include <io.h>
 #endif
 #if HAVE_STDIO_H
@@ -400,9 +400,8 @@ main(int argc, char *argv[])
                     xstrerror());
             exit(-1);
         }
-#ifdef _SQUID_WIN32_
+#if _SQUID_WINDOWS_
         setmode(put_fd, O_BINARY);
-
 #endif
 
         fstat(put_fd, &sb);