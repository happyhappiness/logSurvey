@@ -30,6 +30,7 @@
 #ifndef SQUID_HTTPACCESSLOGENTRY_H
 #define SQUID_HTTPACCESSLOGENTRY_H
 
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
@@ -39,7 +40,6 @@
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
-#include "ProtoPort.h"
 
 /* forward decls */
 class HttpReply;
@@ -154,7 +154,7 @@ class AccessLogEntry
 
         const char *ssluser;
 #endif
-        http_port_list *port;
+        AnyP::PortCfg *port;
 
     } cache;
 
@@ -109,7 +109,10 @@ class ICPState
 
 /// \ingroup ServerProtocolICPAPI
 struct icpUdpData {
+
+    /// IP address for the remote end. Because we reply to packets from unknown non-peers.
     Ip::Address address;
+
     void *msg;
     size_t len;
     icpUdpData *next;
@@ -128,10 +131,10 @@ extern Comm::ConnectionPointer icpOutgoingConn;
 extern Ip::Address theIcpPublicHostID;
 
 /// \ingroup ServerProtocolICPAPI
-HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
+extern HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
+extern bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
@@ -161,13 +164,13 @@ SQUIDCEXTERN void icpHandleIcpV3(int, Ip::Address &, char *, int);
 SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionsOpen(void);
+SQUIDCEXTERN void icpOpenPorts(void);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN void icpConnectionShutdown(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionClose(void);
+SQUIDCEXTERN void icpClosePorts(void);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN int icpSetCacheKey(const cache_key * key);
@@ -262,8 +262,6 @@ squid_SOURCES = \
 	AsyncEngine.cc \
 	AsyncEngine.h \
 	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	CacheDigest.cc \
 	cache_manager.cc \
 	CacheManager.h \
@@ -650,7 +648,7 @@ recv_announce_SOURCES = recv-announce.cc
 ## ACLProxyAuth.cc wants ACLRegexData
 ## cache_cf.cc wants $(AUTH_LIBS)
 ## cache_cf.cc wants Swapdir
-## cache_cf.cc wants ProtoPort
+## cache_cf.cc wants AnyP::PortCfg
 ## client_side wants client_db
 ## client_db wants SNMP_SOURCE
 ## snmp_core wants ACLStringData
@@ -1268,8 +1266,6 @@ tests_testCacheManager_SOURCES = \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	CacheDigest.cc \
 	carp.cc \
 	cbdata.cc \
@@ -1546,7 +1542,6 @@ nodist_tests_testDiskIO_SOURCES= \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
-	anyp/libanyp.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
@@ -1558,6 +1553,7 @@ tests_testDiskIO_LDADD = \
 	$(AUTH_LIBS) \
 	libsquid.la \
 	comm/libcomm.la \
+	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
@@ -1677,8 +1673,6 @@ tests_testEvent_SOURCES = \
 	peer_select.cc \
 	peer_sourcehash.cc \
 	peer_userhash.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	redirect.cc \
 	refresh.cc \
 	RemovalPolicy.cc \
@@ -1871,8 +1865,6 @@ tests_testEventLoop_SOURCES = \
 	peer_select.cc \
 	peer_sourcehash.cc \
 	peer_userhash.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	RemovalPolicy.cc \
 	redirect.cc \
 	refresh.cc \
@@ -1976,8 +1968,6 @@ tests_test_http_range_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	cache_manager.cc \
 	CacheDigest.cc \
 	carp.cc \
@@ -2217,8 +2207,6 @@ tests_testHttpRequest_SOURCES = \
 	cache_manager.cc \
 	cache_cf.cc \
 	debug.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	CacheDigest.cc \
 	carp.cc \
 	cbdata.cc \
@@ -2695,13 +2683,13 @@ tests_testUfs_LDADD = \
 	mgr/libmgr.la \
 	$(REPL_OBJS) \
 	acl/libacls.la \
-	anyp/libanyp.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
 	ipc/libipc.la \
 	$(SSL_LIBS) \
 	comm/libcomm.la \
+	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -2814,9 +2802,9 @@ nodist_tests_testRock_SOURCES = \
 	SquidMath.h \
 	$(TESTSOURCES)
 tests_testRock_LDADD = \
-	anyp/libanyp.la \
 	libsquid.la \
 	comm/libcomm.la \
+	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(AUTH_LIBS) \
@@ -3197,8 +3185,6 @@ tests_testURL_SOURCES = \
 	peer_select.cc \
 	peer_sourcehash.cc \
 	peer_userhash.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	redirect.cc \
 	refresh.cc \
 	RemovalPolicy.cc \
@@ -1,39 +0,0 @@
-#include "squid.h"
-#include "comm.h"
-#include "ProtoPort.h"
-#if HAVE_LIMITS
-#include <limits>
-#endif
-
-http_port_list::http_port_list(const char *aProtocol)
-#if USE_SSL
-        :
-        dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
-#endif
-{
-    protocol = xstrdup(aProtocol);
-}
-
-http_port_list::~http_port_list()
-{
-    if (Comm::IsConnOpen(listenConn)) {
-        listenConn->close();
-        listenConn = NULL;
-    }
-
-    safe_free(name);
-    safe_free(defaultsite);
-    safe_free(protocol);
-
-#if USE_SSL
-    safe_free(cert);
-    safe_free(key);
-    safe_free(options);
-    safe_free(cipher);
-    safe_free(cafile);
-    safe_free(capath);
-    safe_free(dhfile);
-    safe_free(sslflags);
-    safe_free(sslContextSessionId);
-#endif
-}
@@ -144,9 +144,9 @@ class StatCounters
     double cputime;
 
     struct timeval timestamp;
-    StatHist comm_icp_incoming;
+    StatHist comm_udp_incoming;
     StatHist comm_dns_incoming;
-    StatHist comm_http_incoming;
+    StatHist comm_tcp_incoming;
     StatHist select_fds_hist;
 
     struct {
@@ -37,7 +37,7 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "dlink.h"
-#include "ProtoPort.h"
+#include "anyp/PortCfg.h"
 
 const char *AclMatchedName = NULL;
 
@@ -123,7 +123,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 
     // Is this ACL going to work?
     if (strcmp(theType, "myip") == 0) {
-        http_port_list *p = Config.Sockaddr.http;
+        AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
             if (p->intercepted)
@@ -133,7 +133,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myip' type is has been renamed to 'localip' and matches the IP the client connected to.");
         theType = "localip";
     } else if (strcmp(theType, "myport") == 0) {
-        http_port_list *p = Config.Sockaddr.http;
+        AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
             // Bug 3239: myport - not reliable (yet) when there is interception traffic coming
@@ -34,10 +34,10 @@
  */
 
 #include "squid-old.h"
-#include "ProtoPort.h"
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
+#include "anyp/PortCfg.h"
 #include "HttpRequest.h"
 
 /* for ConnStateData */
@@ -4,6 +4,8 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libanyp.la
 
 libanyp_la_SOURCES = \
+	PortCfg.cc \
+	PortCfg.h \
 	ProtocolType.cc \
 	ProtocolType.h \
 	ProtocolVersion.h
@@ -0,0 +1,91 @@
+#include "squid.h"
+#include "anyp/PortCfg.h"
+#include "comm.h"
+#if HAVE_LIMITS
+#include <limits>
+#endif
+
+CBDATA_NAMESPACED_CLASS_INIT(AnyP, PortCfg);
+
+int NHttpSockets = 0;
+int HttpSockets[MAXTCPLISTENPORTS];
+
+AnyP::PortCfg::PortCfg(const char *aProtocol)
+#if USE_SSL
+        :
+        dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
+#endif
+{
+    protocol = xstrdup(aProtocol);
+}
+
+AnyP::PortCfg::~PortCfg()
+{
+    if (Comm::IsConnOpen(listenConn)) {
+        listenConn->close();
+        listenConn = NULL;
+    }
+
+    safe_free(name);
+    safe_free(defaultsite);
+    safe_free(protocol);
+
+#if USE_SSL
+    safe_free(cert);
+    safe_free(key);
+    safe_free(options);
+    safe_free(cipher);
+    safe_free(cafile);
+    safe_free(capath);
+    safe_free(dhfile);
+    safe_free(sslflags);
+    safe_free(sslContextSessionId);
+#endif
+}
+
+AnyP::PortCfg *
+AnyP::PortCfg::clone() const
+{
+    AnyP::PortCfg *b = new AnyP::PortCfg(protocol);
+
+    b->s = s;
+    if (name)
+        b->name = xstrdup(name);
+    if (defaultsite)
+        b->defaultsite = xstrdup(defaultsite);
+
+    b->intercepted = intercepted;
+    b->spoof_client_ip = spoof_client_ip;
+    b->accel = accel;
+    b->allow_direct = allow_direct;
+    b->vhost = vhost;
+    b->sslBump = sslBump;
+    b->vport = vport;
+    b->connection_auth_disabled = connection_auth_disabled;
+    b->disable_pmtu_discovery = disable_pmtu_discovery;
+
+    memcpy( &(b->tcp_keepalive), &(tcp_keepalive), sizeof(tcp_keepalive));
+
+#if 0
+    // AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
+
+#if USE_SSL
+    char *cert;
+    char *key;
+    int version;
+    char *cipher;
+    char *options;
+    char *clientca;
+    char *cafile;
+    char *capath;
+    char *crlfile;
+    char *dhfile;
+    char *sslflags;
+    char *sslContextSessionId;
+    SSL_CTX *sslContext;
+#endif
+
+#endif /*0*/
+
+    return b;
+}
@@ -1,9 +1,5 @@
-/*
- * $Id$
- */
-
-#ifndef SQUID_PROTO_PORT_H
-#define SQUID_PROTO_PORT_H
+#ifndef SQUID_ANYP_PORTCFG_H
+#define SQUID_ANYP_PORTCFG_H
 
 #include "cbdata.h"
 #include "comm/Connection.h"
@@ -12,11 +8,15 @@
 #include "ssl/gadgets.h"
 #endif
 
-struct http_port_list {
-    http_port_list(const char *aProtocol);
-    ~http_port_list();
+namespace AnyP
+{
+
+struct PortCfg {
+    PortCfg(const char *aProtocol);
+    ~PortCfg();
+    AnyP::PortCfg *clone() const;
 
-    http_port_list *next;
+    PortCfg *next;
 
     Ip::Address s;
     char *protocol;            /* protocol name */
@@ -72,7 +72,16 @@ struct http_port_list {
     Ssl::X509_STACK_Pointer certsToChain; ///<  x509 certificates to send with the generated cert
 #endif
 
-    CBDATA_CLASS2(http_port_list);
+    CBDATA_CLASS2(PortCfg); // namespaced
 };
 
-#endif /* SQUID_PROTO_PORT_H */
+} // namespace AnyP
+
+// Max number of TCP listening ports
+#define MAXTCPLISTENPORTS 128
+
+// TODO: kill this global array. Need to check performance of array vs list though.
+extern int NHttpSockets;
+extern int HttpSockets[MAXTCPLISTENPORTS];
+
+#endif /* SQUID_ANYP_PORTCFG_H */
@@ -46,6 +46,7 @@
 #if USE_ECAP
 #include "adaptation/ecap/Config.h"
 #endif
+#include "anyp/PortCfg.h"
 #if USE_SSL
 #include "ssl/support.h"
 #include "ssl/Config.h"
@@ -71,7 +72,6 @@
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "Parsing.h"
-#include "ProtoPort.h"
 #include "rfc1738.h"
 #if SQUID_SNMP
 #include "snmp.h"
@@ -189,17 +189,10 @@ static int check_null_IpAddress_list(const Ip::Address_list *);
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
-static void parsePortList(http_port_list **, const char *protocol);
-#define parse_http_port_list(l) parsePortList((l),"http")
-static void dump_http_port_list(StoreEntry *, const char *, const http_port_list *);
-static void free_http_port_list(http_port_list **);
-
-#if USE_SSL
-#define parse_https_port_list(l) parsePortList((l),"https")
-#define dump_https_port_list(e,n,l) dump_http_port_list((e),(n),(l))
-#define free_https_port_list(l) free_http_port_list((l))
-#define check_null_https_port_list(l) check_null_http_port_list((l))
-#endif /* USE_SSL */
+static void parsePortCfg(AnyP::PortCfg **, const char *protocol);
+#define parse_PortCfg(l) parsePortCfg((l), token)
+static void dump_PortCfg(StoreEntry *, const char *, const AnyP::PortCfg *);
+static void free_PortCfg(AnyP::PortCfg **);
 
 static void parse_b_size_t(size_t * var);
 static void parse_b_int64_t(int64_t * var);
@@ -880,23 +873,14 @@ configDoConfigure(void)
 
     Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath, Config.ssl_client.crlfile);
 
-    {
-
-        peer *p;
-
-        for (p = Config.peers; p != NULL; p = p->next) {
+        for (peer *p = Config.peers; p != NULL; p = p->next) {
             if (p->use_ssl) {
                 debugs(3, 1, "Initializing cache_peer " << p->name << " SSL context");
                 p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
             }
         }
-    }
 
-    {
-
-        http_port_list *s;
-
-        for (s = Config.Sockaddr.http; s != NULL; s = (http_port_list *) s->next) {
+        for (AnyP::PortCfg *s = Config.Sockaddr.http; s != NULL; s = s->next) {
             if (!s->cert && !s->key)
                 continue;
 
@@ -910,13 +894,8 @@ configDoConfigure(void)
 
             Ssl::readCertChainAndPrivateKeyFromFiles(s->signingCert, s->signPkey, s->certsToChain, s->cert, s->key);
         }
-    }
-
-    {
-
-        http_port_list *s;
 
-        for (s = Config.Sockaddr.https; s != NULL; s = s->next) {
+        for (AnyP::PortCfg *s = Config.Sockaddr.https; s != NULL; s = s->next) {
             debugs(3, 1, "Initializing https_port " << s->s << " SSL context");
 
             s->staticSslContext.reset(
@@ -925,7 +904,6 @@ configDoConfigure(void)
                                        s->cafile, s->capath, s->crlfile, s->dhfile,
                                        s->sslContextSessionId));
         }
-    }
 
 #endif
 
@@ -3511,10 +3489,8 @@ check_null_IpAddress_list(const Ip::Address_list * s)
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
-CBDATA_CLASS_INIT(http_port_list);
-
 static void
-parsePortSpecification(http_port_list * s, char *token)
+parsePortSpecification(AnyP::PortCfg * s, char *token)
 {
     char *host = NULL;
     unsigned short port = 0;
@@ -3588,7 +3564,7 @@ parsePortSpecification(http_port_list * s, char *token)
 }
 
 static void
-parse_http_port_option(http_port_list * s, char *token)
+parse_port_option(AnyP::PortCfg * s, char *token)
 {
     /* modes first */
 
@@ -3789,66 +3765,16 @@ parse_http_port_option(http_port_list * s, char *token)
 void
 add_http_port(char *portspec)
 {
-    http_port_list *s = new http_port_list("http");
+    AnyP::PortCfg *s = new AnyP::PortCfg("http_port");
     parsePortSpecification(s, portspec);
-    // we may need to merge better of the above returns a list with clones
+    // we may need to merge better if the above returns a list with clones
     assert(s->next == NULL);
     s->next = Config.Sockaddr.http;
     Config.Sockaddr.http = s;
 }
 
-http_port_list *
-clone_http_port_list(http_port_list *a)
-{
-    http_port_list *b = new http_port_list(a->protocol);
-
-    b->s = a->s;
-    if (a->name)
-        b->name = xstrdup(a->name);
-    if (a->defaultsite)
-        b->defaultsite = xstrdup(a->defaultsite);
-
-    b->intercepted = a->intercepted;
-    b->spoof_client_ip = a->spoof_client_ip;
-    b->accel = a->accel;
-    b->allow_direct = a->allow_direct;
-    b->vhost = a->vhost;
-    b->sslBump = a->sslBump;
-    b->vport = a->vport;
-    b->connection_auth_disabled = a->connection_auth_disabled;
-    b->disable_pmtu_discovery = a->disable_pmtu_discovery;
-
-    memcpy( &(b->tcp_keepalive), &(a->tcp_keepalive), sizeof(a->tcp_keepalive));
-
-#if 0
-    // AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
-
-#if USE_SSL
-    // XXX: temporary hack to ease move of SSL options to http_port
-    http_port_list &http;
-
-    char *cert;
-    char *key;
-    int version;
-    char *cipher;
-    char *options;
-    char *clientca;
-    char *cafile;
-    char *capath;
-    char *crlfile;
-    char *dhfile;
-    char *sslflags;
-    char *sslContextSessionId;
-    SSL_CTX *sslContext;
-#endif
-
-#endif /*0*/
-
-    return b;
-}
-
 static void
-parsePortList(http_port_list ** head, const char *protocol)
+parsePortCfg(AnyP::PortCfg ** head, const char *protocol)
 {
     char *token = strtok(NULL, w_space);
 
@@ -3857,17 +3783,17 @@ parsePortList(http_port_list ** head, const char *protocol)
         return;
     }
 
-    http_port_list *s = new http_port_list(protocol);
+    AnyP::PortCfg *s = new AnyP::PortCfg(protocol);
     parsePortSpecification(s, token);
 
     /* parse options ... */
     while ((token = strtok(NULL, w_space))) {
-        parse_http_port_option(s, token);
+        parse_port_option(s, token);
     }
 
     if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.IsAnyAddr()) {
         // clone the port options from *s to *(s->next)
-        s->next = clone_http_port_list(s);
+        s->next = s->clone();
         s->next->s.SetIPv4();
         debugs(3, 3, protocol << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
@@ -3879,7 +3805,7 @@ parsePortList(http_port_list ** head, const char *protocol)
 }
 
 static void
-dump_generic_http_port(StoreEntry * e, const char *n, const http_port_list * s)
+dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 {
     char buf[MAX_IPSTRLEN];
 
@@ -4002,19 +3928,19 @@ dump_generic_http_port(StoreEntry * e, const char *n, const http_port_list * s)
 }
 
 static void
-dump_http_port_list(StoreEntry * e, const char *n, const http_port_list * s)
+dump_PortCfg(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 {
     while (s) {
-        dump_generic_http_port(e, n, s);
+        dump_generic_port(e, n, s);
         storeAppendPrintf(e, "\n");
         s = s->next;
     }
 }
 
 static void
-free_http_port_list(http_port_list ** head)
+free_PortCfg(AnyP::PortCfg ** head)
 {
-    http_port_list *s;
+    AnyP::PortCfg *s;
 
     while ((s = *head) != NULL) {
         *head = s->next;
@@ -31,8 +31,6 @@ hostdomain		cache_peer
 hostdomaintype		cache_peer
 http_header_access	acl
 http_header_replace
-http_port_list
-https_port_list
 adaptation_access_type	adaptation_service_set adaptation_service_chain acl icap_service icap_class
 adaptation_service_set_type	icap_service ecap_service
 adaptation_service_chain_type	icap_service ecap_service
@@ -52,6 +50,7 @@ obsolete
 onoff
 peer
 peer_access		cache_peer acl
+PortCfg
 QosConfig
 refreshpattern
 removalpolicy
@@ -1279,7 +1279,7 @@ COMMENT_START
 COMMENT_END
 
 NAME: http_port ascii_port
-TYPE: http_port_list
+TYPE: PortCfg
 DEFAULT: none
 LOC: Config.Sockaddr.http
 DOC_START
@@ -1510,7 +1510,7 @@ DOC_END
 
 NAME: https_port
 IFDEF: USE_SSL
-TYPE: https_port_list
+TYPE: PortCfg
 DEFAULT: none
 LOC: Config.Sockaddr.https
 DOC_START
@@ -6307,40 +6307,60 @@ COMMENT_START
  -----------------------------------------------------------------------------
 COMMENT_END
 
-NAME: incoming_icp_average
+NAME: incoming_udp_average incoming_icp_average
 TYPE: int
 DEFAULT: 6
-LOC: Config.comm_incoming.icp_average
-DOC_NONE
+LOC: Config.comm_incoming.udp.average
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
-NAME: incoming_http_average
+NAME: incoming_tcp_average  incoming_http_average
 TYPE: int
 DEFAULT: 4
-LOC: Config.comm_incoming.http_average
-DOC_NONE
+LOC: Config.comm_incoming.tcp.average
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
 NAME: incoming_dns_average
 TYPE: int
 DEFAULT: 4
-LOC: Config.comm_incoming.dns_average
-DOC_NONE
+LOC: Config.comm_incoming.dns.average
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
-NAME: min_icp_poll_cnt
+NAME: min_udp_poll_cnt min_icp_poll_cnt
 TYPE: int
 DEFAULT: 8
-LOC: Config.comm_incoming.icp_min_poll
-DOC_NONE
+LOC: Config.comm_incoming.udp.min_poll
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
 NAME: min_dns_poll_cnt
 TYPE: int
 DEFAULT: 8
-LOC: Config.comm_incoming.dns_min_poll
-DOC_NONE
+LOC: Config.comm_incoming.dns.min_poll
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
-NAME: min_http_poll_cnt
+NAME: min_tcp_poll_cnt min_http_poll_cnt
 TYPE: int
 DEFAULT: 8
-LOC: Config.comm_incoming.http_min_poll
+LOC: Config.comm_incoming.tcp.min_poll
 DOC_START
 	Heavy voodoo here.  I can't even believe you are reading this.
 	Are you crazy?  Don't even think about adjusting these unless
@@ -87,6 +87,7 @@
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
+#include "anyp/PortCfg.h"
 #include "base/Subscription.h"
 #include "base/TextException.h"
 #include "ChunkedCodingParser.h"
@@ -115,7 +116,6 @@
 #include "ipc/StartListening.h"
 #include "MemBuf.h"
 #include "MemObject.h"
-#include "ProtoPort.h"
 #include "rfc1738.h"
 #include "StatCounters.h"
 #include "StatHist.h"
@@ -145,8 +145,8 @@
 class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
 {
 public:
-    typedef void (*Handler)(http_port_list *portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
-    ListeningStartedDialer(Handler aHandler, http_port_list *aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
+    typedef void (*Handler)(AnyP::PortCfg *portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
+    ListeningStartedDialer(Handler aHandler, AnyP::PortCfg *aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
             handler(aHandler), portCfg(aPortCfg), portTypeNote(note), sub(aSub) {}
 
     virtual void print(std::ostream &os) const {
@@ -161,12 +161,12 @@ class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
     Handler handler;
 
 private:
-    http_port_list *portCfg;   ///< from Config.Sockaddr.http
+    AnyP::PortCfg *portCfg;   ///< from Config.Sockaddr.http
     Ipc::FdNoteId portTypeNote;    ///< Type of IPC socket being opened
     Subscription::Pointer sub; ///< The handler to be subscribed for this connetion listener
 };
 
-static void clientListenerConnectionOpened(http_port_list *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
+static void clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
 
 /* our socket-related context */
 
@@ -225,7 +225,7 @@ static void clientUpdateSocketStats(log_type logType, size_t size);
 char *skipLeadingSpace(char *aString);
 static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
 
-static ConnStateData *connStateCreate(const Comm::ConnectionPointer &client, http_port_list *port);
+static ConnStateData *connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port);
 
 
 clientStreamNode *
@@ -3148,7 +3148,7 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
 }
 
 ConnStateData *
-connStateCreate(const Comm::ConnectionPointer &client, http_port_list *port)
+connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
 {
     ConnStateData *result = new ConnStateData;
 
@@ -3210,7 +3210,7 @@ connStateCreate(const Comm::ConnectionPointer &client, http_port_list *port)
 void
 httpAccept(const CommAcceptCbParams &params)
 {
-    http_port_list *s = (http_port_list *)params.data;
+    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3431,7 +3431,7 @@ clientNegotiateSSL(int fd, void *data)
 static void
 httpsAccept(const CommAcceptCbParams &params)
 {
-    http_port_list *s = (http_port_list *)params.data;
+    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3632,12 +3632,12 @@ AddOpenedHttpSocket(const Comm::ConnectionPointer &conn)
 static void
 clientHttpConnectionsOpen(void)
 {
-    http_port_list *s = NULL;
+    AnyP::PortCfg *s = NULL;
 
     for (s = Config.Sockaddr.http; s; s = s->next) {
-        if (MAXHTTPPORTS == NHttpSockets) {
+        if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, 1, "WARNING: You have too many 'http_port' lines.");
-            debugs(1, 1, "         The limit is " << MAXHTTPPORTS);
+            debugs(1, 1, "         The limit is " << MAXTCPLISTENPORTS << " HTTP ports.");
             continue;
         }
 
@@ -3680,12 +3680,12 @@ clientHttpConnectionsOpen(void)
 static void
 clientHttpsConnectionsOpen(void)
 {
-    http_port_list *s;
+    AnyP::PortCfg *s;
 
     for (s = Config.Sockaddr.https; s; s = s->next) {
-        if (MAXHTTPPORTS == NHttpSockets) {
+        if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, 1, "Ignoring 'https_port' lines exceeding the limit.");
-            debugs(1, 1, "The limit is " << MAXHTTPPORTS << " HTTPS ports.");
+            debugs(1, 1, "The limit is " << MAXTCPLISTENPORTS << " HTTPS ports.");
             continue;
         }
 
@@ -3717,7 +3717,7 @@ clientHttpsConnectionsOpen(void)
 
 /// process clientHttpConnectionsOpen result
 static void
-clientListenerConnectionOpened(http_port_list *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
+clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
 {
     if (!OpenedHttpSocket(s->listenConn, portTypeNote))
         return;
@@ -3754,7 +3754,7 @@ clientOpenListenSockets(void)
 void
 clientHttpConnectionsClose(void)
 {
-    for (http_port_list *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, 1, "Closing HTTP port " << s->listenConn->local);
             s->listenConn->close();
@@ -3763,7 +3763,7 @@ clientHttpConnectionsClose(void)
     }
 
 #if USE_SSL
-    for (http_port_list *s = Config.Sockaddr.https; s; s = s->next) {
+    for (AnyP::PortCfg *s = Config.Sockaddr.https; s; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, 1, "Closing HTTPS port " << s->listenConn->local);
             s->listenConn->close();
@@ -254,7 +254,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
-    http_port_list *port;
+    AnyP::PortCfg *port;
 
     bool transparent() const;
     bool reading() const;
@@ -40,6 +40,7 @@
 #include "squid-old.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
+#include "anyp/PortCfg.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
@@ -61,7 +62,6 @@
 #include "ip/QosConfig.h"
 #include "ipcache.h"
 #include "MemObject.h"
-#include "ProtoPort.h"
 #include "SquidTime.h"
 #include "StoreClient.h"
 #include "Store.h"
@@ -54,6 +54,7 @@
 #include "adaptation/icap/History.h"
 #endif
 #endif
+#include "anyp/PortCfg.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
@@ -72,7 +73,6 @@
 #include "HttpRequest.h"
 #include "ip/QosConfig.h"
 #include "MemObject.h"
-#include "ProtoPort.h"
 #include "Store.h"
 #include "SquidTime.h"
 #include "wordlist.h"
@@ -31,6 +31,37 @@ extern comm_err_t DoSelect(int);
 
 extern void QuickPollRequired(void);
 
+/**
+ * Max number of UDP messages to receive per call to the UDP receive poller.
+ * This is a per-port limit for ICP/HTCP ports.
+ * DNS has a separate limit.
+ */
+#if _SQUID_MSWIN_
+#define INCOMING_UDP_MAX 1
+#else
+#define INCOMING_UDP_MAX 15
+#endif
+
+/**
+ * Max number of DNS messages to receive per call to DNS read handler
+ */
+#if _SQUID_MSWIN_
+#define INCOMING_DNS_MAX 1
+#else
+#define INCOMING_DNS_MAX 15
+#endif
+
+/**
+ * Max number of new TCP connections to accept per call to the TCP listener poller.
+ * This is a per-port limit for HTTP/HTTPS ports.
+ */
+#if _SQUID_MSWIN_
+#define INCOMING_TCP_MAX 1
+#else
+#define INCOMING_TCP_MAX 10
+#endif
+#define INCOMING_TOTAL_MAX (INCOMING_TCP_MAX+INCOMING_UDP_MAX+INCOMING_DNS_MAX)
+
 } // namespace Comm
 
 #endif /* _SQUID_SRC_COMM_LOOPS_H */
@@ -35,6 +35,7 @@
 #if USE_POLL
 
 #include "squid-old.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -70,8 +71,8 @@ static int MAX_POLL_TIME = 1000;	/* see also Comm::QuickPollRequired() */
 #define FD_MASK_BITS (FD_MASK_BYTES*NBBY)
 
 /* STATIC */
-static int fdIsHttp(int fd);
-static int fdIsIcp(int fd);
+static int fdIsTcpListen(int fd);
+static int fdIsUdpListen(int fd);
 static int fdIsDns(int fd);
 static OBJH commIncomingStats;
 static int comm_check_incoming_poll_handlers(int nfds, int *fds);
@@ -92,7 +93,7 @@ static void comm_poll_dns_incoming(void);
  * multipled by a factor of (2^INCOMING_FACTOR) to have some
  * pseudo-floating point precision.
  *
- * The variable 'icp_io_events' and 'http_io_events' counts how many normal
+ * The variable 'udp_io_events' and 'tcp_io_events' counts how many normal
  * I/O events have been processed since the last check on the incoming
  * sockets.  When io_events > incoming_interval, its time to check incoming
  * sockets.
@@ -106,7 +107,7 @@ static void comm_poll_dns_incoming(void);
  *
  *  incoming_interval = incoming_interval + target_average - number_of_events_processed
  *
- * There are separate incoming_interval counters for both HTTP and ICP events
+ * There are separate incoming_interval counters for TCP-based, UDP-based, and DNS events
  *
  * You can see the current values of the incoming_interval's, as well as
  * a histogram of 'incoming_events' by asking the cache manager
@@ -128,15 +129,15 @@ static void comm_poll_dns_incoming(void);
 #define MAX_INCOMING_INTEGER 256
 #define INCOMING_FACTOR 5
 #define MAX_INCOMING_INTERVAL (MAX_INCOMING_INTEGER << INCOMING_FACTOR)
-static int icp_io_events = 0;
-static int dns_io_events = 0;
-static int http_io_events = 0;
-static int incoming_icp_interval = 16 << INCOMING_FACTOR;
+static int udp_io_events = 0; ///< I/O events passed since last UDP receiver socket poll
+static int dns_io_events = 0; ///< I/O events passed since last DNS socket poll
+static int tcp_io_events = 0; ///< I/O events passed since last TCP listening socket poll
+static int incoming_udp_interval = 16 << INCOMING_FACTOR;
 static int incoming_dns_interval = 16 << INCOMING_FACTOR;
-static int incoming_http_interval = 16 << INCOMING_FACTOR;
-#define commCheckICPIncoming (++icp_io_events > (incoming_icp_interval>> INCOMING_FACTOR))
-#define commCheckDNSIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
-#define commCheckHTTPIncoming (++http_io_events > (incoming_http_interval>> INCOMING_FACTOR))
+static int incoming_tcp_interval = 16 << INCOMING_FACTOR;
+#define commCheckUdpIncoming (++udp_io_events > (incoming_udp_interval>> INCOMING_FACTOR))
+#define commCheckDnsIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
+#define commCheckTcpIncoming (++tcp_io_events > (incoming_tcp_interval>> INCOMING_FACTOR))
 
 
 void
@@ -169,7 +170,7 @@ Comm::ResetSelect(int fd)
 }
 
 static int
-fdIsIcp(int fd)
+fdIsUdpListen(int fd)
 {
     if (icpIncomingConn != NULL && icpIncomingConn->fd == fd)
         return 1;
@@ -193,12 +194,10 @@ fdIsDns(int fd)
 }
 
 static int
-fdIsHttp(int fd)
+fdIsTcpListen(int fd)
 {
-    int j;
-
-    for (j = 0; j < NHttpSockets; j++) {
-        if (fd == HttpSockets[j])
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
 
@@ -213,7 +212,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
     PF *hdl = NULL;
     int npfds;
 
-    struct pollfd pfds[3 + MAXHTTPPORTS];
+    struct pollfd pfds[3 + MAXTCPLISTENPORTS];
     PROF_start(comm_check_incoming);
     incoming_sockets_accepted = 0;
 
@@ -277,12 +276,12 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
 }
 
 static void
-comm_poll_icp_incoming(void)
+comm_poll_udp_incoming(void)
 {
     int nfds = 0;
     int fds[2];
     int nevents;
-    icp_io_events = 0;
+    udp_io_events = 0;
 
     if (Comm::IsConnOpen(icpIncomingConn))
         fds[nfds++] = icpIncomingConn->fd;
@@ -295,30 +294,30 @@ comm_poll_icp_incoming(void)
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
 
-    incoming_icp_interval += Config.comm_incoming.icp_average - nevents;
+    incoming_udp_interval += Config.comm_incoming.udp.average - nevents;
 
-    if (incoming_icp_interval < Config.comm_incoming.icp_min_poll)
-        incoming_icp_interval = Config.comm_incoming.icp_min_poll;
+    if (incoming_udp_interval < Config.comm_incoming.udp.min_poll)
+        incoming_udp_interval = Config.comm_incoming.udp.min_poll;
 
-    if (incoming_icp_interval > MAX_INCOMING_INTERVAL)
-        incoming_icp_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_udp_interval > MAX_INCOMING_INTERVAL)
+        incoming_udp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_ICP_MAX)
-        nevents = INCOMING_ICP_MAX;
+    if (nevents > INCOMING_UDP_MAX)
+        nevents = INCOMING_UDP_MAX;
 
-    statCounter.comm_icp_incoming.count(nevents);
+    statCounter.comm_udp_incoming.count(nevents);
 }
 
 static void
-comm_poll_http_incoming(void)
+comm_poll_tcp_incoming(void)
 {
     int nfds = 0;
-    int fds[MAXHTTPPORTS];
+    int fds[MAXTCPLISTENPORTS];
     int j;
     int nevents;
-    http_io_events = 0;
+    tcp_io_events = 0;
 
-    /* only poll sockets that won't be deferred */
+    // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
     for (j = 0; j < NHttpSockets; j++) {
         if (HttpSockets[j] < 0)
@@ -328,19 +327,19 @@ comm_poll_http_incoming(void)
     }
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
-    incoming_http_interval = incoming_http_interval
-                             + Config.comm_incoming.http_average - nevents;
+    incoming_tcp_interval = incoming_tcp_interval
+                             + Config.comm_incoming.tcp.average - nevents;
 
-    if (incoming_http_interval < Config.comm_incoming.http_min_poll)
-        incoming_http_interval = Config.comm_incoming.http_min_poll;
+    if (incoming_tcp_interval < Config.comm_incoming.tcp.min_poll)
+        incoming_tcp_interval = Config.comm_incoming.tcp.min_poll;
 
-    if (incoming_http_interval > MAX_INCOMING_INTERVAL)
-        incoming_http_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_tcp_interval > MAX_INCOMING_INTERVAL)
+        incoming_tcp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_HTTP_MAX)
-        nevents = INCOMING_HTTP_MAX;
+    if (nevents > INCOMING_TCP_MAX)
+        nevents = INCOMING_TCP_MAX;
 
-    statCounter.comm_http_incoming.count(nevents);
+    statCounter.comm_tcp_incoming.count(nevents);
 }
 
 /* poll all sockets; call handlers for those that are ready. */
@@ -355,27 +354,26 @@ Comm::DoSelect(int msec)
     unsigned long nfds;
     unsigned long npending;
     int num;
-    int callicp = 0, callhttp = 0;
-    int calldns = 0;
+    int calldns = 0, calludp = 0, calltcp = 0;
     double timeout = current_dtime + (msec / 1000.0);
 
     do {
         double start;
         getCurrentTime();
         start = current_dtime;
 
-        if (commCheckICPIncoming)
-            comm_poll_icp_incoming();
+        if (commCheckUdpIncoming)
+            comm_poll_udp_incoming();
 
-        if (commCheckDNSIncoming)
+        if (commCheckDnsIncoming)
             comm_poll_dns_incoming();
 
-        if (commCheckHTTPIncoming)
-            comm_poll_http_incoming();
+        if (commCheckTcpIncoming)
+            comm_poll_tcp_incoming();
 
         PROF_start(comm_poll_prep_pfds);
 
-        callicp = calldns = callhttp = 0;
+        calldns = calludp = calltcp = 0;
 
         nfds = 0;
 
@@ -474,8 +472,8 @@ Comm::DoSelect(int msec)
             if (revents == 0)
                 continue;
 
-            if (fdIsIcp(fd)) {
-                callicp = 1;
+            if (fdIsUdpListen(fd)) {
+                calludp = 1;
                 continue;
             }
 
@@ -484,8 +482,8 @@ Comm::DoSelect(int msec)
                 continue;
             }
 
-            if (fdIsHttp(fd)) {
-                callhttp = 1;
+            if (fdIsTcpListen(fd)) {
+                calltcp = 1;
                 continue;
             }
 
@@ -494,24 +492,22 @@ Comm::DoSelect(int msec)
             if (revents & (POLLRDNORM | POLLIN | POLLHUP | POLLERR)) {
                 debugs(5, 6, "comm_poll: FD " << fd << " ready for reading");
 
-                if (NULL == (hdl = F->read_handler))
-                    (void) 0;
-                else {
+                if ((hdl = F->read_handler)) {
                     PROF_start(comm_read_handler);
                     F->read_handler = NULL;
                     F->flags.read_pending = 0;
                     hdl(fd, F->read_data);
                     PROF_stop(comm_read_handler);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_poll_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_poll_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_poll_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_poll_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_poll_tcp_incoming();
                 }
             }
 
@@ -525,14 +521,14 @@ Comm::DoSelect(int msec)
                     PROF_stop(comm_write_handler);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_poll_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_poll_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_poll_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_poll_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_poll_tcp_incoming();
                 }
             }
 
@@ -566,14 +562,14 @@ Comm::DoSelect(int msec)
 
         PROF_stop(comm_handle_ready_fd);
 
-        if (callicp)
-            comm_poll_icp_incoming();
+        if (calludp)
+            comm_poll_udp_incoming();
 
         if (calldns)
             comm_poll_dns_incoming();
 
-        if (callhttp)
-            comm_poll_http_incoming();
+        if (calltcp)
+            comm_poll_tcp_incoming();
 
         getCurrentTime();
 
@@ -610,10 +606,10 @@ comm_poll_dns_incoming(void)
     if (nevents < 0)
         return;
 
-    incoming_dns_interval += Config.comm_incoming.dns_average - nevents;
+    incoming_dns_interval += Config.comm_incoming.dns.average - nevents;
 
-    if (incoming_dns_interval < Config.comm_incoming.dns_min_poll)
-        incoming_dns_interval = Config.comm_incoming.dns_min_poll;
+    if (incoming_dns_interval < Config.comm_incoming.dns.min_poll)
+        incoming_dns_interval = Config.comm_incoming.dns.min_poll;
 
     if (incoming_dns_interval > MAX_INCOMING_INTERVAL)
         incoming_dns_interval = MAX_INCOMING_INTERVAL;
@@ -642,20 +638,20 @@ Comm::SelectLoopInit(void)
 static void
 commIncomingStats(StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Current incoming_icp_interval: %d\n",
-                      incoming_icp_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_udp_interval: %d\n",
+                      incoming_udp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "Current incoming_dns_interval: %d\n",
                       incoming_dns_interval >> INCOMING_FACTOR);
-    storeAppendPrintf(sentry, "Current incoming_http_interval: %d\n",
-                      incoming_http_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_tcp_interval: %d\n",
+                      incoming_tcp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Histogram of events per incoming socket type\n");
-    storeAppendPrintf(sentry, "ICP Messages handled per comm_poll_icp_incoming() call:\n");
-    statCounter.comm_icp_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "ICP Messages handled per comm_poll_udp_incoming() call:\n");
+    statCounter.comm_udp_incoming.dump(sentry, statHistIntDumper);
     storeAppendPrintf(sentry, "DNS Messages handled per comm_poll_dns_incoming() call:\n");
     statCounter.comm_dns_incoming.dump(sentry, statHistIntDumper);
-    storeAppendPrintf(sentry, "HTTP Messages handled per comm_poll_http_incoming() call:\n");
-    statCounter.comm_http_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "HTTP Messages handled per comm_poll_tcp_incoming() call:\n");
+    statCounter.comm_tcp_incoming.dump(sentry, statHistIntDumper);
 }
 
 /* Called by async-io or diskd to speed up the polling */
@@ -35,6 +35,7 @@
 #if USE_SELECT
 
 #include "squid-old.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -58,8 +59,8 @@ static int MAX_POLL_TIME = 1000;	/* see also Comm::QuickPollRequired() */
 
 /* STATIC */
 static int examine_select(fd_set *, fd_set *);
-static int fdIsHttp(int fd);
-static int fdIsIcp(int fd);
+static int fdIsTcpListener(int fd);
+static int fdIsUdpListener(int fd);
 static int fdIsDns(int fd);
 static OBJH commIncomingStats;
 static int comm_check_incoming_select_handlers(int nfds, int *fds);
@@ -83,13 +84,13 @@ static int nwritefds;
  * of incoming ICP, then we need to check these sockets more than
  * if we just have HTTP.
  *
- * The variables 'incoming_icp_interval' and 'incoming_http_interval'
+ * The variables 'incoming_udp_interval' and 'incoming_tcp_interval'
  * determine how many normal I/O events to process before checking
  * incoming sockets again.  Note we store the incoming_interval
  * multipled by a factor of (2^INCOMING_FACTOR) to have some
  * pseudo-floating point precision.
  *
- * The variable 'icp_io_events' and 'http_io_events' counts how many normal
+ * The variable 'udp_io_events' and 'tcp_io_events' counts how many normal
  * I/O events have been processed since the last check on the incoming
  * sockets.  When io_events > incoming_interval, its time to check incoming
  * sockets.
@@ -103,7 +104,7 @@ static int nwritefds;
  *
  *  incoming_interval = incoming_interval + target_average - number_of_events_processed
  *
- * There are separate incoming_interval counters for both HTTP and ICP events
+ * There are separate incoming_interval counters for DNS, UDP and TCP events
  *
  * You can see the current values of the incoming_interval's, as well as
  * a histogram of 'incoming_events' by asking the cache manager
@@ -125,15 +126,15 @@ static int nwritefds;
 #define MAX_INCOMING_INTEGER 256
 #define INCOMING_FACTOR 5
 #define MAX_INCOMING_INTERVAL (MAX_INCOMING_INTEGER << INCOMING_FACTOR)
-static int icp_io_events = 0;
+static int udp_io_events = 0;
 static int dns_io_events = 0;
-static int http_io_events = 0;
-static int incoming_icp_interval = 16 << INCOMING_FACTOR;
+static int tcp_io_events = 0;
+static int incoming_udp_interval = 16 << INCOMING_FACTOR;
 static int incoming_dns_interval = 16 << INCOMING_FACTOR;
-static int incoming_http_interval = 16 << INCOMING_FACTOR;
-#define commCheckICPIncoming (++icp_io_events > (incoming_icp_interval>> INCOMING_FACTOR))
-#define commCheckDNSIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
-#define commCheckHTTPIncoming (++http_io_events > (incoming_http_interval>> INCOMING_FACTOR))
+static int incoming_tcp_interval = 16 << INCOMING_FACTOR;
+#define commCheckUdpIncoming (++udp_io_events > (incoming_udp_interval>> INCOMING_FACTOR))
+#define commCheckDnsIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
+#define commCheckTcpIncoming (++tcp_io_events > (incoming_tcp_interval>> INCOMING_FACTOR))
 
 void
 Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t timeout)
@@ -167,7 +168,7 @@ Comm::ResetSelect(int fd)
 }
 
 static int
-fdIsIcp(int fd)
+fdIsUdpListener(int fd)
 {
     if (icpIncomingConn != NULL && fd == icpIncomingConn->fd)
         return 1;
@@ -191,12 +192,10 @@ fdIsDns(int fd)
 }
 
 static int
-fdIsHttp(int fd)
+fdIsTcpListener(int fd)
 {
-    int j;
-
-    for (j = 0; j < NHttpSockets; j++) {
-        if (fd == HttpSockets[j])
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
 
@@ -272,12 +271,12 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 }
 
 static void
-comm_select_icp_incoming(void)
+comm_select_udp_incoming(void)
 {
     int nfds = 0;
     int fds[2];
     int nevents;
-    icp_io_events = 0;
+    udp_io_events = 0;
 
     if (Comm::IsConnOpen(icpIncomingConn))
         fds[nfds++] = icpIncomingConn->fd;
@@ -290,49 +289,48 @@ comm_select_icp_incoming(void)
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
-    incoming_icp_interval += Config.comm_incoming.icp_average - nevents;
+    incoming_udp_interval += Config.comm_incoming.udp.average - nevents;
 
-    if (incoming_icp_interval < 0)
-        incoming_icp_interval = 0;
+    if (incoming_udp_interval < 0)
+        incoming_udp_interval = 0;
 
-    if (incoming_icp_interval > MAX_INCOMING_INTERVAL)
-        incoming_icp_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_udp_interval > MAX_INCOMING_INTERVAL)
+        incoming_udp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_ICP_MAX)
-        nevents = INCOMING_ICP_MAX;
+    if (nevents > INCOMING_UDP_MAX)
+        nevents = INCOMING_UDP_MAX;
 
-    statCounter.comm_icp_incoming.count(nevents);
+    statCounter.comm_udp_incoming.count(nevents);
 }
 
 static void
-comm_select_http_incoming(void)
+comm_select_tcp_incoming(void)
 {
     int nfds = 0;
-    int fds[MAXHTTPPORTS];
-    int j;
+    int fds[MAXTCPLISTENPORTS];
     int nevents;
-    http_io_events = 0;
+    tcp_io_events = 0;
 
-    for (j = 0; j < NHttpSockets; j++) {
-        if (HttpSockets[j] < 0)
-            continue;
+    // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-        fds[nfds++] = HttpSockets[j];
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (Comm::IsConnOpen(s->listenConn))
+            fds[nfds++] = s->listenConn->fd;
     }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
-    incoming_http_interval += Config.comm_incoming.http_average - nevents;
+    incoming_tcp_interval += Config.comm_incoming.tcp.average - nevents;
 
-    if (incoming_http_interval < 0)
-        incoming_http_interval = 0;
+    if (incoming_tcp_interval < 0)
+        incoming_tcp_interval = 0;
 
-    if (incoming_http_interval > MAX_INCOMING_INTERVAL)
-        incoming_http_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_tcp_interval > MAX_INCOMING_INTERVAL)
+        incoming_tcp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_HTTP_MAX)
-        nevents = INCOMING_HTTP_MAX;
+    if (nevents > INCOMING_TCP_MAX)
+        nevents = INCOMING_TCP_MAX;
 
-    statCounter.comm_http_incoming.count(nevents);
+    statCounter.comm_tcp_incoming.count(nevents);
 }
 
 #define DEBUG_FDBITS 0
@@ -349,8 +347,7 @@ Comm::DoSelect(int msec)
     int maxfd;
     int num;
     int pending;
-    int callicp = 0, callhttp = 0;
-    int calldns = 0;
+    int calldns = 0, calludp = 0, calltcp = 0;
     int maxindex;
     unsigned int k;
     int j;
@@ -372,16 +369,16 @@ Comm::DoSelect(int msec)
         getCurrentTime();
         start = current_dtime;
 
-        if (commCheckICPIncoming)
-            comm_select_icp_incoming();
+        if (commCheckUdpIncoming)
+            comm_select_udp_incoming();
 
-        if (commCheckDNSIncoming)
+        if (commCheckDnsIncoming)
             comm_select_dns_incoming();
 
-        if (commCheckHTTPIncoming)
-            comm_select_http_incoming();
+        if (commCheckTcpIncoming)
+            comm_select_tcp_incoming();
 
-        callicp = calldns = callhttp = 0;
+        calldns = calludp = calltcp = 0;
 
         maxfd = Biggest_FD + 1;
 
@@ -508,8 +505,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-                if (fdIsIcp(fd)) {
-                    callicp = 1;
+                if (fdIsUdpListener(fd)) {
+                    calludp = 1;
                     continue;
                 }
 
@@ -518,8 +515,8 @@ Comm::DoSelect(int msec)
                     continue;
                 }
 
-                if (fdIsHttp(fd)) {
-                    callhttp = 1;
+                if (fdIsTcpListener(fd)) {
+                    calltcp = 1;
                     continue;
                 }
 
@@ -535,14 +532,14 @@ Comm::DoSelect(int msec)
                     hdl(fd, F->read_data);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_select_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_select_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_select_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_select_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_select_tcp_incoming();
                 }
             }
         }
@@ -573,8 +570,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-                if (fdIsIcp(fd)) {
-                    callicp = 1;
+                if (fdIsUdpListener(fd)) {
+                    calludp = 1;
                     continue;
                 }
 
@@ -583,8 +580,8 @@ Comm::DoSelect(int msec)
                     continue;
                 }
 
-                if (fdIsHttp(fd)) {
-                    callhttp = 1;
+                if (fdIsTcpListener(fd)) {
+                    calltcp = 1;
                     continue;
                 }
 
@@ -597,26 +594,26 @@ Comm::DoSelect(int msec)
                     hdl(fd, F->write_data);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_select_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_select_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_select_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_select_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_select_tcp_incoming();
                 }
             }
         }
 
-        if (callicp)
-            comm_select_icp_incoming();
+        if (calludp)
+            comm_select_udp_incoming();
 
         if (calldns)
             comm_select_dns_incoming();
 
-        if (callhttp)
-            comm_select_http_incoming();
+        if (calltcp)
+            comm_select_tcp_incoming();
 
         getCurrentTime();
 
@@ -651,10 +648,10 @@ comm_select_dns_incoming(void)
     if (nevents < 0)
         return;
 
-    incoming_dns_interval += Config.comm_incoming.dns_average - nevents;
+    incoming_dns_interval += Config.comm_incoming.dns.average - nevents;
 
-    if (incoming_dns_interval < Config.comm_incoming.dns_min_poll)
-        incoming_dns_interval = Config.comm_incoming.dns_min_poll;
+    if (incoming_dns_interval < Config.comm_incoming.dns.min_poll)
+        incoming_dns_interval = Config.comm_incoming.dns.min_poll;
 
     if (incoming_dns_interval > MAX_INCOMING_INTERVAL)
         incoming_dns_interval = MAX_INCOMING_INTERVAL;
@@ -754,20 +751,20 @@ examine_select(fd_set * readfds, fd_set * writefds)
 static void
 commIncomingStats(StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Current incoming_icp_interval: %d\n",
-                      incoming_icp_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_udp_interval: %d\n",
+                      incoming_udp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "Current incoming_dns_interval: %d\n",
                       incoming_dns_interval >> INCOMING_FACTOR);
-    storeAppendPrintf(sentry, "Current incoming_http_interval: %d\n",
-                      incoming_http_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_tcp_interval: %d\n",
+                      incoming_tcp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Histogram of events per incoming socket type\n");
-    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_icp_incoming() call:\n");
-    statCounter.comm_icp_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_udp_incoming() call:\n");
+    statCounter.comm_udp_incoming.dump(sentry, statHistIntDumper);
     storeAppendPrintf(sentry, "DNS Messages handled per comm_select_dns_incoming() call:\n");
     statCounter.comm_dns_incoming.dump(sentry, statHistIntDumper);
-    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_http_incoming() call:\n");
-    statCounter.comm_http_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_tcp_incoming() call:\n");
+    statCounter.comm_tcp_incoming.dump(sentry, statHistIntDumper);
 }
 
 void
@@ -35,6 +35,7 @@
 #if USE_SELECT_WIN32
 
 #include "squid-old.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -58,8 +59,8 @@ static int MAX_POLL_TIME = 1000;	/* see also Comm::QuickPollRequired() */
 
 /* STATIC */
 static int examine_select(fd_set *, fd_set *);
-static int fdIsHttp(int fd);
-static int fdIsIcp(int fd);
+static int fdIsTcpListener(int fd);
+static int fdIsUdpListener(int fd);
 static int fdIsDns(int fd);
 static OBJH commIncomingStats;
 static int comm_check_incoming_select_handlers(int nfds, int *fds);
@@ -83,13 +84,13 @@ static int nwritefds;
  * of incoming ICP, then we need to check these sockets more than
  * if we just have HTTP.
  *
- * The variables 'incoming_icp_interval' and 'incoming_http_interval'
+ * The variables 'incoming_udp_interval' and 'incoming_tcp_interval'
  * determine how many normal I/O events to process before checking
  * incoming sockets again.  Note we store the incoming_interval
  * multipled by a factor of (2^INCOMING_FACTOR) to have some
  * pseudo-floating point precision.
  *
- * The variable 'icp_io_events' and 'http_io_events' counts how many normal
+ * The variable 'udp_io_events' and 'tcp_io_events' counts how many normal
  * I/O events have been processed since the last check on the incoming
  * sockets.  When io_events > incoming_interval, its time to check incoming
  * sockets.
@@ -103,7 +104,7 @@ static int nwritefds;
  *
  *  incoming_interval = incoming_interval + target_average - number_of_events_processed
  *
- * There are separate incoming_interval counters for both HTTP and ICP events
+ * There are separate incoming_interval counters for DNS, UDP and TCP events
  *
  * You can see the current values of the incoming_interval's, as well as
  * a histogram of 'incoming_events' by asking the cache manager
@@ -125,15 +126,15 @@ static int nwritefds;
 #define MAX_INCOMING_INTEGER 256
 #define INCOMING_FACTOR 5
 #define MAX_INCOMING_INTERVAL (MAX_INCOMING_INTEGER << INCOMING_FACTOR)
-static int icp_io_events = 0;
+static int udp_io_events = 0;
 static int dns_io_events = 0;
-static int http_io_events = 0;
-static int incoming_icp_interval = 16 << INCOMING_FACTOR;
+static int tcp_io_events = 0;
+static int incoming_udp_interval = 16 << INCOMING_FACTOR;
 static int incoming_dns_interval = 16 << INCOMING_FACTOR;
-static int incoming_http_interval = 16 << INCOMING_FACTOR;
-#define commCheckICPIncoming (++icp_io_events > (incoming_icp_interval>> INCOMING_FACTOR))
-#define commCheckDNSIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
-#define commCheckHTTPIncoming (++http_io_events > (incoming_http_interval>> INCOMING_FACTOR))
+static int incoming_tcp_interval = 16 << INCOMING_FACTOR;
+#define commCheckUdpIncoming (++udp_io_events > (incoming_udp_interval>> INCOMING_FACTOR))
+#define commCheckDnsIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
+#define commCheckTcpIncoming (++tcp_io_events > (incoming_tcp_interval>> INCOMING_FACTOR))
 
 void
 Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t timeout)
@@ -167,7 +168,7 @@ Comm::ResetSelect(int fd)
 }
 
 static int
-fdIsIcp(int fd)
+fdIsUdpListener(int fd)
 {
     if (icpIncomingConn != NULL && fd == icpIncomingConn->fd)
         return 1;
@@ -191,12 +192,10 @@ fdIsDns(int fd)
 }
 
 static int
-fdIsHttp(int fd)
+fdIsTcpListener(int fd)
 {
-    int j;
-
-    for (j = 0; j < NHttpSockets; j++) {
-        if (fd == HttpSockets[j])
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
 
@@ -275,12 +274,12 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 }
 
 static void
-comm_select_icp_incoming(void)
+comm_select_udp_incoming(void)
 {
     int nfds = 0;
     int fds[2];
     int nevents;
-    icp_io_events = 0;
+    udp_io_events = 0;
 
     if (Comm::IsConnOpen(icpIncomingConn))
         fds[nfds++] = icpIncomingConn->fd;
@@ -293,49 +292,48 @@ comm_select_icp_incoming(void)
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
-    incoming_icp_interval += Config.comm_incoming.icp_average - nevents;
+    incoming_udp_interval += Config.comm_incoming.udp_average - nevents;
 
-    if (incoming_icp_interval < 0)
-        incoming_icp_interval = 0;
+    if (incoming_udp_interval < 0)
+        incoming_udp_interval = 0;
 
-    if (incoming_icp_interval > MAX_INCOMING_INTERVAL)
-        incoming_icp_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_udp_interval > MAX_INCOMING_INTERVAL)
+        incoming_udp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_ICP_MAX)
-        nevents = INCOMING_ICP_MAX;
+    if (nevents > INCOMING_UDP_MAX)
+        nevents = INCOMING_UDP_MAX;
 
-    statCounter.comm_icp_incoming.count(nevents);
+    statCounter.comm_udp_incoming.count(nevents);
 }
 
 static void
-comm_select_http_incoming(void)
+comm_select_tcp_incoming(void)
 {
     int nfds = 0;
-    int fds[MAXHTTPPORTS];
-    int j;
+    int fds[MAXTCPLISTENPORTS];
     int nevents;
-    http_io_events = 0;
+    tcp_io_events = 0;
 
-    for (j = 0; j < NHttpSockets; j++) {
-        if (HttpSockets[j] < 0)
-            continue;
+    // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-        fds[nfds++] = HttpSockets[j];
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (Comm::IsConnOpen(s->listenConn))
+            fds[nfds++] = s->listenConn->fd;
     }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
-    incoming_http_interval += Config.comm_incoming.http_average - nevents;
+    incoming_tcp_interval += Config.comm_incoming.tcp_average - nevents;
 
-    if (incoming_http_interval < 0)
-        incoming_http_interval = 0;
+    if (incoming_tcp_interval < 0)
+        incoming_tcp_interval = 0;
 
-    if (incoming_http_interval > MAX_INCOMING_INTERVAL)
-        incoming_http_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_tcp_interval > MAX_INCOMING_INTERVAL)
+        incoming_tcp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_HTTP_MAX)
-        nevents = INCOMING_HTTP_MAX;
+    if (nevents > INCOMING_TCP_MAX)
+        nevents = INCOMING_TCP_MAX;
 
-    statCounter.comm_http_incoming.count(nevents);
+    statCounter.comm_tcp_incoming.count(nevents);
 }
 
 #define DEBUG_FDBITS 0
@@ -352,8 +350,7 @@ Comm::DoSelect(int msec)
     int maxfd;
     int num;
     int pending;
-    int callicp = 0, callhttp = 0;
-    int calldns = 0;
+    int calldns = 0, callicp = 0, callhttp = 0;
     int j;
 #if DEBUG_FDBITS
 
@@ -372,16 +369,16 @@ Comm::DoSelect(int msec)
         getCurrentTime();
         start = current_dtime;
 
-        if (commCheckICPIncoming)
-            comm_select_icp_incoming();
+        if (commCheckUdpIncoming)
+            comm_select_udp_incoming();
 
-        if (commCheckDNSIncoming)
+        if (commCheckDnsIncoming)
             comm_select_dns_incoming();
 
-        if (commCheckHTTPIncoming)
-            comm_select_http_incoming();
+        if (commCheckTcpIncoming)
+            comm_select_tcp_incoming();
 
-        callicp = calldns = callhttp = 0;
+        calludp = calldns = calltcp = 0;
 
         maxfd = Biggest_FD + 1;
 
@@ -510,8 +507,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-            if (fdIsIcp(fd)) {
-                callicp = 1;
+            if (fdIsUdpListener(fd)) {
+                calludp = 1;
                 continue;
             }
 
@@ -520,31 +517,29 @@ Comm::DoSelect(int msec)
                 continue;
             }
 
-            if (fdIsHttp(fd)) {
-                callhttp = 1;
+            if (fdIsTcpListener(fd)) {
+                calltcp = 1;
                 continue;
             }
 
             F = &fd_table[fd];
             debugs(5, 6, "comm_select: FD " << fd << " ready for reading");
 
-            if (NULL == (hdl = F->read_handler))
-                (void) 0;
-            else {
+            if ((hdl = F->read_handler)) {
                 F->read_handler = NULL;
                 F->flags.read_pending = 0;
                 commUpdateReadBits(fd, NULL);
                 hdl(fd, F->read_data);
                 statCounter.select_fds++;
 
-                if (commCheckICPIncoming)
-                    comm_select_icp_incoming();
+                if (commCheckUdpIncoming)
+                    comm_select_udp_incoming();
 
-                if (commCheckDNSIncoming)
+                if (commCheckDnsIncoming)
                     comm_select_dns_incoming();
 
-                if (commCheckHTTPIncoming)
-                    comm_select_http_incoming();
+                if (commCheckTcpIncoming)
+                    comm_select_tcp_incoming();
             }
         }
 
@@ -596,8 +591,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-            if (fdIsIcp(fd)) {
-                callicp = 1;
+            if (fdIsUdpListener(fd)) {
+                calludp = 1;
                 continue;
             }
 
@@ -606,8 +601,8 @@ Comm::DoSelect(int msec)
                 continue;
             }
 
-            if (fdIsHttp(fd)) {
-                callhttp = 1;
+            if (fdIsTcpListener(fd)) {
+                calltcp = 1;
                 continue;
             }
 
@@ -620,25 +615,25 @@ Comm::DoSelect(int msec)
                 hdl(fd, F->write_data);
                 statCounter.select_fds++;
 
-                if (commCheckICPIncoming)
-                    comm_select_icp_incoming();
+                if (commCheckUdpIncoming)
+                    comm_select_udp_incoming();
 
-                if (commCheckDNSIncoming)
+                if (commCheckDnsIncoming)
                     comm_select_dns_incoming();
 
-                if (commCheckHTTPIncoming)
-                    comm_select_http_incoming();
+                if (commCheckTcpIncoming)
+                    comm_select_tcp_incoming();
             }
         }
 
-        if (callicp)
-            comm_select_icp_incoming();
+        if (calludp)
+            comm_select_udp_incoming();
 
         if (calldns)
             comm_select_dns_incoming();
 
-        if (callhttp)
-            comm_select_http_incoming();
+        if (calltcp)
+            comm_select_tcp_incoming();
 
         getCurrentTime();
 
@@ -673,10 +668,10 @@ comm_select_dns_incoming(void)
     if (nevents < 0)
         return;
 
-    incoming_dns_interval += Config.comm_incoming.dns_average - nevents;
+    incoming_dns_interval += Config.comm_incoming.dns.average - nevents;
 
-    if (incoming_dns_interval < Config.comm_incoming.dns_min_poll)
-        incoming_dns_interval = Config.comm_incoming.dns_min_poll;
+    if (incoming_dns_interval < Config.comm_incoming.dns.min_poll)
+        incoming_dns_interval = Config.comm_incoming.dns.min_poll;
 
     if (incoming_dns_interval > MAX_INCOMING_INTERVAL)
         incoming_dns_interval = MAX_INCOMING_INTERVAL;
@@ -776,20 +771,20 @@ examine_select(fd_set * readfds, fd_set * writefds)
 static void
 commIncomingStats(StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Current incoming_icp_interval: %d\n",
-                      incoming_icp_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_udp_interval: %d\n",
+                      incoming_udp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "Current incoming_dns_interval: %d\n",
                       incoming_dns_interval >> INCOMING_FACTOR);
-    storeAppendPrintf(sentry, "Current incoming_http_interval: %d\n",
-                      incoming_http_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_tcp_interval: %d\n",
+                      incoming_tcp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Histogram of events per incoming socket type\n");
-    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_icp_incoming() call:\n");
-    statCounter.comm_icp_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_udp_incoming() call:\n");
+    statCounter.comm_udp_incoming.dump(sentry, statHistIntDumper);
     storeAppendPrintf(sentry, "DNS Messages handled per comm_select_dns_incoming() call:\n");
     statCounter.comm_dns_incoming.dump(sentry, statHistIntDumper);
-    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_http_incoming() call:\n");
-    statCounter.comm_http_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_tcp_incoming() call:\n");
+    statCounter.comm_tcp_incoming.dump(sentry, statHistIntDumper);
 }
 
 void
@@ -56,8 +56,6 @@
 #define ACL_ALLWEEK	0x7F
 #define ACL_WEEKDAYS	0x3E
 
-#define MAXHTTPPORTS			128
-
 /* Select types. */
 #define COMM_SELECT_READ   (0x1)
 #define COMM_SELECT_WRITE  (0x2)
@@ -208,33 +206,6 @@
 /* handy to determine the #elements in a static array */
 #define countof(arr) (sizeof(arr)/sizeof(*arr))
 
-/*
- * Max number of ICP messages to receive per call to icpHandleUdp
- */
-#if _SQUID_MSWIN_
-#define INCOMING_ICP_MAX 1
-#else
-#define INCOMING_ICP_MAX 15
-#endif
-/*
- * Max number of DNS messages to receive per call to DNS read handler
- */
-#if _SQUID_MSWIN_
-#define INCOMING_DNS_MAX 1
-#else
-#define INCOMING_DNS_MAX 15
-#endif
-/*
- * Max number of HTTP connections to accept per call to httpAccept
- * and PER HTTP PORT
- */
-#if _SQUID_MSWIN_
-#define INCOMING_HTTP_MAX 1
-#else
-#define INCOMING_HTTP_MAX 10
-#endif
-#define INCOMING_TOTAL_MAX (INCOMING_ICP_MAX+INCOMING_HTTP_MAX)
-
 /*
  * This many TCP connections must FAIL before we mark the
  * peer as DEAD
@@ -38,7 +38,7 @@
 
 #include "rfc2181.h"
 
-/* for ERROR_BUF_SZ, BUFSIZ, MAXHTTPPORTS */
+/* for ERROR_BUF_SZ, BUFSIZ */
 #include "defines.h"
 
 /* for iostats */
@@ -78,9 +78,7 @@ extern "C" {
     extern int Biggest_FD;		/* -1 */
     extern int Number_FD;		/* 0 */
     extern int Opening_FD;		/* 0 */
-    extern int HttpSockets[MAXHTTPPORTS];
     extern int NDnsServersAlloc;	/* 0 */
-    extern int NHttpSockets;	/* 0 */
     extern int RESERVED_FD;
     extern int Squid_MaxFD;		/* SQUID_MAXFD */
     extern int config_lineno;	/* 0 */
@@ -38,6 +38,7 @@
 #include "acl/FilledChecklist.h"
 #include "acl/Acl.h"
 #include "comm.h"
+#include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "comm/UdpOpenDialer.h"
 #include "htcp.h"
@@ -1469,7 +1470,7 @@ htcpRecv(int fd, void *data)
  */
 
 void
-htcpInit(void)
+htcpOpenPorts(void)
 {
     if (Config.Port.htcp <= 0) {
         debugs(31, DBG_IMPORTANT, "HTCP Disabled.");
@@ -1703,7 +1704,7 @@ htcpSocketShutdown(void)
 }
 
 void
-htcpSocketClose(void)
+htcpClosePorts(void)
 {
     htcpSocketShutdown();
 
@@ -62,7 +62,7 @@ typedef class HtcpReplyData htcpReplyData;
 SQUIDCEXTERN void neighborsHtcpReply(const cache_key *, htcpReplyData *, const Ip::Address &);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpInit(void);
+SQUIDCEXTERN void htcpOpenPorts(void);
 
 /**
  * \ingroup ServerProtocolHTCP
@@ -86,7 +86,7 @@ SQUIDCEXTERN void htcpClear(StoreEntry * e, const char *uri, HttpRequest * req,
 SQUIDCEXTERN void htcpSocketShutdown(void);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpSocketClose(void);
+SQUIDCEXTERN void htcpClosePorts(void);
 
 #endif /* USE_HTCP */
 
@@ -595,7 +595,7 @@ icpHandleUdp(int sock, void *data)
     LOCAL_ARRAY(char, buf, SQUID_UDP_SO_RCVBUF);
     int len;
     int icp_version;
-    int max = INCOMING_ICP_MAX;
+    int max = INCOMING_UDP_MAX;
     Comm::SetSelect(sock, COMM_SELECT_READ, icpHandleUdp, NULL, 0);
 
     while (max--) {
@@ -657,7 +657,7 @@ icpHandleUdp(int sock, void *data)
 }
 
 void
-icpConnectionsOpen(void)
+icpOpenPorts(void)
 {
     uint16_t port;
 
@@ -765,7 +765,7 @@ icpConnectionShutdown(void)
 }
 
 void
-icpConnectionClose(void)
+icpClosePorts(void)
 {
     icpConnectionShutdown();
 
@@ -667,13 +667,12 @@ serverConnectionsOpen(void)
     // start various proxying services if we are responsible for them
     if (IamWorkerProcess()) {
         clientOpenListenSockets();
-        icpConnectionsOpen();
+        icpOpenPorts();
 #if USE_HTCP
-
-        htcpInit();
+        htcpOpenPorts();
 #endif
 #if SQUID_SNMP
-        snmpConnectionOpen();
+        snmpOpenPorts();
 #endif
 
         clientdbInit();
@@ -710,13 +709,12 @@ serverConnectionsClose(void)
         clientHttpConnectionsClose();
         icpConnectionShutdown();
 #if USE_HTCP
-
         htcpSocketShutdown();
 #endif
 
         icmpEngine.Close();
 #if SQUID_SNMP
-        snmpConnectionClose();
+        snmpClosePorts();
 #endif
 
         asnFreeMemory();
@@ -731,10 +729,9 @@ mainReconfigureStart(void)
 
     // Initiate asynchronous closing sequence
     serverConnectionsClose();
-    icpConnectionClose();
+    icpClosePorts();
 #if USE_HTCP
-
-    htcpSocketClose();
+    htcpClosePorts();
 #endif
     dnsShutdown();
 #if USE_SSL_CRTD
@@ -1832,13 +1829,12 @@ SquidShutdown()
 #endif
     redirectShutdown();
     externalAclShutdown();
-    icpConnectionClose();
+    icpClosePorts();
 #if USE_HTCP
-
-    htcpSocketClose();
+    htcpClosePorts();
 #endif
 #if SQUID_SNMP
-    snmpConnectionClose();
+    snmpClosePorts();
 #endif
 #if USE_WCCP
 
@@ -31,8 +31,8 @@
  */
 
 #include "squid-old.h"
-#include "ProtoPort.h"
 #include "acl/FilledChecklist.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
@@ -540,13 +540,12 @@ neighbors_init(void)
     if (Comm::IsConnOpen(icpIncomingConn)) {
 
         for (thisPeer = Config.peers; thisPeer; thisPeer = next) {
-            http_port_list *s = NULL;
             next = thisPeer->next;
 
             if (0 != strcmp(thisPeer->host, me))
                 continue;
 
-            for (s = Config.Sockaddr.http; s; s = s->next) {
+            for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
                 if (thisPeer->http_port != s->s.GetPort())
                     continue;
 
@@ -629,7 +628,8 @@ neighborsUdpPing(HttpRequest * request,
             }
 
             debugs(15, 3, "neighborsUdpPing: sending HTCP query");
-            if (htcpQuery(entry, request, p) <= 0) continue; // unable to send.
+            if (htcpQuery(entry, request, p) <= 0)
+                continue; // unable to send.
         } else
 #endif
         {
@@ -239,8 +239,8 @@ SQUIDCEXTERN int httpReqHdrManglersConfigured();
 #if SQUID_SNMP
 SQUIDCEXTERN PF snmpHandleUdp;
 SQUIDCEXTERN void snmpInit(void);
-SQUIDCEXTERN void snmpConnectionOpen(void);
-SQUIDCEXTERN void snmpConnectionClose(void);
+SQUIDCEXTERN void snmpOpenPorts(void);
+SQUIDCEXTERN void snmpClosePorts(void);
 SQUIDCEXTERN const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
 
 SQUIDCEXTERN void addr2oid(Ip::Address &addr, oid *Dest);
@@ -267,7 +267,7 @@ snmpInit(void)
 }
 
 void
-snmpConnectionOpen(void)
+snmpOpenPorts(void)
 {
     debugs(49, 5, "snmpConnectionOpen: Called");
 
@@ -330,7 +330,7 @@ snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo)
 }
 
 void
-snmpConnectionClose(void)
+snmpClosePorts(void)
 {
     if (Comm::IsConnOpen(snmpIncomingConn)) {
         debugs(49, DBG_IMPORTANT, "Closing SNMP receiving port " << snmpIncomingConn->local);
@@ -33,6 +33,7 @@
  */
 
 #include "squid-old.h"
+#include "comm/Loops.h"
 #include "event.h"
 #include "format/Token.h"
 #include "StoreClient.h"
@@ -1504,9 +1505,9 @@ statCountersInitSpecial(StatCounters * C)
      * Cache Digest Stuff
      */
     C->cd.on_xition_count.enumInit(CacheDigestHashFuncCount);
-    C->comm_icp_incoming.enumInit(INCOMING_ICP_MAX);
+    C->comm_udp_incoming.enumInit(INCOMING_UDP_MAX);
     C->comm_dns_incoming.enumInit(INCOMING_DNS_MAX);
-    C->comm_http_incoming.enumInit(INCOMING_HTTP_MAX);
+    C->comm_tcp_incoming.enumInit(INCOMING_TCP_MAX);
     C->select_fds_hist.enumInit(256);	/* was SQUID_MAXFD, but it is way too much. It is OK to crop this statistics */
 }
 
@@ -1524,9 +1525,9 @@ statCountersClean(StatCounters * C)
     C->icp.replySvcTime.clear();
     C->dns.svcTime.clear();
     C->cd.on_xition_count.clear();
-    C->comm_icp_incoming.clear();
+    C->comm_udp_incoming.clear();
     C->comm_dns_incoming.clear();
-    C->comm_http_incoming.clear();
+    C->comm_tcp_incoming.clear();
     C->select_fds_hist.clear();
 }
 
@@ -1551,8 +1552,9 @@ statCountersCopy(StatCounters * dest, const StatCounters * orig)
     dest->icp.replySvcTime=orig->icp.replySvcTime;
     dest->dns.svcTime=orig->dns.svcTime;
     dest->cd.on_xition_count=orig->cd.on_xition_count;
-    dest->comm_icp_incoming=orig->comm_icp_incoming;
-    dest->comm_http_incoming=orig->comm_http_incoming;
+    dest->comm_udp_incoming=orig->comm_udp_incoming;
+    dest->comm_dns_incoming=orig->comm_dns_incoming;
+    dest->comm_tcp_incoming=orig->comm_tcp_incoming;
     dest->select_fds_hist=orig->select_fds_hist;
 }
 
@@ -145,7 +145,9 @@ class CpuAffinityMap;
 class RemovalPolicySettings;
 class external_acl;
 class Store;
-struct http_port_list;
+namespace AnyP {
+struct PortCfg;
+}
 class SwapDir;
 
 /// Used for boolean enabled/disabled options with complex default logic.
@@ -244,11 +246,10 @@ struct SquidConfig {
     } Port;
 
     struct {
-        http_port_list *http;
+        AnyP::PortCfg *http;
 #if USE_SSL
-        http_port_list *https;
+        AnyP::PortCfg *https;
 #endif
-
     } Sockaddr;
 #if SQUID_SNMP
 
@@ -556,12 +557,10 @@ struct SquidConfig {
 #endif
 
     struct {
-        int icp_average;
-        int dns_average;
-        int http_average;
-        int icp_min_poll;
-        int dns_min_poll;
-        int http_min_poll;
+        struct {
+            int average;
+            int min_poll;
+        } dns, udp, tcp;
     } comm_incoming;
     int max_open_disk_fds;
     int uri_whitespace;
@@ -35,11 +35,12 @@
 #include "squid-old.h"
 #include "base/Subscription.h"
 #include "fde.h"
+#include "htcp.h"
 #include "ICP.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
 #include "MemBuf.h"
-#include "ProtoPort.h"
+#include "anyp/PortCfg.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "ipc/Kids.h"
@@ -88,19 +89,16 @@ SQUIDCEXTERN int setresuid(uid_t, uid_t, uid_t);
 void
 releaseServerSockets(void)
 {
-    int i;
-    /* Release the main ports as early as possible */
+    // Release the main ports as early as possible
 
     // clear both http_port and https_port lists.
-    for (i = 0; i < NHttpSockets; i++) {
-        if (HttpSockets[i] >= 0)
-            close(HttpSockets[i]);
-    }
+    clientHttpConnectionsClose();
 
     // clear icp_port's
-    icpConnectionClose();
+    icpClosePorts();
 
     // XXX: Why not the HTCP, SNMP, DNS ports as well?
+    // XXX: why does this differ from main closeServerConnections() anyway ?
 }
 
 static char *
@@ -1258,7 +1256,7 @@ parseEtcHosts(void)
 int
 getMyPort(void)
 {
-    http_port_list *p = NULL;
+    AnyP::PortCfg *p = NULL;
     if ((p = Config.Sockaddr.http)) {
         // skip any special interception ports
         while (p && (p->intercepted || p->spoof_client_ip))
@@ -159,9 +159,8 @@ int WIN32_getrusage(int who, struct rusage *usage)
     return 0;
 }
 
-
-int Win32__WSAFDIsSet(int fd, fd_set FAR * set
-                     )
+int
+Win32__WSAFDIsSet(int fd, fd_set FAR * set)
 {
     fde *F = &fd_table[fd];
     SOCKET s = F->win32.handle;