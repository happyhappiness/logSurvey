diff --git a/src/connect.c b/src/connect.c
index 2be764d..0f2d925 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -39,7 +39,11 @@ as that of the covered work.  */
 
 #ifndef WINDOWS
 # include <sys/socket.h>
-# include <netdb.h>
+# ifdef __VMS
+#  include "vms_ip.h"
+# else /* def __VMS */
+#  include <netdb.h>
+# endif /* def __VMS [else] */
 # include <netinet/in.h>
 # ifndef __BEOS__
 #  include <arpa/inet.h>
diff --git a/src/convert.c b/src/convert.c
index 2811bff..a34a295 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -400,7 +400,8 @@ write_backup_file (const char *file, downloaded_file_t downloaded_file_return)
   /* Rather than just writing over the original .html file with the
      converted version, save the former to *.orig.  Note we only do
      this for files we've _successfully_ downloaded, so we don't
-     clobber .orig files sitting around from previous invocations. */
+     clobber .orig files sitting around from previous invocations.
+     On VMS, use "_orig" instead of ".orig".  See "wget.h". */
 
   /* Construct the backup filename as the original name plus ".orig". */
   size_t         filename_len = strlen (file);
@@ -422,9 +423,9 @@ write_backup_file (const char *file, downloaded_file_t downloaded_file_return)
   else /* downloaded_file_return == FILE_DOWNLOADED_NORMALLY */
     {
       /* Append ".orig" to the name. */
-      filename_plus_orig_suffix = alloca (filename_len + sizeof (".orig"));
+      filename_plus_orig_suffix = alloca (filename_len + sizeof ("ORIG_SFX"));
       strcpy (filename_plus_orig_suffix, file);
-      strcpy (filename_plus_orig_suffix + filename_len, ".orig");
+      strcpy (filename_plus_orig_suffix + filename_len, "ORIG_SFX");
     }
 
   if (!converted_files)
diff --git a/src/ftp-basic.c b/src/ftp-basic.c
index 38f0069..1dcdfc6 100644
--- a/src/ftp-basic.c
+++ b/src/ftp-basic.c
@@ -887,6 +887,42 @@ ftp_cwd (int csock, const char *dir)
   return FTPOK;
 }
 
+/* Sends DELE command to the FTP server.  */
+uerr_t
+ftp_dele (int csock, const char *file)
+{
+  char *request, *respline;
+  int nwritten;
+  uerr_t err;
+
+  /* Send DELE request.  */
+  request = ftp_request ("DELE", file);
+  nwritten = fd_write (csock, request, strlen (request), -1.0);
+  if (nwritten < 0)
+    {
+      xfree (request);
+      return WRITEFAILED;
+    }
+  xfree (request);
+  /* Get appropriate response.  */
+  err = ftp_response (csock, &respline);
+  if (err != FTPOK)
+    return err;                 /* Return with early bad status. */
+
+  /* All OK, so far.  */
+  if (*respline == '5')
+    {
+      err = FTPNSFOD;           /* Permanent Negative Completion. */
+    }
+  else if (*respline != '2')    /* Success might be 226 or 250 (or ???). */
+    {
+      err = FTPRERR;            /* Not Positive Completion. */
+    }
+
+  xfree (respline);             /* Free "respline" storage. */
+  return err;                   /* Return response-based status code. */
+}
+
 /* Sends REST command to the FTP server.  */
 uerr_t
 ftp_rest (int csock, wgint offset)
@@ -956,7 +992,7 @@ ftp_retr (int csock, const char *file)
 /* Sends the LIST command to the server.  If FILE is NULL, send just
    `LIST' (no space).  */
 uerr_t
-ftp_list (int csock, const char *file)
+ftp_list (int csock, const char *file, enum stype rs)
 {
   char *request, *respline;
   int nwritten;
@@ -967,6 +1003,13 @@ ftp_list (int csock, const char *file)
   const char *list_commands[] = { "LIST -a", 
                                   "LIST" };
 
+  /* 2008-01-29  SMS.  For a VMS FTP server, where "LIST -a" may not
+     fail, but will never do what is desired here, skip directly to the
+     simple "LIST" command (assumed to be the last one in the list).
+  */
+  if (rs == ST_VMS)
+    i = countof (list_commands)- 1;
+
   do {
     /* Send request.  */
     request = ftp_request (list_commands[i], file);
diff --git a/src/ftp-ls.c b/src/ftp-ls.c
index e050c5a..95a8b3d 100644
--- a/src/ftp-ls.c
+++ b/src/ftp-ls.c
@@ -557,27 +557,113 @@ ftp_parse_winnt_ls (const char *file)
   return dir;
 }
 
-/* Converts VMS symbolic permissions to number-style ones, e.g. string
-   RWED,RWE,RE to 755. "D" (delete) is taken to be equal to "W"
-   (write). Inspired by a patch of Stoyan Lekov <lekov@eda.bg>. */
-static int
-vmsperms (const char *s)
-{
-  int perms = 0;
 
-  do
+
+/* Convert the VMS-style directory listing stored in "file" to a
+   linked list of fileinfo (system-independent) entries.  The contents
+   of FILE are considered to be produced by the standard VMS
+   "DIRECTORY [/SIZE [= ALL]] /DATE [/OWNER] [/PROTECTION]" command,
+   more or less.  (Different VMS FTP servers may have different headers,
+   and may not supply the same data, but all should be subsets of this.)
+
+   VMS normally provides local (server) time and date information. 
+   Define the logical name or environment variable
+   "WGET_TIMEZONE_DIFFERENTIAL" (seconds) to adjust the receiving local
+   times if different from the remote local times.
+
+   2005-02-23 SMS.
+   Added code to eliminate "^" escape characters from ODS5 extended file
+   names.  The TCPIP FTP server (V5.4) seems to prefer requests which do
+   not use the escaped names which it provides.
+*/
+
+#define VMS_DEFAULT_PROT_FILE 0644
+#define VMS_DEFAULT_PROT_DIR 0755
+
+/* 2005-02-23 SMS.
+   eat_carets().
+
+   Delete ODS5 extended file name escape characters ("^") in the
+   original buffer.
+   Note that the current scheme does not handle all EFN cases, but it
+   could be made more complicated.
+*/
+
+static void eat_carets( char *str)
+/* char *str;      Source pointer. */
+{
+  char *strd;   /* Destination pointer. */
+  char hdgt;
+  unsigned char uchr;
+  unsigned char prop;
+
+  /* Skip ahead to the first "^", if any. */
+  while ((*str != '\0') && (*str != '^'))
+     str++;
+
+  /* If no caret was found, quit early. */
+  if (*str != '\0')
+  {
+    /* Shift characters leftward as carets are found. */
+    strd = str;
+    while (*str != '\0')
     {
-      switch (*s) {
-        case ',': perms <<= 3; break;
-        case 'R': perms  |= 4; break;
-        case 'W': perms  |= 2; break;
-        case 'D': perms  |= 2; break;
-        case 'E': perms  |= 1; break;
-        default:  DEBUGP(("wrong VMS permissons!\n")); 
+      uchr = *str;
+      if (uchr == '^')
+      {
+        /* Found a caret.  Skip it, and check the next character. */
+        uchr = *(++str);
+        prop = char_prop[ uchr];
+        if (prop& 64)
+        {
+          /* Hex digit.  Get char code from this and next hex digit. */
+          if (uchr <= '9')
+          {
+            hdgt = uchr- '0';           /* '0' - '9' -> 0 - 9. */
+          }
+          else
+          {
+            hdgt = ((uchr- 'A')& 7)+ 10;    /* [Aa] - [Ff] -> 10 - 15. */
+          }
+          hdgt <<= 4;                   /* X16. */
+          uchr = *(++str);              /* Next char must be hex digit. */
+          if (uchr <= '9')
+          {
+            uchr = hdgt+ uchr- '0';
+          }
+          else
+          {
+            uchr = hdgt+ ((uchr- 'A')& 15)+ 10;
+          }
+        }
+        else if (uchr == '_')
+        {
+          /* Convert escaped "_" to " ". */
+          uchr = ' ';
+        }
+        else if (uchr == '/')
+        {
+          /* Convert escaped "/" (invalid Zip) to "?" (invalid VMS). */
+          /* Note that this is a left-over from Info-ZIP code, and is
+             probably of little value here, except perhaps to avoid
+             directory confusion which an unconverted slash might cause.
+          */
+          uchr = '?';
+        }
+        /* Else, not a hex digit.  Must be a simple escaped character
+           (or Unicode, which is not yet handled here).
+        */
       }
+      /* Else, not a caret.  Use as-is. */
+      *strd = uchr;
+
+      /* Advance destination and source pointers. */
+      strd++;
+      str++;
     }
-  while (*++s);
-  return perms;
+    /* Terminate the destination string. */
+    *strd = '\0';
+  }
 }
 
 
@@ -585,20 +671,16 @@ static struct fileinfo *
 ftp_parse_vms_ls (const char *file)
 {
   FILE *fp;
-  /* #### A third copy of more-or-less the same array ? */
-  static const char *months[] = {
-    "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
-    "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"
-  };
-  int i;
-  int year, month, day;          /* for time analysis */
-  int hour, min, sec;
+  int dt, i, j, len;
+  int perms;
+  time_t timenow;
   struct tm timestruct;
+  char date_str[ 32];
 
-  char *line, *tok;              /* tokenizer */
+  char *line, *tok;		 /* tokenizer */
   struct fileinfo *dir, *l, cur; /* list creation */
 
-  fp = fopen (file, "rb");
+  fp = fopen (file, "r");
   if (!fp)
     {
       logprintf (LOG_NOTQUIET, "%s: %s\n", file, strerror (errno));
@@ -606,188 +688,334 @@ ftp_parse_vms_ls (const char *file)
     }
   dir = l = NULL;
 
-  /* Skip empty line. */
-  line = read_whole_line (fp);
-  xfree_null (line);
+  /* Skip blank lines, Directory heading, and more blank lines. */
 
-  /* Skip "Directory PUB$DEVICE[PUB]" */
-  line = read_whole_line (fp);
-  xfree_null (line);
+  j = 0; /* Expecting initial blank line(s). */
+  while (1)
+    {
+      line = read_whole_line (fp);
+      if (line == NULL)
+        {
+        break;
+        }
+      else
+        {
+          i = clean_line (line);
+          if (i <= 0)
+            {
+              xfree (line); /* Free useless line storage. */
+              continue; /* Blank line.  Keep looking. */
+            }
+          else
+            {
+              if ((j == 0) && (line[ i- 1] == ']'))
+                {
+                  /* Found Directory heading line.  Next non-blank line
+                  is significant.
+                  */
+                  j = 1;
+                }
+              else if (!strncmp (line, "Total of ", 9))
+                {
+                  /* Found "Total of ..." footing line.  No valid data
+                     will follow (empty directory).
+                  */
+                  xfree (line); /* Free useless line storage. */
+                  line = NULL; /* Arrange for early exit. */
+                  break;
+                }
+              else
+                {
+                  break; /* Must be significant data. */
+                }
+            }
+          xfree (line); /* Free useless line storage. */
+        }
+    }
 
-  /* Skip empty line. */
-  line = read_whole_line (fp);
-  xfree_null (line);
+  /* Read remainder of file until the next blank line or EOF. */
 
-  /* Line loop to end of file: */
-  while ((line = read_whole_line (fp)) != NULL)
+  while (line != NULL)
     {
       char *p;
-      i = clean_line (line);
-      if (!i)
-        {
-          xfree (line);
-          break;
-        }
 
-      /* First column: Name. A bit of black magic again. The name my be
-         either ABCD.EXT or ABCD.EXT;NUM and it might be on a separate
-         line. Therefore we will first try to get the complete name
-         until the first space character; if it fails, we assume that the name
-         occupies the whole line. After that we search for the version
-         separator ";", we remove it and check the extension of the file;
-         extension .DIR denotes directory. */
+      /* The first token is the file name.  After a long name, other
+         data may be on the following line.  A valid directory name ends
+         in ".DIR;1" (any case), although some VMS FTP servers may omit
+         the version number (";1").
+      */
 
       tok = strtok(line, " ");
       if (tok == NULL) tok = line;
-      DEBUGP(("file name: '%s'\n", tok));
-      for (p = tok ; *p && *p != ';' ; p++)
-        ;
-      if (*p == ';') *p = '\0';
-      p   = tok + strlen(tok) - 4;
-      if (!strcmp(p, ".DIR")) *p = '\0';
-      cur.name = xstrdup(tok);
-      DEBUGP(("Name: '%s'\n", cur.name));
-
-      /* If the name ends on .DIR or .DIR;#, it's a directory. We also set
-         the file size to zero as the listing does tell us only the size in
-         filesystem blocks - for an integrity check (when mirroring, for
-         example) we would need the size in bytes. */
-      
-      if (! *p)
+      DEBUGP(("file name:   '%s'\n", tok));
+
+      /* Stripping the version number on a VMS system would be wrong.
+         It may be foolish on a non-VMS system, too, but that's someone
+         else's problem.  (Define PRESERVE_VMS_VERSIONS for proper
+         operation on other operating systems.)
+
+         2005-02-23 SMS.
+         ODS5 extended file names may contain escaped semi-colons, so
+         the version number is identified as right-side decimal digits
+         led by a non-escaped semi-colon.  It may be absent.
+      */
+
+#if (!defined( __VMS) && !defined( PRESERVE_VMS_VERSIONS))
+      for (p = tok+ strlen( tok); (--p > tok) && ISDIGIT( *p); );
+      if ((*p == ';') && (*(p- 1) != '^'))
+        {
+          *p = '\0';
+        }
+#endif /* (!defined( __VMS) && !defined( PRESERVE_VMS_VERSIONS)) */
+
+      /* 2005-02-23 SMS.
+         Eliminate "^" escape characters from ODS5 extended file name. 
+         (A caret is invalid in an ODS2 name, so this is always safe.)
+      */
+      eat_carets( tok);
+      DEBUGP(("file name-^: '%s'\n", tok));
+
+      /* Differentiate between a directory and any other file.  A VMS
+         listing may not include file protections (permissions).  Set a
+         default permissions value (according to the file type), which
+         may be overwritten later.  Store directory names without the
+         ".DIR;1" file type and version number, as the plain name is
+         what will work in a CWD command.
+      */
+      len = strlen( tok);
+      if (!strncasecmp( (tok+ (len- 4)), ".DIR", 4))
         {
+          *(tok+ (len -= 4)) = '\0'; /* Discard ".DIR". */
           cur.type  = FT_DIRECTORY;
-          cur.size  = 0;
-          DEBUGP(("Directory\n"));
+          cur.perms = VMS_DEFAULT_PROT_DIR;
+          DEBUGP(("Directory (nv)\n"));
+        }
+      else if (!strncasecmp( (tok+ (len- 6)), ".DIR;1", 6))
+        {
+          *(tok+ (len -= 6)) = '\0'; /* Discard ".DIR;1". */
+          cur.type  = FT_DIRECTORY;
+          cur.perms = VMS_DEFAULT_PROT_DIR;
+          DEBUGP(("Directory (v)\n"));
         }
       else
         {
           cur.type  = FT_PLAINFILE;
+          cur.perms = VMS_DEFAULT_PROT_FILE;
           DEBUGP(("File\n"));
         }
+      cur.name = xstrdup(tok);
+      DEBUGP(("Name: '%s'\n", cur.name));
+
+      /* Null the date and time string. */
+      *date_str = '\0';
 
+      /* VMS lacks symbolic links. */
+      cur.linkto = NULL;
+
+      /* VMS reports file sizes in (512-byte) disk blocks, not bytes,
+         hence useless for an integrity check based on byte-count.
+         Set size to unknown.
+      */
       cur.size  = 0;
 
-      /* Second column, if exists, or the first column of the next line
-         contain file size in blocks. We will skip it. */
+      /* Get token 2, if any.  A long name may force all other data onto
+         a second line.  If needed, read the second line.
+      */
 
       tok = strtok(NULL, " ");
       if (tok == NULL) 
-      {
-        DEBUGP(("Getting additional line\n"));
-        xfree (line);
-        line = read_whole_line (fp);
-        if (!line)
-        {
-          DEBUGP(("empty line read, leaving listing parser\n"));
-          break;
-        }
-        i = clean_line (line);
-        if (!i) 
         {
-          DEBUGP(("confusing VMS listing item, leaving listing parser\n"));
+          DEBUGP(("Getting additional line.\n"));
           xfree (line);
-          break;
-        }
-        tok = strtok(line, " ");
-      }
-      DEBUGP(("second token: '%s'\n", tok));
-
-      /* Third/Second column: Date DD-MMM-YYYY. */
-
-      tok = strtok(NULL, "-");
-      if (tok == NULL) continue;
-      DEBUGP(("day: '%s'\n",tok));
-      day = atoi(tok);
-      tok = strtok(NULL, "-");
-      if (!tok)
-      {
-        /* If the server produces garbage like
-           'EA95_0PS.GZ;1      No privilege for attempted operation'
-           the first strtok(NULL, "-") will return everything until the end
-           of the line and only the next strtok() call will return NULL. */
-        DEBUGP(("nonsense in VMS listing, skipping this line\n"));
-        xfree (line);
-        break;
-      }
-      for (i=0; i<12; i++) if (!strcmp(tok,months[i])) break;
-      /* Uknown months are mapped to January */
-      month = i % 12 ; 
-      tok = strtok (NULL, " ");
-      if (tok == NULL) continue;
-      year = atoi (tok) - 1900;
-      DEBUGP(("date parsed\n"));
-
-      /* Fourth/Third column: Time hh:mm[:ss] */
-      tok = strtok (NULL, " ");
-      if (tok == NULL) continue;
-      min = sec = 0;
-      p = tok;
-      hour = atoi (p);
-      for (; *p && *p != ':'; ++p)
-        ;
-      if (*p)
-        min = atoi (++p);
-      for (; *p && *p != ':'; ++p)
-        ;
-      if (*p)
-        sec = atoi (++p);
-
-      DEBUGP(("YYYY/MM/DD HH:MM:SS - %d/%02d/%02d %02d:%02d:%02d\n", 
-              year+1900, month, day, hour, min, sec));
-      
-      /* Build the time-stamp (copy & paste from above) */
-      timestruct.tm_sec   = sec;
-      timestruct.tm_min   = min;
-      timestruct.tm_hour  = hour;
-      timestruct.tm_mday  = day;
-      timestruct.tm_mon   = month;
-      timestruct.tm_year  = year;
-      timestruct.tm_wday  = 0;
-      timestruct.tm_yday  = 0;
-      timestruct.tm_isdst = -1;
-      cur.tstamp = mktime (&timestruct); /* store the time-stamp */
-
-      DEBUGP(("Timestamp: %ld\n", cur.tstamp));
-
-      /* Skip the fifth column */
-
-      tok = strtok(NULL, " ");
-      if (tok == NULL) continue;
+          line = read_whole_line (fp);
+          if (!line)
+            {
+              DEBUGP(("EOF.  Leaving listing parser.\n"));
+              break;
+            }
 
-      /* Sixth column: Permissions */
+          /* Second line must begin with " ".  Otherwise, it's a first
+             line (and we may be confused).
+          */
+          if (i <= 0)
+	    {
+              /* Blank line.  End of significant file listing. */
+              DEBUGP(("Blank line.  Leaving listing parser.\n"));
+              xfree (line); /* Free useless line storage. */
+	      break;
+	    }
+          else if (line[ 0] != ' ')
+            {
+              DEBUGP(("Non-blank in column 1.  Must be a new file name?\n"));
+              continue;
+            }
+          else
+            {
+              tok = strtok (line, " ");
+              if (tok == NULL)
+                {
+                  /* Unexpected non-empty but apparently blank line. */
+                  DEBUGP(("Null token.  Leaving listing parser.\n"));
+                  xfree (line); /* Free useless line storage. */
+                  break;
+                }
+            }
+        }
 
-      tok = strtok(NULL, ","); /* Skip the VMS-specific SYSTEM permissons */
-      if (tok == NULL) continue;
-      tok = strtok(NULL, ")");
-      if (tok == NULL)
+      /* Analyze tokens.  (Order is not significant, except date must
+         precede time.)
+
+         Size:       ddd or ddd/ddd (where "ddd" is a decimal number)
+         Date:       DD-MMM-YYYY
+         Time:       HH:MM or HH:MM:SS or HH:MM:SS.CC
+         Owner:      [user] or [user,group]
+         Protection: (ppp,ppp,ppp,ppp) (where "ppp" is "RWED" or some
+                     subset thereof, for System, Owner, Group, World.
+
+         If permission is lacking, info may be replaced by the string:
+         "No privilege for attempted operation".
+      */
+      while (tok != NULL)
+	{
+	  DEBUGP (("Token: >%s<: ", tok));
+
+	  if ((strlen( tok) < 12) && (strchr( tok, '-') != NULL))
+	    {
+	      /* Date. */
+	      DEBUGP (("Date.\n"));
+	      strcpy( date_str, tok);
+	      strcat( date_str, " ");
+	    }
+	  else if ((strlen( tok) < 12) && (strchr( tok, ':') != NULL))
+	    {
+	      /* Time. */
+	      DEBUGP (("Time. "));
+	      strncat( date_str,
+	       tok,
+	       (sizeof( date_str)- strlen( date_str)- 1));
+	      DEBUGP (("Date time: >%s<\n", date_str));
+	    }
+	  else if (strchr( tok, '[') != NULL)
+	    {
+	      /* Owner.  (Ignore.) */
+	      DEBUGP (("Owner.\n"));
+	    }
+	  else if (strchr( tok, '(') != NULL)
+	    {
+	      /* Protections (permissions). */
+	      perms = 0;
+	      j = 0;
+	      for (i = 0; i < strlen( tok); i++)
+		{
+		  switch (tok[ i])
+		    {
+		      case '(':
+		        break;
+		      case ')':
+		        break;
+		      case ',':
+		        if (j == 0)
+		          {
+		            perms = 0;
+		            j = 1;
+		          }
+		        else
+		          {
+		            perms <<= 3;
+		          }
+		        break;
+		    case 'R':
+		      perms |= 4;
+		      break;
+		    case 'W':
+		      perms |= 2;
+		      break;
+		    case 'E':
+		      perms |= 1;
+		      break;
+		    case 'D':
+		      perms |= 2;
+		      break;
+		    }
+		}
+	      cur.perms = perms;
+	      DEBUGP (("Prot.  perms = %0o.\n", cur.perms));
+	    }
+	  else
+	    {
+	      /* Nondescript.  Probably size(s), probably in blocks. 
+                 Could be "No privilege ..." message.  (Ignore.)
+              */
+	      DEBUGP (("Ignored (size?).\n"));
+	    }
+
+	  tok = strtok (NULL, " ");
+	}
+
+      /* Tokens exhausted.  Interpret the data, and fill in the
+         structure.
+      */
+      /* Fill tm timestruct according to date-time string.  Fractional
+         seconds are ignored.  Default to current time, if conversion
+         fails.
+      */
+      timenow = time( NULL);
+      localtime_r( &timenow, &timestruct);
+      strptime( date_str, "%d-%b-%Y %H:%M:%S", &timestruct);
+
+      /* Convert struct tm local time to time_t local time. */
+      timenow = mktime (&timestruct);
+      /* Offset local time according to environment variable (seconds). */
+      if ((tok = getenv( "WGET_TIMEZONE_DIFFERENTIAL")) != NULL)
         {
-          DEBUGP(("confusing VMS permissions, skipping line\n"));
-          xfree (line);
-          continue;
+          dt = atoi( tok);
+          DEBUGP (("Time differential = %d.\n", dt));
+        }
+      else
+        {
+          dt = 0;
         }
-      /* Permissons have the format "RWED,RWED,RE" */
-      cur.perms = vmsperms(tok);
-      DEBUGP(("permissions: %s -> 0%o\n", tok, cur.perms));
 
-      cur.linkto = NULL;
+      if (dt >= 0)
+        {
+          timenow += dt;
+        }
+      else
+        {
+          timenow -= (-dt);
+        }
+      cur.tstamp = timenow; /* Store the time-stamp. */
+      DEBUGP(("Timestamp: %ld\n", cur.tstamp));
 
-      /* And put everything into the linked list */
+      /* Add the data for this item to the linked list, */
       if (!dir)
         {
-          l = dir = xnew (struct fileinfo);
+          l = dir = (struct fileinfo *)xmalloc (sizeof (struct fileinfo));
           memcpy (l, &cur, sizeof (cur));
           l->prev = l->next = NULL;
         }
       else
         {
           cur.prev = l;
-          l->next = xnew (struct fileinfo);
+          l->next = (struct fileinfo *)xmalloc (sizeof (struct fileinfo));
           l = l->next;
           memcpy (l, &cur, sizeof (cur));
           l->next = NULL;
         }
 
+      /* Free old line storage.  Read a new line. */
       xfree (line);
+      line = read_whole_line (fp);
+      if (line != NULL)
+        {
+          i = clean_line (line);
+          if (i <= 0)
+	    {
+              /* Blank line.  End of significant file listing. */
+              xfree (line); /* Free useless line storage. */
+	      break;
+	    }
+        }
     }
 
   fclose (fp);
diff --git a/src/ftp.c b/src/ftp.c
index 0321032..9bc92a8 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -50,6 +50,11 @@ as that of the covered work.  */
 #include "convert.h"            /* for downloaded_file */
 #include "recur.h"              /* for INFINITE_RECURSION */
 
+#ifdef __VMS
+# include "vms.h"
+#endif /* def __VMS */
+
+
 /* File where the "ls -al" listing will be saved.  */
 #ifdef MSDOS
 #define LIST_FILENAME "_listing"
@@ -245,6 +250,7 @@ getftp (struct url *u, wgint *len, wgint restval, ccon *con)
   bool rest_failed = false;
   int flags;
   wgint rd_size;
+  char type_char;
 
   assert (con != NULL);
   assert (con->target != NULL);
@@ -272,7 +278,6 @@ getftp (struct url *u, wgint *len, wgint restval, ccon *con)
     csock = con->csock;
   else                          /* cmd & DO_LOGIN */
     {
-      char type_char;
       char    *host = con->proxy ? con->proxy->host : u->host;
       int      port = con->proxy ? con->proxy->port : u->port;
       char *logname = user;
@@ -404,6 +409,17 @@ Error in server response, closing control connection.\n"));
         default:
           abort ();
         }
+
+#if 0
+      /* 2004-09-17 SMS.
+         Don't help me out.  Please.
+         A reasonably recent VMS FTP server will cope just fine with
+         UNIX file specifications.  This code just spoils things.
+         Discarding the device name, for example, is not a wise move.
+         This code was disabled but left in as an example of what not
+         to do.
+      */
+
       /* VMS will report something like "PUB$DEVICE:[INITIAL.FOLDER]".
          Convert it to "/INITIAL/FOLDER" */ 
       if (con->rs == ST_VMS)
@@ -427,6 +443,8 @@ Error in server response, closing control connection.\n"));
               DEBUGP (("  new = '%s'\n\n", con->id));
             }
         }
+#endif /* 0 */
+
       if (!opt.server_response)
         logputs (LOG_VERBOSE, _("done.\n"));
 
@@ -476,6 +494,11 @@ Error in server response, closing control connection.\n"));
         logputs (LOG_VERBOSE, _("==> CWD not needed.\n"));
       else
         {
+          char *targ;
+	  int cwd_count;
+	  int cwd_end;
+	  int cwd_start;
+
           char *target = u->dir;
 
           DEBUGP (("changing working directory\n"));
@@ -494,11 +517,26 @@ Error in server response, closing control connection.\n"));
              in "bar", not in "foo/bar", as would be customary
              elsewhere.  */
 
+            /* 2004-09-20 SMS.
+               Why is this wise even on UNIX?  It certainly fouls VMS.
+               See below for a more reliable, more universal method.
+            */
+ 
+            /* 2008-04-22 MJC.
+               I'm not crazy about it either. I'm informed it's useful
+               for misconfigured servers that have some dirs in the path
+               with +x but -r, but this method is not RFC-conformant. I
+               understand the need to deal with crappy server
+               configurations, but it's far better to use the canonical
+               method first, and fall back to kludges second.
+            */
+
           if (target[0] != '/'
               && !(con->rs != ST_UNIX
                    && c_isalpha (target[0])
                    && target[1] == ':')
-              && con->rs != ST_OS400)
+              && (con->rs != ST_OS400)
+              && (con->rs != ST_VMS))
             {
               int idlen = strlen (con->id);
               char *ntarget, *p;
@@ -518,6 +556,17 @@ Error in server response, closing control connection.\n"));
               target = ntarget;
             }
 
+#if 0
+          /* 2004-09-17 SMS.
+             Don't help me out.  Please.
+             A reasonably recent VMS FTP server will cope just fine with
+             UNIX file specifications.  This code just spoils things.
+             Discarding the device name, for example, is not a wise
+             move.
+             This code was disabled but left in as an example of what
+             not to do.
+          */
+
           /* If the FTP host runs VMS, we will have to convert the absolute
              directory path in UNIX notation to absolute directory path in
              VMS notation as VMS FTP servers do not like UNIX notation of
@@ -543,10 +592,97 @@ Error in server response, closing control connection.\n"));
               DEBUGP (("  Unix: '%s'\n  VMS: '%s'\n", target, ntarget));
               target = ntarget;
             }
+#endif /* 0 */
+
+          /* 2004-09-20 SMS.
+             A relative directory is relative to the initial directory. 
+             Thus, what _is_ useful on VMS (and probably elsewhere) is
+             to CWD to the initial directory (ideally, whatever the
+             server reports, _exactly_, NOT badly UNIX-ixed), and then
+             CWD to the (new) relative directory.  This should probably
+             be restructured as a function, called once or twice, but
+             I'm lazy enough to take the badly indented loop short-cut
+             for now.
+          */
+
+          /* Decide on one pass (absolute) or two (relative).
+             The VMS restriction may be relaxed when the squirrely code
+             above is reformed.
+          */
+	  if ((con->rs == ST_VMS) && (target[0] != '/'))
+	    {
+	      cwd_start = 0;
+	      DEBUGP (("Using two-step CWD for relative path.\n"));
+	    }
+	  else
+	    {
+              /* Go straight to the target. */
+	      cwd_start = 1;
+	    }
+
+          /* At least one VMS FTP server (TCPware V5.6-2) can switch to
+             a UNIX emulation mode when given a UNIX-like directory
+             specification (like "a/b/c").  If allowed to continue this
+             way, LIST interpretation will be confused, because the
+             system type (SYST response) will not be re-checked, and
+             future UNIX-format directory listings (for multiple URLs or
+             "-r") will be horribly misinterpreted.
+
+             The cheap and nasty work-around is to do a "CWD []" after a
+             UNIX-like directory specification is used.  (A single-level
+             directory is harmless.)  This puts the TCPware server back
+             into VMS mode, and does no harm on other servers.
+
+             Unlike the rest of this block, this particular behavior
+             _is_ VMS-specific, so it gets its own VMS test.
+          */
+	  if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))
+            {
+              cwd_end = 3;
+	      DEBUGP (("Using extra \"CWD []\" step for VMS server.\n"));
+            }
+          else
+            {
+              cwd_end = 2;
+            }
+
+          /* 2004-09-20 SMS. */
+          /* Sorry about the deviant indenting.  Laziness. */
+
+	  for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)
+	{
+          switch (cwd_count)
+            {
+              case 0:
+	        /* Step one (optional): Go to the initial directory,
+	           exactly as reported by the server.
+	        */
+	        targ = con->id;
+                break;
+
+              case 1:
+	        /* Step two: Go to the target directory.  (Absolute or
+	           relative will work now.)
+	        */
+	        targ = target;
+                break;
+
+              case 2:
+                /* Step three (optional): "CWD []" to restore server
+                   VMS-ness.
+                */
+                targ = "[]";
+                break;
+
+              default:
+                /* Can't happen. */
+                assert (1);
+	    }
 
           if (!opt.server_response)
-            logprintf (LOG_VERBOSE, "==> CWD %s ... ", escnonprint (target));
-          err = ftp_cwd (csock, target);
+            logprintf (LOG_VERBOSE, "==> CWD (%d) %s ... ",
+             cwd_count, escnonprint (target));
+          err = ftp_cwd (csock, targ);
           /* FTPRERR, WRITEFAILED, FTPNSFOD */
           switch (err)
             {
@@ -578,7 +714,13 @@ Error in server response, closing control connection.\n"));
             }
           if (!opt.server_response)
             logputs (LOG_VERBOSE, _("done.\n"));
-        }
+
+        } /* for */
+
+          /* 2004-09-20 SMS. */
+          /* End of deviant indenting. */
+
+        } /* else */
     }
   else /* do not CWD */
     logputs (LOG_VERBOSE, _("==> CWD not required.\n"));
@@ -829,6 +971,10 @@ Error in server response, closing control connection.\n"));
           fd_close (local_sock);
           return err;
         case FTPOK:
+          if (getenv( "FTP_DELETE") != NULL)
+          {
+            err = ftp_dele (csock, u->file);
+          }
           break;
         default:
           abort ();
@@ -846,7 +992,7 @@ Error in server response, closing control connection.\n"));
       /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'
          without arguments is better than `LIST .'; confirmed by
          RFC959.  */
-      err = ftp_list (csock, NULL);
+      err = ftp_list (csock, NULL, con->rs);
       /* FTPRERR, WRITEFAILED */
       switch (err)
         {
@@ -912,17 +1058,86 @@ Error in server response, closing control connection.\n"));
     }
 
   /* Open the file -- if output_stream is set, use it instead.  */
+  
+  /* 2005-04-17 SMS.
+     Note that having the output_stream ("-O") file opened in main()
+     (main.c) rather limits the ability in VMS to open the file
+     differently for ASCII versus binary FTP here.  (Of course, doing it
+     there allows a open failure to be detected immediately, without first
+     connecting to the server.)
+  */
   if (!output_stream || con->cmd & DO_LIST)
     {
+/* On VMS, alter the name as required. */
+#ifdef __VMS
+      char *targ;
+
+      targ = ods_conform( con->target);
+      if (targ != con->target)
+        {
+          xfree( con->target);
+          con->target = targ;
+        }
+#endif /* def __VMS */
+ 
       mkalldirs (con->target);
       if (opt.backups)
         rotate_backups (con->target);
 
+/* 2005-04-15 SMS.
+   For VMS, define common fopen() optional arguments, and a handy macro
+   for use as a variable "binary" flag.
+   Elsewhere, define a constant "binary" flag.
+   Isn't it nice to have distinct text and binary file types?
+*/
+# define BIN_TYPE_TRANSFER (type_char != 'A')
+#ifdef __VMS
+# define FOPEN_OPT_ARGS "fop=sqo", "acc", acc_cb, &open_id
+# define FOPEN_OPT_ARGS_BIN "ctx=bin,stm", "rfm=fix", "mrs=512" FOPEN_OPT_ARGS
+# define BIN_TYPE_FILE (BIN_TYPE_TRANSFER && (opt.ftp_stmlf == 0))
+#else /* def __VMS */
+# define BIN_TYPE_FILE 1
+#endif /* def __VMS [else] */
+ 
       if (restval && !(con->cmd & DO_LIST))
-        fp = fopen (con->target, "ab");
+        {
+#ifdef __VMS
+          int open_id;
+
+          if (BIN_TYPE_FILE)
+            {
+              open_id = 3;
+              fp = fopen (con->target, "ab", FOPEN_OPT_ARGS_BIN);
+            }
+          else
+            {
+              open_id = 4;
+              fp = fopen (con->target, "a", FOPEN_OPT_ARGS);
+            }
+#else /* def __VMS */
+          fp = fopen (con->target, "ab");
+#endif /* def __VMS [else] */
+        }
       else if (opt.noclobber || opt.always_rest || opt.timestamping || opt.dirstruct
                || opt.output_document)
-        fp = fopen (con->target, "wb");
+        {
+#ifdef __VMS
+          int open_id;
+
+          if (BIN_TYPE_FILE)
+            {
+              open_id = 5;
+              fp = fopen (con->target, "wb", FOPEN_OPT_ARGS_BIN);
+            }
+          else
+            {
+              open_id = 6;
+              fp = fopen (con->target, "w", FOPEN_OPT_ARGS);
+            }
+#else /* def __VMS */
+          fp = fopen (con->target, "wb");
+#endif /* def __VMS [else] */
+        }
       else
         {
           fp = fopen_excl (con->target, true);
@@ -1049,6 +1264,22 @@ Error in server response, closing control connection.\n"));
      print it out.  */
   if (opt.server_response && (con->cmd & DO_LIST))
     {
+/* 2005-02-25 SMS.
+   Much of this work may already have been done, but repeating it should
+   do no damage beyond wasting time.
+*/
+/* On VMS, alter the name as required. */
+#ifdef __VMS
+      char *targ;
+
+      targ = ods_conform( con->target);
+      if (targ != con->target)
+        {
+          xfree( con->target);
+          con->target = targ;
+        }
+#endif /* def __VMS */
+
       mkalldirs (con->target);
       fp = fopen (con->target, "r");
       if (!fp)
@@ -1088,8 +1319,21 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
   uerr_t err;
   struct_stat st;
 
-  if (!con->target)
-    con->target = url_file_name (u);
+  /* Get the target, and set the name for the message accordingly. */
+  if ((f == NULL) && (con->target))
+    {
+      /* Explicit file (like ".listing"). */
+      locf = con->target;
+    }
+  else
+    {
+      /* URL-derived file.  Consider "-O file" name. */
+      con->target = url_file_name (u);
+      if (!opt.output_document)
+        locf = con->target;
+      else
+        locf = opt.output_document;
+    }
 
   if (opt.noclobber && file_exists_p (con->target))
     {
@@ -1101,10 +1345,6 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
 
   /* Remove it if it's a link.  */
   remove_link (con->target);
-  if (!opt.output_document)
-    locf = con->target;
-  else
-    locf = opt.output_document;
 
   count = 0;
 
@@ -1360,7 +1600,8 @@ ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
   struct fileinfo *orig;
   wgint local_size;
   time_t tml;
-  bool dlthis;
+  bool dlthis; /* Download this (file). */
+  const char *actual_target = NULL;
 
   /* Increase the depth.  */
   ++depth;
@@ -1529,37 +1770,51 @@ Already have correct symlink %s -> %s\n\n"),
           break;
         }       /* switch */
 
+
+      /* 2004-12-15 SMS.
+       * Set permissions _before_ setting the times, as setting the
+       * permissions changes the modified-time, at least on VMS.
+       * Also, use the opt.output_document name here, too, as
+       * appropriate.  (Do the test once, and save the result.)
+       */
+
+      /* #### This code repeats in http.c and ftp.c.  Move it to a
+         function!  */
+      actual_target = NULL;
+      if (opt.output_document)
+        {
+          if (output_stream_regular)
+            actual_target = opt.output_document;
+        }
+      else
+        actual_target = con->target;
+
+      /* If downloading a plain file, set valid (non-zero) permissions. */
+      if (dlthis && (actual_target != NULL) && (f->type == FT_PLAINFILE))
+        {
+          if (f->perms)
+            chmod (actual_target, f->perms);
+          else
+            DEBUGP (("Unrecognized permissions for %s.\n", actual_target));
+        }
+
       /* Set the time-stamp information to the local file.  Symlinks
          are not to be stamped because it sets the stamp on the
          original.  :( */
-      if (!(f->type == FT_SYMLINK && !opt.retr_symlinks)
-          && f->tstamp != -1
-          && dlthis
-          && file_exists_p (con->target))
+
+      if (actual_target != NULL)
         {
-          /* #### This code repeats in http.c and ftp.c.  Move it to a
-             function!  */
-          const char *fl = NULL;
-          if (opt.output_document)
+          if (!(f->type == FT_SYMLINK && !opt.retr_symlinks)
+              && f->tstamp != -1
+              && dlthis
+              && file_exists_p (con->target))
             {
-              if (output_stream_regular)
-                fl = opt.output_document;
+              touch (actual_target, f->tstamp);
             }
-          else
-            fl = con->target;
-          if (fl)
-            touch (fl, f->tstamp);
-        }
-      else if (f->tstamp == -1)
-        logprintf (LOG_NOTQUIET, _("%s: corrupt time-stamp.\n"), con->target);
-
-      if (f->perms && f->type == FT_PLAINFILE && dlthis)
-        {
-          if (opt.preserve_perm)
-            chmod (con->target, f->perms);
+          else if (f->tstamp == -1)
+            logprintf (LOG_NOTQUIET, _("%s: corrupt time-stamp.\n"),
+            actual_target);
         }
-      else
-        DEBUGP (("Unrecognized permissions for %s.\n", con->target));
 
       xfree (con->target);
       con->target = old_target;
@@ -1776,13 +2031,18 @@ ftp_retrieve_glob (struct url *u, ccon *con, int action)
           logprintf (LOG_VERBOSE, _("No matches on pattern `%s'.\n"),
                      escnonprint (u->file));
         }
-      else /* GLOB_GETONE or GLOB_GETALL */
+      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */
         {
           /* Let's try retrieving it anyway.  */
           con->st |= ON_YOUR_OWN;
           res = ftp_loop_internal (u, NULL, con);
           return res;
         }
+
+      /* If action == GLOB_GETALL, and the file list is empty, there's
+         no point in trying to download anything or in complaining about
+         it.  (An empty directory should not cause complaints.)
+      */
     }
   freefileinfo (start);
   if (opt.quota && total_downloaded_bytes > opt.quota)
diff --git a/src/ftp.h b/src/ftp.h
index 02cd85e..9aa88d8 100644
--- a/src/ftp.h
+++ b/src/ftp.h
@@ -58,9 +58,10 @@ uerr_t ftp_epsv (int, ip_address *, int *);
 #endif
 uerr_t ftp_type (int, int);
 uerr_t ftp_cwd (int, const char *);
+uerr_t ftp_dele (int, const char *);
 uerr_t ftp_retr (int, const char *);
 uerr_t ftp_rest (int, wgint);
-uerr_t ftp_list (int, const char *);
+uerr_t ftp_list (int, const char *, enum stype);
 uerr_t ftp_syst (int, enum stype *);
 uerr_t ftp_pwd (int, char **);
 uerr_t ftp_size (int, const char *, wgint *);
diff --git a/src/host.c b/src/host.c
index 5a53022..57f63ef 100644
--- a/src/host.c
+++ b/src/host.c
@@ -41,7 +41,11 @@ as that of the covered work.  */
 # ifndef __BEOS__
 #  include <arpa/inet.h>
 # endif
-# include <netdb.h>
+# ifdef __VMS
+#  include "vms_ip.h"
+# else /* def __VMS */
+#  include <netdb.h>
+# endif /* def __VMS [else] */
 # define SET_H_ERRNO(err) ((void)(h_errno = (err)))
 #else  /* WINDOWS */
 # define SET_H_ERRNO(err) WSASetLastError (err)
diff --git a/src/host.h b/src/host.h
index 5141a6f..10f5424 100644
--- a/src/host.h
+++ b/src/host.h
@@ -34,7 +34,11 @@ as that of the covered work.  */
 #ifdef WINDOWS
 # include <winsock.h>
 #else
-# include <netdb.h>
+# ifdef __VMS
+#  include "vms_ip.h"
+# else /* def __VMS */
+#  include <netdb.h>
+# endif /* def __VMS [else] */
 # include <sys/socket.h>
 # include <netinet/in.h>
 #ifndef __BEOS__
diff --git a/src/http.c b/src/http.c
index ec815c8..d9c85ed 100644
--- a/src/http.c
+++ b/src/http.c
@@ -66,7 +66,11 @@ as that of the covered work.  */
 #include "test.h"
 #endif
 
-extern char *version_string;
+#include "version.h"
+
+#ifdef __VMS
+# include "vms.h"
+#endif /* def __VMS */
 
 /* Forward decls. */
 static char *create_authorization_line (const char *, const char *,
@@ -1333,13 +1337,27 @@ free_hstat (struct http_stat *hs)
    && (c_isspace (line[sizeof (string_constant) - 1])                      \
        || !line[sizeof (string_constant) - 1]))
 
+#ifdef __VMS
+#define SET_USER_AGENT(req) do {                                         \
+  if (!opt.useragent)                                                    \
+    request_set_header (req, "User-Agent",                               \
+                        aprintf ("Wget/%s (VMS %s %s)",                  \
+                        VERSION_STRING, vms_arch(), vms_vers()),         \
+                        rel_value);                                      \
+  else if (*opt.useragent)                                               \
+    request_set_header (req, "User-Agent", opt.useragent, rel_none);     \
+} while (0)
+#else /* def __VMS */
 #define SET_USER_AGENT(req) do {                                         \
   if (!opt.useragent)                                                    \
     request_set_header (req, "User-Agent",                               \
-                        aprintf ("Wget/%s", version_string), rel_value); \
+                        aprintf ("Wget/%s (%s)",                         \
+                        VERSION_STRING, OS_TYPE),                        \
+                        rel_value);                                      \
   else if (*opt.useragent)                                               \
     request_set_header (req, "User-Agent", opt.useragent, rel_none);     \
 } while (0)
+#endif /* def __VMS [else] */
 
 /* The flags that allow clobbering the file (opening with "wb").
    Defined here to avoid repetition later.  #### This will require
@@ -1731,7 +1749,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 
       if (conn->scheme == SCHEME_HTTPS)
         {
-          if (!ssl_connect (sock) || !ssl_check_certificate (sock, u->host))
+          if (!ssl_connect_wget (sock) || !ssl_check_certificate (sock, u->host))
             {
               fd_close (sock);
               return CONSSLERR;
@@ -1852,7 +1870,7 @@ File `%s' already there; not retrieving.\n\n"), hs->local_file);
   if (opt.timestamping && !hs->timestamp_checked)
     {
       size_t filename_len = strlen (hs->local_file);
-      char *filename_plus_orig_suffix = alloca (filename_len + sizeof (".orig"));
+      char *filename_plus_orig_suffix = alloca (filename_len + sizeof (ORIG_SFX));
       bool local_dot_orig_file_exists = false;
       char *local_filename = NULL;
       struct_stat st;
@@ -1877,7 +1895,7 @@ File `%s' already there; not retrieving.\n\n"), hs->local_file);
              --hniksic */
           memcpy (filename_plus_orig_suffix, hs->local_file, filename_len);
           memcpy (filename_plus_orig_suffix + filename_len,
-                  ".orig", sizeof (".orig"));
+                  ORIG_SFX, sizeof (ORIG_SFX));
 
           /* Try to stat() the .orig file. */
           if (stat (filename_plus_orig_suffix, &st) == 0)
@@ -2235,6 +2253,16 @@ File `%s' already there; not retrieving.\n\n"), hs->local_file);
       return RETRFINISHED;
     }
 
+/* 2005-06-17 SMS.
+   For VMS, define common fopen() optional arguments.
+*/
+#ifdef __VMS
+# define FOPEN_OPT_ARGS "fop=sqo", "acc", acc_cb, &open_id
+# define FOPEN_BIN_FLAG 3
+#else /* def __VMS */
+# define FOPEN_BIN_FLAG 1
+#endif /* def __VMS [else] */
+
   /* Open the local file.  */
   if (!output_stream)
     {
@@ -2242,9 +2270,27 @@ File `%s' already there; not retrieving.\n\n"), hs->local_file);
       if (opt.backups)
         rotate_backups (hs->local_file);
       if (hs->restval)
-        fp = fopen (hs->local_file, "ab");
+        {
+#ifdef __VMS
+          int open_id;
+
+          open_id = 21;
+          fp = fopen (hs->local_file, "ab", FOPEN_OPT_ARGS);
+#else /* def __VMS */
+          fp = fopen (hs->local_file, "ab");
+#endif /* def __VMS [else] */
+        }
       else if (ALLOW_CLOBBER)
-        fp = fopen (hs->local_file, "wb");
+        {
+#ifdef __VMS
+          int open_id;
+
+          open_id = 22;
+          fp = fopen (hs->local_file, "wb", FOPEN_OPT_ARGS);
+#else /* def __VMS */
+          fp = fopen (hs->local_file, "wb");
+#endif /* def __VMS [else] */
+        }
       else
         {
           fp = fopen_excl (hs->local_file, true);
@@ -2718,7 +2764,7 @@ Remote file exists.\n\n"));
                   && hstat.remote_time && hstat.remote_time[0])
                 {
                   newtmr = http_atotm (hstat.remote_time);
-                  if (newtmr != -1)
+                  if (newtmr != (time_t)-1)
                     tmr = newtmr;
                 }
               touch (fl, tmr);
diff --git a/src/init.c b/src/init.c
index e957e52..43a0f95 100644
--- a/src/init.c
+++ b/src/init.c
@@ -160,6 +160,9 @@ static const struct {
   { "ftppasswd",        &opt.ftp_passwd,        cmd_string }, /* deprecated */
   { "ftppassword",      &opt.ftp_passwd,        cmd_string },
   { "ftpproxy",         &opt.ftp_proxy,         cmd_string },
+#ifdef __VMS
+  { "ftpstmlf",         &opt.ftp_stmlf,         cmd_boolean },
+#endif /* def __VMS */
   { "ftpuser",          &opt.ftp_user,          cmd_string },
   { "glob",             &opt.ftp_glob,          cmd_boolean },
   { "header",           NULL,                   cmd_spec_header },
@@ -393,11 +396,16 @@ wgetrc_file_name (void)
       return xstrdup (env);
     }
 
-  /* If that failed, try $HOME/.wgetrc.  */
+  /* If that failed, try $HOME/.wgetrc (or equivalent).  */
+
+#ifdef __VMS
+  file = "SYS$LOGIN:.wgetrc";
+#else /* def __VMS */
   home = home_dir ();
   if (home)
     file = aprintf ("%s/.wgetrc", home);
   xfree_null (home);
+#endif /* def __VMS [else] */
 
 #ifdef WINDOWS
   /* Under Windows, if we still haven't found .wgetrc, look for the file
@@ -446,7 +454,7 @@ run_wgetrc (const char *file)
   int ln;
   int errcnt = 0;
 
-  fp = fopen (file, "rb");
+  fp = fopen (file, "r");
   if (!fp)
     {
       fprintf (stderr, _("%s: Cannot read %s (%s).\n"), exec_name,
diff --git a/src/log.c b/src/log.c
index 078a7ac..cbdf59f 100644
--- a/src/log.c
+++ b/src/log.c
@@ -43,6 +43,19 @@ as that of the covered work.  */
 #include "utils.h"
 #include "log.h"
 
+/* 2005-10-25 SMS.
+   VMS log files are often VFC record format, not stream, so fputs() can
+   produce multiple records, even when there's no newline terminator in
+   the buffer.  The result is unsightly output with spurious newlines.
+   Using fprintf() instead of fputs(), along with inhibiting some
+   fflush() activity below, seems to solve the problem.
+*/
+#ifdef __VMS
+# define FPUTS( s, f) fprintf( (f), "%s", (s))
+#else /* def __VMS */
+# define FPUTS( s, f) fputs( (s), (f))
+#endif /* def __VMS [else] */
+
 /* This file impplement support for "logging".  Logging means printing
    output, plus several additional features:
 
@@ -307,7 +320,7 @@ logputs (enum log_options o, const char *s)
     return;
   CHECK_VERBOSE (o);
 
-  fputs (s, fp);
+  FPUTS (s, fp);
   if (save_context_p)
     saved_append (s);
   if (flush_log_p)
@@ -397,7 +410,7 @@ log_vprintf_internal (struct logvprintf_state *state, const char *fmt,
 
   /* Writing succeeded. */
   saved_append (write_ptr);
-  fputs (write_ptr, fp);
+  FPUTS (write_ptr, fp);
   if (state->bigmsg)
     xfree (state->bigmsg);
 
@@ -416,7 +429,19 @@ logflush (void)
 {
   FILE *fp = get_log_fp ();
   if (fp)
-    fflush (fp);
+    {
+/* 2005-10-25 SMS.
+   On VMS, flush only for a terminal.  See note at FPUTS macro, above.
+*/
+#ifdef __VMS
+      if (isatty( fileno( fp)))
+        {
+          fflush (fp);
+        }
+#else /* def __VMS */
+      fflush (fp);
+#endif /* def __VMS [else] */
+    }
   needs_flushing = false;
 }
 
@@ -583,13 +608,13 @@ log_dump_context (void)
     {
       struct log_ln *ln = log_lines + num;
       if (ln->content)
-        fputs (ln->content, fp);
+        FPUTS (ln->content, fp);
       ROT_ADVANCE (num);
     }
   while (num != log_line_current);
   if (trailing_line)
     if (log_lines[log_line_current].content)
-      fputs (log_lines[log_line_current].content, fp);
+      FPUTS (log_lines[log_line_current].content, fp);
   fflush (fp);
 }
 
diff --git a/src/main.c b/src/main.c
index b1e9969..3e32c40 100644
--- a/src/main.c
+++ b/src/main.c
@@ -57,6 +57,12 @@ as that of the covered work.  */
 
 #include <getopt.h>
 
+#ifdef __VMS
+#include "vms.h"
+#endif /* __VMS */
+
+#include "version.h"
+
 #ifndef PATH_SEPARATOR
 # define PATH_SEPARATOR '/'
 #endif
@@ -167,6 +173,9 @@ static struct cmdline_option option_data[] =
     { "force-directories", 'x', OPT_BOOLEAN, "dirstruct", -1 },
     { "force-html", 'F', OPT_BOOLEAN, "forcehtml", -1 },
     { "ftp-password", 0, OPT_VALUE, "ftppassword", -1 },
+#ifdef __VMS
+    { "ftp-stmlf", 0, OPT_BOOLEAN, "ftpstmlf", -1 },
+#endif /* def __VMS */
     { "ftp-user", 0, OPT_VALUE, "ftpuser", -1 },
     { "glob", 0, OPT_BOOLEAN, "glob", -1 },
     { "header", 0, OPT_VALUE, "header", -1 },
@@ -568,6 +577,10 @@ HTTPS (SSL/TLS) options:\n"),
 
     N_("\
 FTP options:\n"),
+#ifdef __VMS
+    N_("\
+       --ftp-stmlf             Use Stream_LF format for all binary FTP files.\n"),
+#endif /* def __VMS */
     N_("\
        --ftp-user=USER         set ftp user to USER.\n"),
     N_("\
@@ -594,8 +607,13 @@ Recursive download:\n"),
        --delete-after       delete files locally after downloading them.\n"),
     N_("\
   -k,  --convert-links      make links in downloaded HTML point to local files.\n"),
+#ifdef __VMS
+    N_("\
+  -K,  --backup-converted   before converting file X, back up as X_orig.\n"),
+#else /* def __VMS */
     N_("\
   -K,  --backup-converted   before converting file X, back up as X.orig.\n"),
+#endif /* def __VMS [else] */
     N_("\
   -m,  --mirror             shortcut for -N -r -l inf --no-remove-listing.\n"),
     N_("\
@@ -638,7 +656,7 @@ Recursive accept/reject:\n"),
   int i;
 
   printf (_("GNU Wget %s, a non-interactive network retriever.\n"),
-          version_string);
+          VERSION_STRING);
   print_usage ();
 
   for (i = 0; i < countof (help); i++)
@@ -676,7 +694,12 @@ secs_to_human_time (double interval)
 static void
 print_version (void)
 {
-  printf ("GNU Wget %s\n\n", version_string);
+#ifdef __VMS
+  printf ("GNU Wget %s built on VMS %s %s.\n\n",
+   VERSION_STRING, vms_arch(), vms_vers());
+#else /* def __VMS */
+  printf ("GNU Wget %s built on %s.\n\n", VERSION_STRING, OS_TYPE);
+#endif /* def __VMS */
   /* TRANSLATORS: When available, an actual copyright character
      (cirle-c) should be used in preference to "(C)". */
   fputs (_("\
@@ -939,10 +962,19 @@ Can't timestamp and not clobber old files at the same time.\n"));
   /* Initialize logging.  */
   log_init (opt.lfilename, append_to_log);
 
-  DEBUGP (("DEBUG output created by Wget %s on %s.\n\n", version_string,
-           OS_TYPE));
+  DEBUGP (("DEBUG output created by Wget %s on %s.\n\n",
+           VERSION_STRING, OS_TYPE));
 
   /* Open the output filename if necessary.  */
+
+/* 2005-04-17 SMS.
+   Note that having the output_stream ("-O") file opened here for an FTP
+   URL rather than in getftp() (ftp.c) (and the http equivalent) rather
+   limits the ability in VMS to open the file differently for ASCII
+   versus binary FTP there.  (Of course, doing it here allows a open
+   failure to be detected immediately, without first connecting to the
+   server.)
+*/
   if (opt.output_document)
     {
       if (HYPHENP (opt.output_document))
@@ -950,8 +982,20 @@ Can't timestamp and not clobber old files at the same time.\n"));
       else
         {
           struct_fstat st;
+
+#ifdef __VMS
+/* Common fopen() optional arguments:
+   sequential access only, access callback function.
+*/
+# define FOPEN_OPT_ARGS , "fop=sqo", "acc", acc_cb, &open_id
+          int open_id = 7;
+#else /* def __VMS */
+# define FOPEN_OPT_ARGS
+#endif /* def __VMS [else] */
+
           output_stream = fopen (opt.output_document,
-                                 opt.always_rest ? "ab" : "wb");
+                                 opt.always_rest ? "ab" : "wb"
+                                 FOPEN_OPT_ARGS);
           if (output_stream == NULL)
             {
               perror (opt.output_document);
@@ -962,6 +1006,20 @@ Can't timestamp and not clobber old files at the same time.\n"));
         }
     }
 
+#ifdef __VMS
+  /* Set global ODS5 flag according to the specified destination (if
+     any), otherwise according to the current default device.
+  */
+  if (output_stream == NULL)
+    {
+      set_ods5_dest( "SYS$DISK");
+    }
+  else if (output_stream != stdout)
+    {
+      set_ods5_dest( opt.output_document);
+    }
+#endif /* def __VMS */
+
 #ifdef WINDOWS
   ws_startup ();
 #endif
diff --git a/src/netrc.c b/src/netrc.c
index fea440d..e6c0d12 100644
--- a/src/netrc.c
+++ b/src/netrc.c
@@ -65,6 +65,21 @@ search_netrc (const char *host, const char **acc, const char **passwd,
   /* Find ~/.netrc.  */
   if (!processed_netrc)
     {
+#ifdef __VMS
+
+      int err;
+      struct_stat buf;
+      char *path = "SYS$LOGIN:.netrc";
+
+      netrc_list = NULL;
+      processed_netrc = 1;
+
+      err = stat (path, &buf);
+      if (err == 0)
+        netrc_list = parse_netrc (path);
+
+#else /* def __VMS */
+
       char *home = home_dir ();
 
       netrc_list = NULL;
@@ -81,6 +96,8 @@ search_netrc (const char *host, const char **acc, const char **passwd,
           if (err == 0)
             netrc_list = parse_netrc (path);
         }
+
+#endif /* def __VMS [else] */
     }
   /* If nothing to do...  */
   if (!netrc_list)
diff --git a/src/openssl.c b/src/openssl.c
index c33b4ad..21dbc3b 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -383,7 +383,7 @@ static struct transport_implementation openssl_transport = {
    Returns true on success, false on failure.  */
 
 bool
-ssl_connect (int fd) 
+ssl_connect_wget (int fd) 
 {
   SSL *conn;
   struct openssl_transport_context *ctx;
@@ -466,7 +466,7 @@ pattern_match (const char *pattern, const char *string)
    its certificate, corresponds to HOST.  (HOST typically comes from
    the URL and is what the user thinks he's connecting to.)
 
-   This assumes that ssl_connect has successfully finished, i.e. that
+   This assumes that ssl_connect_wget has successfully finished, i.e. that
    the SSL handshake has been performed and that FD is connected to an
    SSL handle.
 
diff --git a/src/options.h b/src/options.h
index a4fa2f0..e0d7521 100644
--- a/src/options.h
+++ b/src/options.h
@@ -235,7 +235,12 @@ struct options
   
   bool content_disposition;	/* Honor HTTP Content-Disposition header. */
   bool auth_without_challenge;  /* Issue Basic authentication creds without
-                                   waiting for a challenge. */
+                                  waiting for a challenge. */
+
+#ifdef __VMS
+  int ftp_stmlf;                /* Force Stream_LF format for binary FTP. */
+#endif /* def __VMS */
+
 };
 
 extern struct options opt;
diff --git a/src/retr.c b/src/retr.c
index 179430a..b5a10e2 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -141,8 +141,10 @@ limit_bandwidth (wgint bytes, struct ptimer *timer)
 
 static int
 write_data (FILE *out, const char *buf, int bufsize, wgint *skip,
-            wgint *written)
+            wgint *written, int flags)
 {
+  static int cr_pending = 0;    /* Found CR in ASCII FTP data. */
+
   if (!out)
     return 1;
   if (*skip > bufsize)
@@ -159,14 +161,89 @@ write_data (FILE *out, const char *buf, int bufsize, wgint *skip,
         return 1;
     }
 
-  fwrite (buf, 1, bufsize, out);
-  *written += bufsize;
+/* Note: This code assumes that "\n" is the universal line ending
+   character, as on UNIX and VMS.  If this is not true, then here's
+   where to change it.
+*/
+
+#if 1
+# define EOL_STRING "\n"
+#else /* 1 */
+# define EOL_STRING "\r\n"
+#endif /* 1 [else] */
+#define EOL_STRING_LEN (sizeof( EOL_STRING)- 1)
+
+  if (flags & rb_ftp_ascii)
+    {
+      const char *bufend;
+
+      /* ASCII transfer.  Put out lines delimited by CRLF. */
+      bufend = buf+ bufsize;
+      while (buf < bufend)
+        {
+          /* If CR, put out any pending CR, then set CR-pending flag. */
+          if (*buf == '\r')
+            {
+              if (cr_pending)
+                {
+                  fwrite ("\r", 1, 1, out);
+                  *written += 1;
+                }
+              cr_pending = 1;
+              buf++;
+              continue;
+            }
+
+          if (cr_pending)
+            {
+              if (*buf == '\n')
+                {
+                  /* Found FTP EOL (CRLF).  Put out local EOL. */
+                  fwrite (EOL_STRING, 1, EOL_STRING_LEN, out);
+                  *written += EOL_STRING_LEN;
+                }
+              else
+                {
+                  /* Normal character.  Put out pending CR and it. */
+                  fwrite ("\r", 1, 1, out);
+                  fwrite (buf, 1, 1, out);
+                  *written += 2;
+                }
+              buf++;
+              cr_pending = 0;
+            }
+          else
+            {
+              /* Normal character.  Put it out. */
+              fwrite (buf, 1, 1, out);
+              *written += 1;
+              buf++;
+            }
+        }
+    }
+  else
+    {
+      /* Image transfer.  Put out buffer. */
+      fwrite (buf, 1, bufsize, out);
+      *written += bufsize;
+    }
 
   /* Immediately flush the downloaded data.  This should not hinder
      performance: fast downloads will arrive in large 16K chunks
      (which stdio would write out immediately anyway), and slow
      downloads wouldn't be limited by disk speed.  */
+
+  /* 2005-04-20 SMS.
+     Perhaps it shouldn't hinder performance, but it sure does, at least
+     on VMS (more than 2X).  Rather than speculate on what it should or
+     shouldn't do, it might make more sense to test it.  Even better, it
+     might be nice to explain what possible benefit it could offer, as
+     it appears to be a clear invitation to poor performance with no
+     actual justification.  (Also, why 16K?  Anyone test other values?)
+  */
+#ifndef __VMS
   fflush (out);
+#endif /* ndef __VMS */
   return !ferror (out);
 }
 
@@ -296,7 +373,7 @@ fd_read_body (int fd, FILE *out, wgint toread, wgint startpos,
       if (ret > 0)
         {
           sum_read += ret;
-          if (!write_data (out, dlbuf, ret, &skip, &sum_written))
+          if (!write_data (out, dlbuf, ret, &skip, &sum_written, flags))
             {
               ret = -2;
               goto out;
diff --git a/src/retr.h b/src/retr.h
index ec55cfd..0f92026 100644
--- a/src/retr.h
+++ b/src/retr.h
@@ -41,7 +41,8 @@ extern bool output_stream_regular;
 /* Flags for fd_read_body. */
 enum {
   rb_read_exactly  = 1,
-  rb_skip_startpos = 2
+  rb_skip_startpos = 2,
+  rb_ftp_ascii     = 4
 };
 
 int fd_read_body (int, FILE *, wgint, wgint, wgint *, wgint *, double *, int);
diff --git a/src/ssl.h b/src/ssl.h
index 67fcda5..97be516 100644
--- a/src/ssl.h
+++ b/src/ssl.h
@@ -33,7 +33,7 @@ as that of the covered work.  */
 #define GEN_SSLFUNC_H
 
 bool ssl_init (void);
-bool ssl_connect (int);
+bool ssl_connect_wget (int);
 bool ssl_check_certificate (int, const char *);
 
 #endif /* GEN_SSLFUNC_H */
diff --git a/src/url.c b/src/url.c
index a561725..a84d5db 100644
--- a/src/url.c
+++ b/src/url.c
@@ -43,6 +43,10 @@ as that of the covered work.  */
 #include "url.h"
 #include "host.h"  /* for is_valid_ipv6_address */
 
+#ifdef __VMS
+#include "vms.h"
+#endif /* def __VMS */
+
 #ifdef TESTING
 #include "test.h"
 #endif
@@ -1503,11 +1507,30 @@ url_file_name (const struct url *u)
 
   if ((opt.noclobber || opt.always_rest || opt.timestamping || opt.dirstruct)
       && !(file_exists_p (fname) && !file_non_directory_p (fname)))
-    return fname;
+    {
+      unique = fname;
+    }
+  else
+    {
+      unique = unique_name (fname, true);
+      if (unique != fname)
+        xfree (fname);
+    }
+
+/* On VMS, alter the name as required. */
+#ifdef __VMS
+  {
+    char *unique2;
+
+    unique2 = ods_conform( unique);
+    if (unique2 != unique)
+      {
+        xfree (unique);
+        unique = unique2;
+      }
+  }
+#endif /* def __VMS */
 
-  unique = unique_name (fname, true);
-  if (unique != fname)
-    xfree (fname);
   return unique;
 }
 
diff --git a/src/utils.c b/src/utils.c
index a4928da..8c5c8dc 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -84,10 +84,95 @@ as that of the covered work.  */
 #include "utils.h"
 #include "hash.h"
 
+#ifdef __VMS
+#include "vms.h"
+#endif /* def __VMS */
+
 #ifdef TESTING
 #include "test.h"
 #endif 
 
+/* Character property table for (re-)escaping VMS ODS5 extended file
+   names.  Note that this table ignores Unicode.
+
+   ODS2 valid characters: 0-9 A-Z a-z $ - _ ~
+
+   ODS5 Invalid characters:
+      C0 control codes (0x00 to 0x1F inclusive)
+      Asterisk (*)
+      Question mark (?)
+
+   ODS5 Invalid characters only in VMS V7.2 (which no one runs, right?):
+      Double quotation marks (")
+      Backslash (\)
+      Colon (:)
+      Left angle bracket (<)
+      Right angle bracket (>)
+      Slash (/)
+      Vertical bar (|)
+
+   Characters escaped by "^":
+      SP  !  #  %  &  '  (  )  +  ,  .  ;  =  @  [  ]  ^  `  {  }  ~
+
+   Either "^_" or "^ " is accepted as a space.  Period (.) is a special
+   case.  Note that un-escaped < and > can also confuse a directory
+   spec.
+
+   Characters put out as ^xx:
+      7F (DEL)
+      80-9F (C1 control characters)
+      A0 (nonbreaking space)
+      FF (Latin small letter y diaeresis)
+
+   Other cases:
+      Unicode: "^Uxxxx", where "xxxx" is four hex digits.
+
+    Property table values:
+      Normal escape:    1
+      Space:            2
+      Dot:              4
+      Hex-hex escape:   8
+      ODS2 normal:     16
+      ODS2 lower case: 32
+      Hex digit:       64
+*/
+
+unsigned char char_prop[ 256] = {
+
+/* NUL SOH STX ETX EOT ENQ ACK BEL   BS  HT  LF  VT  FF  CR  SO  SI */
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+
+/* DLE DC1 DC2 DC3 DC4 NAK SYN ETB  CAN  EM SUB ESC  FS  GS  RS  US */
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+
+/*  SP  !   "   #   $   %   &   '    (   )   *   +   ,   -   .   /  */
+    2,  1,  0,  1, 16,  1,  1,  1,   1,  1,  0,  1,  1, 16,  4,  0,
+
+/*  0   1   2   3   4   5   6   7    8   9   :   ;   <   =   >   ?  */
+   80, 80, 80, 80, 80, 80, 80, 80,  80, 80,  0,  1,  1,  1,  1,  1,
+
+/*  @   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O  */
+    1, 80, 80, 80, 80, 80, 80, 16,  16, 16, 16, 16, 16, 16, 16, 16,
+
+/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _  */
+   16, 16, 16, 16, 16, 16, 16, 16,  16, 16, 16,  1,  0,  1,  1, 16,
+
+/*  `   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o  */
+    1, 96, 96, 96, 96, 96, 96, 32,  32, 32, 32, 32, 32, 32, 32, 32,
+
+/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~  DEL */
+   32, 32, 32, 32, 32, 32, 32, 32,  32, 32, 32,  1,  0,  1, 17,  8,
+
+    8,  8,  8,  8,  8,  8,  8,  8,   8,  8,  8,  8,  8,  8,  8,  8,
+    8,  8,  8,  8,  8,  8,  8,  8,   8,  8,  8,  8,  8,  8,  8,  8,
+    8,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  8
+};
+
 /* Utility function: like xstrdup(), but also lowercases S.  */
 
 char *
@@ -314,6 +399,16 @@ datetime_str (time_t t)
 /* The Windows versions of the following two functions are defined in
    mswindows.c. On MSDOS this function should never be called. */
 
+#ifdef __VMS
+
+void
+fork_to_background (void)
+{
+  return;
+}
+
+#else /* def __VMS */
+
 #if !defined(WINDOWS) && !defined(MSDOS)
 void
 fork_to_background (void)
@@ -359,6 +454,9 @@ fork_to_background (void)
   freopen ("/dev/null", "w", stderr);
 }
 #endif /* !WINDOWS && !MSDOS */
+
+#endif /* def __VMS [else] */
+
 
 /* "Touch" FILE, i.e. make its mtime ("modified time") equal the time
    specified with TM.  The atime ("access time") is set to the current
@@ -457,6 +555,14 @@ file_size (const char *filename)
 #endif
 }
 
+/* 2005-02-19 SMS.
+   If no UNIQ_SEP is defined (as on VMS), have unique_name() return the
+   original name.  With the VMS file systems' versioning, everything
+   should be fine, and appending ".NN" just causes trouble.
+*/
+
+#ifdef UNIQ_SEP
+
 /* stat file names named PREFIX.1, PREFIX.2, etc., until one that
    doesn't exist is found.  Return a freshly allocated copy of the
    unused file name.  */
@@ -470,7 +576,7 @@ unique_name_1 (const char *prefix)
   char *template_tail = template + plen;
 
   memcpy (template, prefix, plen);
-  *template_tail++ = '.';
+  *template_tail++ = UNIQ_SEP;
 
   do
     number_to_string (template_tail, count++);
@@ -485,6 +591,8 @@ unique_name_1 (const char *prefix)
    If not, FILE.1 is tried, then FILE.2, etc.  The first FILE.<number>
    file name that doesn't exist is returned.
 
+   2005-02-19 SMS.  "." is now UNIQ_SEP, and may be different.
+
    The resulting file is not created, only verified that it didn't
    exist at the point in time when the function was called.
    Therefore, where security matters, don't rely that the file created
@@ -508,6 +616,20 @@ unique_name (const char *file, bool allow_passthrough)
   return unique_name_1 (file);
 }
 
+#else /* def UNIQ_SEP */
+
+/* Dummy unique_name() for VMS.  Return the original name as easily as
+   possible.
+*/
+char *
+unique_name (const char *file, bool allow_passthrough)
+{
+  /* Return the FILE itself, without modification, irregardful. */
+  return allow_passthrough ? (char *)file : xstrdup (file);
+}
+
+#endif /* def UNIQ_SEP [else] */
+
 /* Create a file based on NAME, except without overwriting an existing
    file with that name.  Providing O_EXCL is correctly implemented,
    this function does not have the race condition associated with
@@ -554,12 +676,61 @@ fopen_excl (const char *fname, bool binary)
 {
   int fd;
 #ifdef O_EXCL
+
+/* 2005-04-14 SMS.
+   VMS lacks O_BINARY, but makes up for it in weird and wonderful ways.
+   It also has file versions which obviate all the O_EXCL effort.
+   O_TRUNC (something of a misnomer) requests a new version.
+*/
+# ifdef __VMS
+/* Common open() optional arguments:
+   sequential access only, access callback function.
+*/
+#  define OPEN_OPT_ARGS "fop=sqo", "acc", acc_cb, &open_id
+
+  int open_id;
+  int flags = O_WRONLY | O_CREAT | O_TRUNC;
+
+  if (binary > 1)
+    {
+      open_id = 11;
+      fd = open( fname,                 /* File name. */
+       flags,                           /* Flags. */
+       0777,                            /* Mode for default protection. */
+       "ctx=bin,stm",                   /* Binary, stream access. */
+       "rfm=stmlf",                     /* Stream_LF. */
+       OPEN_OPT_ARGS);                  /* Access callback. */
+    }
+  else if (binary)
+    {
+      open_id = 12;
+      fd = open( fname,                 /* File name. */
+       flags,                           /* Flags. */
+       0777,                            /* Mode for default protection. */
+       "ctx=bin,stm",                   /* Binary, stream access. */
+       "rfm=fix",                       /* Fixed-length, */
+       "mrs=512",                       /* 512-byte records. */
+       OPEN_OPT_ARGS);                  /* Access callback. */
+    }
+  else
+    {
+      open_id = 13;
+      fd = open( fname,                 /* File name. */
+       flags,                           /* Flags. */
+       0777,                            /* Mode for default protection.
+*/
+       "rfm=stmlf",                     /* Stream_LF. */
+       OPEN_OPT_ARGS);                  /* Access callback. */
+    }
+# else /* def __VMS */
   int flags = O_WRONLY | O_CREAT | O_EXCL;
 # ifdef O_BINARY
   if (binary)
     flags |= O_BINARY;
 # endif
   fd = open (fname, flags, 0666);
+# endif /* def __VMS [else] */
+
   if (fd < 0)
     return NULL;
   return fdopen (fd, binary ? "wb" : "w");
diff --git a/src/utils.h b/src/utils.h
index 7d41b31..456a9c9 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -126,4 +126,6 @@ void stable_sort (void *, size_t, size_t, int (*) (const void *, const void *));
 
 const char *print_decimal (double);
 
+extern unsigned char char_prop[];
+
 #endif /* UTILS_H */
diff --git a/src/version.h b/src/version.h
new file mode 100644
index 0000000..a7073b6
--- /dev/null
+++ b/src/version.h
@@ -0,0 +1,35 @@
+/* Program version
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+This file is part of GNU Wget.
+
+GNU Wget is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+GNU Wget is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Wget.  If not, see <http://www.gnu.org/licenses/>.
+
+Additional permission under GNU GPL version 3 section 7
+
+If you modify this program, or any covered work, by linking or
+combining it with the OpenSSL project's OpenSSL library (or a
+modified version of that library), containing parts covered by the
+terms of the OpenSSL or SSLeay licenses, the Free Software Foundation
+grants you additional permission to convey the resulting work.
+Corresponding Source for a non-source form of such a combination
+shall include the source code for the parts of OpenSSL used as well
+as that of the covered work.  */
+
+#ifndef VERSION_H
+#define VERSION_H
+
+#define VERSION_STRING "1.11a"
+
+#endif /* def VERSION_H */
diff --git a/src/wget.h b/src/wget.h
index 08d8d83..22164ce 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -155,7 +155,7 @@ as that of the covered work.  */
 #else
   /* Fall back to using long, which is always available and in most
      cases large enough. */
-typedef long off_t;
+  typedef long wgint;
 # define SIZEOF_WGINT SIZEOF_LONG
 #endif
 
@@ -339,4 +339,34 @@ typedef enum
   AUTHFAILED, QUOTEXC, WRITEFAILED, SSLINITFAILED
 } uerr_t;
 
+/* 2005-02-19 SMS.
+   Select an appropriate "orig" suffix and a separator character for
+   adding a unique suffix to a file name.
+
+   A VMS ODS2 file system can not tolerate multiple dots.  An ODS5 file
+   system can, but even there not all dots are equal, and heroic effort
+   would be needed to get ".html^.orig" rather than (the less desirable)
+   "^.html.orig".  It's more satisfactory always to use "_orig" on VMS
+   (rather than including "vms.h", testing "ods5_dest", and acting
+   accordingly).
+
+   Note that code in various places assumes that this string is five
+   characters long.
+*/
+# ifdef __VMS
+#  define ORIG_SFX "_orig"
+# else /* def __VMS */
+#  define ORIG_SFX ".orig"
+# endif /* def __VMS [else] */
+
+/* ".NNN" unique-ifying suffix separator character for unique_name() in
+   url.c (and anywhere else).  Note that on VMS, the file system's
+   version numbers solve the problem that unique_name() is designed to
+   handle, obviating this whole exercise.  Other systems may specify a
+   character different from "." here, if desired.
+*/
+# ifndef __VMS
+#  define UNIQ_SEP '.'
+# endif /* ndef __VMS */
+
 #endif /* WGET_H */
diff --git a/vms/COLLECT_DEPS.COM b/vms/COLLECT_DEPS.COM
new file mode 100644
index 0000000..8db4154
--- /dev/null
+++ b/vms/COLLECT_DEPS.COM
@@ -0,0 +1,89 @@
+$!                                              12 April 2005.  SMS.
+$!
+$!    Collect all source file dependencies specified by P2,
+$!    and add P3 prefix.
+$!    Convert absolute dependencies to relative from P4.
+$!    P1 = output file specification.
+$!
+$! MMS /EXTENDED_SYNTAX can't easily pass a macro invocation for P3, so
+$! we remove any internal spaces which might have been added to prevent
+$! immediate evaluation of a macro invocation.
+$!
+$ prefix = f$edit( p3, "COLLAPSE")
+$!
+$ dev_lose = f$parse( p4, , , "DEVICE", "SYNTAX_ONLY")
+$ dir_lose = f$parse( p4, , , "DIRECTORY", "SYNTAX_ONLY")
+$ suffix = ".VMS]"
+$ suffix_loc = f$locate( suffix, dir_lose)
+$ if (suffix_loc .lt f$length( dir_lose))
+$ then
+$    dev_dir_lose = dev_lose+ dir_lose- suffix
+$ else
+$    dev_dir_lose = dev_lose+ dir_lose- "]"
+$ endif
+$!
+$!!! write sys$output " d_d_l: ""''dev_dir_lose'""."
+$!
+$! For portability, make the output file record format Stream_LF.
+$!
+$ create /fdl = sys$input 'p1'
+RECORD
+        Carriage_Control carriage_return
+        Format stream_lf
+$!
+$ open /read /write /error = end_main deps_out 'p1'
+$ on error then goto loop_main_end
+$!
+$! Include proper-inclusion-check preface.
+$!
+$ incl_macro = "INCL_"+ f$parse( p1, , , "NAME", "SYNTAX_ONLY")
+$ write deps_out "#"
+$ write deps_out "# Wget for VMS - MMS (or MMK) Source Dependency File."
+$ write deps_out "#"
+$ write deps_out ""
+$ write deps_out -
+   "# This description file is included by other description files.  It is"
+$ write deps_out -
+   "# not intended to be used alone.  Verify proper inclusion."
+$ write deps_out ""
+$ write deps_out ".IFDEF ''incl_macro'"
+$ write deps_out ".ELSE"
+$ write deps_out -
+   "$$$$ THIS DESCRIPTION FILE IS NOT INTENDED TO BE USED THIS WAY."
+$ write deps_out ".ENDIF"
+$ write deps_out ""
+$!
+$! Actual dependencies from individual dependency files.
+$!
+$ loop_main_top:
+$    file = f$search( p2)
+$    if (file .eqs. "") then goto loop_main_end
+$!
+$    open /read /error = end_subs deps_in 'file'
+$    loop_subs_top:
+$       read /error = loop_subs_end deps_in line
+$       line_reduced = f$edit( line, "COMPRESS, TRIM")
+$       colon = f$locate( " : ", line_reduced)
+$       if (colon .ge. f$length( line_reduced)) then goto loop_subs_top
+$       d_d_l_loc = f$locate( dev_dir_lose, -
+         f$extract( (colon+ 3), 1000, line_reduced))
+$       if (d_d_l_loc .eq. 0)
+$       then
+$          front = f$extract( 0, (colon+ 3), line_reduced)
+$          back = f$extract( (colon+ 3+ f$length( dev_dir_lose)), -
+            1000, line_reduced)
+$          line = front+ "[-"+ back
+$          write deps_out "''prefix'"+ "''line'"
+$       endif
+$    goto loop_subs_top
+$!
+$    loop_subs_end:
+$    close deps_in
+$!
+$ goto loop_main_top
+$!
+$ loop_main_end:
+$ close deps_out
+$!
+$ end_main:
+$!
diff --git a/vms/DESCRIP.MMS b/vms/DESCRIP.MMS
new file mode 100644
index 0000000..2808f87
--- /dev/null
+++ b/vms/DESCRIP.MMS
@@ -0,0 +1,140 @@
+#                                               29 January 2008.  SMS.
+#
+#    MMS or MMK description file for Wget 1.11.
+#
+# The default target, EXE, builds the architecture-specific Wget
+# executable (and the DECC_VER.EXE diagnostic executable).
+#
+# Other targets:
+#
+#    HELP       [.VMS]WGET.HLB help library.
+#
+#    CLEAN      deletes architecture-specific files, but leaves any
+#               individual source dependency files and the help library.
+#
+#    CLEAN_ALL  deletes all generated files, except the main (collected)
+#               source dependency file.
+#
+#    CLEAN_EXE  deletes only the architecture-specific executable. 
+#               Handy if all you wish to do is re-link the executable.
+#
+
+# Include the source file lists (among other data).
+
+INCL_DESCRIP_SRC = 1
+.INCLUDE [-.VMS]descrip_src.mms
+
+# DECC_VER diagnostic program.
+DECC_VER_OBJ = [.$(DEST)]DECC_VER.OBJ
+
+# Executables.
+
+WGET_EXE = [.$(DEST)]WGET.EXE
+DECC_VER_EXE = [.$(DEST)]DECC_VER.EXE
+
+EXE = $(WGET_EXE) $(DECC_VER_EXE)
+
+# HELP library and source file.
+
+HLB = [-.VMS]WGET.HLB
+HLP = [-.VMS]WGET.HLP
+
+# Link the executables (default target).
+
+EXE : $(EXE)
+	@ write sys$output ""
+	@ write sys$output "   ""$<"" is ready."
+	@ write sys$output ""
+
+$(WGET_EXE) : $(OBJS) $(MAIN_OPT) $(IP_OPT)
+	define /user_mode odir [.$(DEST)]
+	$(LINK) $(LINKFLAGS) $(MAIN_OPT) /options $(IP_LINK_OPT) -
+	 $(SSL_LINK_OPT)
+
+$(DECC_VER_OBJ) : [-.VMS]DECC_VER.C
+
+$(DECC_VER_EXE) : $(DECC_VER_OBJ)
+	$(LINK) $(LINKFLAGS) $(MMS$SOURCE)
+
+# Create the HELP library (HELP target).
+
+HELP : $(HLB)
+	@ write sys$output ""
+	@ write sys$output "   ""$<"" is ready."
+	@ write sys$output ""
+
+$(HLB) : $(HLP)
+	LIBRARY /CREATE /HELP $@ $<
+
+# CLEAN target.  Delete the [.$(DEST)] directory and everything in it.
+
+CLEAN :
+	if (f$search( "[.$(DEST)]*.*") .nes. "") then -
+	 delete [.$(DEST)]*.*;*
+	if (f$search( "$(DEST).dir") .nes. "") then -
+	 set protection = w:d $(DEST).dir;*
+	if (f$search( "$(DEST).dir") .nes. "") then -
+	 delete $(DEST).dir;*
+
+# CLEAN_ALL target.  Delete:
+#    The [.$(DEST)] directories and everything in them.
+#    All help-related derived files,
+#    CONFIG.H.
+#    All individual C dependency files.
+# Also mention:
+#    Comprehensive dependency file.
+
+CLEAN_ALL :
+	if (f$search( "[.ALPHA*]*.*") .nes. "") then -
+	 delete [.ALPHA*]*.*;*
+	if (f$search( "ALPHA*.dir", 1) .nes. "") then -
+	 set protection = w:d ALPHA*.dir;*
+	if (f$search( "ALPHA*.dir", 2) .nes. "") then -
+	 delete ALPHA*.dir;*
+	if (f$search( "[.IA64*]*.*") .nes. "") then -
+	 delete [.IA64*]*.*;*
+	if (f$search( "IA64*.dir", 1) .nes. "") then -
+	 set protection = w:d IA64*.dir;*
+	if (f$search( "IA64*.dir", 2) .nes. "") then -
+	 delete IA64*.dir;*
+	if (f$search( "[.VAX*]*.*") .nes. "") then -
+	 delete [.VAX*]*.*;*
+	if (f$search( "VAX*.dir", 1) .nes. "") then -
+	 set protection = w:d VAX*.dir;*
+	if (f$search( "VAX*.dir", 2) .nes. "") then -
+	 delete VAX*.dir;*
+	if (f$search( "$(CONFIG_H)") .nes. "") then -
+	 delete /log /noconfirm $(CONFIG_H);*
+	if (f$search( "$(HLB)") .nes. "") then -
+	 delete /log /noconfirm $(HLB);*
+	if (f$search( "*.MMSD") .nes. "") then -
+	 delete *.MMSD;*
+	@ write sys$output ""
+	@ write sys$output "Note:  This procedure will not"
+	@ write sys$output "   DELETE [.VMS]DESCRIP_DEPS.MMS;*"
+	@ write sys$output -
+ "You may choose to, but a recent version of MMS (V3.5 or newer?) is"
+	@ write sys$output -
+ "needed to regenerate it.  (It may also be recovered from the original"
+	@ write sys$output -
+ "distribution kit.)  See [.VMS]DESCRIP_MKDEPS.MMS for instructions on"
+	@ write sys$output -
+ "generating [.VMS]DESCRIP_DEPS.MMS."
+	@ write sys$output ""
+
+# CLEAN_EXE target.  Delete the executable in [.$(DEST)].
+
+CLEAN_EXE :
+	if (f$search( "[.$(DEST)]*.exe") .nes. "") then -
+	 delete [.$(DEST)]*.exe;*
+
+# Include CONFIG.H dependency and rule.
+
+INCL_CONFIG_SRC = 1
+.INCLUDE [-.VMS]descrip_config.mms
+
+# Include generated source dependencies.
+
+INCL_DESCRIP_DEPS = 1
+.INCLUDE [-.VMS]descrip_deps.mms
+
diff --git a/vms/DESCRIP_CONFIG.MMS b/vms/DESCRIP_CONFIG.MMS
new file mode 100644
index 0000000..2bb5f24
--- /dev/null
+++ b/vms/DESCRIP_CONFIG.MMS
@@ -0,0 +1,19 @@
+#                                               28 January 2008.  SMS.
+#
+#    Wget 1.11 for VMS - MMS (or MMK) Config Description File.
+#
+
+# This description file is included by other description files.  It is
+# not intended to be used alone.  Verify proper inclusion.
+
+.IFDEF INCL_CONFIG_SRC
+.ELSE
+$$$$ THIS DESCRIPTION FILE IS NOT INTENDED TO BE USED THIS WAY.
+.ENDIF
+
+
+# Use the VMS "config.h".
+
+$(CONFIG_H) : [-.vms]config.h_vms
+	backup /log /new_version [-.vms]config.h_vms;0 $(CONFIG_H)
+
diff --git a/vms/DESCRIP_DEPS.MMS b/vms/DESCRIP_DEPS.MMS
new file mode 100644
index 0000000..60f80c1
--- /dev/null
+++ b/vms/DESCRIP_DEPS.MMS
@@ -0,0 +1,469 @@
+#
+# Wget for VMS - MMS (or MMK) Source Dependency File.
+#
+
+# This description file is included by other description files.  It is
+# not intended to be used alone.  Verify proper inclusion.
+
+.IFDEF INCL_DESCRIP_DEPS
+.ELSE
+$$$$ THIS DESCRIPTION FILE IS NOT INTENDED TO BE USED THIS WAY.
+.ENDIF
+
+[.$(DEST)]CMPT.OBJ : [-.SRC]CMPT.C
+[.$(DEST)]CMPT.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]WGET.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]CMPT.OBJ : [-.SRC]LOG.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]CONNECT.C
+[.$(DEST)]CONNECT.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]CONNECT.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]WGET.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]LOG.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]HOST.H
+[.$(DEST)]CONNECT.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]CONNECT.H
+[.$(DEST)]CONNECT.OBJ : [-.SRC]HASH.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]CONVERT.C
+[.$(DEST)]CONVERT.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]WGET.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]LOG.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]URL.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]HASH.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]PTIMER.H
+[.$(DEST)]CONVERT.OBJ : [-.SRC]RES.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]COOKIES.C
+[.$(DEST)]COOKIES.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]WGET.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]LOG.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]HASH.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]COOKIES.H
+[.$(DEST)]COOKIES.OBJ : [-.SRC]HTTP.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]FTP-BASIC.C
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]WGET.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]LOG.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]CONNECT.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]HOST.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]FTP.H
+[.$(DEST)]FTP-BASIC.OBJ : [-.SRC]RETR.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]FTP-LS.C
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]WGET.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]LOG.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]FTP.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]HOST.H
+[.$(DEST)]FTP-LS.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]URL.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]FTP-LS.OBJ : [-.SRC]RETR.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]FTP-OPIE.C
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]WGET.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]LOG.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]GEN-MD5.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]FTP.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.SRC]HOST.H
+[.$(DEST)]FTP-OPIE.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]FTP.OBJ : [-.SRC]FTP.C
+[.$(DEST)]FTP.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]FTP.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]FTP.OBJ : [-.SRC]WGET.H
+[.$(DEST)]FTP.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]FTP.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]FTP.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]FTP.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]FTP.OBJ : [-.SRC]LOG.H
+[.$(DEST)]FTP.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]FTP.OBJ : [-.SRC]URL.H
+[.$(DEST)]FTP.OBJ : [-.SRC]RETR.H
+[.$(DEST)]FTP.OBJ : [-.SRC]FTP.H
+[.$(DEST)]FTP.OBJ : [-.SRC]HOST.H
+[.$(DEST)]FTP.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]FTP.OBJ : [-.SRC]CONNECT.H
+[.$(DEST)]FTP.OBJ : [-.SRC]NETRC.H
+[.$(DEST)]FTP.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]FTP.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]FTP.OBJ : [-.VMS]VMS.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]GEN-MD5.C
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]WGET.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]LOG.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]GEN-MD5.H
+[.$(DEST)]GEN-MD5.OBJ : [-.SRC]GNU-MD5.H
+[.$(DEST)]GETOPT.OBJ : [-.SRC]GETOPT.C
+[.$(DEST)]GETOPT.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]GETOPT.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]GETOPT.OBJ : [-.SRC]GETOPT.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]GNU-MD5.C
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]WGET.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]LOG.H
+[.$(DEST)]GNU-MD5.OBJ : [-.SRC]GNU-MD5.H
+[.$(DEST)]HASH.OBJ : [-.SRC]HASH.C
+[.$(DEST)]HASH.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]HASH.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]HASH.OBJ : [-.SRC]WGET.H
+[.$(DEST)]HASH.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]HASH.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]HASH.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]HASH.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]HASH.OBJ : [-.SRC]LOG.H
+[.$(DEST)]HASH.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]HASH.OBJ : [-.SRC]HASH.H
+[.$(DEST)]HOST.OBJ : [-.SRC]HOST.C
+[.$(DEST)]HOST.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]HOST.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]HOST.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]HOST.OBJ : [-.SRC]WGET.H
+[.$(DEST)]HOST.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]HOST.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]HOST.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]HOST.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]HOST.OBJ : [-.SRC]LOG.H
+[.$(DEST)]HOST.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]HOST.OBJ : [-.SRC]HOST.H
+[.$(DEST)]HOST.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]HOST.OBJ : [-.SRC]URL.H
+[.$(DEST)]HOST.OBJ : [-.SRC]HASH.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]HTML-PARSE.C
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]WGET.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]LOG.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]HTML-PARSE.H
+[.$(DEST)]HTML-PARSE.OBJ : [-.SRC]HASH.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]HTML-URL.C
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]WGET.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]LOG.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]HTML-PARSE.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]URL.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]HASH.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]HTML-URL.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]HTTP-NTLM.C
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]WGET.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]LOG.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]HTTP-NTLM.OBJ : [-.SRC]HTTP-NTLM.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]HTTP.C
+[.$(DEST)]HTTP.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]WGET.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]LOG.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]HASH.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]HTTP.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]URL.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]HOST.H
+[.$(DEST)]HTTP.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]RETR.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]CONNECT.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]NETRC.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]SSL.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]HTTP-NTLM.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]COOKIES.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]GEN-MD5.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]SPIDER.H
+[.$(DEST)]HTTP.OBJ : [-.SRC]VERSION.H
+[.$(DEST)]HTTP.OBJ : [-.VMS]VMS.H
+[.$(DEST)]INIT.OBJ : [-.SRC]INIT.C
+[.$(DEST)]INIT.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]INIT.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]INIT.OBJ : [-.SRC]WGET.H
+[.$(DEST)]INIT.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]INIT.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]INIT.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]INIT.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]INIT.OBJ : [-.SRC]LOG.H
+[.$(DEST)]INIT.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]INIT.OBJ : [-.SRC]INIT.H
+[.$(DEST)]INIT.OBJ : [-.SRC]HOST.H
+[.$(DEST)]INIT.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]INIT.OBJ : [-.SRC]NETRC.H
+[.$(DEST)]INIT.OBJ : [-.SRC]PROGRESS.H
+[.$(DEST)]INIT.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]INIT.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]INIT.OBJ : [-.SRC]RES.H
+[.$(DEST)]INIT.OBJ : [-.SRC]HTTP.H
+[.$(DEST)]INIT.OBJ : [-.SRC]RETR.H
+[.$(DEST)]LOG.OBJ : [-.SRC]LOG.C
+[.$(DEST)]LOG.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]LOG.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]LOG.OBJ : [-.SRC]WGET.H
+[.$(DEST)]LOG.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]LOG.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]LOG.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]LOG.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]LOG.OBJ : [-.SRC]LOG.H
+[.$(DEST)]LOG.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]MAIN.C
+[.$(DEST)]MAIN.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]WGET.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]LOG.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]INIT.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]RETR.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]HOST.H
+[.$(DEST)]MAIN.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]URL.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]PROGRESS.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]SPIDER.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]HTTP.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]GETOPT.H
+[.$(DEST)]MAIN.OBJ : [-.VMS]VMS.H
+[.$(DEST)]MAIN.OBJ : [-.SRC]VERSION.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]NETRC.C
+[.$(DEST)]NETRC.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]WGET.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]LOG.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]NETRC.H
+[.$(DEST)]NETRC.OBJ : [-.SRC]INIT.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]OPENSSL.C
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]WGET.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]LOG.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]CONNECT.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]HOST.H
+[.$(DEST)]OPENSSL.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]URL.H
+[.$(DEST)]OPENSSL.OBJ : [-.SRC]SSL.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]PROGRESS.C
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]WGET.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]LOG.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]PROGRESS.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]PROGRESS.OBJ : [-.SRC]RETR.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]PTIMER.C
+[.$(DEST)]PTIMER.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]WGET.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]LOG.H
+[.$(DEST)]PTIMER.OBJ : [-.SRC]PTIMER.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]RECUR.C
+[.$(DEST)]RECUR.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]WGET.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]LOG.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]URL.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]RETR.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]FTP.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]HOST.H
+[.$(DEST)]RECUR.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]HASH.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]RES.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]RECUR.OBJ : [-.SRC]SPIDER.H
+[.$(DEST)]RES.OBJ : [-.SRC]RES.C
+[.$(DEST)]RES.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]RES.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]RES.OBJ : [-.SRC]WGET.H
+[.$(DEST)]RES.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]RES.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]RES.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]RES.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]RES.OBJ : [-.SRC]LOG.H
+[.$(DEST)]RES.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]RES.OBJ : [-.SRC]HASH.H
+[.$(DEST)]RES.OBJ : [-.SRC]URL.H
+[.$(DEST)]RES.OBJ : [-.SRC]RETR.H
+[.$(DEST)]RES.OBJ : [-.SRC]RES.H
+[.$(DEST)]RETR.OBJ : [-.SRC]RETR.C
+[.$(DEST)]RETR.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]RETR.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]RETR.OBJ : [-.SRC]WGET.H
+[.$(DEST)]RETR.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]RETR.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]RETR.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]RETR.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]RETR.OBJ : [-.SRC]LOG.H
+[.$(DEST)]RETR.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]RETR.OBJ : [-.SRC]RETR.H
+[.$(DEST)]RETR.OBJ : [-.SRC]PROGRESS.H
+[.$(DEST)]RETR.OBJ : [-.SRC]URL.H
+[.$(DEST)]RETR.OBJ : [-.SRC]RECUR.H
+[.$(DEST)]RETR.OBJ : [-.SRC]FTP.H
+[.$(DEST)]RETR.OBJ : [-.SRC]HOST.H
+[.$(DEST)]RETR.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]RETR.OBJ : [-.SRC]HTTP.H
+[.$(DEST)]RETR.OBJ : [-.SRC]CONNECT.H
+[.$(DEST)]RETR.OBJ : [-.SRC]HASH.H
+[.$(DEST)]RETR.OBJ : [-.SRC]CONVERT.H
+[.$(DEST)]RETR.OBJ : [-.SRC]PTIMER.H
+[.$(DEST)]SAFE-CTYPE.OBJ : [-.SRC]SAFE-CTYPE.C
+[.$(DEST)]SAFE-CTYPE.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]SAFE-CTYPE.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]SAFE-CTYPE.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]SNPRINTF.OBJ : [-.SRC]SNPRINTF.C
+[.$(DEST)]SNPRINTF.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]SNPRINTF.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]SPIDER.C
+[.$(DEST)]SPIDER.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]WGET.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]LOG.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]SPIDER.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]URL.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]HASH.H
+[.$(DEST)]SPIDER.OBJ : [-.SRC]RES.H
+[.$(DEST)]URL.OBJ : [-.SRC]URL.C
+[.$(DEST)]URL.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]URL.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]URL.OBJ : [-.SRC]WGET.H
+[.$(DEST)]URL.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]URL.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]URL.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]URL.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]URL.OBJ : [-.SRC]LOG.H
+[.$(DEST)]URL.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]URL.OBJ : [-.SRC]URL.H
+[.$(DEST)]URL.OBJ : [-.SRC]HOST.H
+[.$(DEST)]URL.OBJ : [-.VMS]VMS_IP.H
+[.$(DEST)]URL.OBJ : [-.VMS]VMS.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]UTILS.C
+[.$(DEST)]UTILS.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]WGET.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]LOG.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]UTILS.H
+[.$(DEST)]UTILS.OBJ : [-.SRC]HASH.H
+[.$(DEST)]UTILS.OBJ : [-.VMS]VMS.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]XMALLOC.C
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]WGET.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]LOG.H
+[.$(DEST)]XMALLOC.OBJ : [-.SRC]HASH.H
+[.$(DEST)]VMS.OBJ : [-.VMS]VMS.C
+[.$(DEST)]VMS.OBJ : [-.VMS]VMS.H
+[.$(DEST)]VMS.OBJ : [-.SRC]CONFIG.H
+[.$(DEST)]VMS.OBJ : [-.SRC]CONFIG-POST.H
+[.$(DEST)]VMS.OBJ : [-.SRC]WGET.H
+[.$(DEST)]VMS.OBJ : [-.SRC]SYSDEP.H
+[.$(DEST)]VMS.OBJ : [-.SRC]SAFE-CTYPE.H
+[.$(DEST)]VMS.OBJ : [-.SRC]OPTIONS.H
+[.$(DEST)]VMS.OBJ : [-.SRC]XMALLOC.H
+[.$(DEST)]VMS.OBJ : [-.SRC]LOG.H
+[.$(DEST)]VMS.OBJ : [-.SRC]UTILS.H
diff --git a/vms/DESCRIP_MKDEPS.MMS b/vms/DESCRIP_MKDEPS.MMS
new file mode 100644
index 0000000..2c69500
--- /dev/null
+++ b/vms/DESCRIP_MKDEPS.MMS
@@ -0,0 +1,156 @@
+#                                               28 January 2008.  SMS.
+#
+#    Wget 1.11 for VMS - MMS Dependency Description File.
+#
+#    MMS /EXTENDED_SYNTAX description file to generate a C source
+#    dependencies file.  Unsightly errors result when /EXTENDED_SYNTAX
+#    is not specified.  Typical usage (from the [...src] directory):
+#
+#    $ @ [-.VMS]VMS-WGET.COM DEPS [DASHD] [HPSSL|NOSSL] [NOSKIP] [CLEAN|PURGE]
+#
+# This description file uses this command procedure:
+#
+#    [-.VMS]COLLECT_DEPS.COM
+#
+# MMK users without MMS will be unable to generate the dependencies file
+# using this description file, however there should be one supplied in
+# the kit.  If this file has been deleted, users in this predicament
+# will need to recover it from the original distribution kit.
+#
+# Note:  This dependency generation scheme assumes that the dependencies
+# do not depend on host architecture type or other such variables. 
+# Therefore, no "#include" directive in the C source itself should be
+# conditional on such variables.
+#
+# Note:  For no apparent reason, Wget code uses "system include"
+# brackets (<>) for "config.h", so /MMS_DEPENDENCIES =
+# NOSYSTEM_INCLUDE_FILES is useless here.  Thus, we rely on
+# COLLECT_DEPS.COM to filter out the system includes from the
+# dependencies.
+#
+
+# Required command procedures.
+
+COMS = [-.VMS]COLLECT_DEPS.COM
+
+# Include the source file lists (among other data).
+
+INCL_DESCRIP_SRC = 1
+.INCLUDE [-.VMS]descrip_src.mms
+
+# The ultimate product, a comprehensive dependency list.
+
+DEPS_FILE = [-.VMS]descrip_deps.mms 
+
+# Detect valid qualifier and/or macro options.
+
+.IF $(FINDSTRING Skip, $(MMSQUALIFIERS)) .eq Skip
+DELETE_MMSD = 1
+.ELSIF NOSKIP
+PURGE_MMSD = 1
+.ELSE
+UNK_MMSD = 1
+.ENDIF
+
+# Dependency suffixes and rules.
+#
+# .FIRST is assumed to be used already, so the MMS qualifier/macro check
+# is included in each rule (one way or another).
+
+.SUFFIXES_BEFORE .C .MMSD
+
+.C.MMSD :
+.IF UNK_MMSD
+	@ write sys$output -
+ "   /SKIP_INTERMEDIATES is expected on the MMS command line."
+	@ write sys$output -
+ "   For normal behavior (delete .MMSD files), specify ""/SKIP""."
+	@ write sys$output -
+ "   To retain the .MMSD files, specify ""/MACRO = NOSKIP=1""."
+	@ exit %x00000004
+.ENDIF
+	$(CC) /NOOBJECT -
+	 /define = ($(CDEFINES)) -
+	 $(CFLAGS_INCL) -
+	 $(CFLAGS_LIST) -
+	 $(CFLAGS_PREFIX) -
+	 $(MMS$SOURCE) -
+	 /MMS_DEPENDENCIES = (FILE = $(MMS$TARGET))
+
+# List of MMS dependency files.
+# [.$(DEST)]XXX.obj -> XXX
+
+MODS_SRC = $(FILTER-OUT *], $(PATSUBST *]*.obj, *] *, $(OBJS_SRC)))
+MODS_VMS = $(FILTER-OUT *], $(PATSUBST *]*.obj, *] [-.vms]*, $(OBJS_VMS)))
+
+MODS = $(MODS_SRC) $(MODS_VMS)
+
+# Complete list of C object dependency file names.
+# XXX -> XXX.mmsd
+
+DEPS = $(FOREACH NAME, $(MODS), $(NAME).mmsd)
+
+# Default target is the comprehensive dependency list.
+
+$(DEPS_FILE) : $(CONFIG_H) $(DEPS) $(COMS)
+.IF UNK_MMSD
+	@ write sys$output -
+ "   /SKIP_INTERMEDIATES is expected on the MMS command line."
+	@ write sys$output -
+ "   For normal behavior (delete individual .MMSD files), specify ""/SKIP""."
+	@ write sys$output -
+ "   To retain the individual .MMSD files, specify ""/MACRO = NOSKIP=1""."
+	@ exit %x00000004
+.ENDIF
+#
+#       Note that the space in P3, which prevents immediate macro
+#       expansion, is removed by COLLECT_DEPS.COM.
+#
+        @[-.VMS]collect_deps.com -
+         "$(MMS$TARGET)" "[-...]*.mmsd" "[.$ (DEST)]" -
+	 $(MMSDESCRIPTION_FILE)
+        @ write sys$output -
+         "Created a new dependency file: $(MMS$TARGET)"
+.IF DELETE_MMSD
+	@ write sys$output -
+         "Deleting intermediate .MMSD files..."
+	if (f$search( "*.mmsd;*") .nes. "") then -
+	 delete /log *.mmsd;*
+	if (f$search( "[-.vms]*.mmsd;*") .nes. "") then -
+	 delete /log [-.vms]*.mmsd;*
+.ELSE
+	@ write sys$output -
+         "Purging intermediate .MMSD files..."
+	purge /log *.mmsd, [-.vms]*.mmsd
+.ENDIF
+
+# CLEAN target.
+
+CLEAN :
+	if (f$search( "$(CONFIG_H)") .nes. "") then -
+	 delete /log $(CONFIG_H);*
+	if (f$search( "*.mmsd;*") .nes. "") then -
+	 delete /log *.mmsd;*
+	if (f$search( "[-.vms]*.mmsd;*") .nes. "") then -
+	 delete /log [-.vms]*.mmsd;*
+	if (f$search( "$(DEPS_FILE);*") .nes. "") then -
+	 delete /log $(DEPS_FILE);*
+
+# PURGE target.
+
+PURGE :
+	if (f$search( "$(CONFIG_H);-1") .nes. "") then -
+	 purge /log $(CONFIG_H)
+	if (f$search( "*.mmsd;*") .nes. "") then -
+	 delete /log *.mmsd;*
+	if (f$search( "[-.vms]*.mmsd;*") .nes. "") then -
+	 delete /log [-.vms]*.mmsd;*
+	if (f$search( "$(DEPS_FILE);-1") .nes. "") then -
+	 purge /log $(DEPS_FILE)
+
+
+# Include CONFIG.H dependency and rule.
+
+INCL_CONFIG_SRC = 1
+.INCLUDE [-.VMS]descrip_config.mms
+
diff --git a/vms/DESCRIP_SRC.MMS b/vms/DESCRIP_SRC.MMS
new file mode 100644
index 0000000..df20e23
--- /dev/null
+++ b/vms/DESCRIP_SRC.MMS
@@ -0,0 +1,259 @@
+#                                               29 January 2008.  SMS.
+#
+#    Wget 1.11 for VMS - MMS (or MMK) Source Description File.
+#
+
+# This description file is included by other description files.  It is
+# not intended to be used alone.  Verify proper inclusion.
+
+.IFDEF INCL_DESCRIP_SRC
+.ELSE
+$$$$ THIS DESCRIPTION FILE IS NOT INTENDED TO BE USED THIS WAY.
+.ENDIF
+
+
+# Define MMK architecture macros when using MMS.
+
+.IFDEF __MMK__                          # __MMK__
+.ELSE                                   # __MMK__
+ALPHA_X_ALPHA = 1
+IA64_X_IA64 = 1
+VAX_X_VAX = 1
+.IFDEF $(MMS$ARCH_NAME)_X_ALPHA             # $(MMS$ARCH_NAME)_X_ALPHA
+__ALPHA__ = 1
+.ENDIF                                      # $(MMS$ARCH_NAME)_X_ALPHA
+.IFDEF $(MMS$ARCH_NAME)_X_IA64              # $(MMS$ARCH_NAME)_X_IA64
+__IA64__ = 1
+.ENDIF                                      # $(MMS$ARCH_NAME)_X_IA64
+.IFDEF $(MMS$ARCH_NAME)_X_VAX               # $(MMS$ARCH_NAME)_X_VAX
+__VAX__ = 1
+.ENDIF                                      # $(MMS$ARCH_NAME)_X_VAX
+.ENDIF                                  # __MMK__
+
+# Analyze architecture-related and option macros.
+
+.IFDEF __ALPHA__                        # __ALPHA__
+DECC = 1
+.IFDEF LARGE                                # LARGE
+DEST = ALPHAL
+.ELSE                                       # LARGE
+DEST = ALPHA
+.ENDIF                                      # LARGE
+.ELSE                                   # __ALPHA__
+.IFDEF __IA64__                             # __IA64__
+DECC = 1
+.IFDEF LARGE                                    # LARGE
+DEST = IA64L
+.ELSE                                           # LARGE
+DEST = IA64
+.ENDIF                                          # LARGE
+.ELSE                                       # __IA64__
+.IFDEF __VAX__                                  # __VAX__
+DEST = VAX
+.ELSE                                           # __VAX__
+DEST = UNK
+UNK_DEST = 1
+.ENDIF                                          # __VAX__
+.ENDIF                                      # __IA64__
+.ENDIF                                  # __ALPHA__
+
+# Check for option problems.
+
+.IFDEF __VAX__                          # __VAX__
+.IFDEF LARGE                                # LARGE
+LARGE_VAX = 1
+.ENDIF                                      # LARGE
+.ENDIF                                  # __VAX__
+
+# Complain if warranted.  Otherwise, show destination directory.
+# Make the destination directory, if necessary.
+
+.IFDEF VMS_VERS                         # VMS_VERS
+.IFDEF UNK_DEST                             # UNK_DEST
+.FIRST
+	@ write sys$output -
+ "   Unknown system architecture."
+.IFDEF __MMK__                                  # __MMK__
+	@ write sys$output -
+ "   MMK on IA64?  Try adding ""/MACRO = __IA64__""."
+.ELSE                                           # __MMK__
+	@ write sys$output -
+ "   MMS too old?  Try adding ""/MACRO = MMS$ARCH_NAME=ALPHA"","
+	@ write sys$output -
+ "   or ""/MACRO = MMS$ARCH_NAME=IA64"", or ""/MACRO = MMS$ARCH_NAME=VAX"","
+	@ write sys$output -
+ "   as appropriate.  (Or try a newer version of MMS.)"
+.ENDIF                                          # __MMK__
+	@ write sys$output ""
+	I_WILL_DIE_NOW.  /$$$$INVALID$$$$
+.ELSE                                       # UNK_DEST
+.IFDEF LARGE_VAX                                # LARGE_VAX
+.FIRST
+	@ write sys$output -
+ "   Macro ""LARGE"" is invalid on VAX."
+	@ write sys$output ""
+	I_WILL_DIE_NOW.  /$$$$INVALID$$$$
+.ELSE                                           # LARGE_VAX
+.FIRST
+	@ write sys$output ""
+	@ write sys$output "   Destination: "
+	@ write sys$output "   "+ -
+	   f$extract( 0, (f$length( f$environment( "DEFAULT"))- 1), -
+	   f$environment( "DEFAULT")) + ".$(DEST)]"
+	@ write sys$output ""
+	if (f$search( "$(DEST).DIR;1") .eqs. "") then -
+	 create /directory [.$(DEST)]
+.ENDIF                                          # LARGE_VAX
+.ENDIF                                      # UNK_DEST
+.ELSE                                   # VMS_VERS
+.FIRST
+	@ write sys$output -
+ "   Use VMS-WGET.COM to define the required MMK or MMS macros."
+	@ write sys$output -
+ "   It will then run MMS (or MMK)."
+	@ write sys$output ""
+	I_WILL_DIE_NOW.  /$$$$INVALID$$$$
+.ENDIF                                  # VMS_VERS
+
+# UTIME prefix quirk.
+
+.IFDEF __ALPHA__
+UTNP = , __UTC_UTIME
+.ENDIF
+
+.IFDEF __IA64__
+UTNP = , __UTC_UTIME
+.ENDIF
+
+# DEC C and LINK options.
+
+# Main LINK options file.
+
+MAIN_OPT = [-.VMS]wget.opt
+
+### To enable the "-d" command-line debug option, add "ENABLE_DEBUG", as
+### shown (or in CONFIG.H[_VMS]).
+
+.IFDEF DASHD
+BASE_CDEFINES = "HAVE_CONFIG_H", "SYSTEM_WGETRC=""SYSTEM_WGETRC""", \
+ "ENABLE_DEBUG"
+.ELSE
+BASE_CDEFINES = "HAVE_CONFIG_H", "SYSTEM_WGETRC=""SYSTEM_WGETRC"""
+.ENDIF
+
+.IFDEF MULTINET
+IP_CDEFINES = , "MULTINET"
+IP_OPT = [-.VMS]wget_multinet.opt
+IP_LINK_OPT = , $(IP_OPT) /OPTIONS
+.ENDIF
+
+.IFDEF DBG
+CFLAGS_DBG = /debug /nooptimize
+LINKFLAGS_DBG = /debug
+.ENDIF
+
+.IFDEF LIST
+CFLAGS_LIST = /list = [.$(DEST)] /show = (all, nomessages)
+LINKFLAGS_LIST = /map = [.$(DEST)] /cross_reference /full
+.ENDIF
+
+.IFDEF LARGE
+LARGE_CDEFINES = , "_LARGEFILE"
+.ENDIF
+
+.IFDEF HPSSL                            # HPSSL
+SSL_CDEFINES = , "HAVE_SSL", "ENABLE_NTLM"
+SSL_LINK_OPT = , [-.VMS]WGET_SSL_HP.OPT /OPTIONS
+.ELSE                                   # HPSSL
+.IFDEF SSL                                  # SSL
+SSL_CDEFINES = , "HAVE_SSL", "ENABLE_NTLM"
+SSL_LINK_OPT = , [-.VMS]WGET_SSL.OPT /OPTIONS
+.ELSE                                       # SSL
+SSL_CDEFINES =
+SSL_LINK_OPT = 
+.ENDIF                                      # SSL
+.ENDIF                                  # HPSSL
+
+VER_CDEFINES = , "OS_TYPE=""VMS $(VMS_VERS)"""
+
+CDEFINES = $(BASE_CDEFINES) $(IP_CDEFINES) $(LARGE_CDEFINES) \
+ $(SSL_CDEFINES) $(VER_CDEFINES)
+
+CFLAGS_INCL = /include = ([], [-.vms])
+
+CFLAGS_PREFIX = /prefix = (all, except = \
+ (getopt, optarg, opterr, optind, optopt, utime $(UTNP)))
+
+CFLAGS = \
+ $(CFLAGS_DBG) $(CFLAGS_LIST) \
+ /define = ($(CDEFINES)) \
+ $(CFLAGS_INCL) \
+ $(CFLAGS_PREFIX) \
+ /object = $(MMS$TARGET)
+ 
+LINKFLAGS = $(LINKFLAGS_DBG) $(LINKFLAGS_LIST) \
+ /executable = $(MMS$TARGET)
+
+# Object files.
+
+OBJS_NOSSL_SRC = \
+ [.$(DEST)]cmpt.obj \
+ [.$(DEST)]connect.obj \
+ [.$(DEST)]convert.obj \
+ [.$(DEST)]cookies.obj \
+ [.$(DEST)]ftp.obj \
+ [.$(DEST)]ftp-basic.obj \
+ [.$(DEST)]ftp-ls.obj \
+ [.$(DEST)]ftp-opie.obj \
+ [.$(DEST)]gen-md5.obj \
+ [.$(DEST)]getopt.obj \
+ [.$(DEST)]gnu-md5.obj \
+ [.$(DEST)]hash.obj \
+ [.$(DEST)]host.obj \
+ [.$(DEST)]html-parse.obj \
+ [.$(DEST)]html-url.obj \
+ [.$(DEST)]http.obj \
+ [.$(DEST)]init.obj \
+ [.$(DEST)]log.obj \
+ [.$(DEST)]main.obj \
+ [.$(DEST)]netrc.obj \
+ [.$(DEST)]progress.obj \
+ [.$(DEST)]ptimer.obj \
+ [.$(DEST)]recur.obj \
+ [.$(DEST)]res.obj \
+ [.$(DEST)]retr.obj \
+ [.$(DEST)]safe-ctype.obj \
+ [.$(DEST)]snprintf.obj \
+ [.$(DEST)]spider.obj \
+ [.$(DEST)]url.obj \
+ [.$(DEST)]utils.obj \
+ [.$(DEST)]xmalloc.obj
+
+OBJS_NOSSL_VMS = \
+ [.$(DEST)]vms.obj
+
+OBJS_NOSSL = $(OBJS_NOSSL_SRC) $(OBJS_NOSSL_VMS)
+
+.IFDEF HPSSL                            # HPSSL
+OBJS_SSL = \
+ [.$(DEST)]http-ntlm.obj \
+ [.$(DEST)]openssl.obj
+.ELSE                                   # HPSSL
+.IFDEF SSL                                  # SSL
+OBJS_SSL = \
+ [.$(DEST)]http-ntlm.obj \
+ [.$(DEST)]openssl.obj
+.ELSE                                       # SSL
+OBJS_SSL =
+.ENDIF                                      # SSL
+.ENDIF                                  # HPSSL
+
+OBJS = $(OBJS_NOSSL) $(OBJS_SSL)
+
+OBJS_SRC = $(OBJS_NOSSL_SRC) $(OBJS_SSL)
+OBJS_VMS = $(OBJS_NOSSL_VMS)
+
+# Configuration header file.
+
+CONFIG_H = [-.SRC]config.h
+
diff --git a/vms/VMS-WGET.COM b/vms/VMS-WGET.COM
new file mode 100644
index 0000000..94e1321
--- /dev/null
+++ b/vms/VMS-WGET.COM
@@ -0,0 +1,308 @@
+$!                                              16 November 2006.  SMS.
+$!
+$!    Attempt to build Wget 1.10 automatically, using MMK or MMS.
+$!
+$!    Usage:
+$!
+$!       @ wget_kit_device:[wget_kit_dir.VMS]VMS-WGET.COM -
+$!          [DASHD] [DBG] [HPSSL|NOSSL] [LARGE] [LIST] [MMS] -
+$!          [CLEAN] [CLEAN_ALL] [CLEAN_EXE] [HELP] [MULTINET]
+$!
+$!    To enable the "-d" (diagnostics) Wget command-line option, add
+$! "DASHD" to the command line.
+$!
+$!    To enable large-file (>2GB) support (non-VAX systems), add "LARGE"
+$! to the command line.
+$!
+$!    To build a debug executable, add "DBG" to the command line.
+$!
+$!    To get compiler listing files, add "LIST" to the command line.
+$!
+$!    This procedure prefers MMK to MMS.
+$! To use MMS when both work, add "MMS" to the command line.
+$!
+$!    To prevent automatic detection and use of OpenSSL, add "NOSSL"
+$! to the command line.  This procedure prefers a generic SSL kit to HP
+$! SSL.  If the generic logical names OPENSSL and SSLLIB are defined,
+$! they will be used instead of the the HP SSL logical names SSL$INCLUDE
+$! and SYS$SHARE.  To use HP SSL when these generic logical names are
+$! defined, add "HPSSL" to the command line.
+$!
+$!    To build the "CLEAN" target (which deletes all object and
+$! executable files for the current CPU type, add "CLEAN" to the command
+$! line.  Similarly, the "CLEAN_ALL", "CLEAN_EXE" or "HELP" target may be
+$! specified.  For details, see [.VMS]DESCRIP.MMS.
+$!
+$!    The source code contains some old Multinet-specific code which may
+$! be useful for building the program with Multinet on old VMS versions
+$! (probably VMS before V7.x).  With more modern VMS and Multinet, there
+$! should be no need to use any of the old Multinet-specific code.  If
+$! Multinet build problems occur, try adding "MULTINET" to the command
+$! line.  The source code contains no special code for PathWay or
+$! TCPware IP software (or for the DEC/Compaq/HP UCX or TCPIP software).
+$!
+$!
+$!    Special usage for automatic dependency generation (MMS only):
+$!
+$!       @ wget_kit_device:[wget_kit_dir.VMS]VMS-WGET.COM -
+$!          DEPS [DASHD] [HPSSL|NOSSL] [NOSKIP] [CLEAN|PURGE]
+$!
+$!    See the [.VMS]DESCRIP_MKDEPS.MMS description file for more
+$! details.  Specifying the CLEAN target here deletes the dependency
+$! files, not the usual objects and executables.
+$!
+$!    Note that by default, DESCRIP_MKDEPS.MMS will delete the
+$! intermediate *.MMSD dependency files, leaving only the comprehensive
+$! dependency file, DESCRIP_DEPS.MMS.  To preserve the intermediate
+$! files, specify "NOSKIP".
+$!
+$!    Specifying the PURGE target here deletes the intermediate *.MMSD
+$! dependency files, and purges the comprehensive dependency file,
+$! DESCRIP_DEPS.MMS.
+$!
+$!----------------------------------------------------------------------
+$!
+$! Sense the current default directory.
+$!
+$ def_orig = f$environment( "DEFAULT")
+$!
+$! Arrange for clean-up.
+$!
+$ on error then goto clean_up
+$ on control_y then goto clean_up
+$!
+$! Set default to the kit [.SRC] directory.
+$!
+$ proc = f$environment( "PROCEDURE")
+$ proc_dev_dir = -
+   f$parse( proc, , , "DEVICE")+ f$parse( proc, , , "DIRECTORY")
+$ set default 'proc_dev_dir'
+$ set default [-.src]
+$!
+$! Sense the VMS version.
+$!
+$ VMS_VERS = f$edit( f$getsyi( "version"), "trim")
+$!
+$!
+$! Analyze the command-line parameters.
+$!
+$ CMD = ""
+$ DASHD = ""
+$ DBG = ""
+$ DEPS = ""
+$ HPSSL = ""
+$ IP = ""
+$ LARGE = ""
+$ LIST = ""
+$ NOSKIP = ""
+$ NOSSL = ""
+$ TARGET = ""
+$!
+$ I = 0
+$ p_loop_top:
+$!
+$    I = I+ 1
+$    P = P'I'
+$    P = f$edit( P, "TRIM, UPCASE")
+$!
+$    if (P .eqs. "DASHD")
+$    then
+$       DASHD = "DASHD"
+$    else
+$       if (P .eqs. "DBG")
+$       then
+$          DBG = "DBG"
+$       else
+$          if (P .eqs. "DEPS")
+$          then
+$             DEPS = "DEPS"
+$          else
+$             if (P .eqs. "MMS")
+$             then
+$                CMD = "MMS"
+$             else
+$                if (P .eqs. "LARGE")
+$                then
+$                   LARGE = "LARGE"
+$                else
+$                   if (P .eqs. "LIST")
+$                   then
+$                      LIST = "LIST"
+$                   else
+$                      if (P .eqs. "MULTINET")
+$                      then
+$                         IP = "MULTINET"
+$                      else
+$                         if (P .eqs. "NOSKIP")
+$                         then
+$                            NOSKIP = "NOSKIP"
+$                         else
+$                            if (P .eqs. "NOSSL")
+$                            then
+$                               NOSSL = "NOSSL"
+$                            else
+$                               if (P .eqs. "HPSSL")
+$                               then
+$                                  HPSSL = "HPSSL"
+$                               else
+$                                  if (P .nes. "")
+$                                  then
+$                                     TARGET = P
+$                                  else
+$                                     goto p_loop_bottom
+$                                  endif
+$                               endif
+$                            endif
+$                         endif
+$                      endif
+$                   endif
+$                endif
+$             endif
+$          endif
+$       endif
+$    endif
+$!
+$ goto p_loop_top
+$ p_loop_bottom:
+$!
+$! Verify MMK, if not intending to use MMS.  DEPS rquires MMS.
+$! Accept a (non-blank) foreign command symbol "MMK", or the presence of
+$! MMK.EXE on DCL$PATH.
+$!
+$ if (DEPS .eqs. "")
+$ then
+$    if ((CMD .eqs. "") .and. (DEPS .eqs. ""))
+$    then
+$       CMD = "MMS"
+$       M_ = f$type( MMK)
+$       if (M_ .eqs. "")
+$       then
+$          if (f$search( "DCL$PATH:MMK.EXE") .nes. "") then CMD = "MMK"
+$       else
+$          if (f$edit( MMK, "TRIM") .nes. "") then CMD = "MMK"
+$       endif
+$    endif
+$ endif
+$!
+$! Set MMK or MMS macros.
+$!
+$ MACROS = """""VMS_VERS=''VMS_VERS'"""""
+$!
+$ if (DASHD .nes. "")
+$ then
+$    MACROS = MACROS+ ", """"''DASHD'=1"""""
+$ endif
+$!
+$ if (DBG .nes. "")
+$ then
+$    MACROS = MACROS+ ", """"''DBG'=1"""""
+$ endif
+$!
+$ if (LARGE .nes. "")
+$ then
+$    MACROS = MACROS+ ", """"''LARGE'=1"""""
+$ endif
+$!
+$ if (LIST .nes. "")
+$ then
+$    MACROS = MACROS+ ", """"''LIST'=1"""""
+$ endif
+$!
+$ if (IP .nes. "")
+$ then
+$    MACROS = MACROS+ ", """"''IP'=1"""""
+$ endif
+$!
+$ if (NOSKIP .nes. "")
+$ then
+$    MACROS = MACROS+ ", """"''NOSKIP'=1"""""
+$ endif
+$!
+$ NEED_HP_OPENSSL = 0
+$ if (NOSSL .eqs. "")
+$ then
+$    if (HPSSL .nes. "")
+$    then
+$       if (f$search( "ssl$include:ssl.h") .nes. "")
+$       then
+$          MACROS = MACROS+ ", """"HPSSL=1"""""
+$       endif
+$    else
+$       if (f$search( "openssl:ssl.h") .nes. "")
+$       then
+$          if (f$trnlnm( "OPENSSL") .eqs. "SSL$INCLUDE:")
+$          then
+$             MACROS = MACROS+ ", """"HPSSL=1"""""
+$          else
+$             MACROS = MACROS+ ", """"SSL=1"""""
+$          endif
+$       else
+$          if (f$search( "ssl$include:ssl.h") .nes. "")
+$          then
+$             NEED_HP_OPENSSL = 1
+$             MACROS = MACROS+ ", """"HPSSL=1"""""
+$          endif
+$       endif
+$    endif
+$ endif
+$!
+$ if (MACROS .nes. "")
+$ then
+$    MACROS = "/MACRO = (''MACROS')"
+$ endif
+$!
+$! Compose the MMK or MMS command with the appropriate options.
+$!
+$ if (DEPS .eqs. "")
+$ then
+$    X := 'CMD' /DESCRIPTION = [-.vms]descrip.mms 'MACROS' 'TARGET'
+$ else
+$    CMD = "MMS"
+$    if (NOSKIP .eqs. "")
+$    then
+$       CMD = CMD+ " /SKIP_INTERMEDIATE"
+$    endif
+$    X := 'CMD' /EXTENDED_SYNTAX -
+      /DESCRIPTION = [-.vms]descrip_mkdeps.mms 'MACROS' 'TARGET'
+$ endif
+$!
+$! If using HP SSL, define the logical name OPENSSL.
+$!
+$ if (NEED_HP_OPENSSL)
+$ then
+$    define openssl ssl$include
+$ endif
+$!
+$! If using any SSL, show the openssl definition.
+$!
+$ if (NOSSL .eqs. "")
+$ then
+$    lnm = f$trnlnm( "OPENSSL")
+$    if (lnm .eqs. "")
+$    then
+$       lnm = "(none)"
+$    endif
+$    write sys$output "OPENSSL = "+ lnm
+$ endif
+$!
+$! Show the MMK or MMS command.
+$!
+$ write sys$output X
+$!
+$! Run MMK or MMS with the appropriate options.
+$!
+$ 'X'
+$!
+$ clean_up:
+$!
+$! If using HP SSL, deassign the logical name OPENSSL.
+$!
+$ if (NEED_HP_OPENSSL)
+$ then
+$    deassign openssl
+$ endif
+$!
+$! Restore the original default directory.
+$!
+$ set default 'def_orig'
+$!
diff --git a/vms/VMS_NOTES.TXT b/vms/VMS_NOTES.TXT
new file mode 100644
index 0000000..5456880
--- /dev/null
+++ b/vms/VMS_NOTES.TXT
@@ -0,0 +1,640 @@
+                                                29 January 2008.  SMS.
+
+                       Wget 1.11 for VMS (1.11a)
+                       =========================
+
+------------------------------------------------------------------------
+
+      Disclaimer
+      ----------
+
+   No claims of any sort are made herein.  The main Wget developers seem
+indifferent to this effort.  Any suggestions for improving the code in
+the VMS-specific sections are welcome, but low expectations are more
+realistic than high ones.
+
+------------------------------------------------------------------------
+
+      Description
+      -----------
+
+   This note accompanies a quick VMS port of Wget version 1.10.2, a GNU
+free network utility to retrieve files from the World Wide Web using
+HTTP and FTP.  The most obvious features seem to work, but many have not
+been tested.
+
+   Built and tested (slightly) in these environments:
+
+OpenVMS Alpha V7.3-2, HP C V7.3-009, TCPIP V5.4 - ECO 6
+
+OpenVMS IA64 V8.3, HP C V7.3-018, TCPIP V5.6.
+
+OpenVMS VAX V7.3, Compaq C V6.4-005, TCPIP V5.1.
+
+------------------------------------------------------------------------
+
+      News
+      ----
+
+   Version 1.11a (PRELIMINARY)  2008-01-30
+   ---------------------------------------
+
+- General code update to Wget 1.11.
+
+- Changed to avoid trying "LIST -a" for a VMS FTP server.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.10.2c  2006-11-16
+   ----------------------------
+
+- Changed the code which determines the FTP server type to avoid an
+  ACCVIO if no text was returned in response to a "SYST" inquiry.
+
+- Fixed a command-line parsing problem with the "--ftp-stmlf" option.
+
+- Fixed an unclosed comment (again?) in FTP-LS.C which could have caused
+  problems with ODS5 extended file names.
+
+- Changed VMS-WGET.COM to assume that nothing special is now required
+  for use with the MultiNet IP package.  For obsolete VMS and/or
+  MultiNet versions where the old MultiNet-specific changes are still
+  needed, specify "MULTINET" on the VMS-WGET.COM command line.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.10.2b  2004-12-15
+   ----------------------------
+
+- Changed the "-V" version report to include some host type information.
+
+- Changed the I/O scheme on VMS for progress dots to avoid spurious
+  newline characters when output is directed to a file.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.10.2a  2004-10-13
+   ----------------------------
+
+- General code update to Wget 1.10.2.
+
+- Many legitimate FTP CWD operations on a VMS FTP server failed.  The
+  typical symptom was "No such directory `perfectly/vaild/directory'."
+
+- FTP CWD operations on a VMS FTP server now end with a "CWD []".  For
+  an FTP URL like "ftp://host/a/b/c/d.e" (and contrary to the RFC), Wget
+  uses a UNIX-like directory specification in its CWD command, here,
+  "CWD a/b/c".  This was observed to switch a TCPware FTP server
+  (V5.6-2) into its UNIX emulation mode.  Because Wget checks the system
+  type only once at the beginning of a session, the associated change in
+  directory listing format confused the program.  The typical symptom
+  was "No such file `-rwx---r-x'."  The added "CWD []" command resets
+  the TCPware server to VMS mode, and should be harmless on other VMS
+  FTP servers. 
+
+- VMS-WGET.COM now finds MMK when it's on DCL$PATH as well as when a
+  foreign command symbol "MMK" is defined.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.10.1a  2004-09-09
+   ---------------------------
+
+- General code update to Wget 1.10.1.
+
+- VMS-specific files are now in the new [.VMS] directory.
+
+- Changes to VMS-WGET.COM:
+   - New command-line option, LARGE, enables large-file support on
+     non-VAX systems.
+   - VMS-WGET.COM may now be run from any default directory, not only
+     [.SRC].
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.9.1e  2005-09-09
+   --------------------------
+
+- The default User-Agent string on VMS now includes the host
+  architecture and VMS version.  For example, "Wget/1.9.1e (VMS Alpha
+  V7.3-2)".
+
+- Fixed a problem on VMS with an ODS5 destination file system when a
+  URL-derived file name contained an invalid character ("?" or "*").  A
+  typical complaint might look like:
+     Cannot write to `www.foraddift.non/aspx/index.asp?sid=463e'
+     (file specification syntax error).
+  Now, "?" is converted to "!", and "*" to "#".
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+   Version 1.9.1d  2005-06-21
+   --------------------------
+
+- Replaced the remaining instances where ".orig" was appended to a file
+  name.  Now (for VMS), "_orig" is used everywhere (except in the
+  documentation).
+
+- Disabled (for VMS) the code which appended ".nnn" (decimal "nnn") to
+  an output file name to avoid overwriting an existing file.  The file
+  name is now used unchanged, and VMS file versioning is expected to
+  prevent overwriting.  (The multi-dot file names made this way caused
+  I/O errors on ODS2 file systems.)
+
+- Changed to do translation of CR-LF line endings to local line endings
+  for ASCII FTP transfers.
+
+- Changed (on VMS) to use fixed-512 format for binary FTP files.  Added
+  the new "--ftp-stmlf" option ("ftpstmlf on" command) to let the user
+  restore the old behavior, where Stream_LF was used for both ASCII and
+  binary.
+
+- Added (on VMS) a new open callback function which senses (where
+  supported) the process RMS_DEFAULT values for file extend quantity
+  (deq), multi-block count (mbc), and multi-buffer count (mbf), and sets
+  the FAB/RAB parameters accordingly.  The default deq is now much
+  larger than before (16384, was none), and the default mbc is now 127
+  (was none), speeding creation of a large output file.  Explicitly set
+  RMS_DEFAULT values override built-in defaults.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.9.1c  2004-12-15
+   --------------------------
+
+- Added https (SSL) support, changing DESCRIP.MMS and VMS-WGET.COM, and
+  adding WGET_SSL.OPT and WGET_SSL_HP.OPT.  Limited testing was done on
+  Alpha, using HP SSL V1.1-B and OpenSSL version 0.9.7e.  The build
+  procedure automatically enables SSL support if it can find one of the
+  SSL header files.  The details are explained in comments in
+  VMS-WGET.COM, including its new command-line options, HPSSL and NOSSL.
+
+- Changed CONNECT.C to fix some problems with MultiNet TCP/IP software.
+
+   - A build problem related to header files (netdb.h) when compiled
+     with MultiNet.  Typical symptom:
+
+         %CC-E-REDEFSTRUCT, In this declaration, the struct "hostent" is
+         redefined. at line number 178 in module NETDB of text library
+         SYS$COMMON:[SYSLIB]DECC$RTLDEF.TLB;1
+
+   - A run-time problem with an FTP URL. Typical symptom: 
+
+         accept: bad address
+
+- Changed FTP.C to fix various problems with time-stamping ("-N",
+  "--timestamping") when using an FTP URL.  Some of the misbehavior was
+  specific to a VMS FTP server, but not all.  The typical result was a
+  file with the modification date (and, in some cases, the creation
+  date) left at the date of the download, rather than set to match the
+  date on the server.  Some misleading diagnostic messages also have
+  been corrected.
+
+- Changed FTP-LS.C to fix a typographical error (unclosed comment).
+
+- Changed NETRC.C to fix a potential build problem on non-VMS systems.
+  Adding some VMS-specific code introduced some improper statement
+  ordering, which may generate complaints (or failure) with some C
+  compilers.
+
+- Changed VMS.C to fix a problem with the utime() function (supplied
+  with Wget) when the user specified a non-UNIX file name with the Wget
+  "-O" option.  Typical symptom: 
+
+     utime(home_sms:[sms.wget]t.h): error 0
+
+  As the message might suggest, the file date-time was not being set
+  correctly.  With this fix, utime() should work with either a UNIX-like
+  or VMS-like file specification, and it should also set errno properly
+  when it fails, enabling a more informative error message.
+
+- New MMS/MMK description files and associated command procedures enable
+  automatic source dependency generation.  Changed: DESCRIP.MMS and
+  VMS-WGET.COM.  New: DESCRIP_DEPS.MMS, DESCRIP_MKDEPS.MMS,
+  DESCRIP_SRC.MMS, COLLECT_DEPS.COM, and MOD_DEP.COM.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.9.1b  2004-09-28
+   --------------------------
+
+- Changed CONFIG.H_VMS to fix a build problem with C RTL before VMS
+  V7.3-1 with C Runtime ECO V3.0 on Alpha:
+     %LINK-W-NUDFSYMS, 2 undefined symbols:
+     %LINK-I-UDFSYM,         DECC$GXSNPRINTF
+     %LINK-I-UDFSYM,         DECC$GXVSNPRINTF
+     [...]
+
+- Changed VMS.C:
+
+   - Fixed a build problem with C RTL before V7.2:
+        %CC-E-UNDECLARED, In this statement, "DVI$C_ACP_F11V5" is not
+        declared. at line number 262 in file
+        disk:[xxx.WGET-1_9_1A_VMS.SRC]VMS.C;1
+
+   - Fixed a build problem with C RTL before VMS V7.3 with C Runtime ECO
+     2 on Alpha: 
+        %CC-I-IMPLICITFUNC, In this statement, the identifier
+        "decc$feature_get_index" is implicitly declared as a function.
+        at line number 155 in file disk:[xxx.WGET-1_9_1A_VMS.SRC]VMS.C;1
+
+        %CC-I-IMPLICITFUNC, In this statement, the identifier
+        "decc$feature_get_value" is implicitly declared as a function.
+        at line number 159 in file disk:[xxx.WGET-1_9_1A_VMS.SRC]VMS.C;1
+
+        %CC-I-IMPLICITFUNC, In this statement, the identifier
+        "decc$feature_set_value" is implicitly declared as a function.
+        at line number 169 in file disk:[xxx.WGET-1_9_1A_VMS.SRC]VMS.C;1
+
+     and the related: 
+
+        %LINK-W-NUDFSYMS, 3 undefined symbols:
+        %LINK-I-UDFSYM,         DECC$FEATURE_GET_INDEX
+        %LINK-I-UDFSYM,         DECC$FEATURE_GET_VALUE
+        %LINK-I-UDFSYM,         DECC$FEATURE_SET_VALUE
+        [...]
+
+   - Fixed a build problem with Multinet involving use of both the
+     Multinet-specific and generic netdb.h header files:
+
+        %CC-E-REDEFSTRUCT, In this declaration, the struct "hostent" is
+        redefined. at line number 178 in module NETDB of text library
+        SYS$COMMON:[SYSLIB]DECC$RTLDEF.TLB;1
+
+   - Fixed a typographical error (unclosed comment) which kept the C RTL
+     feature DECC$EFS_CHARSET from being enabled as intended. This
+     caused a run-time problem on non-VAX systems with some ODS5
+     extended file specifications with multiple dots in file names,
+     typically when "-m" ("--mirror"), "-O" ("--output-document"), or
+     "-r" ("--recursive") was used: 
+
+        hostname/test/a.B.c: file specification syntax error
+     or
+        test/a.B.c: non-translatable vms error code: 0x186D4
+        rms-f-syn, file specification syntax error
+
+   - Fixed a spurious diagnostic message when doing HTTP and
+     complex FTP transfers: 
+
+        utime().  sys$parse() = 00010001.
+
+- Changed FTP.C to fix a variety of problems encountered when using a
+  VMS FTP server.  These problems (not seen in Wget 1.5.3h) were caused
+  mostly by inappropriate code added (in the main Wget development
+  stream) to "help" deal with a VMS FTP server.  Removing this code and
+  reforming the procedure used for getting to relative directories seems
+  to have fixed the problems.  As before, a single-slash URL
+  ("ftp://host/one/two/name.type") will be treated as specifying a
+  relative directory ("one/two"), while a double-slash URL
+  ("ftp://host//one/two/name.type") will be treated as specifying an
+  absolute directory ("/one/two").  As usual, the VMS FTP server will
+  attempt to puzzle out whether "/one/two" should really be interpreted
+  as "one:[two]", but it's better equipped to do it than Wget is.
+
+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+
+   Version 1.9.1a  2004-04-28
+   --------------------------
+
+- Changes to VMS-WGET.COM since Wget 1.5.3h:
+
+   - A separate LIST command-line option now controls compiler listing
+     files.  The DBG option no longer implies compiler listing files. 
+     The LIST option also generates a link map with cross-reference.
+
+   - The DBG option may actually work now.
+
+   - Added support for IA64 architecture.
+
+- Changes to DESCRIP.MMS since Wget 1.5.3h:
+
+   - Compiler listing files (.LIS) and link maps (.MAP) are now put into
+     the system-specific directory with the corresponding object files
+     (.OBJ), namely, [.SRC.ALPHA], [.SRC.IA64], or [.SRC.VAX]. 
+     Previously, they were put into the source directory ([.SRC])
+     itself.
+
+   - CLEAN target now deletes any .LIS and .MAP files.
+
+   - New HELP target creates a Wget help library.
+
+   - The OS_TYPE macro is now defined, including the VMS version.
+
+   - No more complaints like "%MMS-W-MBREDEFILL, Illegal attempt to
+     redefine macro 'CFLAGS'" on old versions of MMS.
+
+   - A separate LIST macro now controls compiler listing files.  The
+     DBG macro no longer implies compiler listing files.
+
+   - New support for IA64 architecture.
+
+- Built-in initialization of some DECC$* run-time options on non-VAX
+  systems.  Currently this behavior is compiled in, so any changes must
+  be made in the VMS.C source file.  These changes have no effect on VAX
+  (or older Alpha) systems where the OS and C run-time support is
+  absent.
+
+   - Command-line case preservation.  Wget for VMS enables the following
+     DECC$* run-time option:
+        DECC$ARGV_PARSE_STYLE
+     With extended command parsing enabled ("SET PROCESS
+     /PARSE_STYLE = EXTENDED"), command-line case is preserved.  This
+     obviates quoting case-sensitive option switches, URLs, and other
+     parameters.
+
+   - Extended file names on ODS5 file systems.  Wget for VMS enables the
+     following DECC$* run-time options:
+        DECC$EFS_CASE_PRESERVE
+        DECC$EFS_CHARSET
+     Thus, if an ODS5 file system is used as the destination for
+     downloaded files, multiple dots will be permitted and case will be
+     preserved in file names.  If an ODS2 file system is used, the same
+     character substitutions will be made as in Wget 1.5.3h, namely,
+     "." -> "_" (where needed), "~" -> "-", and "@" -> "$".
+
+------------------------------------------------------------------------
+
+      Changes to Source Files
+      -----------------------
+
+   Files new for VMS (all in [.VMS]):
+
+      COLLECT_DEPS.COM   Dependency collector for DESCRIP_MKDEPS.MMS.
+
+      config.h_vms       VMS-specific CONFIG.H.
+
+      decc_ver.c         Diagnostic program to provide build environment
+                         information.
+
+      DESCRIP.MMS        Main MMK or MMS description ("make") file.
+
+      DESCRIP_CONFIG.MMS CONFIG.H description file.
+
+      DESCRIP_DEPS.MMS   Source dependency description file.
+
+      DESCRIP_MKDEPS.MMS Source dependency generator description file.
+
+      DESCRIP_SRC.MMS    Source list description file.
+
+      VMS-WGET.COM       DCL procedure to build the executable from the
+                         source, using MMK or MMS (and DESCRIP*.MMS).
+
+      vms.c              Various VMS-specific code: DEC C run-time
+                         initialization, ODS2-ODS5 file system
+                         detection, ODS2 file name adjustment, file open
+                         callback function for better RMS parameters,
+                         "utime()" replacement function, and for VMS
+                         before V7.0, "getpwuid()" and "localtime_r()".
+
+      vms.h              VMS-specific header file.  For VMS C RTL before
+                         V7.3, replacement for <utime.h>.  For VMS C RTL
+                         before V7.0, replacement for <pwd.h>. 
+                         Declarations of replacement data
+                         types/structures and function prototypes for
+                         vms.c.
+
+      vms_ip.h           IP software type-specific "#include"
+                         directives.  Used by host.c.
+
+      vms_name_fix.sh    UNIX shell script to restore file names after
+                         storage on an ODS2 file system.
+
+      VMS_NOTES.TXT      These notes.
+
+      WGET.HLP           Simple help file.
+
+      WGET.OPT           LINK options file.
+
+      WGET_MULTINET.OPT  LINK options file supplement for Multinet.
+
+      WGET_SSL.OPT       LINK options file supplement for OpenSSL.
+
+      WGET_SSL_HP.OPT    LINK options file supplement for HP SSL.
+
+
+   Files modified for VMS (all in [.SRC]):
+
+      connect.c         Added code for VMS header files.
+
+      convert.c         Changed to use "_orig" instead of ".orig" on VMS
+                        as the file name suffix used for the "-K"
+                        ("--backup-converted") option.
+
+      ftp.c             Added code for VMS header files.
+                        Changed to eliminate a spurious -debug message
+                        ("Unrecognized permissions for <directory>").
+                        Changed to eliminate spurious complaints when
+                        recursive downloads hit an empty directory.
+                        Changed to fix various problems dealing with a
+                        VMS FTP server.
+                        Changed to fix various problems with FTP and
+                        time-stamping ("-N").
+                        Changed to distinguish between ASCII and binary
+                        FTP transfers for proper local line endings.
+                        Added (for VMS) VMS-specific file open options.
+
+      ftp.h             Added ftp_dele() function.  (See ftp-basic.c.)
+                        Added an argument to ftp_list() for the FTP
+                        server type.  (See ftp-basic.c.)
+
+      ftp-basic.c       Added ftp_dele() function to accomodate a remote
+                        delete-after-download option.
+                        Changed ftp_list() to avoid trying "LIST -a" for
+                        an VMS FTP server.
+
+      ftp-ls.c          Changed to open the ".listing" file in text
+                        mode, not binary.
+                        Changed VMS FTP DIR-parsing code to tolerate
+                        more variability (leading blank lines).
+                        Added support for the environment variable
+                        "WGET_TIMEZONE_DIFFERENTIAL" for file time
+                        adjustment (as in Wget 1.5.3h for VMS).
+
+      host.c            Added code for VMS header files.
+
+      host.h            Added code for VMS header files.
+      
+      http.c            Added code for VMS header files.
+                        Changed to use an OS-specific file name suffix,
+                        "_orig" for VMS, rather than a hard-coded
+                        ".orig".
+                        Added (for VMS) VMS-specific file open options.
+                        Added (for VMS) host type and OS version info to
+                        the default User-Agent string.
+                        Changed "ssl_connect()" to "ssl_connect_wget()"
+                        to avoid conflict with "SSL_connect()".
+                        Added a type cast to remove a
+                        %CC-I-QUESTCOMPARE1 compiler complaint.
+
+      init.c            Changed (on VMS) to use "SYS$LOGIN:.wgetrc" as
+                        the name of the user-specific initialization
+                        file (if "WGETRC" is not defined), and
+                        "SYSTEM_WGETRC" (expected to be a logical name)
+                        as the system-wide initialization file.
+                        Changed to open ".wgetrc" in text mode, not
+                        binary.
+                        Added (for VMS) "--ftp-stmlf" option ("ftpstmlf
+                        on" command to force Stream_LF format (instead
+                        of fixed-512) for binary FTP output files.
+
+      log.c             Changed the I/O scheme on VMS for progress dots
+                        to avoid spurious newline characters when output
+                        is directed to a file.
+
+      main.c            Changed the program identification debug message
+                        ("built on OS_TYPE" instead of "on OS_TYPE"),
+                        and added host information to the "-V" version
+                        report.
+                        Changed to set ODS5 flag if the download
+                        destination is on an ODS5 file system.
+                        Added (for VMS) "--ftp-stmlf" option ("ftpstmlf
+                        on" command to force Stream_LF format (instead
+                        of fixed-512) for binary FTP output files.
+                        Adjusted the help message for -K to say "_orig"
+                        instead of ".orig".  (See convert.c.)
+
+      netrc.c           Changed to use "SYS$LOGIN:.netrc" as the name of
+                        the user name and password file on VMS.
+
+      openssl.c         Changed "ssl_connect()" to "ssl_connect_wget()"
+                        to avoid conflict with "SSL_connect()".
+
+      options.h         Added (for VMS) "--ftp-stmlf" option ("ftpstmlf
+                        on" command to force Stream_LF format (instead
+                        of fixed-512) for binary FTP output files.
+
+      retr.c            Changed to adjust CR-LF line endings in ASCII
+                        FTP data to proper local line endings.
+                        Changed to disable (for VMS) a useless fflush()
+                        which was slowing file I/O.
+
+      retr.h            Changed to accomodate changes for FTP to
+                        distinguish between ASCII and binary FTP
+                        transfers for proper local ASCII line endings.
+
+      ssl.h             Changed "ssl_connect()" to "ssl_connect_wget()"
+                        to avoid conflict with "SSL_connect()".
+
+      url.c             Added code for VMS header files.
+                        Added code to replace unacceptable dots (".")
+                        (and other invalid characters) with underscores
+                        ("_"), tildes ("~") with hyphens ("-"), and at
+                        signs ("@") with dollar signs ("$"),
+                        respectively, in URL-derived file specifications
+                        on ODS2 file systems.
+
+      utils.c           Added VMS-specific code to work around the lack
+                        of "fork()".
+                        Changed to assist ODS2 name reversion.
+                        Added (for VMS) VMS-specific file open options.
+                        Changed to use a macro, UNIQ_SEP, instead of a
+                        hard-coded ".", as the separator character when
+                        adding a decimal "nnn" suffix to a file name to
+                        make it unique.  Not defining UNIQ_SEP, as on
+                        VMS, now disables adding the suffix.  (See
+                        WGET.H.)
+
+      utils.h           Added a declaration of the character properties
+                        look-up table for use in ftp-ls.c.
+
+      version.h         Adapted from version.c.  Changed the version
+                        string from "1.11" to "1.11a".
+
+      wget.h            Added a definition of an OS-specific file name
+                        suffix, ORIG_SFX ("_orig", for VMS), to be used
+                        instead of a hard-coded ".orig".  (See
+                        convert.c, http.c.)
+                        Added a definition of an OS-specific separator
+                        character, UNIQ_SEP, for the decimal "nnn"
+                        version number appended to a file name to make
+                        it unique.  (See utils.c.)
+                        Fixed a defective typedef (affecting small-file
+                        builds).
+
+------------------------------------------------------------------------
+
+      Home source URL
+      ---------------
+
+http://www.gnu.org/directory/wget.html
+http://ftp.gnu.org/gnu/wget/
+ftp://ftp.gnu.org/gnu/wget/
+
+------------------------------------------------------------------------
+
+      Instructions
+      ------------
+
+   Extract the files from the distribution kit.  The kit includes
+objects and executables for Alpha, IA64, and VAX, in the corresponding
+host-specific subdirectories.  These builds were done with options
+(explained below) "DASHD", "LARGE" (except VAX), and "NOSSL".
+
+   The command procedure VMS-WGET.COM attempts to determine the CPU
+type, the IP package, and SSL availability.  It defines the appropriate
+macros for MMK or MMS, and then builds the appropriate executable from
+the source:
+
+      SET DEFAULT [.WGET-1_10_2C_VMS.VMS]   ! For convenience.
+      @ VMS-WGET CLEAN  ! Deletes all object, list, map, and executable
+                        ! files for the current CPU type.
+      @ VMS-WGET        ! Copies CONFIG.H_VMS to CONFIG.H, compiles the
+                        ! source files, and links the executable,
+                        ! WGET.EXE.
+                        ! Add "DASHD" to this command line to enable the
+                        ! Wget "-d" command-line option.
+                        ! Add "DBG" to this command line to build a
+                        ! debug executable.
+                        ! Add "LARGE" to enable large-file support on
+                        ! non-VAX systems.
+                        ! Add "LIST" if compiler listing and link map
+                        ! files are desired.
+                        ! Add "MMS" to use MMS instead of MMK when both
+                        ! are available.
+                        ! Add "NOSSL" to inhibit use of any SSL package.
+                        ! Add "HPSSL" to use the HP SSL package when
+                        ! OpenSSL (the default choice) is also available.
+      @ VMS-WGET HELP   ! Creates a help library.  (Optional.  See
+                        ! below.)
+
+   Set the symbol for the foreign command:
+
+      WGET :== $ actual_device:[actual.directory]WGET.EXE
+
+   A very basic VMS HELP file is supplied in [.DOC]WGET.HLP.  To be
+used, it must be added to a HELP library, either an existing library or
+one just for Wget.  As mentioned above, a new Wget help library may be
+created using the command, "@ VMS-WGET HELP".
+
+   When a new HELP library is created, a logical name "HLP$LIBRARY_n"
+may be defined to allow the HELP utility to find it.  See "HELP HELP
+/USERLIBRARY" for details.
+
+   Try to read the original documentation to learn how to use Wget.  The
+principal differences in this VMS adaptation are:
+
+   "-b" ("background") has no effect.  (It uses "fork()".)
+
+   Excess dots are replaced by underscores in URL-derived file
+specifications on ODS2 file systems.  For example, on a UNIX system, the
+URL "ftp://ftp.anywhere.org/x.y.z/a.b.c" could produce the local file
+"ftp.anywhere.org/x.y.z/a.b.c".  With this VMS adaptation, the local
+ODS2 file would be "[.FTP_ANYWHERE_ORG.X_Y_Z]A_B.C".  On an ODS5 file
+system, the file would be [.ftp^.anywhere^.org.x^.y^.z]a^.b.c".
+
+------------------------------------------------------------------------
+
+   The accompanying source kit may suffer from storage on an ODS2 file
+system, which does not preserve case or allow multiple dots in a file
+name.  Building this kit should work on VMS, but it may be expected to
+fail on other systems.  To use this kit on a non-VMS system, the files
+may need to be renamed to restore their original mixed-case and/or
+multi-dot names.  The UNIX shell script "vms_name_fix.sh" (or something
+like it) should do the job.
+
+------------------------------------------------------------------------
+
+   Steven M. Schweda               (+1) 651-699-9818  (voice)
+   382 South Warwick Street        sms@antinode.org
+   Saint Paul  MN  55105-2547
+
diff --git a/vms/WGET.HLP b/vms/WGET.HLP
new file mode 100644
index 0000000..f99c777
--- /dev/null
+++ b/vms/WGET.HLP
@@ -0,0 +1,245 @@
+1 WGET
+ GNU Wget 1.11a, a non-interactive network retriever.
+ Usage:
+        WGET :== $ device:[directory]WGET.EXE  ! Define foreign command.
+        WGET [OPTION [...]] [URL [...]]
+
+ Mandatory arguments for long options are also mandatory for short options.
+
+2 Startup
+  -V,  --version           display the version of Wget and exit.
+  -h,  --help              print this help.
+  -b,  --background        go to background after startup. (Ignored on VMS.)
+  -e,  --execute=COMMAND   execute a `.wgetrc'-style command.
+
+2 Logging_and_input_file
+  -o,  --output-file=FILE    log messages to FILE.
+  -a,  --append-output=FILE  append messages to FILE.
+  -d,  --debug               print debugging information.
+  -q,  --quiet               quiet (no output).
+  -v,  --verbose             be verbose.  (This is the default.)
+  -nv, --non-verbose         turn off verboseness, without being quiet.
+  -i,  --input-file=FILE     download URLs found in FILE.
+  -F,  --force-html          treat input file as HTML.
+  -B,  --base=URL            prepends URL to relative links in -F -i file.
+
+2 Download
+  -t,  --tries=NUMBER            set number of retries to NUMBER
+                                 (0 unlimits).
+       --retry-connrefused       retry even if connection is refused.
+  -O   --output-document=FILE    write documents to FILE.
+  -nc, --no-clobber              skip downloads that would download to
+                                 existing files.
+  -c,  --continue                resume getting a partially downloaded file.
+       --progress=TYPE           select progress gauge type.
+  -N,  --timestamping            don't re-retrieve files unless newer than
+                                 local.
+  -S,  --server-response         print server response.
+       --spider                  don't download anything.
+  -T,  --timeout=SECONDS         set all timeout values to SECONDS.
+       --dns-timeout=SECS        set the DNS lookup timeout to SECS.
+       --connect-timeout=SECS    set the connect timeout to SECS.
+       --read-timeout=SECS       set the read timeout to SECS.
+  -w,  --wait=SECONDS            wait SECONDS between retrievals.
+       --waitretry=SECS          wait 1...SECS between retrieval retries.
+       --random-wait             wait from 0...2*WAIT secs between
+                                 retrievals.
+       --no-proxy                explicitly turn off proxy.
+  -Q,  --quota=NUMBER            set retrieval quota to NUMBER.
+       --bind-address=ADDRESS    bind to ADDRESS (hostname or IP) on local
+                                 host.
+       --limit-rate=RATE         limit download rate to RATE.
+       --no-dns-cache            disable caching DNS lookups.
+       --restrict-file-names=OS  restrict file name chars to ones OS allows.
+       --ignore-case             ignore case when matching files/dirs.
+  -4,  --inet4-only              connect only to IPv4 addresses.
+  -6,  --inet6-only              connect only to IPv6 addresses.
+       --prefer-family=FAMILY    connect first to addresses of specified
+                                 family, one of IPv6, IPv4, or none.
+       --user=USER               set both FTP and HTTP user to USER.
+       --password=PASS           set both FTP and HTTP password to PASS.
+
+2 Directories
+  -nd  --no-directories           don't create directories.
+  -x,  --force-directories        force creation of directories.
+  -nH, --no-host-directories      don't create host directories.
+       --protocol-directories     use protocol name in directories.
+  -P,  --directory-prefix=PREFIX  save files to PREFIX/...
+       --cut-dirs=NUMBER          ignore NUMBER remote directory components.
+
+2 HTTP_options
+       --http-user=USER        set HTTP user to USER.
+       --http-passwd=PASS      set HTTP password to PASS.
+       --no-cache              disallow server-cached data.
+  -E,  --html-extension        save HTML documents with ".html" extension.
+       --ignore-length         ignore "Content-Length" header field.
+       --header=STRING         insert STRING among the headers.
+       --proxy-user=USER       set USER as proxy username.
+       --proxy-passwd=PASS     set PASS as proxy password.
+       --referer=URL           include "Referer: URL" header in HTTP
+                               request.
+       --save-headers          save the HTTP headers to file.
+  -U,  --user-agent=AGENT      identify as AGENT instead of Wget/VERSION.
+       --no-http-keep-alive    disable HTTP keep-alive (persistent
+                               connections).
+       --no-cookies            don't use cookies.
+       --load-cookies=FILE     load cookies from FILE before session.
+       --save-cookies=FILE     save cookies to FILE after session.
+       --keep-session-cookies  load and save session (non-permanent)
+                               cookies.
+       --post-data=STRING      use the POST method; send STRING as the data.
+       --post-file=FILE        use the POST method; send contents of FILE.
+       --content-disposition   honor the Content-Disposition header when
+                               choosing local file names (EXPERIMENTAL).
+
+2 HTTPS (SSL/TLS) options:
+       --secure-protocol=PR     choose secure protocol, PR, one of: auto,
+                                SSLv2, SSLv3, and TLSv1.
+       --no-check-certificate   don't validate the server's certificate.
+       --certificate=FILE       client certificate file.
+       --certificate-type=TYPE  client certificate type, PEM or DER.
+       --private-key=FILE       private key file.
+       --private-key-type=TYPE  private key type, PEM or DER.
+       --ca-certificate=FILE    file with the bundle of CA's.
+       --ca-directory=DIR       directory where hash list of CA's is stored.
+       --random-file=FILE       FILE with random data to seed the SSL PRNG.
+       --egd-file=FILE          FILE naming the EGD socket with random data.
+
+2 FTP_options
+       --ftp-stmlf             All binary FTP files use Stream_LF format.
+       --ftp-user=USER         set FTP user to USER.
+       --ftp-password=PASS     set FTP password to PASS.
+       --no-remove-listing     don't remove ".listing" files.
+       --no-glob               turn off FTP file name globbing.
+       --no-passive-ftp        disable the "passive" transfer mode.
+       --retr-symlinks         when recursing, get linked-to files (not
+                               dir).
+       --preserve-permissions  preserve remote file permissions.
+
+2 Recursive_retrieval
+  -r,  --recursive          recursive download.
+  -l,  --level=NUMBER       maximum recursion depth (inf or 0 for infinite).
+       --delete-after       delete files locally after downloading them.
+  -k,  --convert-links      make links in downloaded HTML point to local
+                            files.
+  -K,  --backup-converted   before converting file X, back up as X_orig.
+  -m,  --mirror             shortcut for -r -N -l inf --no-remove-listing.
+  -p,  --page-requisites    get all images, etc. needed by HTML page.
+       --strict-comments    turn on strict (SGML) handling of HTML comments.
+
+2 Recursive_accept-reject
+  -A,  --accept=LIST               comma-separated list of accepted
+                                   extensions.
+  -R,  --reject=LIST               comma-separated list of rejected
+                                   extensions.
+  -D,  --domains=LIST              comma-separated list of accepted domains.
+       --exclude-domains=LIST      comma-separated list of rejected domains.
+       --follow-ftp                follow FTP links from HTML documents.
+       --follow-tags=LIST          comma-separated list of followed HTML
+                                   tags.
+  -G,  --ignore-tags=LIST          comma-separated list of ignored HTML
+                                   tags.
+  -H,  --span-hosts                go to foreign hosts when recursive.
+  -L,  --relative                  follow relative links only.
+  -I,  --include-directories=LIST  list of allowed directories.
+  -X,  --exclude-directories=LIST  list of excluded directories.
+  -np, --no-parent                 don't ascend to the parent directory.
+
+2 VMS_specifics
+ Wget on VMS systems may behave differently in some ways from Wget on other
+ systems.
+
+ The "-b" or "--background" command-line option is ignored on VMS systems.
+
+ Other differences involve command-line case, restrictions on directory
+ and file names, some FTP behavior, and some RMS default parameters.
+
+3 Command-line_case
+ On non-VAX systems, Wget for VMS enables the following DECC$* run-time
+ option:
+    DECC$ARGV_PARSE_STYLE
+
+ This way, with extended command parsing enabled ("SET PROCESS
+ /PARSE_STYLE = EXTENDED"), command-line case is preserved, which
+ obviates quoting case-sensitive option switches, URLs, and other
+ parameters.
+
+3 Directory_and_file_names
+ When the destination for a downloaded file is an ODS2 file system,
+ excessive dots (".") in file names and directory names generated by
+ recursive retrieval (which would be illegal in ODS2 directory or file
+ names) are replaced by underscores ("_").  All tildes ("~") are replaced
+ by hyphens ("-"), and all "at" signs ("@") are replaced by dollar signs
+ ("$").  Any other invalid characters are replaced by underscores ("_").
+ Also, case information is lost.
+
+ For example, the command:
+ wget -r "ftp://ftp.xfree86.org/pub/XFree86/3.3.5/binaries/NetBSD-1.3/"
+
+ on a UNIX system, should put files into the directory:
+ ./ftp.xfree86.org/pub/XFree86/3.3.5/binaries/NetBSD-1.3/
+
+ while on a VMS ODS2 file system, the directory would be:
+ [.FTP_XFREE86_ORG.PUB.XFREE86.3_3_5.BINARIES.NETBSD-1_3]
+
+ When the destination for a downloaded file is an ODS5 file system, the
+ ODS5-invalid characters "?" and "*" are converted to "!" and "#",
+ respectively.
+
+ On non-VAX systems, Wget for VMS enables the following DECC$* run-time
+ options:
+    DECC$EFS_CHARSET
+    DECC$EFS_CASE_PRESERVE
+
+ This way, when the destination for a downloaded file is an ODS5 file
+ system, multiple dots will be permitted and case will be preserved in
+ directory and file names, so the previous example directory would be:
+ [.ftp^.xfree86^.org.pub.XFree86.3^.3^.5.binaries.NetBSD-1^.3]
+
+3 FTP_file_date
+ Files downloaded using FTP from some servers may get date-time info in
+ server-local time.  Define an environment variable (symbol or logical
+ name) WGET_TIMEZONE_DIFFERENTIAL (a signed time in seconds) to offset
+ these file dates.
+
+3 FTP_file_format
+ By default, when Wget does a binary (Image) FTP transfer, the
+ destination file is created with fixed-length, 512-byte records.  When
+ Wget does an ASCII FTP transfer, the destination file is created with
+ Stream_LF format.
+
+ In Wget versions before 1.10.1, an FTP destination file was always
+ created with Stream_LF format.
+
+ A new command-line option, --ftp-stmlf, forces all FTP destination
+ files to Stream_LF format, as in Wget versions before 1.10.1.
+
+ Add ";type=a" to the end of an FTP URL to specify an ASCII transfer.
+
+ Destination files specified using "-O" ("--output-document") are always
+ created with Stream_LF format.
+
+3 FTP_file_versions
+ To specify an explicit ";nnn" version number in an FTP URL, escape the
+ ";" as "%3B", or, if the (VMS) FTP server will accept it, use a second
+ dot.  For example, for "file.type;25" use a URL like:
+    ftp://server/directory/file.type%3B25
+ or:
+    ftp://server/directory/file.type.25
+
+3 RMS_default_parameters
+ For improved I/O speed, when writing a downloaded file, Wget uses these
+ RMS parameter values by default: BLOCK_COUNT = 127, BUFFER_COUNT = 2,
+ EXTEND_QUANTITY = 16384.
+
+ The user may overide these values by specifying different (non-zero)
+ values for these parameters using the SET RMS_DEFAULT command.
+
+3 File_attributes
+ As with many C programs which originated on non-VMS systems, Wget may
+ make some assumptions about file attributes which can cause some
+ problems.  One example is the "--post-file=FILE" option, which requires
+ that the "FILE" be in Stream_LF format.  (In this case, HTTP 1.0
+ requires the length of the request to be known, and the method used to
+ determine the size of the file will fail for Variable-length format
+ files.) 
diff --git a/vms/WGET.OPT b/vms/WGET.OPT
new file mode 100644
index 0000000..859f5cd
--- /dev/null
+++ b/vms/WGET.OPT
@@ -0,0 +1,32 @@
+odir:CMPT.OBJ
+odir:CONNECT.OBJ
+odir:CONVERT.OBJ
+odir:COOKIES.OBJ
+odir:FTP-BASIC.OBJ
+odir:FTP-LS.OBJ
+odir:FTP-OPIE.OBJ
+odir:FTP.OBJ
+odir:GEN-MD5.OBJ
+odir:GETOPT.OBJ
+odir:GNU-MD5.OBJ
+odir:HASH.OBJ
+odir:HOST.OBJ
+odir:HTML-PARSE.OBJ
+odir:HTML-URL.OBJ
+odir:HTTP.OBJ
+odir:INIT.OBJ
+odir:LOG.OBJ
+odir:MAIN.OBJ
+odir:NETRC.OBJ
+odir:PTIMER.OBJ
+odir:PROGRESS.OBJ
+odir:RECUR.OBJ
+odir:RES.OBJ
+odir:RETR.OBJ
+odir:SAFE-CTYPE.OBJ
+odir:SNPRINTF.OBJ
+odir:SPIDER.OBJ
+odir:URL.OBJ
+odir:UTILS.OBJ
+odir:VMS.OBJ
+odir:XMALLOC.OBJ
diff --git a/vms/WGET_MULTINET.OPT b/vms/WGET_MULTINET.OPT
new file mode 100644
index 0000000..ca51b1f
--- /dev/null
+++ b/vms/WGET_MULTINET.OPT
@@ -0,0 +1 @@
+MULTINET_SOCKET_LIBRARY /SHAREABLE
diff --git a/vms/WGET_SSL.OPT b/vms/WGET_SSL.OPT
new file mode 100644
index 0000000..7ceebf4
--- /dev/null
+++ b/vms/WGET_SSL.OPT
@@ -0,0 +1,4 @@
+odir:HTTP-NTLM.OBJ
+odir:OPENSSL.OBJ
+SSLLIB:LIBSSL.OLB /LIBRARY
+SSLLIB:LIBCRYPTO.OLB /LIBRARY
diff --git a/vms/WGET_SSL_HP.OPT b/vms/WGET_SSL_HP.OPT
new file mode 100644
index 0000000..591573f
--- /dev/null
+++ b/vms/WGET_SSL_HP.OPT
@@ -0,0 +1,4 @@
+odir:HTTP-NTLM.OBJ
+odir:OPENSSL.OBJ
+SYS$SHARE:SSL$LIBSSL_SHR32 /SHARE
+SYS$SHARE:SSL$LIBCRYPTO_SHR32 /SHARE
diff --git a/vms/config.h_vms b/vms/config.h_vms
new file mode 100644
index 0000000..ae7be46
--- /dev/null
+++ b/vms/config.h_vms
@@ -0,0 +1,391 @@
+/* vms/config.h_vms.  VMS-specific config.h for Wget 1.11. */
+/* Hand-edited from Tru64: src/config.h.  Generated by configure. */
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define if you want the debug output support compiled in. */
+#define ENABLE_DEBUG 1
+
+/* Define if you want the HTTP Digest Authorization compiled in. */
+#define ENABLE_DIGEST 1
+
+/* Define if IPv6 support is enabled. */
+#if !defined( __VAX)
+# define ENABLE_IPV6 1
+#endif /* !defined( __VAX) */
+
+/* Define if you want the NTLM authorization support compiled in. */
+/* #define ENABLE_NTLM 1 */
+
+/* Define if you want the Opie support for FTP compiled in. */
+#define ENABLE_OPIE 1
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+/* #define HAVE_ALLOCA 1 */
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+/* #define HAVE_ALLOCA_H 1 */
+
+/* VMS alloca.  (_LARGEFILE must be defined before this.) */
+#    include <builtins.h>
+#    define alloca __ALLOCA
+
+/* Define to use built-in MD5. */
+#define HAVE_BUILTIN_MD5 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+/* #define HAVE_CLOCK_GETTIME 1 */
+#if __CRTL_VER >= 70320000
+# define HAVE_CLOCK_GETTIME 1
+#endif /* __CRTL_VER >= 70320000 */
+
+/* Define to 1 if you have the `drand48' function. */
+#if __CRTL_VER >= 70000000
+# define HAVE_DRAND48 1
+#endif /* __CRTL_VER >= 70000000 */
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+/* #undef HAVE_FSEEKO */
+#if __CRTL_VER >= 70301000
+# define HAVE_FSEEKO 1
+#endif /* __CRTL_VER >= 70301000 */
+
+/* Define to 1 if you have the `ftello' function. */
+/* #define HAVE_FTELLO 1 */
+#if __CRTL_VER >= 70301000
+# define HAVE_FTELLO 1
+#endif /* __CRTL_VER >= 70301000 */
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+/* #define HAVE_GETADDRINFO 1 */
+#if __CRTL_VER >= 70300000
+# define HAVE_GETADDRINFO 1
+#endif /* __CRTL_VER >= 70300000 */
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define to 1 if you have the `getpagesize' function. */
+/* #define HAVE_GETPAGESIZE 1 */
+#if __CRTL_VER >= 70000000
+# define HAVE_GETPAGESIZE 1
+#endif /* __CRTL_VER >= 70000000 */
+
+/* Define to 1 if you have the `gettext' function. */
+/* #undef HAVE_GETTEXT */
+
+/* Define to 1 if you have the `inet_ntoa' function. */
+#define HAVE_INET_NTOA 1
+
+/* Define to 1 if the system has the type `int64_t'. */
+#if !defined( __VAX)
+# define HAVE_INT64_T 1
+#endif /* !defined( __VAX) */
+
+/* Define to 1 if the system has the type `intptr_t'. */
+#define HAVE_INTPTR_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `isatty' function. */
+#define HAVE_ISATTY 1
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+/* #undef HAVE_LIBDL */
+
+/* Define if you have the gnutls library. */
+/* #undef HAVE_LIBGNUTLS */
+
+/* Define to 1 if you have the <libintl.h> header file. */
+/* #undef HAVE_LIBINTL_H */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+/* #undef HAVE_LIBRT */
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define if you have the ssl library. */
+/* #undef HAVE_LIBSSL */
+
+/* Define if we're compiling support for MD5. */
+#define HAVE_MD5 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memrchr' function. */
+/* #undef HAVE_MEMRCHR */
+
+/* Define to 1 if you have a working `mmap' system call. */
+#define HAVE_MMAP 1
+
+/* Define if you have the nanosleep function. */
+/* #define HAVE_NANOSLEEP 1 */
+#if __CRTL_VER >= 70320000
+# define HAVE_NANOSLEEP 1
+#endif /* __CRTL_VER >= 70320000 */
+
+/* Define this if you want the NLS support. */
+/* #undef HAVE_NLS */
+
+/* Define when using OpenSSL MD5. */
+/* #undef HAVE_OPENSSL_MD5 */
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define to 1 if you have the `sigblock' function. */
+#define HAVE_SIGBLOCK 1
+
+/* Define to 1 if you have the `sigsetjmp' function. */
+#define HAVE_SIGSETJMP 1
+
+/* Define to 1 if the system has the type `sig_atomic_t'. */
+#define HAVE_SIG_ATOMIC_T 1
+
+/* Define to 1 if you have the `snprintf' function. */
+/* #define HAVE_SNPRINTF 1 */
+#if (!defined( __VAX)) && (__CRTL_VER >= 70312000)
+# define HAVE_SNPRINTF 1
+#endif /* (!defined( __VAX)) && (__CRTL_VER >= 70312000) */
+
+/* Define if struct sockaddr_in6 has the sin6_scope_id member */
+/* #define HAVE_SOCKADDR_IN6_SCOPE_ID 1 */
+
+/* Define when using Solaris MD5. */
+/* #undef HAVE_SOLARIS_MD5 */
+
+/* Define to 1 if stdbool.h conforms to C99. */
+/* #undef HAVE_STDBOOL_H */
+#if defined(__DECC) && __DECC_VER >= 60400000
+# define HAVE_STDBOOL_H 1
+#endif /* defined(__DECC) && __DECC_VER >= 60400000 */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+/* #define HAVE_STDINT_H 1 */
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+/* #define HAVE_STRCASECMP 1 */
+#if __CRTL_VER >= 70000000
+# define HAVE_STRCASECMP 1
+#endif /* __CRTL_VER >= 70000000 */
+
+/* Define to 1 if you have the `strdup' function. */
+/* #define HAVE_STRDUP 1 */
+#if __CRTL_VER >= 70000000
+# define HAVE_STRDUP 1
+#endif /* __CRTL_VER >= 70000000 */
+
+/* Define to 1 if you have the <strings.h> header file. */
+/* #define HAVE_STRINGS_H 1 */
+#if __CRTL_VER >= 70000000
+# define HAVE_STRINGS_H 1
+#endif /* __CRTL_VER >= 70000000 */
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strncasecmp' function. */
+/* #define HAVE_STRNCASECMP 1 */
+/* #define HAVE_STRNCASECMP 1 */
+#if __CRTL_VER >= 70000000
+# define HAVE_STRNCASECMP 1
+#endif /* __CRTL_VER >= 70000000 */
+
+/* Define to 1 if you have the `strptime' function. */
+#define HAVE_STRPTIME 1
+
+/* Define to 1 if you have the `strtoll' function. */
+/* #undef HAVE_STRTOLL */
+#if !defined(_ANSI_C_SOURCE) && !defined(__VAX)
+# define HAVE_STRTOLL 1
+#endif /* !defined(_ANSI_C_SOURCE) && !defined(__VAX) */
+
+/* Define to 1 if the system has the type `struct sockaddr_in6'. */
+/* #define HAVE_STRUCT_SOCKADDR_IN6 1 */
+
+/* Define to 1 if the system has the type `struct sockaddr_storage'. */
+/* #define HAVE_STRUCT_SOCKADDR_STORAGE 1 */
+
+/* Define to 1 if the system has the type `struct utimbuf'. */
+#define HAVE_STRUCT_UTIMBUF 1
+
+/* Define to 1 if you have the `symlink' function. */
+/* #define HAVE_SYMLINK 1 */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+/* #define HAVE_SYS_SELECT_H 1 */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/utime.h> header file. */
+/* #undef HAVE_SYS_UTIME_H */
+
+/* Define to 1 if you have the <termios.h> header file. */
+/* #define HAVE_TERMIOS_H 1 */
+
+/* Define to 1 if you have the `timegm' function. */
+/* #undef HAVE_TIMEGM */
+
+/* Define to 1 if the system has the type `uint32_t'. */
+#define HAVE_UINT32_T 1
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+/* #define HAVE_UTIME_H 1 */
+
+/* Define to 1 if you have the `vasprintf' function. */
+/* #undef HAVE_VASPRINTF */
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#if (!defined( __VAX)) && (__CRTL_VER >= 70312000)
+# define HAVE_VSNPRINTF 1
+#endif /* (!defined( __VAX)) && (__CRTL_VER >= 70312000) */
+
+/* Define if fnmatch.h can be included. */
+/* #define HAVE_WORKING_FNMATCH_H 1 */
+
+/* Define to 1 if the system has the type `_Bool'. */
+#if defined(__DECC) && __DECC_VER >= 60400000
+# define HAVE__BOOL 1
+#endif /* defined(__DECC) && __DECC_VER >= 60400000 */
+
+/* Define to be the name of the operating system. */
+#ifndef OS_TYPE
+# define OS_TYPE "VMS"
+#endif /* OS_TYPE */
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* The size of `long long', as computed by sizeof. */
+/* #define SIZEOF_LONG_LONG 8 */
+#ifndef __VAX
+# define SIZEOF_LONG_LONG 8
+#endif /* def __VAX */
+
+/* The size of `off_t', as computed by sizeof. */
+/* #define SIZEOF_OFF_T 8 */
+#ifdef __VAX
+# define SIZEOF_OFF_T 4
+#else /* def __VAX */
+# ifdef _LARGEFILE
+#  define SIZEOF_OFF_T 8
+# else /* def _LARGEFILE */
+#  define SIZEOF_OFF_T 4
+# endif /* def _LARGEFILE [else] */
+#endif /* def __VAX [else]*/
+
+/* The size of `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 4
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+/* #undef WORDS_BIGENDIAN */
+
+/* Define to 1 if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* # undef _ALL_SOURCE */
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to int or size_t on systems without socklen_t. */
+#define socklen_t size_t
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+/* #undef volatile */
+
+
+#include "config-post.h"
+
diff --git a/vms/decc_ver.c b/vms/decc_ver.c
new file mode 100644
index 0000000..8d9e514
--- /dev/null
+++ b/vms/decc_ver.c
@@ -0,0 +1,30 @@
+#include <stdio.h>
+
+int main( void)
+{
+#ifdef __VMS_VERSION
+printf( " __VMS_VERSION: >%s<.\n", __VMS_VERSION);
+#else /* def __VMS_VERSION */
+printf( " __VMS_VERSION: (undefined)<.\n");
+#endif /* def __VMS_VERSION [else] */
+
+#ifdef __VMS_VER
+printf( " __VMS_VER  = %d.\n", __VMS_VER);
+#else /* def __VMS_VER */
+printf( " __VMS_VER  = (undefined).\n");
+#endif /* def __VMS_VER [else] */
+
+#ifdef __DECC_VER
+printf( " __DECC_VER = %d.\n", __DECC_VER);
+#else /* def __DECC_VER */
+printf( " __DECC_VER = (undefined).\n");
+#endif /* def __DECC_VER */
+
+#ifdef __CRTL_VER
+printf( " __CRTL_VER = %d.\n", __CRTL_VER);
+#else /* def __CRTL_VER */
+printf( " __CRTL_VER = (undefined).\n");
+#endif /* def __CRTL_VER */
+
+return 0;
+}
diff --git a/vms/vms.c b/vms/vms.c
new file mode 100644
index 0000000..428b388
--- /dev/null
+++ b/vms/vms.c
@@ -0,0 +1,1050 @@
+/*
+ *    VMS supplement for "wget".
+ *
+ *======================================================================
+ *
+ *       vms_init()
+ *
+ *    On non-VAX systems, uses LIB$INITIALIZE to set a collection of C
+ *    RTL features without using the DECC$* logical name method.
+ *
+ *----------------------------------------------------------------------
+ *
+ *       vms_arch()
+ *
+ *    Returns (run-time) VMS architecture string.
+ *
+ *----------------------------------------------------------------------
+ *
+ *       vms_ver()
+ *
+ *    Returns (run-time) VMS version string.
+ *
+ *----------------------------------------------------------------------
+ *
+ *       set_ods5_dest()
+ *
+ *    Sets a global flag ("ods5_dest") according to the file system type
+ *    of the destination device.
+ *
+ *----------------------------------------------------------------------
+ *
+ *       ods_conform()
+ *
+ *   Simplifies a fancy URL-derived file name into an ODS2- or
+ *   ODS5-compatible file name.
+ *    
+ *----------------------------------------------------------------------
+ *
+ *       utime()
+ *
+ *    VMS C RTL before V7.3 lacks utime().  In V7.3, utime() sets only
+ *    the modified (revised) date, not the created date of a file.
+ *
+ *    UNIX "ls -l" reports the modified time.  VMS "DIRECTORY /DATE"
+ *    reports the creation time.  Reconciling these in FTP DIR reports
+ *    is non-trivial.
+ *
+ *    UNIX utime() sets revision and access times.  VMS does not always
+ *    maintain access times, so this utime() replacement sets the
+ *    creation and revision times to the specified revision (or
+ *    creation?) time.  Any access time is ignored.
+ *
+ *----------------------------------------------------------------------
+ *
+ *       getpwuid()
+ *
+ *    VMS C RTL before V7.0 lacks getpwuid().
+ *
+ *----------------------------------------------------------------------
+ *
+ */
+
+#include "vms.h"
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unixlib.h>
+
+#include <atrdef.h>
+#include <descrip.h>
+#include <dvidef.h>
+#include <fibdef.h>
+#include <iodef.h>
+#include <rms.h>
+#include <stsdef.h>
+#include <syidef.h>
+#include <lib$routines.h>
+#include <starlet.h>
+
+/* Use <iosbdef.h> if available.  Otherwise declare IOSB here. */
+
+#if !defined( __VAX) && (__CRTL_VER >= 70000000)
+#include <iosbdef.h>
+#else /* __CRTL_VER >= 70000000 */
+typedef struct _iosb {
+        unsigned short int iosb$w_status; /* Final I/O status   */
+        unsigned short int iosb$w_bcnt; /* 16-bit byte count    */
+        unsigned int iosb$l_dev_depend; /* 32-bit dev dependent */
+    } IOSB;
+#endif /* !defined( __VAX) && (__CRTL_VER >= 70000000) */
+
+/* Ugly work-around for bad type in VAX <atrdef.h>. */
+
+#ifdef __VAX
+#define UWA (unsigned int)
+#else /* def __VAX */
+#define UWA
+#endif /* def __VAX */
+
+#include "config.h"
+#include "wget.h"
+#include "utils.h"
+
+/*--------------------------------------------------------------------*/
+
+/* Global storage. */
+
+/*    Flag for an ODS5 destination directory. */
+
+int ods5_dest = -1;
+
+/*    Flag to sense if vms_init() was called. */
+
+int vms_init_done = -1;
+
+/*--------------------------------------------------------------------*/
+
+#if !defined( __VAX) && (__CRTL_VER >= 70301000)
+
+/* vms_init()
+
+      Uses LIB$INITIALIZE to set a collection of C RTL features without
+      requiring the user to define the corresponding logical names.
+*/
+
+/* Structure to hold a DECC$* feature name and its desired value. */
+
+typedef struct
+   {
+   char *name;
+   int value;
+   } decc_feat_t;
+
+/* Array of DECC$* feature names and their desired values. */
+
+decc_feat_t decc_feat_array[] = {
+   /* Preserve command-line case with SET PROCESS/PARSE_STYLE=EXTENDED */
+ { "DECC$ARGV_PARSE_STYLE", 1 },
+   /* Preserve case for file names on ODS5 disks. */
+ { "DECC$EFS_CASE_PRESERVE", 1 },
+   /* Enable multiple dots (and most characters) in ODS5 file names,
+      while preserving VMS-ness of ";version". */
+ { "DECC$EFS_CHARSET", 1 },
+   /* List terminator. */
+ { (char *)NULL, 0 } };
+
+/* LIB$INITIALIZE initialization function. */
+
+static void vms_init( void)
+{
+int feat_index;
+int feat_value;
+int feat_value_max;
+int feat_value_min;
+int i;
+int sts;
+
+/* Set the global flag to indicate that LIB$INITIALIZE worked. */
+
+vms_init_done = 1;
+
+/* Loop through all items in the decc_feat_array[]. */
+
+for (i = 0; decc_feat_array[ i].name != NULL; i++)
+   {
+   /* Get the feature index. */
+   feat_index = decc$feature_get_index( decc_feat_array[ i].name);
+   if (feat_index >= 0)
+      {
+      /* Valid item.  Collect its properties. */
+      feat_value = decc$feature_get_value( feat_index, 1);
+      feat_value_min = decc$feature_get_value( feat_index, 2);
+      feat_value_max = decc$feature_get_value( feat_index, 3);
+
+      if ((decc_feat_array[ i].value >= feat_value_min) &&
+       (decc_feat_array[ i].value <= feat_value_max))
+         {
+         /* Valid value.  Set it if necessary. */
+         if (feat_value != decc_feat_array[ i].value)
+            {
+            sts = decc$feature_set_value( feat_index,
+             1,
+             decc_feat_array[ i].value);
+            }
+         }
+      else
+         {
+         /* Invalid DECC feature value. */
+         printf( " INVALID DECC FEATURE VALUE, %d: %d <= %s <= %d.\n",
+          feat_value,
+          feat_value_min, decc_feat_array[ i].name, feat_value_max);
+         }
+      }
+   else
+      {
+      /* Invalid DECC feature name. */
+      printf( " UNKNOWN DECC FEATURE: %s.\n", decc_feat_array[ i].name);
+      }
+   }
+}
+
+/* Get "vms_init()" into a valid, loaded LIB$INITIALIZE PSECT. */
+
+#pragma nostandard
+
+/* Establish the LIB$INITIALIZE PSECTs, with proper alignment and
+   other attributes.  Note that "nopic" is significant only on VAX.
+*/
+#pragma extern_model save
+
+#pragma extern_model strict_refdef "LIB$INITIALIZE" 2, nopic, nowrt
+void (*const x_vms_init)() = vms_init;
+
+#pragma extern_model strict_refdef "LIB$INITIALIZ" 2, nopic, nowrt
+const int spare[ 8] = { 0 };
+
+#pragma extern_model restore
+
+/* Fake reference to ensure loading the LIB$INITIALIZE PSECT. */
+
+#pragma extern_model save
+int lib$initialize(void);
+#pragma extern_model strict_refdef
+int dmy_lib$initialize = (int) lib$initialize;
+#pragma extern_model restore
+
+#pragma standard
+
+#endif /* !defined( __VAX) && (__CRTL_VER >= 70301000) */
+
+/*--------------------------------------------------------------------*/
+
+/* vms_arch()
+  
+      Returns (run-time) VMS architecture string.
+*/
+
+char *vms_arch( void)
+{
+#define ARCH_SIZE 15
+
+static int sts = 0;
+static char arch[ ARCH_SIZE+ 1] = "VAX";        /* Only VAX could fail. */
+unsigned short arch_len;
+
+struct dsc$descriptor_s arch_descr =
+ { ARCH_SIZE, DSC$K_DTYPE_T, DSC$K_CLASS_S, arch };
+
+if (sts == 0)
+   {
+   sts = lib$getsyi( &SYI$_ARCH_NAME, 0, &arch_descr, &arch_len, 0, 0);
+   if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+      {
+      arch[ arch_len] = '\0';
+
+      /* Trim trailing spaces. */
+      while ((arch_len > 0) && (arch[ arch_len- 1] == ' '))
+         {
+         arch[ --arch_len] = '\0';
+         }
+      }
+   }
+return arch;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* vms_vers()
+  
+      Returns (run-time) VMS version string.
+*/
+
+char *vms_vers( void)
+{
+#define VERS_SIZE 8
+
+static int sts = 0;
+static char vers[ VERS_SIZE+ 1] = "";
+unsigned short vers_len;
+
+struct dsc$descriptor_s vers_descr =
+ { VERS_SIZE, DSC$K_DTYPE_T, DSC$K_CLASS_S, vers };
+
+if (sts == 0)
+   {
+   sts = lib$getsyi( &SYI$_VERSION, 0, &vers_descr, &vers_len, 0, 0);
+   if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+   {
+      vers[ vers_len] = '\0';
+
+      /* Trim trailing spaces. */
+      while ((vers_len > 0) && (vers[ vers_len- 1] == ' '))
+         {
+         vers[ --vers_len] = '\0';
+         }
+      }
+   }
+return vers;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* set_ods5_dest()
+
+      Sets global "ods5_dest" according to the file system type of the
+      argument: 0 for ODS2, 1 for ODS5.  (No change if other/unknown or
+      failure.)
+
+      Return value:  Status from sys$getdvi().
+*/
+
+int set_ods5_dest( char *path)
+{
+#ifdef DVI$C_ACP_F11V5
+
+/* Should know about ODS5 file system.  Do actual check.
+   (This should be non-VAX with __CRTL_VER >= 70200000.)
+*/
+
+struct dsc$descriptor_s dev_descr =
+ { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0 };
+
+int acp_code;
+int sts;
+
+/* Load path argument into device descriptor.
+   Default to current default device.
+*/
+if (path == NULL)
+   {
+   dev_descr.dsc$a_pointer = "SYS$DISK";
+   }
+else
+   {
+   dev_descr.dsc$a_pointer = path;
+   }
+dev_descr.dsc$w_length = strlen( dev_descr.dsc$a_pointer);
+
+/* Get filesystem type code.
+   (Text results for this item code have been unreliable.)
+*/
+sts = lib$getdvi( &((int) DVI$_ACPTYPE),
+                  0,
+                  &dev_descr,
+                  &acp_code,
+                  0,
+                  0);
+
+if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+   {
+   if (acp_code == DVI$C_ACP_F11V2)
+      {
+      ods5_dest = 0;
+      }
+   else if (acp_code == DVI$C_ACP_F11V5)
+      {
+      ods5_dest = 1;
+      }
+   }
+
+return sts;
+
+#else /* def DVI$C_ACP_F11V5 */
+
+/* Too old for ODS5 file system.  Do nothing. */
+
+return STS$K_SUCCESS;
+
+#endif /* def DVI$C_ACP_F11V5 */
+}
+
+/*--------------------------------------------------------------------*/
+
+/* ods2_conform()
+
+   Replace ODS2-troublesome characters in the argument, overwriting the
+   original string.  Replace "~" with "-", "@" with "$", and invalid
+   dots and other characters with "_".  (Invalid dots are any in a
+   directory name, and all but the last in a file name.)
+
+   Return value: path.  (Someday this function could be written to leave
+   the original string unchanged, and to return a freshly allocated
+   string, possibly of a dfferent length.)
+
+   2005-02-23 SMS.
+   Changed to use char_prop[] look-up table, and to convert more invalid
+   characters to "_".
+*/
+
+static
+char *ods2_conform( char *path)
+{
+char *p;
+char *prd;
+char *prs;
+char *prv;
+unsigned char uchr;
+unsigned char prop;
+
+/* Locate the last slash. */
+prs = rindex( path, '/');
+if (prs == NULL)
+   {
+   prs = path;
+   }
+
+/* Locate the last dot after the last slash. */
+prd = rindex( prs, '.');
+if (prd == NULL)
+   {
+   prd = prs;
+   }
+
+/* Locate the version (after the last slash and dot). */
+for (prv = prs+ strlen( prs) ; (--prv > prs) && isdigit( *prv); );
+if ((*prv != ';') || (*(prv- 1) == '^'))
+   {
+   prv = prs+ strlen( prs);
+   }
+
+for (p = path ; p < prv; p++)
+   {
+   prop = char_prop[ uchr = *p];
+   if ((prop& 4))
+      {                                 /* Dot. */
+      if (p < prd)
+         {                              /* Before last dot in name. */
+         *p = '_';                      /* Convert to "_". */
+         }
+      }
+   else if ((prop& (32+ 16)) == 0)
+      {                                 /* ODS2-invalid. */
+      if (uchr == '~')
+         {
+         *p = '-';                      /* Convert to "-". */
+         }
+      else if (uchr == '@')
+         {
+         *p = '$';                      /* Convert to "$". */
+         }
+      else if (uchr != '/')             /* Leave "/" as-is. */
+         {
+         *p = '_';                      /* Convert to "_". */
+         }
+      }
+   }
+return path;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* ods_conform()
+
+   Replace troublesome characters for the destination file system (ODS2
+   or ODS5) with more legal characters.
+
+   For ODS5, this is simply "?" -> "!" and "*" -> "#".
+
+   For ODS2, see ods2_conform().
+
+   Return value: path.  (Someday this function could be written to leave
+   the original string unchanged, and to return a freshly allocated
+   string, possibly of a dfferent length.)
+*/
+
+char *ods_conform( char *path)
+{
+char *p;
+
+/* Replacements for invalid (printing) ODS5 characters. */
+#define ODS5_QUESTION '!'
+#define ODS5_ASTERISK '#'
+
+if (ods5_dest <= 0)
+   {
+   /* Return ODS2-conformant file name. */
+   return ods2_conform( path);
+   }
+else
+   {
+   /* Return ODS5-conformant file name.  ("?" -> "!", "*" -> "#".) */
+   for (p = path; *p != '\0'; p++)
+      {
+      if (*p == '?')
+         {
+         *p = ODS5_QUESTION;
+         }
+      else if (*p == '*')
+         {
+         *p = ODS5_ASTERISK;
+         }
+      }
+   return path;
+   }
+}
+
+/*--------------------------------------------------------------------*/
+
+/* Wget-private utime() code. */
+
+/* Use long name (NAML) structure only where available.
+   (This should be non-VAX with __CRTL_VER >= 70200000.)
+*/
+
+#ifdef NAML$C_BID
+
+/* Use long name (NAML) structure. */
+
+#define FAB$L_NAMX fab$l_naml
+#define NAMX NAML
+#define NAMX$C_MAXRSS NAML$C_MAXRSS
+#define NAMX$B_DEV naml$l_long_dev_size
+#define NAMX$L_DEV naml$l_long_dev
+#define NAMX$L_ESA naml$l_long_expand
+#define NAMX$B_ESL naml$l_long_expand_size
+#define NAMX$B_ESS naml$l_long_expand_alloc
+#define NAMX$W_FID naml$w_fid
+#define NAMX$L_RSA naml$l_long_result
+#define NAMX$B_RSL naml$l_long_result_size
+#define NAMX$B_RSS naml$l_long_result_alloc
+#define CC$RMS_NAMX cc$rms_naml
+
+#else /* def NAML$C_BID */
+
+/* Use short name (NAM) structure. */
+
+#define FAB$L_NAMX fab$l_nam
+#define NAMX NAM
+#define NAMX$C_MAXRSS NAM$C_MAXRSS
+#define NAMX$B_DEV nam$b_dev
+#define NAMX$L_DEV nam$l_dev
+#define NAMX$L_ESA nam$l_esa
+#define NAMX$B_ESL nam$b_esl
+#define NAMX$B_ESS nam$b_ess
+#define NAMX$W_FID nam$w_fid
+#define NAMX$L_RSA nam$l_rsa
+#define NAMX$B_RSL nam$b_rsl
+#define NAMX$B_RSS nam$b_rss
+#define CC$RMS_NAMX cc$rms_nam
+
+#endif /* def NAML$C_BID */
+
+/*--------------------------------------------------------------------*/
+
+/* Wget-private utime() code. */
+
+/* Action routine for decc$to_vms(), in utime(). */
+
+char vms_path[ NAMX$C_MAXRSS+ 1];
+
+int set_vms_name( char *name, int type)
+{
+   strncpy( vms_path, name, NAMX$C_MAXRSS);
+   vms_path[ NAMX$C_MAXRSS] = '\0';
+   return 1;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* utime() replacement. */
+
+int utime( const char *path, const struct utimbuf *times)
+{
+time_t utc_unsigned;
+
+int chan, i;
+int sts, sts2;
+
+unsigned short int vms_num_vec_time[ 7];
+static unsigned int vms_abs_time[ 2];
+struct tm *tms;
+struct _iosb iosb_q;
+
+/* QIOW item list used to set creation and revision dates. */
+
+struct atrdef ut_atr[ 3] = {
+ {sizeof( vms_abs_time), ATR$C_CREDATE, UWA vms_abs_time},
+ {sizeof( vms_abs_time), ATR$C_REVDATE, UWA vms_abs_time},
+ {0,0,0}};
+
+/* Various RMS structures used for file access. */
+
+struct FAB ut_fab = cc$rms_fab;
+struct RAB ut_rab = cc$rms_rab;
+struct NAMX ut_namx = CC$RMS_NAMX;
+static struct fibdef ut_fib;
+
+/* Device and file name buffers and their descriptors. */
+
+static char dev_namx[ NAMX$C_MAXRSS+ 1];
+char esa_namx[ NAMX$C_MAXRSS+ 1];
+char rsa_namx[ NAMX$C_MAXRSS+ 1];
+
+struct dsc$descriptor dev_dsc =
+ {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, dev_namx};
+
+struct dsc$descriptor fib_dsc =
+ {sizeof( ut_fib), DSC$K_DTYPE_T, DSC$K_CLASS_S, (char *) &ut_fib};
+
+/* "wget" provides a UNIX-like path name.  With "-O", a user may provide
+   a VMS-like path name.  If a slash is found in the name, assume that
+   it's UNIX-like, and convert it to VMS form.  Otherwise, use it as-is.
+*/
+
+if (strchr( path, '/') != NULL)
+   {
+   sts = decc$to_vms( path, set_vms_name, 0, 0);
+   path = vms_path;
+   }
+
+/* Install the VMS file specification into the FAB. */
+
+ut_fab.fab$l_fna = (char *) path;
+ut_fab.fab$b_fns = (unsigned char) strlen( path);
+
+ut_fab.fab$l_dna = "";
+ut_fab.fab$b_dns = 0;
+
+/* Point the FAB to the NAMX. */
+
+ut_fab.FAB$L_NAMX = &ut_namx;
+
+/* Install the name buffers into the NAM. */
+
+ut_namx.NAMX$L_ESA = esa_namx;
+ut_namx.NAMX$B_ESL = 0;
+ut_namx.NAMX$B_ESS = sizeof( esa_namx)- 1;
+
+ut_namx.NAMX$L_RSA = rsa_namx;
+ut_namx.NAMX$B_RSL = 0;
+ut_namx.NAMX$B_RSS = sizeof( rsa_namx)- 1;
+
+/* Convert the modification time (UTC time_t) to local "tm" time. */
+
+tms = localtime( &(times-> modtime));
+
+/* Move (translate) "tm" structure local time to VMS vector time. */
+
+if (tms != NULL)
+   {
+   vms_num_vec_time[ 0] = tms-> tm_year+ 1900;
+   vms_num_vec_time[ 1] = tms-> tm_mon+ 1;
+   vms_num_vec_time[ 2] = tms-> tm_mday;
+   vms_num_vec_time[ 3] = tms-> tm_hour;
+   vms_num_vec_time[ 4] = tms-> tm_min;
+   vms_num_vec_time[ 5] = tms-> tm_sec;
+   vms_num_vec_time[ 6] = 0;  /* centiseconds */
+
+/* Convert VMS vector time to VMS absolute time (quadword). */
+
+   sts = lib$cvt_vectim( vms_num_vec_time, vms_abs_time);
+
+   if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+      {
+/* Parse the file specification. */
+
+      sts = sys$parse( &ut_fab, 0, 0);
+
+      if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+         {
+/* Locate the file. (Gets the FID.) */
+
+         sts = sys$search( &ut_fab, 0, 0);
+
+         if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+            {
+/* Form the device name descriptor. */
+
+            dev_dsc.dsc$w_length = ut_namx.NAMX$B_DEV;
+            dev_dsc.dsc$a_pointer = (char *) ut_namx.NAMX$L_DEV;
+
+/* Assign a channel to the disk device. */
+
+            sts = sys$assign( &dev_dsc, &chan, 0, 0);
+
+            if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+               {
+/* Move the FID (and not the DID) into the FIB. */
+
+               memset( (void *) &ut_fib, 0, sizeof( ut_fib));
+
+               for (i = 0; i < 3; i++)
+                  {
+                  ut_fib.fib$w_fid[ i] = ut_namx.NAMX$W_FID[ i];
+                  ut_fib.fib$w_did[ i] = 0;
+                  }
+
+/* Prevent this QIOW from setting the revision time to now. */
+
+               ut_fib.fib$l_acctl = FIB$M_NORECORD;
+
+/* Set the file dates. */
+
+               sts = sys$qiow( 0,
+                               chan,
+                               IO$_MODIFY,
+                               &iosb_q,
+                               0,
+                               0,
+                               &fib_dsc,
+                               0,
+                               0,
+                               0,
+                               ut_atr,
+                               0);
+
+               if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+                  {
+                   sts = iosb_q.iosb$w_status;
+                  }
+               sts2 = sys$dassgn( chan);
+
+               if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+                  {
+                  sts = sts2;
+                  }
+               }
+            }
+         }
+      }
+   }
+
+/* Convert successful VMS status to zero = success status.
+   If failure, set errno and vaxc$errno, and return -1 = failure status.
+*/
+
+if ((sts& STS$M_SEVERITY) == STS$K_SUCCESS)
+   {
+   sts = 0;
+   }
+else
+   {
+   errno = EVMSERR;
+   vaxc$errno = sts;
+   sts = -1;
+   }
+
+return sts;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* 2005-04-14 SMS.
+ *
+ *       vms_init_diag().
+ *
+ *    Get Wget debug option value.
+ */
+
+int vms_init_diag( void)
+{
+#ifdef ENABLE_DEBUG
+return (opt.debug > 0);
+#else /* def ENABLE_DEBUG */
+return 0;
+#endif /* def ENABLE_DEBUG */
+}
+
+/*--------------------------------------------------------------------*/
+
+/* 2004-11-23 SMS.
+ *
+ *       get_rms_defaults().
+ *
+ *    Get user-specified values from (DCL) SET RMS_DEFAULT.  FAB/RAB
+ *    items of particular interest are:
+ *
+ *       fab$w_deq         default extension quantity (blocks) (write).
+ *       rab$b_mbc         multi-block count.
+ *       rab$b_mbf         multi-buffer count (used with rah and wbh).
+ */
+
+/* Default RMS parameter values. */
+
+#define RMS_DEQ_DEFAULT 16384   /* About 1/4 the max (65535 blocks). */
+#define RMS_MBC_DEFAULT 127     /* The max, */
+#define RMS_MBF_DEFAULT 2       /* Enough to enable rah and wbh. */
+
+/* GETJPI item descriptor structure. */
+typedef struct
+    {
+    short buf_len;
+    short itm_cod;
+    void *buf;
+    int *ret_len;
+    } jpi_item_t;
+
+/* Durable storage */
+
+static int rms_defaults_known = 0;
+
+/* JPI item buffers. */
+static unsigned short rms_ext;
+static char rms_mbc;
+static unsigned char rms_mbf;
+
+/* Active RMS item values. */
+unsigned short rms_ext_active;
+char rms_mbc_active;
+unsigned char rms_mbf_active;
+
+/* GETJPI item lengths. */
+static int rms_ext_len;         /* Should come back 2. */
+static int rms_mbc_len;         /* Should come back 1. */
+static int rms_mbf_len;         /* Should come back 1. */
+
+/* Desperation attempts to define unknown macros.  Probably doomed.
+ * If these get used, expect sys$getjpiw() to return %x00000014 =
+ * %SYSTEM-F-BADPARAM, bad parameter value.
+ * They keep compilers with old header files quiet, though.
+ */
+#ifndef JPI$_RMS_EXTEND_SIZE
+#  define JPI$_RMS_EXTEND_SIZE 542
+#endif /* ndef JPI$_RMS_EXTEND_SIZE */
+
+#ifndef JPI$_RMS_DFMBC
+#  define JPI$_RMS_DFMBC 535
+#endif /* ndef JPI$_RMS_DFMBC */
+
+#ifndef JPI$_RMS_DFMBFSDK
+#  define JPI$_RMS_DFMBFSDK 536
+#endif /* ndef JPI$_RMS_DFMBFSDK */
+
+/* GETJPI item descriptor set. */
+
+struct
+    {
+    jpi_item_t rms_ext_itm;
+    jpi_item_t rms_mbc_itm;
+    jpi_item_t rms_mbf_itm;
+    int term;
+    } jpi_itm_lst =
+     { { 2, JPI$_RMS_EXTEND_SIZE, &rms_ext, &rms_ext_len },
+       { 1, JPI$_RMS_DFMBC, &rms_mbc, &rms_mbc_len },
+       { 1, JPI$_RMS_DFMBFSDK, &rms_mbf, &rms_mbf_len },
+       0
+     };
+
+int get_rms_defaults()
+{
+int sts;
+
+/* Get process RMS_DEFAULT values. */
+
+sts = sys$getjpiw( 0, 0, 0, &jpi_itm_lst, 0, 0, 0);
+if ((sts& STS$M_SEVERITY) != STS$M_SUCCESS)
+    {
+    /* Failed.  Don't try again. */
+    rms_defaults_known = -1;
+    }
+else
+    {
+    /* Fine, but don't come back. */
+    rms_defaults_known = 1;
+    }
+
+/* Limit the active values according to the RMS_DEFAULT values. */
+
+if (rms_defaults_known > 0)
+    {
+    /* Set the default values. */
+
+    rms_ext_active = RMS_DEQ_DEFAULT;
+    rms_mbc_active = RMS_MBC_DEFAULT;
+    rms_mbf_active = RMS_MBF_DEFAULT;
+
+    /* Default extend quantity.  Use the user value, if set. */
+    if (rms_ext > 0)
+        {
+        rms_ext_active = rms_ext;
+        }
+
+    /* Default multi-block count.  Use the user value, if set. */
+    if (rms_mbc > 0)
+        {
+        rms_mbc_active = rms_mbc;
+        }
+
+    /* Default multi-buffer count.  Use the user value, if set. */
+    if (rms_mbf > 0)
+        {
+        rms_mbf_active = rms_mbf;
+        }
+    }
+
+if (vms_init_diag() > 0)
+    {
+    fprintf( stderr,
+     "Get RMS defaults.  getjpi sts = %%x%08x.\n",
+     sts);
+
+    if (rms_defaults_known > 0)
+        {
+        fprintf( stderr,
+         "               Default: deq = %6d, mbc = %3d, mbf = %3d.\n",
+         rms_ext, rms_mbc, rms_mbf);
+        }
+    }
+return sts;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* 2004-11-23 SMS.
+ *
+ *       acc_cb(), access callback function for DEC C [f]open().
+ *
+ *    Set some RMS FAB/RAB items, with consideration of user-specified
+ * values from (DCL) SET RMS_DEFAULT.  Items of particular interest are:
+ *
+ *       fab$w_deq         default extension quantity (blocks).
+ *       rab$b_mbc         multi-block count.
+ *       rab$b_mbf         multi-buffer count (used with rah and wbh).
+ *
+ *    See also the FOP* macros in OSDEP.H.  Currently, no notice is
+ * taken of the caller-ID value, but options could be set differently
+ * for read versus write access.  (I assume that specifying fab$w_deq,
+ * for example, for a read-only file has no ill effects.)
+ */
+
+/* acc_cb() */
+
+int acc_cb( int *id_arg, struct FAB *fab, struct RAB *rab)
+{
+int sts;
+
+/* Get process RMS_DEFAULT values, if not already done. */
+if (rms_defaults_known == 0)
+    {
+    get_rms_defaults();
+    }
+
+/* If RMS_DEFAULT (and adjusted active) values are available, then set
+ * the FAB/RAB parameters.  If RMS_DEFAULT values are not available,
+ * suffer with the default parameters.
+ */
+if (rms_defaults_known > 0)
+    {
+    /* Set the FAB/RAB parameters accordingly. */
+    fab-> fab$w_deq = rms_ext_active;
+    rab-> rab$b_mbc = rms_mbc_active;
+    rab-> rab$b_mbf = rms_mbf_active;
+
+    /* Truncate at EOF on close, as we'll probably over-extend. */
+    fab-> fab$v_tef = 1;
+
+    /* If using multiple buffers, enable read-ahead and write-behind. */
+    if (rms_mbf_active > 1)
+        {
+        rab-> rab$v_rah = 1;
+        rab-> rab$v_wbh = 1;
+        }
+
+    if (vms_init_diag() > 0)
+        {
+        fprintf( stderr,
+         "Open callback.  ID = %d, deq = %6d, mbc = %3d, mbf = %3d.\n",
+         *id_arg, fab-> fab$w_deq, rab-> rab$b_mbc, rab-> rab$b_mbf);
+        }
+    }
+
+/* Declare success. */
+return 0;
+}
+
+/*--------------------------------------------------------------------*/
+
+/* Added J.Lauret 05-Dec-1999 . Copied from Mosaic distribution */
+
+/*
+ * Here is a replacement for getpwuid for VMS.  It returns pointers
+ * to userid (*pw_name) and owner (*pw_gecos) only.  Other fields
+ * may be added later.
+ * Note that sys$getuai returns owner as a counted string.
+ */
+
+#if __CRTL_VER < 70000000
+
+#include <uaidef.h>
+
+static struct passwd vms_passwd;
+static char vms_userid[16];
+static char vms_owner[40];
+
+struct passwd *getpwuid()
+{
+struct  dsc$descriptor_s
+{
+  unsigned short  dsc$w_length;
+  unsigned char   dsc$b_dtype;
+  unsigned char   dsc$b_class;
+  char            *dsc$a_pointer;
+} user_desc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL};
+
+  char *t_userid, owner[40];
+  int status, length;
+  struct {
+    short buffer_length;
+    short item_code;
+    int buffer_address;
+    int return_length_address;
+    int terminator;
+  } itmlst;
+
+#ifdef __GNUC__
+  (int)t_userid = cuserid((char *) NULL);
+#else
+  t_userid = cuserid((char *) NULL);
+#endif /* GNU C is strange, GEC */
+  user_desc.dsc$w_length       = strlen(t_userid);
+  user_desc.dsc$a_pointer      = t_userid;
+  itmlst.buffer_length         = sizeof(owner);
+  itmlst.item_code             = UAI$_OWNER;
+  itmlst.buffer_address        = (int)owner;
+  itmlst.return_length_address = (int)&length;
+  itmlst.terminator            = 0;
+  status = sys$getuai(0, 0, &user_desc, &itmlst, 0, 0, 0);
+  if ((stats& STS$M_SEVERITY) == STS$K_SUCCESS) {
+    length = (int)owner[0];
+    owner[length+1] = '\0';
+    strcpy(vms_userid, t_userid);
+    strcpy(vms_owner, &owner[1]);
+  } else {
+    vms_userid[0] = '\0';
+    vms_owner[0] = '\0';
+  }
+  vms_passwd.pw_name = vms_userid;
+  vms_passwd.pw_gecos = vms_owner;
+  return (&vms_passwd);
+}
+
+/* Approximate localtime_r as best we can in its absence.  */
+struct tm *
+localtime_r (t, tp)
+     const time_t *t;
+     struct tm *tp;
+{
+  struct tm *l = localtime (t);
+  if (! l)
+    return 0;
+  *tp = *l;
+  return tp;
+}
+
+#endif	/* __CRTL_VER < 70000000 */
+
diff --git a/vms/vms.h b/vms/vms.h
new file mode 100644
index 0000000..05f995b
--- /dev/null
+++ b/vms/vms.h
@@ -0,0 +1,107 @@
+/*
+ *    Various VMS-specific items.
+ *
+ *    Includes:
+ *
+ *  Emergency replacement for <utime.h> for VMS CRTL before V7.3.
+ *
+ *  Emergency replacement for <pwd.h> for VMS CRTL before V7.0.
+ *
+ *  Emergency substitution of stat() for lstat() for VAX and VMS CRTL
+ *  before V7.3-1.
+ *
+ *  Prototypes for VMS-specific functions:
+ *     acc_cb()
+ *     utime() (CRTL < V7.3)
+ *     ods_conform()
+ *     set_ods5_dest()
+ *     vms_arch()
+ *     vms_vers()
+ *
+ *  Global storage:
+ *     ods5_dest
+ */
+
+#ifndef __VMS_H_INCLUDED
+#define __VMS_H_INCLUDED
+
+/* Emergency replacement for <utime.h> for VMS before V7.3. */
+
+#if __CRTL_VER < 70300000
+
+#include <types.h>
+
+/* The "utimbuf" structure is used by "utime()". */
+struct utimbuf {
+        time_t actime;          /* access time */
+        time_t modtime;         /* modification time */
+};
+
+/* Function prototypes for utime(), */
+
+int utime( const char *path, const struct utimbuf *times);
+
+#else /* __CRTL_VER < 70300000 */
+
+#include <utime.h>
+
+#endif /* __CRTL_VER < 70300000 */
+
+
+/* Emergency substitution of stat() for lstat() for VAX and VMS CRTL
+   before V7.3-1.
+*/
+#if defined(__VAX) || __CRTL_VER < 70301000
+
+#define lstat( __p1, __p2) stat( __p1, __p2)
+
+#endif /* defined(__VAX) || __CRTL_VER < 70301000 */
+
+
+/* Global storage. */
+
+/*    VMS destination file system type.  < 0: unset/unknown
+                                         = 0: ODS2
+                                         > 0: ODS5
+*/
+
+extern int ods5_dest;
+
+
+/* Function prototypes. */
+
+extern int acc_cb();
+
+char *ods_conform( char *path);
+
+int set_ods5_dest( char *path);
+
+char *vms_arch( void);
+
+char *vms_vers( void);
+
+/* Emergency replacement for <pwd.h> (for VMS CRTL before V7.0). */
+
+/* Declare "passwd" structure, if needed. */
+
+#ifndef HAVE_PWD_H
+
+struct passwd {
+        char    *pw_name;
+        char    *pw_passwd;
+        int     pw_uid;
+        int     pw_gid;
+        short   pw_salt;
+        int     pw_encrypt;
+        char    *pw_age;
+        char    *pw_comment;
+        char    *pw_gecos;
+        char    *pw_dir;
+        char    *pw_shell;
+};
+
+struct passwd *getpwuid();
+
+#endif /* HAVE_PWD_H */
+
+#endif /* __VMS_H_INCLUDED */
diff --git a/vms/vms_ip.h b/vms/vms_ip.h
new file mode 100644
index 0000000..9efc52d
--- /dev/null
+++ b/vms/vms_ip.h
@@ -0,0 +1,19 @@
+/*    VMS-specific "#include" directives for IP. */
+
+#ifdef MULTINET
+
+#include "multinet_root:[multinet.include.sys]types.h"
+#include "multinet_root:[multinet.include]errno.h"
+#include "multinet_root:[multinet.include]netdb.h"
+
+#else /* MULTINET */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <netdb.h>
+
+#if __CRTL_VER < 70000000
+#define h_errno errno  /* Quiets the compiler, but probably ineffective. */
+#endif /* __CRTL_VER < 70000000 */
+
+#endif /* MULTINET */
diff --git a/vms/vms_name_fix.sh b/vms/vms_name_fix.sh
new file mode 100644
index 0000000..5cb2289
--- /dev/null
+++ b/vms/vms_name_fix.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+#                                               13 October 2005.  SMS.
+#
+# Wget 1.10.2
+#
+#    Restore original file names after storage on an ODS2 file system.
+#
+mv authors AUTHORS
+mv changelog ChangeLog
+mv changelog.readme ChangeLog.README
+mv configure.bat_in configure.bat.in
+mv copying COPYING
+mv doc/changelog doc/ChangeLog
+mv doc/makefile.in doc/Makefile.in
+mv doc/sample.wgetrc_munged_for_texi_inclusion \
+   doc/sample.wgetrc.munged_for_texi_inclusion
+mv doc/texi2pod.pl_in doc/texi2pod.pl.in
+mv install INSTALL
+mv mailing-list MAILING-LIST
+mv makefile.in Makefile.in
+mv news NEWS
+mv patches PATCHES
+mv po/makefile.in_in po/Makefile.in.in
+mv po/potfiles.in po/POTFILES.in
+mv po/en_gb.po po/en_GB.po
+mv po/pt_br.po po/pt_BR.po
+mv po/zh_cn.po po/zh_CN.po
+mv po/zh_tw.po po/zh_TW.po
+mv readme README
+mv readme.checkout README.checkout
+mv src/changelog src/ChangeLog
+mv src/config.h_in src/config.h.in
+mv src/makefile.in src/Makefile.in
+mv todo TODO
+mv util/makefile.in util/Makefile.in
+mv util/readme util/README
+mv windows/changelog windows/ChangeLog
+mv windows/config.h_bor windows/config.h.bor
+mv windows/config.h_mingw windows/config.h.mingw
+mv windows/config.h_ms windows/config.h.ms
+mv windows/makefile.doc windows/Makefile.doc
+mv windows/makefile.in windows/Makefile.in
+mv windows/makefile.src windows/Makefile.src
+mv windows/makefile.src_bor windows/Makefile.src.bor
+mv windows/makefile.src_mingw windows/Makefile.src.mingw
+mv windows/makefile.top windows/Makefile.top
+mv windows/makefile.top_bor windows/Makefile.top.bor
+mv windows/makefile.top_mingw windows/Makefile.top.mingw
+mv windows/makefile.watcom windows/Makefile.watcom
+mv windows/readme windows/README
+#
-- 
cgit v1.0-41-gc330

