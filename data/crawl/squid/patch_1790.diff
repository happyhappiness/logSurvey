@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.89 1997/10/29 17:47:40 wessels Exp $
+#  $Id: Makefile.in,v 1.90 1997/11/03 22:43:06 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -126,6 +126,8 @@ OBJS	 	= \
 		store.o \
 		store_clean.o \
 		store_dir.o \
+		store_key_sha.o \
+		store_key_url.o \
 		tools.o \
 		unlinkd.o \
 		url.o \
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cbdata.cc,v 1.7 1997/10/28 18:10:46 wessels Exp $
+ * $Id: cbdata.cc,v 1.8 1997/11/03 22:43:07 wessels Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * AUTHOR: Duane Wessels
@@ -75,13 +75,13 @@ static HASHCMP cbdata_cmp;
 static HASHHASH cbdata_hash;
 
 static int
-cbdata_cmp(const char *p1, const char *p2)
+cbdata_cmp(const void *p1, const void *p2)
 {
-    return p1 - p2;
+    return (char *) p1 - (char *) p2;
 }
 
 static unsigned int
-cbdata_hash(const char *p, unsigned int mod)
+cbdata_hash(const void *p, unsigned int mod)
 {
     return ((unsigned long) p >> 8) % mod;
 }
@@ -1,8 +1,6 @@
 
-
-
 /*
- * $Id: client.cc,v 1.39 1997/10/30 03:31:19 wessels Exp $
+ * $Id: client.cc,v 1.40 1997/11/03 22:43:08 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.138 1997/10/30 22:41:21 wessels Exp $
+ * $Id: client_side.cc,v 1.139 1997/11/03 22:43:08 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -217,14 +217,15 @@ icpHandleIMSReply(void *data, char *buf, ssize_t size)
     int fd = http->conn->fd;
     StoreEntry *entry = http->entry;
     MemObject *mem = entry->mem_obj;
+    const char *url = storeUrl(entry);
     int unlink_request = 0;
     StoreEntry *oldentry;
-    debug(33, 3) ("icpHandleIMSReply: FD %d '%s'\n", fd, entry->url);
+    debug(33, 3) ("icpHandleIMSReply: FD %d '%s'\n", fd, url);
     put_free_4k_page(buf);
     buf = NULL;
     /* unregister this handler */
     if (size < 0 || entry->store_status == STORE_ABORTED) {
-	debug(33, 3) ("icpHandleIMSReply: ABORTED '%s'\n", entry->url);
+	debug(33, 3) ("icpHandleIMSReply: ABORTED '%s'\n", url);
 	/* We have an existing entry, but failed to validate it */
 	/* Its okay to send the old one anyway */
 	http->log_type = LOG_TCP_REFRESH_FAIL_HIT;
@@ -233,8 +234,7 @@ icpHandleIMSReply(void *data, char *buf, ssize_t size)
 	entry = http->entry = http->old_entry;
 	entry->refcount++;
     } else if (mem->reply->code == 0) {
-	debug(33, 3) ("icpHandleIMSReply: Incomplete headers for '%s'\n",
-	    entry->url);
+	debug(33, 3) ("icpHandleIMSReply: Incomplete headers for '%s'\n", url);
 	storeClientCopy(entry,
 	    http->out.offset + size,
 	    http->out.offset,
@@ -292,7 +292,7 @@ modifiedSince(StoreEntry * entry, request_t * request)
 {
     int object_length;
     MemObject *mem = entry->mem_obj;
-    debug(33, 3) ("modifiedSince: '%s'\n", entry->url);
+    debug(33, 3) ("modifiedSince: '%s'\n", storeUrl(entry));
     if (entry->lastmod < 0)
 	return 1;
     /* Find size of the object */
@@ -354,6 +354,7 @@ clientPurgeRequest(clientHttpRequest * http)
     char *msg;
     StoreEntry *entry;
     ErrorState *err = NULL;
+    const cache_key *k;
     debug(33, 3) ("Config.onoff.enable_purge = %d\n", Config.onoff.enable_purge);
     if (!Config.onoff.enable_purge) {
 	err = errorCon(ERR_ACCESS_DENIED, HTTP_FORBIDDEN);
@@ -363,7 +364,8 @@ clientPurgeRequest(clientHttpRequest * http)
 	return;
     }
     http->log_type = LOG_TCP_MISS;
-    if ((entry = storeGet(http->url)) == NULL) {
+    k = storeKeyPublic(http->url, METHOD_GET);
+    if ((entry = storeGet(k)) == NULL) {
 	http->http_code = HTTP_NOT_FOUND;
     } else {
 	storeRelease(entry);
@@ -168,20 +168,15 @@
 #define EBIT_CLR(flag, bit) 	((flag) &= ~((1<<bit)))
 #define EBIT_TEST(flag, bit) 	((flag) & ((1<<bit)))
 
-/* 
- * KEY_URL              If e->key and e->url point to the same location
- * KEY_CHANGE           If the key for this URL has been changed
- */
-
 #define ENTRY_VALIDATED		(1<<16)
 #define ENTRY_UNUSED15		(1<<15)
 #define ENTRY_NEGCACHED		(1<<14)
 #define HIERARCHICAL 		(1<<13)		/* can we query neighbors? */
 #define KEY_PRIVATE 		(1<<12)		/* is the key currently private? */
 #define ENTRY_DISPATCHED 	(1<<11)
 #define ENTRY_UNUSED10 		(1<<10)
-#define KEY_CHANGE 		(1<<9)
-#define KEY_URL    		(1<<8)
+#define ENTRY_UNUSED09 		(1<<9)
+#define ENTRY_UNUSED08		(1<<8)
 #define ENTRY_CACHABLE   	(1<<7)
 #define REFRESH_REQUEST   	(1<<6)
 #define RELEASE_REQUEST 	(1<<5)
@@ -1,5 +1,5 @@
 /*
- * $Id: ftp.cc,v 1.163 1997/11/03 16:19:23 wessels Exp $
+ * $Id: ftp.cc,v 1.164 1997/11/03 22:43:10 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -183,7 +183,7 @@ ftpStateFree(int fd, void *data)
     FtpStateData *ftpState = data;
     if (ftpState == NULL)
 	return;
-    debug(9, 3) ("ftpStateFree: %s\n", ftpState->entry->url);
+    debug(9, 3) ("ftpStateFree: %s\n", storeUrl(ftpState->entry));
     storeUnregisterAbort(ftpState->entry);
     storeUnlockObject(ftpState->entry);
     if (ftpState->reply_hdr) {
@@ -234,7 +234,7 @@ ftpTimeout(int fd, void *data)
     FtpStateData *ftpState = data;
     StoreEntry *entry = ftpState->entry;
     ErrorState *err;
-    debug(9, 4) ("ftpTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(9, 4) ("ftpTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
     if (entry->store_status == STORE_PENDING) {
 	if (entry->mem_obj->inmem_hi == 0) {
 	    err = errorCon(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT);
@@ -599,7 +599,7 @@ ftpParseListing(FtpStateData * ftpState, int len)
 	end--;
     usable = end - buf;
     if (usable == 0) {
-	debug(9, 3) ("ftpParseListing: didn't find end for %s\n", e->url);
+	debug(9, 3) ("ftpParseListing: didn't find end for %s\n", storeUrl(e));
 	return;
     }
     line = get_free_4k_page();
@@ -877,13 +877,13 @@ void
 ftpStart(request_t * request, StoreEntry * entry)
 {
     LOCAL_ARRAY(char, realm, 8192);
-    char *url = entry->url;
+    const char *url = storeUrl(entry);
     FtpStateData *ftpState = xcalloc(1, sizeof(FtpStateData));
     char *response;
     int fd;
     ErrorState *err;
     cbdataAdd(ftpState);
-    debug(9, 3) ("FtpStart: '%s'\n", entry->url);
+    debug(9, 3) ("FtpStart: '%s'\n", url);
     storeLockObject(entry);
     ftpState->entry = entry;
     ftpState->request = requestLink(request);
@@ -1341,7 +1341,7 @@ ftpSendPasv(FtpStateData * ftpState)
 	Config.Addrs.tcp_outgoing,
 	0,
 	COMM_NONBLOCKING,
-	ftpState->entry->url);
+	storeUrl(ftpState->entry));
     if (fd < 0) {
 	ftpFail(ftpState);
 	return;
@@ -1528,7 +1528,7 @@ ftpReadTransferDone(FtpStateData * ftpState)
     debug(9, 3) ("This is ftpReadTransferDone\n");
     if (code != 226) {
 	debug(9, 1) ("ftpReadTransferDone: Got code %d after reading data\n");
-	debug(9, 1) ("--> releasing '%s'\n", ftpState->entry->url);
+	debug(9, 1) ("--> releasing '%s'\n", storeUrl(ftpState->entry));
 	storeReleaseRequest(ftpState->entry);
     }
     ftpDataTransferDone(ftpState);
@@ -1622,7 +1622,7 @@ static void
 ftpAbort(void *data)
 {
     FtpStateData *ftpState = data;
-    debug(9, 2) ("ftpAbort: %s\n", ftpState->entry->url);
+    debug(9, 2) ("ftpAbort: %s\n", storeUrl(ftpState->entry));
     if (ftpState->data.fd >= 0) {
 	comm_close(ftpState->data.fd);
 	ftpState->data.fd = -1;
@@ -1,5 +1,6 @@
+
 /*
- * $Id: globals.h,v 1.14 1997/10/31 04:09:07 wessels Exp $
+ * $Id: globals.h,v 1.15 1997/11/03 22:43:10 wessels Exp $
  */
 
 extern FILE *debug_log;		/* NULL */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: gopher.cc,v 1.109 1997/10/30 02:41:01 wessels Exp $
+ * $Id: gopher.cc,v 1.110 1997/11/03 22:43:11 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -372,7 +372,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 	    "<BODY><H1>%s<BR>Gopher Search</H1>\n"
 	    "<p>This is a searchable Gopher index. Use the search\n"
 	    "function of your browser to enter search terms.\n"
-	    "<ISINDEX></BODY></HTML>\n", entry->url, entry->url);
+	    "<ISINDEX></BODY></HTML>\n", storeUrl(entry), storeUrl(entry));
 	storeAppend(entry, outbuf, strlen(outbuf));
 	/* now let start sending stuff to client */
 	BIT_CLR(entry->flag, DELAY_SENDING);
@@ -387,7 +387,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 	    "<P>A CSO database usually contains a phonebook or\n"
 	    "directory.  Use the search function of your browser to enter\n"
 	    "search terms.</P><ISINDEX></BODY></HTML>\n",
-	    entry->url, entry->url);
+	    storeUrl(entry), storeUrl(entry));
 
 	storeAppend(entry, outbuf, strlen(outbuf));
 	/* now let start sending stuff to client */
@@ -420,7 +420,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 		/* copy it to temp buffer */
 		if (gopherState->len + len > TEMP_BUF_SIZE) {
 		    debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
-			entry->url);
+			storeUrl(entry));
 		    len = TEMP_BUF_SIZE - gopherState->len;
 		}
 		xmemcpy(gopherState->buf + gopherState->len, inbuf, len);
@@ -446,7 +446,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 		/* copy it to temp buffer */
 		if ((len - (pos - inbuf)) > TEMP_BUF_SIZE) {
 		    debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
-			entry->url);
+			storeUrl(entry));
 		    len = TEMP_BUF_SIZE;
 		}
 		if (len > (pos - inbuf)) {
@@ -650,7 +650,7 @@ gopherTimeout(int fd, void *data)
     GopherStateData *gopherState = data;
     StoreEntry *entry = gopherState->entry;
     ErrorState *err;
-    debug(10, 4) ("gopherTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(10, 4) ("gopherTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
     if (entry->mem_obj->inmem_hi == 0) {
 	err = errorCon(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT);
 	err->url = xstrdup(gopherState->request);
@@ -707,7 +707,7 @@ gopherReadReply(int fd, void *data)
 	    ErrorState *err;
 	    err = errorCon(ERR_READ_ERROR, HTTP_INTERNAL_SERVER_ERROR);
 	    err->xerrno = errno;
-	    err->url = xstrdup(entry->url);
+	    err->url = xstrdup(storeUrl(entry));
 	    errorAppendEntry(entry, err);
 	    storeAbort(entry, 0);
 	    comm_close(fd);
@@ -759,7 +759,7 @@ gopherSendComplete(int fd, char *buf, int size, int errflag, void *data)
 	err->xerrno = errno;
 	err->host = xstrdup(gopherState->host);
 	err->port = gopherState->port;
-	err->url = xstrdup(entry->url);
+	err->url = xstrdup(storeUrl(entry));
 	errorAppendEntry(entry, err);
 
 	storeAbort(entry, 0);
@@ -840,13 +840,13 @@ gopherStart(StoreEntry * entry)
     int fd;
     storeLockObject(entry);
     gopherState->entry = entry;
-    debug(10, 3) ("gopherStart: %s\n", entry->url);
+    debug(10, 3) ("gopherStart: %s\n", storeUrl(entry));
     /* Parse url. */
-    if (gopher_url_parser(entry->url, gopherState->host, &gopherState->port,
+    if (gopher_url_parser(storeUrl(entry), gopherState->host, &gopherState->port,
 	    &gopherState->type_id, gopherState->request)) {
 	ErrorState *err;
 	err = errorCon(ERR_INVALID_URL, HTTP_BAD_REQUEST);
-	err->url = xstrdup(entry->url);
+	err->url = xstrdup(storeUrl(entry));
 	errorAppendEntry(entry, err);
 	storeAbort(entry, 0);
 	gopherStateFree(-1, gopherState);
@@ -858,12 +858,12 @@ gopherStart(StoreEntry * entry)
 	Config.Addrs.tcp_outgoing,
 	0,
 	COMM_NONBLOCKING,
-	entry->url);
+	storeUrl(entry));
     if (fd == COMM_ERROR) {
 	debug(10, 4) ("gopherStart: Failed because we're out of sockets.\n");
 	err = errorCon(ERR_SOCKET_FAILURE, HTTP_INTERNAL_SERVER_ERROR);
 	err->xerrno = errno;
-	err->url = xstrdup(entry->url);
+	err->url = xstrdup(storeUrl(entry));
 	errorAppendEntry(entry, err);
 	storeAbort(entry, 0);
 	gopherStateFree(-1, gopherState);
@@ -910,7 +910,7 @@ gopherConnectDone(int fd, int status, void *data)
 	debug(10, 4) ("gopherConnectDone: Unknown host: %s\n", gopherState->host);
 	err = errorCon(ERR_DNS_FAIL, HTTP_SERVICE_UNAVAILABLE);
 	err->dnsserver_msg = xstrdup(dns_error_message);
-	err->url = xstrdup(entry->url);
+	err->url = xstrdup(storeUrl(entry));
 	errorAppendEntry(entry, err);
 	storeAbort(gopherState->entry, 0);
 	comm_close(fd);
@@ -920,7 +920,7 @@ gopherConnectDone(int fd, int status, void *data)
 	err->xerrno = errno;
 	err->host = xstrdup(gopherState->host);
 	err->port = gopherState->port;
-	err->url = xstrdup(entry->url);
+	err->url = xstrdup(storeUrl(entry));
 	errorAppendEntry(entry, err);
 	storeAbort(gopherState->entry, 0);
 	comm_close(fd);
@@ -943,6 +943,6 @@ static void
 gopherAbort(void *data)
 {
     GopherStateData *gopherState = data;
-    debug(10, 1) ("gopherAbort: %s\n", gopherState->entry->url);
+    debug(10, 1) ("gopherAbort: %s\n", storeUrl(gopherState->entry));
     comm_close(gopherState->fd);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.214 1997/10/31 23:37:24 wessels Exp $
+ * $Id: http.cc,v 1.215 1997/11/03 22:43:12 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -250,7 +250,7 @@ httpTimeout(int fd, void *data)
     HttpStateData *httpState = data;
     StoreEntry *entry = httpState->entry;
     ErrorState *err;
-    debug(11, 4) ("httpTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(11, 4) ("httpTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
     assert(entry->store_status == STORE_PENDING);
     if (entry->mem_obj->inmem_hi == 0) {
 	err = errorCon(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT);
@@ -831,7 +831,7 @@ httpBuildRequestHeader(request_t * request,
 	httpAppendRequestHeader(hdr_out, ybuf, &len, out_sz, 1);
     }
     if (!EBIT_TEST(cc_flags, CCC_MAXAGE)) {
-	url = entry ? entry->url : urlCanonical(orig_request, NULL);
+	url = entry ? storeUrl(entry) : urlCanonical(orig_request, NULL);
 	snprintf(ybuf, YBUF_SZ, "Cache-control: Max-age=%d", (int) getMaxAge(url));
 	httpAppendRequestHeader(hdr_out, ybuf, &len, out_sz, 1);
 	if (request->urlpath) {
@@ -943,7 +943,7 @@ httpSocketOpen(StoreEntry * entry, request_t * request)
 	Config.Addrs.tcp_outgoing,
 	0,
 	COMM_NONBLOCKING,
-	entry->url);
+	storeUrl(entry));
     if (fd < 0) {
 	debug(11, 4) ("httpSocketOpen: Failed because we're out of sockets.\n");
 	err = errorCon(ERR_SOCKET_FAILURE, HTTP_INTERNAL_SERVER_ERROR);
@@ -970,7 +970,7 @@ httpBuildState(int fd, StoreEntry * entry, request_t * orig_request, peer * e)
 	request->method = orig_request->method;
 	xstrncpy(request->host, e->host, SQUIDHOSTNAMELEN);
 	request->port = e->http_port;
-	xstrncpy(request->urlpath, entry->url, MAX_URL);
+	xstrncpy(request->urlpath, storeUrl(entry), MAX_URL);
 	httpState->request = requestLink(request);
 	httpState->peer = e;
 	httpState->orig_request = requestLink(orig_request);
@@ -990,7 +990,7 @@ httpStart(request_t * request, StoreEntry * entry, peer * e)
     HttpStateData *httpState;
     int fd;
     debug(11, 3) ("httpStart: \"%s %s\"\n",
-	RequestMethodStr[request->method], entry->url);
+	RequestMethodStr[request->method], storeUrl(entry));
     if (e) {
 	if (e->options & NEIGHBOR_PROXY_ONLY)
 	    storeReleaseRequest(entry);
@@ -1034,7 +1034,7 @@ static void
 httpRestart(HttpStateData * httpState)
 {
     /* restart a botched request from a persistent connection */
-    debug(11, 2) ("Retrying HTTP request for %s\n", httpState->entry->url);
+    debug(11, 2) ("Retrying HTTP request for %s\n", storeUrl(httpState->entry));
     if (httpState->fd >= 0) {
 	comm_remove_close_handler(httpState->fd, httpStateFree, httpState);
 	comm_close(httpState->fd);
@@ -1082,7 +1082,7 @@ httpConnectDone(int fd, int status, void *data)
 	    peerCheckConnectStart(httpState->peer);
 	comm_close(fd);
     } else {
-	fd_note(fd, entry->url);
+	fd_note(fd, storeUrl(entry));
 	fd_table[fd].uses++;
 	commSetSelect(fd, COMM_SELECT_WRITE, httpSendRequest, httpState, 0);
     }
@@ -1112,7 +1112,7 @@ static void
 httpAbort(void *data)
 {
     HttpStateData *httpState = data;
-    debug(11, 2) ("httpAbort: %s\n", httpState->entry->url);
+    debug(11, 2) ("httpAbort: %s\n", storeUrl(httpState->entry));
     comm_close(httpState->fd);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icmp.cc,v 1.46 1997/10/26 02:35:33 wessels Exp $
+ * $Id: icmp.cc,v 1.47 1997/11/03 22:43:13 wessels Exp $
  *
  * DEBUG: section 37    ICMP Routines
  * AUTHOR: Duane Wessels
@@ -169,9 +169,9 @@ icmpHandleSourcePing(const struct sockaddr_in *from, const char *buf)
     xmemcpy(&header, buf, sizeof(icp_common_t));
     url = buf + sizeof(icp_common_t);
     if (neighbors_do_private_keys && header.reqnum) {
-	key = storeGeneratePrivateKey(url, METHOD_GET, header.reqnum);
+	key = storeKeyPrivate(url, METHOD_GET, header.reqnum);
     } else {
-	key = storeGeneratePublicKey(url, METHOD_GET);
+	key = storeKeyPublic(url, METHOD_GET);
     }
     debug(37, 3) ("icmpHandleSourcePing: from %s, key=%s\n",
 	inet_ntoa(from->sin_addr),
@@ -1,5 +1,5 @@
 /*
- * $Id: mime.cc,v 1.41 1997/10/25 17:22:50 wessels Exp $
+ * $Id: mime.cc,v 1.42 1997/11/03 22:43:15 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -397,8 +397,10 @@ mimeLoadIconFile(const char *icon)
     LOCAL_ARRAY(char, path, MAXPATHLEN);
     LOCAL_ARRAY(char, url, MAX_URL);
     char *buf;
+    const cache_key *key;
     snprintf(url, MAX_URL, "http://internal.squid/icons/%s", icon);
-    if (storeGet(url))
+    key = storeKeyPublic(url, METHOD_GET);
+    if (storeGet(key))
 	return;
     snprintf(path, MAXPATHLEN, "%s/%s", Config.icons.directory, icon);
     fd = file_open(path, O_RDONLY, NULL, NULL);
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.164 1997/10/27 22:54:37 wessels Exp $
+ * $Id: neighbors.cc,v 1.165 1997/11/03 22:43:16 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -400,7 +400,7 @@ neighborsUdpPing(request_t * request,
     int *exprep)
 {
     char *host = request->host;
-    char *url = entry->url;
+    const char *url = storeUrl(entry);
     MemObject *mem = entry->mem_obj;
     const ipcache_addrs *ia = NULL;
     struct sockaddr_in to_addr;
@@ -420,8 +420,7 @@ neighborsUdpPing(request_t * request,
 	debug(15, 0) ("Check 'icp_port' in your config file\n");
 	fatal_dump(NULL);
     }
-    if (entry->swap_status != SWAPOUT_NONE)
-	fatal_dump("neighborsUdpPing: bad swap_status");
+    assert(entry->swap_status == SWAPOUT_NONE);
     mem->start_ping = current_time;
     mem->icp_reply_callback = callback;
     mem->ircb_data = callback_data;
@@ -436,7 +435,7 @@ neighborsUdpPing(request_t * request,
 	    p->host, url);
 	if (p->type == PEER_MULTICAST)
 	    mcastSetTtl(theOutIcpConnection, p->mcast.ttl);
-	reqnum = storeReqnum(entry, request->method);
+	reqnum = mem->reqnum;
 	debug(15, 3) ("neighborsUdpPing: key = '%s'\n", entry->key);
 	debug(15, 3) ("neighborsUdpPing: reqnum = %d\n", reqnum);
 
@@ -918,7 +917,7 @@ peerCountMcastPeersStart(void *data)
     mem->icp_reply_callback = peerCountHandleIcpReply;
     mem->ircb_data = psstate;
     mcastSetTtl(theOutIcpConnection, p->mcast.ttl);
-    p->mcast.reqnum = storeReqnum(fake, METHOD_GET);
+    p->mcast.reqnum = mem->reqnum;
     query = icpCreateMessage(ICP_OP_QUERY, 0, url, p->mcast.reqnum, 0);
     icpUdpSend(theOutIcpConnection,
 	&p->in_addr,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.29 1997/10/25 17:22:54 wessels Exp $
+ * $Id: peer_select.cc,v 1.30 1997/11/03 22:43:17 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -91,7 +91,7 @@ peerSelectIcpPing(request_t * request, int direct, StoreEntry * entry)
     int n;
     if (entry == NULL)
 	return 0;
-    debug(44, 3) ("peerSelectIcpPing: %s\n", entry->url);
+    debug(44, 3) ("peerSelectIcpPing: %s\n", storeUrl(entry));
     if (entry->ping_status != PING_NONE)
 	return 0;
     if (direct == DIRECT_YES)
@@ -142,7 +142,7 @@ peerSelect(request_t * request,
 {
     ps_state *psstate = xcalloc(1, sizeof(ps_state));
     if (entry)
-	debug(44, 3) ("peerSelect: %s\n", entry->url);
+	debug(44, 3) ("peerSelect: %s\n", storeUrl(entry));
     else
 	debug(44, 3) ("peerSelect: %s\n", RequestMethodStr[request->method]);
     cbdataAdd(psstate);
@@ -182,7 +182,7 @@ peerSelectCallback(ps_state * psstate, peer * p)
     StoreEntry *entry = psstate->entry;
     void *data = psstate->callback_data;
     if (entry) {
-	debug(44, 3) ("peerSelectCallback: %s\n", entry->url);
+	debug(44, 3) ("peerSelectCallback: %s\n", storeUrl(entry));
 	if (entry->ping_status == PING_WAITING)
 	    eventDelete(peerPingTimeout, psstate);
 	entry->ping_status = PING_DONE;
@@ -198,7 +198,7 @@ peerSelectCallbackFail(ps_state * psstate)
 {
     request_t *request = psstate->request;
     void *data = psstate->callback_data;
-    char *url = psstate->entry ? psstate->entry->url : urlCanonical(request, NULL);
+    const char *url = psstate->entry ? storeUrl(psstate->entry) : urlCanonical(request, NULL);
     debug(44, 1) ("Failed to select source for '%s'\n", url);
     debug(44, 1) ("  always_direct = %d\n", psstate->always_direct);
     debug(44, 1) ("   never_direct = %d\n", psstate->never_direct);
@@ -336,7 +336,7 @@ peerPingTimeout(void *data)
     ps_state *psstate = data;
     StoreEntry *entry = psstate->entry;
     if (entry)
-	debug(44, 3) ("peerPingTimeout: '%s'\n", entry->url);
+	debug(44, 3) ("peerPingTimeout: '%s'\n", storeUrl(entry));
     entry->ping_status = PING_TIMEOUT;
     PeerStats.timeouts++;
     psstate->icp.timeout = 1;
@@ -387,7 +387,7 @@ peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
     request_t *request = psstate->request;
     debug(44, 3) ("peerHandleIcpReply: %s %s\n",
 	IcpOpcodeStr[op],
-	psstate->entry->url);
+	storeUrl(psstate->entry));
     psstate->icp.n_recv++;
     if (op == ICP_OP_MISS || op == ICP_OP_DECHO) {
 	if (type == PEER_PARENT)
@@ -203,7 +203,7 @@ extern int hash_join(hash_table *, hash_link *);
 extern int hash_remove_link(hash_table *, hash_link *);
 
 /* searching, accessing */
-extern hash_link *hash_lookup(hash_table *, const char *);
+extern hash_link *hash_lookup(hash_table *, const void *);
 extern hash_link *hash_first(hash_table *);
 extern hash_link *hash_next(hash_table *);
 extern hash_link *hash_get_bucket(hash_table *, unsigned int);
@@ -416,7 +416,7 @@ extern void memFreeData(mem_hdr *);
 
 /* ----------------------------------------------------------------- */
 
-extern StoreEntry *storeGet(const char *);
+extern StoreEntry *storeGet(const cache_key *);
 extern StoreEntry *storeCreateEntry(const char *, const char *, int, method_t);
 extern void storeSetPublicKey(StoreEntry *);
 extern StoreEntry *storeGetFirst(void);
@@ -431,8 +431,6 @@ extern void storeSwapInStart(StoreEntry *, SIH *, void *data);
 extern int storeRelease(StoreEntry *);
 extern int storeUnlockObject(StoreEntry *);
 extern int storeUnregister(StoreEntry *, void *);
-extern const char *storeGeneratePublicKey(const char *, method_t);
-extern const char *storeGeneratePrivateKey(const char *, method_t, int);
 extern void storeClientCopy(StoreEntry * e,
     off_t seen_offset,
     off_t copy_offset,
@@ -457,11 +455,21 @@ extern void storeClientListAdd(StoreEntry *, void *);
 extern void InvokeHandlers(StoreEntry *);
 extern int storeEntryValidToSend(StoreEntry *);
 extern void storeTimestampsSet(StoreEntry *);
-extern unsigned int storeReqnum(StoreEntry * entry, method_t);
 extern time_t storeExpiredReferenceAge(void);
 extern void storeRegisterAbort(StoreEntry * e, STABH * cb, void *);
 extern void storeUnregisterAbort(StoreEntry * e);
 extern void storeMemObjectDump(MemObject * mem);
+extern const char *storeUrl(const StoreEntry *);
+
+/* storeKey stuff */
+extern const cache_key *storeKeyDup(const cache_key *);
+extern void storeKeyFree(const cache_key *);
+extern const cache_key *storeKeyScan(const char *);
+extern const char *storeKeyText(const cache_key *);
+extern const cache_key *storeKeyPublic(const char *, method_t);
+extern const cache_key *storeKeyPrivate(const char *, method_t, int);
+extern HASHHASH storeKeyHashHash;
+extern HASHCMP storeKeyHashCmp;
 
 #ifdef __STDC__
 extern void storeAppendPrintf(StoreEntry *, const char *,...);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: refresh.cc,v 1.15 1997/07/15 23:23:31 wessels Exp $
+ * $Id: refresh.cc,v 1.16 1997/11/03 22:43:19 wessels Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -60,13 +60,13 @@ refreshCheck(const StoreEntry * entry, const request_t * request, time_t delta)
     time_t age;
     int factor;
     time_t check_time = squid_curtime + delta;
-    debug(22, 3) ("refreshCheck: '%s'\n", entry->url);
+    debug(22, 3) ("refreshCheck: '%s'\n", storeUrl(entry));
     if (BIT_TEST(entry->flag, ENTRY_REVALIDATE)) {
 	debug(22, 3) ("refreshCheck: YES: Required Authorization\n");
 	return 1;
     }
     for (R = Config.Refresh; R; R = R->next) {
-	if (regexec(&(R->compiled_pattern), entry->url, 0, 0, 0) != 0)
+	if (regexec(&(R->compiled_pattern), storeUrl(entry), 0, 0, 0) != 0)
 	    continue;
 	min = R->min;
 	pct = R->pct;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.132 1997/10/25 17:22:57 wessels Exp $
+ * $Id: squid.h,v 1.133 1997/11/03 22:43:20 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -234,19 +234,6 @@
 #define SA_RESETHAND SA_ONESHOT
 #endif
 
-/* 32 bit integer compatability hack */
-#if SIZEOF_INT == 4
-typedef int num32;
-typedef unsigned int u_num32;
-#elif SIZEOF_LONG == 4
-typedef long num32;
-typedef unsigned long u_num32;
-#else
-typedef long num32;		/* assume that long's are 32bit */
-typedef unsigned long u_num32;
-#endif
-#define NUM32LEN sizeof(num32)	/* this should always be 4 */
-
 #if PURIFY
 #define LOCAL_ARRAY(type,name,size) \
         static type *local_##name=NULL; \
@@ -262,6 +249,16 @@ typedef unsigned long u_num32;
 #include <regex.h>
 #endif
 
+#if STORE_KEY_SHA
+#undef STORE_KEY_URL
+#include "sha.h"
+#else
+#undef STORE_KEY_SHA
+#define STORE_KEY_URL 1
+#define storeKeyHashCmp urlcmp
+#define storeKeyHashHash hash4
+#endif
+
 #include "defines.h"
 #include "enums.h"
 #include "typedefs.h"
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.165 1997/10/31 20:46:24 wessels Exp $
+ * $Id: stat.cc,v 1.166 1997/11/03 22:43:20 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -295,10 +295,6 @@ describeFlags(const StoreEntry * entry)
 	strcat(buf, "RF,");
     if (BIT_TEST(flags, ENTRY_CACHABLE))
 	strcat(buf, "EC,");
-    if (BIT_TEST(flags, KEY_CHANGE))
-	strcat(buf, "KC,");
-    if (BIT_TEST(flags, KEY_URL))
-	strcat(buf, "KU,");
     if (BIT_TEST(flags, ENTRY_DISPATCHED))
 	strcat(buf, "ED,");
     if (BIT_TEST(flags, KEY_PRIVATE))
@@ -341,7 +337,7 @@ statObjects(StoreEntry * sentry, int vm_or_not)
 	    debug(18, 3) ("stat_objects_get:  Processed %d objects...\n", N);
 	}
 	storeAppendPrintf(sentry, "%s %s\n",
-	    RequestMethodStr[entry->method], entry->url);
+	    RequestMethodStr[entry->method], storeUrl(entry));
 	storeAppendPrintf(sentry, "\t%s\n", describeStatuses(entry));
 	storeAppendPrintf(sentry, "\t%s\n", describeFlags(entry));
 	storeAppendPrintf(sentry, "\t%s\n", describeTimestamps(entry));
@@ -507,14 +503,14 @@ memoryAccounted(void)
 {
     return (int)
 	meta_data.store_entries * sizeof(StoreEntry) +
+	meta_data.store_keys +
 	meta_data.ipcache_count * sizeof(ipcache_entry) +
 	meta_data.fqdncache_count * sizeof(fqdncache_entry) +
 	hash_links_allocated * sizeof(hash_link) +
 	sm_stats.total_pages_allocated * sm_stats.page_size +
 	disk_stats.total_pages_allocated * disk_stats.page_size +
 	request_pool.total_pages_allocated * request_pool.page_size +
 	mem_obj_pool.total_pages_allocated * mem_obj_pool.page_size +
-	meta_data.url_strings +
 	meta_data.netdb_addrs * sizeof(netdbEntry) +
 	meta_data.netdb_hosts * sizeof(struct _net_db_name) +
                  meta_data.netdb_peers * sizeof(struct _net_db_peer) +
@@ -673,8 +669,8 @@ info_get(StoreEntry * sentry)
 	(int) (meta_data.store_entries * sizeof(StoreEntry) >> 10));
 
     storeAppendPrintf(sentry, "{\t%-25.25s                      = %6d KB}\n",
-	"URL strings",
-	meta_data.url_strings >> 10);
+	"StoreEntry Keys",
+	meta_data.store_keys >> 10);
 
     storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB}\n",
 	"IPCacheEntry",
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.332 1997/10/31 23:37:38 wessels Exp $
+ * $Id: store.cc,v 1.333 1997/11/03 22:43:22 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -180,7 +180,7 @@ struct storeRebuildState {
 };
 
 typedef struct storeCleanList {
-    char *key;
+    const cache_key *key;
     struct storeCleanList *next;
 } storeCleanList;
 
@@ -222,9 +222,9 @@ static void storeGetMemSpace(int);
 static void storeHashDelete(StoreEntry *);
 static VCB storeSwapInValidateComplete;
 static mem_hdr *new_MemObjectData(void);
-static MemObject *new_MemObject(const char *);
-static StoreEntry *new_StoreEntry(int, const char *);
-static StoreEntry *storeAddDiskRestore(const char *,
+static MemObject *new_MemObject(const char *, const char *);
+static StoreEntry *new_StoreEntry(int, const char *, const char *);
+static StoreEntry *storeAddDiskRestore(const cache_key *,
     int,
     int,
     time_t,
@@ -263,7 +263,7 @@ static void storeEntryListAdd(StoreEntry * e, dlink_node *, dlink_list *);
 static void storeEntryListDelete(dlink_node *, dlink_list *);
 static void storeSetMemStatus(StoreEntry * e, int);
 static void storeClientCopy2(StoreEntry *, store_client *);
-static void storeHashInsert(StoreEntry * e);
+static void storeHashInsert(StoreEntry * e, const cache_key *);
 static void storeSwapOutFileClose(StoreEntry * e);
 
 /* Now, this table is inaccessible to outsider. They have to use a method
@@ -281,40 +281,37 @@ static int store_swap_high = 0;
 static int store_swap_low = 0;
 static int storelog_fd = -1;
 
-/* key temp buffer */
-static char key_temp_buffer[MAX_URL + 100];
-
 /* expiration parameters and stats */
-static int store_buckets;
+static int store_hash_buckets;
 static int store_maintain_rate;
 static int store_maintain_buckets;
 
 static MemObject *
-new_MemObject(const char *log_url)
+new_MemObject(const char *url, const char *log_url)
 {
     MemObject *mem = get_free_mem_obj();
     mem->reply = xcalloc(1, sizeof(struct _http_reply));
     mem->reply->date = -2;
     mem->reply->expires = -2;
     mem->reply->last_modified = -2;
+    mem->url = xstrdup(url);
     mem->log_url = xstrdup(log_url);
     mem->swapout.fd = -1;
     meta_data.mem_obj_count++;
     meta_data.misc += sizeof(struct _http_reply);
-    meta_data.url_strings += strlen(log_url);
+    meta_data.misc += strlen(log_url);
     debug(20, 3) ("new_MemObject: returning %p\n", mem);
     return mem;
 }
 
 static StoreEntry *
-new_StoreEntry(int mem_obj_flag, const char *log_url)
+new_StoreEntry(int mem_obj_flag, const char *url, const char *log_url)
 {
     StoreEntry *e = NULL;
-
     e = xcalloc(1, sizeof(StoreEntry));
     meta_data.store_entries++;
     if (mem_obj_flag)
-	e->mem_obj = new_MemObject(log_url);
+	e->mem_obj = new_MemObject(url, log_url);
     debug(20, 3) ("new_StoreEntry: returning %p\n", e);
     return e;
 }
@@ -325,9 +322,10 @@ destroy_MemObject(MemObject * mem)
     debug(20, 3) ("destroy_MemObject: destroying %p\n", mem);
     assert(mem->swapout.fd == -1);
     destroy_MemObjectData(mem);
-    meta_data.url_strings -= strlen(mem->log_url);
+    meta_data.misc -= strlen(mem->log_url);
     safe_free(mem->clients);
     safe_free(mem->reply);
+    safe_free(mem->url);
     safe_free(mem->log_url);
     requestUnlink(mem->request);
     mem->request = NULL;
@@ -343,16 +341,7 @@ destroy_StoreEntry(StoreEntry * e)
     assert(e != NULL);
     if (e->mem_obj)
 	destroy_MemObject(e->mem_obj);
-    if (e->url) {
-	meta_data.url_strings -= strlen(e->url);
-	safe_free(e->url);
-    } else {
-	debug(20, 3) ("destroy_StoreEntry: WARNING: Entry without URL string!\n");
-    }
-    if (BIT_TEST(e->flag, KEY_URL))
-	e->key = NULL;
-    else
-	safe_free(e->key);
+    assert(e->key == NULL);
     xfree(e);
     meta_data.store_entries--;
 }
@@ -381,10 +370,11 @@ destroy_MemObjectData(MemObject * mem)
 /* ----- INTERFACE BETWEEN STORAGE MANAGER AND HASH TABLE FUNCTIONS --------- */
 
 static void
-storeHashInsert(StoreEntry * e)
+storeHashInsert(StoreEntry * e, const cache_key * key)
 {
     debug(20, 3) ("storeHashInsert: Inserting Entry %p key '%s'\n",
-	e, e->key);
+	e, storeKeyText(key));
+    e->key = storeKeyDup(key);
     hash_join(store_table, (hash_link *) e);
     storeEntryListAdd(e, &e->lru, &all_list);
 }
@@ -394,6 +384,8 @@ storeHashDelete(StoreEntry * e)
 {
     hash_remove_link(store_table, (hash_link *) e);
     storeEntryListDelete(&e->lru, &all_list);
+    storeKeyFree(e->key);
+    e->key = NULL;
 }
 
 /* -------------------------------------------------------------------------- */
@@ -409,9 +401,9 @@ storeLog(int tag, const StoreEntry * e)
     if (mem == NULL)
 	return;
     if (mem->log_url == NULL) {
-	debug(20, 1) ("storeLog: NULL log_url for %s\n", e->url);
+	debug(20, 1) ("storeLog: NULL log_url for %s\n", mem->url);
 	storeMemObjectDump(mem);
-	mem->log_url = xstrdup(e->url);
+	mem->log_url = xstrdup(mem->url);
     }
     reply = mem->reply;
     snprintf(logmsg, MAX_URL << 1, "%9d.%03d %-7s %08X %4d %9d %9d %9d %s %d/%d %s %s\n",
@@ -444,7 +436,8 @@ storePurgeMem(StoreEntry * e)
 {
     if (e->mem_obj == NULL)
 	return;
-    debug(20, 3) ("storePurgeMem: Freeing memory-copy of %s\n", e->key);
+    debug(20, 3) ("storePurgeMem: Freeing memory-copy of %s\n",
+	storeKeyText(e->key));
     storeSetMemStatus(e, NOT_IN_MEMORY);
     destroy_MemObject(e->mem_obj);
     e->mem_obj = NULL;
@@ -460,7 +453,7 @@ storeLockObject(StoreEntry * e)
 	storeEntryListAdd(e, &e->lru, &all_list);
     }
     debug(20, 3) ("storeLockObject: key '%s' count=%d\n",
-	e->key, (int) e->lock_count);
+	storeKeyText(e->key), (int) e->lock_count);
     e->lastref = squid_curtime;
 }
 
@@ -471,8 +464,7 @@ storeReleaseRequest(StoreEntry * e)
 	return;
     if (!storeEntryLocked(e))
 	fatal_dump("storeReleaseRequest: unlocked entry");
-    debug(20, 3) ("storeReleaseRequest: '%s'\n",
-	e->key ? e->key : e->url);
+    debug(20, 3) ("storeReleaseRequest: '%s'\n", storeKeyText(e->key));
     BIT_SET(e->flag, RELEASE_REQUEST);
     storeSetPrivateKey(e);
 }
@@ -484,7 +476,7 @@ storeUnlockObject(StoreEntry * e)
 {
     e->lock_count--;
     debug(20, 3) ("storeUnlockObject: key '%s' count=%d\n",
-	e->key, e->lock_count);
+	storeKeyText(e->key), e->lock_count);
     if (e->lock_count)
 	return (int) e->lock_count;
     if (e->store_status == STORE_PENDING) {
@@ -506,10 +498,10 @@ storeUnlockObject(StoreEntry * e)
 /* Lookup an object in the cache. 
  * return just a reference to object, don't start swapping in yet. */
 StoreEntry *
-storeGet(const char *url)
+storeGet(const cache_key * key)
 {
-    debug(20, 3) ("storeGet: looking up %s\n", url);
-    return (StoreEntry *) hash_lookup(store_table, url);
+    debug(20, 3) ("storeGet: looking up %s\n", storeKeyText(key));
+    return (StoreEntry *) hash_lookup(store_table, key);
 }
 
 static unsigned int
@@ -521,114 +513,46 @@ getKeyCounter(void)
     return key_counter;
 }
 
-unsigned int
-storeReqnum(StoreEntry * entry, method_t method)
-{
-    unsigned int k;
-    if (BIT_TEST(entry->flag, KEY_PRIVATE))
-	k = atoi(entry->key);
-    else
-	k = getKeyCounter();
-    if (method == METHOD_GET)
-	return k;
-    return (method << 24) | k;
-}
-
-const char *
-storeGeneratePrivateKey(const char *url, method_t method, int num)
-{
-    if (num == 0)
-	num = getKeyCounter();
-    else if (num & 0xFF000000) {
-	method = (method_t) (num >> 24);
-	num &= 0x00FFFFFF;
-    }
-    debug(20, 3) ("storeGeneratePrivateKey: '%s'\n", url);
-    key_temp_buffer[0] = '\0';
-    snprintf(key_temp_buffer, MAX_URL + 100, "%d/%s/%s",
-	num,
-	RequestMethodStr[method],
-	url);
-    return key_temp_buffer;
-}
-
-const char *
-storeGeneratePublicKey(const char *url, method_t method)
-{
-    debug(20, 3) ("storeGeneratePublicKey: type=%d %s\n", method, url);
-    switch (method) {
-    case METHOD_GET:
-	return url;
-	/* NOTREACHED */
-	break;
-    case METHOD_POST:
-    case METHOD_PUT:
-    case METHOD_HEAD:
-    case METHOD_CONNECT:
-    case METHOD_TRACE:
-	snprintf(key_temp_buffer, MAX_URL + 100, "/%s/%s", RequestMethodStr[method], url);
-	return key_temp_buffer;
-	/* NOTREACHED */
-	break;
-    default:
-	fatal_dump("storeGeneratePublicKey: Unsupported request method");
-	break;
-    }
-    return NULL;
-}
-
 static void
 storeSetPrivateKey(StoreEntry * e)
 {
-    const char *newkey = NULL;
+    const cache_key *newkey;
+    MemObject *mem = e->mem_obj;
     if (e->key && BIT_TEST(e->flag, KEY_PRIVATE))
 	return;			/* is already private */
-    newkey = storeGeneratePrivateKey(e->url, e->method, 0);
-    assert(hash_lookup(store_table, newkey) == NULL);
     if (e->key)
 	storeHashDelete(e);
-    if (e->key && !BIT_TEST(e->flag, KEY_URL))
-	safe_free(e->key);
-    e->key = xstrdup(newkey);
-    storeHashInsert(e);
-    BIT_CLR(e->flag, KEY_URL);
-    BIT_SET(e->flag, KEY_CHANGE);
+    if (mem != NULL) {
+	mem->reqnum = getKeyCounter();
+	newkey = storeKeyPrivate(mem->url, e->method, mem->reqnum);
+    } else {
+	newkey = storeKeyPrivate("JUNK", METHOD_NONE, getKeyCounter());
+    }
+    assert(hash_lookup(store_table, newkey) == NULL);
+    storeHashInsert(e, newkey);
     BIT_SET(e->flag, KEY_PRIVATE);
 }
 
 void
 storeSetPublicKey(StoreEntry * e)
 {
     StoreEntry *e2 = NULL;
-    hash_link *table_entry = NULL;
-    const char *newkey = NULL;
-    int loop_detect = 0;
+    const cache_key *newkey;
+    MemObject *mem = e->mem_obj;
     if (e->key && !BIT_TEST(e->flag, KEY_PRIVATE))
 	return;			/* is already public */
-    newkey = storeGeneratePublicKey(e->url, e->method);
-    while ((table_entry = hash_lookup(store_table, newkey))) {
-	debug(20, 3) ("storeSetPublicKey: Making old '%s' private.\n", newkey);
-	e2 = (StoreEntry *) table_entry;
+    assert(mem);
+    newkey = storeKeyPublic(mem->url, e->method);
+    if ((e2 = (StoreEntry *) hash_lookup(store_table, newkey))) {
+	debug(20, 3) ("storeSetPublicKey: Making old '%s' private.\n", mem->url);
 	storeSetPrivateKey(e2);
 	storeRelease(e2);
-	assert(++loop_detect < 10);
-	newkey = storeGeneratePublicKey(e->url, e->method);
+	newkey = storeKeyPublic(mem->url, e->method);
     }
     if (e->key)
 	storeHashDelete(e);
-    if (e->key && !BIT_TEST(e->flag, KEY_URL))
-	safe_free(e->key);
-    if (e->method == METHOD_GET) {
-	e->key = e->url;
-	BIT_SET(e->flag, KEY_URL);
-	BIT_CLR(e->flag, KEY_CHANGE);
-    } else {
-	e->key = xstrdup(newkey);
-	BIT_CLR(e->flag, KEY_URL);
-	BIT_SET(e->flag, KEY_CHANGE);
-    }
+    storeHashInsert(e, newkey);
     BIT_CLR(e->flag, KEY_PRIVATE);
-    storeHashInsert(e);
 }
 
 StoreEntry *
@@ -638,11 +562,9 @@ storeCreateEntry(const char *url, const char *log_url, int flags, method_t metho
     MemObject *mem = NULL;
     debug(20, 3) ("storeCreateEntry: '%s' icp flags=%x\n", url, flags);
 
-    e = new_StoreEntry(WITH_MEMOBJ, log_url);
+    e = new_StoreEntry(WITH_MEMOBJ, url, log_url);
     e->lock_count = 1;		/* Note lock here w/o calling storeLock() */
     mem = e->mem_obj;
-    e->url = xstrdup(url);
-    meta_data.url_strings += strlen(url);
     e->method = method;
     if (neighbors_do_private_keys || !BIT_TEST(flags, REQ_HIERARCHICAL))
 	storeSetPrivateKey(e);
@@ -675,7 +597,7 @@ storeCreateEntry(const char *url, const char *log_url, int flags, method_t metho
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
 static StoreEntry *
-storeAddDiskRestore(const char *url,
+storeAddDiskRestore(const cache_key * key,
     int file_number,
     int size,
     time_t expires,
@@ -687,15 +609,12 @@ storeAddDiskRestore(const char *url,
     int clean)
 {
     StoreEntry *e = NULL;
-    debug(20, 5) ("StoreAddDiskRestore: %s, fileno=%08X\n", url, file_number);
+    debug(20, 5) ("StoreAddDiskRestore: %s, fileno=%08X\n", storeKeyText(key), file_number);
     /* if you call this you'd better be sure file_number is not 
      * already in use! */
-    meta_data.url_strings += strlen(url);
-    e = new_StoreEntry(WITHOUT_MEMOBJ, NULL);
-    e->url = xstrdup(url);
+    e = new_StoreEntry(WITHOUT_MEMOBJ, NULL, NULL);
     e->method = METHOD_GET;
-    storeSetPublicKey(e);
-    assert(e->key);
+    storeHashInsert(e, key);
     e->store_status = STORE_OK;
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_DONE;
@@ -734,7 +653,7 @@ storeUnregister(StoreEntry * e, void *data)
     STCB *callback;
     if (mem == NULL)
 	return 0;
-    debug(20, 3) ("storeUnregister: called for '%s'\n", e->key);
+    debug(20, 3) ("storeUnregister: called for '%s'\n", storeKeyText(e->key));
     for (S = &mem->clients; (sc = *S); S = &(*S)->next) {
 	if (sc->callback_data == data)
 	    break;
@@ -751,7 +670,8 @@ storeUnregister(StoreEntry * e, void *data)
     }
     if ((callback = sc->callback)) {
 	/* callback with ssize = -1 to indicate unexpected termination */
-	debug(20, 3) ("storeUnregister: store_client for %s has a callback\n", e->url);
+	debug(20, 3) ("storeUnregister: store_client for %s has a callback\n",
+	    mem->url);
 	sc->callback = NULL;
 	callback(sc->callback_data, sc->copy_buf, -1);
     }
@@ -788,7 +708,7 @@ InvokeHandlers(StoreEntry * e)
     store_client *sc;
     store_client *nx = NULL;
     assert(mem->clients != NULL || mem->nclients == 0);
-    debug(20, 3) ("InvokeHandlers: %s\n", e->key);
+    debug(20, 3) ("InvokeHandlers: %s\n", storeKeyText(e->key));
     /* walk the entire list looking for valid callbacks */
     for (sc = mem->clients; sc; sc = nx) {
 	nx = sc->next;
@@ -805,7 +725,7 @@ InvokeHandlers(StoreEntry * e)
 void
 storeExpireNow(StoreEntry * e)
 {
-    debug(20, 3) ("storeExpireNow: '%s'\n", e->key);
+    debug(20, 3) ("storeExpireNow: '%s'\n", storeKeyText(e->key));
     e->expires = squid_curtime;
 }
 
@@ -832,7 +752,7 @@ storeSwapoutFileOpened(void *data, int fd)
     mem->swapout.fd = (short) fd;
     e->swap_status = SWAPOUT_WRITING;
     debug(20, 5) ("storeSwapoutFileOpened: Begin SwapOut '%s' to FD %d FILE %s.\n",
-	e->url, fd, swapfilename);
+	mem->url, fd, swapfilename);
     xfree(swapfilename);
     debug(20, 5) ("swap_file_number=%08X\n", e->swap_file_number);
     storeCheckSwapOut(e);
@@ -864,7 +784,7 @@ storeSwapOutHandle(int fd, int flag, size_t len, void *data)
 {
     StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
-    debug(20, 3) ("storeSwapOutHandle: '%s', len=%d\n", e->key, (int) len);
+    debug(20, 3) ("storeSwapOutHandle: '%s', len=%d\n", storeKeyText(e->key), (int) len);
     assert(mem != NULL);
     if (flag < 0) {
 	debug(20, 1) ("storeSwapOutHandle: SwapOut failure (err code = %d).\n",
@@ -890,7 +810,7 @@ storeSwapOutHandle(int fd, int flag, size_t len, void *data)
     }
     /* swapping complete */
     debug(20, 5) ("storeSwapOutHandle: SwapOut complete: '%s' to %s.\n",
-	e->url, storeSwapFullPath(e->swap_file_number, NULL));
+	mem->url, storeSwapFullPath(e->swap_file_number, NULL));
     e->swap_status = SWAPOUT_DONE;
     storeDirUpdateSwapSize(e->swap_file_number, mem->swapout.done_offset, 1);
     HTTPCacheInfo->proto_newobject(HTTPCacheInfo,
@@ -918,7 +838,7 @@ storeCheckSwapOut(StoreEntry * e)
     int x;
     assert(mem != NULL);
     /* should we swap something out to disk? */
-    debug(20, 3) ("storeCheckSwapOut: %s\n", e->url);
+    debug(20, 3) ("storeCheckSwapOut: %s\n", mem->url);
     debug(20, 3) ("storeCheckSwapOut: store_status = %s\n",
 	storeStatusStr[e->store_status]);
     if (e->store_status == STORE_ABORTED) {
@@ -979,7 +899,7 @@ storeCheckSwapOut(StoreEntry * e)
 	swap_buf,
 	swapout_size);
     if (swap_buf_len < 0) {
-	debug(20, 1) ("memCopy returned %d for '%s'\n", swap_buf_len, e->key);
+	debug(20, 1) ("memCopy returned %d for '%s'\n", swap_buf_len, storeKeyText(e->key));
 	/* XXX This is probably wrong--we should storeRelease()? */
 	storeDirMapBitReset(e->swap_file_number);
 	safeunlink(storeSwapFullPath(e->swap_file_number, NULL), 1);
@@ -1011,7 +931,7 @@ storeAppend(StoreEntry * e, const char *buf, int len)
     assert(mem != NULL);
     assert(len >= 0);
     if (len) {
-	debug(20, 5) ("storeAppend: appending %d bytes for '%s'\n", len, e->key);
+	debug(20, 5) ("storeAppend: appending %d bytes for '%s'\n", len, storeKeyText(e->key));
 	storeGetMemSpace(len);
 	memAppend(mem->data, buf, len);
 	mem->inmem_hi += len;
@@ -1096,19 +1016,20 @@ storeSwapInFileOpened(void *data, int fd)
 {
     swapin_ctrl_t *ctrlp = (swapin_ctrl_t *) data;
     StoreEntry *e = ctrlp->e;
-    assert(e->mem_obj != NULL);
+    MemObject *mem = e->mem_obj;
+    assert(mem != NULL);
     assert(e->mem_status == NOT_IN_MEMORY);
     assert(e->swap_status == SWAPOUT_WRITING || e->swap_status == SWAPOUT_DONE);
     if (fd < 0) {
-	debug(20, 0) ("storeSwapInStartComplete: Failed for '%s'\n", e->url);
+	debug(20, 0) ("storeSwapInStartComplete: Failed for '%s'\n", mem->url);
 	/* Invoke a store abort that should free the memory object */
 	(ctrlp->callback) (-1, ctrlp->callback_data);
 	xfree(ctrlp->path);
 	xfree(ctrlp);
 	return;
     }
     debug(20, 5) ("storeSwapInStart: initialized swap file '%s' for '%s'\n",
-	ctrlp->path, e->url);
+	ctrlp->path, mem->url);
     (ctrlp->callback) (fd, ctrlp->callback_data);
     xfree(ctrlp->path);
     xfree(ctrlp);
@@ -1121,7 +1042,7 @@ storeDoRebuildFromDisk(void *data)
 {
     struct storeRebuildState *RB = data;
     LOCAL_ARRAY(char, swapfile, MAXPATHLEN);
-    LOCAL_ARRAY(char, url, MAX_URL);
+    LOCAL_ARRAY(char, keytext, MAX_URL);
     StoreEntry *e = NULL;
     time_t expires;
     time_t timestamp;
@@ -1142,6 +1063,7 @@ storeDoRebuildFromDisk(void *data)
     struct _rebuild_dir **D;
     int used;			/* is swapfile already in use? */
     int newer;			/* is the log entry newer than current entry? */
+    const cache_key *key;
 
     /* load a number of objects per invocation */
     if ((d = RB->rebuild_dir) == NULL) {
@@ -1168,7 +1090,7 @@ storeDoRebuildFromDisk(void *data)
 	    continue;
 	if (RB->line_in[0] == '#')
 	    continue;
-	url[0] = '\0';
+	keytext[0] = '\0';
 	sfileno = 0;
 	scan1 = 0;
 	scan2 = 0;
@@ -1186,13 +1108,11 @@ storeDoRebuildFromDisk(void *data)
 	    &scan5,		/* size */
 	    &scan6,		/* refcount */
 	    &scan7,		/* flags */
-	    url);		/* url */
+	    keytext);		/* key */
 	if (x < 1) {
 	    RB->invalid++;
 	    continue;
 	}
-	if (strncmp(url, "http://internal.squid", 21) == 0)
-	    continue;
 	storeSwapFullPath(sfileno, swapfile);
 	if (x != 9) {
 	    RB->invalid++;
@@ -1213,7 +1133,8 @@ storeDoRebuildFromDisk(void *data)
 	lastmod = (time_t) scan4;
 	size = (off_t) scan5;
 
-	e = storeGet(url);
+	key = storeKeyScan(keytext);
+	e = storeGet(key);
 	used = storeDirMapBitTest(sfileno);
 	/* If this URL already exists in the cache, does the swap log
 	 * appear to have a newer entry?  Compare 'lastref' from the
@@ -1264,7 +1185,7 @@ storeDoRebuildFromDisk(void *data)
 	}
 	/* update store_swap_size */
 	RB->objcount++;
-	e = storeAddDiskRestore(url,
+	e = storeAddDiskRestore(key,
 	    sfileno,
 	    (int) size,
 	    expires,
@@ -1275,10 +1196,6 @@ storeDoRebuildFromDisk(void *data)
 	    (u_num32) scan7,	/* flags */
 	    d->clean);
 	storeDirSwapLog(e);
-	HTTPCacheInfo->proto_newobject(HTTPCacheInfo,
-	    urlParseProtocol(url),
-	    (int) size,
-	    TRUE);
     }
     RB->rebuild_dir = d->next;
     for (D = &RB->rebuild_dir; *D; D = &(*D)->next);
@@ -1297,7 +1214,7 @@ storeCleanup(void *data)
     StoreEntry *e;
     hash_link *link_ptr = NULL;
     if (list == NULL) {
-	if (++bucketnum >= store_buckets) {
+	if (++bucketnum >= store_hash_buckets) {
 	    debug(20, 1) ("  Completed Validation Procedure\n");
 	    debug(20, 1) ("  Validated %d Entries\n", validnum);
 	    debug(20, 1) ("  store_swap_size = %dk\n", store_swap_size);
@@ -1312,7 +1229,7 @@ storeCleanup(void *data)
 	    if (BIT_TEST(e->flag, RELEASE_REQUEST))
 		continue;
 	    curr = xcalloc(1, sizeof(storeCleanList));
-	    curr->key = xstrdup(e->key);
+	    curr->key = storeKeyDup(e->key);
 	    curr->next = list;
 	    list = curr;
 	}
@@ -1331,7 +1248,7 @@ storeCleanup(void *data)
 	    debug(20, 1) ("  %7d Entries Validated so far.\n", validnum);
 	assert(validnum <= meta_data.store_entries);
     }
-    xfree(curr->key);
+    storeKeyFree(curr->key);
     xfree(curr);
     eventAdd("storeCleanup", storeCleanup, NULL, 0);
 }
@@ -1497,7 +1414,7 @@ storeCheckCachable(StoreEntry * e)
 void
 storeComplete(StoreEntry * e)
 {
-    debug(20, 3) ("storeComplete: '%s'\n", e->key);
+    debug(20, 3) ("storeComplete: '%s'\n", storeKeyText(e->key));
     e->object_len = e->mem_obj->inmem_hi;
     e->store_status = STORE_OK;
     assert(e->mem_status == NOT_IN_MEMORY);
@@ -1516,7 +1433,7 @@ storeAbort(StoreEntry * e, int cbflag)
     MemObject *mem = e->mem_obj;
     assert(e->store_status == STORE_PENDING);
     assert(mem != NULL);
-    debug(20, 6) ("storeAbort: %s\n", e->key);
+    debug(20, 6) ("storeAbort: %s\n", storeKeyText(e->key));
     storeNegativeCache(e);
     storeReleaseRequest(e);
     e->store_status = STORE_ABORTED;
@@ -1667,9 +1584,7 @@ storeMaintainSwapSpace(void *NOTUSED)
 int
 storeRelease(StoreEntry * e)
 {
-    StoreEntry *hentry = NULL;
-    const char *hkey;
-    debug(20, 3) ("storeRelease: Releasing: '%s'\n", e->key);
+    debug(20, 3) ("storeRelease: Releasing: '%s'\n", storeKeyText(e->key));
     /* If, for any reason we can't discard this object because of an
      * outstanding request, mark it for pending release */
     if (storeEntryLocked(e)) {
@@ -1678,15 +1593,9 @@ storeRelease(StoreEntry * e)
 	storeReleaseRequest(e);
 	return 0;
     }
-    /* check if coresponding HEAD object exists. */
-    if (e->method == METHOD_GET) {
-	hkey = storeGeneratePublicKey(e->url, METHOD_HEAD);
-	if ((hentry = (StoreEntry *) hash_lookup(store_table, hkey)))
-	    storeExpireNow(hentry);
-    }
     if (store_rebuilding) {
 	debug(20, 2) ("storeRelease: Delaying release until store is rebuilt: '%s'\n",
-	    e->key ? e->key : e->url ? e->url : "NO URL");
+	    storeUrl(e));
 	storeExpireNow(e);
 	storeSetPrivateKey(e);
 	BIT_SET(e->flag, RELEASE_REQUEST);
@@ -1697,9 +1606,6 @@ storeRelease(StoreEntry * e)
 	    storePutUnusedFileno(e->swap_file_number);
 	storeDirUpdateSwapSize(e->swap_file_number, e->object_len, -1);
 	e->swap_file_number = -1;
-	HTTPCacheInfo->proto_purgeobject(HTTPCacheInfo,
-	    urlParseProtocol(e->url),
-	    e->object_len);
     }
     storeSetMemStatus(e, NOT_IN_MEMORY);
     storeHashDelete(e);
@@ -1755,8 +1661,7 @@ storeClientListAdd(StoreEntry * e, void *data)
     MemObject *mem = e->mem_obj;
     store_client **T;
     store_client *sc;
-    if (mem == NULL)
-	mem = e->mem_obj = new_MemObject(urlClean(e->url));
+    assert(mem);
     if (storeClientListSearch(mem, data) != NULL)
 	return;
     mem->nclients++;
@@ -1790,7 +1695,7 @@ storeClientCopy(StoreEntry * e,
     assert(e->store_status != STORE_ABORTED);
     assert(recurse_detect < 3);	/* could == 1 for IMS not modified's */
     debug(20, 3) ("storeClientCopy: %s, seen %d, want %d, size %d, cb %p, cbdata %p\n",
-	e->key,
+	storeKeyText(e->key),
 	(int) seen_offset,
 	(int) copy_offset,
 	(int) size,
@@ -1815,7 +1720,7 @@ storeClientCopy2(StoreEntry * e, store_client * sc)
     STCB *callback = sc->callback;
     MemObject *mem = e->mem_obj;
     size_t sz;
-    debug(20, 3) ("storeClientCopy2: %s\n", e->key);
+    debug(20, 3) ("storeClientCopy2: %s\n", storeKeyText(e->key));
     assert(callback != NULL);
     if (e->store_status == STORE_ABORTED) {
 	sc->callback = NULL;
@@ -1902,40 +1807,32 @@ storeEntryValidLength(const StoreEntry * e)
     hdr_sz = e->mem_obj->reply->hdr_sz;
     content_length = e->mem_obj->reply->content_length;
 
-    debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", e->key);
+    debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", storeKeyText(e->key));
     debug(20, 5) ("storeEntryValidLength:     object_len = %d\n", e->object_len);
     debug(20, 5) ("storeEntryValidLength:         hdr_sz = %d\n", hdr_sz);
     debug(20, 5) ("storeEntryValidLength: content_length = %d\n", content_length);
 
     if (content_length == 0) {
 	debug(20, 5) ("storeEntryValidLength: Zero content length; assume valid; '%s'\n",
-	    e->key);
+	    storeKeyText(e->key));
 	return 1;
     }
     if (hdr_sz == 0) {
 	debug(20, 5) ("storeEntryValidLength: Zero header size; assume valid; '%s'\n",
-	    e->key);
+	    storeKeyText(e->key));
 	return 1;
     }
     diff = hdr_sz + content_length - e->object_len;
     if (diff != 0) {
 	debug(20, 3) ("storeEntryValidLength: %d bytes too %s; '%s'\n",
 	    diff < 0 ? -diff : diff,
 	    diff < 0 ? "small" : "big",
-	    e->key);
+	    storeKeyText(e->key));
 	return 0;
     }
     return 1;
 }
 
-#if HAVE_RANDOM
-#define squid_random random
-#elif HAVE_LRAND48
-#define squid_random lrand48
-#else
-#define squid_random rand
-#endif
-
 static void
 storeInitHashValues(void)
 {
@@ -1948,19 +1845,11 @@ storeInitHashValues(void)
     debug(20, 1) ("Target number of buckets: %d\n", i);
     /* ideally the full scan period should be configurable, for the
      * moment it remains at approximately 24 hours.  */
-    if (i < 8192)
-	store_buckets = 7951, store_maintain_rate = 10;
-    else if (i < 12288)
-	store_buckets = 12149, store_maintain_rate = 7;
-    else if (i < 16384)
-	store_buckets = 16231, store_maintain_rate = 5;
-    else if (i < 32768)
-	store_buckets = 33493, store_maintain_rate = 2;
-    else
-	store_buckets = 65357, store_maintain_rate = 1;
-    store_maintain_buckets = 1;
+    store_hash_buckets = storeKeyHashBuckets(i);
+    store_maintain_rate = store_hash_buckets / 86400;
+    assert(store_maintain_rate > 0);
     debug(20, 1) ("Using %d Store buckets, maintain %d bucket%s every %d second%s\n",
-	store_buckets,
+	store_hash_buckets,
 	store_maintain_buckets,
 	store_maintain_buckets == 1 ? null_string : "s",
 	store_maintain_rate,
@@ -1974,7 +1863,8 @@ storeInit(void)
 {
     char *fname = NULL;
     storeInitHashValues();
-    store_table = hash_create(urlcmp, store_buckets, hash4);
+    store_table = hash_create(storeKeyHashCmp,
+	store_hash_buckets, storeKeyHashHash);
     if (strcmp((fname = Config.Log.store), "none") == 0)
 	storelog_fd = -1;
     else
@@ -2012,7 +1902,7 @@ storeConfigure(void)
 }
 
 int
-urlcmp(const char *url1, const char *url2)
+urlcmp(const void *url1, const void *url2)
 {
     if (!url1 || !url2)
 	fatal_dump("urlcmp: Got a NULL url pointer.");
@@ -2094,7 +1984,7 @@ storeWriteCleanLogs(int reopen)
 	    e->object_len,
 	    e->refcount,
 	    e->flag,
-	    e->url);
+	    storeKeyText(e->key));
 	if (write(fd[dirn], line, strlen(line)) < 0) {
 	    debug(50, 0) ("storeWriteCleanLogs: %s: %s\n", new[dirn], xstrerror());
 	    debug(20, 0) ("storeWriteCleanLogs: Current swap logfile not replaced.\n");
@@ -2400,7 +2290,7 @@ storeMemObjectDump(MemObject * mem)
 static void
 storeEntryListAdd(StoreEntry * e, dlink_node * m, dlink_list * list)
 {
-    debug(20, 3) ("storeEntryListAdd: %s\n", e->url);
+    debug(20, 3) ("storeEntryListAdd: %s\n", storeKeyText(e->key));
     m->data = e;
     m->prev = NULL;
     m->next = list->head;
@@ -2452,3 +2342,14 @@ storeSwapOutFileClose(StoreEntry * e)
     mem->swapout.fd = -1;
     storeUnlockObject(e);
 }
+
+const char *
+storeUrl(const StoreEntry * e)
+{
+    if (e == NULL)
+	return "[null entry]";
+    else if (e->mem_obj == NULL)
+	return "[null mem_obj]";
+    else
+	return e->mem_obj->url;
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir.cc,v 1.35 1997/10/30 00:51:07 wessels Exp $
+ * $Id: store_dir.cc,v 1.36 1997/11/03 22:43:22 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -226,7 +226,7 @@ storeDirSwapLog(const StoreEntry * e)
 	e->object_len,
 	e->refcount,
 	e->flag,
-	e->url);
+	storeKeyText(e->key));
     file_write(Config.cacheSwap.swapDirs[dirn].swaplog_fd,
 	xstrdup(logmsg),
 	strlen(logmsg),
@@ -575,7 +575,7 @@ struct _peer {
 	int n_times_counted;
 	int n_replies_expected;
 	int ttl;
-	int reqnum;
+	u_num32 reqnum;
 	int flags;
     } mcast;
     int tcp_up;			/* 0 if a connect() fails */
@@ -655,7 +655,6 @@ struct _icp_common_t {
     u_num32 reqnum;		/* req number (req'd for UDP) */
     u_num32 flags;
     u_num32 pad;
-    /* u_num32 auth[ICP_AUTH_SIZE];     authenticator (old) */
     u_num32 shostid;		/* sender host id */
 };
 
@@ -692,9 +691,9 @@ struct _Meta_data {
     int netdb_addrs;
     int netdb_hosts;
     int netdb_peers;
-    int url_strings;
     int misc;
     int client_info;
+    int store_keys;
 };
 
 struct _cacheinfo {
@@ -765,6 +764,7 @@ struct _dlink_list {
 
 /* This structure can be freed while object is purged out from memory */
 struct _MemObject {
+    char *url;
     mem_hdr *data;
     off_t inmem_hi;
     off_t inmem_lo;
@@ -787,14 +787,13 @@ struct _MemObject {
     } abort;
     char *log_url;
     dlink_node lru;
+    u_num32 reqnum;
 };
 
-/* A cut down structure for store manager */
 struct _StoreEntry {
     /* first two items must be same as hash_link in hash.h */
-    char *key;
+    const cache_key *key;
     struct _StoreEntry *next;
-    char *url;
     MemObject *mem_obj;
     u_num32 flag;
     u_num32 refcount;
@@ -74,6 +74,7 @@ typedef struct _CommWriteStateData CommWriteStateData;
 typedef struct _ErrorState ErrorState;
 typedef struct _dlink_node dlink_node;
 typedef struct _dlink_list dlink_list;
+
 typedef void AIOCB(void *, int aio_return, int aio_errno);
 typedef void CWCB(int fd, char *, int size, int errflag, void *data);
 typedef void CNCB(int fd, int status, void *);
@@ -86,8 +87,8 @@ typedef void DWCB(int, int, size_t, void *);
 typedef void FILE_WALK_HD(int fd, int errflag, void *data);
 typedef void FILE_WALK_LHD(int fd, const char *buf, int size, void *line_data);
 typedef void FQDNH(const char *, void *);
-typedef int HASHCMP(const char *, const char *);
-typedef unsigned int HASHHASH(const char *, unsigned int);
+typedef int HASHCMP(const void *, const void *);
+typedef unsigned int HASHHASH(const void *, unsigned int);
 typedef void IDCB(void *);
 typedef void IPH(const ipcache_addrs *, void *);
 typedef void IRCB(peer *, peer_t, icp_common_t *, void *data);
@@ -102,3 +103,23 @@ typedef void STABH(void *);
 typedef void ERCB(int fd, void *, int size);
 typedef void OBJH(StoreEntry *);
 typedef void SIGHDLR(int sig);
+
+/* 32 bit integer compatability hack */
+#if SIZEOF_INT == 4
+typedef int num32;
+typedef unsigned int u_num32;
+#elif SIZEOF_LONG == 4
+typedef long num32;
+typedef unsigned long u_num32;
+#else
+typedef long num32;		/* assume that long's are 32bit */
+typedef unsigned long u_num32;
+#endif
+#define NUM32LEN sizeof(num32)	/* this should always be 4 */
+
+#if STORE_KEY_SHA
+typedef int cache_key;
+#endif
+#if STORE_KEY_URL
+typedef char cache_key;
+#endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.94 1997/10/30 03:31:26 wessels Exp $
+ * $Id: wais.cc,v 1.95 1997/11/03 22:43:26 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -142,7 +142,7 @@ waisTimeout(int fd, void *data)
     WaisStateData *waisState = data;
     ErrorState *err;
     StoreEntry *entry = waisState->entry;
-    debug(24, 4) ("waisTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(24, 4) ("waisTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
     err = errorCon(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT);
     err->request = urlParse(METHOD_CONNECT, waisState->request);
     errorAppendEntry(entry, err);
@@ -285,7 +285,7 @@ waisStart(request_t * request, StoreEntry * entry)
 {
     WaisStateData *waisState = NULL;
     int fd;
-    char *url = entry->url;
+    const char *url = storeUrl(entry);
     method_t method = request->method;
     debug(24, 3) ("waisStart: \"%s %s\"\n", RequestMethodStr[method], url);
     if (!Config.Wais.relayHost) {
@@ -365,6 +365,6 @@ static void
 waisAbort(void *data)
 {
     HttpStateData *waisState = data;
-    debug(24, 1) ("waisAbort: %s\n", waisState->entry->url);
+    debug(24, 1) ("waisAbort: %s\n", storeUrl(waisState->entry));
     comm_close(waisState->fd);
 }