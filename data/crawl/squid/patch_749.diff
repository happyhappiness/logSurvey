@@ -210,4 +210,20 @@ max(A const & lhs, A const & rhs)
 #endif
 
 
+/**
+ * com_err.h is a C header and needs excplicit shielding, but not
+ * all other system headers including this care to do this.
+ */
+#ifdef __cplusplus
+#if HAVE_ET_COM_ERR_H
+extern "C" {
+#include <et/com_err.h>
+}
+#elif HAVE_COM_ERR_H
+extern "C" {
+#include <com_err.h>
+}
+#endif
+#endif
+
 #endif /* _SQUID_COMPAT_SHARED_H */
@@ -42,6 +42,9 @@
 #elif defined(__FreeBSD__)	/* FreeBSD */
 #define _SQUID_FREEBSD_
 
+#elif defined(__FreeBSD_kernel__)      /* GNU/kFreeBSD */
+#define _SQUID_KFREEBSD_
+
 #elif defined(__sgi__)	|| defined(sgi) || defined(__sgi)	/* SGI */
 #define _SQUID_SGI_
 
@@ -28,7 +28,7 @@ ERROR_TEMPLATES =  \
 	templates/ERR_UNSUP_HTTPVERSION \
 	templates/ERR_READ_TIMEOUT \
 	templates/ERR_ICAP_FAILURE \
-	templates/ERR_FTP_LISTING \
+	templates/ERR_DIR_LISTING \
 	templates/ERR_FTP_FORBIDDEN \
 	templates/ERR_ACCESS_DENIED \
 	templates/ERR_FORWARDING_DENIED \
@@ -135,20 +135,20 @@ install-exec-local: translate
 
 install-data-local: translate
 	$(mkinstalldirs) $(DESTDIR)$(DEFAULT_ERROR_DIR) ; \
-	for l in $(TRANSLATE_LANGUAGES); do \
+	for l in $(TRANSLATE_LANGUAGES) templates; do \
 	    l=`basename $$l .lang`; \
 	    echo "Located $$l for install..."; \
 	    if test -d $(srcdir)/$$l || test -d $(builddir)/$$l; then \
 		$(mkinstalldirs) $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l; \
 	    fi; \
 	    for f in $(ERROR_TEMPLATES); do \
 		page=`basename $$f`; \
-		if test -f $(builddir)/$$l/$$f; then \
-		    echo "$(INSTALL_DATA) $(builddir)/$$l/$$f $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l"; \
-			    $(INSTALL_DATA) $(builddir)/$$l/$$f $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l; \
-		elif test -f $(srcdir)/$$l/$$f; then \
-		    echo "$(INSTALL_DATA) $(srcdir)/$$l/$$f $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l"; \
-			    $(INSTALL_DATA) $(srcdir)/$$l/$$f $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l; \
+		if test -f $(builddir)/$$l/$$page; then \
+		    echo "$(INSTALL_DATA) $(builddir)/$$l/$$page $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l"; \
+			    $(INSTALL_DATA) $(builddir)/$$l/$$page $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l; \
+		elif test -f $(srcdir)/$$l/$$page; then \
+		    echo "$(INSTALL_DATA) $(srcdir)/$$l/$$page $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l"; \
+			    $(INSTALL_DATA) $(srcdir)/$$l/$$page $(DESTDIR)$(DEFAULT_ERROR_DIR)/$$l; \
 		fi; \
 	    done; \
 	done; \
@@ -66,11 +66,11 @@ pre {
     font-family:sans-serif;
 }
 
-/* special event: FTP directory listing */
-#ftplisting tr.entry td.icon,td.filename,td.size,td.date {
+/* special event: FTP / Gopher directory listing */
+#dirlisting tr.entry td.icon,td.filename,td.size,td.date {
     border-bottom: groove;
 }
-#ftplisting td.size {
+#dirlisting td.size {
     width: 50px;
     text-align: right;
     padding-right: 5px;
@@ -3,13 +3,13 @@ ERR_CACHE_ACCESS_DENIED
 ERR_CACHE_MGR_ACCESS_DENIED
 ERR_CANNOT_FORWARD
 ERR_CONNECT_FAIL
+ERR_DIR_LISTING
 ERR_DNS_FAIL
 ERR_ESI
 ERR_FORWARDING_DENIED
 ERR_FTP_DISABLED
 ERR_FTP_FAILURE
 ERR_FTP_FORBIDDEN
-ERR_FTP_LISTING
 ERR_FTP_NOT_FOUND
 ERR_FTP_PUT_CREATED
 ERR_FTP_PUT_ERROR
@@ -1,7 +1,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
-<title>FTP Directory: %U</title>
+<title>Directory: %U</title>
 <style type="text/css"><!-- 
  %l
 
@@ -11,7 +11,7 @@ body
  --></style>
 </head><body>
 <div id="titles">
-<h2>FTP Directory: <a href="/">%U</a>/</h2>
+<h2>Directory: <a href="/">%U</a>/</h2>
 </div>
 <hr>
 
@@ -22,7 +22,7 @@ body
 <pre>%z</pre>
 </blockquote>
 
-<table id="ftplisting" summary="FTP Directory Listing">
+<table id="dirlisting" summary="Directory Listing">
 <tr>
 <th><a href="../"><img border="0" src="/squid-internal-static/icons/anthony-dirup.gif" alt="Parent Directory"></a></th>
 <th nowrap="nowrap"><a href="../">Parent Directory</a> (<a href="/">Root Directory</a>)</th>
@@ -233,6 +233,7 @@ main(int argc, char **argv)
         case 'd':
         case 'g':
         case 'S':
+        case 'K':
             break;
         default:
             if (strlen(argv[1]) > 2) {
@@ -261,8 +261,8 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
 
 #if 1
     debug("Empty LM pass detection: user: '%s', ours:'%s', his: '%s'"
-           "(length: %d)\n",
-           user,lmencoded_empty_pass,tmp.str,tmp.l);
+          "(length: %d)\n",
+          user,lmencoded_empty_pass,tmp.str,tmp.l);
     if (memcmp(tmp.str,lmencoded_empty_pass,ENCODED_PASS_LEN)==0) {
         fprintf(stderr,"Empty LM password supplied for user %s\\%s. "
                 "No-auth\n",domain,user);
@@ -273,8 +273,8 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
     tmp = ntlm_fetch_string ((char *) auth, auth_length, &auth->ntresponse);
     if (tmp.str != NULL && tmp.l != 0) {
         debug("Empty NT pass detection: user: '%s', ours:'%s', his: '%s'"
-               "(length: %d)\n",
-               user,ntencoded_empty_pass,tmp.str,tmp.l);
+              "(length: %d)\n",
+              user,ntencoded_empty_pass,tmp.str,tmp.l);
         if (memcmp(tmp.str,lmencoded_empty_pass,ENCODED_PASS_LEN)==0) {
             fprintf(stderr,"Empty NT password supplied for user %s\\%s. "
                     "No-auth\n",domain,user);
@@ -86,8 +86,7 @@ main(int argc, char *argv[])
         if ((p = strchr(buf, '\n')) != NULL) {
             *p = '\0';		/* strip \n */
             buflen = p - buf;   /* length is known already */
-        }
-        else
+        } else
             buflen = strlen(buf);   /* keep this so we only scan the buffer for \0 once per loop */
 
         debug("Got %d bytes '%s' from Squid\n", buflen, buf);
@@ -119,7 +119,7 @@ struct RefCountable_ {
     /* Not private, to allow class hierarchies */
     void RefCountReference() const {
 #if REFCOUNT_DEBUG
-       old_debug(0,1)("Incrementing this %p from count %u\n",this,count_);
+        old_debug(0,1)("Incrementing this %p from count %u\n",this,count_);
 #endif
 
         ++count_;
@@ -73,7 +73,7 @@ httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p)
     debugs(57, 9, "packing sline " << sline << " using " << p << ":");
     debugs(57, 9, "FORMAT=" << HttpStatusLineFormat );
     debugs(57, 9, "HTTP/" << sline->version.major << "." << sline->version.minor <<
-                 " " << sline->status << " " << (sline->reason ? sline->reason : httpStatusString(sline->status)) );
+           " " << sline->status << " " << (sline->reason ? sline->reason : httpStatusString(sline->status)) );
     packerPrintf(p, HttpStatusLineFormat, sline->version.major,
                  sline->version.minor, sline->status, httpStatusLineReason(sline));
 }
@@ -830,9 +830,9 @@ install-data-local: install-sysconfDATA install-dataDATA
 	$(INSTALL_DATA) squid.conf.documented $(DESTDIR)$(DEFAULT_CONFIG_FILE).documented; \
 	$(mkinstalldirs) $(DESTDIR)$(DEFAULT_LOG_PREFIX)
 
-uninstall-local:
-	@$(SHELL) $(top_srcdir)/scripts/remove-cfg.sh "$(RM)" $(DESTDIR)$(DEFAULT_MIME_TABLE)
-	@$(SHELL) $(top_srcdir)/scripts/remove-cfg.sh "$(RM)" $(DESTDIR)$(DEFAULT_CONFIG_FILE)
+uninstall-local: squid.conf.default
+	@$(SHELL) $(top_srcdir)/scripts/remove-cfg.sh "$(RM)" $(DESTDIR)$(DEFAULT_MIME_TABLE) $(srcdir)/mime.conf.default
+	@$(SHELL) $(top_srcdir)/scripts/remove-cfg.sh "$(RM)" $(DESTDIR)$(DEFAULT_CONFIG_FILE) squid.conf.default
 
 CLEANFILES += cf.data squid.conf.default squid.conf.documented \
 	DiskIO/DiskIOModules_gen.cc \
@@ -24,6 +24,7 @@ struct http_port_list {
     unsigned int allow_direct:1;       /**< Allow direct forwarding in accelerator mode */
     unsigned int vhost:1;              /**< uses host header */
     unsigned int sslBump:1;            /**< intercepts CONNECT requests */
+    unsigned int ignore_cc:1;          /**< Ignore request Cache-Control directives */
 
     int vport;                 /* virtual port support, -1 for dynamic, >0 static*/
     bool connection_auth_disabled;     /* Don't support connection oriented auth */
@@ -437,7 +437,7 @@ aclMatchArp(SplayNode<acl_arp_data *> **dataptr, IpAddress &c)
         return (0 == splayLastResult);
     }
 
-#elif defined(_SQUID_FREEBSD_) || defined(_SQUID_NETBSD_) || defined(_SQUID_OPENBSD_) || defined(_SQUID_DRAGONFLY_)
+#elif defined(_SQUID_FREEBSD_) || defined(_SQUID_NETBSD_) || defined(_SQUID_OPENBSD_) || defined(_SQUID_DRAGONFLY_) || defined(_SQUID_KFREEBSD_)
 
     SplayNode<acl_arp_data *> **Top = dataptr;
 
@@ -216,21 +216,21 @@ acl_ip_data::DecodeMask(const char *asc, IpAddress &mask, int ctype)
     /* dotted notation */
     /* assignment returns true if asc contained an IP address as text */
     if ((mask = asc)) {
-#if USE_IPV6
         /* HACK: IPv4 netmasks don't cleanly map to IPv6 masks. */
-        debugs(28, DBG_IMPORTANT, "WARNING: Netmasks are deprecated. Please use CIDR masks instead.");
+        debugs(28, DBG_CRITICAL, "WARNING: Netmasks are deprecated. Please use CIDR masks instead.");
         if (mask.IsIPv4()) {
             /* locate what CIDR mask was _probably_ meant to be in its native protocol format. */
             /* this will completely crap out with a security fail-open if the admin is playing mask tricks */
             /* however, thats their fault, and we do warn. see bug 2601 for the effects if we don't do this. */
             unsigned int m = mask.GetCIDR();
+#if USE_IPV6
             debugs(28, DBG_CRITICAL, "WARNING: IPv4 netmasks are particularly nasty when used to compare IPv6 to IPv4 ranges.");
-            debugs(28, DBG_CRITICAL, "WARNING: For now we assume you meant to write /" << m);
+#endif
+            debugs(28, DBG_CRITICAL, "WARNING: For now we will assume you meant to write /" << m);
             /* reset the mask completely, and crop to the CIDR boundary back properly. */
             mask.SetNoAddr();
             return mask.ApplyMask(m,AF_INET);
         }
-#endif /* USE_IPV6 */
         return true;
     }
 
@@ -303,18 +303,18 @@ acl_ip_data::FactoryParse(const char *t)
 
 // IPv6
     } else if (sscanf(t, SCAN_ACL1_6, addr1, addr2, mask) == 3) {
-        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN1-v4: " << SCAN_ACL1_6);
+        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN1-v6: " << SCAN_ACL1_6);
         iptype=AF_INET6;
     } else if (sscanf(t, SCAN_ACL2_6, addr1, addr2, &c) >= 2) {
-        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN2-v4: " << SCAN_ACL2_6);
+        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN2-v6: " << SCAN_ACL2_6);
         mask[0] = '\0';
         iptype=AF_INET6;
     } else if (sscanf(t, SCAN_ACL3_6, addr1, mask) == 2) {
-        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN3-v4: " << SCAN_ACL3_6);
+        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN3-v6: " << SCAN_ACL3_6);
         addr2[0] = '\0';
         iptype=AF_INET6;
     } else if (sscanf(t, SCAN_ACL4_6, addr1, mask) == 2) {
-        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN4-v4: " << SCAN_ACL4_6);
+        debugs(28, 9, "aclIpParseIpData: '" << t << "' matched: SCAN4-v6: " << SCAN_ACL4_6);
         addr2[0] = '\0';
         iptype=AF_INET6;
 
@@ -146,7 +146,8 @@ ProxyAuthLookup::checkForAsync(ACLChecklist *cl)const
     assert(checklist->auth_user_request != NULL);
     auth_user_request = checklist->auth_user_request;
 
-    assert(authenticateValidateUser(auth_user_request));
+    int validated = authenticateValidateUser(auth_user_request);
+    assert(validated);
     auth_user_request->start(LookupDone, checklist);
 }
 
@@ -1036,7 +1036,7 @@ authDigestUserLinkNonce(DigestUser * user, digest_nonce_h * nonce)
     authDigestNonceLink(nonce);
 
     /* ping this nonce to this auth user */
-    assert((nonce->user == NULL) || (nonce->user = user));
+    assert((nonce->user == NULL) || (nonce->user == user));
 
     /* we don't lock this reference because removing the user removes the
      * hash too. Of course if that changes we're stuffed so read the code huh?
@@ -3046,6 +3046,14 @@ parse_http_port_option(http_port_list * s, char *token)
         s->accel = 1;
     } else if (strcmp(token, "allow-direct") == 0) {
         s->allow_direct = 1;
+    } else if (strcmp(token, "ignore-cc") == 0) {
+        s->ignore_cc = 1;
+#if !HTTP_VIOLATIONS
+        if (!s->accel) {
+            debugs(3, DBG_CRITICAL, "FATAL: ignore-cc is only valid in accelerator mode");
+            self_destruct();
+        }
+#endif
     } else if (strcmp(token, "no-connection-auth") == 0) {
         s->connection_auth_disabled = true;
     } else if (strcmp(token, "connection-auth=off") == 0) {
@@ -3090,6 +3098,11 @@ parse_http_port_option(http_port_list * s, char *token)
         debugs(3, DBG_IMPORTANT, "Starting IP Spoofing on port " << s->s);
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (IP spoofing enabled)");
 
+        if (!IpInterceptor.ProbeForTproxy(s->s)) {
+            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: TPROXY support in the system does not work.");
+            self_destruct();
+        }
+
     } else if (strcmp(token, "ipv4") == 0) {
 #if USE_IPV6
         if ( !s->s.SetIPv4() ) {
@@ -336,7 +336,7 @@ extern cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, in
 
 /**
  * \ingroup CBDATAAPI
- * 
+ *
  * This needs to be defined LAST in teh class definition. It plays with private/public states in C++.
  */
 #define CBDATA_CLASS2(type)	\
@@ -829,8 +829,8 @@ DOC_START
 	opposite of the last line in the list.  If the last line was
 	deny, the default is allow.  Conversely, if the last line
 	is allow, the default will be deny.  For these reasons, it is a
-	good idea to have an "deny all" or "allow all" entry at the end
-	of your access lists to avoid potential confusion.
+	good idea to have an "deny all" entry at the end of your access
+	lists to avoid potential confusion.
 
 	This clause supports both fast and slow acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
@@ -1113,6 +1113,11 @@ DOC_START
 	   protocol=	Protocol to reconstruct accelerated requests with.
 			Defaults to http.
 
+	   ignore-cc	Ignore request Cache-Control headers.
+
+	   		Warning: This option violates HTTP specifications if
+			used in non-accelerator setups.
+
 	   connection-auth[=on|off]
 	                use connection-auth=off to tell Squid to prevent 
 	                forwarding Microsoft connection oriented authentication
@@ -2370,6 +2370,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     }
 
     request->flags.accelerated = http->flags.accel;
+    request->flags.ignore_cc = conn->port->ignore_cc;
     request->flags.no_direct = request->flags.accelerated ? !conn->port->allow_direct : 0;
 
     /** \par
@@ -368,7 +368,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
 
         // if client sent IMS
 
-        if (http->request->flags.ims) {
+        if (http->request->flags.ims && !old_entry->modifiedSince(http->request)) {
             // forward the 304 from origin
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and forwarding 304 to client");
             sendClientUpstreamResponse();
@@ -747,7 +747,7 @@ clientCheckPinning(ClientHttpRequest * http)
      * a client connection
      */
     if (!http_conn)
-	return;
+        return;
 
     request->flags.connection_auth_disabled = http_conn->port->connection_auth_disabled;
     if (!request->flags.connection_auth_disabled) {
@@ -803,55 +803,47 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     HttpRequest *request = http->request;
     HttpHeader *req_hdr = &request->header;
     int no_cache = 0;
-#if !(USE_SQUID_ESI) || defined(USE_USERAGENT_LOG) || defined(USE_REFERER_LOG)
-
     const char *str;
-#endif
 
     request->imslen = -1;
     request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
         request->flags.ims = 1;
 
-#if USE_SQUID_ESI
-    /*
-     * We ignore Cache-Control as per the Edge Architecture Section 3. See
-     * www.esi.org for more information.
-     */
-#else
-
-    if (req_hdr->has(HDR_PRAGMA)) {
-        String s = req_hdr->getList(HDR_PRAGMA);
+    if (!request->flags.ignore_cc) {
+        if (req_hdr->has(HDR_PRAGMA)) {
+            String s = req_hdr->getList(HDR_PRAGMA);
 
-        if (strListIsMember(&s, "no-cache", ','))
-            no_cache++;
+            if (strListIsMember(&s, "no-cache", ','))
+                no_cache++;
 
-        s.clean();
-    }
+            s.clean();
+        }
 
-    if (request->cache_control)
-        if (EBIT_TEST(request->cache_control->mask, CC_NO_CACHE))
-            no_cache++;
+        if (request->cache_control)
+            if (EBIT_TEST(request->cache_control->mask, CC_NO_CACHE))
+                no_cache++;
 
-    /*
-    * Work around for supporting the Reload button in IE browsers when Squid
-    * is used as an accelerator or transparent proxy, by turning accelerated
-    * IMS request to no-cache requests. Now knows about IE 5.5 fix (is
-    * actually only fixed in SP1, but we can't tell whether we are talking to
-    * SP1 or not so all 5.5 versions are treated 'normally').
-    */
-    if (Config.onoff.ie_refresh) {
-        if (http->flags.accel && request->flags.ims) {
-            if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
-                if (strstr(str, "MSIE 5.01") != NULL)
-                    no_cache++;
-                else if (strstr(str, "MSIE 5.0") != NULL)
-                    no_cache++;
-                else if (strstr(str, "MSIE 4.") != NULL)
-                    no_cache++;
-                else if (strstr(str, "MSIE 3.") != NULL)
-                    no_cache++;
+        /*
+        * Work around for supporting the Reload button in IE browsers when Squid
+        * is used as an accelerator or transparent proxy, by turning accelerated
+        * IMS request to no-cache requests. Now knows about IE 5.5 fix (is
+        * actually only fixed in SP1, but we can't tell whether we are talking to
+        * SP1 or not so all 5.5 versions are treated 'normally').
+        */
+        if (Config.onoff.ie_refresh) {
+            if (http->flags.accel && request->flags.ims) {
+                if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
+                    if (strstr(str, "MSIE 5.01") != NULL)
+                        no_cache++;
+                    else if (strstr(str, "MSIE 5.0") != NULL)
+                        no_cache++;
+                    else if (strstr(str, "MSIE 4.") != NULL)
+                        no_cache++;
+                    else if (strstr(str, "MSIE 3.") != NULL)
+                        no_cache++;
+                }
             }
         }
     }
@@ -860,7 +852,6 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         no_cache++;
     }
 
-#endif
     if (no_cache) {
 #if HTTP_VIOLATIONS
 
@@ -1383,7 +1374,8 @@ ClientHttpRequest::noteAdaptationAnswer(HttpMsg *msg)
         // subscribe to receive reply body
         if (new_rep->body_pipe != NULL) {
             adaptedBodySource = new_rep->body_pipe;
-            assert(adaptedBodySource->setConsumerIfNotLate(this));
+            int consumer_ok = adaptedBodySource->setConsumerIfNotLate(this);
+            assert(consumer_ok);
         }
 
         clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
@@ -597,8 +597,10 @@ commBind(int s, struct addrinfo &inaddr)
 {
     statCounter.syscalls.sock.binds++;
 
-    if (bind(s, inaddr.ai_addr, inaddr.ai_addrlen) == 0)
+    if (bind(s, inaddr.ai_addr, inaddr.ai_addrlen) == 0) {
+        debugs(50, 6, "commBind: bind socket FD " << s << " to " << fd_table[s].local_addr);
         return COMM_OK;
+    }
 
     debugs(50, 0, "commBind: Cannot bind socket FD " << s << " to " << fd_table[s].local_addr << ": " << xstrerror());
 
@@ -628,6 +630,9 @@ comm_open_listener(int sock_type,
 {
     int sock = -1;
 
+    /* all listener sockets require bind() */
+    flags |= COMM_DOBIND;
+
     /* attempt native enabled port. */
     sock = comm_openex(sock_type, proto, addr, flags, 0, note);
 
@@ -790,10 +795,8 @@ comm_openex(int sock_type,
 
     if (addr.GetPort() > (u_short) 0) {
 #ifdef _SQUID_MSWIN_
-
         if (sock_type != SOCK_DGRAM)
 #endif
-
             commSetNoLinger(new_socket);
 
         if (opt_reuseaddr)
@@ -805,7 +808,12 @@ comm_openex(int sock_type,
         comm_set_transparent(new_socket);
     }
 
-    if (!addr.IsNoAddr()) {
+    if ( (flags & COMM_DOBIND) || addr.GetPort() > 0 || !addr.IsAnyAddr() ) {
+        if ( !(flags & COMM_DOBIND) && addr.IsAnyAddr() )
+            debugs(5,1,"WARNING: Squid is attempting to bind() port " << addr << " without being a listener.");
+        if ( addr.IsNoAddr() )
+            debugs(5,0,"CRITICAL: Squid is attempting to bind() port " << addr << "!!");
+
         if (commBind(new_socket, *AI) != COMM_OK) {
             comm_close(new_socket);
             addr.FreeAddrInfo(AI);
@@ -25,6 +25,7 @@ typedef enum {
 #if USE_IPV6
     COMM_ERR_PROTOCOL = -11, /* IPv4 or IPv6 cannot be used on the fd socket */
 #endif
+    COMM_ERR__END__ = -999999 /* Dummy entry to make syntax valid (comma on line above), do not use. New entries added above */
 } comm_err_t;
 
 class DnsLookupDetails;
@@ -66,6 +66,7 @@
 #define COMM_NOCLOEXEC		0x02
 #define COMM_REUSEADDR		0x04
 #define COMM_TRANSPARENT	0x08
+#define COMM_DOBIND		0x10
 
 #define safe_free(x)	if (x) { xxfree(x); x = NULL; }
 
@@ -37,6 +37,7 @@
 #include "errorpage.h"
 #include "Store.h"
 #include "HttpRequest.h"
+#include "HttpReply.h"
 #include "comm.h"
 #if DELAY_POOLS
 #include "DelayPools.h"
@@ -138,7 +139,6 @@ typedef struct gopher_ds {
 } GopherStateData;
 
 static PF gopherStateFree;
-static void gopher_mime_content(MemBuf * mb, const char *name, const char *def);
 static void gopherMimeCreate(GopherStateData *);
 static void gopher_request_parse(const HttpRequest * req,
                                  char *type_id,
@@ -178,41 +178,16 @@ gopherStateFree(int fdnotused, void *data)
     cbdataFree(gopherState);
 }
 
-
-/**
- \ingroup ServerProtocolGopherInternal
- * Figure out content type from file extension
- */
-static void
-gopher_mime_content(MemBuf * mb, const char *name, const char *def_ctype)
-{
-    char *ctype = mimeGetContentType(name);
-    char *cenc = mimeGetContentEncoding(name);
-
-    if (cenc)
-        mb->Printf("Content-Encoding: %s\r\n", cenc);
-
-    mb->Printf("Content-Type: %s\r\n",
-               ctype ? ctype : def_ctype);
-}
-
-
-
 /**
  \ingroup ServerProtocolGopherInternal
  * Create MIME Header for Gopher Data
  */
 static void
 gopherMimeCreate(GopherStateData * gopherState)
 {
-    MemBuf mb;
-
-    mb.init();
-
-    mb.Printf("HTTP/1.0 200 OK Gatewaying\r\n"
-              "Server: Squid/%s\r\n"
-              "Date: %s\r\n",
-              version_string, mkrfc1123(squid_curtime));
+    StoreEntry *entry = gopherState->entry;
+    const char *mime_type = NULL;
+    const char *mime_enc = NULL;
 
     switch (gopherState->type_id) {
 
@@ -225,25 +200,25 @@ gopherMimeCreate(GopherStateData * gopherState)
     case GOPHER_WWW:
 
     case GOPHER_CSO:
-        mb.Printf("Content-Type: text/html\r\n");
+        mime_type = "text/html";
         break;
 
     case GOPHER_GIF:
 
     case GOPHER_IMAGE:
 
     case GOPHER_PLUS_IMAGE:
-        mb.Printf("Content-Type: image/gif\r\n");
+        mime_type = "image/gif";
         break;
 
     case GOPHER_SOUND:
 
     case GOPHER_PLUS_SOUND:
-        mb.Printf("Content-Type: audio/basic\r\n");
+        mime_type = "audio/basic";
         break;
 
     case GOPHER_PLUS_MOVIE:
-        mb.Printf("Content-Type: video/mpeg\r\n");
+        mime_type = "video/mpeg";
         break;
 
     case GOPHER_MACBINHEX:
@@ -254,20 +229,33 @@ gopherMimeCreate(GopherStateData * gopherState)
 
     case GOPHER_BIN:
         /* Rightnow We have no idea what it is. */
-        gopher_mime_content(&mb, gopherState->request, def_gopher_bin);
+        mime_enc = mimeGetContentEncoding(gopherState->request);
+        mime_type = mimeGetContentType(gopherState->request);
+        if (!mime_type)
+            mime_type = def_gopher_bin;
         break;
 
     case GOPHER_FILE:
 
     default:
-        gopher_mime_content(&mb, gopherState->request, def_gopher_text);
+        mime_enc = mimeGetContentEncoding(gopherState->request);
+        mime_type = mimeGetContentType(gopherState->request);
+        if (!mime_type)
+            mime_type = def_gopher_text;
         break;
     }
 
-    mb.Printf("\r\n");
-    EBIT_CLR(gopherState->entry->flags, ENTRY_FWD_HDR_WAIT);
-    gopherState->entry->append(mb.buf, mb.size);
-    mb.clean();
+    assert(entry->isEmpty());
+    EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
+
+    HttpReply *reply = new HttpReply;
+    entry->buffer();
+    HttpVersion version(1, 0);
+    reply->setHeaders(version, HTTP_OK, "Gatewaying", mime_type, -1, -1, -2);
+    if (mime_enc)
+        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+
+    entry->replaceHttpReply(reply);
 }
 
 /**
@@ -1460,58 +1460,58 @@ httpFixupAuthentication(HttpRequest * request, HttpRequest * orig_request, const
 
     /* Nothing to do unless we are forwarding to a peer */
     if (!request->flags.proxying)
-	return;
+        return;
 
     /* Needs to be explicitly enabled */
     if (!orig_request->peer_login)
-	return;
+        return;
 
     /* Maybe already dealt with? */
     if (hdr_out->has(header))
-	return;
+        return;
 
     /* Nothing to do here for PASSTHRU */
     if (strcmp(orig_request->peer_login, "PASSTHRU") == 0)
-	return;
+        return;
 
     /* PROXYPASS is a special case, single-signon to servers with the proxy password (basic only) */
     if (flags.originpeer && strcmp(orig_request->peer_login, "PROXYPASS") == 0 && hdr_in->has(HDR_PROXY_AUTHORIZATION)) {
-	const char *auth = hdr_in->getStr(HDR_PROXY_AUTHORIZATION);
+        const char *auth = hdr_in->getStr(HDR_PROXY_AUTHORIZATION);
 
-	if (auth && strncasecmp(auth, "basic ", 6) == 0) {
-	    hdr_out->putStr(header, auth);
-	    return;
-	}
+        if (auth && strncasecmp(auth, "basic ", 6) == 0) {
+            hdr_out->putStr(header, auth);
+            return;
+        }
     }
 
     /* Special mode to pass the username to the upstream cache */
     if (*orig_request->peer_login == '*') {
-	char loginbuf[256];
-	const char *username = "-";
+        char loginbuf[256];
+        const char *username = "-";
 
-	if (orig_request->extacl_user.size())
-	    username = orig_request->extacl_user.termedBuf();
-	else if (orig_request->auth_user_request)
-	    username = orig_request->auth_user_request->username();
+        if (orig_request->extacl_user.size())
+            username = orig_request->extacl_user.termedBuf();
+        else if (orig_request->auth_user_request)
+            username = orig_request->auth_user_request->username();
 
-	snprintf(loginbuf, sizeof(loginbuf), "%s%s", username, orig_request->peer_login + 1);
+        snprintf(loginbuf, sizeof(loginbuf), "%s%s", username, orig_request->peer_login + 1);
 
-	httpHeaderPutStrf(hdr_out, header, "Basic %s",
-			  base64_encode(loginbuf));
-	return;
+        httpHeaderPutStrf(hdr_out, header, "Basic %s",
+                          base64_encode(loginbuf));
+        return;
     }
 
     /* external_acl provided credentials */
     if (orig_request->extacl_user.size() && orig_request->extacl_passwd.size() &&
-	    (strcmp(orig_request->peer_login, "PASS") == 0 ||
-	     strcmp(orig_request->peer_login, "PROXYPASS") == 0)) {
-	char loginbuf[256];
-	snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
-		 SQUIDSTRINGPRINT(orig_request->extacl_user),
-		 SQUIDSTRINGPRINT(orig_request->extacl_passwd));
-	httpHeaderPutStrf(hdr_out, header, "Basic %s",
-			  base64_encode(loginbuf));
-	return;
+            (strcmp(orig_request->peer_login, "PASS") == 0 ||
+             strcmp(orig_request->peer_login, "PROXYPASS") == 0)) {
+        char loginbuf[256];
+        snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
+                 SQUIDSTRINGPRINT(orig_request->extacl_user),
+                 SQUIDSTRINGPRINT(orig_request->extacl_passwd));
+        httpHeaderPutStrf(hdr_out, header, "Basic %s",
+                          base64_encode(loginbuf));
+        return;
     }
 
     /* Kerberos login to peer */
@@ -1531,7 +1531,7 @@ httpFixupAuthentication(HttpRequest * request, HttpRequest * orig_request, const
 #endif /* HAVE_KRB5 && HAVE_GSSAPI */
 
     httpHeaderPutStrf(hdr_out, header, "Basic %s",
-		      base64_encode(orig_request->peer_login));
+                      base64_encode(orig_request->peer_login));
     return;
 }
 
@@ -1592,7 +1592,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     }
 
 #if USE_SQUID_ESI
-    {
+    if (orig_request->flags.accelerated) {
         /* Append Surrogate-Capabilities */
         String strSurrogate (hdr_in->getList(HDR_SURROGATE_CAPABILITY));
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0 ESI/1.0\"",
@@ -1741,9 +1741,9 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          * authentication forwarding is explicitly enabled
          */
         if (!flags.originpeer && flags.proxying && orig_request->peer_login &&
-		(strcmp(orig_request->peer_login, "PASS") == 0 ||
-		 strcmp(orig_request->peer_login, "PROXYPASS") == 0 ||
-		 strcmp(orig_request->peer_login, "PASSTHRU") == 0)) {
+                (strcmp(orig_request->peer_login, "PASS") == 0 ||
+                 strcmp(orig_request->peer_login, "PROXYPASS") == 0 ||
+                 strcmp(orig_request->peer_login, "PASSTHRU") == 0)) {
             hdr_out->addEntry(e->clone());
         }
         break;
@@ -80,7 +80,7 @@ Ident::IdentConfig Ident::TheConfig;
 
 /**** PRIVATE FUNCTIONS ****/
 
-static void
+void
 Ident::identCallback(IdentStateData * state, char *result)
 {
     IdentClient *client;
@@ -99,7 +99,7 @@ Ident::identCallback(IdentStateData * state, char *result)
     }
 }
 
-static void
+void
 Ident::Close(int fdnotused, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
@@ -110,7 +110,7 @@ Ident::Close(int fdnotused, void *data)
     cbdataFree(state);
 }
 
-static void
+void
 Ident::Timeout(int fd, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
@@ -119,7 +119,7 @@ Ident::Timeout(int fd, void *data)
     comm_close(fd);
 }
 
-static void
+void
 Ident::ConnectDone(int fd, const DnsLookupDetails &, comm_err_t status, int xerrno, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
@@ -155,7 +155,7 @@ Ident::ConnectDone(int fd, const DnsLookupDetails &, comm_err_t status, int xerr
     commSetTimeout(fd, Ident::TheConfig.timeout, Ident::Timeout, state);
 }
 
-static void
+void
 Ident::ReadReply(int fd, char *buf, size_t len, comm_err_t flag, int xerrno, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
@@ -194,7 +194,7 @@ Ident::ReadReply(int fd, char *buf, size_t len, comm_err_t flag, int xerrno, voi
     comm_close(fd);
 }
 
-static void
+void
 Ident::ClientAdd(IdentStateData * state, IDCB * callback, void *callback_data)
 {
     IdentClient *c = (IdentClient *)xcalloc(1, sizeof(*c));
@@ -369,9 +369,6 @@ IpIntercept::NatLookup(int fd, const IpAddress &me, const IpAddress &peer, IpAdd
     client = me;
     dst = peer;
 
-    if ( !me.IsIPv4()   ) return -1;
-    if ( !peer.IsIPv4() ) return -1;
-
 #if 0
     // Crop interception errors down to one per minute.
     int silent = (squid_curtime - last_reported > 60 ? 0 : 1);
@@ -388,6 +385,10 @@ IpIntercept::NatLookup(int fd, const IpAddress &me, const IpAddress &peer, IpAdd
         if ( NetfilterTransparent(fd, me, dst, silent) == 0) return 0;
     }
 
+    /* NAT is only available in IPv4 */
+    if ( !me.IsIPv4()   ) return -1;
+    if ( !peer.IsIPv4() ) return -1;
+
     if (intercept_active) {
         /* NAT methods that use sock-opts to return client address */
         if ( NetfilterInterception(fd, me, client, silent) == 0) return 0;
@@ -438,3 +439,85 @@ IpIntercept::SetTproxy2OutgoingAddr(int fd, const IpAddress &src)
     return 0;
 }
 #endif
+
+bool
+IpIntercept::ProbeForTproxy(IpAddress &test)
+{
+    debugs(3, 3, "Detect TPROXY support on port " << test);
+#if LINUX_TPROXY2
+
+#if USE_IPV6
+    /* TPROXYv2 is not IPv6 capable. Force wildcard sockets to IPv4. Die on IPv6 IPs */
+    debugs(3, DBG_IMPORTANT, "Disabling IPv6 on port " << test << " (TPROXYv2 interception enabled)");
+    if ( test.IsIPv6() && !test.SetIPv4() ) {
+        debugs(3, DBG_CRITICAL, "IPv6 requires TPROXYv4 support. You only have TPROXYv2 for " << test );
+        return false;
+    }
+#endif /* USE_IPV6 */
+    return true;
+
+#else /* not LINUX_TPROXY2 */
+
+#if defined(IP_TRANSPARENT)
+
+    int tos = 1;
+    int tmp_sock = -1;
+
+#if USE_IPV6
+    /* Probe to see if the Kernel TPROXY support is IPv6-enabled */
+    if (test.IsIPv6()) {
+        debugs(3, 3, "...Probing for IPv6 TPROXY support.");
+
+        struct sockaddr_in6 tmp_ip6;
+        IpAddress tmp = "::2";
+        tmp.SetPort(0);
+        tmp.GetSockAddr(tmp_ip6);
+
+        if ( (tmp_sock = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
+                setsockopt(tmp_sock, SOL_IP, IP_TRANSPARENT, (char *)&tos, sizeof(int)) == 0 &&
+                bind(tmp_sock, (struct sockaddr*)&tmp_ip6, sizeof(struct sockaddr_in6)) == 0 ) {
+
+            debugs(3, 3, "IPv6 TPROXY support detected. Using.");
+            close(tmp_sock);
+            return true;
+        }
+        if (tmp_sock >= 0) {
+            close(tmp_sock);
+            tmp_sock = -1;
+        }
+    }
+
+    if ( test.IsIPv6() && !test.SetIPv4() ) {
+        debugs(3, DBG_CRITICAL, "TPROXY lacks IPv6 support for " << test );
+        return false;
+    }
+#endif
+
+    /* Probe to see if the Kernel TPROXY support is IPv4-enabled (aka present) */
+    if (test.IsIPv4()) {
+        debugs(3, 3, "...Probing for IPv4 TPROXY support.");
+
+        struct sockaddr_in tmp_ip4;
+        IpAddress tmp = "127.0.0.2";
+        tmp.SetPort(0);
+        tmp.GetSockAddr(tmp_ip4);
+
+        if ( (tmp_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
+                setsockopt(tmp_sock, SOL_IP, IP_TRANSPARENT, (char *)&tos, sizeof(int)) == 0 &&
+                bind(tmp_sock, (struct sockaddr*)&tmp_ip4, sizeof(struct sockaddr_in)) == 0 ) {
+
+            debugs(3, 3, "IPv4 TPROXY support detected. Using.");
+            close(tmp_sock);
+            return true;
+        }
+        if (tmp_sock >= 0) {
+            close(tmp_sock);
+        }
+    }
+
+#else /* undefined IP_TRANSPARENT */
+    debugs(3, 3, "setsockopt(IP_TRANSPARENT) not supported on this platform. Disabling TPROXYv4.");
+#endif
+#endif /* LINUX_TPROXY2 */
+    return false;
+}
@@ -35,6 +35,17 @@ class IpIntercept
     int SetTproxy2OutgoingAddr(int fd, const IpAddress &src);
 #endif
 
+    /**
+     * Test system networking calls for TPROXY support.
+     * Detects IPv6 and IPv4 level of support matches the address being listened on
+     * and if the compiled v2/v4 is usable as far down as a bind()ing.
+     *
+     * \param test    Address set on the http(s)_port being checked.
+     * \retval true   TPROXY is available.
+     * \retval false  TPROXY is not available.
+     */
+    bool ProbeForTproxy(IpAddress &test);
+
     /**
      \retval 0	Full transparency is disabled.
      \retval 1  Full transparency is enabled and active.
@@ -1308,7 +1308,8 @@ ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
         ia->cur = 0;
     }
 
-    debugs(14, 3, "ipcacheCycleAddr: " << name << " now at " << ia->in_addrs[ia->cur] << " (" << ia->cur << " of " << ia->count << ")");
+    /* NP: zero-based so we increase the human-readable number of our position */
+    debugs(14, 3, "ipcacheCycleAddr: " << name << " now at " << ia->in_addrs[ia->cur] << " (" << (ia->cur+1) << " of " << ia->count << ")");
 }
 
 /**
@@ -220,8 +220,8 @@ logfileRotate(Logfile * lf)
 void
 logfileWrite(Logfile * lf, void *buf, size_t len)
 {
-   /* AYJ: this write gets called once per line? Squid-2 did it in lineEnd which we dont have. */
-   lf->sequence_number++;
+    /* AYJ: this write gets called once per line? Squid-2 did it in lineEnd which we dont have. */
+    lf->sequence_number++;
 
 #if HAVE_SYSLOG
 
@@ -29,8 +29,7 @@
 
 #if HAVE_KRB5 && HAVE_GSSAPI
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 #if HAVE_PROFILE_H
@@ -69,479 +68,472 @@ extern "C"
 #elif  !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERROR_MESSAGE
 #define error_message(code) krb5_get_error_message(kparam.context,code)
 #elif !HAVE_ERROR_MESSAGE
-static char err_code[17];
-const char *KRB5_CALLCONV
-error_message(long code)
-{
-    snprintf(err_code,16,"%ld",code);
-    return err_code;
-}
+    static char err_code[17];
+    const char *KRB5_CALLCONV
+    error_message(long code) {
+        snprintf(err_code,16,"%ld",code);
+        return err_code;
+    }
 #endif
 
 #ifndef gss_mech_spnego
     static gss_OID_desc _gss_mech_spnego =
-	{ 6, (void *) "\x2b\x06\x01\x05\x05\x02" };
+        { 6, (void *) "\x2b\x06\x01\x05\x05\x02" };
     gss_OID gss_mech_spnego = &_gss_mech_spnego;
 #endif
 
 #if HAVE_NAS_KERBEROS
 #include <ibm_svc/krb5_svc.h>
-    const char *KRB5_CALLCONV error_message(long code)
-    {
-	char *msg = NULL;
-	krb5_svc_get_msg(code, &msg);
-	return msg;
+    const char *KRB5_CALLCONV error_message(long code) {
+        char *msg = NULL;
+        krb5_svc_get_msg(code, &msg);
+        return msg;
     }
 #endif
 
-/*
- * Kerberos context and cache structure
- * Caches authentication details to reduce
- * number of authentication requests to kdc
- */
-    static struct kstruct
-    {
-	krb5_context context;
-	krb5_ccache cc;
+    /*
+     * Kerberos context and cache structure
+     * Caches authentication details to reduce
+     * number of authentication requests to kdc
+     */
+    static struct kstruct {
+        krb5_context context;
+        krb5_ccache cc;
     } kparam = {
-    NULL, NULL};
-
-/*
- * krb5_create_cache creates a Kerberos file credential cache or a memory 
- * credential cache if supported. The initial key for the principal 
- * principal_name is extracted from the keytab keytab_filename.
- *
- * If keytab_filename is NULL the default will be used.
- * If principal_name is NULL the first working entry of the keytab will be used.
- */
+        NULL, NULL};
+
+    /*
+     * krb5_create_cache creates a Kerberos file credential cache or a memory
+     * credential cache if supported. The initial key for the principal
+     * principal_name is extracted from the keytab keytab_filename.
+     *
+     * If keytab_filename is NULL the default will be used.
+     * If principal_name is NULL the first working entry of the keytab will be used.
+     */
     int krb5_create_cache(char *keytab_filename, char *principal_name);
 
-/*
- * krb5_cleanup clears used Keberos memory
- */
+    /*
+     * krb5_cleanup clears used Keberos memory
+     */
     void krb5_cleanup(void);
 
-/*
- * check_gss_err checks for gssapi error codes, extracts the error message 
- * and prints it.
- */
+    /*
+     * check_gss_err checks for gssapi error codes, extracts the error message
+     * and prints it.
+     */
     int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-	const char *function);
+                      const char *function);
 
     int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-	const char *function)
-    {
-	if (GSS_ERROR(major_status)) {
-	    OM_uint32 maj_stat, min_stat;
-	    OM_uint32 msg_ctx = 0;
-	    gss_buffer_desc status_string;
-	    char buf[1024];
-	    size_t len;
-
-	    len = 0;
-	    msg_ctx = 0;
-	    while (!msg_ctx) {
-		/* convert major status code (GSS-API error) to text */
-		maj_stat = gss_display_status(&min_stat, major_status,
-		    GSS_C_GSS_CODE, GSS_C_NULL_OID, &msg_ctx, &status_string);
-		if (maj_stat == GSS_S_COMPLETE) {
-		    if (sizeof(buf) > len + status_string.length + 1) {
-			memcpy(buf + len, status_string.value,
-			    status_string.length);
-			len += status_string.length;
-		    }
-		    gss_release_buffer(&min_stat, &status_string);
-		    break;
-		}
-		gss_release_buffer(&min_stat, &status_string);
-	    }
-	    if (sizeof(buf) > len + 2) {
-		strcpy(buf + len, ". ");
-		len += 2;
-	    }
-	    msg_ctx = 0;
-	    while (!msg_ctx) {
-		/* convert minor status code (underlying routine error) to text */
-		maj_stat = gss_display_status(&min_stat, minor_status,
-		    GSS_C_MECH_CODE, GSS_C_NULL_OID, &msg_ctx, &status_string);
-		if (maj_stat == GSS_S_COMPLETE) {
-		    if (sizeof(buf) > len + status_string.length) {
-			memcpy(buf + len, status_string.value,
-			    status_string.length);
-			len += status_string.length;
-		    }
-		    gss_release_buffer(&min_stat, &status_string);
-		    break;
-		}
-		gss_release_buffer(&min_stat, &status_string);
-	    }
-	    debugs(11, 5, HERE << function << "failed: " << buf);
-	    return (1);
-	}
-	return (0);
+                      const char *function) {
+        if (GSS_ERROR(major_status)) {
+            OM_uint32 maj_stat, min_stat;
+            OM_uint32 msg_ctx = 0;
+            gss_buffer_desc status_string;
+            char buf[1024];
+            size_t len;
+
+            len = 0;
+            msg_ctx = 0;
+            while (!msg_ctx) {
+                /* convert major status code (GSS-API error) to text */
+                maj_stat = gss_display_status(&min_stat, major_status,
+                                              GSS_C_GSS_CODE, GSS_C_NULL_OID, &msg_ctx, &status_string);
+                if (maj_stat == GSS_S_COMPLETE) {
+                    if (sizeof(buf) > len + status_string.length + 1) {
+                        memcpy(buf + len, status_string.value,
+                               status_string.length);
+                        len += status_string.length;
+                    }
+                    gss_release_buffer(&min_stat, &status_string);
+                    break;
+                }
+                gss_release_buffer(&min_stat, &status_string);
+            }
+            if (sizeof(buf) > len + 2) {
+                strcpy(buf + len, ". ");
+                len += 2;
+            }
+            msg_ctx = 0;
+            while (!msg_ctx) {
+                /* convert minor status code (underlying routine error) to text */
+                maj_stat = gss_display_status(&min_stat, minor_status,
+                                              GSS_C_MECH_CODE, GSS_C_NULL_OID, &msg_ctx, &status_string);
+                if (maj_stat == GSS_S_COMPLETE) {
+                    if (sizeof(buf) > len + status_string.length) {
+                        memcpy(buf + len, status_string.value,
+                               status_string.length);
+                        len += status_string.length;
+                    }
+                    gss_release_buffer(&min_stat, &status_string);
+                    break;
+                }
+                gss_release_buffer(&min_stat, &status_string);
+            }
+            debugs(11, 5, HERE << function << "failed: " << buf);
+            return (1);
+        }
+        return (0);
     }
 
-    void krb5_cleanup()
-    {
-	debugs(11, 5, HERE << "Cleanup kerberos context");
-	if (kparam.context) {
-	    if (kparam.cc)
-		krb5_cc_destroy(kparam.context, kparam.cc);
-	    kparam.cc = NULL;
-	    krb5_free_context(kparam.context);
-	    kparam.context = NULL;
-	}
+    void krb5_cleanup() {
+        debugs(11, 5, HERE << "Cleanup kerberos context");
+        if (kparam.context) {
+            if (kparam.cc)
+                krb5_cc_destroy(kparam.context, kparam.cc);
+            kparam.cc = NULL;
+            krb5_free_context(kparam.context);
+            kparam.context = NULL;
+        }
     }
 
-    int krb5_create_cache(char *kf, char *pn)
-    {
+    int krb5_create_cache(char *kf, char *pn) {
 
 #define KT_PATH_MAX 256
 #define MAX_RENEW_TIME "365d"
 #define DEFAULT_SKEW (krb5_deltat) 600
 
-	static char *keytab_filename = NULL, *principal_name = NULL;
-	static krb5_keytab keytab = 0;
-	static krb5_keytab_entry entry;
-	static krb5_kt_cursor cursor;
-	static krb5_creds *creds = NULL;
+        static char *keytab_filename = NULL, *principal_name = NULL;
+        static krb5_keytab keytab = 0;
+        static krb5_keytab_entry entry;
+        static krb5_kt_cursor cursor;
+        static krb5_creds *creds = NULL;
 #if HAVE_HEIMDAL_KERBEROS
-	static krb5_creds creds2;
+        static krb5_creds creds2;
 #endif
-	static krb5_principal principal = NULL;
-	static krb5_deltat skew;
-
-	krb5_get_init_creds_opt options;
-	krb5_error_code code = 0;
-	krb5_deltat rlife;
-#if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE 
-	profile_t profile;
+        static krb5_principal principal = NULL;
+        static krb5_deltat skew;
+
+        krb5_get_init_creds_opt options;
+        krb5_error_code code = 0;
+        krb5_deltat rlife;
+#if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE
+        profile_t profile;
 #endif
 #if HAVE_HEIMDAL_KERBEROS
-	krb5_kdc_flags flags;
-	krb5_realm *client_realm;
+        krb5_kdc_flags flags;
+        krb5_realm *client_realm;
 #endif
-	char *mem_cache;
-
-      restart:
-/*
- * Check if credentials need to be renewed
- */
-	if (creds &&
-	    (creds->times.endtime - time(0) > skew) &&
-	    (creds->times.renew_till - time(0) > 2 * skew)) {
-	    if (creds->times.endtime - time(0) < 2 * skew) {
+        char *mem_cache;
+
+restart:
+        /*
+         * Check if credentials need to be renewed
+         */
+        if (creds &&
+                (creds->times.endtime - time(0) > skew) &&
+                (creds->times.renew_till - time(0) > 2 * skew)) {
+            if (creds->times.endtime - time(0) < 2 * skew) {
 #if !HAVE_HEIMDAL_KERBEROS
-		/* renew ticket */
-		code =
-		    krb5_get_renewed_creds(kparam.context, creds, principal,
-		    kparam.cc, NULL);
+                /* renew ticket */
+                code =
+                    krb5_get_renewed_creds(kparam.context, creds, principal,
+                                           kparam.cc, NULL);
 #else
-		/* renew ticket */
-		flags.i = 0;
-		flags.b.renewable = flags.b.renew = 1;
-
-		code =
-		    krb5_cc_get_principal(kparam.context, kparam.cc,
-		    &creds2.client);
-		if (code) {
-		    debugs(11, 5,
-			HERE <<
-			"Error while getting principal from credential cache : "
-			<< error_message(code));
-		    return (1);
-		}
-		client_realm = krb5_princ_realm(kparam.context, creds2.client);
-		code =
-		    krb5_make_principal(kparam.context, &creds2.server,
-		    *client_realm, KRB5_TGS_NAME, *client_realm, NULL);
-		if (code) {
-		    debugs(11, 5,
-			HERE << "Error while getting krbtgt principal : " <<
-			error_message(code));
-		    return (1);
-		}
-		code =
-		    krb5_get_kdc_cred(kparam.context, kparam.cc, flags, NULL,
-		    NULL, &creds2, &creds);
-		krb5_free_creds(kparam.context, &creds2);
+                /* renew ticket */
+                flags.i = 0;
+                flags.b.renewable = flags.b.renew = 1;
+
+                code =
+                    krb5_cc_get_principal(kparam.context, kparam.cc,
+                                          &creds2.client);
+                if (code) {
+                    debugs(11, 5,
+                           HERE <<
+                           "Error while getting principal from credential cache : "
+                           << error_message(code));
+                    return (1);
+                }
+                client_realm = krb5_princ_realm(kparam.context, creds2.client);
+                code =
+                    krb5_make_principal(kparam.context, &creds2.server,
+                                        *client_realm, KRB5_TGS_NAME, *client_realm, NULL);
+                if (code) {
+                    debugs(11, 5,
+                           HERE << "Error while getting krbtgt principal : " <<
+                           error_message(code));
+                    return (1);
+                }
+                code =
+                    krb5_get_kdc_cred(kparam.context, kparam.cc, flags, NULL,
+                                      NULL, &creds2, &creds);
+                krb5_free_creds(kparam.context, &creds2);
 #endif
-		if (code) {
-		    if (code == KRB5KRB_AP_ERR_TKT_EXPIRED) {
-			krb5_free_creds(kparam.context, creds);
-			creds = NULL;
-			/* this can happen because of clock skew */
-			goto restart;
-		    }
-		    debugs(11, 5,
-			HERE << "Error while get credentials : " <<
-			error_message(code));
-		    return (1);
-		}
-	    }
-	} else {
-	    /* reinit */
-	    if (!kparam.context) {
-		code = krb5_init_context(&kparam.context);
-		if (code) {
-		    debugs(11, 5,
-			HERE << "Error while initialising Kerberos library : "
-			<< error_message(code));
-		    return (1);
-		}
-	    }
-#if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE 
-	    code = krb5_get_profile(kparam.context, &profile);
-	    if (code) {
-		if (profile)
-		    profile_release(profile);
-		debugs(11, 5,
-		    HERE << "Error while getting profile : " <<
-		    error_message(code));
-		return (1);
-	    }
-	    code =
-		profile_get_integer(profile, "libdefaults", "clockskew", 0,
-		5 * 60, &skew);
-	    if (profile)
-		profile_release(profile);
-	    if (code) {
-		debugs(11, 5,
-		    HERE << "Error while getting clockskew : " <<
-		    error_message(code));
-		return (1);
-	    }
+                if (code) {
+                    if (code == KRB5KRB_AP_ERR_TKT_EXPIRED) {
+                        krb5_free_creds(kparam.context, creds);
+                        creds = NULL;
+                        /* this can happen because of clock skew */
+                        goto restart;
+                    }
+                    debugs(11, 5,
+                           HERE << "Error while get credentials : " <<
+                           error_message(code));
+                    return (1);
+                }
+            }
+        } else {
+            /* reinit */
+            if (!kparam.context) {
+                code = krb5_init_context(&kparam.context);
+                if (code) {
+                    debugs(11, 5,
+                           HERE << "Error while initialising Kerberos library : "
+                           << error_message(code));
+                    return (1);
+                }
+            }
+#if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE
+            code = krb5_get_profile(kparam.context, &profile);
+            if (code) {
+                if (profile)
+                    profile_release(profile);
+                debugs(11, 5,
+                       HERE << "Error while getting profile : " <<
+                       error_message(code));
+                return (1);
+            }
+            code =
+                profile_get_integer(profile, "libdefaults", "clockskew", 0,
+                                    5 * 60, &skew);
+            if (profile)
+                profile_release(profile);
+            if (code) {
+                debugs(11, 5,
+                       HERE << "Error while getting clockskew : " <<
+                       error_message(code));
+                return (1);
+            }
 #elif HAVE_KRB5_GET_MAX_TIME_SKEW && HAVE_HEIMDAL_KERBEROS
-	    skew = krb5_get_max_time_skew(kparam.context);
+            skew = krb5_get_max_time_skew(kparam.context);
 #elif HAVE_MAX_SKEW_IN_KRB5_CONTEXT && HAVE_HEIMDAL_KERBEROS
-	    skew = kparam.context->max_skew;
+            skew = kparam.context->max_skew;
 #else
-	    skew = DEFAULT_SKEW;
+            skew = DEFAULT_SKEW;
 #endif
 
-	    if (!kf) {
-		char buf[KT_PATH_MAX], *p;
-
-		krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
-		p = strchr(buf, ':');
-		if (p)
-		    p++;
-		if (keytab_filename)
-		    xfree(keytab_filename);
-		keytab_filename = xstrdup(p ? p : buf);
-	    } else {
-		keytab_filename = xstrdup(kf);
-	    }
-
-	    code = krb5_kt_resolve(kparam.context, keytab_filename, &keytab);
-	    if (code) {
-		debugs(11, 5,
-		    HERE << "Error while resolving keytab filename " <<
-		    keytab_filename << " : " << error_message(code));
-		return (1);
-	    }
-
-	    if (!pn) {
-		code = krb5_kt_start_seq_get(kparam.context, keytab, &cursor);
-		if (code) {
-		    debugs(11, 5,
-			HERE << "Error while starting keytab scan : " <<
-			error_message(code));
-		    return (1);
-		}
-		code =
-		    krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor);
-		krb5_copy_principal(kparam.context, entry.principal,
-		    &principal);
-		if (code && code != KRB5_KT_END) {
-		    debugs(11, 5,
-			HERE << "Error while scanning keytab : " <<
-			error_message(code));
-		    return (1);
-		}
-
-		code = krb5_kt_end_seq_get(kparam.context, keytab, &cursor);
-		if (code) {
-		    debugs(11, 5,
-			HERE << "Error while ending keytab scan : " <<
-			error_message(code));
-		    return (1);
-		}
+            if (!kf) {
+                char buf[KT_PATH_MAX], *p;
+
+                krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
+                p = strchr(buf, ':');
+                if (p)
+                    p++;
+                if (keytab_filename)
+                    xfree(keytab_filename);
+                keytab_filename = xstrdup(p ? p : buf);
+            } else {
+                keytab_filename = xstrdup(kf);
+            }
+
+            code = krb5_kt_resolve(kparam.context, keytab_filename, &keytab);
+            if (code) {
+                debugs(11, 5,
+                       HERE << "Error while resolving keytab filename " <<
+                       keytab_filename << " : " << error_message(code));
+                return (1);
+            }
+
+            if (!pn) {
+                code = krb5_kt_start_seq_get(kparam.context, keytab, &cursor);
+                if (code) {
+                    debugs(11, 5,
+                           HERE << "Error while starting keytab scan : " <<
+                           error_message(code));
+                    return (1);
+                }
+                code =
+                    krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor);
+                krb5_copy_principal(kparam.context, entry.principal,
+                                    &principal);
+                if (code && code != KRB5_KT_END) {
+                    debugs(11, 5,
+                           HERE << "Error while scanning keytab : " <<
+                           error_message(code));
+                    return (1);
+                }
+
+                code = krb5_kt_end_seq_get(kparam.context, keytab, &cursor);
+                if (code) {
+                    debugs(11, 5,
+                           HERE << "Error while ending keytab scan : " <<
+                           error_message(code));
+                    return (1);
+                }
 #if HAVE_HEIMDAL_KERBEROS || ( HAVE_KRB5_KT_FREE_ENTRY && HAVE_DECL_KRB5_KT_FREE_ENTRY)
-		code = krb5_kt_free_entry(kparam.context, &entry);
+                code = krb5_kt_free_entry(kparam.context, &entry);
 #else
-		code = krb5_free_keytab_entry_contents(kparam.context, &entry);
+                code = krb5_free_keytab_entry_contents(kparam.context, &entry);
 #endif
-		if (code) {
-		    debugs(11, 5,
-			HERE << "Error while freeing keytab entry : " <<
-			error_message(code));
-		    return (1);
-		}
-
-	    } else {
-		principal_name = xstrdup(pn);
-	    }
-
-	    if (!principal) {
-		code =
-		    krb5_parse_name(kparam.context, principal_name, &principal);
-		if (code) {
-		    debugs(11, 5,
-			HERE << "Error while parsing principal name " <<
-			principal_name << " : " << error_message(code));
-		    return (1);
-		}
-	    }
-
-	    creds = (krb5_creds *) xmalloc(sizeof(*creds));
-	    memset(creds, 0, sizeof(*creds));
-	    krb5_get_init_creds_opt_init(&options);
-	    code = krb5_string_to_deltat((char *) MAX_RENEW_TIME, &rlife);
-	    if (code != 0 || rlife == 0) {
-		debugs(11, 5,
-		    HERE << "Error bad lifetime value " << MAX_RENEW_TIME <<
-		    " : " << error_message(code));
-		return (1);
-	    }
-	    krb5_get_init_creds_opt_set_renew_life(&options, rlife);
-
-	    code =
-		krb5_get_init_creds_keytab(kparam.context, creds, principal,
-		keytab, 0, NULL, &options);
-	    if (code) {
-		debugs(11, 5,
-		    HERE <<
-		    "Error while initializing credentials from keytab : " <<
-		    error_message(code));
-		return (1);
-	    }
+                if (code) {
+                    debugs(11, 5,
+                           HERE << "Error while freeing keytab entry : " <<
+                           error_message(code));
+                    return (1);
+                }
+
+            } else {
+                principal_name = xstrdup(pn);
+            }
+
+            if (!principal) {
+                code =
+                    krb5_parse_name(kparam.context, principal_name, &principal);
+                if (code) {
+                    debugs(11, 5,
+                           HERE << "Error while parsing principal name " <<
+                           principal_name << " : " << error_message(code));
+                    return (1);
+                }
+            }
+
+            creds = (krb5_creds *) xmalloc(sizeof(*creds));
+            memset(creds, 0, sizeof(*creds));
+            krb5_get_init_creds_opt_init(&options);
+            code = krb5_string_to_deltat((char *) MAX_RENEW_TIME, &rlife);
+            if (code != 0 || rlife == 0) {
+                debugs(11, 5,
+                       HERE << "Error bad lifetime value " << MAX_RENEW_TIME <<
+                       " : " << error_message(code));
+                return (1);
+            }
+            krb5_get_init_creds_opt_set_renew_life(&options, rlife);
+
+            code =
+                krb5_get_init_creds_keytab(kparam.context, creds, principal,
+                                           keytab, 0, NULL, &options);
+            if (code) {
+                debugs(11, 5,
+                       HERE <<
+                       "Error while initializing credentials from keytab : " <<
+                       error_message(code));
+                return (1);
+            }
 #if !HAVE_KRB5_MEMORY_CACHE
-	    mem_cache =
-		(char *) xmalloc(strlen("FILE:/tmp/peer_proxy_negotiate_auth_")
-		+ 16);
-	    snprintf(mem_cache,
-		strlen("FILE:/tmp/peer_proxy_negotiate_auth_") + 16,
-		"FILE:/tmp/peer_proxy_negotiate_auth_%d", (int) getpid());
+            mem_cache =
+                (char *) xmalloc(strlen("FILE:/tmp/peer_proxy_negotiate_auth_")
+                                 + 16);
+            snprintf(mem_cache,
+                     strlen("FILE:/tmp/peer_proxy_negotiate_auth_") + 16,
+                     "FILE:/tmp/peer_proxy_negotiate_auth_%d", (int) getpid());
 #else
-	    mem_cache =
-		(char *) xmalloc(strlen("MEMORY:peer_proxy_negotiate_auth_") +
-		16);
-	    snprintf(mem_cache,
-		strlen("MEMORY:peer_proxy_negotiate_auth_") + 16,
-		"MEMORY:peer_proxy_negotiate_auth_%d", (int) getpid());
+            mem_cache =
+                (char *) xmalloc(strlen("MEMORY:peer_proxy_negotiate_auth_") +
+                                 16);
+            snprintf(mem_cache,
+                     strlen("MEMORY:peer_proxy_negotiate_auth_") + 16,
+                     "MEMORY:peer_proxy_negotiate_auth_%d", (int) getpid());
 #endif
 
-	    setenv("KRB5CCNAME", mem_cache, 1);
-	    code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc);
-	    if (mem_cache)
-		xfree(mem_cache);
-	    if (code) {
-		debugs(11, 5,
-		    HERE << "Error while resolving memory credential cache : "
-		    << error_message(code));
-		return (1);
-	    }
-	    code = krb5_cc_initialize(kparam.context, kparam.cc, principal);
-	    if (code) {
-		debugs(11, 5,
-		    HERE <<
-		    "Error while initializing memory credential cache : " <<
-		    error_message(code));
-		return (1);
-	    }
-	    code = krb5_cc_store_cred(kparam.context, kparam.cc, creds);
-	    if (code) {
-		debugs(11, 5,
-		    HERE << "Error while storing credentials : " <<
-		    error_message(code));
-		return (1);
-	    }
-
-	    if (!creds->times.starttime)
-		creds->times.starttime = creds->times.authtime;
-	}
-	return (0);
+            setenv("KRB5CCNAME", mem_cache, 1);
+            code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc);
+            if (mem_cache)
+                xfree(mem_cache);
+            if (code) {
+                debugs(11, 5,
+                       HERE << "Error while resolving memory credential cache : "
+                       << error_message(code));
+                return (1);
+            }
+            code = krb5_cc_initialize(kparam.context, kparam.cc, principal);
+            if (code) {
+                debugs(11, 5,
+                       HERE <<
+                       "Error while initializing memory credential cache : " <<
+                       error_message(code));
+                return (1);
+            }
+            code = krb5_cc_store_cred(kparam.context, kparam.cc, creds);
+            if (code) {
+                debugs(11, 5,
+                       HERE << "Error while storing credentials : " <<
+                       error_message(code));
+                return (1);
+            }
+
+            if (!creds->times.starttime)
+                creds->times.starttime = creds->times.authtime;
+        }
+        return (0);
     }
 
-/*
- * peer_proxy_negotiate_auth gets a GSSAPI token for principal_name
- * and base64 encodes it.
- */
-    char *peer_proxy_negotiate_auth(char *principal_name, char *proxy)
-    {
-	int rc = 0;
-	OM_uint32 major_status, minor_status;
-	gss_ctx_id_t gss_context = GSS_C_NO_CONTEXT;
-	gss_name_t server_name = GSS_C_NO_NAME;
-	gss_buffer_desc service = GSS_C_EMPTY_BUFFER;
-	gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
-	gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
-	char *token = NULL;
-
-	setbuf(stdout, NULL);
-	setbuf(stdin, NULL);
-
-	if (!proxy) {
-	    debugs(11, 5, HERE << "Error : No proxy server name");
-	    return NULL;
-	}
-
-	if (principal_name)
-	    debugs(11, 5,
-		HERE << "Creating credential cache for " << principal_name);
-	else
-	    debugs(11, 5, HERE << "Creating credential cache");
-	rc = krb5_create_cache(NULL, principal_name);
-	if (rc) {
-	    debugs(11, 5, HERE << "Error : Failed to create Kerberos cache");
-	    krb5_cleanup();
-	    return NULL;
-	}
-
-	service.value = (void *) xmalloc(strlen("HTTP") + strlen(proxy) + 2);
-	snprintf((char *) service.value, strlen("HTTP") + strlen(proxy) + 2,
-	    "%s@%s", "HTTP", proxy);
-	service.length = strlen((char *) service.value);
-
-	debugs(11, 5, HERE << "Import gss name");
-	major_status = gss_import_name(&minor_status, &service,
-	    gss_nt_service_name, &server_name);
-
-	if (check_gss_err(major_status, minor_status, "gss_import_name()"))
-	    goto cleanup;
-
-	debugs(11, 5, HERE << "Initialize gss security context");
-	major_status = gss_init_sec_context(&minor_status,
-	    GSS_C_NO_CREDENTIAL,
-	    &gss_context,
-	    server_name,
-	    gss_mech_spnego,
-	    0,
-	    0,
-	    GSS_C_NO_CHANNEL_BINDINGS,
-	    &input_token, NULL, &output_token, NULL, NULL);
-
-	if (check_gss_err(major_status, minor_status, "gss_init_sec_context()"))
-	    goto cleanup;
-
-	debugs(11, 5, HERE << "Got token with length " << output_token.length);
-	if (output_token.length) {
-
-	    token =
-		(char *) base64_encode_bin((const char *) output_token.value,
-		output_token.length);
-	}
-
-
-      cleanup:
-	gss_delete_sec_context(&minor_status, &gss_context, NULL);
-	gss_release_buffer(&minor_status, &service);
-	gss_release_buffer(&minor_status, &input_token);
-	gss_release_buffer(&minor_status, &output_token);
-	gss_release_name(&minor_status, &server_name);
-
-	return token;
+    /*
+     * peer_proxy_negotiate_auth gets a GSSAPI token for principal_name
+     * and base64 encodes it.
+     */
+    char *peer_proxy_negotiate_auth(char *principal_name, char *proxy) {
+        int rc = 0;
+        OM_uint32 major_status, minor_status;
+        gss_ctx_id_t gss_context = GSS_C_NO_CONTEXT;
+        gss_name_t server_name = GSS_C_NO_NAME;
+        gss_buffer_desc service = GSS_C_EMPTY_BUFFER;
+        gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
+        gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
+        char *token = NULL;
+
+        setbuf(stdout, NULL);
+        setbuf(stdin, NULL);
+
+        if (!proxy) {
+            debugs(11, 5, HERE << "Error : No proxy server name");
+            return NULL;
+        }
+
+        if (principal_name)
+            debugs(11, 5,
+                   HERE << "Creating credential cache for " << principal_name);
+        else
+            debugs(11, 5, HERE << "Creating credential cache");
+        rc = krb5_create_cache(NULL, principal_name);
+        if (rc) {
+            debugs(11, 5, HERE << "Error : Failed to create Kerberos cache");
+            krb5_cleanup();
+            return NULL;
+        }
+
+        service.value = (void *) xmalloc(strlen("HTTP") + strlen(proxy) + 2);
+        snprintf((char *) service.value, strlen("HTTP") + strlen(proxy) + 2,
+                 "%s@%s", "HTTP", proxy);
+        service.length = strlen((char *) service.value);
+
+        debugs(11, 5, HERE << "Import gss name");
+        major_status = gss_import_name(&minor_status, &service,
+                                       gss_nt_service_name, &server_name);
+
+        if (check_gss_err(major_status, minor_status, "gss_import_name()"))
+            goto cleanup;
+
+        debugs(11, 5, HERE << "Initialize gss security context");
+        major_status = gss_init_sec_context(&minor_status,
+                                            GSS_C_NO_CREDENTIAL,
+                                            &gss_context,
+                                            server_name,
+                                            gss_mech_spnego,
+                                            0,
+                                            0,
+                                            GSS_C_NO_CHANNEL_BINDINGS,
+                                            &input_token, NULL, &output_token, NULL, NULL);
+
+        if (check_gss_err(major_status, minor_status, "gss_init_sec_context()"))
+            goto cleanup;
+
+        debugs(11, 5, HERE << "Got token with length " << output_token.length);
+        if (output_token.length) {
+
+            token =
+                (char *) base64_encode_bin((const char *) output_token.value,
+                                           output_token.length);
+        }
+
+
+cleanup:
+        gss_delete_sec_context(&minor_status, &gss_context, NULL);
+        gss_release_buffer(&minor_status, &service);
+        gss_release_buffer(&minor_status, &input_token);
+        gss_release_buffer(&minor_status, &output_token);
+        gss_release_name(&minor_status, &server_name);
+
+        return token;
     }
 
 #ifdef __cplusplus
@@ -281,7 +281,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
     }
 
     /* request-specific checks */
-    if (request) {
+    if (request && !request->flags.ignore_cc) {
         HttpHdrCc *cc = request->cache_control;
 
         if (request->flags.ims && (R->flags.refresh_ims || Config.onoff.refresh_all_ims)) {
@@ -1004,7 +1004,7 @@ struct _iostats {
 
 
 struct request_flags {
-    request_flags(): range(0),nocache(0),ims(0),auth(0),cachable(0),hierarchical(0),loopdetect(0),proxy_keepalive(0),proxying(0),refresh(0),redirected(0),need_validation(0),accelerated(0),intercepted(0),spoof_client_ip(0),internal(0),internalclient(0),must_keepalive(0),destinationIPLookedUp_(0) {
+    request_flags(): range(0),nocache(0),ims(0),auth(0),cachable(0),hierarchical(0),loopdetect(0),proxy_keepalive(0),proxying(0),refresh(0),redirected(0),need_validation(0),accelerated(0),ignore_cc(0),intercepted(0),spoof_client_ip(0),internal(0),internalclient(0),must_keepalive(0),destinationIPLookedUp_(0) {
 #if HTTP_VIOLATIONS
         nocache_hack = 0;
 #endif
@@ -1030,6 +1030,7 @@ unsigned int proxying:
     unsigned int nocache_hack:1;	/* for changing/ignoring no-cache requests */
 #endif
     unsigned int accelerated:1;
+    unsigned int ignore_cc:1;
     unsigned int intercepted:1;  /**< transparently intercepted request */
     unsigned int spoof_client_ip:1;  /**< spoof client ip if possible */
     unsigned int internal:1;
@@ -895,8 +895,8 @@ main(int argc, char *argv[])
     if ((s = getenv("SCRIPT_NAME")) != NULL)
         script_name = xstrdup(s);
 
-   char **args = argv;
-   while (argc > 1 && args[1][0] == '-') {
+    char **args = argv;
+    while (argc > 1 && args[1][0] == '-') {
 //        const char *value = "";
         char option = args[1][1];
         switch (option) {
@@ -1034,7 +1034,7 @@ read_request(void)
 
     make_pub_auth(req);
     debug("cmgr: got req: host: '%s' port: %d uname: '%s' passwd: '%s' auth: '%s' oper: '%s'\n",
-                     safe_str(req->hostname), req->port, safe_str(req->user_name), safe_str(req->passwd), safe_str(req->pub_auth), safe_str(req->action));
+          safe_str(req->hostname), req->port, safe_str(req->user_name), safe_str(req->passwd), safe_str(req->pub_auth), safe_str(req->action));
     return req;
 }
 