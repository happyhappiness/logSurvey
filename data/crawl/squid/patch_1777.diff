@@ -32,18 +32,18 @@ SOFTWARE.
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 #include <sys/types.h>
 
 #ifndef EIGHTBIT_SUBIDS
-typedef u_long	oid;
+typedef u_long oid;
 #define MAX_SUBID   0xFFFFFFFF
 #else
-typedef u_char	oid;
+typedef u_char oid;
 #define MAX_SUBID   0xFF
 #endif
 
@@ -92,108 +92,108 @@ typedef long int32;
 struct counter64 {
     u_int32 high;
     u_int32 low;
-  };
-
-
-extern u_char	*asn_parse_int _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type,
-			long *intp,
-			int intsize));
-
-extern u_char	*asn_build_int _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			long *intp,
-			int intsize));
-
-extern u_char	*asn_parse_unsigned_int _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type,
-			u_long *intp,
-			int intsize));
-
-extern u_char	*asn_build_unsigned_int _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			u_long *intp,
-			int intsize));
-
-extern u_char	*asn_parse_string _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type,
-			u_char *string,
-			int *len));
-
-extern u_char	*asn_build_string _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			u_char *str,
-			int len));
-
-extern u_char	*asn_parse_header _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type));
-
-extern u_char	*asn_build_header _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			int len));
-
-extern u_char	*asn_build_sequence _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			int len));
-
-extern u_char	*asn_parse_length _ANSI_ARGS_((u_char *data,
-			u_long *eln));
-
-extern u_char	*asn_build_length _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			int len));
-
-extern u_char	*asn_parse_objid _ANSI_ARGS_((
-			u_char *data,
-			int *datalength,
-			u_char *type,
-			oid *objid, 
-			int *objidlength));
-
-extern u_char	*asn_build_objid _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			oid *objid, 
-			int objidlength));
-
-extern u_char	*asn_parse_null _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type));
-
-extern u_char	*asn_build_null _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type));
-extern u_char	*asn_parse_bitstring _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type,
-			u_char *str,
-			int *len));
-
-extern u_char	*asn_build_bitstring _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			u_char *str,
-			int len));
-
-extern u_char	*asn_parse_unsigned_int64 _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char *type,
-			struct counter64 *cp,
-			int cp_size));
-
-extern u_char	*asn_build_unsigned_int64 _ANSI_ARGS_((u_char *data,
-			int *datalength,
-			u_char type,
-			struct counter64 *cp,
-			int cp_size));
+};
+
+
+extern u_char *asn_parse_int _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type,
+	long *intp,
+	int intsize));
+
+extern u_char *asn_build_int _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	long *intp,
+	int intsize));
+
+extern u_char *asn_parse_unsigned_int _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type,
+	u_long * intp,
+	int intsize));
+
+extern u_char *asn_build_unsigned_int _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	u_long * intp,
+	int intsize));
+
+extern u_char *asn_parse_string _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type,
+	u_char * string,
+	int *len));
+
+extern u_char *asn_build_string _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	u_char * str,
+	int len));
+
+extern u_char *asn_parse_header _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type));
+
+extern u_char *asn_build_header _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	int len));
+
+extern u_char *asn_build_sequence _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	int len));
+
+extern u_char *asn_parse_length _ANSI_ARGS_((u_char * data,
+	u_long * eln));
+
+extern u_char *asn_build_length _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	int len));
+
+extern u_char *asn_parse_objid _ANSI_ARGS_((
+	u_char * data,
+	int *datalength,
+	u_char * type,
+	oid * objid,
+	int *objidlength));
+
+extern u_char *asn_build_objid _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	oid * objid,
+	int objidlength));
+
+extern u_char *asn_parse_null _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type));
+
+extern u_char *asn_build_null _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type));
+extern u_char *asn_parse_bitstring _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type,
+	u_char * str,
+	int *len));
+
+extern u_char *asn_build_bitstring _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	u_char * str,
+	int len));
+
+extern u_char *asn_parse_unsigned_int64 _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char * type,
+	struct counter64 * cp,
+	int cp_size));
+
+extern u_char *asn_build_unsigned_int64 _ANSI_ARGS_((u_char * data,
+	int *datalength,
+	u_char type,
+	struct counter64 * cp,
+	int cp_size));
 
 #endif
@@ -4,9 +4,9 @@
  */
 
 /* PROTOTYPES should be set to one if and only if the compiler supports
-  function argument prototyping.
-The following makes PROTOTYPES default to 0 if it has not already
-  been defined with C compiler flags.
+ * function argument prototyping.
+ * The following makes PROTOTYPES default to 0 if it has not already
+ * been defined with C compiler flags.
  */
 #ifndef PROTOTYPES
 #define PROTOTYPES 0
@@ -22,8 +22,8 @@ typedef unsigned short int UINT2;
 typedef unsigned long int UINT4;
 
 /* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
-If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
-  returns an empty list.
+ * If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
+ * returns an empty list.
  */
 #if PROTOTYPES
 #define PROTO_LIST(list) list
@@ -35,36 +35,35 @@ If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  */
 
 /* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
-rights reserved.
-
-License to copy and use this software is granted provided that it
-is identified as the "RSA Data Security, Inc. MD5 Message-Digest
-Algorithm" in all material mentioning or referencing this software
-or this function.
-
-License is also granted to make and use derivative works provided
-that such works are identified as "derived from the RSA Data
-Security, Inc. MD5 Message-Digest Algorithm" in all material
-mentioning or referencing the derived work.
-
-RSA Data Security, Inc. makes no representations concerning either
-the merchantability of this software or the suitability of this
-software for any particular purpose. It is provided "as is"
-without express or implied warranty of any kind.
-
-These notices must be retained in any copies of any part of this
-documentation and/or software.
+ * rights reserved.
+ * 
+ * License to copy and use this software is granted provided that it
+ * is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm" in all material mentioning or referencing this software
+ * or this function.
+ * 
+ * License is also granted to make and use derivative works provided
+ * that such works are identified as "derived from the RSA Data
+ * Security, Inc. MD5 Message-Digest Algorithm" in all material
+ * mentioning or referencing the derived work.
+ * 
+ * RSA Data Security, Inc. makes no representations concerning either
+ * the merchantability of this software or the suitability of this
+ * software for any particular purpose. It is provided "as is"
+ * without express or implied warranty of any kind.
+ * 
+ * These notices must be retained in any copies of any part of this
+ * documentation and/or software.
  */
 
 /* MD5 context. */
 typedef struct {
-  UINT4 state[4];                                   /* state (ABCD) */
-  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
-  unsigned char buffer[64];                         /* input buffer */
+    UINT4 state[4];		/* state (ABCD) */
+    UINT4 count[2];		/* number of bits, modulo 2^64 (lsb first) */
+    unsigned char buffer[64];	/* input buffer */
 } MD5_CTX;
 
-void MD5Init PROTO_LIST ((MD5_CTX *));
+void MD5Init PROTO_LIST((MD5_CTX *));
 void MD5Update PROTO_LIST
-  ((MD5_CTX *, unsigned char *, unsigned int));
-void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));
-
+          ((MD5_CTX *, unsigned char *, unsigned int));
+void MD5Final PROTO_LIST((unsigned char[16], MD5_CTX *));
@@ -30,9 +30,9 @@ SOFTWARE.
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 
@@ -47,7 +47,7 @@ SOFTWARE.
  */
 struct enum_list {
     struct enum_list *next;
-    int	value;
+    int value;
     char *label;
 };
 
@@ -56,13 +56,13 @@ struct enum_list {
  */
 struct node {
     struct node *next;
-    char label[MAXLABEL]; /* This node's (unique) textual name */
-    u_long  subid;  /* This node's integer subidentifier */
-    char parent[MAXLABEL];/* The parent's textual name */
-    int type;	    /* The type of object this represents */
+    char label[MAXLABEL];	/* This node's (unique) textual name */
+    u_long subid;		/* This node's integer subidentifier */
+    char parent[MAXLABEL];	/* The parent's textual name */
+    int type;			/* The type of object this represents */
     struct enum_list *enums;	/* (optional) list of enumerated integers
-(otherwise NULL) */
-    char *description;	/* description (a quoted string) */
+				 * (otherwise NULL) */
+    char *description;		/* description (a quoted string) */
 };
 
 /*
@@ -72,13 +72,13 @@ struct tree {
     struct tree *child_list;	/* list of children of this node */
     struct tree *next_peer;	/* Next node in list of peers */
     struct tree *parent;
-    char label[MAXLABEL];		/* This node's textual name */
+    char label[MAXLABEL];	/* This node's textual name */
     u_long subid;		/* This node's integer subidentifier */
     int type;			/* This node's object type */
     struct enum_list *enums;	/* (optional) list of enumerated integers
-(otherwise NULL) */
-    void (*printer)();     /* Value printing function */
-    char *description;	/* description (a quoted string) */
+				 * (otherwise NULL) */
+    void (*printer) ();		/* Value printing function */
+    char *description;		/* description (a quoted string) */
 };
 
 /* non-aggregate types for tree end nodes */
@@ -113,35 +113,35 @@ SOFTWARE.
 
 
 typedef struct _conf_if_list {
-  char *name;
-  int type;
-  int speed;
-  struct _conf_if_list *next;
+    char *name;
+    int type;
+    int speed;
+    struct _conf_if_list *next;
 } conf_if_list;
 
 extern conf_if_list *if_list;
 
 #ifndef SQUID_SNMP
-/*extern void init_snmp();*/
-
-extern int read_objid (char *input,
-				   oid *output,
-				   int	*out_len);
-
-extern void sprint_objid (char *buf,oid *id,int idlen);
-extern void print_objid (oid *id,
-				     int idlen);
-void snmp_add_null_var (struct snmp_pdu *,
-					   oid *,
-					   int);
-extern void xdump (u_char *cp,
-			       int length,
-			       char *prefix);
-
-extern void snmp_synch_setup (struct snmp_session *session);
-
-extern int snmp_synch_response (struct snmp_session *ss,
-					    struct snmp_pdu *pdu,
-					    struct snmp_pdu **response);
+/*extern void init_snmp(); */
+
+extern int read_objid(char *input,
+    oid * output,
+    int *out_len);
+
+extern void sprint_objid(char *buf, oid * id, int idlen);
+extern void print_objid(oid * id,
+    int idlen);
+void snmp_add_null_var(struct snmp_pdu *,
+    oid *,
+    int);
+extern void xdump(u_char * cp,
+    int length,
+    char *prefix);
+
+extern void snmp_synch_setup(struct snmp_session *session);
+
+extern int snmp_synch_response(struct snmp_session *ss,
+    struct snmp_pdu *pdu,
+    struct snmp_pdu **response);
 #endif
 #endif
@@ -30,9 +30,9 @@ SOFTWARE.
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 
@@ -50,62 +50,62 @@ typedef int ssize_t;
 typedef struct sockaddr_in ipaddr;
 
 typedef struct {
-    u_char	securityModel;
-    u_char	qoS;
-    u_char	agentID[12];
-    u_long	agentBoots;
-    int		agentTime;
-    int		MMS;
-    int	     	userLen;
-    u_char   	userName[16];
-    int		authLen;
-    u_char	authDigest[16];
-    u_char     *authDigestPtr;
-    int		contextLen;
-    u_char	contextSelector[40];
+    u_char securityModel;
+    u_char qoS;
+    u_char agentID[12];
+    u_long agentBoots;
+    int agentTime;
+    int MMS;
+    int userLen;
+    u_char userName[16];
+    int authLen;
+    u_char authDigest[16];
+    u_char *authDigestPtr;
+    int contextLen;
+    u_char contextSelector[40];
 } Parameters;
 
 struct snmp_session {
-    int	    retries;		/* Number of retries before timeout. */
-    long    timeout;    	/* Number of uS until first timeout, then exponential backoff */
-    char    *peername;		/* Domain name or dotted IP address of default peer */
+    int retries;		/* Number of retries before timeout. */
+    long timeout;		/* Number of uS until first timeout, then exponential backoff */
+    char *peername;		/* Domain name or dotted IP address of default peer */
     u_short remote_port;	/* UDP port number of peer. */
-    u_short local_port; 	/* My UDP port number, 0 for default, picked randomly */
+    u_short local_port;		/* My UDP port number, 0 for default, picked randomly */
 
     /* Authentication function or NULL if null authentication is used */
-    int    (*authenticator)();
-    int	    (*callback)();  	/* Function to interpret incoming data */
+    int (*authenticator) ();
+    int (*callback) ();		/* Function to interpret incoming data */
 
     /* Pointer to data that the callback function may consider important */
-    void    *callback_magic;
+    void *callback_magic;
 
-    int		version; 	/* SNMP version number */
+    int version;		/* SNMP version number */
 
     /* fields to support SNMPv1 community model */
-    int	        community_len;
-    u_char      *community;
+    int community_len;
+    u_char *community;
 
     /* the private keys to use for user-based security */
-    u_char   	authKey[16];
-    u_char   	privKey[16];
+    u_char authKey[16];
+    u_char privKey[16];
 
     /* fields to support user-based security model in SNMPv2 */
-    Parameters	params;
-
-    u_char	qoS;
-    u_char	agentID[16];
-    u_long	agentBoots;
-    int		agentTime;		/* the agentTime value */
-    int		agentClock;		/* the running agentClock */
-    int	     	userLen;
-    u_char   	userName[32];
-    int		MMS;
-    int		contextLen;
-    u_char	contextSelector[64];
+    Parameters params;
+
+    u_char qoS;
+    u_char agentID[16];
+    u_long agentBoots;
+    int agentTime;		/* the agentTime value */
+    int agentClock;		/* the running agentClock */
+    int userLen;
+    u_char userName[32];
+    int MMS;
+    int contextLen;
+    u_char contextSelector[64];
 
     /* misc stuff */
-    int		readView;
-    int		writeView;
+    int readView;
+    int writeView;
 };
 
 /*
@@ -134,63 +134,63 @@ struct snmp_session {
 extern int snmp_errno;
 /* Error return values */
 #define SNMPERR_GENERR		-1
-#define SNMPERR_BAD_LOCPORT	-2  /* local port was already in use */
+#define SNMPERR_BAD_LOCPORT	-2	/* local port was already in use */
 #define SNMPERR_BAD_ADDRESS	-3
 #define SNMPERR_BAD_SESSION	-4
 #define SNMPERR_TOO_LONG	-5
 
 
 struct snmp_pdu {
-    ipaddr  address;	/* Address of peer */
+    ipaddr address;		/* Address of peer */
 
-    int	    command;	/* Type of this PDU */
+    int command;		/* Type of this PDU */
 
     Parameters params;
 
-    u_long  reqid;	/* Request id */
-    u_long  errstat;	/* Error status */
-    u_long  errindex;	/* Error index */
+    u_long reqid;		/* Request id */
+    u_long errstat;		/* Error status */
+    u_long errindex;		/* Error index */
 
     /* Trap information */
-    oid	    *enterprise;/* System OID */
-    int	    enterprise_length;
-    ipaddr  agent_addr;	/* address of object generating trap */
-    int	    trap_type;	/* trap type */
-    int	    specific_type;  /* specific type */
-    u_long  time;	/* Uptime */
+    oid *enterprise;		/* System OID */
+    int enterprise_length;
+    ipaddr agent_addr;		/* address of object generating trap */
+    int trap_type;		/* trap type */
+    int specific_type;		/* specific type */
+    u_long time;		/* Uptime */
 
     struct variable_list *variables;
 };
 
 
 struct variable_list {
-    struct variable_list *next_variable;    /* NULL for last variable */
-    oid	    *name;  /* Object identifier of variable */
-    int	    name_length;    /* number of subid's in name */
-    u_char  type;   /* ASN type of variable */
-    union { /* value of variable */
-	long	*integer;
-	u_char	*string;
-	oid	*objid;
-	u_char  *bitstring;
+    struct variable_list *next_variable;	/* NULL for last variable */
+    oid *name;			/* Object identifier of variable */
+    int name_length;		/* number of subid's in name */
+    u_char type;		/* ASN type of variable */
+    union {			/* value of variable */
+	long *integer;
+	u_char *string;
+	oid *objid;
+	u_char *bitstring;
 	struct counter64 *counter64;
 
     } val;
-    int	    val_len;
+    int val_len;
 };
 
 #ifndef SQUID_SNMP
 /*
  * struct snmp_session *snmp_open(session)
- *	struct snmp_session *session;
+ *      struct snmp_session *session;
  * 
  * Sets up the session with the snmp_session information provided
  * by the user.  Then opens and binds the necessary UDP port.
  * A handle to the created session is returned (this is different than
  * the pointer passed to snmp_open()).  On any error, NULL is returned
  * and snmp_errno is set to the appropriate error code.
  */
-struct snmp_session *snmp_open _ANSI_ARGS_((struct snmp_session *session));
+struct snmp_session *snmp_open _ANSI_ARGS_((struct snmp_session * session));
 
 /*
  * int snmp_close(session)
@@ -200,13 +200,13 @@ struct snmp_session *snmp_open _ANSI_ARGS_((struct snmp_session *session));
  * dequeues any pending requests, and closes any sockets allocated for
  * the session.  Returns 0 on error, 1 otherwise.
  */
-int snmp_close _ANSI_ARGS_((struct snmp_session *session));
+int snmp_close _ANSI_ARGS_((struct snmp_session * session));
 
 
 /*
  * int snmp_send(session, pdu)
  *     struct snmp_session *session;
- *     struct snmp_pdu	*pdu;
+ *     struct snmp_pdu  *pdu;
  * 
  * Sends the input pdu on the session after calling snmp_build to create
  * a serialized packet.  If necessary, set some of the pdu data from the
@@ -216,8 +216,8 @@ int snmp_close _ANSI_ARGS_((struct snmp_session *session));
  * On any error, 0 is returned.
  * The pdu is freed by snmp_send() unless a failure occured.
  */
-int snmp_send _ANSI_ARGS_((struct snmp_session *session,
-			   struct snmp_pdu *pdu));
+int snmp_send _ANSI_ARGS_((struct snmp_session * session,
+	struct snmp_pdu * pdu));
 
 
 /*
@@ -230,7 +230,7 @@ int snmp_send _ANSI_ARGS_((struct snmp_session *session,
  * is passed to the callback routine for that session.  If the callback
  * routine returns successfully, the pdu and it's request are deleted.
  */
-void snmp_read (fd_set  *fdset);
+void snmp_read(fd_set * fdset);
 
 
 /*
@@ -240,7 +240,7 @@ void snmp_read (fd_set  *fdset);
  * 
  * Frees the pdu and any malloc'd data associated with it.
  */
-void snmp_free_pdu (struct snmp_pdu *pdu);
+void snmp_free_pdu(struct snmp_pdu *pdu);
 
 /*
  * int snmp_select_info(numfds, fdset, timeout, block)
@@ -269,9 +269,9 @@ void snmp_free_pdu (struct snmp_pdu *pdu);
  * snmp_select_info returns the number of open sockets.  (i.e. The number of sessions open)
  */
 int snmp_select_info _ANSI_ARGS_((int *numfds,
-				  fd_set *fdset,
-				  struct timeval *timeout,
-				  int *block));
+	fd_set * fdset,
+	struct timeval * timeout,
+	int *block));
 
 /*
  * void snmp_timeout();
@@ -291,10 +291,10 @@ void snmp_timeout _ANSI_ARGS_((void));
  * This routine must be supplied by the application:
  *
  * u_char *authenticator(pdu, length, community, community_len)
- * u_char *pdu;		The rest of the PDU to be authenticated
- * int *length;		The length of the PDU (updated by the authenticator)
- * u_char *community;	The community name to authenticate under.
- * int	community_len	The length of the community name.
+ * u_char *pdu;         The rest of the PDU to be authenticated
+ * int *length;         The length of the PDU (updated by the authenticator)
+ * u_char *community;   The community name to authenticate under.
+ * int  community_len   The length of the community name.
  *
  * Returns the authenticated pdu, or NULL if authentication failed.
  * If null authentication is used, the authenticator in snmp_session can be
@@ -307,9 +307,9 @@ void snmp_timeout _ANSI_ARGS_((void));
  * int callback(operation, session, reqid, pdu, magic)
  * int operation;
  * struct snmp_session *session;    The session authenticated under.
- * int reqid;			    The request id of this pdu (0 for TRAP)
- * struct snmp_pdu *pdu;	    The pdu information.
- * void *magic			    A link to the data for this routine.
+ * int reqid;                       The request id of this pdu (0 for TRAP)
+ * struct snmp_pdu *pdu;            The pdu information.
+ * void *magic                      A link to the data for this routine.
  *
  * Returns 1 if request was successful, 0 if it should be kept pending.
  * Any data in the pdu must be copied because it will be freed elsewhere.
@@ -29,15 +29,15 @@ SOFTWARE.
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 
 
 struct synch_state {
-    int	waiting;
+    int waiting;
     int status;
 /* status codes */
 #define STAT_SUCCESS	0
@@ -51,8 +51,8 @@ extern struct synch_state snmp_synch_state;
 
 extern struct snmp_pdu *snmp_pdu_create _ANSI_ARGS_((int cmd));
 
-extern struct snmp_pdu *snmp_fix_pdu _ANSI_ARGS_((struct snmp_pdu *pdu,
-						  int cmd));
+extern struct snmp_pdu *snmp_fix_pdu _ANSI_ARGS_((struct snmp_pdu * pdu,
+	int cmd));
 extern char *snmp_errstring _ANSI_ARGS_((int errstat));
 
 #endif
@@ -31,9 +31,9 @@ SOFTWARE.
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 
@@ -55,7 +55,7 @@ SOFTWARE.
 #define BUILD_ERROR	-2
 
 #define SID_MAX_LEN	200
-#define MAX_NAME_LEN	64  /* number of subid's in a objid */
+#define MAX_NAME_LEN	64	/* number of subid's in a objid */
 
 #ifndef NULL
 #define NULL 0
@@ -77,9 +77,9 @@ SOFTWARE.
 #define ACTION      3
 #define FREE        4
 
-#define RONLY	0xAAAA	/* read access for everyone */
-#define RWRITE	0xAABA	/* add write access for community private */
-#define NOACCESS 0x0000	/* no access for anybody */
+#define RONLY	0xAAAA		/* read access for everyone */
+#define RWRITE	0xAABA		/* add write access for community private */
+#define NOACCESS 0x0000		/* no access for anybody */
 
 #define INTEGER	    ASN_INTEGER
 #define STRING	    ASN_OCTET_STR
@@ -103,35 +103,35 @@ SOFTWARE.
 #define ERROR(string)
 #endif
 
-/* from snmp.c*/
-extern u_char	sid[];	/* size SID_MAX_LEN */
-
-extern u_char *snmp_parse_var_op _ANSI_ARGS_((u_char *data,
-					      oid *var_name,
-					      int *var_name_len,
-					      u_char *var_val_type,
-					      int *var_val_len,
-					      u_char **var_val, 
-					      int *listlength));
-
-extern u_char *snmp_build_var_op _ANSI_ARGS_((u_char *data,
-					      oid *var_name,
-					      int *var_name_len,
-					      u_char var_val_type,
-					      int var_val_len,
-					      u_char *var_val,
-					      int *listlength));
-
-extern u_char *snmp_auth_parse _ANSI_ARGS_((u_char *data,
-					    int *length,
-					    u_char *sid,
-					    int *slen,
-					    long *version));
-
-extern u_char *snmp_auth_build _ANSI_ARGS_((u_char *data,
-					    int *length,
-					    struct snmp_session *session,
-					    int is_agent,
-					    int messagelen));
+/* from snmp.c */
+extern u_char sid[];		/* size SID_MAX_LEN */
+
+extern u_char *snmp_parse_var_op _ANSI_ARGS_((u_char * data,
+	oid * var_name,
+	int *var_name_len,
+	u_char * var_val_type,
+	int *var_val_len,
+	u_char ** var_val,
+	int *listlength));
+
+extern u_char *snmp_build_var_op _ANSI_ARGS_((u_char * data,
+	oid * var_name,
+	int *var_name_len,
+	u_char var_val_type,
+	int var_val_len,
+	u_char * var_val,
+	int *listlength));
+
+extern u_char *snmp_auth_parse _ANSI_ARGS_((u_char * data,
+	int *length,
+	u_char * sid,
+	int *slen,
+	long *version));
+
+extern u_char *snmp_auth_build _ANSI_ARGS_((u_char * data,
+	int *length,
+	struct snmp_session * session,
+	int is_agent,
+	int messagelen));
 
 #endif
@@ -4,9 +4,9 @@
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 
@@ -20,55 +20,55 @@ extern void snmp_alarm _ANSI_ARGS_((int ival, void (*handler) (void)));
  * service for filedescriptors:
  */
 
-extern void fd_add _ANSI_ARGS_((int fd, void (*func)(int fd)));
+extern void fd_add _ANSI_ARGS_((int fd, void (*func) (int fd)));
 extern void fd_service _ANSI_ARGS_((void));
 
 
 /* ---------------------------------------------------------------------- */
 
 /*
-**  SNMP Agent extension for Spacer-Controler Management
-**
-**  Copyright (c) 1997 FT/CNET/DES/GRL Olivier Montanuy
-** 
-*/
+ * **  SNMP Agent extension for Spacer-Controler Management
+ * **
+ * **  Copyright (c) 1997 FT/CNET/DES/GRL Olivier Montanuy
+ * ** 
+ */
 /*
-** Function to safely copy a string, and ensure the last
-** character is always '\0'.
-*/
+ * ** Function to safely copy a string, and ensure the last
+ * ** character is always '\0'.
+ */
 void
 strcpy_safe _ANSI_ARGS_((char *str, int str_len, char *val));
 
 
 /*
-** Function to get IP address of this agent
-** WARNING: this scans all interfaces (slow)
-*/
-u_long 
+ * ** Function to get IP address of this agent
+ * ** WARNING: this scans all interfaces (slow)
+ */
+u_long
 Util_local_ip_address _ANSI_ARGS_((void));
 
 /*
-** Function to get the current time in seconds
-*/
-long 
+ * ** Function to get the current time in seconds
+ */
+long
 Util_time_now _ANSI_ARGS_((void));
 
 /*
-** Function to determine how long the agent has been running
-*  (WARNING: this seems rather slow)
-*/
-long 
-Util_time_running();
+ * ** Function to determine how long the agent has been running
+ * *  (WARNING: this seems rather slow)
+ */
+long
+     Util_time_running();
 
 /*
-** Read data from file
-*/
+ * ** Read data from file
+ */
 int
 Util_file_read _ANSI_ARGS_((char *file, int offset, char *data, int dataSz));
 
 /*
-** Write data into file
-*/
+ * ** Write data into file
+ */
 int
 Util_file_write _ANSI_ARGS_((char *file, int offset, char *data, int dataSz));
 
@@ -31,35 +31,35 @@ PERFORMANCE OF THIS SOFTWARE.
 
 #undef _ANSI_ARGS_
 #if (defined(__STDC__) && ! defined(NO_PROTOTYPE)) || defined(USE_PROTOTYPE)
-# define _ANSI_ARGS_(x) x
+#define _ANSI_ARGS_(x) x
 #else
-# define _ANSI_ARGS_(x) ()
+#define _ANSI_ARGS_(x) ()
 #endif
 
 
-u_char	*var_system();
-u_char	*var_ifEntry();
-u_char	*var_atEntry();
-u_char	*var_ip();
-u_char	*var_ipAddrEntry();
-u_char	*var_ipRouteEntry();
-u_char	*var_icmp();
-u_char	*var_tcp();
-u_char	*var_udp();
+u_char *var_system();
+u_char *var_ifEntry();
+u_char *var_atEntry();
+u_char *var_ip();
+u_char *var_ipAddrEntry();
+u_char *var_ipRouteEntry();
+u_char *var_icmp();
+u_char *var_tcp();
+u_char *var_udp();
 #ifdef linux
-u_char	*var_snmp();
-u_char	*var_id();
+u_char *var_snmp();
+u_char *var_id();
 #endif
-u_char	*var_process();
-u_char	*var_event();
-u_char  *var_capture();
-u_char	*var_demo();
-u_char	*var_snmpStats();
-u_char	*var_usecStats();
-u_char	*var_usecAgent();
-u_char	*var_orEntry();
-u_char	*var_rwstats();
-u_char	*getStatPtr();
+u_char *var_process();
+u_char *var_event();
+u_char *var_capture();
+u_char *var_demo();
+u_char *var_snmpStats();
+u_char *var_usecStats();
+u_char *var_usecAgent();
+u_char *var_orEntry();
+u_char *var_rwstats();
+u_char *getStatPtr();
 
 extern long long_return;
 extern u_char return_buf[];
@@ -257,32 +257,33 @@ extern u_char return_buf[];
 
 #ifdef linux
 struct inpcb {
-        struct  inpcb *inp_next;        /* pointers to other pcb's */
-        struct  in_addr inp_faddr;      /* foreign host table entry */
-        u_short inp_fport;              /* foreign port */
-        struct  in_addr inp_laddr;      /* local host table entry */
-        u_short inp_lport;              /* local port */
-	int     inp_state;
-	int     uid;			/* owner of the connection */
+    struct inpcb *inp_next;	/* pointers to other pcb's */
+    struct in_addr inp_faddr;	/* foreign host table entry */
+    u_short inp_fport;		/* foreign port */
+    struct in_addr inp_laddr;	/* local host table entry */
+    u_short inp_lport;		/* local port */
+    int inp_state;
+    int uid;			/* owner of the connection */
 };
+
 #endif
 
-extern void TCP_Scan_Init ();
-extern int TCP_Scan_Next ();
+extern void TCP_Scan_Init();
+extern int TCP_Scan_Next();
 
 
 struct variable {
-    u_char	    magic;	    /* passed to function as a hint */
-    char	    type;	    /* type of variable */
+    u_char magic;		/* passed to function as a hint */
+    char type;			/* type of variable */
 /* See important comment in snmp_vars.c relating to acl */
-    u_short	    acl;	    /* access control list for variable */
-    u_char	    *(*findVar)();  /* function that finds variable */
-    u_char	    namelen;	    /* length of above */
-    oid		    name[32];	    /* object identifier of variable */
+    u_short acl;		/* access control list for variable */
+    u_char *(*findVar) ();	/* function that finds variable */
+    u_char namelen;		/* length of above */
+    oid name[32];		/* object identifier of variable */
 };
 
-extern int compare ();
-extern void Interface_Scan_Init ();
-extern int Interface_Scan_Next ();
+extern int compare();
+extern void Interface_Scan_Init();
+extern int Interface_Scan_Next();
 
 #endif
@@ -5,10 +5,10 @@ typedef struct _splay_node {
     struct _splay_node *right;
 } splayNode;
 
-typedef int SPCMP (const void *, splayNode *);
+typedef int SPCMP(const void *, splayNode *);
 
 extern int splayLastResult;
 
 splayNode *splay_insert(void *, splayNode *, SPCMP *);
-splayNode *splay_splay(const void *, splayNode *, SPCMP* );
+splayNode *splay_splay(const void *, splayNode *, SPCMP *);
 void splay_destroy(splayNode *, void (*)(void *));
@@ -1,3 +1,4 @@
+
 /* ====================================================================
  * Copyright (c) 1995-1997 The Apache Group.  All rights reserved.
  *
@@ -17,7 +17,7 @@
 int splayLastResult = 0;
 
 splayNode *
-splay_insert(void *data, splayNode * top, SPCMP *compare)
+splay_insert(void *data, splayNode * top, SPCMP * compare)
 {
     splayNode *new = xcalloc(sizeof(splayNode), 1);
     new->data = data;
@@ -44,7 +44,7 @@ splay_insert(void *data, splayNode * top, SPCMP *compare)
 }
 
 splayNode *
-splay_splay(const void *data, splayNode * top, SPCMP *compare)
+splay_splay(const void *data, splayNode * top, SPCMP * compare)
 {
     splayNode N;
     splayNode *l;
@@ -71,41 +71,41 @@ SOFTWARE.
  */
 u_char *
 asn_parse_int(data, datalength, type, intp, intsize)
-    u_char  *data;	  /* IN - pointer to start of object */
-    int	    *datalength;  /* IN/OUT - number of valid bytes left in buffer */
-    u_char  *type;	  /* OUT - asn type of object */
-    long    *intp;	  /* IN/OUT - pointer to start of output buffer */
-    int     intsize;      /* IN - size of output buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - asn type of object */
+     long *intp;		/* IN/OUT - pointer to start of output buffer */
+     int intsize;		/* IN - size of output buffer */
 {
 /*
  * ASN.1 integer ::= 0x02 asnlength byte {byte}*
  */
     u_char *bufp = data;
-    u_long	    asn_length;
-    long   value = 0;
+    u_long asn_length;
+    long value = 0;
 
-    if (intsize != sizeof (long)){
+    if (intsize != sizeof(long)) {
 	ERROR("not long");
 	return NULL;
     }
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
-    if (bufp == NULL){
+    if (bufp == NULL) {
 	ERROR("bad length");
 	return NULL;
     }
-    if (asn_length + (bufp - data) > *datalength){
+    if (asn_length + (bufp - data) > *datalength) {
 	ERROR("overflow of message");
 	return NULL;
     }
-    if (asn_length > intsize){
+    if (asn_length > intsize) {
 	ERROR("I don't support such large integers");
 	return NULL;
     }
-    *datalength -= (int)asn_length + (bufp - data);
+    *datalength -= (int) asn_length + (bufp - data);
     if (*bufp & 0x80)
-	value = -1; /* integer is negative */
-    while(asn_length--)
+	value = -1;		/* integer is negative */
+    while (asn_length--)
 	value = (value << 8) | *bufp++;
     *intp = value;
     return bufp;
@@ -124,42 +124,42 @@ asn_parse_int(data, datalength, type, intp, intsize)
  */
 u_char *
 asn_parse_unsigned_int(data, datalength, type, intp, intsize)
-    u_char	    *data;	/* IN - pointer to start of object */
-    int	    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char		    *type;	/* OUT - asn type of object */
-    u_long		    *intp;	/* IN/OUT - pointer to start of output buffer */
-    int			    intsize;    /* IN - size of output buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - asn type of object */
+     u_long *intp;		/* IN/OUT - pointer to start of output buffer */
+     int intsize;		/* IN - size of output buffer */
 {
 /*
  * ASN.1 integer ::= 0x02 asnlength byte {byte}*
  */
     u_char *bufp = data;
-    u_long	    asn_length;
+    u_long asn_length;
     u_long value = 0;
 
-    if (intsize != sizeof (long)){
+    if (intsize != sizeof(long)) {
 	ERROR("not long");
 	return NULL;
     }
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
-    if (bufp == NULL){
+    if (bufp == NULL) {
 	ERROR("bad length");
 	return NULL;
     }
-    if (asn_length + (bufp - data) > *datalength){
+    if (asn_length + (bufp - data) > *datalength) {
 	ERROR("overflow of message");
 	return NULL;
     }
     if ((asn_length > (intsize + 1)) ||
-	((asn_length == intsize + 1) && *bufp != 0x00)){
+	((asn_length == intsize + 1) && *bufp != 0x00)) {
 	ERROR("I don't support such large integers");
 	return NULL;
     }
-    *datalength -= (int)asn_length + (bufp - data);
+    *datalength -= (int) asn_length + (bufp - data);
     if (*bufp & 0x80)
-	value = -1; /* integer is negative */
-    while(asn_length--)
+	value = -1;		/* integer is negative */
+    while (asn_length--)
 	value = (value << 8) | *bufp++;
     *intp = value;
     return bufp;
@@ -178,11 +178,11 @@ asn_parse_unsigned_int(data, datalength, type, intp, intsize)
  */
 u_char *
 asn_build_int(data, datalength, type, intp, intsize)
-    u_char *data;	/* IN - pointer to start of output buffer */
-    int    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	/* IN - asn type of object */
-    long   *intp;	/* IN - pointer to start of long integer */
-    int    intsize;    /* IN - size of *intp */
+     u_char *data;		/* IN - pointer to start of output buffer */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - asn type of object */
+     long *intp;		/* IN - pointer to start of long integer */
+     int intsize;		/* IN - size of *intp */
 {
 /*
  * ASN.1 integer ::= 0x02 asnlength byte {byte}*
@@ -191,7 +191,7 @@ asn_build_int(data, datalength, type, intp, intsize)
     long integer;
     u_long mask;
 
-    if (intsize != sizeof (long)) {
+    if (intsize != sizeof(long)) {
 	ERROR("not long");
 	return NULL;
     }
@@ -204,8 +204,8 @@ asn_build_int(data, datalength, type, intp, intsize)
      */
     mask = 0x1FF << ((8 * (sizeof(int32) - 1)) - 1);
     /* mask is 0xFF800000 on a big-endian machine */
-    while((((integer & mask) == 0) || ((integer & mask) == mask))
-	  && intsize > 1){
+    while ((((integer & mask) == 0) || ((integer & mask) == mask))
+	&& intsize > 1) {
 	intsize--;
 	integer <<= 8;
     }
@@ -217,8 +217,8 @@ asn_build_int(data, datalength, type, intp, intsize)
     *datalength -= intsize;
     mask = 0xFF << (8 * (sizeof(int32) - 1));
     /* mask is 0xFF000000 on a big-endian machine */
-    while(intsize--){
-	*data++ = (u_char)((integer & mask) >> (8 * (sizeof(int32) - 1)));
+    while (intsize--) {
+	*data++ = (u_char) ((integer & mask) >> (8 * (sizeof(int32) - 1)));
 	integer <<= 8;
     }
     return data;
@@ -237,11 +237,11 @@ asn_build_int(data, datalength, type, intp, intsize)
  */
 u_char *
 asn_build_unsigned_int(data, datalength, type, intp, intsize)
-    u_char *data;	/* IN - pointer to start of output buffer */
-    int    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	/* IN - asn type of object */
-    u_long *intp;	/* IN - pointer to start of long integer */
-    int    intsize;    /* IN - size of *intp */
+     u_char *data;		/* IN - pointer to start of output buffer */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - asn type of object */
+     u_long *intp;		/* IN - pointer to start of long integer */
+     int intsize;		/* IN - size of *intp */
 {
 /*
  * ASN.1 integer ::= 0x02 asnlength byte {byte}*
@@ -251,14 +251,14 @@ asn_build_unsigned_int(data, datalength, type, intp, intsize)
     u_long mask;
     int add_null_byte = 0;
 
-    if (intsize != sizeof (long)) {
+    if (intsize != sizeof(long)) {
 	ERROR("not long");
 	return NULL;
     }
     integer = *intp;
     mask = 0xFF << (8 * (sizeof(int32) - 1));
     /* mask is 0xFF000000 on a big-endian machine */
-    if ((u_char)((integer & mask) >> (8 * (sizeof(int32) - 1))) & 0x80){
+    if ((u_char) ((integer & mask) >> (8 * (sizeof(int32) - 1))) & 0x80) {
 	/* if MSB is set */
 	add_null_byte = 1;
 	intsize++;
@@ -270,7 +270,7 @@ asn_build_unsigned_int(data, datalength, type, intp, intsize)
      */
     mask = 0x1FF << ((8 * (sizeof(int32) - 1)) - 1);
     /* mask is 0xFF800000 on a big-endian machine */
-    while((((integer & mask) == 0) || ((integer & mask) == mask)) && intsize > 1){
+    while ((((integer & mask) == 0) || ((integer & mask) == mask)) && intsize > 1) {
 	intsize--;
 	integer <<= 8;
     }
@@ -280,14 +280,14 @@ asn_build_unsigned_int(data, datalength, type, intp, intsize)
     if (*datalength < intsize)
 	return NULL;
     *datalength -= intsize;
-    if (add_null_byte == 1){
+    if (add_null_byte == 1) {
 	*data++ = '\0';
 	intsize--;
     }
     mask = 0xFF << (8 * (sizeof(int32) - 1));
     /* mask is 0xFF000000 on a big-endian machine */
-    while(intsize--){
-	*data++ = (u_char)((integer & mask) >> (8 * (sizeof(int32) - 1)));
+    while (intsize--) {
+	*data++ = (u_char) ((integer & mask) >> (8 * (sizeof(int32) - 1)));
 	integer <<= 8;
     }
     return data;
@@ -308,35 +308,35 @@ asn_build_unsigned_int(data, datalength, type, intp, intsize)
  */
 u_char *
 asn_parse_string(data, datalength, type, string, strlength)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    *type;	    /* OUT - asn type of object */
-    u_char	    *string;	    /* IN/OUT - pointer to start of output buffer */
-    int    *strlength;     /* IN/OUT - size of output buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - asn type of object */
+     u_char *string;		/* IN/OUT - pointer to start of output buffer */
+     int *strlength;		/* IN/OUT - size of output buffer */
 {
 /*
  * ASN.1 octet string ::= primstring | cmpdstring
  * primstring ::= 0x04 asnlength byte {byte}*
  * cmpdstring ::= 0x24 asnlength string {string}*
  */
     u_char *bufp = data;
-    u_long	    asn_length;
+    u_long asn_length;
 
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
     if (bufp == NULL)
 	return NULL;
-    if (asn_length + (bufp - data) > *datalength){
+    if (asn_length + (bufp - data) > *datalength) {
 	ERROR("overflow of message");
 	return NULL;
     }
-    if (asn_length > *strlength){
+    if (asn_length > *strlength) {
 	ERROR("I don't support such long strings");
 	return NULL;
     }
-    bcopy((char *)bufp, (char *)string, (int)asn_length);
-    *strlength = (int)asn_length;
-    *datalength -= (int)asn_length + (bufp - data);
+    bcopy((char *) bufp, (char *) string, (int) asn_length);
+    *strlength = (int) asn_length;
+    *datalength -= (int) asn_length + (bufp - data);
     return bufp + asn_length;
 }
 
@@ -353,11 +353,11 @@ asn_parse_string(data, datalength, type, string, strlength)
  */
 u_char *
 asn_build_string(data, datalength, type, string, strlength)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	    /* IN - ASN type of string */
-    u_char	    *string;	    /* IN - pointer to start of input buffer */
-    int    strlength;	    /* IN - size of input buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - ASN type of string */
+     u_char *string;		/* IN - pointer to start of input buffer */
+     int strlength;		/* IN - size of input buffer */
 {
 /*
  * ASN.1 octet string ::= primstring | cmpdstring
@@ -370,7 +370,7 @@ asn_build_string(data, datalength, type, string, strlength)
 	return NULL;
     if (*datalength < strlength)
 	return NULL;
-    bcopy((char *)string, (char *)data, strlength);
+    bcopy((char *) string, (char *) data, strlength);
     *datalength -= strlength;
     return data + strlength;
 }
@@ -387,9 +387,9 @@ asn_build_string(data, datalength, type, string, strlength)
  */
 u_char *
 asn_parse_header(data, datalength, type)
-    u_char	    *data;	/* IN - pointer to start of object */
-    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char	    *type;	/* OUT - ASN type of object */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - ASN type of object */
 {
     u_char *bufp = data;
     int header_len;
@@ -398,9 +398,8 @@ asn_parse_header(data, datalength, type)
     if (*datalength <= 0) {
 	return NULL;
     }
-
     /* this only works on data types < 30, i.e. no extension octets */
-    if (IS_EXTENSION_ID(*bufp)){
+    if (IS_EXTENSION_ID(*bufp)) {
 	ERROR("can't process ID >= 30");
 	return NULL;
     }
@@ -409,11 +408,11 @@ asn_parse_header(data, datalength, type)
     if (bufp == NULL)
 	return NULL;
     header_len = bufp - data;
-    if (header_len + asn_length > *datalength){
+    if (header_len + asn_length > *datalength) {
 	ERROR("asn length too long");
 	return NULL;
     }
-    *datalength = (int)asn_length;
+    *datalength = (int) asn_length;
     return bufp;
 }
 
@@ -432,17 +431,17 @@ asn_parse_header(data, datalength, type)
  */
 u_char *
 asn_build_header(data, datalength, type, length)
-    u_char *data;	/* IN - pointer to start of object */
-    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	/* IN - ASN type of object */
-    int		    length;	/* IN - length of object */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - ASN type of object */
+     int length;		/* IN - length of object */
 {
     if (*datalength < 1)
 	return NULL;
     *data++ = type;
     (*datalength)--;
     return asn_build_length(data, datalength, length);
-    
+
 }
 
 /*
@@ -460,20 +459,20 @@ asn_build_header(data, datalength, type, length)
  */
 u_char *
 asn_build_sequence(data, datalength, type, length)
-    u_char *data;	/* IN - pointer to start of object */
-    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	/* IN - ASN type of object */
-    int		    length;	/* IN - length of object */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - ASN type of object */
+     int length;		/* IN - length of object */
 {
     *datalength -= 4;
-    if (*datalength < 0){
+    if (*datalength < 0) {
 	*datalength += 4;	/* fix up before punting */
 	return NULL;
     }
     *data++ = type;
-    *data++ = (u_char)(0x02 | ASN_LONG_LEN);
-    *data++ = (u_char)((length >> 8) & 0xFF);
-    *data++ = (u_char)(length & 0xFF);
+    *data++ = (u_char) (0x02 | ASN_LONG_LEN);
+    *data++ = (u_char) ((length >> 8) & 0xFF);
+    *data++ = (u_char) (length & 0xFF);
     return data;
 }
 
@@ -487,63 +486,63 @@ asn_build_sequence(data, datalength, type, length)
  */
 u_char *
 asn_parse_length(data, length)
-    u_char  *data;	/* IN - pointer to start of length field */
-    u_long  *length;	/* OUT - value of length field */
+     u_char *data;		/* IN - pointer to start of length field */
+     u_long *length;		/* OUT - value of length field */
 {
     u_char lengthbyte = *data;
 
     *length = 0;
-    if (lengthbyte & ASN_LONG_LEN){
+    if (lengthbyte & ASN_LONG_LEN) {
 	lengthbyte &= ~ASN_LONG_LEN;	/* turn MSb off */
-	if (lengthbyte == 0){
+	if (lengthbyte == 0) {
 	    ERROR("We don't support indefinite lengths");
 	    return NULL;
 	}
-	if (lengthbyte > sizeof(long)){
+	if (lengthbyte > sizeof(long)) {
 	    ERROR("we can't support data lengths that long");
 	    return NULL;
 	}
-	bcopy((char *)data + 1, (char *)length, (int)lengthbyte);
+	bcopy((char *) data + 1, (char *) length, (int) lengthbyte);
 	/* XXX: is this useable on a 64bit platform ? */
 	*length = ntohl(*length);
-	*length >>= (8 * ((sizeof (*length)) - lengthbyte));
+	*length >>= (8 * ((sizeof(*length)) - lengthbyte));
 	return data + lengthbyte + 1;
-    } else { /* short asnlength */
-	*length = (long)lengthbyte;
+    } else {			/* short asnlength */
+	*length = (long) lengthbyte;
 	return data + 1;
     }
 }
 
 u_char *
 asn_build_length(data, datalength, length)
-    u_char *data;	/* IN - pointer to start of object */
-    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    int    length;	/* IN - length of object */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     int length;		/* IN - length of object */
 {
-    u_char    *start_data = data;
+    u_char *start_data = data;
 
     /* no indefinite lengths sent */
-    if (length < 0x80){
-	if (*datalength < 1){
+    if (length < 0x80) {
+	if (*datalength < 1) {
 	    ERROR("build_length");
 	    return NULL;
-	}	    
-	*data++ = (u_char)length;
-    } else if (length <= 0xFF){
-	if (*datalength < 2){
+	}
+	*data++ = (u_char) length;
+    } else if (length <= 0xFF) {
+	if (*datalength < 2) {
 	    ERROR("build_length");
 	    return NULL;
-	}	    
-	*data++ = (u_char)(0x01 | ASN_LONG_LEN);
-	*data++ = (u_char)length;
-    } else { /* 0xFF < length <= 0xFFFF */
-	if (*datalength < 3){
+	}
+	*data++ = (u_char) (0x01 | ASN_LONG_LEN);
+	*data++ = (u_char) length;
+    } else {			/* 0xFF < length <= 0xFFFF */
+	if (*datalength < 3) {
 	    ERROR("build_length");
 	    return NULL;
-	}	    
-	*data++ = (u_char)(0x02 | ASN_LONG_LEN);
-	*data++ = (u_char)((length >> 8) & 0xFF);
-	*data++ = (u_char)(length & 0xFF);
+	}
+	*data++ = (u_char) (0x02 | ASN_LONG_LEN);
+	*data++ = (u_char) ((length >> 8) & 0xFF);
+	*data++ = (u_char) (length & 0xFF);
     }
     *datalength -= (data - start_data);
     return data;
@@ -564,11 +563,11 @@ asn_build_length(data, datalength, length)
  */
 u_char *
 asn_parse_objid(data, datalength, type, objid, objidlength)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    *type;	    /* OUT - ASN type of object */
-    oid		    *objid;	    /* IN/OUT - pointer to start of output buffer */
-    int		    *objidlength;     /* IN/OUT - number of sub-id's in objid */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - ASN type of object */
+     oid *objid;		/* IN/OUT - pointer to start of output buffer */
+     int *objidlength;		/* IN/OUT - number of sub-id's in objid */
 {
 /*
  * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
@@ -579,54 +578,54 @@ asn_parse_objid(data, datalength, type, objid, objidlength)
     u_char *bufp = data;
     oid *oidp = objid + 1;
     u_long subidentifier;
-    long   length;
-    u_long	    asn_length;
+    long length;
+    u_long asn_length;
 
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
     if (bufp == NULL)
 	return NULL;
-    if (asn_length + (bufp - data) > *datalength){
+    if (asn_length + (bufp - data) > *datalength) {
 	ERROR("overflow of message");
 	return NULL;
     }
-    *datalength -= (int)asn_length + (bufp - data);
+    *datalength -= (int) asn_length + (bufp - data);
 
     /* Handle invalid object identifier encodings of the form 06 00 robustly */
     if (asn_length == 0)
 	objid[0] = objid[1] = 0;
 
     length = asn_length;
-    (*objidlength)--;	/* account for expansion of first byte */
-    while (length > 0 && (*objidlength)-- > 0){
+    (*objidlength)--;		/* account for expansion of first byte */
+    while (length > 0 && (*objidlength)-- > 0) {
 	subidentifier = 0;
-	do {	/* shift and add in low order 7 bits */
-	    subidentifier = (subidentifier << 7) + (*(u_char *)bufp & ~ASN_BIT8);
+	do {			/* shift and add in low order 7 bits */
+	    subidentifier = (subidentifier << 7) + (*(u_char *) bufp & ~ASN_BIT8);
 	    length--;
-	} while (*(u_char *)bufp++ & ASN_BIT8);	/* last byte has high bit clear */
-	if (subidentifier > (u_long)MAX_SUBID){
+	} while (*(u_char *) bufp++ & ASN_BIT8);	/* last byte has high bit clear */
+	if (subidentifier > (u_long) MAX_SUBID) {
 	    ERROR("subidentifier too long");
 	    return NULL;
 	}
-	*oidp++ = (oid)subidentifier;
+	*oidp++ = (oid) subidentifier;
     }
 
     /*
      * The first two subidentifiers are encoded into the first component
      * with the value (X * 40) + Y, where:
-     *	X is the value of the first subidentifier.
+     *  X is the value of the first subidentifier.
      *  Y is the value of the second subidentifier.
      */
-    subidentifier = (u_long)objid[1];
-    if (subidentifier == 0x2B){
+    subidentifier = (u_long) objid[1];
+    if (subidentifier == 0x2B) {
 	objid[0] = 1;
 	objid[1] = 3;
     } else {
-	objid[1] = (u_char)(subidentifier % 40);
-	objid[0] = (u_char)((subidentifier - objid[1]) / 40);
+	objid[1] = (u_char) (subidentifier % 40);
+	objid[0] = (u_char) ((subidentifier - objid[1]) / 40);
     }
 
-    *objidlength = (int)(oidp - objid);
+    *objidlength = (int) (oidp - objid);
     return bufp;
 }
 
@@ -643,11 +642,11 @@ asn_parse_objid(data, datalength, type, objid, objidlength)
  */
 u_char *
 asn_build_objid(data, datalength, type, objid, objidlength)
-    u_char *data;	    /* IN - pointer to start of object */
-    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	    /* IN - ASN type of object */
-    oid		    *objid;	    /* IN - pointer to start of input buffer */
-    int		    objidlength;    /* IN - number of sub-id's in objid */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - ASN type of object */
+     oid *objid;		/* IN - pointer to start of input buffer */
+     int objidlength;		/* IN - number of sub-id's in objid */
 {
 /*
  * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
@@ -658,11 +657,11 @@ asn_build_objid(data, datalength, type, objid, objidlength)
     u_char buf[MAX_OID_LEN];
     u_char *bp = buf;
     oid *op = objid;
-    int    asnlength;
+    int asnlength;
     u_long subid, mask, testmask;
     int bits, testbits;
 
-    if (objidlength < 2){
+    if (objidlength < 2) {
 	*bp++ = 0;
 	objidlength = 0;
     } else {
@@ -671,29 +670,29 @@ asn_build_objid(data, datalength, type, objid, objidlength)
 	op += 2;
     }
 
-    while(objidlength-- > 0){
+    while (objidlength-- > 0) {
 	subid = *op++;
-	if (subid < 127){ /* off by one? */
+	if (subid < 127) {	/* off by one? */
 	    *bp++ = subid;
 	} else {
-	    mask = 0x7F; /* handle subid == 0 case */
+	    mask = 0x7F;	/* handle subid == 0 case */
 	    bits = 0;
 	    /* testmask *MUST* !!!! be of an unsigned type */
-	    for(testmask = 0x7F, testbits = 0; testmask != 0;
-		testmask <<= 7, testbits += 7){
-		if (subid & testmask){	/* if any bits set */
+	    for (testmask = 0x7F, testbits = 0; testmask != 0;
+		testmask <<= 7, testbits += 7) {
+		if (subid & testmask) {		/* if any bits set */
 		    mask = testmask;
 		    bits = testbits;
 		}
 	    }
 	    /* mask can't be zero here */
-	    for(;mask != 0x7F; mask >>= 7, bits -= 7){
+	    for (; mask != 0x7F; mask >>= 7, bits -= 7) {
 		/* fix a mask that got truncated above */
-		if (mask == 0x1E00000)  
+		if (mask == 0x1E00000)
 		    mask = 0xFE00000;
-		*bp++ = (u_char)(((subid & mask) >> bits) | ASN_BIT8);
+		*bp++ = (u_char) (((subid & mask) >> bits) | ASN_BIT8);
 	    }
-	    *bp++ = (u_char)(subid & mask);
+	    *bp++ = (u_char) (subid & mask);
 	}
     }
     asnlength = bp - buf;
@@ -702,7 +701,7 @@ asn_build_objid(data, datalength, type, objid, objidlength)
 	return NULL;
     if (*datalength < asnlength)
 	return NULL;
-    bcopy((char *)buf, (char *)data, asnlength);
+    bcopy((char *) buf, (char *) data, asnlength);
     *datalength -= asnlength;
     return data + asnlength;
 }
@@ -719,21 +718,21 @@ asn_build_objid(data, datalength, type, objid, objidlength)
  */
 u_char *
 asn_parse_null(data, datalength, type)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    *type;	    /* OUT - ASN type of object */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - ASN type of object */
 {
 /*
  * ASN.1 null ::= 0x05 0x00
  */
-    u_char   *bufp = data;
-    u_long	    asn_length;
+    u_char *bufp = data;
+    u_long asn_length;
 
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
     if (bufp == NULL)
 	return NULL;
-    if (asn_length != 0){
+    if (asn_length != 0) {
 	ERROR("Malformed NULL");
 	return NULL;
     }
@@ -754,9 +753,9 @@ asn_parse_null(data, datalength, type)
  */
 u_char *
 asn_build_null(data, datalength, type)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	    /* IN - ASN type of object */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - ASN type of object */
 {
 /*
  * ASN.1 null ::= 0x05 0x00
@@ -778,41 +777,41 @@ asn_build_null(data, datalength, type)
  */
 u_char *
 asn_parse_bitstring(data, datalength, type, string, strlength)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    *type;	    /* OUT - asn type of object */
-    u_char	    *string;	    /* IN/OUT - pointer to start of output buffer */
-    int    *strlength;     /* IN/OUT - size of output buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - asn type of object */
+     u_char *string;		/* IN/OUT - pointer to start of output buffer */
+     int *strlength;		/* IN/OUT - size of output buffer */
 {
 /*
  * bitstring ::= 0x03 asnlength unused {byte}*
  */
     u_char *bufp = data;
-    u_long	    asn_length;
+    u_long asn_length;
 
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
     if (bufp == NULL)
 	return NULL;
-    if (asn_length + (bufp - data) > *datalength){
+    if (asn_length + (bufp - data) > *datalength) {
 	ERROR("overflow of message");
 	return NULL;
     }
-    if (asn_length > *strlength){
+    if (asn_length > *strlength) {
 	ERROR("I don't support such long bitstrings");
 	return NULL;
     }
-    if (asn_length < 1){
+    if (asn_length < 1) {
 	ERROR("Invalid bitstring");
 	return NULL;
     }
-    if (/** *bufp < 0 || **/ *bufp > 7){
+    if ( /** *bufp < 0 || **/ *bufp > 7) {
 	ERROR("Invalid bitstring");
 	return NULL;
     }
-    bcopy((char *)bufp, (char *)string, (int)asn_length);
-    *strlength = (int)asn_length;
-    *datalength -= (int)asn_length + (bufp - data);
+    bcopy((char *) bufp, (char *) string, (int) asn_length);
+    *strlength = (int) asn_length;
+    *datalength -= (int) asn_length + (bufp - data);
     return bufp + asn_length;
 }
 
@@ -830,16 +829,16 @@ asn_parse_bitstring(data, datalength, type, string, strlength)
  */
 u_char *
 asn_build_bitstring(data, datalength, type, string, strlength)
-    u_char	    *data;	    /* IN - pointer to start of object */
-    int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	    /* IN - ASN type of string */
-    u_char	    *string;	    /* IN - pointer to start of input buffer */
-    int    strlength;	    /* IN - size of input buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - ASN type of string */
+     u_char *string;		/* IN - pointer to start of input buffer */
+     int strlength;		/* IN - size of input buffer */
 {
 /*
  * ASN.1 bit string ::= 0x03 asnlength unused {byte}*
  */
-    if (strlength < 1 || /** *string < 0 || **/ *string > 7){
+    if (strlength < 1 || /** *string < 0 || **/ *string > 7) {
 	ERROR("Building invalid bitstring");
 	return NULL;
     }
@@ -848,7 +847,7 @@ asn_build_bitstring(data, datalength, type, string, strlength)
 	return NULL;
     if (*datalength < strlength)
 	return NULL;
-    bcopy((char *)string, (char *)data, strlength);
+    bcopy((char *) string, (char *) data, strlength);
     *datalength -= strlength;
     return data + strlength;
 }
@@ -867,45 +866,45 @@ asn_build_bitstring(data, datalength, type, string, strlength)
  */
 u_char *
 asn_parse_unsigned_int64(data, datalength, type, cp, countersize)
-    u_char	    *data;	/* IN - pointer to start of object */
-    int	    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char		    *type;	/* OUT - asn type of object */
-    struct counter64	    *cp;	/* IN/OUT -pointer to counter struct */
-    int			    countersize;/* IN - size of output buffer */
+     u_char *data;		/* IN - pointer to start of object */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char *type;		/* OUT - asn type of object */
+     struct counter64 *cp;	/* IN/OUT -pointer to counter struct */
+     int countersize;		/* IN - size of output buffer */
 {
 /*
  * ASN.1 integer ::= 0x02 asnlength byte {byte}*
  */
     u_char *bufp = data;
-    u_long	    asn_length;
+    u_long asn_length;
     u_long low = 0, high = 0;
     int intsize = 4;
-    
-    if (countersize != sizeof(struct counter64)){
+
+    if (countersize != sizeof(struct counter64)) {
 	ERROR("not counter64 size");
 	return NULL;
     }
     *type = *bufp++;
     bufp = asn_parse_length(bufp, &asn_length);
-    if (bufp == NULL){
+    if (bufp == NULL) {
 	ERROR("bad length");
 	return NULL;
     }
-    if (asn_length + (bufp - data) > *datalength){
+    if (asn_length + (bufp - data) > *datalength) {
 	ERROR("overflow of message");
 	return NULL;
     }
     if ((asn_length > (intsize * 2 + 1)) ||
-	((asn_length == (intsize * 2) + 1) && *bufp != 0x00)){
+	((asn_length == (intsize * 2) + 1) && *bufp != 0x00)) {
 	ERROR("I don't support such large integers");
 	return NULL;
     }
-    *datalength -= (int)asn_length + (bufp - data);
-    if (*bufp & 0x80){
-	low = -1; /* integer is negative */
+    *datalength -= (int) asn_length + (bufp - data);
+    if (*bufp & 0x80) {
+	low = -1;		/* integer is negative */
 	high = -1;
     }
-    while(asn_length--){
+    while (asn_length--) {
 	high = (high << 8) | ((low & 0xFF000000) >> 24);
 	low = (low << 8) | *bufp++;
     }
@@ -927,11 +926,11 @@ asn_parse_unsigned_int64(data, datalength, type, cp, countersize)
  */
 u_char *
 asn_build_unsigned_int64(data, datalength, type, cp, countersize)
-    u_char *data;	/* IN - pointer to start of output buffer */
-    int    *datalength;/* IN/OUT - number of valid bytes left in buffer */
-    u_char	    type;	/* IN - asn type of object */
-    struct counter64 *cp;	/* IN - pointer to counter struct */
-    int    countersize; /* IN - size of *intp */
+     u_char *data;		/* IN - pointer to start of output buffer */
+     int *datalength;		/* IN/OUT - number of valid bytes left in buffer */
+     u_char type;		/* IN - asn type of object */
+     struct counter64 *cp;	/* IN - pointer to counter struct */
+     int countersize;		/* IN - size of *intp */
 {
 /*
  * ASN.1 integer ::= 0x02 asnlength byte {byte}*
@@ -942,7 +941,7 @@ asn_build_unsigned_int64(data, datalength, type, cp, countersize)
     int add_null_byte = 0;
     int intsize;
 
-    if (countersize != sizeof (struct counter64)) {
+    if (countersize != sizeof(struct counter64)) {
 	ERROR("not counter64 size");
 	return NULL;
     }
@@ -951,7 +950,7 @@ asn_build_unsigned_int64(data, datalength, type, cp, countersize)
     high = cp->high;
     mask = 0xFF << (8 * (sizeof(int32) - 1));
     /* mask is 0xFF000000 on a big-endian machine */
-    if ((u_char)((high & mask) >> (8 * (sizeof(int32) - 1))) & 0x80) {
+    if ((u_char) ((high & mask) >> (8 * (sizeof(int32) - 1))) & 0x80) {
 	/* if MSB is set */
 	add_null_byte = 1;
 	intsize++;
@@ -964,8 +963,8 @@ asn_build_unsigned_int64(data, datalength, type, cp, countersize)
      */
     mask2 = 0x1FF << ((8 * (sizeof(int32) - 1)) - 1);
     /* mask2 is 0xFF800000 on a big-endian machine */
-    while((((high & mask2) == 0) || ((high & mask2) == mask2))
-	  && intsize > 1){
+    while ((((high & mask2) == 0) || ((high & mask2) == mask2))
+	&& intsize > 1) {
 	intsize--;
 	high = (high << 8)
 	    | ((low & mask) >> (8 * (sizeof(int32) - 1)));
@@ -977,18 +976,16 @@ asn_build_unsigned_int64(data, datalength, type, cp, countersize)
     if (*datalength < intsize)
 	return NULL;
     *datalength -= intsize;
-    if (add_null_byte == 1){
+    if (add_null_byte == 1) {
 	*data++ = '\0';
 	intsize--;
     }
-    while(intsize--){
-	*data++ = (u_char)((high & mask) >> (8 * (sizeof(int32) - 1)));
+    while (intsize--) {
+	*data++ = (u_char) ((high & mask) >> (8 * (sizeof(int32) - 1)));
 	high = (high << 8)
 	    | ((low & mask) >> (8 * (sizeof(int32) - 1)));
 	low <<= 8;
-	
+
     }
     return data;
 }
-
-
@@ -1,3 +1,4 @@
+
 /**********************************************************************
 	Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University
 
@@ -19,20 +20,9 @@ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
-#include <stdio.h>
-#include <ctype.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <sys/time.h>
 
 #include "squid.h"
 
-#ifdef linux
-#include <stdlib.h>
-#include <string.h>
-#endif
-
-
 #include "asn1.h"
 #include "snmp.h"
 #include "snmp_impl.h"
@@ -54,10 +44,10 @@ static struct tree *get_symbol();
 
 static char *
 uptimeString(timeticks, buf)
-    u_long timeticks;
-    char *buf;
+     u_long timeticks;
+     char *buf;
 {
-    int	seconds, minutes, hours, days;
+    int seconds, minutes, hours, days;
 
     timeticks /= 100;
     days = timeticks / (60 * 60 * 24);
@@ -69,32 +59,32 @@ uptimeString(timeticks, buf)
     minutes = timeticks / 60;
     seconds = timeticks % 60;
 
-    if (days == 0){
-	snprintf(buf,32, "%d:%02d:%02d", hours, minutes, seconds);
+    if (days == 0) {
+	snprintf(buf, 32, "%d:%02d:%02d", hours, minutes, seconds);
     } else if (days == 1) {
-	snprintf(buf,32,  "%d day, %d:%02d:%02d", days, hours, minutes, seconds);
+	snprintf(buf, 32, "%d day, %d:%02d:%02d", days, hours, minutes, seconds);
     } else {
-	snprintf(buf,32, "%d days, %d:%02d:%02d", days, hours, minutes, seconds);
+	snprintf(buf, 32, "%d days, %d:%02d:%02d", days, hours, minutes, seconds);
     }
     return buf;
 }
 
 static void
 sprint_hexstring(buf, cp, len)
-    char *buf;
-    u_char  *cp;
-    int	    len;
+     char *buf;
+     u_char *cp;
+     int len;
 {
 
-    for(; len >= 16; len -= 16){
+    for (; len >= 16; len -= 16) {
 	sprintf(buf, "%02X %02X %02X %02X %02X %02X %02X %02X ", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
 	buf += strlen(buf);
 	cp += 8;
 	sprintf(buf, "%02X %02X %02X %02X %02X %02X %02X %02X\n", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
 	buf += strlen(buf);
 	cp += 8;
     }
-    for(; len > 0; len--){
+    for (; len > 0; len--) {
 	sprintf(buf, "%02X ", *cp++);
 	buf += strlen(buf);
     }
@@ -103,14 +93,14 @@ sprint_hexstring(buf, cp, len)
 
 static void
 sprint_asciistring(buf, cp, len)
-    char *buf;
-    u_char  *cp;
-    int	    len;
+     char *buf;
+     u_char *cp;
+     int len;
 {
-    int	x;
+    int x;
 
-    for(x = 0; x < len; x++){
-	if (isprint(*cp)){
+    for (x = 0; x < len; x++) {
+	if (isprint(*cp)) {
 	    *buf++ = *cp++;
 	} else {
 	    *buf++ = '.';
@@ -127,32 +117,32 @@ sprint_asciistring(buf, cp, len)
 #ifdef UNUSED
 int
 read_rawobjid(input, output, out_len)
-    char *input;
-    oid *output;
-    int	*out_len;
+     char *input;
+     oid *output;
+     int *out_len;
 {
-    char    buf[12], *cp;
-    oid	    *op = output;
-    u_long  subid;
+    char buf[12], *cp;
+    oid *op = output;
+    u_long subid;
 
-    while(*input != '\0'){
+    while (*input != '\0') {
 	if (!isdigit(*input))
 	    break;
 	cp = buf;
-	while(isdigit(*input))
+	while (isdigit(*input))
 	    *cp++ = *input++;
 	*cp = '\0';
 	subid = atoi(buf);
-	if(subid > MAX_SUBID){
+	if (subid > MAX_SUBID) {
 	    fprintf(stderr, "sub-identifier too large: %s\n", buf);
 	    return 0;
 	}
-	if((*out_len)-- <= 0){
+	if ((*out_len)-- <= 0) {
 	    fprintf(stderr, "object identifier too long\n");
 	    return 0;
 	}
 	*op++ = subid;
-	if(*input++ != '.')
+	if (*input++ != '.')
 	    break;
     }
     *out_len = op - output;
@@ -164,49 +154,49 @@ read_rawobjid(input, output, out_len)
 #endif /* UNUSED */
 
 /*
-  0
-  < 4
-  hex
-
-  0 ""
-  < 4 hex Hex: oo oo oo
-  < 4     "fgh" Hex: oo oo oo
-  > 4 hex Hex: oo oo oo oo oo oo oo oo
-  > 4     "this is a test"
-
-  */
+ * 0
+ * < 4
+ * hex
+ * 
+ * 0 ""
+ * < 4 hex Hex: oo oo oo
+ * < 4     "fgh" Hex: oo oo oo
+ * > 4 hex Hex: oo oo oo oo oo oo oo oo
+ * > 4     "this is a test"
+ * 
+ */
 static void
 sprint_octet_string(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
     int hex, x;
     u_char *cp;
 
-    if (var->type != ASN_OCTET_STR){
+    if (var->type != ASN_OCTET_STR) {
 	sprintf(buf, "Wrong Type (should be OCTET STRING): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     hex = 0;
-    for(cp = var->val.string, x = 0; x < var->val_len; x++, cp++){
+    for (cp = var->val.string, x = 0; x < var->val_len; x++, cp++) {
 	if (!(isprint(*cp) || isspace(*cp)))
 	    hex = 1;
     }
-    if (var->val_len == 0){
+    if (var->val_len == 0) {
 	strcpy(buf, "\"\"");
 	return;
     }
-    if (!hex){
+    if (!hex) {
 	*buf++ = '"';
 	sprint_asciistring(buf, var->val.string, var->val_len);
 	buf += strlen(buf);
 	*buf++ = '"';
 	*buf = '\0';
     }
-    if (hex || var->val_len <= 4){
+    if (hex || var->val_len <= 4) {
 	sprintf(buf, " Hex: ");
 	buf += strlen(buf);
 	sprint_hexstring(buf, var->val.string, var->val_len);
@@ -215,15 +205,15 @@ sprint_octet_string(buf, var, enums)
 
 static void
 sprint_opaque(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
 
-    if (var->type != OPAQUE){
+    if (var->type != OPAQUE) {
 	sprintf(buf, "Wrong Type (should be Opaque): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "OPAQUE: ");
@@ -233,55 +223,55 @@ sprint_opaque(buf, var, enums)
 
 static void
 sprint_object_identifier(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != ASN_OBJECT_ID){
+    if (var->type != ASN_OBJECT_ID) {
 	sprintf(buf, "Wrong Type (should be OBJECT IDENTIFIER): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "OID: ");
     buf += strlen(buf);
-    sprint_objid(buf, (oid *)(var->val.objid), var->val_len / sizeof(oid));
+    sprint_objid(buf, (oid *) (var->val.objid), var->val_len / sizeof(oid));
 }
 
 static void
 sprint_timeticks(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
     char timebuf[32];
 
-    if (var->type != TIMETICKS){
+    if (var->type != TIMETICKS) {
 	sprintf(buf, "Wrong Type (should be Timeticks): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
-    sprintf(buf, "Timeticks: (%ld) %s", *(u_long *)(var->val.integer), 
-	    uptimeString(*(u_long *)(var->val.integer), timebuf));
+    sprintf(buf, "Timeticks: (%ld) %s", *(u_long *) (var->val.integer),
+	uptimeString(*(u_long *) (var->val.integer), timebuf));
 }
 
 static void
 sprint_integer(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    char    *enum_string = NULL;
+    char *enum_string = NULL;
 
-    if (var->type != ASN_INTEGER){
+    if (var->type != ASN_INTEGER) {
 	sprintf(buf, "Wrong Type (should be INTEGER): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     for (; enums; enums = enums->next)
-	if (enums->value == *var->val.integer){
+	if (enums->value == *var->val.integer) {
 	    enum_string = enums->label;
 	    break;
 	}
@@ -293,20 +283,20 @@ sprint_integer(buf, var, enums)
 
 static void
 sprint_uinteger(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    char    *enum_string = NULL;
+    char *enum_string = NULL;
 
-    if (var->type != UINTEGER){
+    if (var->type != UINTEGER) {
 	sprintf(buf, "Wrong Type (should be UInteger32): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     for (; enums; enums = enums->next)
-	if (enums->value == *var->val.integer){
+	if (enums->value == *var->val.integer) {
 	    enum_string = enums->label;
 	    break;
 	}
@@ -318,48 +308,48 @@ sprint_uinteger(buf, var, enums)
 
 static void
 sprint_gauge(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != GAUGE){
+    if (var->type != GAUGE) {
 	sprintf(buf, "Wrong Type (should be Gauge): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "Gauge: %lu", *var->val.integer);
 }
 
 static void
 sprint_counter(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != COUNTER){
+    if (var->type != COUNTER) {
 	sprintf(buf, "Wrong Type (should be Counter): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "%lu", *var->val.integer);
 }
 
 static void
 sprint_networkaddress(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
     int x, len;
     u_char *cp;
 
     sprintf(buf, "Network Address: ");
     buf += strlen(buf);
-    cp = var->val.string;    
+    cp = var->val.string;
     len = var->val_len;
-    for(x = 0; x < len; x++){
+    for (x = 0; x < len; x++) {
 	sprintf(buf, "%02X", *cp++);
 	buf += strlen(buf);
 	if (x < (len - 1))
@@ -369,33 +359,33 @@ sprint_networkaddress(buf, var, enums)
 
 static void
 sprint_ipaddress(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
     u_char *ip;
 
-    if (var->type != IPADDRESS){
+    if (var->type != IPADDRESS) {
 	sprintf(buf, "Wrong Type (should be Ipaddress): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     ip = var->val.string;
-    sprintf(buf, "IpAddress: %d.%d.%d.%d",ip[0], ip[1], ip[2], ip[3]);
+    sprintf(buf, "IpAddress: %d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
 }
 
 #if 0
 static void
 sprint_unsigned_short(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != ASN_INTEGER){
+    if (var->type != ASN_INTEGER) {
 	sprintf(buf, "Wrong Type (should be INTEGER): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "INT: %lu", *var->val.integer);
@@ -404,33 +394,33 @@ sprint_unsigned_short(buf, var, enums)
 
 static void
 sprint_null(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != ASN_NULL){
+    if (var->type != ASN_NULL) {
 	sprintf(buf, "Wrong Type (should be NULL): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "NULL");
 }
 
 static void
 sprint_bitstring(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
     int len, bit;
     u_char *cp;
     char *enum_string;
 
-    if (var->type != ASN_BIT_STR){
+    if (var->type != ASN_BIT_STR) {
 	sprintf(buf, "Wrong Type (should be BIT STRING): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "BIT_STRING: ");
@@ -439,12 +429,12 @@ sprint_bitstring(buf, var, enums)
     buf += strlen(buf);
 
     cp = var->val.bitstring + 1;
-    for(len = 0; len < var->val_len - 1; len++){
-	for(bit = 0; bit < 8; bit++){
-	    if (*cp & (0x80 >> bit)){
+    for (len = 0; len < var->val_len - 1; len++) {
+	for (bit = 0; bit < 8; bit++) {
+	    if (*cp & (0x80 >> bit)) {
 		enum_string = NULL;
 		for (; enums; enums = enums->next)
-		    if (enums->value == (len * 8) + bit){
+		    if (enums->value == (len * 8) + bit) {
 			enum_string = enums->label;
 			break;
 		    }
@@ -455,20 +445,20 @@ sprint_bitstring(buf, var, enums)
 		buf += strlen(buf);
 	    }
 	}
-	cp ++;	    
+	cp++;
     }
 }
 
 static void
 sprint_nsapaddress(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != NSAP){
+    if (var->type != NSAP) {
 	sprintf(buf, "Wrong Type (should be NsapAddress): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
     sprintf(buf, "NsapAddress: ");
@@ -478,93 +468,94 @@ sprint_nsapaddress(buf, var, enums)
 
 static void
 sprint_counter64(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    if (var->type != COUNTER64){
+    if (var->type != COUNTER64) {
 	sprintf(buf, "Wrong Type (should be Counter64): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL);
+	sprint_by_type(buf, var, (struct enum_list *) NULL);
 	return;
     }
 /* XXX */
     sprintf(buf, "Counter64: ");
     buf += strlen(buf);
-    
+
     sprint_hexstring(buf, &var->val.counter64->high,
-		     sizeof(var->val.counter64->high));
+	sizeof(var->val.counter64->high));
     buf += strlen(buf);
     sprint_hexstring(buf, &var->val.counter64->low,
-		     sizeof(var->val.counter64->low));
+	sizeof(var->val.counter64->low));
 }
 
 
 static void
 sprint_unknowntype(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
 /*    sprintf(buf, "Variable has bad type"); */
     sprint_by_type(buf, var, NULL);
 }
 
 static void
 sprint_badtype(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
     sprintf(buf, "Variable has bad type");
 }
 
 static void
 sprint_by_type(buf, var, enums)
-    char *buf;
-    struct variable_list *var;
-    struct enum_list	    *enums;
+     char *buf;
+     struct variable_list *var;
+     struct enum_list *enums;
 {
-    switch (var->type){
-	case ASN_INTEGER:
-	    sprint_integer(buf, var, enums);
-	    break;
-	case ASN_OCTET_STR:
-	    sprint_octet_string(buf, var, enums);
-	    break;
-	case OPAQUE:
-	    sprint_opaque(buf, var, enums);
-	    break;
-	case ASN_OBJECT_ID:
-	    sprint_object_identifier(buf, var, enums);
-	    break;
-	case TIMETICKS:
-	    sprint_timeticks(buf, var, enums);
-	    break;
-	case GAUGE:
-	    sprint_gauge(buf, var, enums);
-	    break;
-	case COUNTER:
-	    sprint_counter(buf, var, enums);
-	    break;
-	case IPADDRESS:
-	    sprint_ipaddress(buf, var, enums);
-	    break;
-	case ASN_NULL:
-	    sprint_null(buf, var, enums);
-	    break;
-	case UINTEGER:
-	    sprint_uinteger(buf, var, enums);
-	    break;
-	default:
-	    sprint_badtype(buf, var, enums);
-	    break;
+    switch (var->type) {
+    case ASN_INTEGER:
+	sprint_integer(buf, var, enums);
+	break;
+    case ASN_OCTET_STR:
+	sprint_octet_string(buf, var, enums);
+	break;
+    case OPAQUE:
+	sprint_opaque(buf, var, enums);
+	break;
+    case ASN_OBJECT_ID:
+	sprint_object_identifier(buf, var, enums);
+	break;
+    case TIMETICKS:
+	sprint_timeticks(buf, var, enums);
+	break;
+    case GAUGE:
+	sprint_gauge(buf, var, enums);
+	break;
+    case COUNTER:
+	sprint_counter(buf, var, enums);
+	break;
+    case IPADDRESS:
+	sprint_ipaddress(buf, var, enums);
+	break;
+    case ASN_NULL:
+	sprint_null(buf, var, enums);
+	break;
+    case UINTEGER:
+	sprint_uinteger(buf, var, enums);
+	break;
+    default:
+	sprint_badtype(buf, var, enums);
+	break;
     }
 }
 
 struct tree *get_symbol();
 
-oid RFC1213_MIB[] = { 1, 3, 6, 1, 2, 1 };
+oid RFC1213_MIB[] =
+{1, 3, 6, 1, 2, 1};
 unsigned char RFC1213_MIB_text[] = ".iso.org.dod.internet.mgmt.mib-2";
 unsigned char EXPERIMENTAL_MIB_text[] = ".iso.org.dod.internet.experimental";
 unsigned char PRIVATE_MIB_text[] = ".iso.org.dod.internet.private";
@@ -588,26 +579,24 @@ init_mib()
     if (!Mib)
 	Mib = read_mib("mib.txt");
 #ifdef MIBFILEPATH
-    if (!Mib)
-      {
-	char tmp [1024];
-	sprintf (tmp, "%s/mib.txt", MIBFILEPATH);
+    if (!Mib) {
+	char tmp[1024];
+	sprintf(tmp, "%s/mib.txt", MIBFILEPATH);
 	Mib = read_mib(tmp);
-      }
+    }
 #endif
     if (!Mib)
 	Mib = read_mib("/etc/mib.txt");
-    if (!Mib){
+    if (!Mib) {
 	fprintf(stderr, "Couldn't find mib file\n");
 	exit(2);
     }
     prefix = getenv("PREFIX");
-    if (! prefix) {
-      prefix = Standard_Prefix;
+    if (!prefix) {
+	prefix = Standard_Prefix;
     }
-
     /* save prefix: */
-    snmp_new_prefix (prefix);
+    snmp_new_prefix(prefix);
 
     if (getenv("SUFFIX"))
 	Suffix = TRUE;
@@ -626,82 +615,84 @@ init_mib()
  */
 
 char *
-snmp_new_prefix (char *prefix) 
+snmp_new_prefix(char *prefix)
 {
-  char *lastchar;
-  int  plen;
-
-  if (prefix) {
-    lastchar = ".";   
-    if (*prefix == '.') { prefix++; }
-    if ((plen = strlen (prefix))) {
-      lastchar = prefix + plen - 1; 
-    }
-    strncpy (Prefix, prefix, sizeof (Prefix) - 2);
-    Prefix [sizeof (Prefix) - 2] = 0;
-    if (*lastchar != '.') {
-      Prefix [plen++] = '.';
-      Prefix [plen] = 0;
+    char *lastchar;
+    int plen;
+
+    if (prefix) {
+	lastchar = ".";
+	if (*prefix == '.') {
+	    prefix++;
+	}
+	if ((plen = strlen(prefix))) {
+	    lastchar = prefix + plen - 1;
+	}
+	strncpy(Prefix, prefix, sizeof(Prefix) - 2);
+	Prefix[sizeof(Prefix) - 2] = 0;
+	if (*lastchar != '.') {
+	    Prefix[plen++] = '.';
+	    Prefix[plen] = 0;
+	}
+	return Prefix;
     }
-    return Prefix;
-  }
-  return (char *)NULL;
+    return (char *) NULL;
 }
 
 
 
 static void
 set_functions(subtree)
-    struct tree *subtree;
+     struct tree *subtree;
 {
-    for(; subtree; subtree = subtree->next_peer){
-	switch(subtree->type){
-	    case TYPE_OBJID:
-		subtree->printer = sprint_object_identifier;
-		break;
-	    case TYPE_OCTETSTR:
-		subtree->printer = sprint_octet_string;
-		break;
-	    case TYPE_INTEGER:
-		subtree->printer = sprint_integer;
-		break;
-	    case TYPE_NETADDR:
-		subtree->printer = sprint_networkaddress;
-		break;
-	    case TYPE_IPADDR:
-		subtree->printer = sprint_ipaddress;
-		break;
-	    case TYPE_COUNTER:
-		subtree->printer = sprint_counter;
-		break;
-	    case TYPE_GAUGE:
-		subtree->printer = sprint_gauge;
-		break;
-	    case TYPE_TIMETICKS:
-		subtree->printer = sprint_timeticks;
-		break;
-	    case TYPE_OPAQUE:
-		subtree->printer = sprint_opaque;
-		break;
-	    case TYPE_NULL:
-		subtree->printer = sprint_null;
-		break;
-	    case TYPE_BITSTRING:
-		subtree->printer = sprint_bitstring;
-		break;
-	    case TYPE_NSAPADDRESS:
-		subtree->printer = sprint_nsapaddress;
-		break;
-	    case TYPE_COUNTER64:
-		subtree->printer = sprint_counter64;
-		break;
-	    case TYPE_UINTEGER:
-		subtree->printer = sprint_uinteger;
-		break;
-	    case TYPE_OTHER:
-	    default:
-		subtree->printer = sprint_unknowntype;
-		break;
+    for (; subtree; subtree = subtree->next_peer) {
+	switch (subtree->type) {
+	case TYPE_OBJID:
+	    subtree->printer = sprint_object_identifier;
+	    break;
+	case TYPE_OCTETSTR:
+	    subtree->printer = sprint_octet_string;
+	    break;
+	case TYPE_INTEGER:
+	    subtree->printer = sprint_integer;
+	    break;
+	case TYPE_NETADDR:
+	    subtree->printer = sprint_networkaddress;
+	    break;
+	case TYPE_IPADDR:
+	    subtree->printer = sprint_ipaddress;
+	    break;
+	case TYPE_COUNTER:
+	    subtree->printer = sprint_counter;
+	    break;
+	case TYPE_GAUGE:
+	    subtree->printer = sprint_gauge;
+	    break;
+	case TYPE_TIMETICKS:
+	    subtree->printer = sprint_timeticks;
+	    break;
+	case TYPE_OPAQUE:
+	    subtree->printer = sprint_opaque;
+	    break;
+	case TYPE_NULL:
+	    subtree->printer = sprint_null;
+	    break;
+	case TYPE_BITSTRING:
+	    subtree->printer = sprint_bitstring;
+	    break;
+	case TYPE_NSAPADDRESS:
+	    subtree->printer = sprint_nsapaddress;
+	    break;
+	case TYPE_COUNTER64:
+	    subtree->printer = sprint_counter64;
+	    break;
+	case TYPE_UINTEGER:
+	    subtree->printer = sprint_uinteger;
+	    break;
+	case TYPE_OTHER:
+	default:
+	    subtree->printer = sprint_unknowntype;
+	    break;
 	}
 	set_functions(subtree->child_list);
     }
@@ -715,7 +706,7 @@ main(argc, argv)
      char *argv[];
 {
     oid objid[64];
-    int objidlen = sizeof (objid);
+    int objidlen = sizeof(objid);
     int count;
     struct variable variable;
 
@@ -726,31 +717,31 @@ main(argc, argv)
     variable.val.integer = 3;
     variable.val_len = 4;
     for (argc--; argc; argc--, argv++) {
-	objidlen = sizeof (objid);
+	objidlen = sizeof(objid);
 	printf("read_objid(%s) = %d\n",
-	       argv[1], read_objid(argv[1], objid, &objidlen));
-	for(count = 0; count < objidlen; count++)
+	    argv[1], read_objid(argv[1], objid, &objidlen));
+	for (count = 0; count < objidlen; count++)
 	    printf("%d.", objid[count]);
 	printf("\n");
 	print_variable(objid, objidlen, &variable);
     }
 }
 
-#endif testing
+#endif	/* testing */
 
 
 #if 0
 static struct tree *
 find_rfc1213_mib(root)
-    struct tree *root;
+     struct tree *root;
 {
     oid *op = RFC1213_MIB;
     struct tree *tp;
     int len;
 
-    for(len = sizeof(RFC1213_MIB)/sizeof(oid); len; len--, op++){
-	for(tp = root; tp; tp = tp->next_peer){
-	    if (tp->subid == *op){
+    for (len = sizeof(RFC1213_MIB) / sizeof(oid); len; len--, op++) {
+	for (tp = root; tp; tp = tp->next_peer) {
+	    if (tp->subid == *op) {
 		root = tp->child_list;
 		break;
 	    }
@@ -762,42 +753,44 @@ find_rfc1213_mib(root)
 }
 #endif
 
-int read_objid(input, output, out_len)
-    char *input;
-    oid *output;
-    int	*out_len;   /* number of subid's in "output" */
+int 
+read_objid(input, output, out_len)
+     char *input;
+     oid *output;
+     int *out_len;		/* number of subid's in "output" */
 {
     struct tree *root = Mib;
     oid *op = output;
     char buf[512];
 
-    bzero (buf, sizeof(buf));
+    bzero(buf, sizeof(buf));
 
     if (*input == '.')
 	input++;
     else {
-        strcpy(buf, Prefix);
+	strcpy(buf, Prefix);
 	strcat(buf, input);
 	input = buf;
     }
 
-    if (root == NULL){
+    if (root == NULL) {
 	fprintf(stderr, "Mib not initialized.  Exiting.\n");
 	exit(1);
     }
     if ((*out_len =
-	 parse_subtree(root, input, output, out_len)) == 0)
+	    parse_subtree(root, input, output, out_len)) == 0)
 	return (0);
     *out_len += output - op;
 
     return (1);
 }
 
 #ifdef notdef
-int read_objid(input, output, out_len)
-    char *input;
-    oid *output;
-    int	*out_len;   /* number of subid's in "output" */
+int 
+read_objid(input, output, out_len)
+     char *input;
+     oid *output;
+     int *out_len;		/* number of subid's in "output" */
 {
     struct tree *root = Mib;
     oid *op = output;
@@ -807,7 +800,7 @@ int read_objid(input, output, out_len)
 	input++;
     else {
 	root = find_rfc1213_mib(root);
-	for (i = 0; i < sizeof (RFC1213_MIB)/sizeof(oid); i++) {
+	for (i = 0; i < sizeof(RFC1213_MIB) / sizeof(oid); i++) {
 	    if ((*out_len)-- > 0)
 		*output++ = RFC1213_MIB[i];
 	    else {
@@ -817,12 +810,12 @@ int read_objid(input, output, out_len)
 	}
     }
 
-    if (root == NULL){
+    if (root == NULL) {
 	fprintf(stderr, "Mib not initialized.  Exiting.\n");
 	exit(1);
     }
     if ((*out_len =
-	 parse_subtree(root, input, output, out_len)) == 0)
+	    parse_subtree(root, input, output, out_len)) == 0)
 	return (0);
     *out_len += output - op;
 
@@ -832,10 +825,10 @@ int read_objid(input, output, out_len)
 
 static int
 parse_subtree(subtree, input, output, out_len)
-    struct tree *subtree;
-    char *input;
-    oid	*output;
-    int	*out_len;   /* number of subid's */
+     struct tree *subtree;
+     char *input;
+     oid *output;
+     int *out_len;		/* number of subid's */
 {
     char buf[128], *to = buf;
     u_long subid = 0;
@@ -862,13 +855,12 @@ parse_subtree(subtree, input, output, out_len)
 		goto found;
 	}
 	tp = NULL;
-    }
-    else {
+    } else {
 	/*
 	 * Read the name into a buffer.
 	 */
 	while ((*input != '\0') &&
-	       (*input != '.')) {
+	    (*input != '.')) {
 	    *to++ = *input++;
 	}
 	*to = '\0';
@@ -892,13 +884,12 @@ parse_subtree(subtree, input, output, out_len)
 	}
     }
 
-found:
-    if(subid > (u_long)MAX_SUBID){
+  found:
+    if (subid > (u_long) MAX_SUBID) {
 	fprintf(stderr, "sub-identifier too large: %s\n", buf);
 	return (0);
     }
-
-    if ((*out_len)-- <= 0){
+    if ((*out_len)-- <= 0) {
 	fprintf(stderr, "object identifier too long\n");
 	return (0);
     }
@@ -907,31 +898,30 @@ parse_subtree(subtree, input, output, out_len)
     if (*input != '.')
 	return (1);
     if ((*out_len =
-	 parse_subtree(tp ? tp->child_list : NULL, ++input, output, out_len)) == 0)
+	    parse_subtree(tp ? tp->child_list : NULL, ++input, output, out_len)) == 0)
 	return (0);
     return (++*out_len);
 }
 
 void
 sprint_objid(buf, objid, objidlen)
-    char *buf;
-    oid	    *objid;
-    int	    objidlen;	/* number of subidentifiers */
+     char *buf;
+     oid *objid;
+     int objidlen;		/* number of subidentifiers */
 {
-    char    tempbuf[2048], *cp;
-    struct tree    *subtree = Mib;
+    char tempbuf[2048], *cp;
+    struct tree *subtree = Mib;
 
-    *tempbuf = '.';	/* this is a fully qualified name */
+    *tempbuf = '.';		/* this is a fully qualified name */
     get_symbol(objid, objidlen, subtree, tempbuf + 1);
-    if (Suffix){
-	for(cp =tempbuf; *cp; cp++)
-	    ;
-	while(cp >= tempbuf){
+    if (Suffix) {
+	for (cp = tempbuf; *cp; cp++);
+	while (cp >= tempbuf) {
 	    if (isalpha(*cp))
 		break;
 	    cp--;
 	}
-	while(cp >= tempbuf){
+	while (cp >= tempbuf) {
 	    if (*cp == '.')
 		break;
 	    cp--;
@@ -942,30 +932,30 @@ sprint_objid(buf, objid, objidlen)
 
     } else {
 	cp = tempbuf;
-	if ((strlen(tempbuf) > strlen((char *)RFC1213_MIB_text))
-	    && !bcmp(tempbuf, (char *)RFC1213_MIB_text,
-		     strlen((char *)RFC1213_MIB_text))){
+	if ((strlen(tempbuf) > strlen((char *) RFC1213_MIB_text))
+	    && !bcmp(tempbuf, (char *) RFC1213_MIB_text,
+		strlen((char *) RFC1213_MIB_text))) {
 	    cp += sizeof(RFC1213_MIB_text);
 	}
-	if ((strlen(tempbuf) > strlen((char *)EXPERIMENTAL_MIB_text))
+	if ((strlen(tempbuf) > strlen((char *) EXPERIMENTAL_MIB_text))
 	    && !bcmp(tempbuf, (char *) EXPERIMENTAL_MIB_text,
-		     strlen((char *)EXPERIMENTAL_MIB_text))){
-            cp += sizeof(EXPERIMENTAL_MIB_text);
+		strlen((char *) EXPERIMENTAL_MIB_text))) {
+	    cp += sizeof(EXPERIMENTAL_MIB_text);
 	}
-	if ((strlen(tempbuf) > strlen((char *)PRIVATE_MIB_text))
+	if ((strlen(tempbuf) > strlen((char *) PRIVATE_MIB_text))
 	    && !bcmp(tempbuf, (char *) PRIVATE_MIB_text,
-		     strlen((char *)PRIVATE_MIB_text))){
-            cp += sizeof(PRIVATE_MIB_text);
+		strlen((char *) PRIVATE_MIB_text))) {
+	    cp += sizeof(PRIVATE_MIB_text);
 	}
-	if ((strlen(tempbuf) > strlen((char *)PARTY_MIB_text))
+	if ((strlen(tempbuf) > strlen((char *) PARTY_MIB_text))
 	    && !bcmp(tempbuf, (char *) PARTY_MIB_text,
-		     strlen((char *)PARTY_MIB_text))){
-            cp += sizeof(PARTY_MIB_text);
+		strlen((char *) PARTY_MIB_text))) {
+	    cp += sizeof(PARTY_MIB_text);
 	}
-	if ((strlen(tempbuf) > strlen((char *)SECRETS_MIB_text))
+	if ((strlen(tempbuf) > strlen((char *) SECRETS_MIB_text))
 	    && !bcmp(tempbuf, (char *) SECRETS_MIB_text,
-		     strlen((char *)SECRETS_MIB_text))){
-            cp += sizeof(SECRETS_MIB_text);
+		strlen((char *) SECRETS_MIB_text))) {
+	    cp += sizeof(SECRETS_MIB_text);
 	}
     }
     strcpy(buf, cp);
@@ -974,10 +964,10 @@ sprint_objid(buf, objid, objidlen)
 
 void
 print_objid(objid, objidlen)
-    oid	    *objid;
-    int	    objidlen;	/* number of subidentifiers */
+     oid *objid;
+     int objidlen;		/* number of subidentifiers */
 {
-    char    buf[256];
+    char buf[256];
 
     sprint_objid(buf, objid, objidlen);
     printf("%s\n", buf);
@@ -986,25 +976,25 @@ print_objid(objid, objidlen)
 
 void
 print_variable(objid, objidlen, variable)
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *variable;
+     oid *objid;
+     int objidlen;
+     struct variable_list *variable;
 {
-    char    buf[2048];
+    char buf[2048];
 
     sprint_variable(buf, objid, objidlen, variable);
     printf("%s", buf);
 }
 
 static void
 sprint_variable(buf, objid, objidlen, variable)
-    char *buf;
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *variable;
+     char *buf;
+     oid *objid;
+     int objidlen;
+     struct variable_list *variable;
 {
-    char    tempbuf[2048];
-    struct tree    *subtree = Mib;
+    char tempbuf[2048];
+    struct tree *subtree = Mib;
 
     sprint_objid(buf, objid, objidlen);
     buf += strlen(buf);
@@ -1018,11 +1008,11 @@ sprint_variable(buf, objid, objidlen, variable)
     else if (variable->type == SNMP_ENDOFMIBVIEW)
 	sprintf(buf, "No more variables left in this MIB View\n");
     else {
-	*tempbuf = '.';	/* this is a fully qualified name */
+	*tempbuf = '.';		/* this is a fully qualified name */
 	subtree = get_symbol(objid, objidlen, subtree, tempbuf + 1);
 	buf += strlen(buf);
 	if (subtree->printer)
-	    (*subtree->printer)(buf, variable, subtree->enums);
+	    (*subtree->printer) (buf, variable, subtree->enums);
 	else {
 	    sprint_by_type(buf, variable, subtree->enums);
 	}
@@ -1032,13 +1022,13 @@ sprint_variable(buf, objid, objidlen, variable)
 
 void
 sprint_value(buf, objid, objidlen, variable)
-    char *buf;
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *variable;
+     char *buf;
+     oid *objid;
+     int objidlen;
+     struct variable_list *variable;
 {
-    char    tempbuf[2048];
-    struct tree    *subtree = Mib;
+    char tempbuf[2048];
+    struct tree *subtree = Mib;
 
     if (variable->type == SNMP_NOSUCHOBJECT)
 	sprintf(buf, "No Such Object available on this agent\n");
@@ -1049,7 +1039,7 @@ sprint_value(buf, objid, objidlen, variable)
     else {
 	subtree = get_symbol(objid, objidlen, subtree, tempbuf);
 	if (subtree->printer)
-	    (*subtree->printer)(buf, variable, subtree->enums);
+	    (*subtree->printer) (buf, variable, subtree->enums);
 	else {
 	    sprint_by_type(buf, variable, subtree->enums);
 	}
@@ -1058,50 +1048,50 @@ sprint_value(buf, objid, objidlen, variable)
 
 void
 print_value(objid, objidlen, variable)
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *variable;
+     oid *objid;
+     int objidlen;
+     struct variable_list *variable;
 {
-    char    tempbuf[2048];
+    char tempbuf[2048];
 
     sprint_value(tempbuf, objid, objidlen, variable);
     printf("%s\n", tempbuf);
 }
 
 static struct tree *
 get_symbol(objid, objidlen, subtree, buf)
-    oid	    *objid;
-    int	    objidlen;
-    struct tree    *subtree;
-    char    *buf;
+     oid *objid;
+     int objidlen;
+     struct tree *subtree;
+     char *buf;
 {
-    struct tree    *return_tree = NULL;
+    struct tree *return_tree = NULL;
 
-    for(; subtree; subtree = subtree->next_peer){
-	if (*objid == subtree->subid){
+    for (; subtree; subtree = subtree->next_peer) {
+	if (*objid == subtree->subid) {
 	    strcpy(buf, subtree->label);
 	    goto found;
 	}
     }
 
     /* subtree not found */
-    while(objidlen--){	/* output rest of name, uninterpreted */
+    while (objidlen--) {	/* output rest of name, uninterpreted */
 	sprintf(buf, "%lu.", *objid++);
-	while(*buf)
+	while (*buf)
 	    buf++;
     }
-    *(buf - 1) = '\0'; /* remove trailing dot */
+    *(buf - 1) = '\0';		/* remove trailing dot */
     return NULL;
 
-found:
-    if (objidlen > 1){
-	while(*buf)
+  found:
+    if (objidlen > 1) {
+	while (*buf)
 	    buf++;
 	*buf++ = '.';
 	*buf = '\0';
 	return_tree = get_symbol(objid + 1, objidlen - 1, subtree->child_list,
-				 buf);
-    } 
+	    buf);
+    }
     if (return_tree != NULL)
 	return return_tree;
     else
@@ -1111,11 +1101,11 @@ get_symbol(objid, objidlen, subtree, buf)
 
 static int
 lc_cmp(s1, s2)
-    char *s1, *s2;
+     char *s1, *s2;
 {
     char c1, c2;
 
-    while(*s1 && *s2){
+    while (*s1 && *s2) {
 	if (isupper(*s1))
 	    c1 = tolower(*s1);
 	else
@@ -1142,70 +1132,70 @@ lc_cmp(s1, s2)
  */
 static struct tree *
 get_tree(objid, objidlen, subtree)
-    oid     *objid;
-    int     objidlen;
-    struct tree    *subtree;
+     oid *objid;
+     int objidlen;
+     struct tree *subtree;
 {
-    struct tree    *return_tree = NULL;
+    struct tree *return_tree = NULL;
 
-    for(; subtree; subtree = subtree->next_peer){
-        if (*objid == subtree->subid)
-            goto found;
+    for (; subtree; subtree = subtree->next_peer) {
+	if (*objid == subtree->subid)
+	    goto found;
     }
 
     return NULL;
 
-found:
+  found:
     if (objidlen > 1)
-        return_tree = get_tree(objid + 1, objidlen - 1, subtree->child_list);
+	return_tree = get_tree(objid + 1, objidlen - 1, subtree->child_list);
     if (return_tree != NULL)
-        return return_tree;
+	return return_tree;
     else
-        return subtree;
+	return subtree;
 }
 
 
 #if 0
 static char *
 get_description(objid, objidlen)
-    oid     *objid;
-    int     objidlen;   /* number of subidentifiers */
+     oid *objid;
+     int objidlen;		/* number of subidentifiers */
 {
-    struct tree    *subtree = Mib;
+    struct tree *subtree = Mib;
 
     subtree = get_tree(objid, objidlen, subtree);
     if (subtree)
-        return (subtree->description);
+	return (subtree->description);
     else
-        return NULL;
+	return NULL;
 }
 #endif
 
 
 #if 0
 static void
 print_description(objid, objidlen)
-    oid     *objid;
-    int     objidlen;   /* number of subidentifiers */
+     oid *objid;
+     int objidlen;		/* number of subidentifiers */
 {
     char *desc = get_description(objid, objidlen);
 
     if (desc && desc[0] != '\0')
-        printf("Description: \"%s\"\n", desc);
+	printf("Description: \"%s\"\n", desc);
     else
-        printf("No description\n");
+	printf("No description\n");
 }
 #endif
 
 
 static struct tree *
 find_node(name, subtree)
-    char *name;
-    struct tree *subtree;
+     char *name;
+     struct tree *subtree;
 {
     struct tree *tp, *ret;
 
-    for(tp = subtree; tp; tp = tp->next_peer){
+    for (tp = subtree; tp; tp = tp->next_peer) {
 	if (!strcasecmp(name, tp->label))
 	    return tp;
 	ret = find_node(name, tp->child_list);
@@ -1219,16 +1209,16 @@ find_node(name, subtree)
 #if 0
 static int
 get_node(name, objid, objidlen)
-    char *name;
-    oid *objid;
-    int *objidlen;
+     char *name;
+     oid *objid;
+     int *objidlen;
 {
     struct tree *tp;
     oid newname[64], *op;
 
     tp = find_node(name, Mib);
-    if (tp){
-	for(op = newname + 63; op >= newname; op--){
+    if (tp) {
+	for (op = newname + 63; op >= newname; op--) {
 	    *op = tp->subid;
 	    tp = tp->parent;
 	    if (tp == NULL)
@@ -1243,6 +1233,6 @@ get_node(name, objid, objidlen)
 	return 0;
     }
 
-    
+
 }
 #endif
@@ -49,7 +49,7 @@ struct subid {
 
 /* use large token buffer in case of very long tokens: */
 #define MAXTC	1024
-struct tc {	/* textual conventions */
+struct tc {			/* textual conventions */
     int type;
     char descriptor[MAXTOKEN];
     struct enum_list *enums;
@@ -61,7 +61,7 @@ int Line = 1;
 
 #define SYNTAX_MASK	0x80
 /* types of tokens
- Tokens wiht the SYNTAX_MASK bit set are syntax tokens */
+ * Tokens wiht the SYNTAX_MASK bit set are syntax tokens */
 #define	CONTINUE    -1
 #define ENDOFFILE   0
 #define LABEL	    1
@@ -78,7 +78,7 @@ int Line = 1;
 #define OPAQUE	    (12 | SYNTAX_MASK)
 #define NUL	    (13 | SYNTAX_MASK)
 #define SEQUENCE    14
-#define OF	    15	/* SEQUENCE OF */
+#define OF	    15		/* SEQUENCE OF */
 #define OBJTYPE	    16
 #define ACCESS	    17
 #define READONLY    18
@@ -126,85 +126,86 @@ int Line = 1;
 #define SEMI        60
 
 struct tok {
-	char *name;			/* token name */
-	int len;			/* length not counting nul */
-	int token;			/* value */
-	int hash;			/* hash of name */
-	struct tok *next;		/* pointer to next in hash table */
+    char *name;			/* token name */
+    int len;			/* length not counting nul */
+    int token;			/* value */
+    int hash;			/* hash of name */
+    struct tok *next;		/* pointer to next in hash table */
 };
 
 
-struct tok tokens[] = {
-	{ "obsolete", sizeof ("obsolete")-1, OBSOLETE },
-	{ "Opaque", sizeof ("Opaque")-1, OPAQUE },
-/*	{ "recommended", sizeof("recommended")-1, RECOMMENDED },  */
-	{ "optional", sizeof ("optional")-1, OPTIONAL },
-	{ "LAST-UPDATED", sizeof ("LAST-UPDATED")-1, LASTUPDATED },
-	{ "ORGANIZATION", sizeof ("ORGANIZATION")-1, ORGANIZATION },
-	{ "CONTACT-INFO", sizeof ("CONTACT-INFO")-1, CONTACTINFO },
-	{ "MODULE-IDENTITY", sizeof ("MODULE-IDENTITY")-1, MODULEIDENTITY },
-	{ "MODULE-COMPLIANCE", sizeof ("MODULE-COMPLIANCE")-1, COMPLIANCE },
-        { "DEFINITIONS", sizeof("DEFINITIONS")-1, DEFINITIONS},
-        { "END", sizeof("END")-1, END},
-        { ";", sizeof(";")-1, SEMI},
-	{ "AUGMENTS", sizeof ("AUGMENTS")-1, AUGMENTS },
-	{ "not-accessible", sizeof ("not-accessible")-1, NOACCESS },
-	{ "write-only", sizeof ("write-only")-1, WRITEONLY },
-	{ "NsapAddress", sizeof("NsapAddress")-1, NSAPADDRESS},
-	{ "UNITS", sizeof("Units")-1, UNITS},
-	{ "REFERENCE", sizeof("REFERENCE")-1, REFERENCE},
-	{ "NUM-ENTRIES", sizeof("NUM-ENTRIES")-1, NUM_ENTRIES},
-	{ "BITSTRING", sizeof("BitString")-1, BITSTRING},
-	{ "BIT", sizeof("BIT")-1, CONTINUE},
-	{ "Counter64", sizeof("Counter64")-1, COUNTER64},
-	{ "TimeTicks", sizeof ("TimeTicks")-1, TIMETICKS },
-	{ "NOTIFICATION-TYPE", sizeof ("NOTIFICATION-TYPE")-1, NOTIFTYPE },
-	{ "OBJECT-GROUP", sizeof ("OBJECT-GROUP")-1, OBJGROUP },
-	{ "OBJECTIDENTIFIER", sizeof ("OBJECTIDENTIFIER")-1, OBJID },
+struct tok tokens[] =
+{
+    {"obsolete", sizeof("obsolete") - 1, OBSOLETE},
+    {"Opaque", sizeof("Opaque") - 1, OPAQUE},
+/*      { "recommended", sizeof("recommended")-1, RECOMMENDED },  */
+    {"optional", sizeof("optional") - 1, OPTIONAL},
+    {"LAST-UPDATED", sizeof("LAST-UPDATED") - 1, LASTUPDATED},
+    {"ORGANIZATION", sizeof("ORGANIZATION") - 1, ORGANIZATION},
+    {"CONTACT-INFO", sizeof("CONTACT-INFO") - 1, CONTACTINFO},
+    {"MODULE-IDENTITY", sizeof("MODULE-IDENTITY") - 1, MODULEIDENTITY},
+    {"MODULE-COMPLIANCE", sizeof("MODULE-COMPLIANCE") - 1, COMPLIANCE},
+    {"DEFINITIONS", sizeof("DEFINITIONS") - 1, DEFINITIONS},
+    {"END", sizeof("END") - 1, END},
+    {";", sizeof(";") - 1, SEMI},
+    {"AUGMENTS", sizeof("AUGMENTS") - 1, AUGMENTS},
+    {"not-accessible", sizeof("not-accessible") - 1, NOACCESS},
+    {"write-only", sizeof("write-only") - 1, WRITEONLY},
+    {"NsapAddress", sizeof("NsapAddress") - 1, NSAPADDRESS},
+    {"UNITS", sizeof("Units") - 1, UNITS},
+    {"REFERENCE", sizeof("REFERENCE") - 1, REFERENCE},
+    {"NUM-ENTRIES", sizeof("NUM-ENTRIES") - 1, NUM_ENTRIES},
+    {"BITSTRING", sizeof("BitString") - 1, BITSTRING},
+    {"BIT", sizeof("BIT") - 1, CONTINUE},
+    {"Counter64", sizeof("Counter64") - 1, COUNTER64},
+    {"TimeTicks", sizeof("TimeTicks") - 1, TIMETICKS},
+    {"NOTIFICATION-TYPE", sizeof("NOTIFICATION-TYPE") - 1, NOTIFTYPE},
+    {"OBJECT-GROUP", sizeof("OBJECT-GROUP") - 1, OBJGROUP},
+    {"OBJECTIDENTIFIER", sizeof("OBJECTIDENTIFIER") - 1, OBJID},
 	/*
 	 * This CONTINUE appends the next word onto OBJECT,
 	 * hopefully matching OBJECTIDENTIFIER above.
 	 */
-	{ "OBJECT", sizeof ("OBJECT")-1, CONTINUE },
-	{ "NetworkAddress", sizeof ("NetworkAddress")-1, NETADDR },
-	{ "Gauge", sizeof ("Gauge")-1, GAUGE },
-	{ "read-write", sizeof ("read-write")-1, READWRITE },
-	{ "read-create", sizeof ("read-create")-1, READCREATE },
-	{ "OCTETSTRING", sizeof ("OCTETSTRING")-1, OCTETSTR },
-	{ "OCTET", sizeof ("OCTET")-1, -1 },
-	{ "OF", sizeof ("OF")-1, OF },
-	{ "SEQUENCE", sizeof ("SEQUENCE")-1, SEQUENCE },
-	{ "NULL", sizeof ("NULL")-1, NUL },
-	{ "IpAddress", sizeof ("IpAddress")-1, IPADDR },
-	{ "UInteger32", sizeof ("UInteger32")-1, UINTEGER32 },
-	{ "INTEGER", sizeof ("INTEGER")-1, INTEGER },
-	{ "Counter", sizeof ("Counter")-1, COUNTER },
-	{ "read-only", sizeof ("read-only")-1, READONLY },
-        { "DESCRIPTION", sizeof ("DESCRIPTION")-1, DESCRIPTION },
-        { "INDEX", sizeof ("INDEX")-1, INDEX },
-        { "DEFVAL", sizeof ("DEFVAL")-1, DEFVAL },
-        { "deprecated", sizeof ("deprecated")-1, DEPRECATED },
-        { "SIZE", sizeof ("SIZE")-1, SIZE },
-	{ "MAX-ACCESS", sizeof ("MAX-ACCESS")-1, ACCESS },
-	{ "ACCESS", sizeof ("ACCESS")-1, ACCESS },
-	{ "mandatory", sizeof ("mandatory")-1, MANDATORY },
-	{ "current", sizeof ("current")-1, CURRENT },
-	{ "STATUS", sizeof ("STATUS")-1, STATUS },
-	{ "SYNTAX", sizeof ("SYNTAX")-1, SYNTAX },
-	{ "OBJECT-TYPE", sizeof ("OBJECT-TYPE")-1, OBJTYPE },
-	{ "{", sizeof ("{")-1, LEFTBRACKET },
-	{ "}", sizeof ("}")-1, RIGHTBRACKET },
-	{ "::=", sizeof ("::=")-1, EQUALS },
-	{ "(", sizeof ("(")-1, LEFTPAREN },
-	{ ")", sizeof (")")-1, RIGHTPAREN },
-	{ ",", sizeof (",")-1, COMMA },
-	{ NULL }
+    {"OBJECT", sizeof("OBJECT") - 1, CONTINUE},
+    {"NetworkAddress", sizeof("NetworkAddress") - 1, NETADDR},
+    {"Gauge", sizeof("Gauge") - 1, GAUGE},
+    {"read-write", sizeof("read-write") - 1, READWRITE},
+    {"read-create", sizeof("read-create") - 1, READCREATE},
+    {"OCTETSTRING", sizeof("OCTETSTRING") - 1, OCTETSTR},
+    {"OCTET", sizeof("OCTET") - 1, -1},
+    {"OF", sizeof("OF") - 1, OF},
+    {"SEQUENCE", sizeof("SEQUENCE") - 1, SEQUENCE},
+    {"NULL", sizeof("NULL") - 1, NUL},
+    {"IpAddress", sizeof("IpAddress") - 1, IPADDR},
+    {"UInteger32", sizeof("UInteger32") - 1, UINTEGER32},
+    {"INTEGER", sizeof("INTEGER") - 1, INTEGER},
+    {"Counter", sizeof("Counter") - 1, COUNTER},
+    {"read-only", sizeof("read-only") - 1, READONLY},
+    {"DESCRIPTION", sizeof("DESCRIPTION") - 1, DESCRIPTION},
+    {"INDEX", sizeof("INDEX") - 1, INDEX},
+    {"DEFVAL", sizeof("DEFVAL") - 1, DEFVAL},
+    {"deprecated", sizeof("deprecated") - 1, DEPRECATED},
+    {"SIZE", sizeof("SIZE") - 1, SIZE},
+    {"MAX-ACCESS", sizeof("MAX-ACCESS") - 1, ACCESS},
+    {"ACCESS", sizeof("ACCESS") - 1, ACCESS},
+    {"mandatory", sizeof("mandatory") - 1, MANDATORY},
+    {"current", sizeof("current") - 1, CURRENT},
+    {"STATUS", sizeof("STATUS") - 1, STATUS},
+    {"SYNTAX", sizeof("SYNTAX") - 1, SYNTAX},
+    {"OBJECT-TYPE", sizeof("OBJECT-TYPE") - 1, OBJTYPE},
+    {"{", sizeof("{") - 1, LEFTBRACKET},
+    {"}", sizeof("}") - 1, RIGHTBRACKET},
+    {"::=", sizeof("::=") - 1, EQUALS},
+    {"(", sizeof("(") - 1, LEFTPAREN},
+    {")", sizeof(")") - 1, RIGHTPAREN},
+    {",", sizeof(",") - 1, COMMA},
+    {NULL}
 };
 
 #define	HASHSIZE	32
 #define	BUCKET(x)	(x & 0x01F)
 
-struct tok	*buckets[HASHSIZE];
+struct tok *buckets[HASHSIZE];
 
 static void do_subtree();
 static int get_token();
@@ -214,21 +215,21 @@ static int tossObjectIdentifier();
 static void
 hash_init()
 {
-	struct tok	*tp;
-	char	*cp;
-	int	h;
-	int	b;
-
-	bzero((char *)buckets, sizeof(buckets));
-	for (tp = tokens; tp->name; tp++) {
-		for (h = 0, cp = tp->name; *cp; cp++)
-			h += *cp;
-		tp->hash = h;
-		b = BUCKET(h);
-		if (buckets[b])
-		    tp->next = buckets[b]; /* BUG ??? */
-		buckets[b] = tp;
-	}
+    struct tok *tp;
+    char *cp;
+    int h;
+    int b;
+
+    bzero((char *) buckets, sizeof(buckets));
+    for (tp = tokens; tp->name; tp++) {
+	for (h = 0, cp = tp->name; *cp; cp++)
+	    h += *cp;
+	tp->hash = h;
+	b = BUCKET(h);
+	if (buckets[b])
+	    tp->next = buckets[b];	/* BUG ??? */
+	buckets[b] = tp;
+    }
 }
 
 #define NHASHSIZE    128
@@ -239,42 +240,42 @@ void
 init_node_hash(nodes)
      struct node *nodes;
 {
-     struct node *np, *nextp;
-     char *cp;
-     int hash;
-
-     bzero((char *)nbuckets,sizeof(nbuckets));
-     for(np = nodes; np;){
-         nextp = np->next;
-         hash = 0;
-	 for(cp = np->parent; *cp; cp++)
-	     hash += *cp;
-	 np->next = nbuckets[NBUCKET(hash)];
-	 nbuckets[NBUCKET(hash)] = np;
-	 np = nextp;
-     }
+    struct node *np, *nextp;
+    char *cp;
+    int hash;
+
+    bzero((char *) nbuckets, sizeof(nbuckets));
+    for (np = nodes; np;) {
+	nextp = np->next;
+	hash = 0;
+	for (cp = np->parent; *cp; cp++)
+	    hash += *cp;
+	np->next = nbuckets[NBUCKET(hash)];
+	nbuckets[NBUCKET(hash)] = np;
+	np = nextp;
+    }
 }
 
 static char *
 Malloc(num)
-    unsigned num;
+     unsigned num;
 {
 #ifndef linux
-    char* calloc();
+    char *calloc();
 #endif
-    
+
     /* this is to fix (what seems to be) a problem with the IBM RT C
-       library malloc */
+     * library malloc */
     if (num < 16)
 	num = 16;
-    return (char *)calloc(1, num);
+    return (char *) calloc(1, num);
 }
 
 static void
 print_error(string, token, type)
-    char *string;
-    char *token;
-    int type;
+     char *string;
+     char *token;
+     int type;
 {
     if (type == ENDOFFILE)
 	fprintf(stderr, "%s(EOF): On or around line %d\n", string, Line);
@@ -286,22 +287,22 @@ print_error(string, token, type)
 
 #ifdef TEST
 print_subtree(tree, count)
-    struct tree *tree;
-    int count;
+     struct tree *tree;
+     int count;
 {
     struct tree *tp;
     int i;
 
-    for(i = 0; i < count; i++)
+    for (i = 0; i < count; i++)
 	printf("  ");
     printf("Children of %s:\n", tree->label);
     count++;
-    for(tp = tree->child_list; tp; tp = tp->next_peer){
-	for(i = 0; i < count; i++)
+    for (tp = tree->child_list; tp; tp = tp->next_peer) {
+	for (i = 0; i < count; i++)
 	    printf("  ");
 	printf("%s\n", tp->label);
     }
-    for(tp = tree->child_list; tp; tp = tp->next_peer){
+    for (tp = tree->child_list; tp; tp = tp->next_peer) {
 	print_subtree(tp, count);
     }
 }
@@ -314,71 +315,71 @@ build_translation_table()
 {
     int count;
 
-    for(count = 0; count < 256; count++){
-	switch(count){
-	    case OBJID:
-		translation_table[count] = TYPE_OBJID;
-		break;
-	    case OCTETSTR:
-		translation_table[count] = TYPE_OCTETSTR;
-		break;
-	    case INTEGER:
-		translation_table[count] = TYPE_INTEGER;
-		break;
-	    case NETADDR:
-		translation_table[count] = TYPE_IPADDR;
-		break;
-	    case IPADDR:
-		translation_table[count] = TYPE_IPADDR;
-		break;
-	    case COUNTER:
-		translation_table[count] = TYPE_COUNTER;
-		break;
-	    case GAUGE:
-		translation_table[count] = TYPE_GAUGE;
-		break;
-	    case TIMETICKS:
-		translation_table[count] = TYPE_TIMETICKS;
-		break;
-	    case OPAQUE:
-		translation_table[count] = TYPE_OPAQUE;
-		break;
-	    case NUL:
-		translation_table[count] = TYPE_NULL;
-		break;
-	    case COUNTER64:
-		translation_table[count] = TYPE_COUNTER64;
-		break;
-	    case BITSTRING:
-		translation_table[count] = TYPE_BITSTRING;
-		break;
-	    case NSAPADDRESS:
-		translation_table[count] = TYPE_NSAPADDRESS;
-		break;
-	    case UINTEGER32:
-		translation_table[count] = TYPE_UINTEGER;
-		break;
-	    default:
-		translation_table[count] = TYPE_OTHER;
-		break;
+    for (count = 0; count < 256; count++) {
+	switch (count) {
+	case OBJID:
+	    translation_table[count] = TYPE_OBJID;
+	    break;
+	case OCTETSTR:
+	    translation_table[count] = TYPE_OCTETSTR;
+	    break;
+	case INTEGER:
+	    translation_table[count] = TYPE_INTEGER;
+	    break;
+	case NETADDR:
+	    translation_table[count] = TYPE_IPADDR;
+	    break;
+	case IPADDR:
+	    translation_table[count] = TYPE_IPADDR;
+	    break;
+	case COUNTER:
+	    translation_table[count] = TYPE_COUNTER;
+	    break;
+	case GAUGE:
+	    translation_table[count] = TYPE_GAUGE;
+	    break;
+	case TIMETICKS:
+	    translation_table[count] = TYPE_TIMETICKS;
+	    break;
+	case OPAQUE:
+	    translation_table[count] = TYPE_OPAQUE;
+	    break;
+	case NUL:
+	    translation_table[count] = TYPE_NULL;
+	    break;
+	case COUNTER64:
+	    translation_table[count] = TYPE_COUNTER64;
+	    break;
+	case BITSTRING:
+	    translation_table[count] = TYPE_BITSTRING;
+	    break;
+	case NSAPADDRESS:
+	    translation_table[count] = TYPE_NSAPADDRESS;
+	    break;
+	case UINTEGER32:
+	    translation_table[count] = TYPE_UINTEGER;
+	    break;
+	default:
+	    translation_table[count] = TYPE_OTHER;
+	    break;
 	}
     }
 }
 
 static struct tree *
 build_tree(nodes)
-    struct node *nodes;
+     struct node *nodes;
 {
     struct node *np;
     struct tree *tp, *lasttp;
     int bucket, nodes_left = 0;
-    
+
     build_translation_table();
     /* grow tree from this root node */
     init_node_hash(nodes);
 
     /* build root node */
-    tp = (struct tree *)Malloc(sizeof(struct tree));
+    tp = (struct tree *) Malloc(sizeof(struct tree));
     tp->parent = NULL;
     tp->next_peer = NULL;
     tp->child_list = NULL;
@@ -392,7 +393,7 @@ build_tree(nodes)
     lasttp = tp;
 
     /* build root node */
-    tp = (struct tree *)Malloc(sizeof(struct tree));
+    tp = (struct tree *) Malloc(sizeof(struct tree));
     tp->parent = NULL;
     tp->next_peer = lasttp;
     tp->child_list = NULL;
@@ -406,7 +407,7 @@ build_tree(nodes)
     lasttp = tp;
 
     /* build root node */
-    tp = (struct tree *)Malloc(sizeof(struct tree));
+    tp = (struct tree *) Malloc(sizeof(struct tree));
     tp->parent = NULL;
     tp->next_peer = lasttp;
     tp->child_list = NULL;
@@ -423,20 +424,20 @@ build_tree(nodes)
     print_subtree(tp, 0);
 #endif /* TEST */
     /* If any nodes are left, the tree is probably inconsistent */
-    for(bucket = 0; bucket < NHASHSIZE; bucket++){
-        if (nbuckets[bucket]){
+    for (bucket = 0; bucket < NHASHSIZE; bucket++) {
+	if (nbuckets[bucket]) {
 	    nodes_left = 1;
 	    break;
 	}
     }
-    if (nodes_left){
+    if (nodes_left) {
 	fprintf(stderr, "The mib description doesn't seem to be consistent.\n");
 	fprintf(stderr, "Some nodes couldn't be linked under the \"iso\" tree.\n");
 	fprintf(stderr, "these nodes are left:\n");
-	for(bucket = 0; bucket < NHASHSIZE; bucket++){
-	    for(np = nbuckets[bucket]; np; np = np->next)
-	        fprintf(stderr, "%s ::= { %s %ld } (%d)\n", np->label,
-			np->parent, np->subid, np->type);
+	for (bucket = 0; bucket < NHASHSIZE; bucket++) {
+	    for (np = nbuckets[bucket]; np; np = np->next)
+		fprintf(stderr, "%s ::= { %s %ld } (%d)\n", np->label,
+		    np->parent, np->subid, np->type);
 	}
     }
     return tp;
@@ -448,28 +449,28 @@ build_tree(nodes)
  */
 static void
 do_subtree(root, nodes)
-    struct tree *root;
-    struct node **nodes;
+     struct tree *root;
+     struct node **nodes;
 {
     struct tree *tp;
     struct tree *peer = NULL;
     struct node *np, **headp;
     struct node *oldnp = NULL, *child_list = NULL, *childp = NULL;
     char *cp;
     int hash;
-    
+
     tp = root;
     hash = 0;
-    for(cp = tp->label; *cp; cp++)
-        hash += *cp;
+    for (cp = tp->label; *cp; cp++)
+	hash += *cp;
     headp = &nbuckets[NBUCKET(hash)];
     /*
      * Search each of the nodes for one whose parent is root, and
      * move each into a separate list.
      */
-    for(np = *headp; np; np = np->next){
-	if ((*tp->label != *np->parent) || strcmp(tp->label, np->parent)){
-	    if ((*tp->label == *np->label) && !strcmp(tp->label, np->label)){
+    for (np = *headp; np; np = np->next) {
+	if ((*tp->label != *np->parent) || strcmp(tp->label, np->parent)) {
+	    if ((*tp->label == *np->label) && !strcmp(tp->label, np->label)) {
 		/* if there is another node with the same label, assume that
 		 * any children after this point in the list belong to the other node.
 		 * This adds some scoping to the table and allows vendors to
@@ -479,17 +480,17 @@ do_subtree(root, nodes)
 	    }
 	    oldnp = np;
 	} else {
-	    if (child_list == NULL){
-		child_list = childp = np;   /* first entry in child list */
+	    if (child_list == NULL) {
+		child_list = childp = np;	/* first entry in child list */
 	    } else {
 		childp->next = np;
 		childp = np;
 	    }
 	    /* take this node out of the node list */
-	    if (oldnp == NULL){
-		*headp = np->next;  /* fix root of node list */
+	    if (oldnp == NULL) {
+		*headp = np->next;	/* fix root of node list */
 	    } else {
-		oldnp->next = np->next;	/* link around this node */
+		oldnp->next = np->next;		/* link around this node */
 	    }
 	}
     }
@@ -498,8 +499,8 @@ do_subtree(root, nodes)
     /*
      * Take each element in the child list and place it into the tree.
      */
-    for(np = child_list; np; np = np->next){
-	tp = (struct tree *)Malloc(sizeof(struct tree));
+    for (np = child_list; np; np = np->next) {
+	tp = (struct tree *) Malloc(sizeof(struct tree));
 	tp->parent = root;
 	tp->next_peer = NULL;
 	tp->child_list = NULL;
@@ -508,21 +509,21 @@ do_subtree(root, nodes)
 	tp->type = translation_table[np->type];
 	tp->enums = np->enums;
 	np->enums = NULL;	/* so we don't free them later */
-	tp->description = np->description; /* steals memory from np */
-	np->description = NULL; /* so we don't free it later */
-	if (root->child_list == NULL){
+	tp->description = np->description;	/* steals memory from np */
+	np->description = NULL;	/* so we don't free it later */
+	if (root->child_list == NULL) {
 	    root->child_list = tp;
 	} else {
 	    peer->next_peer = tp;
 	}
 	peer = tp;
-/*	if (tp->type == TYPE_OTHER) */
-	    do_subtree(tp, nodes);	/* recurse on this child if it isn't
-					   an end node */
+/*      if (tp->type == TYPE_OTHER) */
+	do_subtree(tp, nodes);	/* recurse on this child if it isn't
+				 * an end node */
     }
     /* free all nodes that were copied into tree */
     oldnp = NULL;
-    for(np = child_list; np; np = np->next){
+    for (np = child_list; np; np = np->next) {
 	if (oldnp)
 	    free(oldnp);
 	oldnp = np;
@@ -539,41 +540,41 @@ do_subtree(root, nodes)
  * Returns NULL on error.
  */
 static int
-getoid(fp, oid,  length)
-    FILE *fp;
-    struct subid *oid;	/* an array of subids */
-    int length;	    /* the length of the array */
+getoid(fp, oid, length)
+     FILE *fp;
+     struct subid *oid;		/* an array of subids */
+     int length;		/* the length of the array */
 {
     int count;
     int type;
     char token[MAXTOKEN];
     char *cp;
 
-    if ((type = get_token(fp, token)) != LEFTBRACKET){
+    if ((type = get_token(fp, token)) != LEFTBRACKET) {
 	print_error("Expected \"{\"", token, type);
 	return 0;
     }
     type = get_token(fp, token);
-    for(count = 0; count < length; count++, oid++){
+    for (count = 0; count < length; count++, oid++) {
 	oid->label = 0;
 	oid->subid = -1;
-	if (type == RIGHTBRACKET){
+	if (type == RIGHTBRACKET) {
 	    return count;
-	} else if (type != LABEL && type != NUMBER){
+	} else if (type != LABEL && type != NUMBER) {
 	    print_error("Not valid for object identifier", token, type);
 	    return 0;
 	}
-	if (type == LABEL){
+	if (type == LABEL) {
 	    /* this entry has a label */
-	    cp = (char *)Malloc((unsigned)strlen(token) + 1);
+	    cp = (char *) Malloc((unsigned) strlen(token) + 1);
 	    strcpy(cp, token);
 	    oid->label = cp;
 	    type = get_token(fp, token);
-	    if (type == LEFTPAREN){
+	    if (type == LEFTPAREN) {
 		type = get_token(fp, token);
-		if (type == NUMBER){
+		if (type == NUMBER) {
 		    oid->subid = atoi(token);
-		    if ((type = get_token(fp, token)) != RIGHTPAREN){
+		    if ((type = get_token(fp, token)) != RIGHTPAREN) {
 			print_error("Unexpected a closing parenthesis", token, type);
 			return 0;
 		    }
@@ -597,17 +598,17 @@ getoid(fp, oid,  length)
 
 static void
 free_node(np)
-    struct node *np;
+     struct node *np;
 {
     struct enum_list *ep, *tep;
 
     ep = np->enums;
-    while(ep){
+    while (ep) {
 	tep = ep;
 	ep = ep->next;
-	free((char *)tep);
+	free((char *) tep);
     }
-    free((char *)np);
+    free((char *) np);
 }
 
 /*
@@ -618,8 +619,8 @@ free_node(np)
  */
 static struct node *
 parse_objectid(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[MAXTOKEN];
@@ -630,21 +631,21 @@ parse_objectid(fp, name)
     struct node *np, *root, *oldnp = NULL;
 
     type = get_token(fp, token);
-    if (type != EQUALS){
+    if (type != EQUALS) {
 	print_error("Bad format", token, type);
 	return 0;
     }
-    if ((length = getoid(fp, oid, 32)) != 0){
-	np = root = (struct node *)Malloc(sizeof(struct node));
-	bzero((char *)np, sizeof(struct node));
+    if ((length = getoid(fp, oid, 32)) != 0) {
+	np = root = (struct node *) Malloc(sizeof(struct node));
+	bzero((char *) np, sizeof(struct node));
 	/*
 	 * For each parent-child subid pair in the subid array,
 	 * create a node and link it into the node list.
 	 */
-	for(count = 0, op = oid, nop=oid+1; count < (length - 2); count++,
-	    op++, nop++){
+	for (count = 0, op = oid, nop = oid + 1; count < (length - 2); count++,
+	    op++, nop++) {
 	    /* every node must have parent's name and child's name or number */
-	    if (op->label && (nop->label || (nop->subid != -1))){
+	    if (op->label && (nop->label || (nop->subid != -1))) {
 		strcpy(np->parent, op->label);
 		if (nop->label)
 		    strcpy(np->label, nop->label);
@@ -653,28 +654,28 @@ parse_objectid(fp, name)
 		np->type = 0;
 		np->enums = 0;
 		/* set up next entry */
-		np->next = (struct node *)Malloc(sizeof(*np->next));
-		bzero((char *)np->next, sizeof(struct node));
+		np->next = (struct node *) Malloc(sizeof(*np->next));
+		bzero((char *) np->next, sizeof(struct node));
 		oldnp = np;
 		np = np->next;
 	    }
 	}
-	np->next = (struct node *)NULL;
+	np->next = (struct node *) NULL;
 	/*
 	 * The above loop took care of all but the last pair.  This pair is taken
 	 * care of here.  The name for this node is taken from the label for this
 	 * entry.
 	 * np still points to an unused entry.
 	 */
-	if (count == (length - 2)){
-	    if (op->label){
+	if (count == (length - 2)) {
+	    if (op->label) {
 		strcpy(np->parent, op->label);
 		strcpy(np->label, name);
 		if (nop->subid != -1)
 		    np->subid = nop->subid;
 		else
 		    print_error("Warning: This entry is pretty silly",
-				np->label, type);
+			np->label, type);
 	    } else {
 		free_node(np);
 		if (oldnp)
@@ -683,36 +684,36 @@ parse_objectid(fp, name)
 		    return NULL;
 	    }
 	} else {
-	    print_error("Missing end of oid", (char *)NULL, type);
-	    free_node(np);   /* the last node allocated wasn't used */
+	    print_error("Missing end of oid", (char *) NULL, type);
+	    free_node(np);	/* the last node allocated wasn't used */
 	    if (oldnp)
 		oldnp->next = NULL;
 	    return NULL;
 	}
 	/* free the oid array */
-	for(count = 0, op = oid; count < length; count++, op++){
+	for (count = 0, op = oid; count < length; count++, op++) {
 	    if (op->label)
 		free(op->label);
 	    op->label = 0;
 	}
 	return root;
     } else {
-	print_error("Bad object identifier", (char *)NULL, type);
+	print_error("Bad object identifier", (char *) NULL, type);
 	return 0;
     }
 }
 
 static int
 get_tc(descriptor, ep)
-    char *descriptor;
-    struct enum_list **ep;
+     char *descriptor;
+     struct enum_list **ep;
 {
     int i;
 
-    for(i = 0; i < MAXTC; i++){
+    for (i = 0; i < MAXTC; i++) {
 	if (tclist[i].type == 0)
 	    break;
-	if (!strcmp(descriptor, tclist[i].descriptor)){
+	if (!strcmp(descriptor, tclist[i].descriptor)) {
 	    *ep = tclist[i].enums;
 	    return tclist[i].type;
 	}
@@ -726,70 +727,70 @@ get_tc(descriptor, ep)
  */
 static int
 parse_asntype(fp, name, ntype, ntoken)
-    FILE *fp;
-    char *name;
-    int *ntype;
-    char *ntoken;
+     FILE *fp;
+     char *name;
+     int *ntype;
+     char *ntoken;
 {
     int type, i;
     char token[MAXTOKEN];
     struct enum_list *ep = 0;
     struct tc *tcp;
     int level;
-    
+
     type = get_token(fp, token);
-    if (type == SEQUENCE){
-	while((type = get_token(fp, token)) != ENDOFFILE){
-	    if (type == RIGHTBRACKET){
+    if (type == SEQUENCE) {
+	while ((type = get_token(fp, token)) != ENDOFFILE) {
+	    if (type == RIGHTBRACKET) {
 		*ntype = get_token(fp, ntoken);
 		return 1;
 	    }
 	}
 	print_error("Expected \"}\"", token, type);
 	return 0;
     } else {
-	if (!strcmp(token, "TEXTUAL-CONVENTION")){
+	if (!strcmp(token, "TEXTUAL-CONVENTION")) {
 	    while (type != SYNTAX)
 		type = get_token(fp, token);
 	    type = get_token(fp, token);
 	}
 	/* textual convention */
-	for(i = 0; i < MAXTC; i++){
+	for (i = 0; i < MAXTC; i++) {
 	    if (tclist[i].type == 0)
 		break;
 	}
-	if (i == MAXTC){
+	if (i == MAXTC) {
 	    print_error("No more textual conventions possible.", token, type);
 	    return 0;
 	}
 	tcp = &tclist[i];
 	strcpy(tcp->descriptor, name);
-	if (!(type & SYNTAX_MASK)){
+	if (!(type & SYNTAX_MASK)) {
 	    print_error("Textual convention doesn't map to real type.", token,
-			type);
+		type);
 	    return 0;
 	}
 	tcp->type = type;
 	*ntype = get_token(fp, ntoken);
-	if (*ntype == LEFTPAREN){
+	if (*ntype == LEFTPAREN) {
 	    level = 1;
 	    /* don't record any constraints for now */
-	    while(level > 0){
+	    while (level > 0) {
 		*ntype = get_token(fp, ntoken);
 		if (*ntype == LEFTPAREN)
 		    level++;
 		if (*ntype == RIGHTPAREN)
-		    level--;		
+		    level--;
 	    }
 	    *ntype = get_token(fp, ntoken);
 	} else if (*ntype == LEFTBRACKET) {
 	    /* if there is an enumeration list, parse it */
-	    while((type = get_token(fp, token)) != ENDOFFILE){
+	    while ((type = get_token(fp, token)) != ENDOFFILE) {
 		if (type == RIGHTBRACKET)
 		    break;
-		if (type == LABEL){
+		if (type == LABEL) {
 		    /* this is an enumerated label */
-		    if (tcp->enums == 0){
+		    if (tcp->enums == 0) {
 			ep = tcp->enums = (struct enum_list *)
 			    Malloc(sizeof(struct enum_list));
 		    } else {
@@ -800,30 +801,30 @@ parse_asntype(fp, name, ntype, ntoken)
 		    ep->next = 0;
 		    /* a reasonable approximation for the length */
 		    ep->label =
-			(char *)Malloc((unsigned)strlen(token) + 1);
+			(char *) Malloc((unsigned) strlen(token) + 1);
 		    strcpy(ep->label, token);
 		    type = get_token(fp, token);
-		    if (type != LEFTPAREN){
+		    if (type != LEFTPAREN) {
 			print_error("Expected \"(\"", token, type);
 			/* free_node(np); */
 			return 0;
 		    }
 		    type = get_token(fp, token);
-		    if (type != NUMBER){
+		    if (type != NUMBER) {
 			print_error("Expected integer", token, type);
 			/* free_node(np); */
 			return 0;
 		    }
 		    ep->value = atoi(token);
 		    type = get_token(fp, token);
-		    if (type != RIGHTPAREN){
+		    if (type != RIGHTPAREN) {
 			print_error("Expected \")\"", token, type);
 			/* free_node(np); */
 			return 0;
 		    }
 		}
 	    }
-	    if (type == ENDOFFILE){
+	    if (type == ENDOFFILE) {
 		print_error("Expected \"}\"", token, type);
 		/* free_node(np); */
 		return 0;
@@ -841,8 +842,8 @@ parse_asntype(fp, name, ntype, ntoken)
  */
 static struct node *
 parse_objecttype(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[MAXTOKEN];
@@ -855,19 +856,19 @@ parse_objecttype(fp, name)
     struct enum_list *ep = 0;
 
     type = get_token(fp, token);
-    if (type != SYNTAX){
+    if (type != SYNTAX) {
 	print_error("Bad format for OBJECT TYPE", token, type);
 	return 0;
     }
-    np = (struct node *)Malloc(sizeof(struct node));
+    np = (struct node *) Malloc(sizeof(struct node));
     np->next = 0;
     np->enums = 0;
-    np->description = NULL;        /* default to an empty description */
+    np->description = NULL;	/* default to an empty description */
     type = get_token(fp, token);
-    if (type == LABEL){
+    if (type == LABEL) {
 	tctype = get_tc(token, &(np->enums));
 #if 0
-	if (tctype == LABEL){
+	if (tctype == LABEL) {
 	    print_error("No known translation for type", token, type);
 	    return 0;
 	}
@@ -876,173 +877,172 @@ parse_objecttype(fp, name)
     }
     np->type = type;
     nexttype = get_token(fp, nexttoken);
-    switch(type){
-	case SEQUENCE:
-	    strcpy(syntax, token);
-	    if (nexttype == OF){
-		strcat(syntax, " ");
-		strcat(syntax, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-		strcat(syntax, " ");
-		strcat(syntax, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-	    }
-	    break;
-	case INTEGER:
-	case UINTEGER32:
-	    strcpy(syntax, token);
-	    if (nexttype == LEFTBRACKET) {
-		/* if there is an enumeration list, parse it */
-		while((type = get_token(fp, token)) != ENDOFFILE){
-		    if (type == RIGHTBRACKET)
-			break;
-		    if (type == LABEL){
-			/* this is an enumerated label */
-			if (np->enums == 0){
-			    ep = np->enums = (struct enum_list *)
-					Malloc(sizeof(struct enum_list));
-			} else {
-			    ep->next = (struct enum_list *)
-					Malloc(sizeof(struct enum_list));
-			    ep = ep->next;
-			}
-			ep->next = 0;
-			/* a reasonable approximation for the length */
-			ep->label =
-			    (char *)Malloc((unsigned)strlen(token) + 1);
-			strcpy(ep->label, token);
-			type = get_token(fp, token);
-			if (type != LEFTPAREN){
-			    print_error("Expected \"(\"", token, type);
-			    free_node(np);
-			    return 0;
-			}
-			type = get_token(fp, token);
-			if (type != NUMBER){
-			    print_error("Expected integer", token, type);
-			    free_node(np);
-			    return 0;
-			}
-			ep->value = atoi(token);
-			type = get_token(fp, token);
-			if (type != RIGHTPAREN){
-			    print_error("Expected \")\"", token, type);
-			    free_node(np);
-			    return 0;
-			}
+    switch (type) {
+    case SEQUENCE:
+	strcpy(syntax, token);
+	if (nexttype == OF) {
+	    strcat(syntax, " ");
+	    strcat(syntax, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	    strcat(syntax, " ");
+	    strcat(syntax, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	}
+	break;
+    case INTEGER:
+    case UINTEGER32:
+	strcpy(syntax, token);
+	if (nexttype == LEFTBRACKET) {
+	    /* if there is an enumeration list, parse it */
+	    while ((type = get_token(fp, token)) != ENDOFFILE) {
+		if (type == RIGHTBRACKET)
+		    break;
+		if (type == LABEL) {
+		    /* this is an enumerated label */
+		    if (np->enums == 0) {
+			ep = np->enums = (struct enum_list *)
+			    Malloc(sizeof(struct enum_list));
+		    } else {
+			ep->next = (struct enum_list *)
+			    Malloc(sizeof(struct enum_list));
+			ep = ep->next;
+		    }
+		    ep->next = 0;
+		    /* a reasonable approximation for the length */
+		    ep->label =
+			(char *) Malloc((unsigned) strlen(token) + 1);
+		    strcpy(ep->label, token);
+		    type = get_token(fp, token);
+		    if (type != LEFTPAREN) {
+			print_error("Expected \"(\"", token, type);
+			free_node(np);
+			return 0;
+		    }
+		    type = get_token(fp, token);
+		    if (type != NUMBER) {
+			print_error("Expected integer", token, type);
+			free_node(np);
+			return 0;
+		    }
+		    ep->value = atoi(token);
+		    type = get_token(fp, token);
+		    if (type != RIGHTPAREN) {
+			print_error("Expected \")\"", token, type);
+			free_node(np);
+			return 0;
 		    }
 		}
-		if (type == ENDOFFILE){
-		    print_error("Expected \"}\"", token, type);
-		    free_node(np);
-		    return 0;
+	    }
+	    if (type == ENDOFFILE) {
+		print_error("Expected \"}\"", token, type);
+		free_node(np);
+		return 0;
+	    }
+	    nexttype = get_token(fp, nexttoken);
+	} else if (nexttype == LEFTPAREN) {
+	    /* ignore the "constrained integer" for now */
+	    nexttype = get_token(fp, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	}
+	break;
+    case BITSTRING:
+	strcpy(syntax, token);
+	if (nexttype == LEFTBRACKET) {
+	    /* if there is an enumeration list, parse it */
+	    while ((type = get_token(fp, token)) != ENDOFFILE) {
+		if (type == RIGHTBRACKET)
+		    break;
+		if (type == LABEL) {
+		    /* this is an enumerated label */
+		    if (np->enums == 0) {
+			ep = np->enums = (struct enum_list *)
+			    Malloc(sizeof(struct enum_list));
+		    } else {
+			ep->next = (struct enum_list *)
+			    Malloc(sizeof(struct enum_list));
+			ep = ep->next;
+		    }
+		    ep->next = 0;
+		    /* a reasonable approximation for the length */
+		    ep->label =
+			(char *) Malloc((unsigned) strlen(token) + 1);
+		    strcpy(ep->label, token);
+		    type = get_token(fp, token);
+		    if (type != LEFTPAREN) {
+			print_error("Expected \"(\"", token, type);
+			free_node(np);
+			return 0;
+		    }
+		    type = get_token(fp, token);
+		    if (type != NUMBER) {
+			print_error("Expected integer", token, type);
+			free_node(np);
+			return 0;
+		    }
+		    ep->value = atoi(token);
+		    type = get_token(fp, token);
+		    if (type != RIGHTPAREN) {
+			print_error("Expected \")\"", token, type);
+			free_node(np);
+			return 0;
+		    }
 		}
-		nexttype = get_token(fp, nexttoken);
-	    } else if (nexttype == LEFTPAREN){
-		/* ignore the "constrained integer" for now */
-		nexttype = get_token(fp, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-		nexttype = get_token(fp, nexttoken);
 	    }
-	    break;
-	case BITSTRING:
-	    strcpy(syntax, token);
-	    if (nexttype == LEFTBRACKET) {
-		/* if there is an enumeration list, parse it */
-		while((type = get_token(fp, token)) != ENDOFFILE){
-		    if (type == RIGHTBRACKET)
+	    if (type == ENDOFFILE) {
+		print_error("Expected \"}\"", token, type);
+		free_node(np);
+		return 0;
+	    }
+	    nexttype = get_token(fp, nexttoken);
+	} else if (nexttype == LEFTPAREN) {
+	    /* ignore the "constrained integer" for now */
+	    nexttype = get_token(fp, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	}
+	break;
+    case OCTETSTR:
+	strcpy(syntax, token);
+	/* ignore the "constrained octet string" for now */
+	if (nexttype == LEFTPAREN) {
+	    nexttype = get_token(fp, nexttoken);
+	    if (nexttype == SIZE) {
+		nexttype = get_token(fp, nexttoken);
+		if (nexttype == LEFTPAREN) {
+		    nexttype = get_token(fp, nexttoken);	/* 0..255 */
+		    nexttype = get_token(fp, nexttoken);	/* ) */
+		    nexttype = get_token(fp, nexttoken);	/* ) */
+		    if (nexttype == RIGHTPAREN) {
+			nexttype = get_token(fp, nexttoken);
 			break;
-		    if (type == LABEL){
-			/* this is an enumerated label */
-			if (np->enums == 0){
-			    ep = np->enums = (struct enum_list *)
-					Malloc(sizeof(struct enum_list));
-			} else {
-			    ep->next = (struct enum_list *)
-					Malloc(sizeof(struct enum_list));
-			    ep = ep->next;
-			}
-			ep->next = 0;
-			/* a reasonable approximation for the length */
-			ep->label =
-			    (char *)Malloc((unsigned)strlen(token) + 1);
-			strcpy(ep->label, token);
-			type = get_token(fp, token);
-			if (type != LEFTPAREN){
-			    print_error("Expected \"(\"", token, type);
-			    free_node(np);
-			    return 0;
-			}
-			type = get_token(fp, token);
-			if (type != NUMBER){
-			    print_error("Expected integer", token, type);
-			    free_node(np);
-			    return 0;
-			}
-			ep->value = atoi(token);
-			type = get_token(fp, token);
-			if (type != RIGHTPAREN){
-			    print_error("Expected \")\"", token, type);
-			    free_node(np);
-			    return 0;
-			}
 		    }
 		}
-		if (type == ENDOFFILE){
-		    print_error("Expected \"}\"", token, type);
-		    free_node(np);
-		    return 0;
-		}
-		nexttype = get_token(fp, nexttoken);
-	    } else if (nexttype == LEFTPAREN){
-		/* ignore the "constrained integer" for now */
-		nexttype = get_token(fp, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-		nexttype = get_token(fp, nexttoken);
 	    }
-	    break;
-	case OCTETSTR:
-	    strcpy(syntax, token);
-            /* ignore the "constrained octet string" for now */
-            if (nexttype == LEFTPAREN) {
-                nexttype = get_token(fp, nexttoken);
-                if (nexttype == SIZE) {
-                    nexttype = get_token(fp, nexttoken);
-                    if (nexttype == LEFTPAREN) {
-                        nexttype = get_token(fp, nexttoken); /* 0..255 */
-                        nexttype = get_token(fp, nexttoken); /* ) */
-                        nexttype = get_token(fp, nexttoken); /* ) */
-                        if (nexttype == RIGHTPAREN)
-                        {
-                            nexttype = get_token(fp, nexttoken);
-                            break;
-                        }
-                    }
-                }
-                print_error("Bad syntax", token, type);
-                free_node(np);
-                return 0;
-            }
-	    break;
-	case OBJID:
-	case NETADDR:
-	case IPADDR:
-	case COUNTER:
-	case GAUGE:
-	case TIMETICKS:
-	case OPAQUE:
-	case NUL:
-	case LABEL:
-	case NSAPADDRESS:
-	case COUNTER64:
-	    strcpy(syntax, token);
-	    break;
-	default:
 	    print_error("Bad syntax", token, type);
 	    free_node(np);
 	    return 0;
+	}
+	break;
+    case OBJID:
+    case NETADDR:
+    case IPADDR:
+    case COUNTER:
+    case GAUGE:
+    case TIMETICKS:
+    case OPAQUE:
+    case NUL:
+    case LABEL:
+    case NSAPADDRESS:
+    case COUNTER64:
+	strcpy(syntax, token);
+	break;
+    default:
+	print_error("Bad syntax", token, type);
+	free_node(np);
+	return 0;
     }
-    if (nexttype == UNITS){
+    if (nexttype == UNITS) {
 	type = get_token(fp, token);
 	if (type != QUOTESTRING) {
 	    print_error("Bad DESCRIPTION", token, type);
@@ -1051,26 +1051,26 @@ parse_objecttype(fp, name)
 	}
 	nexttype = get_token(fp, nexttoken);
     }
-    if (nexttype != ACCESS){
+    if (nexttype != ACCESS) {
 	print_error("Should be ACCESS", nexttoken, nexttype);
 	free_node(np);
 	return 0;
     }
     type = get_token(fp, token);
     if (type != READONLY && type != READWRITE && type != WRITEONLY
-	&& type != NOACCESS && type != READCREATE){
+	&& type != NOACCESS && type != READCREATE) {
 	print_error("Bad access type", nexttoken, nexttype);
 	free_node(np);
 	return 0;
     }
     type = get_token(fp, token);
-    if (type != STATUS){
+    if (type != STATUS) {
 	print_error("Should be STATUS", token, nexttype);
 	free_node(np);
 	return 0;
     }
     type = get_token(fp, token);
-    if (type != MANDATORY && type != CURRENT && type != OPTIONAL && type != OBSOLETE && type != DEPRECATED){
+    if (type != MANDATORY && type != CURRENT && type != OPTIONAL && type != OBSOLETE && type != DEPRECATED) {
 	print_error("Bad status", token, type);
 	free_node(np);
 	return 0;
@@ -1080,55 +1080,55 @@ parse_objecttype(fp, name)
      */
     type = get_token(fp, token);
     while (type != EQUALS) {
-      switch (type) {
-        case DESCRIPTION:
-          type = get_token(fp, token);
-          if (type != QUOTESTRING) {
-              print_error("Bad DESCRIPTION", token, type);
-              free_node(np);
-              return 0;
-          }
+	switch (type) {
+	case DESCRIPTION:
+	    type = get_token(fp, token);
+	    if (type != QUOTESTRING) {
+		print_error("Bad DESCRIPTION", token, type);
+		free_node(np);
+		return 0;
+	    }
 #ifdef TEST
-printf("Description== \"%.50s\"\n", quoted_string_buffer);
+	    printf("Description== \"%.50s\"\n", quoted_string_buffer);
 #endif
-	  np->description = quoted_string_buffer;
-	  quoted_string_buffer = (char *)calloc(1, MAXQUOTESTR);
-          break;
+	    np->description = quoted_string_buffer;
+	    quoted_string_buffer = (char *) calloc(1, MAXQUOTESTR);
+	    break;
 
 	case REFERENCE:
-	  type = get_token(fp, token);
-	  if (type != QUOTESTRING) {
-	      print_error("Bad DESCRIPTION", token, type);
-	      free_node(np);
-	      return 0;
-	  }
-	  break;
-        case INDEX:
-        case DEFVAL:
+	    type = get_token(fp, token);
+	    if (type != QUOTESTRING) {
+		print_error("Bad DESCRIPTION", token, type);
+		free_node(np);
+		return 0;
+	    }
+	    break;
+	case INDEX:
+	case DEFVAL:
 	case AUGMENTS:
 	case NUM_ENTRIES:
-          if (tossObjectIdentifier(fp) != OBJID) {
-              print_error("Bad Object Identifier", token, type);
-              free_node(np);
-              return 0;
-          }
-          break;
-
-        default:
-          print_error("Bad format of optional clauses", token,type);
-          free_node(np);
-          return 0;
-
-      }
-      type = get_token(fp, token);
+	    if (tossObjectIdentifier(fp) != OBJID) {
+		print_error("Bad Object Identifier", token, type);
+		free_node(np);
+		return 0;
+	    }
+	    break;
+
+	default:
+	    print_error("Bad format of optional clauses", token, type);
+	    free_node(np);
+	    return 0;
+
+	}
+	type = get_token(fp, token);
     }
-    if (type != EQUALS){
+    if (type != EQUALS) {
 	print_error("Bad format", token, type);
 	free_node(np);
 	return 0;
     }
     length = getoid(fp, oid, 32);
-    if (length > 1 && length <= 32){
+    if (length > 1 && length <= 32) {
 	/* just take the last pair in the oid list */
 	if (oid[length - 2].label)
 	    strncpy(np->parent, oid[length - 2].label, MAXLABEL);
@@ -1138,12 +1138,12 @@ printf("Description== \"%.50s\"\n", quoted_string_buffer);
 	else
 	    print_error("Warning: This entry is pretty silly", np->label, type);
     } else {
-	print_error("No end to oid", (char *)NULL, type);
+	print_error("No end to oid", (char *) NULL, type);
 	free_node(np);
 	np = 0;
     }
     /* free oid array */
-    for(count = 0; count < length; count++){
+    for (count = 0; count < length; count++) {
 	if (oid[count].label)
 	    free(oid[count].label);
 	oid[count].label = 0;
@@ -1158,45 +1158,45 @@ printf("Description== \"%.50s\"\n", quoted_string_buffer);
  */
 static struct node *
 parse_objectgroup(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[MAXTOKEN];
     int count, length;
     struct subid oid[32];
     struct node *np;
 
-    np = (struct node *)Malloc(sizeof(struct node));
+    np = (struct node *) Malloc(sizeof(struct node));
     np->type = 0;
     np->next = 0;
     np->enums = 0;
-    np->description = NULL;        /* default to an empty description */
+    np->description = NULL;	/* default to an empty description */
     type = get_token(fp, token);
     while (type != EQUALS) {
-      switch (type) {
-        case DESCRIPTION:
-          type = get_token(fp, token);
-          if (type != QUOTESTRING) {
-              print_error("Bad DESCRIPTION", token, type);
-              free_node(np);
-              return 0;
-          }
+	switch (type) {
+	case DESCRIPTION:
+	    type = get_token(fp, token);
+	    if (type != QUOTESTRING) {
+		print_error("Bad DESCRIPTION", token, type);
+		free_node(np);
+		return 0;
+	    }
 #ifdef TEST
-printf("Description== \"%.50s\"\n", quoted_string_buffer);
+	    printf("Description== \"%.50s\"\n", quoted_string_buffer);
 #endif
-	  np->description = quoted_string_buffer;
-	  quoted_string_buffer = (char *)calloc(1, MAXQUOTESTR);
-          break;
-
-        default:
-	  /* NOTHING */
-	  break;
-      }
-      type = get_token(fp, token);
+	    np->description = quoted_string_buffer;
+	    quoted_string_buffer = (char *) calloc(1, MAXQUOTESTR);
+	    break;
+
+	default:
+	    /* NOTHING */
+	    break;
+	}
+	type = get_token(fp, token);
     }
     length = getoid(fp, oid, 32);
-    if (length > 1 && length <= 32){
+    if (length > 1 && length <= 32) {
 	/* just take the last pair in the oid list */
 	if (oid[length - 2].label)
 	    strncpy(np->parent, oid[length - 2].label, MAXLABEL);
@@ -1206,12 +1206,12 @@ printf("Description== \"%.50s\"\n", quoted_string_buffer);
 	else
 	    print_error("Warning: This entry is pretty silly", np->label, type);
     } else {
-	print_error("No end to oid", (char *)NULL, type);
+	print_error("No end to oid", (char *) NULL, type);
 	free_node(np);
 	np = 0;
     }
     /* free oid array */
-    for(count = 0; count < length; count++){
+    for (count = 0; count < length; count++) {
 	if (oid[count].label)
 	    free(oid[count].label);
 	oid[count].label = 0;
@@ -1225,45 +1225,45 @@ printf("Description== \"%.50s\"\n", quoted_string_buffer);
  */
 static struct node *
 parse_notificationDefinition(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[MAXTOKEN];
     int count, length;
     struct subid oid[32];
     struct node *np;
 
-    np = (struct node *)Malloc(sizeof(struct node));
+    np = (struct node *) Malloc(sizeof(struct node));
     np->type = 0;
     np->next = 0;
     np->enums = 0;
-    np->description = NULL;        /* default to an empty description */
+    np->description = NULL;	/* default to an empty description */
     type = get_token(fp, token);
     while (type != EQUALS) {
-      switch (type) {
-        case DESCRIPTION:
-          type = get_token(fp, token);
-          if (type != QUOTESTRING) {
-              print_error("Bad DESCRIPTION", token, type);
-              free_node(np);
-              return 0;
-          }
+	switch (type) {
+	case DESCRIPTION:
+	    type = get_token(fp, token);
+	    if (type != QUOTESTRING) {
+		print_error("Bad DESCRIPTION", token, type);
+		free_node(np);
+		return 0;
+	    }
 #ifdef TEST
-printf("Description== \"%.50s\"\n", quoted_string_buffer);
+	    printf("Description== \"%.50s\"\n", quoted_string_buffer);
 #endif
-	  np->description = quoted_string_buffer;
-	  quoted_string_buffer = (char *)calloc(1, MAXQUOTESTR);
-          break;
-
-        default:
-	  /* NOTHING */
-	  break;
-      }
-      type = get_token(fp, token);
+	    np->description = quoted_string_buffer;
+	    quoted_string_buffer = (char *) calloc(1, MAXQUOTESTR);
+	    break;
+
+	default:
+	    /* NOTHING */
+	    break;
+	}
+	type = get_token(fp, token);
     }
     length = getoid(fp, oid, 32);
-    if (length > 1 && length <= 32){
+    if (length > 1 && length <= 32) {
 	/* just take the last pair in the oid list */
 	if (oid[length - 2].label)
 	    strncpy(np->parent, oid[length - 2].label, MAXLABEL);
@@ -1273,12 +1273,12 @@ printf("Description== \"%.50s\"\n", quoted_string_buffer);
 	else
 	    print_error("Warning: This entry is pretty silly", np->label, type);
     } else {
-	print_error("No end to oid", (char *)NULL, type);
+	print_error("No end to oid", (char *) NULL, type);
 	free_node(np);
 	np = 0;
     }
     /* free oid array */
-    for(count = 0; count < length; count++){
+    for (count = 0; count < length; count++) {
 	if (oid[count].label)
 	    free(oid[count].label);
 	oid[count].label = 0;
@@ -1292,26 +1292,26 @@ printf("Description== \"%.50s\"\n", quoted_string_buffer);
  */
 static struct node *
 parse_compliance(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[MAXTOKEN];
     int count, length;
     struct subid oid[32];
     struct node *np;
 
-    np = (struct node *)Malloc(sizeof(struct node));
+    np = (struct node *) Malloc(sizeof(struct node));
     np->type = 0;
     np->next = 0;
     np->enums = 0;
-    np->description = NULL;        /* default to an empty description */
+    np->description = NULL;	/* default to an empty description */
     type = get_token(fp, token);
     while (type != EQUALS) {
 	type = get_token(fp, token);
     }
     length = getoid(fp, oid, 32);
-    if (length > 1 && length <= 32){
+    if (length > 1 && length <= 32) {
 	/* just take the last pair in the oid list */
 	if (oid[length - 2].label)
 	    strncpy(np->parent, oid[length - 2].label, MAXLABEL);
@@ -1321,12 +1321,12 @@ parse_compliance(fp, name)
 	else
 	    print_error("Warning: This entry is pretty silly", np->label, type);
     } else {
-	print_error("No end to oid", (char *)NULL, type);
+	print_error("No end to oid", (char *) NULL, type);
 	free_node(np);
 	np = 0;
     }
     /* free oid array */
-    for(count = 0; count < length; count++){
+    for (count = 0; count < length; count++) {
 	if (oid[count].label)
 	    free(oid[count].label);
 	oid[count].label = 0;
@@ -1342,26 +1342,26 @@ parse_compliance(fp, name)
  */
 static struct node *
 parse_moduleIdentity(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[MAXTOKEN];
     int count, length;
     struct subid oid[32];
     struct node *np;
 
-    np = (struct node *)Malloc(sizeof(struct node));
+    np = (struct node *) Malloc(sizeof(struct node));
     np->type = 0;
     np->next = 0;
     np->enums = 0;
-    np->description = NULL;        /* default to an empty description */
+    np->description = NULL;	/* default to an empty description */
     type = get_token(fp, token);
     while (type != EQUALS) {
 	type = get_token(fp, token);
     }
     length = getoid(fp, oid, 32);
-    if (length > 1 && length <= 32){
+    if (length > 1 && length <= 32) {
 	/* just take the last pair in the oid list */
 	if (oid[length - 2].label)
 	    strncpy(np->parent, oid[length - 2].label, MAXLABEL);
@@ -1371,34 +1371,35 @@ parse_moduleIdentity(fp, name)
 	else
 	    print_error("Warning: This entry is pretty silly", np->label, type);
     } else {
-	print_error("No end to oid", (char *)NULL, type);
+	print_error("No end to oid", (char *) NULL, type);
 	free_node(np);
 	np = 0;
     }
     /* free oid array */
-    for(count = 0; count < length; count++){
+    for (count = 0; count < length; count++) {
 	if (oid[count].label)
 	    free(oid[count].label);
 	oid[count].label = 0;
     }
     return np;
 }
 
-int parse_mib_header(fp, name)
-    FILE *fp;
-    char *name;
+int 
+parse_mib_header(fp, name)
+     FILE *fp;
+     char *name;
 {
     int type = DEFINITIONS;
     char token[MAXTOKEN];
-    
+
     /* This probably isn't good enough.  If there is no
-       imports clause we can't go around waiting (forever) for a semicolon.
-       We need to check for semi following an EXPORTS clause or an IMPORTS
-       clause of both.  Look for BEGIN; in my initial MIBs to see those
-       that I needed to hack to get to parse because they didn't have
-       an IMPORTS or and EXPORTS clause.
-       */
-    while(type != SEMI && type != ENDOFFILE){
+     * imports clause we can't go around waiting (forever) for a semicolon.
+     * We need to check for semi following an EXPORTS clause or an IMPORTS
+     * clause of both.  Look for BEGIN; in my initial MIBs to see those
+     * that I needed to hack to get to parse because they didn't have
+     * an IMPORTS or and EXPORTS clause.
+     */
+    while (type != SEMI && type != ENDOFFILE) {
 	type = get_token(fp, token);
     }
     return (type == SEMI);
@@ -1412,196 +1413,196 @@ int parse_mib_header(fp, name)
  */
 static struct node *
 parse(fp)
-    FILE *fp;
+     FILE *fp;
 {
     char token[MAXTOKEN];
     char name[MAXTOKEN];
-    int	type = 1;
+    int type = 1;
 #define BETWEEN_MIBS  	      1
 #define IN_MIB                2
     int state = BETWEEN_MIBS;
     struct node *np = 0, *root = NULL;
 
     hash_init();
-    quoted_string_buffer = (char *)calloc(1, MAXQUOTESTR);  /* free this later */
+    quoted_string_buffer = (char *) calloc(1, MAXQUOTESTR);	/* free this later */
     bzero(tclist, 64 * sizeof(struct tc));
 
-    while(type != ENDOFFILE){
+    while (type != ENDOFFILE) {
 	type = get_token(fp, token);
-skipget:
-	if (type == END){
-	    if (state != IN_MIB){
-		print_error("Error, end before start of MIB.", (char *)NULL, type);
+      skipget:
+	if (type == END) {
+	    if (state != IN_MIB) {
+		print_error("Error, end before start of MIB.", (char *) NULL, type);
 		return NULL;
 	    }
 	    state = BETWEEN_MIBS;
 	    continue;
-	} else if (type != LABEL){
-	    if (type == ENDOFFILE){
+	} else if (type != LABEL) {
+	    if (type == ENDOFFILE) {
 		return root;
 	    }
 	    print_error(token, "is a reserved word", type);
 	    return NULL;
 	}
 	strncpy(name, token, MAXTOKEN);
 	type = get_token(fp, token);
-	if (type == DEFINITIONS){
-	    if (state != BETWEEN_MIBS){
-		print_error("Error, nested MIBS.", (char *)NULL, type);
+	if (type == DEFINITIONS) {
+	    if (state != BETWEEN_MIBS) {
+		print_error("Error, nested MIBS.", (char *) NULL, type);
 		return NULL;
 	    }
 	    state = IN_MIB;
-	    if (!parse_mib_header(fp, name)){
-		print_error("Bad parse of module header", (char *)NULL, type);
+	    if (!parse_mib_header(fp, name)) {
+		print_error("Bad parse of module header", (char *) NULL, type);
 		return NULL;
 	    }
-       } else if (type == OBJTYPE){
-	    if (root == NULL){
+	} else if (type == OBJTYPE) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_objecttype(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of object type", (char *)NULL,
-				type);
+		if (np == NULL) {
+		    print_error("Bad parse of object type", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_objecttype(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of objecttype", (char *)NULL,
-				type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of objecttype", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == OBJGROUP){
-	    if (root == NULL){
+	} else if (type == OBJGROUP) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_objectgroup(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of object group", (char *)NULL,
-				type);
+		if (np == NULL) {
+		    print_error("Bad parse of object group", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_objectgroup(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of objectgroup", (char *)NULL,
-				type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of objectgroup", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == NOTIFTYPE){
-	    if (root == NULL){
+	} else if (type == NOTIFTYPE) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_notificationDefinition(fp, name);
-		if (np == NULL){
+		if (np == NULL) {
 		    print_error("Bad parse of notification definition",
-				(char *)NULL, type);
+			(char *) NULL, type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_notificationDefinition(fp, name);
-		if (np->next == NULL){
+		if (np->next == NULL) {
 		    print_error("Bad parse of notification definition",
-				(char *)NULL, type);
+			(char *) NULL, type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == COMPLIANCE){
-	    if (root == NULL){
+	} else if (type == COMPLIANCE) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_compliance(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of module compliance", (char *)NULL,
-				type);
+		if (np == NULL) {
+		    print_error("Bad parse of module compliance", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_compliance(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of module compliance", (char *)NULL,
-				type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of module compliance", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == MODULEIDENTITY){
-	    if (root == NULL){
+	} else if (type == MODULEIDENTITY) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_moduleIdentity(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of module identity", (char *)NULL,
-				type);
+		if (np == NULL) {
+		    print_error("Bad parse of module identity", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_moduleIdentity(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of module identity", (char *)NULL,
-				type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of module identity", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == OBJID){
-	    if (root == NULL){
+	} else if (type == OBJID) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_objectid(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of object id", (char *)NULL, type);
+		if (np == NULL) {
+		    print_error("Bad parse of object id", (char *) NULL, type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_objectid(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of object type", (char *)NULL,
-				type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of object type", (char *) NULL,
+			type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == EQUALS){
-	    if (!parse_asntype(fp, name, &type, token)){
+	} else if (type == EQUALS) {
+	    if (!parse_asntype(fp, name, &type, token)) {
 		print_error("Bad parse of ASN type definition.", NULL, EQUALS);
 		return NULL;
 	    }
 	    goto skipget;
-	} else if (type == ENDOFFILE){
+	} else if (type == ENDOFFILE) {
 	    break;
 	} else {
-	    print_error("Bad operator", (char *)NULL, type);
+	    print_error("Bad operator", (char *) NULL, type);
 	    return NULL;
 	}
     }
 #ifdef TEST
-{
-    struct enum_list *ep;
-    
-    for(np = root; np; np = np->next){
-	printf("%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
+    {
+	struct enum_list *ep;
+
+	for (np = root; np; np = np->next) {
+	    printf("%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
 		np->type);
-	if (np->enums){
-	    printf("Enums: \n");
-	    for(ep = np->enums; ep; ep = ep->next){
-		printf("%s(%d)\n", ep->label, ep->value);
+	    if (np->enums) {
+		printf("Enums: \n");
+		for (ep = np->enums; ep; ep = ep->next) {
+		    printf("%s(%d)\n", ep->label, ep->value);
+		}
 	    }
 	}
     }
-}
 #endif /* TEST */
     return root;
 }
@@ -1612,8 +1613,8 @@ parse(fp)
  */
 static int
 get_token(fp, token)
-    FILE *fp;
-    char *token;
+     FILE *fp;
+     char *token;
 {
     static char last = ' ';
     int ch;
@@ -1624,7 +1625,7 @@ get_token(fp, token)
     *cp = 0;
     ch = last;
     /* skip all white space */
-    while(isspace(ch) && ch != -1){
+    while (isspace(ch) && ch != -1) {
 	ch = getc(fp);
 	if (ch == '\n')
 	    Line++;
@@ -1634,7 +1635,6 @@ get_token(fp, token)
     } else if (ch == '"') {
 	return parseQuoteString(fp, token);
     }
-
     /*
      * Accumulate characters until end of token is found.  Then attempt to
      * match this token as a reserved word.  If a match is found, return the
@@ -1644,8 +1644,8 @@ get_token(fp, token)
 	if (ch == '\n')
 	    Line++;
 	if (isspace(ch) || ch == '(' || ch == ')' || ch == '{' || ch == '}' ||
-	    ch == ',' || ch == ';'){
-	    if (!isspace(ch) && *token == 0){
+	    ch == ',' || ch == ';') {
+	    if (!isspace(ch) && *token == 0) {
 		hash += ch;
 		*cp++ = ch;
 		last = ' ';
@@ -1656,29 +1656,28 @@ get_token(fp, token)
 
 	    for (tp = buckets[BUCKET(hash)]; tp; tp = tp->next) {
 		if ((tp->hash == hash) && (strcmp(tp->name, token) == 0))
-			break;
+		    break;
 	    }
-	    if (tp){
+	    if (tp) {
 		if (tp->token == CONTINUE)
 		    continue;
 		return (tp->token);
 	    }
-
-	    if (token[0] == '-' && token[1] == '-'){
+	    if (token[0] == '-' && token[1] == '-') {
 		/* strip comment */
-		if (ch != '\n'){
+		if (ch != '\n') {
 		    while ((ch = getc(fp)) != -1)
-			if (ch == '\n'){
+			if (ch == '\n') {
 			    Line++;
 			    break;
 			}
 		}
 		if (ch == -1)
 		    return ENDOFFILE;
 		last = ch;
-		return get_token(fp, token);		
+		return get_token(fp, token);
 	    }
-	    for(cp = token; *cp; cp++)
+	    for (cp = token; *cp; cp++)
 		if (!isdigit(*cp))
 		    return LABEL;
 	    return NUMBER;
@@ -1688,14 +1687,14 @@ get_token(fp, token)
 	    if (ch == '\n')
 		Line++;
 	}
-    
+
     } while ((ch = getc(fp)) != -1);
     return ENDOFFILE;
 }
 
 struct tree *
 read_mib(filename)
-    char *filename;
+     char *filename;
 {
     FILE *fp;
     struct node *nodes;
@@ -1705,7 +1704,7 @@ read_mib(filename)
     if (fp == NULL)
 	return NULL;
     nodes = parse(fp);
-    if (!nodes){
+    if (!nodes) {
 	fprintf(stderr, "Mib table is bad.  Exiting\n");
 	exit(1);
     }
@@ -1717,15 +1716,15 @@ read_mib(filename)
 
 #ifdef TEST
 main(argc, argv)
-    int argc;
-    char *argv[];
+     int argc;
+     char *argv[];
 {
     FILE *fp;
     struct node *nodes;
     struct tree *tp;
 
     fp = fopen("mib.txt", "r");
-    if (fp == NULL){
+    if (fp == NULL) {
 	fprintf(stderr, "open failed\n");
 	return 1;
     }
@@ -1739,22 +1738,21 @@ main(argc, argv)
 
 static int
 parseQuoteString(fp, token)
-    FILE *fp;
-    char *token;
+     FILE *fp;
+     char *token;
 {
     int ch;
 
     ch = ' ';
-    *token = '\0';                      /* make the token empty */
+    *token = '\0';		/* make the token empty */
 
-    while(ch != -1) {
-        ch = getc(fp);
+    while (ch != -1) {
+	ch = getc(fp);
 	if (ch == '\n')
 	    Line++;
 	else if (ch == '"') {
-            return QUOTESTRING;
-        }
-
+	    return QUOTESTRING;
+	}
     }
 
     return 0;
@@ -1766,30 +1764,30 @@ parseQuoteString(fp, token)
  */
 static int
 tossObjectIdentifier(fp)
-    FILE *fp;
+     FILE *fp;
 {
     int ch;
 
-        ch = getc(fp);
+    ch = getc(fp);
 /*    ch = last; = ' '? */
     /* skip all white space */
-    while(isspace(ch) && ch != -1){
-        ch = getc(fp);
-        if (ch == '\n')
-            Line++;
+    while (isspace(ch) && ch != -1) {
+	ch = getc(fp);
+	if (ch == '\n')
+	    Line++;
     }
     if (ch != '{')
-        return 0;
+	return 0;
 
-    while(ch != -1) {
-        ch = getc(fp);
+    while (ch != -1) {
+	ch = getc(fp);
 
-        if (ch == '\n')
-            Line++;
-        else if (ch == '}')
-            return OBJID;
+	if (ch == '\n')
+	    Line++;
+	else if (ch == '}')
+	    return OBJID;
     }
 
-/*    last = ch;*/
+/*    last = ch; */
     return 0;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.119 1997/11/17 22:11:24 wessels Exp $
+ * $Id: acl.cc,v 1.120 1997/11/21 01:59:14 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -1073,7 +1073,7 @@ aclMatchProxyAuth(struct _acl_proxy_auth *p, aclCheck_t * checklist)
     if ((passwd = strchr(sent_user, ':')) != NULL)
 	*passwd++ = '\0';
     if (passwd == NULL) {
-        debug(28, 3) ("aclMatchProxyAuth: No passwd in auth blob\n");
+	debug(28, 3) ("aclMatchProxyAuth: No passwd in auth blob\n");
 	return 0;
     }
     debug(28, 5) ("aclMatchProxyAuth: checking user %s\n", sent_user);
@@ -1,6 +1,7 @@
 
+
 /*
- * $Id: client.cc,v 1.41 1997/11/21 00:29:34 wessels Exp $
+ * $Id: client.cc,v 1.42 1997/11/21 01:59:15 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -195,7 +195,7 @@ typedef enum {
     ICP_UNUSED19,
     ICP_UNUSED20,
     ICP_MISS_NOFETCH,
-    ICP_DENIED,	
+    ICP_DENIED,
     ICP_HIT_OBJ,
     ICP_END
 } icp_opcode;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.193 1997/11/21 00:29:36 wessels Exp $
+ * $Id: main.cc,v 1.194 1997/11/21 01:59:16 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -404,7 +404,7 @@ serverConnectionsOpen(void)
 	}
     }
 #ifdef SQUID_SNMP
-        initSquidSnmp();
+    initSquidSnmp();
 #endif
 
     clientdbInit();
@@ -572,7 +572,7 @@ mainInitialize(void)
     configured_once = 1;
 
 #ifdef SQUID_SNMP
-	init_snmp();
+    init_snmp();
 #endif
 }
 
@@ -239,8 +239,8 @@ extern PF icpHandleUdp;
 extern PF httpAccept;
 extern DEFER httpAcceptDefer;
 #ifdef SQUID_SNMP
-/*extern PF snmpHandleUdp;*/
-/*extern void initSquidSnmp();*/
+/*extern PF snmpHandleUdp; */
+/*extern void initSquidSnmp(); */
 #endif /* SQUID_SNMP */
 
 extern void icpSendERROR(int fd,