@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.78 1997/06/21 02:38:03 wessels Exp $
+#  $Id: Makefile.in,v 1.79 1997/06/26 22:41:35 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -177,6 +177,27 @@ squid.conf: squid.conf.pre Makefile
 	s%@DEFAULT_PID_FILE@%$(DEFAULT_PID_FILE)%g;\
 	s%@DEFAULT_SWAP_DIR@%$(DEFAULT_SWAP_DIR)%g" < squid.conf.pre >$@
 
+cache_cf.o: cf_parser.c
+
+cf_parser.c: cf.data cf_gen
+	./cf_gen cf.data
+
+cf_gen: cf_gen.o
+	$(CC) -o $@ cf_gen.o
+
+cf.data: cf.data.pre Makefile
+	sed "\
+	s%@DEFAULT_CONFIG_FILE@%$(DEFAULT_CONFIG_FILE)%g;\
+	s%@DEFAULT_MIME_TABLE@%$(DEFAULT_MIME_TABLE)%g;\
+	s%@DEFAULT_DNSSERVER@%$(DEFAULT_DNSSERVER)%g;\
+	s%@DEFAULT_UNLINKD@%$(DEFAULT_UNLINKD)%g;\
+	s%@DEFAULT_PINGER@%$(DEFAULT_PINGER)%g;\
+	s%@DEFAULT_CACHE_LOG@%$(DEFAULT_CACHE_LOG)%g;\
+	s%@DEFAULT_ACCESS_LOG@%$(DEFAULT_ACCESS_LOG)%g;\
+	s%@DEFAULT_STORE_LOG@%$(DEFAULT_STORE_LOG)%g;\
+	s%@DEFAULT_PID_FILE@%$(DEFAULT_PID_FILE)%g;\
+	s%@DEFAULT_SWAP_DIR@%$(DEFAULT_SWAP_DIR)%g" < cf.data.pre >$@
+
 install-mkdirs:
 	-@if test ! -d $(prefix); then \
 		echo "mkdir $(prefix)"; \
@@ -276,6 +297,7 @@ install-pinger:
 
 clean: 
 	-rm -rf *.o *pure_* core $(PROGS) $(UTILS) $(CGIPROGS) $(SUID_UTILS)
+	-rm -f cf_gen cf_parser.c cf.data
 
 distclean:	clean
 	-rm -f Makefile squid.conf squid.conf.pre
@@ -1,5 +1,5 @@
 /*
- * $Id: cache_cf.cc,v 1.197 1997/06/21 02:38:04 wessels Exp $
+ * $Id: cache_cf.cc,v 1.198 1997/06/26 22:41:37 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -232,43 +232,21 @@ int config_lineno = 0;
 
 static char fatal_str[BUFSIZ];
 static char *safe_xstrdup _PARAMS((const char *p));
-static void parseOnOff _PARAMS((int *));
-static void parseIntegerValue _PARAMS((int *));
-static void parseString _PARAMS((char **));
 static void self_destruct _PARAMS((void));
 static void wordlistAdd _PARAMS((wordlist **, const char *));
 
 static void configDoConfigure _PARAMS((void));
 static void configSetFactoryDefaults _PARAMS((void));
-static void parseAddressLine _PARAMS((struct in_addr *));
-static void parseAnnounceToLine _PARAMS((void));
-static void parseAppendDomainLine _PARAMS((void));
-static void parseCacheAnnounceLine _PARAMS((void));
-static void parseCacheHostLine _PARAMS((void));
-static void parseDebugOptionsLine _PARAMS((void));
-static void parseEffectiveUserLine _PARAMS((void));
-static void parseErrHtmlLine _PARAMS((void));
-static void parseWordlist _PARAMS((wordlist **));
-static void parseHostAclLine _PARAMS((void));
-static void parseHostDomainLine _PARAMS((void));
-static void parseHostDomainTypeLine _PARAMS((void));
-static void parseHttpPortLine _PARAMS((void));
-static void parseHttpdAccelLine _PARAMS((void));
-static void parseIcpPortLine _PARAMS((void));
-static void parseMcastGroupLine _PARAMS((void));
-static void parseMemLine _PARAMS((void));
-static void parseMgrLine _PARAMS((void));
-static void parseKilobytes _PARAMS((int *));
 static void parseRefreshPattern _PARAMS((int icase));
-static void parseVisibleHostnameLine _PARAMS((void));
-static void parseWAISRelayLine _PARAMS((void));
-static void parseCachemgrPasswd _PARAMS((void));
-static void parsePathname _PARAMS((char **, int fatal));
-static void parseProxyLine _PARAMS((peer **));
-static void parseHttpAnonymizer _PARAMS((int *));
 static int parseTimeUnits _PARAMS((const char *unit));
 static void parseTimeLine _PARAMS((int *iptr, const char *units));
 
+static void parse_string _PARAMS((char **));
+static void parse_wordlist _PARAMS((wordlist **));
+static void dump_all _PARAMS((void));
+static void default_all _PARAMS((void));
+static int parse_line _PARAMS((char[]));
+
 static void
 self_destruct(void)
 {
@@ -337,106 +315,6 @@ intlistDestroy(intlist ** list)
 	if (sscanf(token, "%d", &var) != 1) \
 		self_destruct();
 
-
-static void
-parseCacheHostLine(void)
-{
-    char *type = NULL;
-    char *hostname = NULL;
-    char *token = NULL;
-    u_short http_port = CACHE_HTTP_PORT;
-    u_short icp_port = CACHE_ICP_PORT;
-    int options = 0;
-    int weight = 1;
-    int mcast_ttl = 0;
-    int i;
-
-    if (!(hostname = strtok(NULL, w_space)))
-	self_destruct();
-    if (!(type = strtok(NULL, w_space)))
-	self_destruct();
-
-    GetInteger(i);
-    http_port = (u_short) i;
-    GetInteger(i);
-    icp_port = (u_short) i;
-    while ((token = strtok(NULL, w_space))) {
-	if (!strcasecmp(token, "proxy-only")) {
-	    options |= NEIGHBOR_PROXY_ONLY;
-	} else if (!strcasecmp(token, "no-query")) {
-	    options |= NEIGHBOR_NO_QUERY;
-	} else if (!strcasecmp(token, "multicast-responder")) {
-	    options |= NEIGHBOR_MCAST_RESPONDER;
-	} else if (!strncasecmp(token, "weight=", 7)) {
-	    weight = atoi(token + 7);
-	} else if (!strncasecmp(token, "ttl=", 4)) {
-	    mcast_ttl = atoi(token + 4);
-	    if (mcast_ttl < 0)
-		mcast_ttl = 0;
-	    if (mcast_ttl > 128)
-		mcast_ttl = 128;
-	} else if (!strncasecmp(token, "default", 7)) {
-	    options |= NEIGHBOR_DEFAULT_PARENT;
-	} else if (!strncasecmp(token, "round-robin", 11)) {
-	    options |= NEIGHBOR_ROUNDROBIN;
-	} else {
-	    debug(3, 0) ("parseCacheHostLine: token='%s'\n", token);
-	    self_destruct();
-	}
-    }
-    if (weight < 1)
-	weight = 1;
-    neighborAdd(hostname, type, http_port, icp_port, options,
-	weight, mcast_ttl);
-}
-
-
-static void
-parseHostDomainLine(void)
-{
-    char *host = NULL;
-    char *domain = NULL;
-    if (!(host = strtok(NULL, w_space)))
-	self_destruct();
-    while ((domain = strtok(NULL, list_sep)))
-	neighborAddDomainPing(host, domain);
-}
-
-static void
-parseHostDomainTypeLine(void)
-{
-    char *host = NULL;
-    char *type = NULL;
-    char *domain = NULL;
-    if (!(host = strtok(NULL, w_space)))
-	self_destruct();
-    if (!(type = strtok(NULL, w_space)))
-	self_destruct();
-    while ((domain = strtok(NULL, list_sep)))
-	neighborAddDomainType(host, domain, type);
-}
-
-static void
-parseHostAclLine(void)
-{
-    char *host = NULL;
-    char *aclname = NULL;
-    if (!(host = strtok(NULL, w_space)))
-	self_destruct();
-    while ((aclname = strtok(NULL, list_sep)))
-	neighborAddAcl(host, aclname);
-}
-
-static void
-parseMemLine(void)
-{
-    char *token;
-    int i;
-    GetInteger(i);
-    Config.Mem.maxSize = i << 20;
-}
-
-
 static void
 parseRefreshPattern(int icase)
 {
@@ -460,172 +338,364 @@ parseRefreshPattern(int icase)
     safe_free(pattern);
 }
 
-static void
-parseQuickAbort(void)
+int
+parseConfigFile(const char *file_name)
 {
-    char *token;
-    int i;
-    token = strtok(NULL, w_space);
-    if (!strcasecmp(token, "on")) {
-	Config.quickAbort.min = 10 << 10;	/* 10k */
-	Config.quickAbort.pct = 64;	/* 50% */
-	Config.quickAbort.max = 100 << 10;	/* 100k */
-    } else if (!strcasecmp(token, "off")) {
-	Config.quickAbort.min = -1;
-	Config.quickAbort.pct = 0;
-	Config.quickAbort.max = 0;
-    } else {
-	if (sscanf(token, "%d", &i) != 1)
-	    self_destruct();
-	Config.quickAbort.min = i * 1024;
-	GetInteger(i);
-	Config.quickAbort.pct = i * 128 / 100;	/* 128 is full scale */
-	GetInteger(i);
-	Config.quickAbort.max = i * 1024;
+    FILE *fp = NULL;
+    char *token = NULL;
+    LOCAL_ARRAY(char, tmp_line, BUFSIZ);
+
+    configFreeMemory();
+    configSetFactoryDefaults();
+    aclDestroyAcls();
+    aclDestroyDenyInfoList(&Config.denyInfoList);
+    aclDestroyAccessList(&Config.accessList.HTTP);
+    aclDestroyAccessList(&Config.accessList.ICP);
+    aclDestroyAccessList(&Config.accessList.MISS);
+    aclDestroyAccessList(&Config.accessList.NeverDirect);
+    aclDestroyAccessList(&Config.accessList.AlwaysDirect);
+    aclDestroyRegexList(Config.cache_stop_relist);
+    Config.cache_stop_relist = NULL;
+
+    if ((fp = fopen(file_name, "r")) == NULL) {
+	sprintf(fatal_str, "Unable to open configuration file: %s: %s",
+	    file_name, xstrerror());
+	fatal(fatal_str);
+    }
+    cfg_filename = file_name;
+    if ((token = strrchr(cfg_filename, '/')))
+	cfg_filename = token + 1;
+    memset(config_input_line, '\0', BUFSIZ);
+    config_lineno = 0;
+    while (fgets(config_input_line, BUFSIZ, fp)) {
+	config_lineno++;
+	if ((token = strchr(config_input_line, '\n')))
+	    *token = '\0';
+	if (config_input_line[0] == '#')
+	    continue;
+	if (config_input_line[0] == '\0')
+	    continue;
+	debug(3, 5) ("Processing: '%s'\n", config_input_line);
+	strcpy(tmp_line, config_input_line);
+	if (!parse_line(tmp_line)) {
+	    debug(3, 0) ("parseConfigFile: line %d unrecognized: '%s'\n",
+		config_lineno,
+		config_input_line);
+	}
+    }
+
+    /* Scale values */
+    Config.maxRequestSize <<= 10;	/* 1k */
+    Config.Store.maxObjectSize <<= 10;	/* 1k */
+    Config.Mem.maxSize <<= 10;	/* 1m */
+
+    /* Sanity checks */
+    if (Config.Swap.maxSize < (Config.Mem.maxSize >> 10)) {
+	printf("WARNING: cache_swap (%d kbytes) is less than cache_mem (%d bytes).\n", Config.Swap.maxSize, Config.Mem.maxSize);
+	printf("         This will cause serious problems with your cache!!!\n");
+	printf("         Change your configuration file.\n");
+	fflush(stdout);		/* print message */
+    }
+    if (Config.cleanRate < 1)
+	Config.cleanRate = 86400 * 365;		/* one year */
+    if (Config.Announce.rate < 1) {
+	Config.Announce.rate = 86400 * 365;	/* one year */
+	Config.Announce.on = 0;
+    }
+    if (Config.dnsChildren < 0)
+	Config.dnsChildren = 0;
+    if (Config.dnsChildren < 1) {
+	printf("WARNING: dnsservers are disabled!\n");
+	printf("WARNING: Cache performance may be very poor\n");
+    } else if (Config.dnsChildren > DefaultDnsChildrenMax) {
+	printf("WARNING: dns_children was set to a bad value: %d\n",
+	    Config.dnsChildren);
+	printf("Setting it to the maximum (%d).\n", DefaultDnsChildrenMax);
+	Config.dnsChildren = DefaultDnsChildrenMax;
+    }
+    if (Config.Program.redirect) {
+	if (Config.redirectChildren < 1) {
+	    Config.redirectChildren = 0;
+	    safe_free(Config.Program.redirect);
+	} else if (Config.redirectChildren > DefaultRedirectChildrenMax) {
+	    printf("WARNING: redirect_children was set to a bad value: %d\n",
+		Config.redirectChildren);
+	    printf("Setting it to the maximum (%d).\n", DefaultRedirectChildrenMax);
+	    Config.redirectChildren = DefaultRedirectChildrenMax;
+	}
     }
+    fclose(fp);
+    configDoConfigure();
+    dump_all();
+    return 0;
 }
 
-static void
-parseKilobytes(int *val)
+static char *
+safe_xstrdup(const char *p)
 {
-    char *token;
-    int i;
-    GetInteger(i);
-    *val = i * 1024;
+    return p ? xstrdup(p) : NULL;
 }
 
-static void
-parseMgrLine(void)
+void
+configFreeMemory(void)
 {
-    char *token;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
+    safe_free(Config.Wais.relayHost);
+    safe_free(Config.Log.log);
+    safe_free(Config.Log.access);
+    safe_free(Config.Log.store);
+    safe_free(Config.Log.swap);
     safe_free(Config.adminEmail);
-    Config.adminEmail = xstrdup(token);
-}
-
+    safe_free(Config.effectiveUser);
+    safe_free(Config.effectiveGroup);
+    safe_free(Config.Program.dnsserver);
+    safe_free(Config.Program.redirect);
+    safe_free(Config.Program.unlinkd);
+    safe_free(Config.Program.pinger);
+    safe_free(Config.Accel.host);
+    safe_free(Config.Accel.prefix);
+    safe_free(Config.appendDomain);
+    safe_free(Config.debugOptions);
+    safe_free(Config.pidFilename);
+    safe_free(Config.mimeTablePathname);
+    safe_free(Config.visibleHostname);
 #if USE_PROXY_AUTH
-static void
-parseProxyAuthLine(void)
-{
-    char *token;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
     safe_free(Config.proxyAuth.File);
     aclDestroyRegexList(Config.proxyAuth.IgnoreDomains);
     Config.proxyAuth.IgnoreDomains = NULL;
-    Config.proxyAuth.File = xstrdup(token);
-    aclParseRegexList(&Config.proxyAuth.IgnoreDomains, 1);
-}
 #endif /* USE_PROXY_AUTH */
+    safe_free(Config.Announce.host);
+    safe_free(Config.Announce.file);
+    safe_free(Config.errHtmlText);
+    safe_free(Config.Ftp.icon_prefix);
+    safe_free(Config.Ftp.icon_suffix);
+    safe_free(Config.Ftp.anon_user);
+    peerDestroy(Config.sslProxy);
+    peerDestroy(Config.passProxy);
+    wordlistDestroy(&Config.hierarchy_stoplist);
+    wordlistDestroy(&Config.mcast_group_list);
+    wordlistDestroy(&Config.dns_testname_list);
+    wordlistDestroy(&Config.cache_stoplist);
+    objcachePasswdDestroy(&Config.passwd_list);
+    refreshFreeMemory();
+}
+
 
 static void
-parseHttpdAccelLine(void)
+configSetFactoryDefaults(void)
 {
-    char *token;
-    LOCAL_ARRAY(char, buf, BUFSIZ);
-    int i;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    safe_free(Config.Accel.host);
-    Config.Accel.host = xstrdup(token);
-    GetInteger(i);
-    Config.Accel.port = i;
-    safe_free(Config.Accel.prefix);
-    sprintf(buf, "http://%s:%d", Config.Accel.host, Config.Accel.port);
-    Config.Accel.prefix = xstrdup(buf);
-    httpd_accel_mode = 1;
+    memset(&Config, '\0', sizeof(Config));
+    Config.Mem.maxSize = DefaultMemMaxSize;
+    Config.Mem.highWaterMark = DefaultMemHighWaterMark;
+    Config.Mem.lowWaterMark = DefaultMemLowWaterMark;
+    Config.Swap.maxSize = DefaultSwapMaxSize;
+    Config.Swap.highWaterMark = DefaultSwapHighWaterMark;
+    Config.Swap.lowWaterMark = DefaultSwapLowWaterMark;
+    Config.Netdb.high = DefaultNetdbHigh;
+    Config.Netdb.low = DefaultNetdbLow;
+    Config.Netdb.period = DefaultNetdbPeriod;
+
+    Config.Wais.relayHost = safe_xstrdup(DefaultWaisRelayHost);
+    Config.Wais.relayPort = DefaultWaisRelayPort;
+
+    Config.referenceAge = DefaultReferenceAge;
+    Config.negativeTtl = DefaultNegativeTtl;
+    Config.negativeDnsTtl = DefaultNegativeDnsTtl;
+    Config.positiveDnsTtl = DefaultPositiveDnsTtl;
+    Config.Timeout.read = DefaultReadTimeout;
+    Config.Timeout.connect = DefaultConnectTimeout;
+    Config.Timeout.defer = DefaultDeferTimeout;
+    Config.Timeout.request = DefaultRequestTimeout;
+    Config.Timeout.lifetime = DefaultClientLifetime;
+    Config.shutdownLifetime = DefaultShutdownLifetime;
+    Config.maxRequestSize = DefaultMaxRequestSize;
+    Config.cleanRate = DefaultCleanRate;
+    Config.dnsChildren = DefaultDnsChildren;
+    Config.redirectChildren = DefaultRedirectChildren;
+    Config.sourcePing = DefaultSourcePing;
+    Config.quickAbort.min = DefaultQuickAbortMin;
+    Config.quickAbort.pct = DefaultQuickAbortPct;
+    Config.quickAbort.max = DefaultQuickAbortMax;
+    Config.commonLogFormat = DefaultCommonLogFormat;
+    Config.logMimeHdrs = DefaultLogMimeHdrs;
+    Config.identLookup = DefaultIdentLookup;
+    Config.debugOptions = safe_xstrdup(DefaultDebugOptions);
+    Config.neighborTimeout = DefaultNeighborTimeout;
+    Config.stallDelay = DefaultStallDelay;
+    Config.singleParentBypass = DefaultSingleParentBypass;
+    Config.adminEmail = safe_xstrdup(DefaultAdminEmail);
+    Config.effectiveUser = safe_xstrdup(DefaultEffectiveUser);
+    Config.effectiveGroup = safe_xstrdup(DefaultEffectiveGroup);
+    Config.appendDomain = safe_xstrdup(DefaultAppendDomain);
+    Config.errHtmlText = safe_xstrdup(DefaultErrHtmlText);
+    Config.Port.icp = DefaultIcpPortNum;
+    Config.Log.log_fqdn = DefaultLogLogFqdn;
+    Config.Log.log = safe_xstrdup(DefaultCacheLogFile);
+    Config.Log.access = safe_xstrdup(DefaultAccessLogFile);
+    Config.Log.store = safe_xstrdup(DefaultStoreLogFile);
+    Config.Log.swap = safe_xstrdup(DefaultSwapLogFile);
+#if USE_USERAGENT_LOG
+    Config.Log.useragent = safe_xstrdup(DefaultUseragentLogFile);
+#endif
+    Config.Log.rotateNumber = DefaultLogRotateNumber;
+    Config.Program.dnsserver = safe_xstrdup(DefaultDnsserverProgram);
+    Config.Program.redirect = safe_xstrdup(DefaultRedirectProgram);
+    Config.Program.pinger = safe_xstrdup(DefaultPingerProgram);
+    Config.Program.unlinkd = safe_xstrdup(DefaultUnlinkdProgram);
+    Config.Accel.host = safe_xstrdup(DefaultAccelHost);
+    Config.Accel.prefix = safe_xstrdup(DefaultAccelPrefix);
+    Config.Accel.port = DefaultAccelPort;
+    Config.Accel.withProxy = DefaultAccelWithProxy;
+    Config.pidFilename = safe_xstrdup(DefaultPidFilename);
+    Config.mimeTablePathname = safe_xstrdup(DefaultMimeTable);
+    Config.visibleHostname = safe_xstrdup(DefaultVisibleHostname);
+#if USE_PROXY_AUTH
+    Config.proxyAuth.File = safe_xstrdup(DefaultProxyAuthFile);
+/*    Config.proxyAuth.IgnoreDomains = safe_xstrdup(DefaultproxyAuthIgnoreDomains); */
+#endif /* USE_PROXY_AUTH */
+    Config.Announce.host = safe_xstrdup(DefaultAnnounceHost);
+    Config.Announce.port = DefaultAnnouncePort;
+    Config.Announce.file = safe_xstrdup(DefaultAnnounceFile);
+    Config.Announce.rate = DefaultAnnounceRate;
+    Config.Announce.on = 0;
+    Config.tcpRcvBufsz = DefaultTcpRcvBufsz;
+    Config.udpMaxHitObjsz = DefaultUdpMaxHitObjsz;
+    Config.Addrs.tcp_outgoing.s_addr = DefaultTcpOutgoingAddr;
+    Config.Addrs.tcp_incoming.s_addr = DefaultTcpIncomingAddr;
+    Config.Addrs.udp_outgoing.s_addr = DefaultUdpOutgoingAddr;
+    Config.Addrs.udp_incoming.s_addr = DefaultUdpIncomingAddr;
+    Config.Addrs.client_netmask.s_addr = DefaultClientNetmask;
+    Config.passProxy = DefaultPassProxy;
+    Config.sslProxy = DefaultSslProxy;
+    Config.ipcache.size = DefaultIpcacheSize;
+    Config.ipcache.low = DefaultIpcacheLow;
+    Config.ipcache.high = DefaultIpcacheHigh;
+    Config.minDirectHops = DefaultMinDirectHops;
+    Config.Store.maxObjectSize = DefaultMaxObjectSize;
+    Config.Store.avgObjectSize = DefaultAvgObjectSize;
+    Config.Store.objectsPerBucket = DefaultObjectsPerBucket;
+    Config.Options.log_udp = DefaultOptionsLogUdp;
+    Config.Options.res_defnames = DefaultOptionsResDefnames;
+    Config.Options.anonymizer = DefaultOptionsAnonymizer;
+    Config.Options.enable_purge = DefaultOptionsEnablePurge;
+    Config.Options.client_db = DefaultOptionsClientDb;
+    Config.Options.query_icmp = DefaultOptionsQueryIcmp;
+    Config.Ftp.icon_prefix = safe_xstrdup(DefaultFtpIconPrefix);
+    Config.Ftp.icon_suffix = safe_xstrdup(DefaultFtpIconSuffix);
+    Config.Ftp.list_width = DefaultFtpListWidth;
+    Config.Ftp.list_wrap = DefaultFtpListWrap;
+    Config.Ftp.anon_user = safe_xstrdup(DefaultFtpAnonUser);
 }
 
 static void
-parseEffectiveUserLine(void)
+configDoConfigure(void)
 {
-    char *token;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    safe_free(Config.effectiveUser);
-    safe_free(Config.effectiveGroup);
-    Config.effectiveUser = xstrdup(token);
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	return;			/* group is optional */
-    Config.effectiveGroup = xstrdup(token);
+    httpd_accel_mode = Config.Accel.prefix ? 1 : 0;
+    if (Config.errHtmlText == NULL)
+	Config.errHtmlText = xstrdup(null_string);
+    storeConfigure();
+    if (httpd_accel_mode && !strcmp(Config.Accel.host, "virtual"))
+	vhost_mode = 1;
+    if (Config.Port.http == NULL)
+	fatal("No http_port specified!");
+    sprintf(ThisCache, "%s:%d (Squid/%s)",
+	getMyHostname(),
+	(int) Config.Port.http->i,
+	SQUID_VERSION);
+    if (!Config.udpMaxHitObjsz || Config.udpMaxHitObjsz > SQUID_UDP_SO_SNDBUF)
+	Config.udpMaxHitObjsz = SQUID_UDP_SO_SNDBUF;
+    if (Config.appendDomain)
+	Config.appendDomainLen = strlen(Config.appendDomain);
+    else
+	Config.appendDomainLen = 0;
 }
 
+/* Parse a time specification from the config file.  Store the
+ * result in 'iptr', after converting it to 'units' */
 static void
-parsePathname(char **path, int fatal)
+parseTimeLine(int *iptr, const char *units)
 {
     char *token;
-    struct stat sb;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
+    double d;
+    int m;
+    int u;
+    if ((u = parseTimeUnits(units)) == 0)
 	self_destruct();
-    safe_free(*path);
-    *path = xstrdup(token);
-    if (fatal && stat(token, &sb) < 0) {
-	debug(50, 1) ("parsePathname: %s: %s\n", token, xstrerror());
+    if ((token = strtok(NULL, w_space)) == NULL)
 	self_destruct();
+    d = atof(token);
+    m = u;			/* default to 'units' if none specified */
+    if ((token = strtok(NULL, w_space)) != NULL) {
+	if ((m = parseTimeUnits(token)) == 0)
+	    self_destruct();
     }
+    *iptr = m * d / u;
 }
 
+static int
+parseTimeUnits(const char *unit)
+{
+    if (!strncasecmp(unit, T_SECOND_STR, strlen(T_SECOND_STR)))
+	return 1;
+    if (!strncasecmp(unit, T_MINUTE_STR, strlen(T_MINUTE_STR)))
+	return 60;
+    if (!strncasecmp(unit, T_HOUR_STR, strlen(T_HOUR_STR)))
+	return 3600;
+    if (!strncasecmp(unit, T_DAY_STR, strlen(T_DAY_STR)))
+	return 86400;
+    if (!strncasecmp(unit, T_WEEK_STR, strlen(T_WEEK_STR)))
+	return 86400 * 7;
+    if (!strncasecmp(unit, T_FORTNIGHT_STR, strlen(T_FORTNIGHT_STR)))
+	return 86400 * 14;
+    if (!strncasecmp(unit, T_MONTH_STR, strlen(T_MONTH_STR)))
+	return 86400 * 30;
+    if (!strncasecmp(unit, T_YEAR_STR, strlen(T_YEAR_STR)))
+	return 86400 * 365.2522;
+    if (!strncasecmp(unit, T_DECADE_STR, strlen(T_DECADE_STR)))
+	return 86400 * 365.2522 * 10;
+    debug(3, 1) ("parseTimeUnits: unknown time unit '%s'\n", unit);
+    return 0;
+}
+
+/*****************************************************************************
+ * Max
+ *****************************************************************************/
+
 static void
-parseOnOff(int *var)
+dump_acl(void)
 {
-    char *token;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    if (!strcasecmp(token, "on") || !strcasecmp(token, "enable"))
-	*var = 1;
-    else
-	*var = 0;
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseWAISRelayLine(void)
+parse_acl(void)
 {
-    char *token;
-    int i;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    safe_free(Config.Wais.relayHost);
-    Config.Wais.relayHost = xstrdup(token);
-    GetInteger(i);
-    Config.Wais.relayPort = (u_short) i;
+    aclParseAclLine();
 }
 
 static void
-parseWordlist(wordlist ** list)
+dump_acl_access(struct _acl_access *head)
 {
-    char *token;
-    while ((token = strtok(NULL, w_space)))
-	wordlistAdd(list, token);
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseAppendDomainLine(void)
+parse_acl_access(struct _acl_access **head)
 {
-    char *token;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    if (*token != '.')
-	self_destruct();
-    safe_free(Config.appendDomain);
-    Config.appendDomain = xstrdup(token);
+    aclParseAccessLine(head);
 }
 
 static void
-parseAddressLine(struct in_addr *addr)
+dump_address(struct in_addr addr)
+{
+    printf("%s", inet_ntoa(addr));
+}
+
+static void
+parse_address(struct in_addr *addr)
 {
-    char *token;
     const struct hostent *hp;
-    token = strtok(NULL, w_space);
+    char *token = strtok(NULL, w_space);
+
     if (token == NULL)
 	self_destruct();
     if (safe_inet_addr(token, addr) == 1)
@@ -637,66 +707,61 @@ parseAddressLine(struct in_addr *addr)
 }
 
 static void
-parseMcastGroupLine(void)
+dump_announceto(void)
 {
-    char *token = NULL;
-    while ((token = strtok(NULL, w_space)))
-	wordlistAdd(&Config.mcast_group_list, token);
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseHttpPortLine(void)
+parse_announceto(void)
 {
     char *token;
     int i;
-    if (Config.Port.n_http == MAXHTTPPORTS) {
-	sprintf(fatal_str, "Limit of %d HTTP Ports exceeded, redefine MAXHTTPPORTS.\n",
-	    MAXHTTPPORTS);
-	fatal(fatal_str);
+
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	self_destruct();
+    safe_free(Config.Announce.host);
+    Config.Announce.host = xstrdup(token);
+    if ((token = strchr(Config.Announce.host, ':'))) {
+	*token++ = '\0';
+	if (sscanf(token, "%d", &i) != 1)
+	    Config.Announce.port = i;
     }
-    GetInteger(i);
-    if (i < 0)
-	i = 0;
-    Config.Port.http[Config.Port.n_http++] = (u_short) i;
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	return;
+    safe_free(Config.Announce.file);
+    Config.Announce.file = xstrdup(token);
 }
 
 static void
-parseIcpPortLine(void)
+dump_appenddomain(void)
 {
-    char *token;
-    int i;
-    GetInteger(i);
-    if (i < 0)
-	i = 0;
-    Config.Port.icp = (u_short) i;
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseDebugOptionsLine(void)
+parse_appenddomain(void)
 {
-    char *token;
-    token = strtok(NULL, null_string);
-    safe_free(Config.debugOptions);
-    if (token == NULL) {
-	Config.debugOptions = NULL;
-	return;
-    }
-    Config.debugOptions = xstrdup(token);
-}
+    char *token = strtok(NULL, w_space);
 
-static void
-parseVisibleHostnameLine(void)
-{
-    char *token;
-    token = strtok(NULL, w_space);
-    safe_free(Config.visibleHostname);
     if (token == NULL)
 	self_destruct();
-    Config.visibleHostname = xstrdup(token);
+    if (*token != '.')
+	self_destruct();
+    safe_free(Config.appendDomain);
+    Config.appendDomain = xstrdup(token);
+}
+
+static void
+dump_cacheannounce(void)
+{
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseCacheAnnounceLine(void)
+parse_cacheannounce(void)
 {
     char *token;
     int i;
@@ -707,761 +772,646 @@ parseCacheAnnounceLine(void)
 }
 
 static void
-parseAnnounceToLine(void)
+dump_cachedir(void)
 {
-    char *token;
-    int i;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    safe_free(Config.Announce.host);
-    Config.Announce.host = xstrdup(token);
-    if ((token = strchr(Config.Announce.host, ':'))) {
-	*token++ = '\0';
-	if (sscanf(token, "%d", &i) != 1)
-	    Config.Announce.port = i;
-    }
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	return;
-    safe_free(Config.Announce.file);
-    Config.Announce.file = xstrdup(token);
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseVizHackLine(void)
+parse_cachedir(void)
 {
     char *token;
+    char *dir;
     int i;
-    const struct hostent *hp;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    if (safe_inet_addr(token, &Config.vizHack.addr) == 1)
-	(void) 0;
-    else if ((hp = gethostbyname(token)))	/* dont use ipcache */
-	Config.vizHack.addr = inaddrFromHostent(hp);
-    else
-	self_destruct();
+    int size;
+    int l1;
+    int l2;
+    int readonly = 0;
+
     if ((token = strtok(NULL, w_space)) == NULL)
 	self_destruct();
-    if (sscanf(token, "%d", &i) == 1)
-	Config.vizHack.port = i;
-    Config.vizHack.mcast_ttl = 64;
-    if ((token = strtok(NULL, w_space)) == NULL)
-	return;
-    if (sscanf(token, "%d", &i) == 1)
-	Config.vizHack.mcast_ttl = i;
+    dir = token;
+    GetInteger(i);
+    size = i << 10;		/* Mbytes to kbytes */
+    Config.Swap.maxSize += size;
+    GetInteger(i);
+    l1 = i;
+    GetInteger(i);
+    l2 = i;
+    if ((token = strtok(NULL, w_space)))
+	if (!strcasecmp(token, "read-only"))
+	    readonly = 1;
+    if (configured_once)
+	storeReconfigureSwapDisk(dir, size, l1, l2, readonly);
+    else
+	storeAddSwapDisk(dir, size, l1, l2, readonly);
 }
 
 static void
-parseProxyLine(peer ** E)
+dump_cachehost(void)
 {
-    char *token;
-    char *t;
-    peer *e;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    if (*E) {
-	peerDestroy(*E);
-	*E = NULL;
-    }
-    e = xcalloc(1, sizeof(peer));
-    if ((t = strchr(token, ':'))) {
-	*t++ = '\0';
-	e->http_port = atoi(t);
-    }
-    e->host = xstrdup(token);
-    e->tcp_up = 1;
-    *E = e;
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseIntegerValue(int *iptr)
+parse_cachehost(void)
 {
-    char *token;
+    char *type = NULL;
+    char *hostname = NULL;
+    char *token = NULL;
+    u_short http_port = CACHE_HTTP_PORT;
+    u_short icp_port = CACHE_ICP_PORT;
+    int options = 0;
+    int weight = 1;
+    int mcast_ttl = 0;
     int i;
+
+    if (!(hostname = strtok(NULL, w_space)))
+	self_destruct();
+    if (!(type = strtok(NULL, w_space)))
+	self_destruct();
+
+    GetInteger(i);
+    http_port = (u_short) i;
     GetInteger(i);
-    *iptr = i;
+    icp_port = (u_short) i;
+    while ((token = strtok(NULL, w_space))) {
+	if (!strcasecmp(token, "proxy-only")) {
+	    options |= NEIGHBOR_PROXY_ONLY;
+	} else if (!strcasecmp(token, "no-query")) {
+	    options |= NEIGHBOR_NO_QUERY;
+	} else if (!strcasecmp(token, "multicast-responder")) {
+	    options |= NEIGHBOR_MCAST_RESPONDER;
+	} else if (!strncasecmp(token, "weight=", 7)) {
+	    weight = atoi(token + 7);
+	} else if (!strncasecmp(token, "ttl=", 4)) {
+	    mcast_ttl = atoi(token + 4);
+	    if (mcast_ttl < 0)
+		mcast_ttl = 0;
+	    if (mcast_ttl > 128)
+		mcast_ttl = 128;
+	} else if (!strncasecmp(token, "default", 7)) {
+	    options |= NEIGHBOR_DEFAULT_PARENT;
+	} else if (!strncasecmp(token, "round-robin", 11)) {
+	    options |= NEIGHBOR_ROUNDROBIN;
+	} else {
+	    debug(3, 0) ("parseCacheHostLine: token='%s'\n", token);
+	    self_destruct();
+	}
+    }
+    if (weight < 1)
+	weight = 1;
+    neighborAdd(hostname, type, http_port, icp_port, options,
+	weight, mcast_ttl);
+}
+
+static void
+dump_cachemgrpasswd(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_cachemgrpasswd(void)
+{
+    char *passwd = NULL;
+    wordlist *actions = NULL;
+    parse_string(&passwd);
+    parse_wordlist(&actions);
+    objcachePasswdAdd(&Config.passwd_list, passwd, actions);
+    wordlistDestroy(&actions);
+}
+
+static void
+dump_denyinfo(struct _acl_deny_info_list *var)
+{
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_denyinfo(struct _acl_deny_info_list **var)
+{
+    aclParseDenyInfoLine(var);
+}
+
+static void
+dump_effectiveuser(void)
+{
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseString(char **sptr)
+parse_effectiveuser(void)
 {
     char *token;
     token = strtok(NULL, w_space);
     if (token == NULL)
 	self_destruct();
-    *sptr = xstrdup(token);
+    safe_free(Config.effectiveUser);
+    safe_free(Config.effectiveGroup);
+    Config.effectiveUser = xstrdup(token);
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	return;			/* group is optional */
+    Config.effectiveGroup = xstrdup(token);
 }
 
 static void
-parseErrHtmlLine(void)
+dump_errhtml(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_errhtml(void)
 {
     char *token;
     if ((token = strtok(NULL, null_string)))
 	Config.errHtmlText = xstrdup(token);
 }
 
 static void
-parseCachemgrPasswd(void)
+dump_hostacl(void)
 {
-    char *passwd = NULL;
-    wordlist *actions = NULL;
-    parseString(&passwd);
-    parseWordlist(&actions);
-    objcachePasswdAdd(&Config.passwd_list, passwd, actions);
-    wordlistDestroy(&actions);
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_hostacl(void)
+{
+    char *host = NULL;
+    char *aclname = NULL;
+    if (!(host = strtok(NULL, w_space)))
+	self_destruct();
+    while ((aclname = strtok(NULL, list_sep)))
+	neighborAddAcl(host, aclname);
+}
+
+static void
+dump_hostdomain(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_hostdomain(void)
+{
+    char *host = NULL;
+    char *domain = NULL;
+    if (!(host = strtok(NULL, w_space)))
+	self_destruct();
+    while ((domain = strtok(NULL, list_sep)))
+	neighborAddDomainPing(host, domain);
 }
 
 static void
-parseHttpAnonymizer(int *iptr)
+dump_hostdomaintype(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_hostdomaintype(void)
+{
+    char *host = NULL;
+    char *type = NULL;
+    char *domain = NULL;
+    if (!(host = strtok(NULL, w_space)))
+	self_destruct();
+    if (!(type = strtok(NULL, w_space)))
+	self_destruct();
+    while ((domain = strtok(NULL, list_sep)))
+	neighborAddDomainType(host, domain, type);
+}
+
+static void
+dump_httpanonymizer(int var)
+{
+    switch (var) {
+    case ANONYMIZER_NONE:
+	printf("off");
+	break;
+    case ANONYMIZER_STANDARD:
+	printf("paranoid");
+	break;
+    case ANONYMIZER_PARANOID:
+	printf("standard");
+	break;
+    }
+}
+
+static void
+parse_httpanonymizer(int *var)
 {
     char *token;
     token = strtok(NULL, w_space);
     if (token == NULL)
 	self_destruct();
     if (!strcasecmp(token, "off"))
-	*iptr = ANONYMIZER_NONE;
+	*var = ANONYMIZER_NONE;
     else if (!strcasecmp(token, "paranoid"))
-	*iptr = ANONYMIZER_PARANOID;
+	*var = ANONYMIZER_PARANOID;
     else
-	*iptr = ANONYMIZER_STANDARD;
+	*var = ANONYMIZER_STANDARD;
+}
+
+static void
+dump_httpdaccel(void)
+{
+    debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parseCacheDir(void)
+parse_httpdaccel(void)
 {
     char *token;
-    char *dir;
+    LOCAL_ARRAY(char, buf, BUFSIZ);
     int i;
-    int size;
-    int l1;
-    int l2;
-    int readonly = 0;
-    if ((token = strtok(NULL, w_space)) == NULL)
+    token = strtok(NULL, w_space);
+    if (token == NULL)
 	self_destruct();
-    dir = token;
-    GetInteger(i);
-    size = i << 10;		/* Mbytes to kbytes */
-    Config.Swap.maxSize += size;
-    GetInteger(i);
-    l1 = i;
+    safe_free(Config.Accel.host);
+    Config.Accel.host = xstrdup(token);
     GetInteger(i);
-    l2 = i;
-    if ((token = strtok(NULL, w_space)))
-	if (!strcasecmp(token, "read-only"))
-	    readonly = 1;
-    if (configured_once)
-	storeReconfigureSwapDisk(dir, size, l1, l2, readonly);
-    else
-	storeAddSwapDisk(dir, size, l1, l2, readonly);
+    Config.Accel.port = i;
+    safe_free(Config.Accel.prefix);
+    sprintf(buf, "http://%s:%d", Config.Accel.host, Config.Accel.port);
+    Config.Accel.prefix = xstrdup(buf);
+    httpd_accel_mode = 1;
 }
 
-int
-parseConfigFile(const char *file_name)
+static void
+dump_ushortlist(ushortlist *u)
 {
-    FILE *fp = NULL;
-    char *token = NULL;
-    LOCAL_ARRAY(char, tmp_line, BUFSIZ);
+    while (u) {
+	printf("%d ", (int) u->i);
+	u = u->next;
+    }
+}
 
-    configFreeMemory();
-    configSetFactoryDefaults();
-    aclDestroyAcls();
-    aclDestroyDenyInfoList(&Config.denyInfoList);
-    aclDestroyAccessList(&Config.accessList.HTTP);
-    aclDestroyAccessList(&Config.accessList.ICP);
-    aclDestroyAccessList(&Config.accessList.MISS);
-    aclDestroyAccessList(&Config.accessList.NeverDirect);
-    aclDestroyAccessList(&Config.accessList.AlwaysDirect);
-    aclDestroyRegexList(Config.cache_stop_relist);
-    Config.cache_stop_relist = NULL;
-
-    if ((fp = fopen(file_name, "r")) == NULL) {
-	sprintf(fatal_str, "Unable to open configuration file: %s: %s",
-	    file_name, xstrerror());
-	fatal(fatal_str);
+static void
+parse_ushortlist(ushortlist ** P)
+{
+    char *token;
+    int i;
+    ushortlist *u;
+    ushortlist **U;
+    while ((token = strtok(NULL, w_space))) {
+	if (sscanf(token, "%d", &i) != 1)
+	    self_destruct();
+	if (i < 0)
+	    i = 0;
+	u = xcalloc(1, sizeof(ushortlist));
+	u->i = (u_short) i;
+	for (U = P; *U; U = &(*U)->next);
+	*U = u;
     }
-    cfg_filename = file_name;
-    if ((token = strrchr(cfg_filename, '/')))
-	cfg_filename = token + 1;
-    memset(config_input_line, '\0', BUFSIZ);
-    config_lineno = 0;
-    while (fgets(config_input_line, BUFSIZ, fp)) {
-	config_lineno++;
-	if ((token = strchr(config_input_line, '\n')))
-	    *token = '\0';
-	if (config_input_line[0] == '#')
-	    continue;
-	if (config_input_line[0] == '\0')
-	    continue;
-	debug(3, 5) ("Processing: '%s'\n", config_input_line);
-	strcpy(tmp_line, config_input_line);
-	if ((token = strtok(tmp_line, w_space)) == NULL)
-	    continue;
-
-	if (!strcmp(token, "cache_host"))
-	    parseCacheHostLine();
-
-	else if (!strcmp(token, "cache_host_domain"))
-	    parseHostDomainLine();
-	else if (!strcmp(token, "cache_host_acl"))
-	    parseHostAclLine();
-	else if (!strcmp(token, "neighbor_type_domain"))
-	    parseHostDomainTypeLine();
-
-	else if (!strcmp(token, "neighbor_timeout"))
-	    parseTimeLine(&Config.neighborTimeout, T_SECOND_STR);
-	else if (!strcmp(token, "neighbour_timeout"))	/* alternate spelling */
-	    parseTimeLine(&Config.neighborTimeout, T_SECOND_STR);
-
-	else if (!strcmp(token, "cache_dir"))
-	    parseCacheDir();
-
-	else if (!strcmp(token, "cache_log"))
-	    parsePathname(&Config.Log.log, 0);
-
-	else if (!strcmp(token, "cache_access_log"))
-	    parsePathname(&Config.Log.access, 0);
-
-	else if (!strcmp(token, "cache_store_log"))
-	    parsePathname(&Config.Log.store, 0);
-
-	else if (!strcmp(token, "cache_swap_log"))
-	    parsePathname(&Config.Log.swap, 0);
-
-#if USE_USERAGENT_LOG
-	else if (!strcmp(token, "useragent_log"))
-	    parsePathname(&Config.Log.useragent, 0);
-#endif
-
-	else if (!strcmp(token, "logfile_rotate"))
-	    parseIntegerValue(&Config.Log.rotateNumber);
-
-	else if (!strcmp(token, "httpd_accel_with_proxy"))
-	    parseOnOff(&Config.Accel.withProxy);
-
-	else if (!strcmp(token, "httpd_accel_uses_host_header"))
-	    parseOnOff(&opt_accel_uses_host);
-
-	else if (!strcmp(token, "httpd_accel"))
-	    parseHttpdAccelLine();
-
-	else if (!strcmp(token, "cache_effective_user"))
-	    parseEffectiveUserLine();
-
-	else if (!strcmp(token, "cache_swap_high"))
-	    parseIntegerValue(&Config.Swap.highWaterMark);
-
-	else if (!strcmp(token, "cache_swap_low"))
-	    parseIntegerValue(&Config.Swap.lowWaterMark);
-
-	else if (!strcmp(token, "cache_mem_high"))
-	    parseIntegerValue(&Config.Mem.highWaterMark);
-
-	else if (!strcmp(token, "cache_mem_low"))
-	    parseIntegerValue(&Config.Mem.lowWaterMark);
-
-	else if (!strcmp(token, "cache_mem"))
-	    parseMemLine();
-
-	else if (!strcmp(token, "cache_mgr"))
-	    parseMgrLine();
-
-	else if (!strcmp(token, "acl"))
-	    aclParseAclLine();
-
-	else if (!strcmp(token, "deny_info"))
-	    aclParseDenyInfoLine(&Config.denyInfoList);
-
-	else if (!strcmp(token, "http_access"))
-	    aclParseAccessLine(&Config.accessList.HTTP);
-	else if (!strcmp(token, "icp_access"))
-	    aclParseAccessLine(&Config.accessList.ICP);
-	else if (!strcmp(token, "miss_access"))
-	    aclParseAccessLine(&Config.accessList.MISS);
-	else if (!strcmp(token, "never_direct"))
-	    aclParseAccessLine(&Config.accessList.NeverDirect);
-	else if (!strcmp(token, "always_direct"))
-	    aclParseAccessLine(&Config.accessList.AlwaysDirect);
-
-	else if (!strcmp(token, "hierarchy_stoplist"))
-	    parseWordlist(&Config.hierarchy_stoplist);
-
-	else if (!strcmp(token, "cache_stoplist"))
-	    parseWordlist(&Config.cache_stoplist);
-	else if (!strcmp(token, "cache_stoplist_pattern"))
-	    aclParseRegexList(&Config.cache_stop_relist, 0);
-	else if (!strcmp(token, "cache_stoplist_pattern/i"))
-	    aclParseRegexList(&Config.cache_stop_relist, 1);
-
-	else if (!strcmp(token, "refresh_pattern"))
-	    parseRefreshPattern(0);
-	else if (!strcmp(token, "refresh_pattern/i"))
-	    parseRefreshPattern(1);
-
-	else if (!strcmp(token, "quick_abort"))
-	    parseQuickAbort();
-
-	else if (!strcmp(token, "negative_ttl"))
-	    parseTimeLine(&Config.negativeTtl, T_SECOND_STR);
-	else if (!strcmp(token, "negative_dns_ttl"))
-	    parseTimeLine(&Config.negativeDnsTtl, T_SECOND_STR);
-	else if (!strcmp(token, "positive_dns_ttl"))
-	    parseTimeLine(&Config.positiveDnsTtl, T_SECOND_STR);
-	else if (!strcmp(token, "read_timeout"))
-	    parseTimeLine(&Config.Timeout.read, T_SECOND_STR);
-	else if (!strcmp(token, "connect_timeout"))
-	    parseTimeLine(&Config.Timeout.connect, T_SECOND_STR);
-	else if (!strcmp(token, "defer_timeout"))
-	    parseTimeLine(&Config.Timeout.defer, T_SECOND_STR);
-	else if (!strcmp(token, "request_timeout"))
-	    parseTimeLine(&Config.Timeout.request, T_SECOND_STR);
-	else if (!strcmp(token, "client_lifetime"))
-	    parseTimeLine(&Config.Timeout.lifetime, T_SECOND_STR);
-	else if (!strcmp(token, "shutdown_lifetime"))
-	    parseTimeLine(&Config.shutdownLifetime, T_SECOND_STR);
-	else if (!strcmp(token, "clean_rate"))
-	    parseTimeLine(&Config.cleanRate, T_SECOND_STR);
-	else if (!strcmp(token, "reference_age"))
-	    parseTimeLine(&Config.referenceAge, T_MINUTE_STR);
-
-	else if (!strcmp(token, "request_size"))
-	    parseKilobytes(&Config.maxRequestSize);
-
-	else if (!strcmp(token, "cache_dns_program"))
-	    parsePathname(&Config.Program.dnsserver, 1);
-
-	else if (!strcmp(token, "dns_children"))
-	    parseIntegerValue(&Config.dnsChildren);
-	else if (!strcmp(token, "dns_defnames"))
-	    parseOnOff(&Config.Options.res_defnames);
-
-	else if (!strcmp(token, "redirect_program"))
-	    parsePathname(&Config.Program.redirect, 1);
-
-	else if (!strcmp(token, "redirect_children"))
-	    parseIntegerValue(&Config.redirectChildren);
-
-	else if (!strcmp(token, "pinger_program"))
-	    parsePathname(&Config.Program.pinger, 1);
-
-	else if (!strcmp(token, "unlinkd_program"))
-	    parsePathname(&Config.Program.unlinkd, 1);
-
-#if USE_PROXY_AUTH
-	else if (!strcmp(token, "proxy_auth"))
-	    parseProxyAuthLine();
-	else if (!strcmp(token, "proxy_auth_ignore"))
-	    aclParseRegexList(&Config.proxyAuth.IgnoreDomains, 1);
-#endif /* USE_PROXY_AUTH */
-
-	else if (!strcmp(token, "source_ping"))
-	    parseOnOff(&Config.sourcePing);
+}
 
-	else if (!strcmp(token, "emulate_httpd_log"))
-	    parseOnOff(&Config.commonLogFormat);
+static void
+dump_int(int var)
+{
+    printf("%d", var);
+}
 
-	else if (!strcmp(token, "log_mime_hdrs"))
-	    parseOnOff(&Config.logMimeHdrs);
+static void
+parse_int(int *var)
+{
+    char *token;
+    int i;
 
-	else if (!strcmp(token, "ident_lookup"))
-	    parseOnOff(&Config.identLookup);
+    GetInteger(i);
+    *var = i;
+}
 
-	else if (!strcmp(token, "append_domain"))
-	    parseAppendDomainLine();
+static void
+dump_onoff(int var)
+{
+    printf(var ? "on" : "off");
+}
 
-	else if (!strcmp(token, "wais_relay"))
-	    parseWAISRelayLine();
+static void
+parse_onoff(int *var)
+{
+    char *token = strtok(NULL, w_space);
 
-	else if (!strcmp(token, "mcast_groups"))
-	    parseMcastGroupLine();
+    if (token == NULL)
+	self_destruct();
+    if (!strcasecmp(token, "on") || !strcasecmp(token, "enable"))
+	*var = 1;
+    else
+	*var = 0;
+}
 
-	else if (!strcmp(token, "tcp_incoming_address"))
-	    parseAddressLine(&Config.Addrs.tcp_incoming);
+static void
+dump_pathname_check(char path[])
+{
+    printf("%s", path);
+}
 
-	else if (!strcmp(token, "tcp_outgoing_address"))
-	    parseAddressLine(&Config.Addrs.tcp_outgoing);
+static void
+parse_pathname_check(char *path[])
+{
+    struct stat sb;
 
-	else if (!strcmp(token, "udp_incoming_address"))
-	    parseAddressLine(&Config.Addrs.udp_incoming);
+    parse_string(path);
 
-	else if (!strcmp(token, "udp_outgoing_address"))
-	    parseAddressLine(&Config.Addrs.udp_outgoing);
+    if (stat(*path, &sb) < 0) {
+	debug(50, 1) ("parse_pathname_check: %s: %s\n", *path, xstrerror());
+	self_destruct();
+    }
+}
 
-	else if (!strcmp(token, "client_netmask"))
-	    parseAddressLine(&Config.Addrs.client_netmask);
+static void
+dump_proxy(peer * E)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "tcp_recv_bufsize"))
-	    parseIntegerValue(&Config.tcpRcvBufsz);
+static void
+parse_proxy(peer ** E)
+{
+    char *token;
+    char *t;
+    peer *e;
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	self_destruct();
+    if (*E) {
+	peerDestroy(*E);
+	*E = NULL;
+    }
+    e = xcalloc(1, sizeof(peer));
+    if ((t = strchr(token, ':'))) {
+	*t++ = '\0';
+	e->http_port = atoi(t);
+    }
+    e->host = xstrdup(token);
+    e->tcp_up = 1;
+    *E = e;
+}
 
-	else if (!strcmp(token, "log_fqdn"))
-	    parseOnOff(&Config.Log.log_fqdn);
+#if USE_PROXY_AUTH
+static void
+dump_proxyauth(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "bind_address"))
-	    parseAddressLine(&Config.Addrs.tcp_incoming);
+static void
+parse_proxyauth(void)
+{
+    char *token;
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	self_destruct();
+    safe_free(Config.proxyAuth.File);
+    aclDestroyRegexList(Config.proxyAuth.IgnoreDomains);
+    Config.proxyAuth.IgnoreDomains = NULL;
+    Config.proxyAuth.File = xstrdup(token);
+    aclParseRegexList(&Config.proxyAuth.IgnoreDomains, 1);
+}
+#endif /* USE_PROXY_AUTH */
 
-	else if (!strcmp(token, "outbound_address"))
-	    parseAddressLine(&Config.Addrs.tcp_outgoing);
+static void
+dump_quickabort(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "http_port") || !strcmp(token, "ascii_port"))
-	    parseHttpPortLine();
+static void
+parse_quickabort(void)
+{
+    char *token;
+    int i;
+    token = strtok(NULL, w_space);
+    if (!strcasecmp(token, "on")) {
+	Config.quickAbort.min = 10 << 10;	/* 10k */
+	Config.quickAbort.pct = 64;	/* 50% */
+	Config.quickAbort.max = 100 << 10;	/* 100k */
+    } else if (!strcasecmp(token, "off")) {
+	Config.quickAbort.min = -1;
+	Config.quickAbort.pct = 0;
+	Config.quickAbort.max = 0;
+    } else {
+	if (sscanf(token, "%d", &i) != 1)
+	    self_destruct();
+	Config.quickAbort.min = i * 1024;
+	GetInteger(i);
+	Config.quickAbort.pct = i * 128 / 100;	/* 128 is full scale */
+	GetInteger(i);
+	Config.quickAbort.max = i * 1024;
+    }
+}
 
-	else if (!strcmp(token, "icp_port") || !strcmp(token, "udp_port"))
-	    parseIcpPortLine();
+static void
+dump_refreshpattern(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "dns_testnames"))
-	    parseWordlist(&Config.dns_testname_list);
+static void
+parse_refreshpattern(void)
+{
+    parseRefreshPattern(0);
+}
 
-	else if (!strcmp(token, "single_parent_bypass"))
-	    parseOnOff(&Config.singleParentBypass);
+static void
+dump_refreshpattern_icase(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "debug_options"))
-	    parseDebugOptionsLine();
+static void
+parse_refreshpattern_icase(void)
+{
+    parseRefreshPattern(1);
+}
 
-	else if (!strcmp(token, "pid_filename"))
-	    parsePathname(&Config.pidFilename, 0);
-	else if (!strcmp(token, "mime_table"))
-	    parsePathname(&Config.mimeTablePathname, 1);
-	else if (!strcmp(token, "visible_hostname"))
-	    parseVisibleHostnameLine();
+static void
+dump_regexlist(relist * var)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "ftp_user"))
-	    parseString(&Config.Ftp.anon_user);
+static void
+parse_regexlist(relist ** var)
+{
+    aclParseRegexList(var, 0);
+}
 
-	else if (!strcmp(token, "cache_announce"))
-	    parseCacheAnnounceLine();
+static void
+dump_regexlist_icase(relist * var)
+{
+    debug(0,0)("XXX need to fix\n");
+}
 
-	else if (!strcmp(token, "announce_to"))
-	    parseAnnounceToLine();
+static void
+parse_regexlist_icase(relist ** var)
+{
+    aclParseRegexList(var, 1);
+}
 
-	else if (!strcmp(token, "ssl_proxy"))
-	    parseProxyLine(&Config.sslProxy);
-	else if (!strcmp(token, "passthrough_proxy"))
-	    parseProxyLine(&Config.passProxy);
+static void
+dump_string(char var[])
+{
+    printf("%s", var);
+}
 
-	else if (!strcmp(token, "err_html_text"))
-	    parseErrHtmlLine();
+static void
+parse_string(char *var[])
+{
+    char *token = strtok(NULL, w_space);
 
-	else if (!strcmp(token, "ipcache_size"))
-	    parseIntegerValue(&Config.ipcache.size);
-	else if (!strcmp(token, "ipcache_low"))
-	    parseIntegerValue(&Config.ipcache.low);
-	else if (!strcmp(token, "ipcache_high"))
-	    parseIntegerValue(&Config.ipcache.high);
+    safe_free(*var);
+    if (token == NULL)
+	self_destruct();
+    *var = xstrdup(token);
+}
 
-	else if (!strcmp(token, "memory_pools"))
-	    parseOnOff(&opt_mem_pools);
-	else if (!strcmp(token, "udp_hit_obj"))
-	    parseOnOff(&opt_udp_hit_obj);
-	else if (!strcmp(token, "udp_hit_obj_size"))
-	    parseIntegerValue(&Config.udpMaxHitObjsz);
-	else if (!strcmp(token, "forwarded_for"))
-	    parseOnOff(&opt_forwarded_for);
-	else if (!strcmp(token, "log_icp_queries"))
-	    parseOnOff(&Config.Options.log_udp);
-	else if (!strcmp(token, "http_anonymizer"))
-	    parseHttpAnonymizer(&Config.Options.anonymizer);
-	else if (!strcmp(token, "client_db"))
-	    parseOnOff(&Config.Options.client_db);
-	else if (!strcmp(token, "query_icmp"))
-	    parseOnOff(&Config.Options.query_icmp);
+static void
+dump_string_optional(const char *var)
+{
+    printf("%s", var);
+}
 
-	else if (!strcmp(token, "minimum_direct_hops"))
-	    parseIntegerValue(&Config.minDirectHops);
+static void
+parse_string_optional(char *volatile *var)
+{
+    char *token = strtok(NULL, null_string);
 
-	else if (!strcmp(token, "cachemgr_passwd"))
-	    parseCachemgrPasswd();
-
-	else if (!strcmp(token, "store_objects_per_bucket"))
-	    parseIntegerValue(&Config.Store.objectsPerBucket);
-	else if (!strcmp(token, "store_avg_object_size"))
-	    parseIntegerValue(&Config.Store.avgObjectSize);
-	else if (!strcmp(token, "maximum_object_size"))
-	    parseKilobytes(&Config.Store.maxObjectSize);
-
-	else if (!strcmp(token, "viz_hack_addr"))
-	    parseVizHackLine();
-
-	else if (!strcmp(token, "netdb_high"))
-	    parseIntegerValue(&Config.Netdb.high);
-	else if (!strcmp(token, "netdb_low"))
-	    parseIntegerValue(&Config.Netdb.low);
-	else if (!strcmp(token, "netdb_ping_period"))
-	    parseTimeLine(&Config.Netdb.period, T_SECOND_STR);
-
-	/* If unknown, treat as a comment line */
-	else {
-	    debug(3, 0) ("parseConfigFile: line %d unrecognized: '%s'\n",
-		config_lineno,
-		config_input_line);
-	}
+    safe_free(*var);
+    if (token == NULL) {
+	*var = NULL;
+	return;
     }
+    *var = xstrdup(token);
+}
 
-    /* Sanity checks */
-    if (Config.Swap.maxSize < (Config.Mem.maxSize >> 10)) {
-	printf("WARNING: cache_swap (%d kbytes) is less than cache_mem (%d bytes).\n", Config.Swap.maxSize, Config.Mem.maxSize);
-	printf("         This will cause serious problems with your cache!!!\n");
-	printf("         Change your configuration file.\n");
-	fflush(stdout);		/* print message */
-    }
-    if (Config.cleanRate < 1)
-	Config.cleanRate = 86400 * 365;		/* one year */
-    if (Config.Announce.rate < 1) {
-	Config.Announce.rate = 86400 * 365;	/* one year */
-	Config.Announce.on = 0;
-    }
-    if (Config.dnsChildren < 0)
-	Config.dnsChildren = 0;
-    if (Config.dnsChildren < 1) {
-	printf("WARNING: dnsservers are disabled!\n");
-	printf("WARNING: Cache performance may be very poor\n");
-    } else if (Config.dnsChildren > DefaultDnsChildrenMax) {
-	printf("WARNING: dns_children was set to a bad value: %d\n",
-	    Config.dnsChildren);
-	printf("Setting it to the maximum (%d).\n", DefaultDnsChildrenMax);
-	Config.dnsChildren = DefaultDnsChildrenMax;
-    }
-    if (Config.Program.redirect) {
-	if (Config.redirectChildren < 1) {
-	    Config.redirectChildren = 0;
-	    safe_free(Config.Program.redirect);
-	} else if (Config.redirectChildren > DefaultRedirectChildrenMax) {
-	    printf("WARNING: redirect_children was set to a bad value: %d\n",
-		Config.redirectChildren);
-	    printf("Setting it to the maximum (%d).\n", DefaultRedirectChildrenMax);
-	    Config.redirectChildren = DefaultRedirectChildrenMax;
-	}
-    }
-    fclose(fp);
-    configDoConfigure();
-    return 0;
+static void
+dump_time_min(int var)
+{
+    printf("%d", var / 60);
 }
 
-static char *
-safe_xstrdup(const char *p)
+static void
+parse_time_min(int *var)
 {
-    return p ? xstrdup(p) : NULL;
+    parseTimeLine(var, T_MINUTE_STR);
 }
 
-void
-configFreeMemory(void)
+static void
+dump_time_sec(int var)
 {
-    safe_free(Config.Wais.relayHost);
-    safe_free(Config.Log.log);
-    safe_free(Config.Log.access);
-    safe_free(Config.Log.store);
-    safe_free(Config.Log.swap);
-    safe_free(Config.adminEmail);
-    safe_free(Config.effectiveUser);
-    safe_free(Config.effectiveGroup);
-    safe_free(Config.Program.dnsserver);
-    safe_free(Config.Program.redirect);
-    safe_free(Config.Program.unlinkd);
-    safe_free(Config.Program.pinger);
-    safe_free(Config.Accel.host);
-    safe_free(Config.Accel.prefix);
-    safe_free(Config.appendDomain);
-    safe_free(Config.debugOptions);
-    safe_free(Config.pidFilename);
-    safe_free(Config.mimeTablePathname);
-    safe_free(Config.visibleHostname);
-#if USE_PROXY_AUTH
-    safe_free(Config.proxyAuth.File);
-    aclDestroyRegexList(Config.proxyAuth.IgnoreDomains);
-    Config.proxyAuth.IgnoreDomains = NULL;
-#endif /* USE_PROXY_AUTH */
-    safe_free(Config.Announce.host);
-    safe_free(Config.Announce.file);
-    safe_free(Config.errHtmlText);
-    safe_free(Config.Ftp.icon_prefix);
-    safe_free(Config.Ftp.icon_suffix);
-    safe_free(Config.Ftp.anon_user);
-    peerDestroy(Config.sslProxy);
-    peerDestroy(Config.passProxy);
-    wordlistDestroy(&Config.hierarchy_stoplist);
-    wordlistDestroy(&Config.mcast_group_list);
-    wordlistDestroy(&Config.dns_testname_list);
-    wordlistDestroy(&Config.cache_stoplist);
-    objcachePasswdDestroy(&Config.passwd_list);
-    refreshFreeMemory();
+    printf("%d", var);
 }
 
+static void
+parse_time_sec(int *var)
+{
+    parseTimeLine(var, T_SECOND_STR);
+}
 
 static void
-configSetFactoryDefaults(void)
+dump_ushort(u_short var)
 {
-    memset(&Config, '\0', sizeof(Config));
-    Config.Mem.maxSize = DefaultMemMaxSize;
-    Config.Mem.highWaterMark = DefaultMemHighWaterMark;
-    Config.Mem.lowWaterMark = DefaultMemLowWaterMark;
-    Config.Swap.maxSize = DefaultSwapMaxSize;
-    Config.Swap.highWaterMark = DefaultSwapHighWaterMark;
-    Config.Swap.lowWaterMark = DefaultSwapLowWaterMark;
-    Config.Netdb.high = DefaultNetdbHigh;
-    Config.Netdb.low = DefaultNetdbLow;
-    Config.Netdb.period = DefaultNetdbPeriod;
+    printf("%d", var);
+}
 
-    Config.Wais.relayHost = safe_xstrdup(DefaultWaisRelayHost);
-    Config.Wais.relayPort = DefaultWaisRelayPort;
+static void
+parse_ushort(u_short * var)
+{
+    char *token;
+    int i;
 
-    Config.referenceAge = DefaultReferenceAge;
-    Config.negativeTtl = DefaultNegativeTtl;
-    Config.negativeDnsTtl = DefaultNegativeDnsTtl;
-    Config.positiveDnsTtl = DefaultPositiveDnsTtl;
-    Config.Timeout.read = DefaultReadTimeout;
-    Config.Timeout.connect = DefaultConnectTimeout;
-    Config.Timeout.defer = DefaultDeferTimeout;
-    Config.Timeout.request = DefaultRequestTimeout;
-    Config.Timeout.lifetime = DefaultClientLifetime;
-    Config.shutdownLifetime = DefaultShutdownLifetime;
-    Config.maxRequestSize = DefaultMaxRequestSize;
-    Config.cleanRate = DefaultCleanRate;
-    Config.dnsChildren = DefaultDnsChildren;
-    Config.redirectChildren = DefaultRedirectChildren;
-    Config.sourcePing = DefaultSourcePing;
-    Config.quickAbort.min = DefaultQuickAbortMin;
-    Config.quickAbort.pct = DefaultQuickAbortPct;
-    Config.quickAbort.max = DefaultQuickAbortMax;
-    Config.commonLogFormat = DefaultCommonLogFormat;
-    Config.logMimeHdrs = DefaultLogMimeHdrs;
-    Config.identLookup = DefaultIdentLookup;
-    Config.debugOptions = safe_xstrdup(DefaultDebugOptions);
-    Config.neighborTimeout = DefaultNeighborTimeout;
-    Config.stallDelay = DefaultStallDelay;
-    Config.singleParentBypass = DefaultSingleParentBypass;
-    Config.adminEmail = safe_xstrdup(DefaultAdminEmail);
-    Config.effectiveUser = safe_xstrdup(DefaultEffectiveUser);
-    Config.effectiveGroup = safe_xstrdup(DefaultEffectiveGroup);
-    Config.appendDomain = safe_xstrdup(DefaultAppendDomain);
-    Config.errHtmlText = safe_xstrdup(DefaultErrHtmlText);
-    Config.Port.n_http = 0;
-    Config.Port.icp = DefaultIcpPortNum;
-    Config.Log.log_fqdn = DefaultLogLogFqdn;
-    Config.Log.log = safe_xstrdup(DefaultCacheLogFile);
-    Config.Log.access = safe_xstrdup(DefaultAccessLogFile);
-    Config.Log.store = safe_xstrdup(DefaultStoreLogFile);
-    Config.Log.swap = safe_xstrdup(DefaultSwapLogFile);
-#if USE_USERAGENT_LOG
-    Config.Log.useragent = safe_xstrdup(DefaultUseragentLogFile);
-#endif
-    Config.Log.rotateNumber = DefaultLogRotateNumber;
-    Config.Program.dnsserver = safe_xstrdup(DefaultDnsserverProgram);
-    Config.Program.redirect = safe_xstrdup(DefaultRedirectProgram);
-    Config.Program.pinger = safe_xstrdup(DefaultPingerProgram);
-    Config.Program.unlinkd = safe_xstrdup(DefaultUnlinkdProgram);
-    Config.Accel.host = safe_xstrdup(DefaultAccelHost);
-    Config.Accel.prefix = safe_xstrdup(DefaultAccelPrefix);
-    Config.Accel.port = DefaultAccelPort;
-    Config.Accel.withProxy = DefaultAccelWithProxy;
-    Config.pidFilename = safe_xstrdup(DefaultPidFilename);
-    Config.mimeTablePathname = safe_xstrdup(DefaultMimeTable);
-    Config.visibleHostname = safe_xstrdup(DefaultVisibleHostname);
-#if USE_PROXY_AUTH
-    Config.proxyAuth.File = safe_xstrdup(DefaultProxyAuthFile);
-/*    Config.proxyAuth.IgnoreDomains = safe_xstrdup(DefaultproxyAuthIgnoreDomains); */
-#endif /* USE_PROXY_AUTH */
-    Config.Announce.host = safe_xstrdup(DefaultAnnounceHost);
-    Config.Announce.port = DefaultAnnouncePort;
-    Config.Announce.file = safe_xstrdup(DefaultAnnounceFile);
-    Config.Announce.rate = DefaultAnnounceRate;
-    Config.Announce.on = 0;
-    Config.tcpRcvBufsz = DefaultTcpRcvBufsz;
-    Config.udpMaxHitObjsz = DefaultUdpMaxHitObjsz;
-    Config.Addrs.tcp_outgoing.s_addr = DefaultTcpOutgoingAddr;
-    Config.Addrs.tcp_incoming.s_addr = DefaultTcpIncomingAddr;
-    Config.Addrs.udp_outgoing.s_addr = DefaultUdpOutgoingAddr;
-    Config.Addrs.udp_incoming.s_addr = DefaultUdpIncomingAddr;
-    Config.Addrs.client_netmask.s_addr = DefaultClientNetmask;
-    Config.passProxy = DefaultPassProxy;
-    Config.sslProxy = DefaultSslProxy;
-    Config.ipcache.size = DefaultIpcacheSize;
-    Config.ipcache.low = DefaultIpcacheLow;
-    Config.ipcache.high = DefaultIpcacheHigh;
-    Config.minDirectHops = DefaultMinDirectHops;
-    Config.Store.maxObjectSize = DefaultMaxObjectSize;
-    Config.Store.avgObjectSize = DefaultAvgObjectSize;
-    Config.Store.objectsPerBucket = DefaultObjectsPerBucket;
-    Config.Options.log_udp = DefaultOptionsLogUdp;
-    Config.Options.res_defnames = DefaultOptionsResDefnames;
-    Config.Options.anonymizer = DefaultOptionsAnonymizer;
-    Config.Options.enable_purge = DefaultOptionsEnablePurge;
-    Config.Options.client_db = DefaultOptionsClientDb;
-    Config.Options.query_icmp = DefaultOptionsQueryIcmp;
-    Config.Ftp.icon_prefix = safe_xstrdup(DefaultFtpIconPrefix);
-    Config.Ftp.icon_suffix = safe_xstrdup(DefaultFtpIconSuffix);
-    Config.Ftp.list_width = DefaultFtpListWidth;
-    Config.Ftp.list_wrap = DefaultFtpListWrap;
-    Config.Ftp.anon_user = safe_xstrdup(DefaultFtpAnonUser);
+    GetInteger(i);
+    if (i < 0)
+	i = 0;
+    *var = (u_short) i;
 }
 
 static void
-configDoConfigure(void)
+dump_vizhack(void)
 {
-    httpd_accel_mode = Config.Accel.prefix ? 1 : 0;
-    if (Config.errHtmlText == NULL)
-	Config.errHtmlText = xstrdup(null_string);
-    storeConfigure();
-    if (httpd_accel_mode && !strcmp(Config.Accel.host, "virtual"))
-	vhost_mode = 1;
-    sprintf(ThisCache, "%s:%d (Squid/%s)",
-	getMyHostname(),
-	(int) Config.Port.http[0],
-	SQUID_VERSION);
-    if (!Config.udpMaxHitObjsz || Config.udpMaxHitObjsz > SQUID_UDP_SO_SNDBUF)
-	Config.udpMaxHitObjsz = SQUID_UDP_SO_SNDBUF;
-    if (Config.appendDomain)
-	Config.appendDomainLen = strlen(Config.appendDomain);
-    else
-	Config.appendDomainLen = 0;
-    if (Config.Port.n_http == 0)
-	Config.Port.http[Config.Port.n_http++] = DefaultHttpPortNum;
+    debug(0,0)("XXX need to fix\n");
 }
 
-/* Parse a time specification from the config file.  Store the
- * result in 'iptr', after converting it to 'units' */
 static void
-parseTimeLine(int *iptr, const char *units)
+parse_vizhack(void)
 {
     char *token;
-    double d;
-    int m;
-    int u;
-    if ((u = parseTimeUnits(units)) == 0)
+    int i;
+    const struct hostent *hp;
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	self_destruct();
+    if (safe_inet_addr(token, &Config.vizHack.addr) == 1)
+	(void) 0;
+    else if ((hp = gethostbyname(token)))	/* dont use ipcache */
+	Config.vizHack.addr = inaddrFromHostent(hp);
+    else
 	self_destruct();
     if ((token = strtok(NULL, w_space)) == NULL)
 	self_destruct();
-    d = atof(token);
-    m = u;			/* default to 'units' if none specified */
-    if ((token = strtok(NULL, w_space)) != NULL) {
-	if ((m = parseTimeUnits(token)) == 0)
-	    self_destruct();
+    if (sscanf(token, "%d", &i) == 1)
+	Config.vizHack.port = i;
+    Config.vizHack.mcast_ttl = 64;
+    if ((token = strtok(NULL, w_space)) == NULL)
+	return;
+    if (sscanf(token, "%d", &i) == 1)
+	Config.vizHack.mcast_ttl = i;
+}
+
+static void
+dump_waisrelay(void)
+{
+    debug(0,0)("XXX need to fix\n");
+}
+
+static void
+parse_waisrelay(void)
+{
+    char *token;
+    int i;
+    token = strtok(NULL, w_space);
+    if (token == NULL)
+	self_destruct();
+    safe_free(Config.Wais.relayHost);
+    Config.Wais.relayHost = xstrdup(token);
+    GetInteger(i);
+    Config.Wais.relayPort = (u_short) i;
+}
+
+static void
+dump_wordlist(wordlist * list)
+{
+    printf("{");
+    while (list != NULL) {
+	printf("%s ", list->key);
+	list = list->next;
     }
-    *iptr = m * d / u;
+    printf("}");
 }
 
-static int
-parseTimeUnits(const char *unit)
+static void
+parse_wordlist(wordlist ** list)
 {
-    if (!strncasecmp(unit, T_SECOND_STR, strlen(T_SECOND_STR)))
-	return 1;
-    if (!strncasecmp(unit, T_MINUTE_STR, strlen(T_MINUTE_STR)))
-	return 60;
-    if (!strncasecmp(unit, T_HOUR_STR, strlen(T_HOUR_STR)))
-	return 3600;
-    if (!strncasecmp(unit, T_DAY_STR, strlen(T_DAY_STR)))
-	return 86400;
-    if (!strncasecmp(unit, T_WEEK_STR, strlen(T_WEEK_STR)))
-	return 86400 * 7;
-    if (!strncasecmp(unit, T_FORTNIGHT_STR, strlen(T_FORTNIGHT_STR)))
-	return 86400 * 14;
-    if (!strncasecmp(unit, T_MONTH_STR, strlen(T_MONTH_STR)))
-	return 86400 * 30;
-    if (!strncasecmp(unit, T_YEAR_STR, strlen(T_YEAR_STR)))
-	return 86400 * 365.2522;
-    if (!strncasecmp(unit, T_DECADE_STR, strlen(T_DECADE_STR)))
-	return 86400 * 365.2522 * 10;
-    debug(3, 1) ("parseTimeUnits: unknown time unit '%s'\n", unit);
-    return 0;
+    char *token;
+
+    while ((token = strtok(NULL, w_space)))
+	wordlistAdd(list, token);
 }
+
+static void
+parse_proxyauth(void)
+{
+	fatal("not implemented");
+}
+
+static void
+dump_proxyauth(void)
+{
+	fatal("not implemented");
+}
+
+#include "cf_parser.c"
@@ -60,32 +60,29 @@ DOC_END
 NAME: tcp_incoming_address bind_address
 TYPE: address
 LOC: Config.Addrs.tcp_incoming
-DEFAULT: INADDR_ANY
+DEFAULT: 0.0.0.0
 DOC_NONE
 
 NAME: tcp_outgoing_address outbound_address
 TYPE: address
 LOC: Config.Addrs.tcp_outgoing
-DEFAULT: no_addr.s_addr
+DEFAULT: 255.255.255.255
 DOC_NONE
 
 NAME: udp_incoming_address
 TYPE: address
 LOC:Config.Addrs.udp_incoming
-DEFAULT: INADDR_ANY
+DEFAULT: 0.0.0.0
 DOC_NONE
 
 NAME: udp_outgoing_address
 TYPE: address
 LOC: Config.Addrs.udp_outgoing
-DEFAULT: no_addr.s_addr
+DEFAULT: 255.255.255.255
 DOC_START
 	Usage: tcp_incoming_address 10.20.30.40
 	       udp_outgoing_address fully.qualified.domain.name
 
-	These tags have replaced 'bind_address' and 'outbound_address'
-	to provide more control for multihomed hosts.
-
 	tcp_incoming_address	is used for the HTTP socket which accepts
 				connections from clients and other caches.
 	tcp_outgoing_address	is used for connections made to remote
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.113 1997/06/20 00:00:10 wessels Exp $
+ * $Id: client_side.cc,v 1.114 1997/06/26 22:41:40 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -202,7 +202,7 @@ proxyAuthenticate(const char *headers)
      * table of users and passwords handy */
     static time_t last_time = 0;
     static time_t change_time = 0;
-    static hash_table * validated = NULL;
+    static hash_table *validated = NULL;
     static char *passwords = NULL;
     LOCAL_ARRAY(char, sent_user, ICP_IDENT_SZ);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.128 1997/06/20 05:26:09 wessels Exp $
+ * $Id: ftp.cc,v 1.129 1997/06/26 22:41:41 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -180,6 +180,7 @@ ftpStateFree(int fd, void *data)
     FtpStateData *ftpState = data;
     if (ftpState == NULL)
 	return;
+    debug(9, 3) ("ftpStateFree: %s\n", ftpState->entry->url);
     storeUnregisterAbort(ftpState->entry);
     storeUnlockObject(ftpState->entry);
     if (ftpState->reply_hdr) {
@@ -662,11 +663,11 @@ ftpReadData(int fd, void *data)
 	storeTimestampsSet(entry);
 	storeComplete(entry);
 	/* expect the "transfer complete" message on the control socket */
-    	commSetSelect(ftpState->ctrl.fd,
-		COMM_SELECT_READ,
-		ftpReadControlReply,
-		ftpState,
-		0);
+	commSetSelect(ftpState->ctrl.fd,
+	    COMM_SELECT_READ,
+	    ftpReadControlReply,
+	    ftpState,
+	    0);
     } else {
 	if (EBIT_TEST(ftpState->flags, FTP_ISDIR)) {
 	    ftpParseListing(ftpState, len);
@@ -918,7 +919,7 @@ ftpWriteCommandCallback(int fd, char *buf, int size, int errflag, void *data)
     StoreEntry *entry = ftpState->entry;
     debug(9, 7) ("ftpWriteCommandCallback: wrote %d bytes\n", size);
     if (errflag) {
-	debug(50,1)("ftpWriteCommandCallback: FD %d: %s\n", fd, xstrerror());
+	debug(50, 1) ("ftpWriteCommandCallback: FD %d: %s\n", fd, xstrerror());
 	BIT_RESET(entry->flag, ENTRY_CACHABLE);
 	storeReleaseRequest(entry);
 	storeAbort(entry, ERR_WRITE_ERROR, xstrerror(), 0);
@@ -1482,6 +1483,6 @@ ftpAbort(void *data)
     FtpStateData *ftpState = data;
     debug(9, 1) ("ftpAbort: %s\n", ftpState->entry->url);
     if (ftpState->data.fd >= 0)
-        comm_close(ftpState->data.fd);
+	comm_close(ftpState->data.fd);
     comm_close(ftpState->ctrl.fd);
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: main.cc,v 1.156 1997/06/21 02:38:09 wessels Exp $
+ * $Id: main.cc,v 1.157 1997/06/26 22:41:43 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -138,6 +138,7 @@ const char *const appname = "squid";
 const char *const localhost = "127.0.0.1";
 struct in_addr local_addr;
 struct in_addr no_addr;
+struct in_addr any_addr;
 struct in_addr theOutICPAddr;
 const char *const dash_str = "-";
 const char *const null_string = "";
@@ -150,7 +151,6 @@ extern void (*failure_notify) _PARAMS((const char *));
 static volatile int rotate_pending = 0;		/* set by SIGUSR1 handler */
 static int httpPortNumOverride = 1;
 static int icpPortNumOverride = 1;	/* Want to detect "-u 0" */
-static struct in_addr any_addr;
 #if MALLOC_DBG
 static int malloc_debug_level = 0;
 #endif
@@ -349,16 +349,17 @@ serverConnectionsOpen(void)
     struct in_addr addr;
     struct sockaddr_in xaddr;
     u_short port;
+    ushortlist *u;
     int len;
     int x;
     int fd;
     wordlist *s;
-    for (x = 0; x < Config.Port.n_http; x++) {
+    for (u = Config.Port.http; u; u=u->next) {
 	enter_suid();
 	fd = comm_open(SOCK_STREAM,
 	    0,
 	    Config.Addrs.tcp_incoming,
-	    Config.Port.http[x],
+	    u->i,
 	    COMM_NONBLOCKING,
 	    "HTTP Socket");
 	leave_suid();
@@ -367,7 +368,7 @@ serverConnectionsOpen(void)
 	comm_listen(fd);
 	commSetSelect(fd, COMM_SELECT_READ, httpAccept, NULL, 0);
 	debug(1, 1) ("Accepting HTTP connections on port %d, FD %d.\n",
-	    (int) Config.Port.http[x], fd);
+	    (int) u->i, fd);
 	HttpSockets[NHttpSockets++] = fd;
     }
     if (NHttpSockets < 1)
@@ -527,8 +528,9 @@ mainInitialize(void)
 	debug(0, 0) ("'cache_effective_user' option in the config file.\n");
 	fatal("Don't run Squid as root, set 'cache_effective_user'!");
     }
+    assert(Config.Port.http);
     if (httpPortNumOverride != 1)
-	Config.Port.http[0] = (u_short) httpPortNumOverride;
+	Config.Port.http->i = (u_short) httpPortNumOverride;
     if (icpPortNumOverride != 1)
 	Config.Port.icp = (u_short) icpPortNumOverride;
 
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.147 1997/06/21 02:38:10 wessels Exp $
+ * $Id: neighbors.cc,v 1.148 1997/06/26 22:41:44 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -730,15 +730,15 @@ neighborAdd(const char *host,
     int mcast_ttl)
 {
     peer *p = NULL;
-    int j;
+    ushortlist *u;
     const char *me = getMyHostname();
     if (!strcmp(host, me)) {
-	for (j = 0; j < Config.Port.n_http; j++) {
-	    if (http_port == Config.Port.http[j]) {
-		debug(15, 0) ("neighborAdd: skipping cache_host %s %s/%d/%d\n",
-		    type, host, http_port, icp_port);
-		return;
-	    }
+	for (u=Config.Port.http; u; u=u->next) {
+	    if (http_port != u->i)
+		continue;
+	    debug(15, 0) ("neighborAdd: skipping cache_host %s %s/%d/%d\n",
+	        type, host, http_port, icp_port);
+	    return;
 	}
     }
     p = xcalloc(1, sizeof(peer));
@@ -910,7 +910,7 @@ peerDestroy(peer * p)
 	safe_free(l);
     }
     if (p->ip_lookup_pending)
-        ipcacheUnregister(p->host, p);
+	ipcacheUnregister(p->host, p);
     safe_free(p->host);
     cbdataFree(p);
 }
@@ -958,7 +958,7 @@ peerRefreshDNS(void *junk)
     peer *next = Peers.peers_head;
     while ((p = next)) {
 	next = p->next;
-        p->ip_lookup_pending = 1;
+	p->ip_lookup_pending = 1;
 	/* some random, bogus FD for ipcache */
 	p->test_fd = Squid_MaxFD + current_time.tv_usec;
 	ipcache_nbgethostbyname(p->host, peerDNSConfigure, p);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.39 1997/06/18 00:20:02 wessels Exp $
+ * $Id: send-announce.cc,v 1.40 1997/06/26 22:41:45 wessels Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -62,10 +62,11 @@ send_announce(const ipcache_addrs * ia, void *data)
     sndbuf[0] = '\0';
     sprintf(tbuf, "cache_version SQUID/%s\n", version_string);
     strcat(sndbuf, tbuf);
+    assert(Config.Port.http);
     sprintf(tbuf, "Running on %s %d %d\n",
 	getMyHostname(),
-	Config.Port.http[0],
-	Config.Port.icp);
+	(int) Config.Port.http->i,
+	(int) Config.Port.icp);
     strcat(sndbuf, tbuf);
     if (Config.adminEmail) {
 	sprintf(tbuf, "cache_admin: %s\n", Config.adminEmail);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.124 1997/06/21 02:38:15 wessels Exp $
+ * $Id: squid.h,v 1.125 1997/06/26 22:41:46 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -350,7 +350,8 @@ extern const char *const appname;	/* main.c */
 extern struct in_addr local_addr;	/* main.c */
 extern struct in_addr theOutICPAddr;	/* main.c */
 extern const char *const localhost;
-extern struct in_addr no_addr;	/* comm.c */
+extern struct in_addr no_addr;	/* main.c */
+extern struct in_addr any_addr;	/* main.c */
 extern int opt_udp_hit_obj;	/* main.c */
 extern int opt_mem_pools;	/* main.c */
 extern int opt_forwarded_for;	/* main.c */