@@ -1,3 +1,19 @@
+Changes to squid-4.0.12 (01 Jul 2016):
+
+	- Regression Fix: shell issues with require_smblib definition
+	- Regression Bug 4532: pid_filename not working as documented
+	- Regression Bug 4504: Too many WARNING: Ignoring error setting CA certificate locations
+	- Bug 4516: security_file_certgen man page update
+	- Bug 4446: undefined reference to 'libecap::Name::Name'
+	- Bug 4376: clang cannot build Squid eCAP code
+	- HTTP/1.1: Update all stored headers on 304 revalidation
+	- TLS: Authority Key Identifier certificate extension
+	- Add a script to find kid-specific cache.log lines
+	- Cleanup cppunit detection and use
+	- ... and several performance improvements
+	- ... and some unit test updates
+	- ... and all fixes from 3.5.20
+
 Changes to squid-4.0.11 (09 Jun 2016):
 
 	- Bug 4517: error: comparison between signed and unsigned integer
@@ -172,6 +188,25 @@ Changes to squid-4.0.1 (14 Oct 2015):
 	- ... and many documentation changes
 	- ... and much code cleanup and polishing
 
+Changes to squid-3.5.20 (01 Jul 2016):
+
+	- Bug 4523: smblib compile fails on NetBSD
+	- Bug 4485: off-by-one out-of-bounds Parser::Tokenizer::int64() read errors
+	- Bug 3579: assertion failed 'MemPools[type]' from dst_as ACL
+	- Fix icons loading speed
+	- Fix OpenSSL detection on FreeBSD
+	- Fix assertion failed: Write.cc:38: 'fd_table[conn->fd].flags.open'
+	- Fix SEGFAULT parsing malformed adaptation service configuration
+	- Fix ConnStateData::In::maybeMakeSpaceAvailable() logic
+	- Do not override user defined -std option
+	- Do not allow low-level debugging to hide important/critical messages
+	- Do not make bogus recvmsg(2) calls when closing UDS sockets
+	- Support unified EUI format code in external_acl_type
+
+Changes to squid-3.5.19 (09 May 2016):
+
+	- Regression Bug 4515: interception proxy hangs
+
 Changes to squid-3.5.18 (06 May 2016):
 
 	- Bug 4510: stale comment about 32KB limit on shared memory cache entries
@@ -5,7 +5,7 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-AC_INIT([Squid Web Proxy],[4.0.11-BZR],[http://bugs.squid-cache.org/],[squid])
+AC_INIT([Squid Web Proxy],[4.0.12-BZR],[http://bugs.squid-cache.org/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
 AC_CONFIG_AUX_DIR(cfgaux)
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.18 release notes</title>
+<title>Squid 3.5.20 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.18.
+The Squid Team are pleased to announce the release of Squid-3.5.20.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -364,6 +364,10 @@ This section gives a thorough account of those changes in three categories:
 	<tag>sslproxy_cert_sign_hash</tag>
 	<p>New directive to set the hashing algorithm to use when signing generated certificates.
 
+	<tag>sslproxy_foreign_intermediate_certs</tag>
+	<p>New directive to load intermediate certificates for validating server
+	   certificate chains. This directive is only available in 3.5.13 and later.
+
 	<tag>sslproxy_session_cache_size</tag>
 	<p>New directive which sets the cache size to use for TLS/SSL sessions cache.
 
@@ -452,6 +456,7 @@ This section gives a thorough account of those changes in three categories:
 	<p>New format code <em>%ssl::&lt;cert_subject</em> to send SSL server certificate DN.
 	<p>New format code <em>%ssl::&lt;cert_issuer</em> to send SSL server certificate issuer DN.
 	<p>New format code <em>%un</em> to send any available user name (requires 3.5.7 or later).
+	<p>New format code <em>%&gt;eui</em> to send either EUI-48 or EUI-64 (requires 3.5.20 or later).
 	<p>New response kv-pair <em>clt_conn_tag=</em> to associates a given tag with the client TCP connection.
 
 	<tag>forward_max_tries</tag>
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 4.0.11 release notes</title>
+<title>Squid 4.0.12 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -12,7 +12,7 @@ for Applied Network Research and members of the Web Caching community.
 <toc>
 
 <sect>Notice
-<p>The Squid Team are pleased to announce the release of Squid-4.0.11 for testing.
+<p>The Squid Team are pleased to announce the release of Squid-4.0.12 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v4/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -150,12 +150,12 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
        service we are going to call, sine some servers want it in uppercase */
 
     for (i=0; i < strlen(server); i++)
-        called[i] = toupper(server[i]);
+        called[i] = xtoupper(server[i]);
 
     called[strlen(server)] = 0;    /* Make it a string */
 
     for (i=0; i < strlen(con -> myname); i++)
-        calling[i] = toupper(con -> myname[i]);
+        calling[i] = xtoupper(con -> myname[i]);
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
@@ -266,12 +266,12 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
        service we are going to call, sine some servers want it in uppercase */
 
     for (i=0; i < strlen(host); i++)
-        called[i] = toupper(host[i]);
+        called[i] = xtoupper(host[i]);
 
     called[strlen(host)] = 0;    /* Make it a string */
 
     for (i=0; i < strlen(con -> myname); i++)
-        calling[i] = toupper(con -> myname[i]);
+        calling[i] = xtoupper(con -> myname[i]);
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
@@ -42,7 +42,6 @@ CachePeer::CachePeer() :
     domain(NULL),
 #if USE_OPENSSL
     sslContext(NULL),
-    sslSession(NULL),
 #endif
     front_end_https(0),
     connection_auth(2 /* auto */)
@@ -102,9 +101,6 @@ CachePeer::~CachePeer()
 #if USE_OPENSSL
     if (sslContext)
         SSL_CTX_free(sslContext);
-
-    if (sslSession)
-        SSL_SESSION_free(sslSession);
 #endif
 }
 
@@ -184,9 +184,7 @@ class CachePeer
     /// security settings for peer connection
     Security::PeerOptions secure;
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
     int front_end_https;
     int connection_auth;
@@ -236,7 +236,7 @@ bool Adaptation::Ecap::ServiceRep::probed() const
 
 bool Adaptation::Ecap::ServiceRep::up() const
 {
-    return theService;
+    return bool(theService);
 }
 
 bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &urlPath) const
@@ -34,9 +34,6 @@ CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &svcCfg):
     AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(svcCfg),
     sslContext(NULL),
-#if USE_OPENSSL
-    sslSession(NULL),
-#endif
     theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
@@ -111,9 +111,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     virtual void noteAdaptationAnswer(const Answer &answer);
 
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
 private:
     // stores Prepare() callback info
@@ -725,8 +725,7 @@ Ssl::IcapPeerConnector::initializeSsl()
     if (check)
         check->dst_peer_name = *host;
 
-    if (icapService->sslSession)
-        SSL_set_session(ssl, icapService->sslSession);
+    Security::GetSessionResumeData(Security::SessionPointer(ssl), icapService->sslSession);
 
     return ssl;
 }
@@ -738,13 +737,7 @@ Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
 
     const int fd = serverConnection()->fd;
-    auto ssl = fd_table[fd].ssl.get();
-    assert(ssl);
-    if (!SSL_session_reused(ssl)) {
-        if (icapService->sslSession)
-            SSL_SESSION_free(icapService->sslSession);
-        icapService->sslSession = SSL_get1_session(ssl);
-    }
+    Security::GetSessionResumeData(fd_table[fd].ssl, icapService->sslSession);
 }
 
 void
@@ -143,8 +143,7 @@ AnyP::PortCfg::configureSslServerContext()
         }
     }
 
-    secure.staticContext.resetWithoutLocking(secure.createStaticServerContext(*this));
-    if (!secure.staticContext) {
+    if (!secure.createStaticServerContext(*this)) {
         char buf[128];
         fatalf("%s_port %s initialization error", AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
     }
@@ -201,7 +201,7 @@ Auth::User::addIp(Ip::Address ipaddr)
             /* This ip has already been seen. */
             found = 1;
             /* update IP ttl */
-            ipdata->ip_expiretime = squid_curtime;
+            ipdata->ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
         } else if (ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&ipdata->node, &ip_list);
@@ -946,10 +946,6 @@ configDoConfigure(void)
         }
     }
 #endif
-
-    if (Config.readAheadGap <= 0) {
-        fatalf("read_ahead_gap must be greater than 0 bytes");
-    }
 }
 
 /** Parse a line containing an obsolete directive.
@@ -5650,17 +5650,6 @@ DEFAULT: 16 KB
 DOC_START
 	The amount of data the cache will buffer ahead of what has been
 	sent to the client when retrieving an object from another server.
-	
-	This also influences the maximum network read(2)/write(2) sizes in some
-	circumstances. Reducing the size of this buffer will decrease
-	per-connection memory usage at the cost of more read(2)/write(2) calls.
-	Conversely, increasing the size of this buffer will decrease the number of
-	read(2)/write(2) calls at the cost of memory usage, potentially improving
-	performance.
-
-	Squid does not slow does the response delivery to the client in order to
-	fill the buffer.
-
 DOC_END
 
 NAME: negative_ttl
@@ -1012,9 +1012,12 @@ ConnStateData::abortRequestParsing(const char *const uri)
     http->uri = xstrdup(uri);
     setLogUri (http, uri);
     auto *context = new Http::Stream(clientConnection, http);
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = context->reqbuf;
+    tempBuffer.length = HTTP_REQBUF_SZ;
     clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, new clientReplyContext(http), clientSocketRecipient,
-                     clientSocketDetach, context, context->getClientStreamBuffer());
+                     clientSocketDetach, context, tempBuffer);
     return context;
 }
 
@@ -1356,11 +1359,15 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
     http->req_sz = hp->messageHeaderSize();
     Http::Stream *result = new Http::Stream(csd->clientConnection, http);
 
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = result->reqbuf;
+    tempBuffer.length = HTTP_REQBUF_SZ;
+
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
-                     clientSocketDetach, newClient, result->getClientStreamBuffer());
+                     clientSocketDetach, newClient, tempBuffer);
 
     /* set url */
     debugs(33,5, "Prepare absolute URL from " <<
@@ -2563,8 +2570,8 @@ httpAccept(const CommAcceptCbParams &params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = Http::NewServer(xact);
-    AsyncJob::Start(connState); // usually async-calls readSomeData()
+    auto *srv = Http::NewServer(xact);
+    AsyncJob::Start(srv); // usually async-calls readSomeData()
 }
 
 #if USE_OPENSSL
@@ -2650,7 +2657,7 @@ clientNegotiateSSL(int fd, void *data)
         return;
     }
 
-    if (SSL_session_reused(ssl)) {
+    if (Security::SessionIsResumed(fd_table[fd].ssl)) {
         debugs(83, 2, "clientNegotiateSSL: Session " << SSL_get_session(ssl) <<
                " reused on FD " << fd << " (" << fd_table[fd].ipaddr << ":" << (int)fd_table[fd].remote_port << ")");
     } else {
@@ -2791,8 +2798,8 @@ httpsAccept(const CommAcceptCbParams &params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = Https::NewServer(xact);
-    AsyncJob::Start(connState); // usually async-calls postHttpsAccept()
+    auto *srv = Https::NewServer(xact);
+    AsyncJob::Start(srv); // usually async-calls postHttpsAccept()
 }
 
 void
@@ -11,7 +11,6 @@
 #include "http/Stream.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
-#include "SquidConfig.h"
 #include "Store.h"
 #include "TimeOrTag.h"
 
@@ -21,10 +20,10 @@ Http::Stream::Stream(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aR
     reply(nullptr),
     writtenToSocket(0),
     mayUseConnection_(false),
-    connRegistered_(false),
-    requestBuffer(nullptr)
+    connRegistered_(false)
 {
     assert(http != nullptr);
+    memset(reqbuf, '\0', sizeof (reqbuf));
     flags.deferred = 0;
     flags.parsed_ok = 0;
     deferredparams.node = nullptr;
@@ -110,10 +109,12 @@ Http::Stream::pullData()
     debugs(33, 5, reply << " written " << http->out.size << " into " << clientConnection);
 
     /* More data will be coming from the stream. */
-    StoreIOBuffer readBuffer = getClientStreamBuffer();
+    StoreIOBuffer readBuffer;
     /* XXX: Next requested byte in the range sequence */
     /* XXX: length = getmaximumrangelenfgth */
     readBuffer.offset = getNextRangeOffset();
+    readBuffer.length = HTTP_REQBUF_SZ;
+    readBuffer.data = reqbuf;
     /* we may note we have reached the end of the wanted ranges */
     clientStreamRead(getTail(), http, readBuffer);
 }
@@ -567,18 +568,6 @@ Http::Stream::deferRecipientForLater(clientStreamNode *node, HttpReply *rep, Sto
     deferredparams.queuedBuffer = receivedData;
 }
 
-StoreIOBuffer
-Http::Stream::getClientStreamBuffer()
-{
-    if (!requestBuffer) {
-        requestBuffer = new MemBlob(Config.readAheadGap);
-    }
-    StoreIOBuffer tempBuffer;
-    tempBuffer.data = requestBuffer->mem;
-    tempBuffer.length = requestBuffer->spaceSize();
-    return tempBuffer;
-}
-
 void
 Http::Stream::prepareReply(HttpReply *rep)
 {
@@ -120,13 +120,12 @@ class Stream : public RefCountable
 
     void deferRecipientForLater(clientStreamNode *, HttpReply *, StoreIOBuffer receivedData);
 
-    StoreIOBuffer getClientStreamBuffer();
-
 public: // HTTP/1.x state data
 
     Comm::ConnectionPointer clientConnection; ///< details about the client connection socket
     ClientHttpRequest *http;    /* we pretend to own that Job */
     HttpReply *reply;
+    char reqbuf[HTTP_REQBUF_SZ];
     struct {
         unsigned deferred:1; ///< This is a pipelined request waiting for the current object to complete
         unsigned parsed_ok:1; ///< Was this parsed correctly?
@@ -159,8 +158,6 @@ class Stream : public RefCountable
 
     bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
     bool connRegistered_;
-
-    MemBlob::Pointer requestBuffer;
 };
 
 } // namespace Http
@@ -117,19 +117,21 @@ Security::ServerOptions::createBlankContext() const
     return t;
 }
 
-Security::ContextPtr
+bool
 Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &port)
 {
     updateTlsVersionLimits();
 
-    Security::ContextPtr t = createBlankContext();
+    Security::ContextPointer t(createBlankContext());
     if (t) {
 #if USE_OPENSSL
-        Ssl::InitServerContext(t, port);
+        if (!Ssl::InitServerContext(t, port))
+            return false;
 #endif
     }
 
-    return t;
+    staticContext = std::move(t);
+    return bool(staticContext);
 }
 
 void
@@ -33,7 +33,9 @@ class ServerOptions : public PeerOptions
     virtual void dumpCfg(Packable *, const char *pfx) const;
 
     /// generate a security server-context from these configured options
-    Security::ContextPtr createStaticServerContext(AnyP::PortCfg &);
+    /// the resulting context is stored in staticContext
+    /// \returns true if a context could be created
+    bool createStaticServerContext(AnyP::PortCfg &);
 
     /// update the context with DH, EDH, EECDH settings
     void updateContextEecdh(Security::ContextPtr &);
@@ -16,6 +16,52 @@
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
+#if USE_GNUTLS
+void
+squid_datum_free(gnutls_datum_t *D) {
+    gnutls_free(D);
+}
+#endif
+
+bool
+Security::SessionIsResumed(const Security::SessionPointer &s)
+{
+    return
+#if USE_OPENSSL
+        SSL_session_reused(s.get()) == 1;
+#elif USE_GNUTLS
+        gnutls_session_is_resumed(s.get()) != 0;
+#else
+        false;
+#endif
+}
+
+void
+Security::GetSessionResumeData(const Security::SessionPointer &s, Security::SessionStatePointer &data)
+{
+    if (!SessionIsResumed(s)) {
+#if USE_OPENSSL
+        data.reset(SSL_get1_session(s.get()));
+#elif USE_GNUTLS
+        gnutls_datum_t *tmp = nullptr;
+        (void)gnutls_session_get_data2(s.get(), tmp);
+        data.reset(tmp);
+#endif
+    }
+}
+
+void
+Security::SetSessionResumeData(const Security::SessionPtr &s, const Security::SessionStatePointer &data)
+{
+    if (s) {
+#if USE_OPENSSL
+        (void)SSL_set_session(s, data.get());
+#elif USE_GNUTLS
+        (void)gnutls_session_set_data(s, data->data, data->size);
+#endif
+    }
+}
+
 static bool
 isTlsServer()
 {
@@ -32,24 +32,40 @@ typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer<SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL> SessionPointer;
 
+typedef std::unique_ptr<SSL_SESSION, std::function<decltype(SSL_SESSION_free)>> SessionStatePointer;
+
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
-// TODO: Convert to Locking pointer.
 // Locks can be implemented attaching locks counter to gnutls_session_t
 // objects using the gnutls_session_set_ptr()/gnutls_session_get_ptr ()
 // library functions
-//typedef std::unique_ptr<struct gnutls_session_int, std::function<decltype(gnutls_deinit)>> SessionPointer;
 CtoCpp1(gnutls_deinit, gnutls_session_t);
 typedef LockingPointer<struct gnutls_session_int, gnutls_deinit_cpp, -1> SessionPointer;
 
+/// wrapper function to avoid compile errors with gnutls_free() being a typedef.
+void squid_datum_free(gnutls_datum_t *D);
+typedef std::unique_ptr<gnutls_datum_t, std::function<decltype(squid_datum_free)>> SessionStatePointer;
+
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
 CtoCpp1(xfree, SessionPtr);
 typedef LockingPointer<void, xfree_cpp, -1> SessionPointer;
 
+typedef std::unique_ptr<int> SessionStatePointer;
+
 #endif
 
+/// whether the session is a resumed one
+bool SessionIsResumed(const Security::SessionPointer &);
+
+/// Retrieve the data needed to resume this session on a later connection
+void GetSessionResumeData(const Security::SessionPointer &, Security::SessionStatePointer &);
+
+/// Set the data for resuming a previous session.
+/// Needs to be done before using the SessionPointer for a handshake.
+void SetSessionResumeData(const Security::SessionPtr &, const Security::SessionStatePointer &);
+
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
@@ -759,11 +759,15 @@ Ftp::Server::parseOneRequest()
     Http::Stream *const result =
         new Http::Stream(clientConnection, http);
 
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = result->reqbuf;
+    tempBuffer.length = HTTP_REQBUF_SZ;
+
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
-                     clientSocketDetach, newClient, result->getClientStreamBuffer());
+                     clientSocketDetach, newClient, tempBuffer);
 
     result->flags.parsed_ok = 1;
     return result;
@@ -46,8 +46,7 @@ Ssl::BlindPeerConnector::initializeSsl()
         SBuf *host = new SBuf(peer->secure.sslDomain);
         SSL_set_ex_data(ssl, ssl_ex_index_server, host);
 
-        if (peer->sslSession)
-            SSL_set_session(ssl, peer->sslSession);
+        Security::SetSessionResumeData(ssl, peer->sslSession);
     } else {
         SBuf *hostName = new SBuf(request->url.host());
         SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
@@ -70,13 +69,9 @@ Ssl::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
     }
 
-    const int fd = serverConnection()->fd;
-    Security::SessionPtr ssl = fd_table[fd].ssl.get();
-    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
-        if (serverConnection()->getPeer()->sslSession)
-            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
-
-        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
+    if (auto *peer = serverConnection()->getPeer()) {
+        const int fd = serverConnection()->fd;
+        Security::GetSessionResumeData(fd_table[fd].ssl, peer->sslSession);
     }
 }
 
@@ -557,63 +557,57 @@ configureSslContext(Security::ContextPtr sslContext, AnyP::PortCfg &port)
 }
 
 bool
-Ssl::InitServerContext(Security::ContextPtr &sslContext, AnyP::PortCfg &port)
+Ssl::InitServerContext(const Security::ContextPointer &ctx, AnyP::PortCfg &port)
 {
-    if (!sslContext)
+    if (!ctx)
         return false;
 
-    if (!SSL_CTX_use_certificate(sslContext, port.signingCert.get())) {
+    if (!SSL_CTX_use_certificate(ctx.get(), port.signingCert.get())) {
         const int ssl_error = ERR_get_error();
         const auto &keys = port.secure.certs.front();
         debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS certificate '" << keys.certFile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
         return false;
     }
 
-    if (!SSL_CTX_use_PrivateKey(sslContext, port.signPkey.get())) {
+    if (!SSL_CTX_use_PrivateKey(ctx.get(), port.signPkey.get())) {
         const int ssl_error = ERR_get_error();
         const auto &keys = port.secure.certs.front();
         debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS private key '" << keys.privateKeyFile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
         return false;
     }
 
-    Ssl::addChainToSslContext(sslContext, port.certsToChain.get());
+    Ssl::addChainToSslContext(ctx.get(), port.certsToChain.get());
 
     /* Alternate code;
         debugs(83, DBG_IMPORTANT, "Using certificate in " << certfile);
 
-        if (!SSL_CTX_use_certificate_chain_file(sslContext, certfile)) {
+        if (!SSL_CTX_use_certificate_chain_file(ctx.get(), certfile)) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << certfile << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
             return false;
         }
 
         debugs(83, DBG_IMPORTANT, "Using private key in " << keyfile);
-        ssl_ask_password(sslContext, keyfile);
+        ssl_ask_password(ctx.get(), keyfile);
 
-        if (!SSL_CTX_use_PrivateKey_file(sslContext, keyfile, SSL_FILETYPE_PEM)) {
+        if (!SSL_CTX_use_PrivateKey_file(ctx.get(), keyfile, SSL_FILETYPE_PEM)) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << keyfile << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
             return false;
         }
 
         debugs(83, 5, "Comparing private and public SSL keys.");
 
-        if (!SSL_CTX_check_private_key(sslContext)) {
+        if (!SSL_CTX_check_private_key(ctx.get())) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: SSL private key '" << certfile << "' does not match public key '" <<
                    keyfile << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
             return false;
         }
     */
 
-    if (!configureSslContext(sslContext, port)) {
+    if (!configureSslContext(ctx.get(), port)) {
         debugs(83, DBG_CRITICAL, "ERROR: Configuring static SSL context");
-        SSL_CTX_free(sslContext);
         return false;
     }
 
@@ -112,7 +112,7 @@ extern Ipc::MemMap *SessionCache;
 extern const char *SessionCacheName;
 
 /// initialize a TLS server context with OpenSSL specific settings
-bool InitServerContext(Security::ContextPtr &, AnyP::PortCfg &);
+bool InitServerContext(const Security::ContextPointer &, AnyP::PortCfg &);
 
 /// initialize a TLS client context with OpenSSL specific settings
 bool InitClientContext(Security::ContextPtr &, Security::PeerOptions &, long options, long flags);
@@ -34,7 +34,7 @@ void parse_securePeerOptions(Security::PeerOptions *) STUB
 void Security::ServerOptions::parse(const char *) STUB
 void Security::ServerOptions::dumpCfg(Packable *, const char *) const STUB
 Security::ContextPtr Security::ServerOptions::createBlankContext() const STUB
-Security::ContextPtr Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &) STUB_RETVAL(nullptr)
+bool Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &) STUB_RETVAL(false)
 void Security::ServerOptions::updateContextEecdh(Security::ContextPtr &) STUB
 
 #include "security/NegotiationHistory.h"
@@ -48,3 +48,10 @@ const char *Security::NegotiationHistory::printTlsVersion(AnyP::ProtocolVersion
 Security::HandshakeParser::HandshakeParser() STUB
 bool Security::HandshakeParser::parseHello(const SBuf &) STUB_RETVAL(false)
 
+#include "security/Session.h"
+namespace Security {
+bool SessionIsResumed(const Security::SessionPointer &) STUB_RETVAL(false)
+void GetSessionResumeData(const Security::SessionPointer &, Security::SessionStatePointer &) STUB
+void SetSessionResumeData(const Security::SessionPtr &, const Security::SessionStatePointer &) STUB
+} // namespace Security
+
@@ -55,7 +55,7 @@ namespace Ssl
 CertError & CertError::operator = (const CertError &old) STUB_RETVAL(*this)
 bool CertError::operator == (const CertError &ce) const STUB_RETVAL(false)
 bool CertError::operator != (const CertError &ce) const STUB_RETVAL(false)
-bool InitServerContext(Security::ContextPtr &, AnyP::PortCfg &) STUB_RETVAL(false)
+bool InitServerContext(const Security::ContextPointer &, AnyP::PortCfg &) STUB_RETVAL(false)
 bool InitClientContext(Security::ContextPtr &, Security::PeerOptions &, long, const char *) STUB_RETVAL(false)
 } // namespace Ssl
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)