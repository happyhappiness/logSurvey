@@ -1,5 +1,5 @@
 /*
- * $Id: HttpBody.cc,v 1.4 1998/02/26 08:10:53 rousskov Exp $
+ * $Id: HttpBody.cc,v 1.5 1998/02/26 18:00:30 wessels Exp $
  *
  * DEBUG: section 56    HTTP Message Body
  * AUTHOR: Alex Rousskov
@@ -37,35 +37,35 @@
 
 
 void
-httpBodyInit(HttpBody *body)
+httpBodyInit(HttpBody * body)
 {
     body->buf = NULL;
     body->size = 0;
     body->freefunc = NULL;
 }
 
 void
-httpBodyClean(HttpBody *body)
+httpBodyClean(HttpBody * body)
 {
     assert(body);
     if (body->buf) {
 	assert(body->freefunc);
-	(*body->freefunc)(body->buf);
+	(*body->freefunc) (body->buf);
     }
     body->buf = NULL;
     body->size = 0;
 }
 
 /* set body, if freefunc is NULL the content will be copied, otherwise not */
 void
-httpBodySet(HttpBody *body, const char *buf, int size, FREE *freefunc)
+httpBodySet(HttpBody * body, const char *buf, int size, FREE * freefunc)
 {
     assert(body);
     assert(!body->buf);
     assert(buf);
     assert(size);
-    assert(buf[size-1] == '\0'); /* paranoid */
-    if (!freefunc) { /* they want us to make our own copy */
+    assert(buf[size - 1] == '\0');	/* paranoid */
+    if (!freefunc) {		/* they want us to make our own copy */
 	body->buf = xmalloc(size);
 	xmemcpy(body->buf, buf, size);
 	freefunc = &xfree;
@@ -75,16 +75,16 @@ httpBodySet(HttpBody *body, const char *buf, int size, FREE *freefunc)
 }
 
 void
-httpBodyPackInto(const HttpBody *body, Packer *p)
+httpBodyPackInto(const HttpBody * body, Packer * p)
 {
     assert(body && p);
     /* assume it was a 0-terminating buffer */
     if (body->size)
-	packerAppend(p, body->buf, body->size-1);
+	packerAppend(p, body->buf, body->size - 1);
 }
 
 const char *
-httpBodyPtr(const HttpBody *body)
+httpBodyPtr(const HttpBody * body)
 {
     return body->buf ? body->buf : "";
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: HttpHeader.cc,v 1.9 1998/02/26 06:30:01 rousskov Exp $
+ * $Id: HttpHeader.cc,v 1.10 1998/02/26 18:00:31 wessels Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -32,25 +32,25 @@
 #include "MemPool.h"
 
 /*
-   On naming conventions:
- 
-   HTTP/1.1 defines message-header as 
-
-          message-header = field-name ":" [ field-value ] CRLF
-          field-name     = token
-          field-value    = *( field-content | LWS )
-
-   HTTP/1.1 does not give a name name a group of all message-headers in a message.
-   Squid 1.1 seems to refer to that group _plus_ start-line as "headers".
-
-   HttpHeader is an object that represents all message-headers in a message.
-   HttpHeader does not manage start-line.
-
-   HttpHeader is implemented as a collection of header "entries"
-   An entry is a (field_id, field) pair where
-	- field_id is one of the http_hdr_type ids,
-	- field is a compiled(parsed) image of message-header.
-*/
+ * On naming conventions:
+ * 
+ * HTTP/1.1 defines message-header as 
+ * 
+ * message-header = field-name ":" [ field-value ] CRLF
+ * field-name     = token
+ * field-value    = *( field-content | LWS )
+ * 
+ * HTTP/1.1 does not give a name name a group of all message-headers in a message.
+ * Squid 1.1 seems to refer to that group _plus_ start-line as "headers".
+ * 
+ * HttpHeader is an object that represents all message-headers in a message.
+ * HttpHeader does not manage start-line.
+ * 
+ * HttpHeader is implemented as a collection of header "entries"
+ * An entry is a (field_id, field) pair where
+ * - field_id is one of the http_hdr_type ids,
+ * - field is a compiled(parsed) image of message-header.
+ */
 
 
 /*
@@ -59,13 +59,13 @@
 
 /* HTTP/1.1 extension-header */
 struct _HttpHeaderExtField {
-    char *name;   /* field-name  from HTTP/1.1 (no column after name!) */
-    char *value;  /* field-value from HTTP/1.1 */
+    char *name;			/* field-name  from HTTP/1.1 (no column after name!) */
+    char *value;		/* field-value from HTTP/1.1 */
 };
 
 /* possible types for fields */
 typedef enum {
-    ftInvalid = HDR_ENUM_END, /* to catch nasty errors with hdr_id<->fld_type clashes */
+    ftInvalid = HDR_ENUM_END,	/* to catch nasty errors with hdr_id<->fld_type clashes */
     ftInt,
     ftPChar,
     ftDate_1123,
@@ -89,10 +89,10 @@ typedef size_t StatSize;
 
 /* per field statistics */
 typedef struct {
-    StatCount aliveCount;  /* created but not destroyed (count)*/
-    StatCount parsCount;   /* #parsing attempts */
-    StatCount errCount;    /* #pasring errors */
-    StatCount repCount;    /* #repetitons */
+    StatCount aliveCount;	/* created but not destroyed (count) */
+    StatCount parsCount;	/* #parsing attempts */
+    StatCount errCount;		/* #pasring errors */
+    StatCount repCount;		/* #repetitons */
 } HttpHeaderFieldStat;
 
 /* per header statistics */
@@ -128,45 +128,47 @@ typedef ssize_t HttpHeaderPos;
  * We calculate name lengths and reorganize this array on start up. 
  * After reorganization, field id can be used as an index to the table.
  */
-static field_attrs_t Headers[] = {
-    { "Accept",            HDR_ACCEPT,          ftPChar },
-    { "Age",               HDR_AGE,             ftInt },
-    { "Cache-Control",     HDR_CACHE_CONTROL,   ftPSCC },
-    { "Connection",        HDR_CONNECTION,      ftPChar }, /* for now */
-    { "Content-Encoding",  HDR_CONTENT_ENCODING,ftPChar },
-    { "Content-Length",    HDR_CONTENT_LENGTH,  ftInt },
-    { "Content-MD5",       HDR_CONTENT_MD5,     ftPChar }, /* for now */
-    { "Content-Type",      HDR_CONTENT_TYPE,    ftPChar },
-    { "Date",              HDR_DATE,            ftDate_1123 },
-    { "Etag",              HDR_ETAG,            ftPChar }, /* for now */
-    { "Expires",           HDR_EXPIRES,         ftDate_1123 },
-    { "Host",              HDR_HOST,            ftPChar },
-    { "If-Modified-Since", HDR_IMS,             ftDate_1123 },
-    { "Last-Modified",     HDR_LAST_MODIFIED,   ftDate_1123 },
-    { "Location",          HDR_LOCATION,        ftPChar },
-    { "Max-Forwards",      HDR_MAX_FORWARDS,    ftInt },
-    { "Proxy-Authenticate",HDR_PROXY_AUTHENTICATE,ftPChar },
-    { "Public",            HDR_PUBLIC,          ftPChar },
-    { "Retry-After",       HDR_RETRY_AFTER,     ftPChar }, /* for now */
+static field_attrs_t Headers[] =
+{
+    {"Accept", HDR_ACCEPT, ftPChar},
+    {"Age", HDR_AGE, ftInt},
+    {"Cache-Control", HDR_CACHE_CONTROL, ftPSCC},
+    {"Connection", HDR_CONNECTION, ftPChar},	/* for now */
+    {"Content-Encoding", HDR_CONTENT_ENCODING, ftPChar},
+    {"Content-Length", HDR_CONTENT_LENGTH, ftInt},
+    {"Content-MD5", HDR_CONTENT_MD5, ftPChar},	/* for now */
+    {"Content-Type", HDR_CONTENT_TYPE, ftPChar},
+    {"Date", HDR_DATE, ftDate_1123},
+    {"Etag", HDR_ETAG, ftPChar},	/* for now */
+    {"Expires", HDR_EXPIRES, ftDate_1123},
+    {"Host", HDR_HOST, ftPChar},
+    {"If-Modified-Since", HDR_IMS, ftDate_1123},
+    {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
+    {"Location", HDR_LOCATION, ftPChar},
+    {"Max-Forwards", HDR_MAX_FORWARDS, ftInt},
+    {"Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftPChar},
+    {"Public", HDR_PUBLIC, ftPChar},
+    {"Retry-After", HDR_RETRY_AFTER, ftPChar},	/* for now */
     /* fix this: make count-but-treat as OTHER mask @?@ @?@ */
-    { "Set-Cookie:",        HDR_SET_COOKIE,      ftPChar },
-    { "Upgrade",           HDR_UPGRADE,         ftPChar }, /* for now */
-    { "Warning",           HDR_WARNING,         ftPChar }, /* for now */
-    { "WWW-Authenticate",  HDR_WWW_AUTHENTICATE,ftPChar },
-    { "Proxy-Connection",  HDR_PROXY_KEEPALIVE, ftInt },   /* true/false */
-    { "Other:",            HDR_OTHER,           ftPExtField } /* ':' will not allow matches */
+    {"Set-Cookie:", HDR_SET_COOKIE, ftPChar},
+    {"Upgrade", HDR_UPGRADE, ftPChar},	/* for now */
+    {"Warning", HDR_WARNING, ftPChar},	/* for now */
+    {"WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftPChar},
+    {"Proxy-Connection", HDR_PROXY_KEEPALIVE, ftInt},	/* true/false */
+    {"Other:", HDR_OTHER, ftPExtField}	/* ':' will not allow matches */
 };
 
 /* this table is used for parsing server cache control header */
-static field_attrs_t SccAttrs[] = {
-    { "public",            SCC_PUBLIC },
-    { "private",           SCC_PRIVATE },
-    { "no-cache",          SCC_NO_CACHE },
-    { "no-store",          SCC_NO_STORE },
-    { "no-transform",      SCC_NO_TRANSFORM },
-    { "must-revalidate",   SCC_MUST_REVALIDATE },
-    { "proxy-revalidate",  SCC_PROXY_REVALIDATE },
-    { "max-age",           SCC_MAX_AGE }
+static field_attrs_t SccAttrs[] =
+{
+    {"public", SCC_PUBLIC},
+    {"private", SCC_PRIVATE},
+    {"no-cache", SCC_NO_CACHE},
+    {"no-store", SCC_NO_STORE},
+    {"no-transform", SCC_NO_TRANSFORM},
+    {"must-revalidate", SCC_MUST_REVALIDATE},
+    {"proxy-revalidate", SCC_PROXY_REVALIDATE},
+    {"max-age", SCC_MAX_AGE}
 };
 
 /*
@@ -176,50 +178,54 @@ static field_attrs_t SccAttrs[] = {
  * draft-ietf-http-v11-spec-rev-01.txt. Headers that are currently not
  * recognized, are commented out.
  */
-static int ListHeadersMask = 0; /* set run-time using  ListHeaders */
-static http_hdr_type ListHeaders[] = {
-    HDR_ACCEPT, 
+static int ListHeadersMask = 0;	/* set run-time using  ListHeaders */
+static http_hdr_type ListHeaders[] =
+{
+    HDR_ACCEPT,
     /* HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE, */
     /* HDR_ACCEPT_RANGES, */
     /* HDR_ALLOW, */
     HDR_CACHE_CONTROL, HDR_CONNECTION,
-    HDR_CONTENT_ENCODING, 
+    HDR_CONTENT_ENCODING,
     /* HDR_CONTENT_LANGUAGE,  HDR_IF_MATCH, HDR_IF_NONE_MATCH,
-       HDR_PRAGMA, HDR_TRANSFER_ENCODING, */
-    HDR_UPGRADE, /* HDR_VARY, */
+     * HDR_PRAGMA, HDR_TRANSFER_ENCODING, */
+    HDR_UPGRADE,		/* HDR_VARY, */
     /* HDR_VIA, HDR_WARNING, */
-    HDR_WWW_AUTHENTICATE, 
+    HDR_WWW_AUTHENTICATE,
     /* HDR_EXPECT, HDR_TE, HDR_TRAILER */
 };
 
-static int ReplyHeadersMask = 0; /* set run-time using ReplyHeaders */
-static http_hdr_type ReplyHeaders[] = {
+static int ReplyHeadersMask = 0;	/* set run-time using ReplyHeaders */
+static http_hdr_type ReplyHeaders[] =
+{
     HDR_ACCEPT, HDR_AGE, HDR_CACHE_CONTROL, HDR_CONTENT_LENGTH,
-    HDR_CONTENT_MD5,  HDR_CONTENT_TYPE, HDR_DATE, HDR_ETAG, HDR_EXPIRES,
+    HDR_CONTENT_MD5, HDR_CONTENT_TYPE, HDR_DATE, HDR_ETAG, HDR_EXPIRES,
     HDR_LAST_MODIFIED, HDR_LOCATION, HDR_MAX_FORWARDS, HDR_PUBLIC, HDR_RETRY_AFTER,
     HDR_SET_COOKIE, HDR_UPGRADE, HDR_WARNING, HDR_PROXY_KEEPALIVE, HDR_OTHER
 };
 
-static int RequestHeadersMask = 0; /* set run-time using RequestHeaders */
-static http_hdr_type RequestHeaders[] = {
+static int RequestHeadersMask = 0;	/* set run-time using RequestHeaders */
+static http_hdr_type RequestHeaders[] =
+{
     HDR_OTHER
 };
 
 /* when first field is added, this is how much entries we allocate */
 #define INIT_FIELDS_PER_HEADER 8
 
 /* recycle bin for short strings (32KB total only) */
-static const size_t shortStrSize = 32; /* max size of a recyclable string */
-static const size_t shortStrPoolCount = (32*1024)/32; /* sync this with shortStrSize */
+static const size_t shortStrSize = 32;	/* max size of a recyclable string */
+static const size_t shortStrPoolCount = (32 * 1024) / 32;	/* sync this with shortStrSize */
 static MemPool *shortStrings = NULL;
 
 /* header accounting */
-static HttpHeaderStat HttpHeaderStats[] = {
-    { "reply" },
-    { "request" },
-    { "all" }
+static HttpHeaderStat HttpHeaderStats[] =
+{
+    {"reply"},
+    {"request"},
+    {"all"}
 };
-static int HttpHeaderStatCount = sizeof(HttpHeaderStats)/sizeof(*HttpHeaderStats);
+static int HttpHeaderStatCount = sizeof(HttpHeaderStats) / sizeof(*HttpHeaderStats);
 
 /* global counters */
 static StatCount HeaderParsedCount = 0;
@@ -239,52 +245,52 @@ static StatSize longStrHighWaterSize = 0;
 
 #define assert_eid(id) assert((id) >= 0 && (id) < HDR_ENUM_END)
 
-static void httpHeaderInitAttrTable(field_attrs_t *table, int count);
+static void httpHeaderInitAttrTable(field_attrs_t * table, int count);
 static int httpHeaderCalcMask(const int *enums, int count);
-static void httpHeaderStatInit(HttpHeaderStat *hs, const char *label);
-
-static HttpHeaderEntry *httpHeaderGetEntry(const HttpHeader *hdr, HttpHeaderPos *pos);
-static void httpHeaderDelAt(HttpHeader *hdr, HttpHeaderPos pos);
-static void httpHeaderAddParsedEntry(HttpHeader *hdr, HttpHeaderEntry *e);
-static void httpHeaderAddNewEntry(HttpHeader *hdr, const HttpHeaderEntry *e);
-static void httpHeaderSet(HttpHeader *hdr, http_hdr_type id, const field_store value);
-static void httpHeaderSyncMasks(HttpHeader *hdr, const HttpHeaderEntry *e, int add);
-static int httpHeaderIdByName(const char *name, int name_len, const field_attrs_t *attrs, int end, int mask);
-static void httpHeaderGrow(HttpHeader *hdr);
-
-static void httpHeaderEntryInit(HttpHeaderEntry *e, http_hdr_type id, field_store field);
-static void httpHeaderEntryClean(HttpHeaderEntry *e);
-static int httpHeaderEntryParseInit(HttpHeaderEntry *e, const char *field_start, const char *field_end, int mask);
-static int httpHeaderEntryParseExtFieldInit(HttpHeaderEntry *e, int id, const HttpHeaderExtField *f);
-static int httpHeaderEntryParseByTypeInit(HttpHeaderEntry *e, int id, const HttpHeaderExtField *f);
-static HttpHeaderEntry httpHeaderEntryClone(const HttpHeaderEntry *e);
-static void httpHeaderEntryPackInto(const HttpHeaderEntry *e, Packer *p);
-static void httpHeaderEntryPackByType(const HttpHeaderEntry *e, Packer *p);
-static void httpHeaderEntryJoinWith(HttpHeaderEntry *e, const HttpHeaderEntry *newe);
-static int httpHeaderEntryIsValid(const HttpHeaderEntry *e);
-static const char *httpHeaderEntryName(const HttpHeaderEntry *e);
-
-static void httpHeaderFieldInit(field_store *field);
+static void httpHeaderStatInit(HttpHeaderStat * hs, const char *label);
+
+static HttpHeaderEntry *httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos);
+static void httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos);
+static void httpHeaderAddParsedEntry(HttpHeader * hdr, HttpHeaderEntry * e);
+static void httpHeaderAddNewEntry(HttpHeader * hdr, const HttpHeaderEntry * e);
+static void httpHeaderSet(HttpHeader * hdr, http_hdr_type id, const field_store value);
+static void httpHeaderSyncMasks(HttpHeader * hdr, const HttpHeaderEntry * e, int add);
+static int httpHeaderIdByName(const char *name, int name_len, const field_attrs_t * attrs, int end, int mask);
+static void httpHeaderGrow(HttpHeader * hdr);
+
+static void httpHeaderEntryInit(HttpHeaderEntry * e, http_hdr_type id, field_store field);
+static void httpHeaderEntryClean(HttpHeaderEntry * e);
+static int httpHeaderEntryParseInit(HttpHeaderEntry * e, const char *field_start, const char *field_end, int mask);
+static int httpHeaderEntryParseExtFieldInit(HttpHeaderEntry * e, int id, const HttpHeaderExtField * f);
+static int httpHeaderEntryParseByTypeInit(HttpHeaderEntry * e, int id, const HttpHeaderExtField * f);
+static HttpHeaderEntry httpHeaderEntryClone(const HttpHeaderEntry * e);
+static void httpHeaderEntryPackInto(const HttpHeaderEntry * e, Packer * p);
+static void httpHeaderEntryPackByType(const HttpHeaderEntry * e, Packer * p);
+static void httpHeaderEntryJoinWith(HttpHeaderEntry * e, const HttpHeaderEntry * newe);
+static int httpHeaderEntryIsValid(const HttpHeaderEntry * e);
+static const char *httpHeaderEntryName(const HttpHeaderEntry * e);
+
+static void httpHeaderFieldInit(field_store * field);
 static field_store httpHeaderFieldDup(field_type type, field_store value);
 static field_store httpHeaderFieldBadValue(field_type type);
 
 static HttpScc *httpSccCreate();
 static HttpScc *httpSccParseCreate(const char *str);
-static void httpSccParseInit(HttpScc *scc, const char *str);
-static void httpSccDestroy(HttpScc *scc);
-static HttpScc *httpSccDup(HttpScc *scc);
-static void httpSccUpdateStats(const HttpScc *scc, StatHist *hist);
+static void httpSccParseInit(HttpScc * scc, const char *str);
+static void httpSccDestroy(HttpScc * scc);
+static HttpScc *httpSccDup(HttpScc * scc);
+static void httpSccUpdateStats(const HttpScc * scc, StatHist * hist);
 
-static void httpSccPackValueInto(HttpScc *scc, Packer *p);
-static void httpSccJoinWith(HttpScc *scc, HttpScc *new_scc);
+static void httpSccPackValueInto(HttpScc * scc, Packer * p);
+static void httpSccJoinWith(HttpScc * scc, HttpScc * new_scc);
 
 static HttpHeaderExtField *httpHeaderExtFieldCreate(const char *name, const char *value);
 static HttpHeaderExtField *httpHeaderExtFieldParseCreate(const char *field_start, const char *field_end);
-static void httpHeaderExtFieldDestroy(HttpHeaderExtField *f);
-static HttpHeaderExtField *httpHeaderExtFieldDup(HttpHeaderExtField *f);
+static void httpHeaderExtFieldDestroy(HttpHeaderExtField * f);
+static HttpHeaderExtField *httpHeaderExtFieldDup(HttpHeaderExtField * f);
 
-static void httpHeaderStatDump(const HttpHeaderStat *hs, StoreEntry *e);
-static void shortStringStatDump(StoreEntry *e);
+static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
+static void shortStringStatDump(StoreEntry * e);
 
 static char *dupShortStr(const char *str);
 static char *dupShortBuf(const char *str, size_t len);
@@ -313,62 +319,62 @@ httpHeaderInitModule()
 {
     int i;
     /* paranoid check if smbd put a big object into field_store */
-    assert(sizeof(field_store) == sizeof(char*));
+    assert(sizeof(field_store) == sizeof(char *));
     /* have to force removal of const here */
-    httpHeaderInitAttrTable((field_attrs_t *)Headers, countof(Headers));
-    httpHeaderInitAttrTable((field_attrs_t *)SccAttrs, countof(SccAttrs));
+    httpHeaderInitAttrTable((field_attrs_t *) Headers, countof(Headers));
+    httpHeaderInitAttrTable((field_attrs_t *) SccAttrs, countof(SccAttrs));
     /* create masks */
-    ListHeadersMask = httpHeaderCalcMask((const int*)ListHeaders, countof(ListHeaders));
-    ReplyHeadersMask = httpHeaderCalcMask((const int*)ReplyHeaders, countof(ReplyHeaders));
-    RequestHeadersMask = httpHeaderCalcMask((const int*)RequestHeaders, countof(RequestHeaders));
+    ListHeadersMask = httpHeaderCalcMask((const int *) ListHeaders, countof(ListHeaders));
+    ReplyHeadersMask = httpHeaderCalcMask((const int *) ReplyHeaders, countof(ReplyHeaders));
+    RequestHeadersMask = httpHeaderCalcMask((const int *) RequestHeaders, countof(RequestHeaders));
     /* create a pool of short strings @?@ we never destroy it! */
-    shortStrings = memPoolCreate(shortStrPoolCount, shortStrPoolCount/10, shortStrSize, "shortStr");
+    shortStrings = memPoolCreate(shortStrPoolCount, shortStrPoolCount / 10, shortStrSize, "shortStr");
     /* init header stats */
     for (i = 0; i < HttpHeaderStatCount; i++)
-	httpHeaderStatInit(HttpHeaderStats+i, HttpHeaderStats[i].label);
+	httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
     cachemgrRegister("http_headers",
 	"HTTP Header Statistics", httpHeaderStoreReport, 0);
 }
 
 static void
-httpHeaderInitAttrTable(field_attrs_t *table, int count)
+httpHeaderInitAttrTable(field_attrs_t * table, int count)
 {
     int i;
     assert(table);
-    assert(count > 1); /* to protect from buggy "countof" implementations */
+    assert(count > 1);		/* to protect from buggy "countof" implementations */
 
     /* reorder so that .id becomes an index */
     for (i = 0; i < count;) {
 	const int id = table[i].id;
-	assert(id >= 0 && id < count); /* sanity check */
-	assert(id >= i);    /* entries prior to i have been indexed already */
-	if (id != i) { /* out of order */
+	assert(id >= 0 && id < count);	/* sanity check */
+	assert(id >= i);	/* entries prior to i have been indexed already */
+	if (id != i) {		/* out of order */
 	    const field_attrs_t fa = table[id];
-	    assert(fa.id != id);  /* avoid endless loops */
-	    table[id] = table[i]; /* swap */
+	    assert(fa.id != id);	/* avoid endless loops */
+	    table[id] = table[i];	/* swap */
 	    table[i] = fa;
 	} else
-	    i++; /* make progress */
+	    i++;		/* make progress */
     }
 
     /* calculate name lengths and init stats */
     for (i = 0; i < count; ++i) {
 	assert(table[i].name);
 	table[i].name_len = strlen(table[i].name);
-	debug(55,5) ("hdr table entry[%d]: %s (%d)\n", i, table[i].name, table[i].name_len);
+	debug(55, 5) ("hdr table entry[%d]: %s (%d)\n", i, table[i].name, table[i].name_len);
 	assert(table[i].name_len);
 	/* init stats */
 	memset(&table[i].stat, 0, sizeof(table[i].stat));
     }
 }
 
 static void
-httpHeaderStatInit(HttpHeaderStat *hs, const char *label)
+httpHeaderStatInit(HttpHeaderStat * hs, const char *label)
 {
     assert(hs);
     assert(label);
     hs->label = label;
-    statHistEnumInit(&hs->hdrUCountDistr, 32); /* not a real enum */
+    statHistEnumInit(&hs->hdrUCountDistr, 32);	/* not a real enum */
     statHistEnumInit(&hs->fieldTypeDistr, HDR_ENUM_END);
     statHistEnumInit(&hs->ccTypeDistr, SCC_ENUM_END);
 }
@@ -380,11 +386,11 @@ httpHeaderCalcMask(const int *enums, int count)
     int i;
     int mask = 0;
     assert(enums);
-    assert(count < sizeof(int)*8); /* check for overflow */
+    assert(count < sizeof(int) * 8);	/* check for overflow */
 
     for (i = 0; i < count; ++i) {
-	assert(enums[i] < sizeof(int)*8); /* check for overflow again */
-	assert(!EBIT_TEST(mask,enums[i])); /* check for duplicates */
+	assert(enums[i] < sizeof(int) * 8);	/* check for overflow again */
+	assert(!EBIT_TEST(mask, enums[i]));	/* check for duplicates */
 	EBIT_SET(mask, enums[i]);
     }
     return mask;
@@ -407,14 +413,14 @@ httpHeaderCreate()
 
 /* "create" for non-alloc objects; also used by real Create */
 void
-httpHeaderInit(HttpHeader *hdr)
+httpHeaderInit(HttpHeader * hdr)
 {
     assert(hdr);
     memset(hdr, 0, sizeof(*hdr));
 }
 
 void
-httpHeaderClean(HttpHeader *hdr)
+httpHeaderClean(HttpHeader * hdr)
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
@@ -437,21 +443,21 @@ httpHeaderClean(HttpHeader *hdr)
 }
 
 void
-httpHeaderDestroy(HttpHeader *hdr)
+httpHeaderDestroy(HttpHeader * hdr)
 {
     httpHeaderClean(hdr);
     xfree(hdr);
 }
 
 /* create a copy of self */
 HttpHeader *
-httpHeaderClone(HttpHeader *hdr)
+httpHeaderClone(HttpHeader * hdr)
 {
     HttpHeader *clone = httpHeaderCreate();
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
 
-    debug(55,7) ("cloning hdr: %p -> %p\n", hdr, clone);
+    debug(55, 7) ("cloning hdr: %p -> %p\n", hdr, clone);
 
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
 	HttpHeaderEntry e_clone = httpHeaderEntryClone(e);
@@ -463,7 +469,8 @@ httpHeaderClone(HttpHeader *hdr)
 
 /* just handy in parsing: resets and returns false */
 static int
-httpHeaderReset(HttpHeader *hdr) {
+httpHeaderReset(HttpHeader * hdr)
+{
     httpHeaderClean(hdr);
     httpHeaderInit(hdr);
     return 0;
@@ -479,23 +486,23 @@ httpHeaderReset(HttpHeader *hdr) {
  * additional storage, I guess.
  */
 int
-httpHeaderParse(HttpHeader *hdr, const char *header_start, const char *header_end)
+httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_end)
 {
     const char *field_start = header_start;
     HttpHeaderEntry e;
     int mask = 0;
 
     assert(hdr);
     assert(header_start && header_end);
-    debug(55,7) ("parsing hdr: (%p) '%s'\n...\n", hdr, getStringPrefix(header_start));
+    debug(55, 7) ("parsing hdr: (%p) '%s'\n...\n", hdr, getStringPrefix(header_start));
     /* select appropriate field mask */
-    mask = (/* fix this @?@ @?@ */ 1 ) ? ReplyHeadersMask : RequestHeadersMask;
+    mask = ( /* fix this @?@ @?@ */ 1) ? ReplyHeadersMask : RequestHeadersMask;
     /* commonn format headers are "<name>:[ws]<value>" lines delimited by <CRLF> */
     while (field_start < header_end) {
 	const char *field_end = field_start + strcspn(field_start, "\r\n");
-	/*tmp_debug(here) ("found end of field: %d\n", (int)*field_end);*/
-	if (!*field_end) 
-	    return httpHeaderReset(hdr); /* missing <CRLF> */
+	/*tmp_debug(here) ("found end of field: %d\n", (int)*field_end); */
+	if (!*field_end)
+	    return httpHeaderReset(hdr);	/* missing <CRLF> */
 	/*
 	 * If we fail to parse a field, we ignore that field. We also could
 	 * claim that the whole header is invalid. The latter is safer, but less
@@ -513,23 +520,25 @@ httpHeaderParse(HttpHeader *hdr, const char *header_start, const char *header_en
 	 */
 	field_start = field_end;
 	/* skip CRLF */
-	if (*field_start == '\r') field_start++;
-	if (*field_start == '\n') field_start++;
+	if (*field_start == '\r')
+	    field_start++;
+	if (*field_start == '\n')
+	    field_start++;
     }
-    return 1; /* even if no fields where found, they could be optional! */
+    return 1;			/* even if no fields where found, they could be optional! */
 }
 
 /*
  * packs all the entries into the buffer, 
  * returns number of bytes packed including terminating '\0'
  */
 void
-httpHeaderPackInto(const HttpHeader *hdr, Packer *p)
+httpHeaderPackInto(const HttpHeader * hdr, Packer * p)
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     const HttpHeaderEntry *e;
     assert(hdr && p);
-    debug(55,7) ("packing hdr: (%p)\n", hdr);
+    debug(55, 7) ("packing hdr: (%p)\n", hdr);
     /* pack all entries one by one */
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
 	httpHeaderEntryPackInto(e, p);
@@ -538,20 +547,20 @@ httpHeaderPackInto(const HttpHeader *hdr, Packer *p)
 
 /* returns next valid entry */
 static HttpHeaderEntry *
-httpHeaderGetEntry(const HttpHeader *hdr, HttpHeaderPos *pos)
+httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
 {
     assert(hdr && pos);
     assert(*pos >= HttpHeaderInitPos && *pos < hdr->capacity);
     tmp_debug(here) ("searching next e in hdr %p from %d\n", hdr, *pos);
     for ((*pos)++; *pos < hdr->ucount; (*pos)++) {
 	HttpHeaderEntry *e = hdr->entries + *pos;
-    	if (httpHeaderEntryIsValid(e)) {
-	    debug(55,8)("%p returning entry: %s at %d\n", 
+	if (httpHeaderEntryIsValid(e)) {
+	    debug(55, 8) ("%p returning entry: %s at %d\n",
 		hdr, httpHeaderEntryName(e), *pos);
-    	    return e;
+	    return e;
 	}
     }
-    debug(55,8) ("no more entries in hdr %p\n", hdr);
+    debug(55, 8) ("no more entries in hdr %p\n", hdr);
     return NULL;
 }
 
@@ -561,7 +570,7 @@ httpHeaderGetEntry(const HttpHeader *hdr, HttpHeaderPos *pos)
  * ask for HDR_OTHER entries since there could be more than one.
  */
 static HttpHeaderEntry *
-httpHeaderFindEntry(const HttpHeader *hdr, http_hdr_type id, HttpHeaderPos *pos)
+httpHeaderFindEntry(const HttpHeader * hdr, http_hdr_type id, HttpHeaderPos * pos)
 {
     HttpHeaderPos p;
     HttpHeaderEntry *e;
@@ -570,15 +579,16 @@ httpHeaderFindEntry(const HttpHeader *hdr, http_hdr_type id, HttpHeaderPos *pos)
     assert_eid(id);
     assert(id != HDR_OTHER);
 
-    debug(55,8) ("finding entry %d in hdr %p\n", id, hdr);
+    debug(55, 8) ("finding entry %d in hdr %p\n", id, hdr);
     /* check mask first @?@ @?@ remove double checking and asserts when done */
     is_absent = (id != HDR_OTHER && !EBIT_TEST(hdr->emask, id));
-    if (!pos) pos = &p;
+    if (!pos)
+	pos = &p;
     *pos = HttpHeaderInitPos;
     while ((e = httpHeaderGetEntry(hdr, pos))) {
-    	if (e->id == id) {
+	if (e->id == id) {
 	    assert(!is_absent);
-    	    return e;
+	    return e;
 	}
     }
     assert(!EBIT_TEST(hdr->emask, id));
@@ -589,16 +599,16 @@ httpHeaderFindEntry(const HttpHeader *hdr, http_hdr_type id, HttpHeaderPos *pos)
  * deletes all field(s) with a given name if any, returns #fields deleted; 
  * used to process Connection: header and delete fields in "paranoid" setup
  */
-int 
-httpHeaderDelFields(HttpHeader *hdr, const char *name)
+int
+httpHeaderDelFields(HttpHeader * hdr, const char *name)
 {
     int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
 
-    debug(55,7) ("deleting '%s' fields in hdr %p\n", name, hdr);
+    debug(55, 7) ("deleting '%s' fields in hdr %p\n", name, hdr);
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-    	if (!strcmp(httpHeaderEntryName(e), name)) {
+	if (!strcmp(httpHeaderEntryName(e), name)) {
 	    httpHeaderDelAt(hdr, pos);
 	    count++;
 	}
@@ -611,13 +621,13 @@ httpHeaderDelFields(HttpHeader *hdr, const char *name)
  * possible to iterate(search) and delete fields at the same time
  */
 static void
-httpHeaderDelAt(HttpHeader *hdr, HttpHeaderPos pos)
+httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos)
 {
     HttpHeaderEntry *e;
     assert(hdr);
     assert(pos >= 0 && pos < hdr->ucount);
     e = hdr->entries + pos;
-    debug(55,7) ("%p deling entry at %d: id: %d (%p:%p)\n", 
+    debug(55, 7) ("%p deling entry at %d: id: %d (%p:%p)\n",
 	hdr, pos, e->id, hdr->entries, e);
     /* sync masks */
     httpHeaderSyncMasks(hdr, e, 0);
@@ -632,14 +642,14 @@ httpHeaderDelAt(HttpHeader *hdr, HttpHeaderPos pos)
  * this function returns.
  */
 static void
-httpHeaderAddParsedEntry(HttpHeader *hdr, HttpHeaderEntry *e)
+httpHeaderAddParsedEntry(HttpHeader * hdr, HttpHeaderEntry * e)
 {
     HttpHeaderEntry *olde;
     assert(hdr);
     assert(e);
     assert_eid(e->id);
 
-    debug(55,7) ("%p adding parsed entry %d\n", hdr, e->id);
+    debug(55, 7) ("%p adding parsed entry %d\n", hdr, e->id);
 
     /* there is no good reason to add invalid entries */
     if (!httpHeaderEntryIsValid(e))
@@ -657,7 +667,7 @@ httpHeaderAddParsedEntry(HttpHeader *hdr, HttpHeaderEntry *e)
     } else {
 	/* actual add */
 	httpHeaderAddNewEntry(hdr, e);
-	debug(55,6) ("%p done adding parsed entry %d (%s)\n", hdr, e->id, httpHeaderEntryName(e));
+	debug(55, 6) ("%p done adding parsed entry %d (%s)\n", hdr, e->id, httpHeaderEntryName(e));
     }
 }
 
@@ -666,11 +676,11 @@ httpHeaderAddParsedEntry(HttpHeader *hdr, HttpHeaderEntry *e)
  * copy e value, thus, e can point to a tmp variable (but e->field is not dupped!)
  */
 static void
-httpHeaderAddNewEntry(HttpHeader *hdr, const HttpHeaderEntry *e)
+httpHeaderAddNewEntry(HttpHeader * hdr, const HttpHeaderEntry * e)
 {
     assert(hdr && e);
-    debug(55,8) ("%p adding entry: %d at %d, (%p:%p)\n", 
-	hdr, e->id, hdr->ucount, 
+    debug(55, 8) ("%p adding entry: %d at %d, (%p:%p)\n",
+	hdr, e->id, hdr->ucount,
 	hdr->entries, hdr->entries + hdr->ucount);
     if (!hdr->ucount)
 	HeaderParsedCount++;
@@ -681,14 +691,14 @@ httpHeaderAddNewEntry(HttpHeader *hdr, const HttpHeaderEntry *e)
     httpHeaderSyncMasks(hdr, e, 1);
 }
 
-#if 0 /* save for parts */
+#if 0				/* save for parts */
 /*
  * Splits list field and appends all entries separately; 
  * Warning: This is internal function, never call this directly, 
  *          only for httpHeaderAddField use.
  */
 static void
-httpHeaderAddListField(HttpHeader *hdr, HttpHeaderField *fld)
+httpHeaderAddListField(HttpHeader * hdr, HttpHeaderField * fld)
 {
     const char *v;
     assert(hdr);
@@ -700,10 +710,11 @@ httpHeaderAddListField(HttpHeader *hdr, HttpHeaderField *fld)
      */
     /* we got a fld.value that is a list of values separated by ',' */
     v = strtok(fld->value, ",");
-    httpHeaderAddSingleField(hdr, fld); /* first strtok() did its job! */
+    httpHeaderAddSingleField(hdr, fld);		/* first strtok() did its job! */
     while ((v = strtok(NULL, ","))) {
 	/* ltrim and skip empty fields */
-	while (isspace(*v) || *v == ',') v++;
+	while (isspace(*v) || *v == ',')
+	    v++;
 	if (*v)
 	    httpHeaderAddSingleField(hdr, httpHeaderFieldCreate(fld->name, v));
     }
@@ -715,12 +726,13 @@ httpHeaderAddListField(HttpHeader *hdr, HttpHeaderField *fld)
  */
 
 /* test if a field is present */
-int httpHeaderHas(const HttpHeader *hdr, http_hdr_type id)
+int
+httpHeaderHas(const HttpHeader * hdr, http_hdr_type id)
 {
     assert(hdr);
     assert_eid(id);
     assert(id != HDR_OTHER);
-    debug(55,7) ("%p lookup for %d\n", hdr, id);
+    debug(55, 7) ("%p lookup for %d\n", hdr, id);
     return EBIT_TEST(hdr->emask, id);
 
 #ifdef SLOW_BUT_SAFE
@@ -729,11 +741,12 @@ int httpHeaderHas(const HttpHeader *hdr, http_hdr_type id)
 }
 
 /* delete a field if any */
-void httpHeaderDel(HttpHeader *hdr, http_hdr_type id)
+void
+httpHeaderDel(HttpHeader * hdr, http_hdr_type id)
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     assert(id != HDR_OTHER);
-    debug(55,8) ("%p del-by-id %d\n", hdr, id);
+    debug(55, 8) ("%p del-by-id %d\n", hdr, id);
     if (httpHeaderFindEntry(hdr, id, &pos)) {
 	httpHeaderDelAt(hdr, pos);
     }
@@ -745,15 +758,15 @@ void httpHeaderDel(HttpHeader *hdr, http_hdr_type id)
  * (if field is not present, it is added; otherwise, old content is destroyed).
  */
 static void
-httpHeaderSet(HttpHeader *hdr, http_hdr_type id, const field_store value)
+httpHeaderSet(HttpHeader * hdr, http_hdr_type id, const field_store value)
 {
     HttpHeaderPos pos;
     HttpHeaderEntry e;
     assert(hdr);
     assert_eid(id);
-    
-    debug(55,7) ("%p sets entry with id: %d\n", hdr, id);
-    if (httpHeaderFindEntry(hdr, id, &pos)) /* delete old entry */
+
+    debug(55, 7) ("%p sets entry with id: %d\n", hdr, id);
+    if (httpHeaderFindEntry(hdr, id, &pos))	/* delete old entry */
 	httpHeaderDelAt(hdr, pos);
 
     httpHeaderEntryInit(&e, id, httpHeaderFieldDup(Headers[id].type, value));
@@ -764,36 +777,37 @@ httpHeaderSet(HttpHeader *hdr, http_hdr_type id, const field_store value)
 }
 
 void
-httpHeaderSetInt(HttpHeader *hdr, http_hdr_type id, int number)
+httpHeaderSetInt(HttpHeader * hdr, http_hdr_type id, int number)
 {
     field_store value;
     assert_eid(id);
-    assert(Headers[id].type == ftInt); /* must be of an appropriatre type */
+    assert(Headers[id].type == ftInt);	/* must be of an appropriatre type */
     value.v_int = number;
     httpHeaderSet(hdr, id, value);
 }
 
 void
-httpHeaderSetTime(HttpHeader *hdr, http_hdr_type id, time_t time)
+httpHeaderSetTime(HttpHeader * hdr, http_hdr_type id, time_t time)
 {
     field_store value;
     assert_eid(id);
-    assert(Headers[id].type == ftDate_1123); /* must be of an appropriatre type */
+    assert(Headers[id].type == ftDate_1123);	/* must be of an appropriatre type */
     value.v_time = time;
     httpHeaderSet(hdr, id, value);
 }
+
 void
-httpHeaderSetStr(HttpHeader *hdr, http_hdr_type id, const char *str)
+httpHeaderSetStr(HttpHeader * hdr, http_hdr_type id, const char *str)
 {
     field_store value;
     assert_eid(id);
-    assert(Headers[id].type == ftPChar); /* must be of a string type */
+    assert(Headers[id].type == ftPChar);	/* must be of a string type */
     value.v_pcchar = str;
     httpHeaderSet(hdr, id, value);
 }
 
 void
-httpHeaderSetAuth(HttpHeader *hdr, const char *authScheme, const char *realm)
+httpHeaderSetAuth(HttpHeader * hdr, const char *authScheme, const char *realm)
 {
     MemBuf mb;
     assert(hdr && authScheme && realm);
@@ -805,56 +819,56 @@ httpHeaderSetAuth(HttpHeader *hdr, const char *authScheme, const char *realm)
 
 /* add extension header (these fields are not parsed/analyzed/joined, etc.) */
 void
-httpHeaderAddExt(HttpHeader *hdr, const char *name, const char* value)
+httpHeaderAddExt(HttpHeader * hdr, const char *name, const char *value)
 {
     HttpHeaderExtField *ext = httpHeaderExtFieldCreate(name, value);
     HttpHeaderEntry e;
 
-    debug(55,8) ("%p adds ext entry '%s:%s'\n", hdr, name, value);
+    debug(55, 8) ("%p adds ext entry '%s:%s'\n", hdr, name, value);
     httpHeaderEntryInit(&e, HDR_OTHER, ext);
     httpHeaderAddNewEntry(hdr, &e);
 }
 
 /* get a value of a field (not lvalue though) */
 field_store
-httpHeaderGet(const HttpHeader *hdr, http_hdr_type id)
+httpHeaderGet(const HttpHeader * hdr, http_hdr_type id)
 {
     HttpHeaderEntry *e;
     assert_eid(id);
-    assert(id != HDR_OTHER); /* there is no single value for HDR_OTHER */
+    assert(id != HDR_OTHER);	/* there is no single value for HDR_OTHER */
 
-    debug(55,7) ("%p get for id %d\n", hdr, id);
+    debug(55, 7) ("%p get for id %d\n", hdr, id);
     if ((e = httpHeaderFindEntry(hdr, id, NULL)))
 	return e->field;
     else
 	return httpHeaderFieldBadValue(Headers[id].type);
 }
 
 const char *
-httpHeaderGetStr(const HttpHeader *hdr, http_hdr_type id)
+httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id)
 {
     assert_eid(id);
-    assert(Headers[id].type == ftPChar); /* must be of an apropriate type */
+    assert(Headers[id].type == ftPChar);	/* must be of an apropriate type */
     return httpHeaderGet(hdr, id).v_pchar;
 }
 
 time_t
-httpHeaderGetTime(const HttpHeader *hdr, http_hdr_type id)
+httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id)
 {
     assert_eid(id);
-    assert(Headers[id].type == ftDate_1123); /* must be of an apropriate type */
+    assert(Headers[id].type == ftDate_1123);	/* must be of an apropriate type */
     return httpHeaderGet(hdr, id).v_time;
 }
 
 HttpScc *
-httpHeaderGetScc(const HttpHeader *hdr)
+httpHeaderGetScc(const HttpHeader * hdr)
 {
     return httpHeaderGet(hdr, HDR_CACHE_CONTROL).v_pscc;
 }
 
 /* updates header masks */
 static void
-httpHeaderSyncMasks(HttpHeader *hdr, const HttpHeaderEntry *e, int add)
+httpHeaderSyncMasks(HttpHeader * hdr, const HttpHeaderEntry * e, int add)
 {
     int isSet;
     assert(hdr && e);
@@ -870,15 +884,15 @@ httpHeaderSyncMasks(HttpHeader *hdr, const HttpHeaderEntry *e, int add)
 }
 
 static int
-httpHeaderIdByName(const char *name, int name_len, const field_attrs_t *attrs, int end, int mask)
+httpHeaderIdByName(const char *name, int name_len, const field_attrs_t * attrs, int end, int mask)
 {
     int i;
     for (i = 0; i < end; ++i) {
 	if (mask < 0 || EBIT_TEST(mask, i)) {
 	    if (name_len >= 0 && name_len != attrs[i].name_len)
 		continue;
-	    if (!strncasecmp(name, attrs[i].name, 
-		name_len < 0 ? attrs[i].name_len+1 : name_len))
+	    if (!strncasecmp(name, attrs[i].name,
+		    name_len < 0 ? attrs[i].name_len + 1 : name_len))
 		return i;
 	}
     }
@@ -887,29 +901,29 @@ httpHeaderIdByName(const char *name, int name_len, const field_attrs_t *attrs, i
 
 /* doubles the size of the fields index, starts with INIT_FIELDS_PER_HEADER */
 static void
-httpHeaderGrow(HttpHeader *hdr)
+httpHeaderGrow(HttpHeader * hdr)
 {
     int new_cap;
     int new_size;
     assert(hdr);
-    new_cap = (hdr->capacity) ? 2*hdr->capacity : INIT_FIELDS_PER_HEADER;
-    new_size = new_cap*sizeof(HttpHeaderEntry);
+    new_cap = (hdr->capacity) ? 2 * hdr->capacity : INIT_FIELDS_PER_HEADER;
+    new_size = new_cap * sizeof(HttpHeaderEntry);
 
-    debug(55,9) ("%p grow (%p) %d->%d\n", hdr, hdr->entries, hdr->capacity, new_cap);
+    debug(55, 9) ("%p grow (%p) %d->%d\n", hdr, hdr->entries, hdr->capacity, new_cap);
     hdr->entries = hdr->entries ?
 	xrealloc(hdr->entries, new_size) :
 	xmalloc(new_size);
-    memset(hdr->entries+hdr->capacity, 0, (new_cap-hdr->capacity)*sizeof(HttpHeaderEntry));
+    memset(hdr->entries + hdr->capacity, 0, (new_cap - hdr->capacity) * sizeof(HttpHeaderEntry));
     hdr->capacity = new_cap;
-    debug(55,9) ("%p grew (%p)\n", hdr, hdr->entries);
+    debug(55, 9) ("%p grew (%p)\n", hdr, hdr->entries);
 }
 
 /*
  * HttpHeaderEntry
  */
 
 static void
-httpHeaderEntryInit(HttpHeaderEntry *e, http_hdr_type id, field_store field)
+httpHeaderEntryInit(HttpHeaderEntry * e, http_hdr_type id, field_store field)
 {
     assert(e);
     assert_eid(id);
@@ -919,29 +933,30 @@ httpHeaderEntryInit(HttpHeaderEntry *e, http_hdr_type id, field_store field)
 }
 
 static void
-httpHeaderEntryClean(HttpHeaderEntry *e) {
+httpHeaderEntryClean(HttpHeaderEntry * e)
+{
     assert(e);
     assert_eid(e->id);
     /* type-based cleanup */
     switch (Headers[e->id].type) {
-	case ftInvalid:
-	case ftInt:
-	case ftDate_1123:
-            /* no special cleaning is necessary */
-	    break;
-	case ftPChar:
-	    freeShortString(e->field.v_pchar);
-	    break;
-	case ftPSCC:
-	    if (e->field.v_pscc)
-		httpSccDestroy(e->field.v_pscc);
-	    break;
-	case ftPExtField:
-	    if (e->field.v_pefield)
-		httpHeaderExtFieldDestroy(e->field.v_pefield);
-	    break;
-	default:
-	    assert(0); /* somebody added a new type? */
+    case ftInvalid:
+    case ftInt:
+    case ftDate_1123:
+	/* no special cleaning is necessary */
+	break;
+    case ftPChar:
+	freeShortString(e->field.v_pchar);
+	break;
+    case ftPSCC:
+	if (e->field.v_pscc)
+	    httpSccDestroy(e->field.v_pscc);
+	break;
+    case ftPExtField:
+	if (e->field.v_pefield)
+	    httpHeaderExtFieldDestroy(e->field.v_pefield);
+	break;
+    default:
+	assert(0);		/* somebody added a new type? */
     }
     Headers[e->id].stat.aliveCount--;
     /* we have to do that so entry will be _invlaid_ */
@@ -951,7 +966,7 @@ httpHeaderEntryClean(HttpHeaderEntry *e) {
 
 /* parses and inits header entry, returns true on success */
 static int
-httpHeaderEntryParseInit(HttpHeaderEntry *e, const char *field_start, const char *field_end, int mask)
+httpHeaderEntryParseInit(HttpHeaderEntry * e, const char *field_start, const char *field_end, int mask)
 {
     HttpHeaderExtField *f;
     int id;
@@ -963,7 +978,7 @@ httpHeaderEntryParseInit(HttpHeaderEntry *e, const char *field_start, const char
     e->field.v_pchar = NULL;
     /* first assume it is just an extension field */
     f = httpHeaderExtFieldParseCreate(field_start, field_end);
-    if (!f) /* total parsing failure */
+    if (!f)			/* total parsing failure */
 	return 0;
     id = httpHeaderIdByName(f->name, -1, Headers, countof(Headers), mask);
     if (id < 0)
@@ -982,7 +997,7 @@ httpHeaderEntryParseInit(HttpHeaderEntry *e, const char *field_start, const char
 }
 
 static int
-httpHeaderEntryParseExtFieldInit(HttpHeaderEntry *e, int id, const HttpHeaderExtField *f)
+httpHeaderEntryParseExtFieldInit(HttpHeaderEntry * e, int id, const HttpHeaderExtField * f)
 {
     assert(e && f);
     assert_eid(id);
@@ -992,43 +1007,43 @@ httpHeaderEntryParseExtFieldInit(HttpHeaderEntry *e, int id, const HttpHeaderExt
      * then parse using value type if needed
      */
     switch (id) {
-	case HDR_PROXY_KEEPALIVE:
-	    /*  we treat Proxy-Connection as "keep alive" only if it says so */
-	    httpHeaderEntryInit(e, id, (int)!strcasecmp(f->value, "Keep-Alive"));
-	    break;
-	default:
-	    /* if we got here, it is something that can be parsed based on value type */
-	    if (!httpHeaderEntryParseByTypeInit(e, id, f))
-		return 0;
+    case HDR_PROXY_KEEPALIVE:
+	/*  we treat Proxy-Connection as "keep alive" only if it says so */
+	httpHeaderEntryInit(e, id, (int) !strcasecmp(f->value, "Keep-Alive"));
+	break;
+    default:
+	/* if we got here, it is something that can be parsed based on value type */
+	if (!httpHeaderEntryParseByTypeInit(e, id, f))
+	    return 0;
     }
     /* parsing was successful, post-processing maybe required */
     switch (id) {
-	case HDR_CONTENT_TYPE: {
+    case HDR_CONTENT_TYPE:{
 	    /* cut off "; parameter" from Content-Type @?@ why? */
 	    const int l = strcspn(e->field.v_pchar, ";\t ");
 	    if (l > 0)
 		e->field.v_pchar[l] = '\0';
 	    break;
 	}
-	case HDR_EXPIRES:
-	    /*
-	     * The HTTP/1.0 specs says that robust implementations should
-	     * consider bad or malformed Expires header as equivalent to
-	     * "expires immediately."
-	     */
-	    if (!httpHeaderEntryIsValid(e))
-		e->field.v_time = squid_curtime;
-	    /*
-	     * real expiration value also depends on max-age too, but it is not
-	     * of our business (HttpReply should handle it)
-	     */
-	    break;
+    case HDR_EXPIRES:
+	/*
+	 * The HTTP/1.0 specs says that robust implementations should
+	 * consider bad or malformed Expires header as equivalent to
+	 * "expires immediately."
+	 */
+	if (!httpHeaderEntryIsValid(e))
+	    e->field.v_time = squid_curtime;
+	/*
+	 * real expiration value also depends on max-age too, but it is not
+	 * of our business (HttpReply should handle it)
+	 */
+	break;
     }
     return 1;
 }
 
 static int
-httpHeaderEntryParseByTypeInit(HttpHeaderEntry *e, int id, const HttpHeaderExtField *f)
+httpHeaderEntryParseByTypeInit(HttpHeaderEntry * e, int id, const HttpHeaderExtField * f)
 {
     int type;
     field_store field;
@@ -1037,45 +1052,45 @@ httpHeaderEntryParseByTypeInit(HttpHeaderEntry *e, int id, const HttpHeaderExtFi
     type = Headers[id].type;
 
     httpHeaderFieldInit(&field);
-    switch(type) {
-	case ftInt:
-	    field.v_int = atoi(f->value);
-	    if (!field.v_int && !isdigit(*f->value)) {
-		debug(55, 1) ("cannot parse an int header field: id: %d, field: '%s: %s'\n",
-		    id, f->name, f->value);
-		Headers[id].stat.errCount++;
-		return 0;
-	    }
-	    break;
+    switch (type) {
+    case ftInt:
+	field.v_int = atoi(f->value);
+	if (!field.v_int && !isdigit(*f->value)) {
+	    debug(55, 1) ("cannot parse an int header field: id: %d, field: '%s: %s'\n",
+		id, f->name, f->value);
+	    Headers[id].stat.errCount++;
+	    return 0;
+	}
+	break;
 
-	case ftPChar:
-	    field.v_pchar = dupShortStr(f->value);
-	    break;
+    case ftPChar:
+	field.v_pchar = dupShortStr(f->value);
+	break;
 
-	case ftDate_1123:
-	    field.v_time = parse_rfc1123(f->value);
-	    if (field.v_time <= 0)
-		Headers[id].stat.errCount++;
-	    /*
-	     * if parse_rfc1123 fails we fall through anyway so upper levels
-	     * will notice invalid date
-	     */
-	    break;
-
-	case ftPSCC:
-	    field.v_pscc = httpSccParseCreate(f->value);
-	    if (!field.v_pscc) {
-		debug(55, 0) ("failed to parse scc hdr: id: %d, field: '%s: %s'\n",
-		    id, f->name, f->value);
-		Headers[id].stat.errCount++;
-		return 0;
-	    }
-	    break;
+    case ftDate_1123:
+	field.v_time = parse_rfc1123(f->value);
+	if (field.v_time <= 0)
+	    Headers[id].stat.errCount++;
+	/*
+	 * if parse_rfc1123 fails we fall through anyway so upper levels
+	 * will notice invalid date
+	 */
+	break;
+
+    case ftPSCC:
+	field.v_pscc = httpSccParseCreate(f->value);
+	if (!field.v_pscc) {
+	    debug(55, 0) ("failed to parse scc hdr: id: %d, field: '%s: %s'\n",
+		id, f->name, f->value);
+	    Headers[id].stat.errCount++;
+	    return 0;
+	}
+	break;
 
-	default:
-	    debug(55, 0) ("something went wrong with hdr field type analysis: id: %d, type: %d, field: '%s: %s'\n", 
-		id, type, f->name, f->value);
-	    assert(0);
+    default:
+	debug(55, 0) ("something went wrong with hdr field type analysis: id: %d, type: %d, field: '%s: %s'\n",
+	    id, type, f->name, f->value);
+	assert(0);
     }
     /* success, do actual init */
     httpHeaderEntryInit(e, id, field);
@@ -1084,7 +1099,7 @@ httpHeaderEntryParseByTypeInit(HttpHeaderEntry *e, int id, const HttpHeaderExtFi
 
 
 static HttpHeaderEntry
-httpHeaderEntryClone(const HttpHeaderEntry *e)
+httpHeaderEntryClone(const HttpHeaderEntry * e)
 {
     HttpHeaderEntry clone;
     assert(e);
@@ -1095,7 +1110,7 @@ httpHeaderEntryClone(const HttpHeaderEntry *e)
 }
 
 static void
-httpHeaderEntryPackInto(const HttpHeaderEntry *e, Packer *p)
+httpHeaderEntryPackInto(const HttpHeaderEntry * e, Packer * p)
 {
     assert(e && p);
 
@@ -1107,108 +1122,108 @@ httpHeaderEntryPackInto(const HttpHeaderEntry *e, Packer *p)
      * then swap using value type
      */
     switch (e->id) {
-	case HDR_PROXY_KEEPALIVE:
-	    packerPrintf(p, "%s", "Keep-Alive");
-	    break;
-	default:
-	    /* if we got here, it is something that can be swap based on value type */
-	    httpHeaderEntryPackByType(e, p);
+    case HDR_PROXY_KEEPALIVE:
+	packerPrintf(p, "%s", "Keep-Alive");
+	break;
+    default:
+	/* if we got here, it is something that can be swap based on value type */
+	httpHeaderEntryPackByType(e, p);
     }
     /* add CRLF */
     packerPrintf(p, "%s", "\r\n");
 }
 
 static void
-httpHeaderEntryPackByType(const HttpHeaderEntry *e, Packer *p)
+httpHeaderEntryPackByType(const HttpHeaderEntry * e, Packer * p)
 {
     field_type type;
     assert(e && p);
     assert_eid(e->id);
-    type = Headers[e->id].type;    
-    switch(type) {
-	case ftInt:
-	    packerPrintf(p, "%d", e->field.v_int);
-	    break;
-	case ftPChar:
-	    packerPrintf(p, "%s", e->field.v_pchar);
-	    break;
-	case ftDate_1123:
-	    packerPrintf(p, "%s", mkrfc1123(e->field.v_time));
-	    break;
-	case ftPSCC:
-	    httpSccPackValueInto(e->field.v_pscc, p);
-	    break;
-	case ftPExtField:
-	    packerPrintf(p, "%s", e->field.v_pefield->value);
-	    break;
-	default:
-	    assert(0 && type); /* pack for invalid/unknown type */
+    type = Headers[e->id].type;
+    switch (type) {
+    case ftInt:
+	packerPrintf(p, "%d", e->field.v_int);
+	break;
+    case ftPChar:
+	packerPrintf(p, "%s", e->field.v_pchar);
+	break;
+    case ftDate_1123:
+	packerPrintf(p, "%s", mkrfc1123(e->field.v_time));
+	break;
+    case ftPSCC:
+	httpSccPackValueInto(e->field.v_pscc, p);
+	break;
+    case ftPExtField:
+	packerPrintf(p, "%s", e->field.v_pefield->value);
+	break;
+    default:
+	assert(0 && type);	/* pack for invalid/unknown type */
     }
 }
 
 static void
-httpHeaderEntryJoinWith(HttpHeaderEntry *e, const HttpHeaderEntry *newe)
+httpHeaderEntryJoinWith(HttpHeaderEntry * e, const HttpHeaderEntry * newe)
 {
     field_type type;
     assert(e && newe);
     assert_eid(e->id);
     assert(e->id == newe->id);
 
-    debug(55,6) ("joining entry (%p) with (%p)\n", e, newe);
+    debug(55, 6) ("joining entry (%p) with (%p)\n", e, newe);
     /* type-based join */
     type = Headers[e->id].type;
-    switch(type) {
-	case ftPChar:
-	    e->field.v_pchar = appShortStr(e->field.v_pchar, newe->field.v_pchar);
-	    break;
-	case ftPSCC:
-	    httpSccJoinWith(e->field.v_pscc, newe->field.v_pscc);
-	    break;
-	default:
-	    debug(55, 0) ("join for invalid/unknown type: id: %d, type: %d\n", e->id, type);
-	    assert(0);
+    switch (type) {
+    case ftPChar:
+	e->field.v_pchar = appShortStr(e->field.v_pchar, newe->field.v_pchar);
+	break;
+    case ftPSCC:
+	httpSccJoinWith(e->field.v_pscc, newe->field.v_pscc);
+	break;
+    default:
+	debug(55, 0) ("join for invalid/unknown type: id: %d, type: %d\n", e->id, type);
+	assert(0);
     }
 }
 
 
 static int
-httpHeaderEntryIsValid(const HttpHeaderEntry *e)
+httpHeaderEntryIsValid(const HttpHeaderEntry * e)
 {
     assert(e);
     if (e->id == -1)
 	return 0;
     assert_eid(e->id);
     /* type-based analysis */
-    switch(Headers[e->id].type) {
-	case ftInvalid:
-	    return 0;
-	case ftInt:
-	    return e->field.v_int >= 0;
-	case ftPChar:
-	    return e->field.v_pchar != NULL;
-	    break;
-	case ftDate_1123:
-	    return e->field.v_time >= 0;
-	    break;
-	case ftPSCC:
-	    return e->field.v_pscc != NULL;
-	    break;
-	case ftPExtField:
-	    return e->field.v_pefield != NULL;
-	    break;
-	default:
-	    assert(0); /* query for invalid/unknown type */
+    switch (Headers[e->id].type) {
+    case ftInvalid:
+	return 0;
+    case ftInt:
+	return e->field.v_int >= 0;
+    case ftPChar:
+	return e->field.v_pchar != NULL;
+	break;
+    case ftDate_1123:
+	return e->field.v_time >= 0;
+	break;
+    case ftPSCC:
+	return e->field.v_pscc != NULL;
+	break;
+    case ftPExtField:
+	return e->field.v_pefield != NULL;
+	break;
+    default:
+	assert(0);		/* query for invalid/unknown type */
     }
-    return 0; /* not reached */
+    return 0;			/* not reached */
 }
 
 static const char *
-httpHeaderEntryName(const HttpHeaderEntry *e)
+httpHeaderEntryName(const HttpHeaderEntry * e)
 {
     assert(e);
     assert_eid(e->id);
 
-    return (e->id == HDR_OTHER) ? 
+    return (e->id == HDR_OTHER) ?
 	e->field.v_pefield->name : Headers[e->id].name;
 }
 
@@ -1217,7 +1232,7 @@ httpHeaderEntryName(const HttpHeaderEntry *e)
  */
 
 static void
-httpHeaderFieldInit(field_store *field)
+httpHeaderFieldInit(field_store * field)
 {
     assert(field);
     memset(field, 0, sizeof(field_store));
@@ -1227,25 +1242,25 @@ static field_store
 httpHeaderFieldDup(field_type type, field_store value)
 {
     /* type based duplication */
-    switch(type) {
-	case ftInt:
-	    return value.v_int;
-	case ftPChar:
-	    return dupShortStr(value.v_pchar);
-	    break;
-	case ftDate_1123:
-	    return value.v_time;
-	    break;
-	case ftPSCC:
-	    return httpSccDup(value.v_pscc);
-	    break;
-	case ftPExtField:
-	    return httpHeaderExtFieldDup(value.v_pefield);
-	    break;
-	default:
-	    assert(0); /* dup of invalid/unknown type */
+    switch (type) {
+    case ftInt:
+	return value.v_int;
+    case ftPChar:
+	return dupShortStr(value.v_pchar);
+	break;
+    case ftDate_1123:
+	return value.v_time;
+	break;
+    case ftPSCC:
+	return httpSccDup(value.v_pscc);
+	break;
+    case ftPExtField:
+	return httpHeaderExtFieldDup(value.v_pefield);
+	break;
+    default:
+	assert(0);		/* dup of invalid/unknown type */
     }
-    return NULL; /* not reached */
+    return NULL;		/* not reached */
 }
 
 /*
@@ -1255,19 +1270,19 @@ httpHeaderFieldDup(field_type type, field_store value)
 static field_store
 httpHeaderFieldBadValue(field_type type)
 {
-    switch(type) {
-	case ftInt:
-	case ftDate_1123:
-	    return -1;
-	case ftPChar:
-	case ftPSCC:
-	case ftPExtField:
-	    return NULL;
-	case ftInvalid:
-	default:
-	    assert(0); /* query for invalid/unknown type */
+    switch (type) {
+    case ftInt:
+    case ftDate_1123:
+	return -1;
+    case ftPChar:
+    case ftPSCC:
+    case ftPExtField:
+	return NULL;
+    case ftInvalid:
+    default:
+	assert(0);		/* query for invalid/unknown type */
     }
-    return NULL; /* not reached */
+    return NULL;		/* not reached */
 }
 
 /*
@@ -1282,7 +1297,7 @@ httpSccCreate()
     return scc;
 }
 
-/* creates an scc object from a 0-terminating string*/
+/* creates an scc object from a 0-terminating string */
 static HttpScc *
 httpSccParseCreate(const char *str)
 {
@@ -1293,20 +1308,20 @@ httpSccParseCreate(const char *str)
 
 /* parses a 0-terminating string and inits scc */
 static void
-httpSccParseInit(HttpScc *scc, const char *str)
+httpSccParseInit(HttpScc * scc, const char *str)
 {
     const char *item;
-    const char *p; /* '=' parameter */
+    const char *p;		/* '=' parameter */
     const char *pos = NULL;
     int type;
     int ilen;
     assert(scc && str);
 
     CcPasredCount++;
     /* iterate through comma separated list */
-    while(strListGetItem(str, ',', &item, &ilen, &pos)) {
+    while (strListGetItem(str, ',', &item, &ilen, &pos)) {
 	/* strip '=' statements @?@ */
-	if ((p = strchr(item, '=')) && (p-item < ilen))
+	if ((p = strchr(item, '=')) && (p - item < ilen))
 	    ilen = p++ - item;
 	/* find type */
 	type = httpHeaderIdByName(item, ilen,
@@ -1321,35 +1336,35 @@ httpSccParseInit(HttpScc *scc, const char *str)
 	    continue;
 	}
 	/* update mask */
-        EBIT_SET(scc->mask, type);
+	EBIT_SET(scc->mask, type);
 	/* post-processing special cases */
 	switch (type) {
-	    case SCC_MAX_AGE:
-		if (p)
-		    scc->max_age = (time_t) atoi(p);
-		if (scc->max_age < 0) {
-		    debug(55, 0) ("scc: invalid max-age specs near '%s'\n", item);
-		    scc->max_age = -1;
-		    EBIT_CLR(scc->mask, type);
-		}
-		break;
-	    default:
-		/* note that we ignore most of '=' specs @?@ */
-		break;
+	case SCC_MAX_AGE:
+	    if (p)
+		scc->max_age = (time_t) atoi(p);
+	    if (scc->max_age < 0) {
+		debug(55, 0) ("scc: invalid max-age specs near '%s'\n", item);
+		scc->max_age = -1;
+		EBIT_CLR(scc->mask, type);
+	    }
+	    break;
+	default:
+	    /* note that we ignore most of '=' specs @?@ */
+	    break;
 	}
     }
     return;
 }
 
 static void
-httpSccDestroy(HttpScc *scc)
+httpSccDestroy(HttpScc * scc)
 {
     assert(scc);
     memFree(MEM_HTTP_SCC, scc);
 }
 
 static HttpScc *
-httpSccDup(HttpScc *scc)
+httpSccDup(HttpScc * scc)
 {
     HttpScc *dup;
     assert(scc);
@@ -1360,13 +1375,13 @@ httpSccDup(HttpScc *scc)
 }
 
 static void
-httpSccPackValueInto(HttpScc *scc, Packer *p)
+httpSccPackValueInto(HttpScc * scc, Packer * p)
 {
     http_scc_type flag;
     int pcount = 0;
     assert(scc && p);
     if (scc->max_age >= 0) {
-        packerPrintf(p, "max-age=%d", scc->max_age);
+	packerPrintf(p, "max-age=%d", scc->max_age);
 	pcount++;
     }
     for (flag = 0; flag < SCC_ENUM_END; flag++) {
@@ -1378,7 +1393,7 @@ httpSccPackValueInto(HttpScc *scc, Packer *p)
 }
 
 static void
-httpSccJoinWith(HttpScc *scc, HttpScc *new_scc)
+httpSccJoinWith(HttpScc * scc, HttpScc * new_scc)
 {
     assert(scc && new_scc);
     if (scc->max_age < 0)
@@ -1387,7 +1402,7 @@ httpSccJoinWith(HttpScc *scc, HttpScc *new_scc)
 }
 
 static void
-httpSccUpdateStats(const HttpScc *scc, StatHist *hist)
+httpSccUpdateStats(const HttpScc * scc, StatHist * hist)
 {
     http_scc_type c;
     assert(scc);
@@ -1419,14 +1434,14 @@ httpHeaderExtFieldParseCreate(const char *field_start, const char *field_end)
     const char *value_start;
     /* note: value_end == field_end */
 
-    if (!name_end || name_end <= field_start || name_end > field_end) 
+    if (!name_end || name_end <= field_start || name_end > field_end)
 	return NULL;
 
-    tmp_debug(here) ("got field len: %d\n", field_end-field_start);
+    tmp_debug(here) ("got field len: %d\n", field_end - field_start);
 
-    value_start = name_end + 1; /* skip ':' */
+    value_start = name_end + 1;	/* skip ':' */
     /* skip white space */
-    while (value_start < field_end && isspace(*value_start)) 
+    while (value_start < field_end && isspace(*value_start))
 	value_start++;
 
     /* cut off "; parameter" from Content-Type @?@ why? */
@@ -1435,16 +1450,15 @@ httpHeaderExtFieldParseCreate(const char *field_start, const char *field_end)
 	if (l > 0 && value_start + l < field_end)
 	    field_end = value_start + l;
     }
-
     f = xcalloc(1, sizeof(HttpHeaderExtField));
-    f->name = dupShortBuf(field_start, name_end-field_start);
-    f->value = dupShortBuf(value_start, field_end-value_start);
-    debug(55,8) ("got field: '%s: %s' (%p)\n", f->name, f->value, f);
+    f->name = dupShortBuf(field_start, name_end - field_start);
+    f->value = dupShortBuf(value_start, field_end - value_start);
+    debug(55, 8) ("got field: '%s: %s' (%p)\n", f->name, f->value, f);
     return f;
 }
 
 static void
-httpHeaderExtFieldDestroy(HttpHeaderExtField *f)
+httpHeaderExtFieldDestroy(HttpHeaderExtField * f)
 {
     assert(f);
     freeShortString(f->name);
@@ -1453,7 +1467,7 @@ httpHeaderExtFieldDestroy(HttpHeaderExtField *f)
 }
 
 static HttpHeaderExtField *
-httpHeaderExtFieldDup(HttpHeaderExtField *f)
+httpHeaderExtFieldDup(HttpHeaderExtField * f)
 {
     assert(f);
     return httpHeaderExtFieldCreate(f->name, f->value);
@@ -1491,12 +1505,12 @@ httpHeaderFldsPerHdrDumper(StoreEntry * sentry, int idx, double val, double size
 {
     if (count)
 	storeAppendPrintf(sentry, "%2d\t %5d\t %5d\t %6.2lf\n",
-	    idx, ((int)(val+size)), count, xpercent(count, HeaderEntryParsedCount));
+	    idx, ((int) (val + size)), count, xpercent(count, HeaderEntryParsedCount));
 }
 
 
 static void
-httpHeaderStatDump(const HttpHeaderStat *hs, StoreEntry *e)
+httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
 {
     assert(hs && e);
 
@@ -1517,26 +1531,26 @@ httpHeaderStatDump(const HttpHeaderStat *hs, StoreEntry *e)
 }
 
 static void
-shortStringStatDump(StoreEntry *e)
+shortStringStatDump(StoreEntry * e)
 {
     storeAppendPrintf(e, "<h3>Short String Stats</h3>\n<p>%s\n</p>\n",
 	memPoolReport(shortStrings));
     storeAppendPrintf(e, "<br><h3>Long String Stats</h3>\n");
     storeAppendPrintf(e, "\talive: %3d (%5.1lf KB) high-water:  %3d (%5.1lf KB)\n",
-	longStrAliveCount, (double)longStrAliveSize/1024.,
-	longStrHighWaterCount, (double)longStrHighWaterSize/1024.);
+	longStrAliveCount, (double) longStrAliveSize / 1024.,
+	longStrHighWaterCount, (double) longStrHighWaterSize / 1024.);
 }
 
 void
-httpHeaderStoreReport(StoreEntry *e)
+httpHeaderStoreReport(StoreEntry * e)
 {
     int i;
     http_hdr_type ht;
     assert(e);
 
     /* fix this (including summing for totals) for req hdrs @?@ */
-    for (i = 0; i < 1 /*HttpHeaderStatCount*/; i++) {
-	httpHeaderStatDump(HttpHeaderStats+i, e);
+    for (i = 0; i < 1 /*HttpHeaderStatCount */ ; i++) {
+	httpHeaderStatDump(HttpHeaderStats + i, e);
 	storeAppendPrintf(e, "%s\n", "<br>");
     }
     storeAppendPrintf(e, "%s\n", "<hr size=1 noshade>");
@@ -1545,10 +1559,10 @@ httpHeaderStoreReport(StoreEntry *e)
     storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\t %6s\n",
 	"id", "name", "#alive", "%err", "%repeat");
     for (ht = 0; ht < HDR_ENUM_END; ht++) {
-	field_attrs_t *f = Headers+ht;
+	field_attrs_t *f = Headers + ht;
 	storeAppendPrintf(e, "%2d\t %-20s\t %5d\t %6.3lf\t %6.3lf\n",
 	    f->id, f->name, f->stat.aliveCount,
-	    xpercent(f->stat.errCount, f->stat.parsCount), 
+	    xpercent(f->stat.errCount, f->stat.parsCount),
 	    xpercent(f->stat.repCount, f->stat.parsCount));
     }
     storeAppendPrintf(e, "%s\n", "<hr size=1 noshade>");
@@ -1576,16 +1590,16 @@ dupShortBuf(const char *str, size_t len)
     buf = allocShortBuf(len + 1);
     assert(buf);
     if (len)
-	xmemcpy(buf, str, len); /* may not have terminating 0 */
-    buf[len] = '\0'; /* terminate */
-    debug(55,9) ("dupped short buf[%d] (%p): '%s'\n", len+1, buf, buf);
+	xmemcpy(buf, str, len);	/* may not have terminating 0 */
+    buf[len] = '\0';		/* terminate */
+    debug(55, 9) ("dupped short buf[%d] (%p): '%s'\n", len + 1, buf, buf);
     return buf;
 }
 
 static char *
 appShortStr(char *str, const char *app_str)
 {
-    const size_t size = strlen(str)+strlen(app_str)+1;
+    const size_t size = strlen(str) + strlen(app_str) + 1;
     char *buf = allocShortBuf(size);
     snprintf(buf, size, "%s, %s", str, app_str);
     freeShortString(str);
@@ -1616,10 +1630,10 @@ freeShortString(char *str)
 {
     assert(shortStrings);
     if (str) {
-	const size_t sz = strlen(str)+1;
-        debug(55,9) ("freeing short str of size %d (max: %d) '%s' (%p)\n", sz, shortStrings->obj_size, str, str);
+	const size_t sz = strlen(str) + 1;
+	debug(55, 9) ("freeing short str of size %d (max: %d) '%s' (%p)\n", sz, shortStrings->obj_size, str, str);
 	if (sz > shortStrings->obj_size) {
-	    debug(55,9) ("LONG short string[%d>%d]: %s\n", sz, shortStrings->obj_size, str);
+	    debug(55, 9) ("LONG short string[%d>%d]: %s\n", sz, shortStrings->obj_size, str);
 	    assert(longStrAliveCount);
 	    xfree(str);
 	    longStrAliveCount--;
@@ -1647,7 +1661,7 @@ strListGetItem(const char *str, char del, const char **item, int *ilen, const ch
     size_t len;
     assert(str && item && pos);
     if (*pos)
-	if (!**pos)   /* end of string */
+	if (!**pos)		/* end of string */
 	    return 0;
 	else
 	    (*pos)++;
@@ -1656,22 +1670,24 @@ strListGetItem(const char *str, char del, const char **item, int *ilen, const ch
 
     /* skip leading ws (ltrim) */
     *pos += xcountws(*pos);
-    *item = *pos; /* remember item's start */
+    *item = *pos;		/* remember item's start */
     /* find next delimiter */
     *pos = strchr(*item, del);
-    if (!*pos) /* last item */
+    if (!*pos)			/* last item */
 	*pos = *item + strlen(*item);
-    len = *pos - *item; /* *pos points to del or '\0' */
+    len = *pos - *item;		/* *pos points to del or '\0' */
     /* rtrim */
-    while (len > 0 && isspace((*item)[len-1])) len--;
+    while (len > 0 && isspace((*item)[len - 1]))
+	len--;
     if (ilen)
 	*ilen = len;
     return len > 0;
 }
 
 /* handy to printf prefixes of potentially very long buffers */
 static const char *
-getStringPrefix(const char *str) {
+getStringPrefix(const char *str)
+{
 #define SHORT_PREFIX_SIZE 256
     LOCAL_ARRAY(char, buf, SHORT_PREFIX_SIZE);
     xstrncpy(buf, str, SHORT_PREFIX_SIZE);
@@ -1682,13 +1698,12 @@ getStringPrefix(const char *str) {
 static double
 xpercent(double part, double whole)
 {
-    return xdiv(100*part, whole);
+    return xdiv(100 * part, whole);
 }
 
 /* safe division */
 static double
 xdiv(double nom, double denom)
 {
-    return (denom != 0.0) ? nom/denom : -1;
+    return (denom != 0.0) ? nom / denom : -1;
 }
-
@@ -1,5 +1,6 @@
+
 /*
- * $Id: HttpReply.cc,v 1.5 1998/02/26 08:10:54 rousskov Exp $
+ * $Id: HttpReply.cc,v 1.6 1998/02/26 18:00:31 wessels Exp $
  *
  * DEBUG: section 58    HTTP Reply (Response)
  * AUTHOR: Alex Rousskov
@@ -37,9 +38,9 @@
 /* local constants */
 
 /* local routines */
-static void httpReplyDoDestroy(HttpReply *rep);
-static int httpReplyParseStep(HttpReply *rep, const char *parse_start, int atEnd);
-static int httpReplyParseError(HttpReply *rep);
+static void httpReplyDoDestroy(HttpReply * rep);
+static int httpReplyParseStep(HttpReply * rep, const char *parse_start, int atEnd);
+static int httpReplyParseError(HttpReply * rep);
 static int httpReplyIsolateStart(const char **parse_start, const char **blk_start, const char **blk_end);
 static int httpReplyIsolateHeaders(const char **parse_start, const char **blk_start, const char **blk_end);
 
@@ -54,7 +55,7 @@ httpReplyCreate()
 }
 
 void
-httpReplyInit(HttpReply *rep)
+httpReplyInit(HttpReply * rep)
 {
     assert(rep);
     rep->hdr_sz = 0;
@@ -65,7 +66,7 @@ httpReplyInit(HttpReply *rep)
 }
 
 void
-httpReplyClean(HttpReply *rep)
+httpReplyClean(HttpReply * rep)
 {
     assert(rep);
     httpBodyClean(&rep->body);
@@ -74,7 +75,7 @@ httpReplyClean(HttpReply *rep)
 }
 
 void
-httpReplyDestroy(HttpReply *rep)
+httpReplyDestroy(HttpReply * rep)
 {
     assert(rep);
     tmp_debug(here) ("destroying rep: %p\n", rep);
@@ -83,15 +84,15 @@ httpReplyDestroy(HttpReply *rep)
 }
 
 void
-httpReplyReset(HttpReply *rep)
+httpReplyReset(HttpReply * rep)
 {
     httpReplyClean(rep);
     httpReplyInit(rep);
 }
 
 /* absorb: copy the contents of a new reply to the old one, destroy new one */
 void
-httpReplyAbsorb(HttpReply *rep, HttpReply *new_rep)
+httpReplyAbsorb(HttpReply * rep, HttpReply * new_rep)
 {
     assert(rep && new_rep);
     httpReplyClean(rep);
@@ -102,7 +103,7 @@ httpReplyAbsorb(HttpReply *rep, HttpReply *new_rep)
 
 /* parses a buffer that may not be 0-terminated */
 int
-httpReplyParse(HttpReply *rep, const char *buf)
+httpReplyParse(HttpReply * rep, const char *buf)
 {
     /*
      * this extra buffer/copy will be eliminated when headers become meta-data
@@ -121,7 +122,7 @@ httpReplyParse(HttpReply *rep, const char *buf)
 }
 
 void
-httpReplyPackInto(const HttpReply *rep, Packer *p)
+httpReplyPackInto(const HttpReply * rep, Packer * p)
 {
     assert(rep);
     httpStatusLinePackInto(&rep->sline, p);
@@ -132,7 +133,7 @@ httpReplyPackInto(const HttpReply *rep, Packer *p)
 
 /* create memBuf, create mem-based packer,  pack, destroy packer, return MemBuf */
 MemBuf
-httpReplyPack(const HttpReply *rep)
+httpReplyPack(const HttpReply * rep)
 {
     MemBuf mb;
     Packer p;
@@ -147,7 +148,7 @@ httpReplyPack(const HttpReply *rep)
 
 /* swap: create swap-based packer, pack, destroy packer */
 void
-httpReplySwapOut(const HttpReply *rep, StoreEntry *e)
+httpReplySwapOut(const HttpReply * rep, StoreEntry * e)
 {
     Packer p;
     assert(rep && e);
@@ -170,7 +171,7 @@ httpPackedReply(double ver, http_status status, const char *ctype,
 }
 
 MemBuf
-httpPacked304Reply(const HttpReply *rep)
+httpPacked304Reply(const HttpReply * rep)
 {
     MemBuf mb;
     assert(rep);
@@ -180,7 +181,7 @@ httpPacked304Reply(const HttpReply *rep)
 
     if (httpHeaderHas(&rep->hdr, HDR_DATE))
 	memBufPrintf(&mb, "Date: %s\r\n", mkrfc1123(
-	    httpHeaderGetTime(&rep->hdr, HDR_DATE)));
+		httpHeaderGetTime(&rep->hdr, HDR_DATE)));
 
     if (httpHeaderHas(&rep->hdr, HDR_CONTENT_TYPE))
 	memBufPrintf(&mb, "Content-type: %s\r\n",
@@ -192,35 +193,35 @@ httpPacked304Reply(const HttpReply *rep)
 
     if (httpHeaderHas(&rep->hdr, HDR_EXPIRES))
 	memBufPrintf(&mb, "Expires: %s\r\n", mkrfc1123(
-	    httpHeaderGetTime(&rep->hdr, HDR_EXPIRES)));
+		httpHeaderGetTime(&rep->hdr, HDR_EXPIRES)));
 
     if (httpHeaderHas(&rep->hdr, HDR_LAST_MODIFIED))
 	memBufPrintf(&mb, "Last-modified: %s\r\n", mkrfc1123(
-	    httpHeaderGetTime(&rep->hdr, HDR_LAST_MODIFIED)));
+		httpHeaderGetTime(&rep->hdr, HDR_LAST_MODIFIED)));
 
     memBufAppend(&mb, "\r\n", 2);
     return mb;
 }
 
 void
-httpReplySetHeaders(HttpReply *reply, double ver, http_status status, const char *reason,
+httpReplySetHeaders(HttpReply * reply, double ver, http_status status, const char *reason,
     const char *ctype, int clen, time_t lmt, time_t expires)
 {
     HttpHeader *hdr;
     assert(reply);
     httpStatusLineSet(&reply->sline, ver, status, reason);
     hdr = &reply->hdr;
     httpHeaderAddExt(hdr, "Server", full_appname_string);
-    httpHeaderAddExt(hdr, "MIME-Version", "1.0"); /* do we need this? @?@ */
+    httpHeaderAddExt(hdr, "MIME-Version", "1.0");	/* do we need this? @?@ */
     httpHeaderSetTime(hdr, HDR_DATE, squid_curtime);
     if (ctype)
 	httpHeaderSetStr(hdr, HDR_CONTENT_TYPE, ctype);
     if (clen > 0)
 	httpHeaderSetInt(hdr, HDR_CONTENT_LENGTH, clen);
     if (expires >= 0)
 	httpHeaderSetTime(hdr, HDR_EXPIRES, expires);
-    if (lmt > 0) /* this used to be lmt != 0 @?@ */
-  	httpHeaderSetTime(hdr, HDR_LAST_MODIFIED, lmt);
+    if (lmt > 0)		/* this used to be lmt != 0 @?@ */
+	httpHeaderSetTime(hdr, HDR_LAST_MODIFIED, lmt);
 }
 
 /*
@@ -242,9 +243,9 @@ httpReplySetHeaders(HttpReply *reply, double ver, http_status status, const char
  */
 
 void
-httpReplyUpdateOnNotModified(HttpReply *rep, HttpReply *freshRep)
+httpReplyUpdateOnNotModified(HttpReply * rep, HttpReply * freshRep)
 {
-#if 0 /* this is what we want: */
+#if 0				/* this is what we want: */
     rep->cache_control = freshRep->cache_control;
     rep->misc_headers = freshRep->misc_headers;
     if (freshRep->date > -1)
@@ -260,7 +261,7 @@ httpReplyUpdateOnNotModified(HttpReply *rep, HttpReply *freshRep)
     assert(rep && freshRep);
     /* save precious info */
     date = httpHeaderGetTime(&rep->hdr, HDR_DATE);
-    expires= httpReplyExpires(rep);
+    expires = httpReplyExpires(rep);
     lmt = httpHeaderGetTime(&rep->hdr, HDR_LAST_MODIFIED);
     /* clean old headers */
     httpHeaderClean(&rep->hdr);
@@ -276,43 +277,45 @@ httpReplyUpdateOnNotModified(HttpReply *rep, HttpReply *freshRep)
 }
 
 int
-httpReplyContentLen(const HttpReply *rep) {
+httpReplyContentLen(const HttpReply * rep)
+{
     assert(rep);
     return httpHeaderGet(&rep->hdr, HDR_CONTENT_LENGTH).v_int;
 }
 
 /* should we return "" or NULL if no content-type? Return NULL for now @?@ */
 const char *
-httpReplyContentType(const HttpReply *rep) {
+httpReplyContentType(const HttpReply * rep)
+{
     assert(rep);
     return httpHeaderGetStr(&rep->hdr, HDR_CONTENT_TYPE);
 }
 
 /* does it make sense to cache these computations ? @?@ */
 time_t
-httpReplyExpires(const HttpReply *rep)
+httpReplyExpires(const HttpReply * rep)
 {
     HttpScc *scc;
     time_t exp = -1;
     assert(rep);
     /* The max-age directive takes priority over Expires, check it first */
     scc = httpHeaderGetScc(&rep->hdr);
     if (scc)
-	exp = scc -> max_age;
+	exp = scc->max_age;
     if (exp < 0)
 	exp = httpHeaderGetTime(&rep->hdr, HDR_EXPIRES);
     return exp;
 }
 
 int
-httpReplyHasScc(const HttpReply *rep, http_scc_type type)
+httpReplyHasScc(const HttpReply * rep, http_scc_type type)
 {
     HttpScc *scc;
     assert(rep);
     assert(type >= 0 && type < SCC_ENUM_END);
 
     scc = httpHeaderGetScc(&rep->hdr);
-    return scc && /* scc header is present */
+    return scc &&		/* scc header is present */
 	EBIT_TEST(scc->mask, type);
 }
 
@@ -321,7 +324,8 @@ httpReplyHasScc(const HttpReply *rep, http_scc_type type)
 
 /* internal function used by Destroy and Absorb */
 static void
-httpReplyDoDestroy(HttpReply *rep) {
+httpReplyDoDestroy(HttpReply * rep)
+{
     memFree(MEM_HTTPREPLY, rep);
 }
 
@@ -333,7 +337,7 @@ httpReplyDoDestroy(HttpReply *rep) {
  *      -1 -- parse error
  */
 static int
-httpReplyParseStep(HttpReply *rep, const char *buf, int atEnd)
+httpReplyParseStep(HttpReply * rep, const char *buf, int atEnd)
 {
     const char *parse_start = buf;
     const char *blk_start, *blk_end;
@@ -351,9 +355,8 @@ httpReplyParseStep(HttpReply *rep, const char *buf, int atEnd)
 
 	*parse_end_ptr = parse_start;
 	rep->hdr_sz = *parse_end_ptr - buf;
-        rep->pstate++;
+	rep->pstate++;
     }
-    
     if (rep->pstate == psReadyToParseHeaders) {
 	if (!httpReplyIsolateHeaders(&parse_start, &blk_start, &blk_end))
 	    if (atEnd)
@@ -367,7 +370,6 @@ httpReplyParseStep(HttpReply *rep, const char *buf, int atEnd)
 	rep->hdr_sz = *parse_end_ptr - buf;
 	rep->pstate++;
     }
-
     /* could check here for a _small_ body that we could parse right away?? @?@ */
 
     return 1;
@@ -376,7 +378,7 @@ httpReplyParseStep(HttpReply *rep, const char *buf, int atEnd)
 
 /* handy: resets and returns -1 */
 static int
-httpReplyParseError(HttpReply *rep)
+httpReplyParseError(HttpReply * rep)
 {
     assert(rep);
     /* reset */
@@ -391,14 +393,14 @@ static int
 httpReplyIsolateStart(const char **parse_start, const char **blk_start, const char **blk_end)
 {
     int slen = strcspn(*parse_start, "\r\n");
-    if (!(*parse_start)[slen]) /* no CRLF found */
+    if (!(*parse_start)[slen])	/* no CRLF found */
 	return 0;
 
     *blk_start = *parse_start;
     *blk_end = *blk_start + slen;
-    if (**blk_end == '\r') /* CR */
+    if (**blk_end == '\r')	/* CR */
 	(*blk_end)++;
-    if (**blk_end == '\n') /* LF */
+    if (**blk_end == '\n')	/* LF */
 	(*blk_end)++;
 
     *parse_start = *blk_end;
@@ -415,12 +417,12 @@ httpReplyIsolateHeaders(const char **parse_start, const char **blk_start, const
     const char *end = NULL;
 
     if (p1 && p2)
-        end = p1 < p2 ? p1 : p2;
+	end = p1 < p2 ? p1 : p2;
     else
-        end = p1 ? p1 : p2;
+	end = p1 ? p1 : p2;
 
     if (end) {
-        *blk_start = *parse_start;
+	*blk_start = *parse_start;
 	*blk_end = end + 1;
 	*parse_start = end + (end == p1 ? 3 : 2);
     }
@@ -1,5 +1,5 @@
 /*
- * $Id: HttpStatusLine.cc,v 1.4 1998/02/26 08:10:55 rousskov Exp $
+ * $Id: HttpStatusLine.cc,v 1.5 1998/02/26 18:00:32 wessels Exp $
  *
  * DEBUG: section 57    HTTP Status-line
  * AUTHOR: Alex Rousskov
@@ -40,17 +40,21 @@ static const char *httpStatusString(http_status status);
 
 
 void
-httpStatusLineInit(HttpStatusLine *sline) {
+httpStatusLineInit(HttpStatusLine * sline)
+{
     httpStatusLineSet(sline, 0.0, 0, NULL);
 }
 
 void
-httpStatusLineClean(HttpStatusLine *sline) {
+httpStatusLineClean(HttpStatusLine * sline)
+{
     httpStatusLineSet(sline, 0.0, 500, NULL);
 }
 
 /* set values */
-void httpStatusLineSet(HttpStatusLine *sline, double version, http_status status, const char *reason) {
+void
+httpStatusLineSet(HttpStatusLine * sline, double version, http_status status, const char *reason)
+{
     assert(sline);
     sline->version = version;
     sline->status = status;
@@ -60,22 +64,23 @@ void httpStatusLineSet(HttpStatusLine *sline, double version, http_status status
 
 /* parse a 0-terminating buffer and fill internal structires; returns true on success */
 void
-httpStatusLinePackInto(const HttpStatusLine *sline, Packer *p)
+httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p)
 {
     assert(sline && p);
     tmp_debug(here) ("packing sline %p using %p:\n", sline, p);
     tmp_debug(here) (HttpStatusLineFormat, sline->version, sline->status,
 	sline->reason ? sline->reason : httpStatusString(sline->status));
     packerPrintf(p, HttpStatusLineFormat,
-	sline->version, sline->status, 
+	sline->version, sline->status,
 	sline->reason ? sline->reason : httpStatusString(sline->status));
 }
 
 /* pack fields using Packer */
 int
-httpStatusLineParse(HttpStatusLine *sline, const char *start, const char *end) {
+httpStatusLineParse(HttpStatusLine * sline, const char *start, const char *end)
+{
     assert(sline);
-    sline->status = HTTP_INVALID_HEADER; /* Squid header parsing error */
+    sline->status = HTTP_INVALID_HEADER;	/* Squid header parsing error */
     if (strncasecmp(start, "HTTP/", 5))
 	return 0;
     start += 5;
@@ -86,7 +91,7 @@ httpStatusLineParse(HttpStatusLine *sline, const char *start, const char *end) {
 	return 0;
     sline->status = atoi(++start);
     /* we ignore 'reason-phrase' */
-    return 1; /* success */
+    return 1;			/* success */
 }
 
 static const char *
@@ -96,7 +101,7 @@ httpStatusString(http_status status)
     const char *p = NULL;
     switch (status) {
     case 0:
-	p = "Init";  /* we init .status with code 0 */
+	p = "Init";		/* we init .status with code 0 */
 	break;
     case 100:
 	p = "Continue";
@@ -1,5 +1,5 @@
 /*
- * $Id: MemBuf.cc,v 1.4 1998/02/26 07:06:14 rousskov Exp $
+ * $Id: MemBuf.cc,v 1.5 1998/02/26 18:00:33 wessels Exp $
  *
  * DEBUG: section 59    auto-growing Memory Buffer with printf
  * AUTHOR: Alex Rousskov
@@ -33,64 +33,64 @@
  */
 
 /*
-    Rationale:
-    ----------
-
-    Here is how one would comm_write an object without MemBuffer:
-
-    {
-	-- allocate:
-	buf = malloc(big_enough);
-
-        -- "pack":
-	snprintf object(s) piece-by-piece constantly checking for overflows
-	    and maintaining (buf+offset);
-	...
-
-	-- write
-	comm_write(buf, free, ...);
-    }
-
-    The whole "packing" idea is quite messy: We are given a buffer of fixed
-    size and we have to check all the time that we still fit. Sounds logical.
-    However, what happens if we have more data? If we are lucky to be careful
-    to stop before we overrun any buffers, we still may have garbage (e.g.
-    half of ETag) in the buffer.
-
-    MemBuffer:
-    ----------
-
-    MemBuffer is a memory-resident buffer with printf()-like interface. It
-    hides all offest handling and overflow checking. Moreover, it has a
-    build-in control that no partial data has been written.
-
-    MemBuffer is designed to handle relatively small data. It starts with a
-    small buffer of configurable size to avoid allocating huge buffers all the
-    time.  MemBuffer doubles the buffer when needed. It assert()s that it will
-    not grow larger than a configurable limit. MemBuffer has virtually no
-    overhead (and can even reduce memory consumption) compared to old
-    "packing" approach.
-
-    MemBuffer eliminates both "packing" mess and truncated data:
-
-    {
-	-- setup
-	MemBuf buf;
-
-	-- required init with optional size tuning (see #defines for defaults)
-        memBufInit(&buf, initial-size, absolute-maximum);
-
-	-- "pack" (no need to handle offsets or check for overflows)
-	memBufPrintf(&buf, ...);
-	...
-
-	-- write
-	comm_write(buf.buf, memBufFreeFunc(&buf), ...);
-
-	-- *iff* you did not give the buffer away, free it yourself
-	-- memBufFree(&buf);
-    }
-*/
+ * Rationale:
+ * ----------
+ * 
+ * Here is how one would comm_write an object without MemBuffer:
+ * 
+ * {
+ * -- allocate:
+ * buf = malloc(big_enough);
+ * 
+ * -- "pack":
+ * snprintf object(s) piece-by-piece constantly checking for overflows
+ * and maintaining (buf+offset);
+ * ...
+ * 
+ * -- write
+ * comm_write(buf, free, ...);
+ * }
+ * 
+ * The whole "packing" idea is quite messy: We are given a buffer of fixed
+ * size and we have to check all the time that we still fit. Sounds logical.
+ * However, what happens if we have more data? If we are lucky to be careful
+ * to stop before we overrun any buffers, we still may have garbage (e.g.
+ * half of ETag) in the buffer.
+ * 
+ * MemBuffer:
+ * ----------
+ * 
+ * MemBuffer is a memory-resident buffer with printf()-like interface. It
+ * hides all offest handling and overflow checking. Moreover, it has a
+ * build-in control that no partial data has been written.
+ * 
+ * MemBuffer is designed to handle relatively small data. It starts with a
+ * small buffer of configurable size to avoid allocating huge buffers all the
+ * time.  MemBuffer doubles the buffer when needed. It assert()s that it will
+ * not grow larger than a configurable limit. MemBuffer has virtually no
+ * overhead (and can even reduce memory consumption) compared to old
+ * "packing" approach.
+ * 
+ * MemBuffer eliminates both "packing" mess and truncated data:
+ * 
+ * {
+ * -- setup
+ * MemBuf buf;
+ * 
+ * -- required init with optional size tuning (see #defines for defaults)
+ * memBufInit(&buf, initial-size, absolute-maximum);
+ * 
+ * -- "pack" (no need to handle offsets or check for overflows)
+ * memBufPrintf(&buf, ...);
+ * ...
+ * 
+ * -- write
+ * comm_write(buf.buf, memBufFreeFunc(&buf), ...);
+ * 
+ * -- *iff* you did not give the buffer away, free it yourself
+ * -- memBufFree(&buf);
+ * }
+ */
 
 
 #include "squid.h"
@@ -103,20 +103,20 @@
 
 
 /* local routines */
-static void memBufGrow(MemBuf *mb, mb_size_t min_cap);
+static void memBufGrow(MemBuf * mb, mb_size_t min_cap);
 
 
 /* init with defaults */
 void
-memBufDefInit(MemBuf *mb)
+memBufDefInit(MemBuf * mb)
 {
     memBufInit(mb, MEM_BUF_INIT_SIZE, MEM_BUF_MAX_SIZE);
 }
 
 
 /* init with specific sizes */
 void
-memBufInit(MemBuf *mb, mb_size_t szInit, mb_size_t szMax)
+memBufInit(MemBuf * mb, mb_size_t szInit, mb_size_t szMax)
 {
     assert(mb);
     assert(szInit > 0 && szMax > 0);
@@ -135,29 +135,29 @@ memBufInit(MemBuf *mb, mb_size_t szInit, mb_size_t szMax)
  * memBufFreeFunc
  */
 void
-memBufClean(MemBuf *mb)
+memBufClean(MemBuf * mb)
 {
-   assert(mb);
-   assert(mb->buf);
-   assert(mb->freefunc); /* not frozen */
+    assert(mb);
+    assert(mb->buf);
+    assert(mb->freefunc);	/* not frozen */
 
-   (*mb->freefunc)(mb->buf); /* freeze */
-   mb->buf = NULL;
-   mb->size = mb->capacity = 0;
+    (*mb->freefunc) (mb->buf);	/* freeze */
+    mb->buf = NULL;
+    mb->size = mb->capacity = 0;
 }
 
 /* calls memcpy, appends exactly size bytes, extends buffer if needed */
 void
-memBufAppend(MemBuf *mb, const char *buf, mb_size_t sz)
+memBufAppend(MemBuf * mb, const char *buf, mb_size_t sz)
 {
     assert(mb && buf && sz >= 0);
     assert(mb->buf);
-    assert(mb->freefunc); /* not frozen */
+    assert(mb->freefunc);	/* not frozen */
 
     if (sz > 0) {
 	if (mb->size + sz > mb->capacity)
-	   memBufGrow(mb, mb->size + sz);
-	assert(mb->size + sz <= mb->capacity); /* paranoid */
+	    memBufGrow(mb, mb->size + sz);
+	assert(mb->size + sz <= mb->capacity);	/* paranoid */
 	xmemcpy(mb->buf + mb->size, buf, sz);
 	mb->size += sz;
     }
@@ -166,7 +166,7 @@ memBufAppend(MemBuf *mb, const char *buf, mb_size_t sz)
 /* calls snprintf, extends buffer if needed */
 #ifdef __STDC__
 void
-memBufPrintf(MemBuf *mb, const char *fmt, ...)
+memBufPrintf(MemBuf * mb, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
@@ -190,25 +190,25 @@ memBufPrintf(va_alist)
 
 /* vprintf for other printf()'s to use */
 void
-memBufVPrintf(MemBuf *mb, const char *fmt, va_list vargs)
+memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs)
 {
     mb_size_t sz = 0;
     assert(mb && fmt);
     assert(mb->buf);
-    assert(mb->freefunc); /* not frozen */
+    assert(mb->freefunc);	/* not frozen */
     /* @?@ we do not init buf with '\0', do we have to for vsnprintf?? @?@ */
     /* assert in Grow should quit first, but we do not want to have a scare (1) loop */
-    while (mb->capacity <= mb->max_capacity) { 
+    while (mb->capacity <= mb->max_capacity) {
 	mb_size_t free_space = mb->capacity - mb->size;
 	/* put as much as we can */
 	sz = vsnprintf(mb->buf + mb->size, free_space, fmt, vargs) + 1;
 	/* check for possible overflow @?@ can vsnprintf cut more than needed off? */
-	if (sz + 32 >= free_space) /* magic constant 32, ARGH! @?@ */
-	    memBufGrow(mb, mb->capacity+1);
+	if (sz + 32 >= free_space)	/* magic constant 32, ARGH! @?@ */
+	    memBufGrow(mb, mb->capacity + 1);
 	else
 	    break;
     }
-    mb->size += sz-1; /* note that we cut 0-terminator as store does @?@ @?@ */
+    mb->size += sz - 1;		/* note that we cut 0-terminator as store does @?@ @?@ */
 }
 
 /*
@@ -219,21 +219,21 @@ memBufVPrintf(MemBuf *mb, const char *fmt, va_list vargs)
  *   (you still can read-access .buf and .size)
  */
 FREE *
-memBufFreeFunc(MemBuf *mb)
+memBufFreeFunc(MemBuf * mb)
 {
     FREE *ff;
     assert(mb);
     assert(mb->buf);
-    assert(mb->freefunc); /* not frozen */
+    assert(mb->freefunc);	/* not frozen */
 
     ff = mb->freefunc;
-    mb->freefunc = NULL; /* freeze */
+    mb->freefunc = NULL;	/* freeze */
     return ff;
 }
 
 /* grows (doubles) internal buffer to satisfy required minimal capacity */
 static void
-memBufGrow(MemBuf *mb, mb_size_t min_cap)
+memBufGrow(MemBuf * mb, mb_size_t min_cap)
 {
     mb_size_t new_cap;
     assert(mb);
@@ -242,16 +242,17 @@ memBufGrow(MemBuf *mb, mb_size_t min_cap)
     /* determine next capacity */
     new_cap = mb->capacity;
     if (new_cap > 0)
-	while (new_cap < min_cap) new_cap *= 2; /* double */
+	while (new_cap < min_cap)
+	    new_cap *= 2;	/* double */
     else
 	new_cap = min_cap;
 
     /* last chance to fit before we assert(!overflow) */
     if (new_cap > mb->max_capacity)
 	new_cap = mb->max_capacity;
 
-    assert(new_cap <= mb->max_capacity); /* no overflow */
-    assert(new_cap > mb->capacity);      /* progress */
+    assert(new_cap <= mb->max_capacity);	/* no overflow */
+    assert(new_cap > mb->capacity);	/* progress */
 
     /* finally [re]allocate memory */
     if (!mb->buf) {
@@ -261,7 +262,7 @@ memBufGrow(MemBuf *mb, mb_size_t min_cap)
 	assert(mb->freefunc);
 	mb->buf = realloc(mb->buf, new_cap);
     }
-    memset(mb->buf+mb->size, 0, new_cap-mb->size); /* just in case */
+    memset(mb->buf + mb->size, 0, new_cap - mb->size);	/* just in case */
     mb->capacity = new_cap;
 }
 
@@ -270,7 +271,7 @@ memBufGrow(MemBuf *mb, mb_size_t min_cap)
 
 /* puts report on MemBuf _module_ usage into mb */
 void
-memBufReport(MemBuf *mb)
+memBufReport(MemBuf * mb)
 {
     assert(mb);
     memBufPrintf(mb, "memBufReport is not yet implemented @?@\n");
@@ -1,5 +1,6 @@
+
 /*
- * $Id: Packer.cc,v 1.4 1998/02/26 08:10:55 rousskov Exp $
+ * $Id: Packer.cc,v 1.5 1998/02/26 18:00:34 wessels Exp $
  *
  * DEBUG: section 60    Packer: A uniform interface to store-like modules
  * AUTHOR: Alex Rousskov
@@ -29,36 +30,36 @@
  */
 
 /*
-    Rationale:
-    ----------
-
-    OK, we have to major interfaces comm.c and store.c.
-
-    Store.c has a nice storeAppend[Printf] capability which makes "storing"
-    things easy and painless. 
-
-    Comm.c lacks commAppend[Printf] because comm does not handle its own
-    buffers (no mem_obj equivalent for comm.c).
-
-    Thus, if one wants to be able to store _and_ comm_write an object, s/he
-    has to implement two almost identical functions.
-
-    Packer
-    ------
-
-    Packer provides for a more uniform interface to store and comm modules.
-    Packer has its own append and printf routines that "know" where to send
-    incoming data. In case of store interface, Packer sends data to
-    storeAppend.  Otherwise, Packer uses a MemBuf that can be flushed later to
-    comm_write.
-
-    Thus, one can write just one function that will either "pack" things for
-    comm_write or "append" things to store, depending on actual packer
-    supplied.
-
-    It is amasing how much work a tiny object can save. :)
-
-*/
+ * Rationale:
+ * ----------
+ * 
+ * OK, we have to major interfaces comm.c and store.c.
+ * 
+ * Store.c has a nice storeAppend[Printf] capability which makes "storing"
+ * things easy and painless. 
+ * 
+ * Comm.c lacks commAppend[Printf] because comm does not handle its own
+ * buffers (no mem_obj equivalent for comm.c).
+ * 
+ * Thus, if one wants to be able to store _and_ comm_write an object, s/he
+ * has to implement two almost identical functions.
+ * 
+ * Packer
+ * ------
+ * 
+ * Packer provides for a more uniform interface to store and comm modules.
+ * Packer has its own append and printf routines that "know" where to send
+ * incoming data. In case of store interface, Packer sends data to
+ * storeAppend.  Otherwise, Packer uses a MemBuf that can be flushed later to
+ * comm_write.
+ * 
+ * Thus, one can write just one function that will either "pack" things for
+ * comm_write or "append" things to store, depending on actual packer
+ * supplied.
+ * 
+ * It is amasing how much work a tiny object can save. :)
+ * 
+ */
 
 
 /*
@@ -87,49 +88,49 @@
  */
 
 /* append()'s */
-static void (*const store_append)(StoreEntry *, const char *, int) = &storeAppend;
-static void (*const memBuf_append)(MemBuf *, const char *, mb_size_t) = &memBufAppend;
+static void (*const store_append) (StoreEntry *, const char *, int) = &storeAppend;
+static void (*const memBuf_append) (MemBuf *, const char *, mb_size_t) = &memBufAppend;
 
 /* vprintf()'s */
-static void (*const store_vprintf)(StoreEntry *, const char *, va_list ap) = &storeAppendVPrintf;
-static void (*const memBuf_vprintf)(MemBuf *, const char *, va_list ap) = &memBufVPrintf;
+static void (*const store_vprintf) (StoreEntry *, const char *, va_list ap) = &storeAppendVPrintf;
+static void (*const memBuf_vprintf) (MemBuf *, const char *, va_list ap) = &memBufVPrintf;
 
 
 /* init/clean */
 
 /* init with this to forward data to StoreEntry */
 void
-packerToStoreInit(Packer *p, StoreEntry *e)
+packerToStoreInit(Packer * p, StoreEntry * e)
 {
     assert(p && e);
-    p->append = (append_f)store_append;
-    p->vprintf = (vprintf_f)storeAppendVPrintf;
+    p->append = (append_f) store_append;
+    p->vprintf = (vprintf_f) storeAppendVPrintf;
     p->real_handler = e;
 }
 
 /* init with this to accumulate data in MemBuf */
 void
-packerToMemInit(Packer *p, MemBuf *mb)
+packerToMemInit(Packer * p, MemBuf * mb)
 {
     assert(p && mb);
-    p->append = (append_f)memBuf_append;
-    p->vprintf = (vprintf_f)memBuf_vprintf;
+    p->append = (append_f) memBuf_append;
+    p->vprintf = (vprintf_f) memBuf_vprintf;
     p->real_handler = mb;
 }
 
 /* call this when you are done */
 void
-packerClean(Packer *p)
+packerClean(Packer * p)
 {
-   assert(p);
-   /* it is not really necessary to do this, but, just in case... */
-   p->append = NULL;
-   p->vprintf = NULL;
-   p->real_handler = NULL;
+    assert(p);
+    /* it is not really necessary to do this, but, just in case... */
+    p->append = NULL;
+    p->vprintf = NULL;
+    p->real_handler = NULL;
 }
 
 void
-packerAppend(Packer *p, const char *buf, int sz)
+packerAppend(Packer * p, const char *buf, int sz)
 {
     assert(p);
     assert(p->real_handler && p->append);
@@ -138,7 +139,7 @@ packerAppend(Packer *p, const char *buf, int sz)
 
 #ifdef __STDC__
 void
-packerPrintf(Packer *p, const char *fmt, ...)
+packerPrintf(Packer * p, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
@@ -1,5 +1,6 @@
+
 /*
- * $Id: StatHist.cc,v 1.2 1998/02/25 16:40:06 wessels Exp $
+ * $Id: StatHist.cc,v 1.3 1998/02/26 18:00:35 wessels Exp $
  *
  * DEBUG: section 62    Generic Histogram
  * AUTHOR: Duane Wessels
@@ -87,14 +88,14 @@ statHistCopy(StatHist * Dest, const StatHist * Orig)
     assert(Dest->scale == Orig->scale);
     assert(Dest->val_in == Orig->val_in && Dest->val_out == Orig->val_out);
     /* actual copy */
-    xmemcpy(Dest->bins, Orig->bins, Dest->capacity*sizeof(*Dest->bins));
+    xmemcpy(Dest->bins, Orig->bins, Dest->capacity * sizeof(*Dest->bins));
 }
 
 void
 statHistCount(StatHist * H, double val)
 {
     const int bin = statHistBin(H, val);
-    assert(H->bins);	/* make sure it got initialized */
+    assert(H->bins);		/* make sure it got initialized */
     assert(0 <= bin && bin < H->capacity);
     H->bins[bin]++;
 }
@@ -103,13 +104,13 @@ static int
 statHistBin(const StatHist * H, double v)
 {
     int bin;
-    v -= H->min; /* offset */
-    if (v < 0.0) /* too small */
+    v -= H->min;		/* offset */
+    if (v < 0.0)		/* too small */
 	return 0;
     bin = (int) (H->scale * H->val_in(v) + 0.5);
-    if (bin < 0) /* should not happen */
+    if (bin < 0)		/* should not happen */
 	bin = 0;
-    if (bin >= H->capacity) /* too big */
+    if (bin >= H->capacity)	/* too big */
 	bin = H->capacity - 1;
     return bin;
 }
@@ -168,7 +169,7 @@ statHistBinDumper(StoreEntry * sentry, int idx, double val, double size, int cou
 {
     if (count)
 	storeAppendPrintf(sentry, "\t%3d/%f\t%d\t%f\n",
-	    idx, val, count, count/size);
+	    idx, val, count, count / size);
 }
 
 void
@@ -179,16 +180,24 @@ statHistDump(const StatHist * H, StoreEntry * sentry, StatHistBinDumper bd)
     if (!bd)
 	bd = statHistBinDumper;
     for (i = 0; i < H->capacity; i++) {
-	const double right_border = statHistVal(H, i+1);
+	const double right_border = statHistVal(H, i + 1);
 	assert(right_border - left_border > 0.0);
 	bd(sentry, i, left_border, right_border - left_border, H->bins[i]);
 	left_border = right_border;
     }
 }
 
 /* log based histogram */
-static double Log(double x) { return log(x+1); }
-static double Exp(double x) { return exp(x)-1; }
+static double
+Log(double x)
+{
+    return log(x + 1);
+}
+static double
+Exp(double x)
+{
+    return exp(x) - 1;
+}
 void
 statHistLogInit(StatHist * H, int capacity, double min, double max)
 {
@@ -197,9 +206,13 @@ statHistLogInit(StatHist * H, int capacity, double min, double max)
 
 /* linear histogram for enums */
 /* we want to be have [-1,last_enum+1] range to track out of range enums */
-static double Null(double x) { return x; }
+static double
+Null(double x)
+{
+    return x;
+}
 void
 statHistEnumInit(StatHist * H, int last_enum)
 {
-    statHistInit(H, last_enum+3, &Null, &Null, -1, last_enum+1+1);
+    statHistInit(H, last_enum + 3, &Null, &Null, -1, last_enum + 1 + 1);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.143 1998/02/25 21:30:39 wessels Exp $
+ * $Id: acl.cc,v 1.144 1998/02/26 18:00:35 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -1485,7 +1485,7 @@ aclChecklistFree(aclCheck_t * checklist)
     if (checklist->state[ACL_DST_IP] == ACL_LOOKUP_PENDING)
 	ipcacheUnregister(checklist->request->host, checklist);
     if (checklist->request)
-    requestUnlink(checklist->request);
+	requestUnlink(checklist->request);
     checklist->request = NULL;
     cbdataFree(checklist);
 }
@@ -1550,7 +1550,7 @@ aclChecklistCreate(const acl_access * A,
      */
     cbdataLock(A);
     if (request != NULL)
-    	checklist->request = requestLink(request);
+	checklist->request = requestLink(request);
     checklist->src_addr = src_addr;
     for (i = 0; i < ACL_ENUM_MAX; i++)
 	checklist->state[i] = ACL_LOOKUP_NONE;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.253 1998/02/26 09:01:11 kostas Exp $
+ * $Id: cache_cf.cc,v 1.254 1998/02/26 18:00:37 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -445,19 +445,19 @@ dump_snmp_access(StoreEntry * entry, const char *name, communityEntry * Head)
     acl_list *l;
     communityEntry *cp;
     acl_access *head;
- 
+
     for (cp = Head; cp; cp = cp->next) {
-	head=cp->acls;
-       while (head != NULL) {
-	for (l = head->acl_list; l != NULL; l = l->next) {
-	    storeAppendPrintf(entry, "%s %s %s %s%s\n",
-		name, cp->name, 
-		head->allow ? "Allow" : "Deny",
-		l->op ? "" : "!",
-		l->acl->name);
+	head = cp->acls;
+	while (head != NULL) {
+	    for (l = head->acl_list; l != NULL; l = l->next) {
+		storeAppendPrintf(entry, "%s %s %s %s%s\n",
+		    name, cp->name,
+		    head->allow ? "Allow" : "Deny",
+		    l->op ? "" : "!",
+		    l->acl->name);
+	    }
+	    head = head->next;
 	}
-	head = head->next;
-       }
     }
 }
 #endif
@@ -481,26 +481,26 @@ dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 #if SQUID_SNMP
 
 static void
-parse_snmp_access(communityEntry  **head)
+parse_snmp_access(communityEntry ** head)
 {
     char *t;
     communityEntry *cp;
- 
-    t=strtok(NULL, w_space);
-    for (cp = *head; cp; cp = cp->next) 
-        if (!strcmp(t, cp->name)) {
-    		aclParseAccessLine(&cp->acls);
-		return;
+
+    t = strtok(NULL, w_space);
+    for (cp = *head; cp; cp = cp->next)
+	if (!strcmp(t, cp->name)) {
+	    aclParseAccessLine(&cp->acls);
+	    return;
 	}
-     debug(15,0)("parse_snmp_access: You need to define community %s first!\n",t);
+    debug(15, 0) ("parse_snmp_access: You need to define community %s first!\n", t);
 }
 
 static void
 free_snmp_access(communityEntry ** Head)
 {
     communityEntry *cp;
-    
-    for (cp = *Head; cp; cp = cp->next) 
+
+    for (cp = *Head; cp; cp = cp->next)
 	aclDestroyAccessList(&cp->acls);
 }
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_manager.cc,v 1.6 1998/02/23 13:03:01 rousskov Exp $
+ * $Id: cache_manager.cc,v 1.7 1998/02/26 18:00:37 wessels Exp $
  *
  * DEBUG: section 16    Cache Manager Objects
  * AUTHOR: Duane Wessels
@@ -48,17 +48,17 @@ typedef struct _action_table {
     struct _action_table *next;
 } action_table;
 
-static action_table * cachemgrFindAction(const char *action);
+static action_table *cachemgrFindAction(const char *action);
 #if 0
 static cachemgrStateData *cachemgrParse(const char *url);
 #else
 static cachemgrStateData *cachemgrParseUrl(const char *url);
 #endif
-static void cachemgrParseHeaders(cachemgrStateData *mgr, const request_t *request);
+static void cachemgrParseHeaders(cachemgrStateData * mgr, const request_t * request);
 static int cachemgrCheckPassword(cachemgrStateData *);
-static void cachemgrStateFree(cachemgrStateData *mgr);
+static void cachemgrStateFree(cachemgrStateData * mgr);
 static char *cachemgrPasswdGet(cachemgr_passwd *, const char *);
-static const char *cachemgrActionProtection(const action_table *at);
+static const char *cachemgrActionProtection(const action_table * at);
 static OBJH cachemgrShutdown;
 static OBJH cachemgrMenu;
 
@@ -70,7 +70,7 @@ cachemgrRegister(const char *action, const char *desc, OBJH * handler, int pw_re
     action_table *a;
     action_table **A;
     if (cachemgrFindAction(action) != NULL) {
-	debug(16, 3)("cachemgrRegister: Duplicate '%s'\n", action);
+	debug(16, 3) ("cachemgrRegister: Duplicate '%s'\n", action);
 	return;
     }
     a = xcalloc(1, sizeof(action_table));
@@ -80,7 +80,7 @@ cachemgrRegister(const char *action, const char *desc, OBJH * handler, int pw_re
     a->pw_req_flag = pw_req_flag;
     for (A = &ActionTable; *A; A = &(*A)->next);
     *A = a;
-    debug(16, 3)("cachemgrRegister: registered %s\n", action);
+    debug(16, 3) ("cachemgrRegister: registered %s\n", action);
 }
 
 static action_table *
@@ -111,7 +111,7 @@ cachemgrParseUrl(const char *url)
 	debug(16, 0) ("cachemgrParseUrl: action '%s' not found\n", request);
 	return NULL;
     } else {
-    	prot = cachemgrActionProtection(a);
+	prot = cachemgrActionProtection(a);
 	if (!strcmp(prot, "disabled") || !strcmp(prot, "hidden")) {
 	    debug(16, 0) ("cachemgrParseUrl: action '%s' is %s\n", request, prot);
 	    return NULL;
@@ -126,15 +126,15 @@ cachemgrParseUrl(const char *url)
 }
 
 static void
-cachemgrParseHeaders(cachemgrStateData *mgr, const request_t *request)
+cachemgrParseHeaders(cachemgrStateData * mgr, const request_t * request)
 {
-    const char *basic_cookie; /* base 64 _decoded_ user:passwd pair */
+    const char *basic_cookie;	/* base 64 _decoded_ user:passwd pair */
     const char *authField;
     const char *passwd_del;
     assert(mgr && request);
     /* this parsing will go away when hdrs are added to request_t @?@ */
     basic_cookie = mime_get_auth(request->headers, "Basic", &authField);
-    debug(16,9) ("cachemgrParseHeaders: got auth: '%s'\n", authField ? authField:"<none>");
+    debug(16, 9) ("cachemgrParseHeaders: got auth: '%s'\n", authField ? authField : "<none>");
     if (!authField)
 	return;
     if (!basic_cookie) {
@@ -148,11 +148,11 @@ cachemgrParseHeaders(cachemgrStateData *mgr, const request_t *request)
     /* found user:password pair, reset old values */
     safe_free(mgr->user_name);
     safe_free(mgr->passwd);
-    mgr->user_name = xstrdup(basic_cookie); 
+    mgr->user_name = xstrdup(basic_cookie);
     mgr->user_name[passwd_del - basic_cookie] = '\0';
-    mgr->passwd = xstrdup(passwd_del+1);
+    mgr->passwd = xstrdup(passwd_del + 1);
     /* warning: this prints decoded password which maybe not what you want to do @?@ @?@ */
-    debug(16,9) ("cachemgrParseHeaders: got user: '%s' passwd: '%s'\n", mgr->user_name, mgr->passwd);
+    debug(16, 9) ("cachemgrParseHeaders: got user: '%s' passwd: '%s'\n", mgr->user_name, mgr->passwd);
 }
 
 /*
@@ -176,16 +176,16 @@ cachemgrCheckPassword(cachemgrStateData * mgr)
 }
 
 static void
-cachemgrStateFree(cachemgrStateData *mgr)
+cachemgrStateFree(cachemgrStateData * mgr)
 {
-	safe_free(mgr->action);
-	safe_free(mgr->user_name);
-	safe_free(mgr->passwd);
-	xfree(mgr);
+    safe_free(mgr->action);
+    safe_free(mgr->user_name);
+    safe_free(mgr->passwd);
+    xfree(mgr);
 }
 
 void
-cachemgrStart(int fd, request_t *request, StoreEntry * entry)
+cachemgrStart(int fd, request_t * request, StoreEntry * entry)
 {
     cachemgrStateData *mgr = NULL;
     ErrorState *err = NULL;
@@ -206,13 +206,13 @@ cachemgrStart(int fd, request_t *request, StoreEntry * entry)
     cachemgrParseHeaders(mgr, request);
     if (mgr->user_name && strlen(mgr->user_name))
 	debug(16, 1) ("CACHEMGR: %s@%s requesting '%s'\n",
-	      mgr->user_name, fd_table[fd].ipaddr, mgr->action);
+	    mgr->user_name, fd_table[fd].ipaddr, mgr->action);
     else
 	debug(16, 1) ("CACHEMGR: %s requesting '%s'\n",
-	      fd_table[fd].ipaddr, mgr->action);
+	    fd_table[fd].ipaddr, mgr->action);
     /* Check password */
     if (cachemgrCheckPassword(mgr) != 0) {
-#if 0 /* old response, we ask for authentication now */
+#if 0				/* old response, we ask for authentication now */
 	cachemgrStateFree(mgr);
 	debug(16, 1) ("WARNING: Incorrect Cachemgr Password!\n");
 	err = errorCon(ERR_INVALID_URL, HTTP_NOT_FOUND);
@@ -224,11 +224,11 @@ cachemgrStart(int fd, request_t *request, StoreEntry * entry)
 	/* warn if user specified incorrect password */
 	if (mgr->passwd)
 	    debug(16, 1) ("WARNING: CACHEMGR: Incorrect Password (user: %s, action: %s)!\n",
-	        mgr->user_name ? mgr->user_name : "<unknown>", mgr->action);
+		mgr->user_name ? mgr->user_name : "<unknown>", mgr->action);
 	else
 	    debug(16, 3) ("CACHEMGR: requesting authentication for action: '%s'.\n",
 		mgr->action);
-        err->request = requestLink(request);
+	err->request = requestLink(request);
 	rep = errorBuildReply(err);
 	errorStateFree(err);
 	/* add Authenticate header, use 'action' as a realm because password depends on action */
@@ -250,7 +250,7 @@ cachemgrStart(int fd, request_t *request, StoreEntry * entry)
     {
 	HttpReply *rep = httpReplyCreate();
 	httpReplySetHeaders(rep, (double) 1.0, HTTP_OK, NULL,
-	    "text/plain", -1 /* C-Len */, squid_curtime /* LMT */, squid_curtime);
+	    "text/plain", -1 /* C-Len */ , squid_curtime /* LMT */ , squid_curtime);
 	httpReplySwapOut(rep, entry);
 	httpReplyDestroy(rep);
     }
@@ -278,7 +278,7 @@ cachemgrShutdown(StoreEntry * entryunused)
 }
 
 static const char *
-cachemgrActionProtection(const action_table *at)
+cachemgrActionProtection(const action_table * at)
 {
     char *pwd;
     assert(at);
@@ -293,7 +293,7 @@ cachemgrActionProtection(const action_table *at)
 }
 
 static void
-cachemgrMenu(StoreEntry *sentry)
+cachemgrMenu(StoreEntry * sentry)
 {
     action_table *a;
     for (a = ActionTable; a != NULL; a = a->next) {
@@ -1,5 +1,6 @@
+
 /*
- * $Id: cachemgr.cc,v 1.71 1998/02/26 00:19:52 rousskov Exp $
+ * $Id: cachemgr.cc,v 1.72 1998/02/26 18:00:38 wessels Exp $
  *
  * DEBUG: section 0     CGI Cache Manager
  * AUTHOR: Duane Wessels
@@ -147,7 +148,7 @@ typedef struct {
 /*
  * Static variables and constants
  */
-static const time_t passwd_ttl = 60*60*3; /* in sec */
+static const time_t passwd_ttl = 60 * 60 * 3;	/* in sec */
 static const char *script_name = "/cgi-bin/cachemgr.cgi";
 static const char *const w_space = " \t\n\r";
 static const char *progname = NULL;
@@ -169,33 +170,37 @@ static cachemgr_request *read_request(void);
 static char *read_get_request(void);
 static char *read_post_request(void);
 
-static void make_pub_auth(cachemgr_request *req);
-static void decode_pub_auth(cachemgr_request *req);
-static void reset_auth(cachemgr_request *req);
-static const char *make_auth_header(const cachemgr_request *req);
+static void make_pub_auth(cachemgr_request * req);
+static void decode_pub_auth(cachemgr_request * req);
+static void reset_auth(cachemgr_request * req);
+static const char *make_auth_header(const cachemgr_request * req);
 
 
-static const char *safe_str(const char *str)
+static const char *
+safe_str(const char *str)
 {
     return str ? str : "";
 }
 
-static char *xstrtok(char **str, char del)
+static char *
+xstrtok(char **str, char del)
 {
     if (*str) {
 	char *p = strchr(*str, del);
 	char *tok = *str;
 	int len;
 	if (p) {
-	    *str = p+1;
+	    *str = p + 1;
 	    *p = '\0';
 	} else
 	    *str = NULL;
 	/* trim */
 	len = strlen(tok);
-	while (len && isspace(tok[len-1])) tok[--len] = '\0';
-	while (isspace(*tok)) tok++;
-  	return tok;
+	while (len && isspace(tok[len - 1]))
+	    tok[--len] = '\0';
+	while (isspace(*tok))
+	    tok++;
+	return tok;
     } else
 	return "";
 }
@@ -213,8 +218,10 @@ print_trailer(void)
 static void
 auth_html(char *host, int port, const char *user_name)
 {
-    if (!user_name) user_name = "";
-    if (!host || !strlen(host)) host = "localhost";
+    if (!user_name)
+	user_name = "";
+    if (!host || !strlen(host))
+	host = "localhost";
     printf("Content-type: text/html\r\n\r\n");
     printf("<HTML><HEAD><TITLE>Cache Manager Interface</TITLE></HEAD>\n");
     printf("<BODY><H1>Cache Manager Interface</H1>\n");
@@ -300,16 +307,16 @@ munge_menu_line(const char *buf, cachemgr_request * req)
     if (!strcmp(p, "disabled"))
 	snprintf(html, 1024, "<LI type=\"circle\">%s (disabled)<A HREF=\"%s\">.</A>\n", d, a_url);
     else
-    /* disable a hidden action (requires a password, but password is not in squid.conf) */
+	/* disable a hidden action (requires a password, but password is not in squid.conf) */
     if (!strcmp(p, "hidden"))
 	snprintf(html, 1024, "<LI type=\"circle\">%s (hidden)<A HREF=\"%s\">.</A>\n", d, a_url);
     else
-    /* disable link if authentication is required and we have no password */
-    if (!strcmp(p, "protected") && !req -> passwd)
+	/* disable link if authentication is required and we have no password */
+    if (!strcmp(p, "protected") && !req->passwd)
 	snprintf(html, 1024, "<LI type=\"circle\">%s (requires <a href=\"%s\">authentication</a>)<A HREF=\"%s\">.</A>\n",
 	    d, menu_url(req, "authenticate"), a_url);
     else
-    /* highlight protected but probably available entries */
+	/* highlight protected but probably available entries */
     if (!strcmp(p, "protected"))
 	snprintf(html, 1024, "<LI type=\"square\"><A HREF=\"%s\"><font color=\"#FF0000\">%s</font></A>\n",
 	    a_url, d);
@@ -323,10 +330,12 @@ munge_menu_line(const char *buf, cachemgr_request * req)
 static int
 read_reply(int s, cachemgr_request * req)
 {
-    char buf[4*1024];
+    char buf[4 * 1024];
     FILE *fp = fdopen(s, "r");
     /* interpretation states */
-    enum { isStatusLine, isHeaders, isBodyStart, isBody, isForward, isEof, isForwardEof, isSuccess, isError } istate = isStatusLine;
+    enum {
+	isStatusLine, isHeaders, isBodyStart, isBody, isForward, isEof, isForwardEof, isSuccess, isError
+    } istate = isStatusLine;
     int parse_menu = 0;
     const char *action = req->action;
     const char *statusStr = NULL;
@@ -349,30 +358,30 @@ read_reply(int s, cachemgr_request * req)
 	case isStatusLine:
 	    /* get HTTP status */
 	    /* uncomment the following if you want to debug headers */
-            /* fputs("\r\n\r\n", stdout); */
+	    /* fputs("\r\n\r\n", stdout); */
 	    status = parse_status_line(buf, &statusStr);
 	    istate = status == 200 ? isHeaders : isForward;
 	    /* if cache asks for authentication, we have to reset our info */
 	    if (status == 401 || status == 407) {
 		reset_auth(req);
-		status = 403; /* Forbiden, see comments in case isForward: */
+		status = 403;	/* Forbiden, see comments in case isForward: */
 	    }
 	    /* this is a way to pass HTTP status to the Web server */
 	    if (statusStr)
-		printf("Status: %d %s", status, statusStr); /* statusStr has '\n' */
+		printf("Status: %d %s", status, statusStr);	/* statusStr has '\n' */
 	    break;
 	case isHeaders:
 	    /* forward header field */
-	    if (!strcmp(buf, "\r\n")) { /* end of headers */
-		fputs("Content-Type: text/html\r\n", stdout); /* add our type */
+	    if (!strcmp(buf, "\r\n")) {		/* end of headers */
+		fputs("Content-Type: text/html\r\n", stdout);	/* add our type */
 		istate = isBodyStart;
 	    }
-	    if (strncasecmp(buf, "Content-Type:", 13)) /* filter out their type */
-	        fputs(buf, stdout);
+	    if (strncasecmp(buf, "Content-Type:", 13))	/* filter out their type */
+		fputs(buf, stdout);
 	    break;
 	case isBodyStart:
 	    printf("<HTML><HEAD><TITLE>CacheMgr@%s: %s</TITLE></HEAD><BODY>\n",
-		   req->hostname, action);
+		req->hostname, action);
 	    if (parse_menu) {
 		printf("<H2><a href=\"%s\">Cache Manager</a> menu for %s:</H2>",
 		    menu_url(req, "authenticate"), req->hostname);
@@ -398,10 +407,9 @@ read_reply(int s, cachemgr_request * req)
 	     * 401 to .cgi because web server filters out all auth info. Thus we
 	     * disable authentication headers for now.
 	     */
-	    if (!strncasecmp(buf, "WWW-Authenticate:", 17) || !strncasecmp(buf, "Proxy-Authenticate:", 19))
-		; /* skip */
+	    if (!strncasecmp(buf, "WWW-Authenticate:", 17) || !strncasecmp(buf, "Proxy-Authenticate:", 19));	/* skip */
 	    else
-	 	fputs(buf, stdout);
+		fputs(buf, stdout);
 	    break;
 	case isEof:
 	    /* print trailers */
@@ -433,7 +441,7 @@ process_request(cachemgr_request * req)
     static struct sockaddr_in S;
     int s;
     int l;
-    static char buf[2*1024];
+    static char buf[2 * 1024];
     if (req == NULL) {
 	auth_html(CACHEMGR_HOSTNAME, CACHE_HTTP_PORT, "");
 	return 1;
@@ -476,7 +484,7 @@ process_request(cachemgr_request * req)
     l = snprintf(buf, sizeof(buf),
 	"GET cache_object://%s/%s HTTP/1.0\r\n"
 	"Accept: */*\r\n"
-	"%s" /* Authentication info or nothing */
+	"%s"			/* Authentication info or nothing */
 	"\r\n",
 	req->hostname,
 	req->action,
@@ -503,12 +511,12 @@ main(int argc, char *argv[])
     return process_request(req);
 }
 
-#if 0 /* left for parts if request headers will ever be processed */
+#if 0				/* left for parts if request headers will ever be processed */
 static char *
 read_request_headers()
 {
     extern char **environ;
-    const char **varp = (const char**) environ;
+    const char **varp = (const char **) environ;
     char *buf = NULL;
     int size = 0;
     if (!varp)
@@ -517,23 +525,23 @@ read_request_headers()
     /* first calc the size */
     for (; *varp; varp++) {
 	if (1 || !strncasecmp(*varp, "HTTP_", 5))
-		size += strlen(*varp);
+	    size += strlen(*varp);
     }
     if (!size)
 	return NULL;
-    size++; /* paranoid */
-    size += 1024; /* @?@?@?@ */
+    size++;			/* paranoid */
+    size += 1024;		/* @?@?@?@ */
     /* allocate memory */
     buf = calloc(1, size);
     /* parse and put headers */
-    for (varp =  (const char**) environ; *varp; varp++) {
+    for (varp = (const char **) environ; *varp; varp++) {
 	sprintf(buf + strlen(buf), "%s\r\n", *varp);
 	if (0 && !strncasecmp(*varp, "HTTP_", 5)) {
 	    const char *name = (*varp) + 5;
 	    const char *value = strchr(name, '=');
 	    if (value) {
-		strncat(buf, name, value-name);
-		sprintf(buf + strlen(buf), ": %s\r\n", value+1);
+		strncat(buf, name, value - name);
+		sprintf(buf + strlen(buf), ": %s\r\n", value + 1);
 	    }
 	}
     }
@@ -595,20 +603,15 @@ read_request(void)
 	*q++ = '\0';
 	if (0 == strcasecmp(t, "host") && strlen(q))
 	    req->hostname = xstrdup(q);
-	else
-	if (0 == strcasecmp(t, "port") && strlen(q))
+	else if (0 == strcasecmp(t, "port") && strlen(q))
 	    req->port = atoi(q);
-	else
-	if (0 == strcasecmp(t, "user_name") && strlen(q))
+	else if (0 == strcasecmp(t, "user_name") && strlen(q))
 	    req->user_name = xstrdup(q);
-	else
-	if (0 == strcasecmp(t, "passwd") && strlen(q))
+	else if (0 == strcasecmp(t, "passwd") && strlen(q))
 	    req->passwd = xstrdup(q);
-	else
-	if (0 == strcasecmp(t, "auth") && strlen(q))
+	else if (0 == strcasecmp(t, "auth") && strlen(q))
 	    req->pub_auth = xstrdup(q), decode_pub_auth(req);
-	else
-	if (0 == strcasecmp(t, "operation"))
+	else if (0 == strcasecmp(t, "operation"))
 	    req->action = xstrdup(q);
     }
     make_pub_auth(req);
@@ -625,7 +628,7 @@ read_request(void)
  * Currently no powerful encryption is used.
  */
 static void
-make_pub_auth(cachemgr_request *req)
+make_pub_auth(cachemgr_request * req)
 {
     static char buf[1024];
     safe_free(req->pub_auth);
@@ -644,7 +647,7 @@ make_pub_auth(cachemgr_request *req)
 }
 
 static void
-decode_pub_auth(cachemgr_request *req)
+decode_pub_auth(cachemgr_request * req)
 {
     char *buf;
     const char *host_name;
@@ -664,7 +667,7 @@ decode_pub_auth(cachemgr_request *req)
     debug(3) fprintf(stderr, "cmgr: decoded host: '%s'\n", host_name);
     if ((time_str = strtok(NULL, "|")) == NULL)
 	return;
-    debug(3) fprintf(stderr, "cmgr: decoded time: '%s' (now: %d)\n", time_str, (int)now);
+    debug(3) fprintf(stderr, "cmgr: decoded time: '%s' (now: %d)\n", time_str, (int) now);
     if ((user_name = strtok(NULL, "|")) == NULL)
 	return;
     debug(3) fprintf(stderr, "cmgr: decoded uname: '%s'\n", user_name);
@@ -685,23 +688,23 @@ decode_pub_auth(cachemgr_request *req)
 }
 
 static void
-reset_auth(cachemgr_request *req)
+reset_auth(cachemgr_request * req)
 {
     safe_free(req->passwd);
     safe_free(req->pub_auth);
 }
 
 static const char *
-make_auth_header(const cachemgr_request *req)
+make_auth_header(const cachemgr_request * req)
 {
     static char buf[1024];
     const char *str64;
-    if (!req -> passwd)
+    if (!req->passwd)
 	return "";
 
-    snprintf(buf, sizeof(buf), "%s:%s", 
+    snprintf(buf, sizeof(buf), "%s:%s",
 	req->user_name ? req->user_name : "",
-	req -> passwd);
+	req->passwd);
 
     str64 = base64_encode(buf);
     snprintf(buf, sizeof(buf), "Authorization: Basic %s\r\n", str64);
@@ -1,7 +1,8 @@
 
 
+
 /*
- * $Id: client.cc,v 1.56 1998/02/22 07:45:18 rousskov Exp $
+ * $Id: client.cc,v 1.57 1998/02/26 18:00:39 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.217 1998/02/26 08:10:57 rousskov Exp $
+ * $Id: client_side.cc,v 1.218 1998/02/26 18:00:40 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -892,9 +892,9 @@ clientBuildReplyHeader(clientHttpRequest * http,
 	l = strcspn(t, crlf) + 1;
 	xstrncpy(xbuf, t, l > 4096 ? 4096 : l);
 	/* enforce 1.0 reply version, this hack will be rewritten */
-	if (!hdr_len && !strncasecmp(xbuf, "HTTP/", 5) && l > 8 && 
-	    ( isspace(xbuf[8]) || isspace(xbuf[9])))
-	    xmemmove(xbuf+5, "1.0 ", 4);
+	if (!hdr_len && !strncasecmp(xbuf, "HTTP/", 5) && l > 8 &&
+	    (isspace(xbuf[8]) || isspace(xbuf[9])))
+	    xmemmove(xbuf + 5, "1.0 ", 4);
 #if 0
 	if (strncasecmp(xbuf, "Accept-Ranges:", 14) == 0)
 	    continue;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: debug.cc,v 1.62 1998/02/24 20:01:44 rousskov Exp $
+ * $Id: debug.cc,v 1.63 1998/02/26 17:57:45 wessels Exp $
  *
  * DEBUG: section 0     Debug Routines
  * AUTHOR: Harvest Derived
@@ -294,9 +294,9 @@ debugLogTime(time_t t)
     static char buf[128];
     static time_t last_t = 0;
     if (t != last_t) {
-        tm = localtime(&t);
-        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
-        last_t = t;
+	tm = localtime(&t);
+	strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
+	last_t = t;
     }
     return buf;
 }
@@ -307,62 +307,68 @@ debugLogTime(time_t t)
 
 #if 0
 
-    Rationale
-    ---------
-
-    When you have a long nested processing sequence, it is often impossible
-    for low level routines to know in what larger context they operate. If a
-    routine coredumps, one can restore the context using debugger trace.
-    However, in many case you do not want to coredump, but just want to report
-    a potential problem. A report maybe useless out of problem context.
-
-    To solve this potential problem, use the following approach:
-
-    int top_level_foo(const char *url)
-    {
-	/* define current context */
-	Ctx ctx = ctx_enter(url); /* note: we stack but do not dup ctx descriptions! */
-	...
-	/* go down; middle_level_bar will eventually call bottom_level_boo */
+    /*
+     * Rationale
+     * ---------
+     * 
+     * When you have a long nested processing sequence, it is often impossible
+     * for low level routines to know in what larger context they operate. If a
+     * routine coredumps, one can restore the context using debugger trace.
+     * However, in many case you do not want to coredump, but just want to report
+     * a potential problem. A report maybe useless out of problem context.
+     * 
+     * To solve this potential problem, use the following approach:
+     */
+
+int
+top_level_foo(const char *url)
+{
+    /* define current context */
+    Ctx ctx = ctx_enter(url);	/* note: we stack but do not dup ctx descriptions! */
+    ...
+    /* go down; middle_level_bar will eventually call bottom_level_boo */
 	middle_level_bar(method, protocol);
-	...
-	/* exit, clean after yourself */
+    ...
+    /* exit, clean after yourself */
 	ctx_exit(ctx);
-    }
-
-    void bottom_level_boo(int status, void *data)
-    {
-	/*
-	 * detect exceptional condition, and simply report it, the context
-	 * information will be available somewhere close in the log file
-	 */
-	if (status == STRANGE_STATUS)
-	    debug(13, 6) ("DOS attack detected, data: %p\n", data);
-	...
-    }
-
-    Current implementation is extremely simple but still very handy. It has a
-    negligible overhead (descriptions are not duplicated).
-
-    When the _first_ debug message for a given context is printed, it is
-    prepended with the current context description. Context is printed with
-    the same debugging level as the original message.
-
-    Note that we do not print context every type you do ctx_enter(). This
-    approach would produce too many useless messages.  For the same reason, a
-    context description is printed at most _once_ even if you have 10
-    debugging messages within one context.
+}
 
-    Contexts can be nested, of course. You must use ctx_enter() to enter a
-    context (push it onto stack).  It is probably safe to exit several nested
-    contexts at _once_ by calling ctx_exit() at the top level (this will pop
-    all context till current one). However, as in any stack, you cannot start
-    in the middle.
+void
+bottom_level_boo(int status, void *data)
+{
+    /*
+     * detect exceptional condition, and simply report it, the context
+     * information will be available somewhere close in the log file
+     */
+    if (status == STRANGE_STATUS)
+	debug(13, 6) ("DOS attack detected, data: %p\n", data);
+    ...
+}
 
-    Analysis: 
-	i)   locate debugging message,
-	ii)  locate current context by going _upstream_ in your log file,
-	iii) hack away.
+    /*
+     * Current implementation is extremely simple but still very handy. It has a
+     * negligible overhead (descriptions are not duplicated).
+     * 
+     * When the _first_ debug message for a given context is printed, it is
+     * prepended with the current context description. Context is printed with
+     * the same debugging level as the original message.
+     * 
+     * Note that we do not print context every type you do ctx_enter(). This
+     * approach would produce too many useless messages.  For the same reason, a
+     * context description is printed at most _once_ even if you have 10
+     * debugging messages within one context.
+     * 
+     * Contexts can be nested, of course. You must use ctx_enter() to enter a
+     * context (push it onto stack).  It is probably safe to exit several nested
+     * contexts at _once_ by calling ctx_exit() at the top level (this will pop
+     * all context till current one). However, as in any stack, you cannot start
+     * in the middle.
+     * 
+     * Analysis: 
+     * i)   locate debugging message,
+     * ii)  locate current context by going _upstream_ in your log file,
+     * iii) hack away.
+     */
 
 #endif /* rationale */
 
@@ -372,24 +378,28 @@ debugLogTime(time_t t)
  *       add printf()-style interface
  */
 
-
-/* implementation */
-
 /*
+ * implementation:
+ *
  * descriptions for contexts over CTX_MAX_LEVEL limit are ignored, you probably
  * have a bug if your nesting goes that deep.
  */
+
 #define CTX_MAX_LEVEL 255
-/* produce a warning when nesting reaches this level and then double the level */
-static int Ctx_Warn_Level = 32;  /* set to -1 to disable this feature */
+
+/*
+ * produce a warning when nesting reaches this level and then double
+ * the level
+ */
+static int Ctx_Warn_Level = 32;
 /* all descriptions has been printed up to this level */
 static Ctx_Reported_Level = -1;
 /* descriptions are still valid or active up to this level */
 static Ctx_Valid_Level = -1;
 /* current level, the number of nested ctx_enter() calls */
 static Ctx_Current_Level = -1;
 /* saved descriptions (stack) */
-static const char *Ctx_Descrs[CTX_MAX_LEVEL+1];
+static const char *Ctx_Descrs[CTX_MAX_LEVEL + 1];
 /* "safe" get secription */
 static const char *ctx_get_descr(Ctx ctx);
 
@@ -403,18 +413,17 @@ ctx_enter(const char *descr)
 	Ctx_Descrs[Ctx_Current_Level] = descr;
 
     if (Ctx_Current_Level == Ctx_Warn_Level) {
-	debug(0,0) ("# ctx: suspiciously deep (%d) nesting:\n", Ctx_Warn_Level);
+	debug(0, 0) ("# ctx: suspiciously deep (%d) nesting:\n", Ctx_Warn_Level);
 	Ctx_Warn_Level *= 2;
     }
-
     return Ctx_Current_Level;
 }
 
 void
 ctx_exit(Ctx ctx)
 {
     assert(ctx >= 0);
-    Ctx_Current_Level = (ctx >= 0) ? ctx-1 : -1;
+    Ctx_Current_Level = (ctx >= 0) ? ctx - 1 : -1;
     if (Ctx_Valid_Level > Ctx_Current_Level)
 	Ctx_Valid_Level = Ctx_Current_Level;
 }
@@ -431,9 +440,9 @@ ctx_print()
     /* ok, user saw [0,Ctx_Reported_Level] descriptions */
     /* first inform about entries popped since user saw them */
     if (Ctx_Valid_Level < Ctx_Reported_Level) {
-	if (Ctx_Reported_Level != Ctx_Valid_Level+1)
-	    _db_print("ctx: exit levels from %2d down to %2d\n", 
-		Ctx_Reported_Level, Ctx_Valid_Level+1);
+	if (Ctx_Reported_Level != Ctx_Valid_Level + 1)
+	    _db_print("ctx: exit levels from %2d down to %2d\n",
+		Ctx_Reported_Level, Ctx_Valid_Level + 1);
 	else
 	    _db_print("ctx: exit level %2d\n", Ctx_Reported_Level);
 	Ctx_Reported_Level = Ctx_Valid_Level;
@@ -442,7 +451,7 @@ ctx_print()
     while (Ctx_Reported_Level < Ctx_Current_Level) {
 	Ctx_Reported_Level++;
 	Ctx_Valid_Level++;
-	_db_print("ctx: enter level %2d: '%s'\n", Ctx_Reported_Level, 
+	_db_print("ctx: enter level %2d: '%s'\n", Ctx_Reported_Level,
 	    ctx_get_descr(Ctx_Reported_Level));
     }
     /* unlock */
@@ -453,6 +462,7 @@ ctx_print()
 static const char *
 ctx_get_descr(Ctx ctx)
 {
-    if (ctx < 0 || ctx > CTX_MAX_LEVEL) return "<lost>";
+    if (ctx < 0 || ctx > CTX_MAX_LEVEL)
+	return "<lost>";
     return Ctx_Descrs[ctx] ? Ctx_Descrs[ctx] : "<null>";
 }
@@ -52,7 +52,7 @@
 
 /* useful for temporary debuging messages, delete it later @?@ */
 #define here __FILE__,__LINE__
-#define dev_null 1 ? ((void)0) : 
+#define dev_null 1 ? ((void)0) :
 #ifdef HAVE_SYSLOG
 #define tmp_debug(fl) _db_level = 0, dev_null _db_print("%s:%d: ",fl), dev_null _db_print
 #else
@@ -45,7 +45,7 @@ typedef enum {
     ERR_ACCESS_DENIED,
     ERR_CACHE_ACCESS_DENIED,
     ERR_CACHE_MGR_ACCESS_DENIED,
-    ERR_SQUID_SIGNATURE, /* not really an error */
+    ERR_SQUID_SIGNATURE,	/* not really an error */
     ERR_MAX
 } err_type;
 
@@ -534,9 +534,9 @@ typedef enum {
 
 
 /* parse state of HttpReply or HttpRequest */
-typedef enum { 
-    psReadyToParseStartLine = 0, 
-    psReadyToParseHeaders, 
-    psParsed, 
-    psError 
+typedef enum {
+    psReadyToParseStartLine = 0,
+    psReadyToParseHeaders,
+    psParsed,
+    psError
 } HttpMsgParseState;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.118 1998/02/25 23:56:53 rousskov Exp $
+ * $Id: errorpage.cc,v 1.119 1998/02/26 18:00:42 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -42,14 +42,19 @@
  * note: hard coded error messages are not appended with %S automagically
  * to give you more control on the format
  */
-static const struct { err_type type; const char *text; } error_hard_text[] = {
-    { ERR_SQUID_SIGNATURE,
-	"\n<br clear=\"all\">\n"
-	"<hr noshade size=1>\n"
-	"Generated on %T by <a href=\"http://squid.nlanr.net/\">%s</a>@%h"
+static const struct {
+    err_type type;
+    const char *text;
+} error_hard_text[] = {
+
+    {
+	ERR_SQUID_SIGNATURE,
+	    "\n<br clear=\"all\">\n"
+	    "<hr noshade size=1>\n"
+	    "Generated on %T by <a href=\"http://squid.nlanr.net/\">%s</a>@%h"
     }
 };
-static const int error_hard_text_count = sizeof(error_hard_text)/sizeof(*error_hard_text);
+static const int error_hard_text_count = sizeof(error_hard_text) / sizeof(*error_hard_text);
 static char *error_text[ERR_MAX];
 
 static char *errorTryLoadText(err_type type, const char *dir);
@@ -135,7 +140,7 @@ errorTryLoadText(err_type type, const char *dir)
 	text = NULL;
     }
     file_close(fd);
-    strcat(text, "%S"); /* add signature */
+    strcat(text, "%S");		/* add signature */
     return text;
 }
 
@@ -442,13 +447,13 @@ errorConvert(char token, ErrorState * err)
 
 /* allocates and initializes an error response */
 HttpReply *
-errorBuildReply(ErrorState *err)
+errorBuildReply(ErrorState * err)
 {
     HttpReply *rep = httpReplyCreate();
     MemBuf content = errorBuildContent(err);
     /* no LMT for error pages; error pages expire immediately */
     httpReplySetHeaders(rep, 1.0, err->http_status, NULL, "text/html", content.size, 0, squid_curtime);
-    httpBodySet(&rep->body, content.buf, content.size+1, NULL);
+    httpBodySet(&rep->body, content.buf, content.size + 1, NULL);
     memBufClean(&content);
     return rep;
 }
@@ -457,7 +462,7 @@ static MemBuf
 errorBuildContent(ErrorState * err)
 {
     MemBuf content;
-#if 0 /* use MemBuf so we can support recursion;  const pointers: no xstrdup */
+#if 0				/* use MemBuf so we can support recursion;  const pointers: no xstrdup */
     LOCAL_ARRAY(char, content, ERROR_BUF_SZ);
     int clen;
     char *m;
@@ -469,14 +474,14 @@ errorBuildContent(ErrorState * err)
     const char *t;
     assert(err != NULL);
     assert(err->type > ERR_NONE && err->type < ERR_MAX);
-#if 0 /* use MemBuf so we can support recursion */
+#if 0				/* use MemBuf so we can support recursion */
     mx = m = xstrdup(error_text[err->type]);
 #endif
     memBufDefInit(&content);
     m = error_text[err->type];
     assert(m);
     while ((p = strchr(m, '%'))) {
-#if 0 /* use MemBuf so we can support recursion */
+#if 0				/* use MemBuf so we can support recursion */
 	*p = '\0';		/* terminate */
 	xstrncpy(content + clen, m, ERROR_BUF_SZ - clen);	/* copy */
 	clen += (p - m);	/* advance */
@@ -490,12 +495,12 @@ errorBuildContent(ErrorState * err)
 	if (clen >= ERROR_BUF_SZ)
 	    break;
 #endif
-	memBufAppend(&content, m, p - m);                       /* copy */
-	t = errorConvert(*++p, err);                         /* convert */
-	memBufPrintf(&content, "%s", t);                        /* copy */
-        m = p + 1;                                           /* advance */
+	memBufAppend(&content, m, p - m);	/* copy */
+	t = errorConvert(*++p, err);	/* convert */
+	memBufPrintf(&content, "%s", t);	/* copy */
+	m = p + 1;		/* advance */
     }
-#if 0 /* use MemBuf so we can support recursion */
+#if 0				/* use MemBuf so we can support recursion */
     if (clen < ERROR_BUF_SZ && m != NULL) {
 	xstrncpy(content + clen, m, ERROR_BUF_SZ - clen);
 	clen += strlen(m);
@@ -510,12 +515,12 @@ errorBuildContent(ErrorState * err)
     xfree(mx);
 #endif
     if (*m)
-	memBufPrintf(&content, "%s", m);                     /* copy tail */
+	memBufPrintf(&content, "%s", m);	/* copy tail */
     assert(content.size == strlen(content.buf));
     return content;
 }
 
-#if 0 /* we use httpReply instead of a buffer now */
+#if 0				/* we use httpReply instead of a buffer now */
 const char *
 errorBuildBuf(ErrorState * err, int *len)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.86 1998/02/26 09:01:12 kostas Exp $
+ * $Id: fqdncache.cc,v 1.87 1998/02/26 18:00:43 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -956,13 +956,13 @@ snmp_fqdncacheFn(variable_list * Var, long *ErrP)
 	Answer->type = SMI_TIMETICKS;
 	Answer->val_len = sizeof(long);
 	Answer->val.integer = xmalloc(Answer->val_len);
-	*(Answer->val.integer) = squid_curtime-fq->lastref;
+	*(Answer->val.integer) = squid_curtime - fq->lastref;
 	break;
     case NET_FQDN_EXPIRES:
 	Answer->type = SMI_TIMETICKS;
 	Answer->val_len = sizeof(long);
 	Answer->val.integer = xmalloc(Answer->val_len);
-	*(Answer->val.integer) = fq->expires-squid_curtime;
+	*(Answer->val.integer) = fq->expires - squid_curtime;
 	break;
     case NET_FQDN_STATE:
 	Answer->type = ASN_INTEGER;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.39 1998/02/21 00:56:56 rousskov Exp $
+ * $Id: globals.h,v 1.40 1998/02/26 18:00:43 wessels Exp $
  */
 
 extern FILE *debug_log;		/* NULL */
@@ -26,7 +26,7 @@ extern const char *const dash_str;	/* "-" */
 extern const char *const localhost;	/* "127.0.0.1" */
 extern const char *const null_string;	/* "" */
 extern const char *const version_string;	/* SQUID_VERSION */
-extern const char *const full_appname_string;   /* "Squid/" SQUID_VERSION */
+extern const char *const full_appname_string;	/* "Squid/" SQUID_VERSION */
 extern const char *const w_space;	/* " \t\n\r" */
 extern const char *fdTypeStr[];
 extern const char *hier_strings[];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.161 1998/02/26 09:01:13 kostas Exp $
+ * $Id: ipcache.cc,v 1.162 1998/02/26 18:00:44 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -1059,7 +1059,7 @@ ipcache_restart(void)
 
 #ifdef SQUID_SNMP
 
-int 
+int
 ipcache_getMax()
 {
     int i = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.226 1998/02/23 03:07:03 wessels Exp $
+ * $Id: main.cc,v 1.227 1998/02/26 18:00:45 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -441,7 +441,7 @@ mainInitialize(void)
     dnsOpenServers();
     redirectOpenServers();
     useragentOpenLog();
-    httpHeaderInitModule();     /* must go before any header processing (e.g. the one in errorInitialize) */
+    httpHeaderInitModule();	/* must go before any header processing (e.g. the one in errorInitialize) */
     errorInitialize();
     accessLogInit();
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.6 1998/02/21 00:56:58 rousskov Exp $
+ * $Id: mem.cc,v 1.7 1998/02/26 18:00:46 wessels Exp $
  *
  * DEBUG: section 13    Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -49,11 +49,11 @@ typedef struct {
 
 static memData MemData[MEM_MAX];
 
-static void * stackPop(Stack * s);
+static void *stackPop(Stack * s);
 static int stackFull(Stack * s);
 static int stackEmpty(Stack * s);
 static void stackPush(Stack * s, void *p);
-static void memDataInit(mem_type , const char *, size_t , int );
+static void memDataInit(mem_type, const char *, size_t, int);
 static OBJH memStats;
 
 static int
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.51 1998/02/22 07:45:20 rousskov Exp $
+ * $Id: mime.cc,v 1.52 1998/02/26 18:00:47 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -241,12 +241,14 @@ mime_get_auth(const char *hdr, const char *auth_scheme, const char **auth_field)
 {
     char *auth_hdr;
     char *t;
-    if (auth_field) *auth_field = NULL;
+    if (auth_field)
+	*auth_field = NULL;
     if (hdr == NULL)
 	return NULL;
     if ((auth_hdr = mime_get_header(hdr, "Authorization")) == NULL)
 	return NULL;
-    if (auth_field) *auth_field = auth_hdr;
+    if (auth_field)
+	*auth_field = auth_hdr;
     if ((t = strtok(auth_hdr, " \t")) == NULL)
 	return NULL;
     if (strcasecmp(t, auth_scheme) != 0)
@@ -451,7 +453,7 @@ mimeLoadIconFile(const char *icon)
 	METHOD_GET);
     assert(e != NULL);
     e->mem_obj->request = requestLink(urlParse(METHOD_GET, url));
-#if 0 /* use new interface */
+#if 0				/* use new interface */
     buf = memAllocate(MEM_4K_BUF, 1);
     l = 0;
     l += snprintf(buf + l, SM_PAGE_SIZE - l, "HTTP/1.0 200 OK\r\n");
@@ -466,7 +468,7 @@ mimeLoadIconFile(const char *icon)
     storeAppend(e, buf, l);
 #else
     httpReplyReset(e->mem_obj->reply);
-    httpReplySetHeaders(e->mem_obj->reply, 1.0, 200, NULL, 
+    httpReplySetHeaders(e->mem_obj->reply, 1.0, 200, NULL,
 	type, (int) sb.st_size, sb.st_mtime, squid_curtime + 86400);
     httpReplySwapOut(e->mem_obj->reply, e);
     /* read the file into the buffer and append it to store */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.69 1998/02/26 09:01:14 kostas Exp $
+ * $Id: net_db.cc,v 1.70 1998/02/26 18:00:47 wessels Exp $
  *
  * DEBUG: section 37    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -699,7 +699,7 @@ netdbUpdatePeer(request_t * r, peer * e, int irtt, int ihops)
 }
 
 #ifdef SQUID_SNMP
-int 
+int
 netdb_getMax()
 {
     int i = 0;
@@ -778,11 +778,11 @@ snmp_netdbFn(variable_list * Var, long *ErrP)
 	break;
     case NETDB_PINGTIME:
 	Answer->type = SMI_TIMETICKS;
-	*(Answer->val.integer) = (long) n->next_ping_time-squid_curtime;
+	*(Answer->val.integer) = (long) n->next_ping_time - squid_curtime;
 	break;
     case NETDB_LASTUSE:
 	Answer->type = SMI_TIMETICKS;
-	*(Answer->val.integer) = (long) squid_curtime-n->last_use_time;
+	*(Answer->val.integer) = (long) squid_curtime - n->last_use_time;
 	break;
     default:
 	*ErrP = SNMP_ERR_NOSUCHNAME;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: pconn.cc,v 1.13 1998/02/19 23:31:19 wessels Exp $
+ * $Id: pconn.cc,v 1.14 1998/02/26 18:00:48 wessels Exp $
  *
  * DEBUG: section 48    Persistent Connections
  * AUTHOR: Duane Wessels
@@ -124,27 +124,27 @@ pconnHistDump(StoreEntry * e)
 {
     int i;
     storeAppendPrintf(e,
-        "Client-side persistent connection counts:\n"
-        "\n"
-        "\treq/\n"
-        "\tconn      count\n"
-        "\t----  ---------\n");
+	"Client-side persistent connection counts:\n"
+	"\n"
+	"\treq/\n"
+	"\tconn      count\n"
+	"\t----  ---------\n");
     for (i = 0; i < PCONN_HIST_SZ; i++) {
-        if (client_pconn_hist[i] == 0)
-            continue;
-        storeAppendPrintf(e, "\t%4d  %9d\n", i, client_pconn_hist[i]);
+	if (client_pconn_hist[i] == 0)
+	    continue;
+	storeAppendPrintf(e, "\t%4d  %9d\n", i, client_pconn_hist[i]);
     }
     storeAppendPrintf(e,
-        "\n"
-        "Server-side persistent connection counts:\n"
-        "\n"
-        "\treq/\n"
-        "\tconn      count\n"
-        "\t----  ---------\n");
+	"\n"
+	"Server-side persistent connection counts:\n"
+	"\n"
+	"\treq/\n"
+	"\tconn      count\n"
+	"\t----  ---------\n");
     for (i = 0; i < PCONN_HIST_SZ; i++) {
-        if (server_pconn_hist[i] == 0)
-            continue;
-        storeAppendPrintf(e, "\t%4d  %9d\n", i, server_pconn_hist[i]);
+	if (server_pconn_hist[i] == 0)
+	    continue;
+	storeAppendPrintf(e, "\t%4d  %9d\n", i, server_pconn_hist[i]);
     }
 }
 
@@ -158,8 +158,8 @@ pconnInit(void)
     assert(table == NULL);
     table = hash_create((HASHCMP *) strcmp, 229, hash_string);
     for (i = 0; i < PCONN_HIST_SZ; i++) {
-        client_pconn_hist[i] = 0;
-        server_pconn_hist[i] = 0;
+	client_pconn_hist[i] = 0;
+	server_pconn_hist[i] = 0;
     }
     cachemgrRegister("pconn",
 	"Persistent Connection Utilization Histograms",
@@ -217,12 +217,12 @@ void
 pconnHistCount(int what, int i)
 {
     if (i >= PCONN_HIST_SZ)
-        i = PCONN_HIST_SZ - 1;
+	i = PCONN_HIST_SZ - 1;
     /* what == 0 for client, 1 for server */
     if (what == 0)
-        client_pconn_hist[i]++;
+	client_pconn_hist[i]++;
     else if (what == 1)
-        server_pconn_hist[i]++;
+	server_pconn_hist[i]++;
     else
-        assert(0);
+	assert(0);
 }
@@ -108,18 +108,18 @@ extern void comm_write(int fd,
     CWCB * handler,
     void *handler_data,
     FREE *);
-extern void comm_write_mbuf(int fd, MemBuf mb, CWCB *handler, void *handler_data);
+extern void comm_write_mbuf(int fd, MemBuf mb, CWCB * handler, void *handler_data);
 extern void commCallCloseHandlers(int fd);
 extern int commSetTimeout(int fd, int, PF *, void *);
 extern void commSetDefer(int fd, DEFER * func, void *);
 extern int ignoreErrno(int);
 
-extern void packerToStoreInit(Packer *p, StoreEntry *e);
-extern void packerToMemInit(Packer *p, MemBuf *mb);
-extern void packerClean(Packer *p);
-extern void packerAppend(Packer *p, const char *buf, int size);
+extern void packerToStoreInit(Packer * p, StoreEntry * e);
+extern void packerToMemInit(Packer * p, MemBuf * mb);
+extern void packerClean(Packer * p);
+extern void packerAppend(Packer * p, const char *buf, int size);
 #ifdef __STDC__
-extern void packerPrintf(Packer *p, const char *fmt, ...);
+extern void packerPrintf(Packer * p, const char *fmt,...);
 #else
 extern void packerPrintf();
 #endif
@@ -231,92 +231,92 @@ extern void httpInit(void);
 
 /* Http Status Line */
 /* init/clean */
-extern void httpStatusLineInit(HttpStatusLine *sline);
-extern void httpStatusLineClean(HttpStatusLine *sline);
+extern void httpStatusLineInit(HttpStatusLine * sline);
+extern void httpStatusLineClean(HttpStatusLine * sline);
 /* set values */
-extern void httpStatusLineSet(HttpStatusLine *sline, double version, 
+extern void httpStatusLineSet(HttpStatusLine * sline, double version,
     http_status status, const char *reason);
 /* parse/pack */
 /* parse a 0-terminating buffer and fill internal structires; returns true on success */
-extern int httpStatusLineParse(HttpStatusLine *sline, const char *start,
+extern int httpStatusLineParse(HttpStatusLine * sline, const char *start,
     const char *end);
 /* pack fields using Packer */
-extern void httpStatusLinePackInto(const HttpStatusLine *sline, Packer *p);
+extern void httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p);
 
 /* Http Body */
 /* init/clean */
-extern void httpBodyInit(HttpBody *body);
-extern void httpBodyClean(HttpBody *body);
+extern void httpBodyInit(HttpBody * body);
+extern void httpBodyClean(HttpBody * body);
 /* get body ptr (always use this) */
-extern const char *httpBodyPtr(const HttpBody *body);
+extern const char *httpBodyPtr(const HttpBody * body);
 /* set body, if freefunc is NULL the content will be copied, otherwise not */
-extern void httpBodySet(HttpBody *body, const char *content, int size,
-    FREE *freefunc);
+extern void httpBodySet(HttpBody * body, const char *content, int size,
+    FREE * freefunc);
 
 /* pack */
-extern void httpBodyPackInto(const HttpBody *body, Packer *p);
+extern void httpBodyPackInto(const HttpBody * body, Packer * p);
 
 
 /* Http Header */
 extern void httpHeaderInitModule();
 /* create/init/clean/destroy */
 extern HttpHeader *httpHeaderCreate();
-extern void httpHeaderInit(HttpHeader *hdr);
-extern void httpHeaderClean(HttpHeader *hdr);
-extern void httpHeaderDestroy(HttpHeader *hdr);
+extern void httpHeaderInit(HttpHeader * hdr);
+extern void httpHeaderClean(HttpHeader * hdr);
+extern void httpHeaderDestroy(HttpHeader * hdr);
 /* clone */
-HttpHeader *httpHeaderClone(HttpHeader *hdr);
+HttpHeader *httpHeaderClone(HttpHeader * hdr);
 /* parse/pack */
-extern int httpHeaderParse(HttpHeader *hdr, const char *header_start, const char *header_end);
-extern void httpHeaderPackInto(const HttpHeader *hdr, Packer *p);
+extern int httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_end);
+extern void httpHeaderPackInto(const HttpHeader * hdr, Packer * p);
 /* field manipulation */
-extern int httpHeaderHas(const HttpHeader *hdr, http_hdr_type type);
-extern void httpHeaderDel(HttpHeader *hdr, http_hdr_type id);
-extern void httpHeaderSetInt(HttpHeader *hdr, http_hdr_type type, int number);
-extern void httpHeaderSetTime(HttpHeader *hdr, http_hdr_type type, time_t time);
-extern void httpHeaderSetStr(HttpHeader *hdr, http_hdr_type type, const char *str);
-extern void httpHeaderSetAuth(HttpHeader *hdr, const char *authScheme, const char *realm);
-extern void httpHeaderAddExt(HttpHeader *hdr, const char *name, const char* value);
-extern const char *httpHeaderGetStr(const HttpHeader *hdr, http_hdr_type id);
-extern time_t httpHeaderGetTime(const HttpHeader *hdr, http_hdr_type id);
-extern HttpScc *httpHeaderGetScc(const HttpHeader *hdr);
-extern field_store httpHeaderGet(const HttpHeader *hdr, http_hdr_type id);
-int httpHeaderDelFields(HttpHeader *hdr, const char *name);
+extern int httpHeaderHas(const HttpHeader * hdr, http_hdr_type type);
+extern void httpHeaderDel(HttpHeader * hdr, http_hdr_type id);
+extern void httpHeaderSetInt(HttpHeader * hdr, http_hdr_type type, int number);
+extern void httpHeaderSetTime(HttpHeader * hdr, http_hdr_type type, time_t time);
+extern void httpHeaderSetStr(HttpHeader * hdr, http_hdr_type type, const char *str);
+extern void httpHeaderSetAuth(HttpHeader * hdr, const char *authScheme, const char *realm);
+extern void httpHeaderAddExt(HttpHeader * hdr, const char *name, const char *value);
+extern const char *httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id);
+extern time_t httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id);
+extern HttpScc *httpHeaderGetScc(const HttpHeader * hdr);
+extern field_store httpHeaderGet(const HttpHeader * hdr, http_hdr_type id);
+int httpHeaderDelFields(HttpHeader * hdr, const char *name);
 /* store report about current header usage and other stats */
-extern void httpHeaderStoreReport(StoreEntry *e);
+extern void httpHeaderStoreReport(StoreEntry * e);
 
 /* Http Reply */
 extern HttpReply *httpReplyCreate();
-extern void httpReplyInit(HttpReply *rep);
-extern void httpReplyClean(HttpReply *rep);
-extern void httpReplyDestroy(HttpReply *rep);
+extern void httpReplyInit(HttpReply * rep);
+extern void httpReplyClean(HttpReply * rep);
+extern void httpReplyDestroy(HttpReply * rep);
 /* reset: clean, then init */
-void httpReplyReset(HttpReply *rep);
+void httpReplyReset(HttpReply * rep);
 /* absorb: copy the contents of a new reply to the old one, destroy new one */
-void httpReplyAbsorb(HttpReply *rep, HttpReply *new_rep);
+void httpReplyAbsorb(HttpReply * rep, HttpReply * new_rep);
 /* parse returns -1,0,+1 on error,need-more-data,success */
-extern int httpReplyParse(HttpReply *rep, const char *buf); /*, int atEnd); */
-extern void httpReplyPackInto(const HttpReply *rep, Packer *p);
+extern int httpReplyParse(HttpReply * rep, const char *buf);	/*, int atEnd); */
+extern void httpReplyPackInto(const HttpReply * rep, Packer * p);
 /* ez-routines */
 /* mem-pack: returns a ready to use mem buffer with a packed reply */
-extern MemBuf httpReplyPack(const HttpReply *rep);
+extern MemBuf httpReplyPack(const HttpReply * rep);
 /* swap: create swap-based packer, pack, destroy packer */
-extern void httpReplySwapOut(const HttpReply *rep, StoreEntry *e);
+extern void httpReplySwapOut(const HttpReply * rep, StoreEntry * e);
 /* set commonly used info with one call */
-extern void httpReplySetHeaders(HttpReply *rep, double ver, http_status status,
+extern void httpReplySetHeaders(HttpReply * rep, double ver, http_status status,
     const char *reason, const char *ctype, int clen, time_t lmt, time_t expires);
 /* do everything in one call: init, set, pack, clean, return MemBuf */
-extern MemBuf httpPackedReply(double ver, http_status status, const char *ctype, 
+extern MemBuf httpPackedReply(double ver, http_status status, const char *ctype,
     int clen, time_t lmt, time_t expires);
 /* construct 304 reply and pack it into MemBuf, return MemBuf */
-extern MemBuf httpPacked304Reply(const HttpReply *rep);
+extern MemBuf httpPacked304Reply(const HttpReply * rep);
 /* update when 304 reply is received for a cached object */
-extern void httpReplyUpdateOnNotModified(HttpReply *rep, HttpReply *freshRep);
+extern void httpReplyUpdateOnNotModified(HttpReply * rep, HttpReply * freshRep);
 /* header manipulation, see HttpReply.c for caveats */
-extern int httpReplyContentLen(const HttpReply *rep);
-extern const char *httpReplyContentType(const HttpReply *rep);
-extern time_t httpReplyExpires(const HttpReply *rep);
-extern int httpReplyHasScc(const HttpReply *rep, http_scc_type type);
+extern int httpReplyContentLen(const HttpReply * rep);
+extern const char *httpReplyContentType(const HttpReply * rep);
+extern time_t httpReplyExpires(const HttpReply * rep);
+extern int httpReplyHasScc(const HttpReply * rep, http_scc_type type);
 
 
 extern void icmpOpen(void);
@@ -381,25 +381,25 @@ extern int ipcacheUnregister(const char *name, void *data);
 
 /* MemBuf */
 /* init with specific sizes */
-extern void memBufInit(MemBuf *mb, mb_size_t szInit, mb_size_t szMax);
+extern void memBufInit(MemBuf * mb, mb_size_t szInit, mb_size_t szMax);
 /* init with defaults */
-extern void memBufDefInit(MemBuf *mb);
+extern void memBufDefInit(MemBuf * mb);
 /* cleans the mb; last function to call if you do not give .buf away */
-extern void memBufClean(MemBuf *mb);
+extern void memBufClean(MemBuf * mb);
 /* calls memcpy, appends exactly size bytes, extends buffer if needed */
-extern void memBufAppend(MemBuf *mb, const char *buf, mb_size_t size);
+extern void memBufAppend(MemBuf * mb, const char *buf, mb_size_t size);
 /* calls snprintf, extends buffer if needed */
 #ifdef __STDC__
-extern void memBufPrintf(MemBuf *mb, const char *fmt, ...);
+extern void memBufPrintf(MemBuf * mb, const char *fmt,...);
 #else
 extern void memBufPrintf();
 #endif
 /* vprintf for other printf()'s to use */
-extern void memBufVPrintf(MemBuf *mb, const char *fmt, va_list ap);
+extern void memBufVPrintf(MemBuf * mb, const char *fmt, va_list ap);
 /* returns free() function to be used, _freezes_ the object! */
-extern FREE *memBufFreeFunc(MemBuf *mb);
+extern FREE *memBufFreeFunc(MemBuf * mb);
 /* puts report on MemBuf _module_ usage into mb */
-extern void memBufReport(MemBuf *mb);
+extern void memBufReport(MemBuf * mb);
 
 extern char *mime_get_header(const char *mime, const char *header);
 extern char *mime_headers_end(const char *mime);
@@ -453,7 +453,7 @@ extern int netdbHostHops(const char *host);
 extern int netdbHostRtt(const char *host);
 extern void netdbUpdatePeer(request_t *, peer * e, int rtt, int hops);
 
-extern void cachemgrStart(int fd, request_t *request, StoreEntry * entry);
+extern void cachemgrStart(int fd, request_t * request, StoreEntry * entry);
 extern void cachemgrRegister(const char *, const char *, OBJH *, int);
 extern void cachemgrInit(void);
 
@@ -17,13 +17,13 @@ enum {
 
 void snmpAclCheckDone(int answer, void *);
 static struct snmp_pdu *snmp_agent_response(struct snmp_pdu *PDU);
-static int community_check(char *b, oid *name, int namelen);
+static int community_check(char *b, oid * name, int namelen);
 struct snmp_session *Session;
 extern int get_median_svc(int, int);
 extern StatCounters *snmpStatGet(int);
 extern void snmp_agent_parse_done(int, snmp_request_t *);
 
-void snmpAclCheckStart(snmp_request_t *rq);
+void snmpAclCheckStart(snmp_request_t * rq);
 
 
 /* returns: 
@@ -32,93 +32,92 @@ void snmpAclCheckStart(snmp_request_t *rq);
  * 0: failed */
 
 void
-snmp_agent_parse(snmp_request_t *rq)
+snmp_agent_parse(snmp_request_t * rq)
 {
     long this_reqid;
-    u_char *buf=rq->buf;
-    int len=rq->len;
-    
+    u_char *buf = rq->buf;
+    int len = rq->len;
+
     struct snmp_pdu *PDU;
     u_char *Community;
 
     /* Now that we have the data, turn it into a PDU */
-    cbdataAdd(rq,MEM_NONE);
+    cbdataAdd(rq, MEM_NONE);
     PDU = snmp_pdu_create(0);
     Community = snmp_parse(Session, PDU, buf, len);
-    rq->community=Community;
-    rq->PDU=PDU;
-    this_reqid=PDU->reqid;
+    rq->community = Community;
+    rq->PDU = PDU;
+    this_reqid = PDU->reqid;
     debug(49, 5) ("snmp_agent_parse: reqid=%d\n", PDU->reqid);
 
     if (Community == NULL) {
 	debug(49, 8) ("snmp_agent_parse: Community == NULL\n");
 
 	snmp_free_pdu(PDU);
-    	snmp_agent_parse_done(0, rq);
+	snmp_agent_parse_done(0, rq);
 	return;
     }
     snmpAclCheckStart(rq);
 }
 
 void
-snmpAclCheckStart(snmp_request_t *rq)
+snmpAclCheckStart(snmp_request_t * rq)
 {
-	communityEntry *cp;
-	for (cp=Config.Snmp.communities;cp!=NULL;cp=cp->next) 
-		if (!strcmp(rq->community, cp->name) && cp->acls) {
-        		rq->acl_checklist= aclChecklistCreate(cp->acls,
-        			NULL,rq->from.sin_addr, NULL, NULL);
-			aclNBCheck(rq->acl_checklist,snmpAclCheckDone, rq);
-			return;
-		}
-	snmpAclCheckDone(ACCESS_ALLOWED, rq);
+    communityEntry *cp;
+    for (cp = Config.Snmp.communities; cp != NULL; cp = cp->next)
+	if (!strcmp(rq->community, cp->name) && cp->acls) {
+	    rq->acl_checklist = aclChecklistCreate(cp->acls,
+		NULL, rq->from.sin_addr, NULL, NULL);
+	    aclNBCheck(rq->acl_checklist, snmpAclCheckDone, rq);
+	    return;
+	}
+    snmpAclCheckDone(ACCESS_ALLOWED, rq);
 }
 
 void
 snmpAclCheckDone(int answer, void *data)
 {
-    snmp_request_t *rq=data;
-    u_char *outbuf=rq->outbuf;
-    
+    snmp_request_t *rq = data;
+    u_char *outbuf = rq->outbuf;
+
     struct snmp_pdu *PDU, *RespPDU;
     u_char *Community;
     variable_list *VarPtr;
     variable_list **VarPtrP;
     int ret;
-   
-    debug(49,5)("snmpAclCheckDone: called with answer=%d.\n",answer);
+
+    debug(49, 5) ("snmpAclCheckDone: called with answer=%d.\n", answer);
     rq->acl_checklist = NULL;
-    PDU=rq->PDU;
-    Community=rq->community;
+    PDU = rq->PDU;
+    Community = rq->community;
 
-    if (answer==ACCESS_DENIED) {
-		debug(49,5)("snmpAclCheckDone: failed on acl.\n");
-    		snmp_agent_parse_done(0, rq);
-		return;
+    if (answer == ACCESS_DENIED) {
+	debug(49, 5) ("snmpAclCheckDone: failed on acl.\n");
+	snmp_agent_parse_done(0, rq);
+	return;
     }
-
     for (VarPtrP = &(PDU->variables);
-        *VarPtrP;
-        VarPtrP = &((*VarPtrP)->next_variable)) {
-        VarPtr = *VarPtrP;
+	*VarPtrP;
+	VarPtrP = &((*VarPtrP)->next_variable)) {
+	VarPtr = *VarPtrP;
 
-	debug(49,5)("snmpAclCheckDone: checking.\n");
+	debug(49, 5) ("snmpAclCheckDone: checking.\n");
 	/* access check for each variable */
 
-    	if (!community_check(Community, VarPtr->name, VarPtr->name_length)) {
-		debug(49,5)("snmpAclCheckDone: failed on community_check.\n");
-    		snmp_agent_parse_done(0, rq);
-		return;
-    	}
+	if (!community_check(Community, VarPtr->name, VarPtr->name_length)) {
+	    debug(49, 5) ("snmpAclCheckDone: failed on community_check.\n");
+	    snmp_agent_parse_done(0, rq);
+	    return;
+	}
     }
-    Session->community=xstrdup(Community);
-    Session->community_len=strlen(Community);
+    Session->community = xstrdup(Community);
+    Session->community_len = strlen(Community);
     RespPDU = snmp_agent_response(PDU);
     snmp_free_pdu(PDU);
     if (RespPDU == NULL) {
 	debug(49, 8) ("snmpAclCheckDone: RespPDU == NULL. Returning code 2.\n");
-	debug(49,5)("snmpAclCheckDone: failed on RespPDU==NULL.\n");
-    	snmp_agent_parse_done(2, rq);
+	debug(49, 5) ("snmpAclCheckDone: failed on RespPDU==NULL.\n");
+	snmp_agent_parse_done(2, rq);
 	return;
     }
     debug(49, 8) ("snmpAclCheckDone: Response pdu (%x) errstat=%d reqid=%d.\n",
@@ -128,8 +127,8 @@ snmpAclCheckDone(int answer, void *data)
     ret = snmp_build(Session, RespPDU, outbuf, &rq->outlen);
     /* XXXXX Handle failure */
     snmp_free_pdu(RespPDU);
-	/* XXX maybe here */
-    debug(49,5)("snmpAclCheckDone: ok!\n");
+    /* XXX maybe here */
+    debug(49, 5) ("snmpAclCheckDone: ok!\n");
     snmp_agent_parse_done(1, rq);
 }
 
@@ -225,7 +224,6 @@ snmp_agent_response(struct snmp_pdu *PDU)
 	/* Done.  Return this PDU */
 	return (Answer);
     }				/* end SNMP_PDU_GETNEXT */
-
     debug(49, 9) ("snmp_agent_response: Ignoring PDU %d\n", PDU->command);
     snmp_free_pdu(Answer);
     return (NULL);
@@ -236,43 +234,43 @@ in_view(oid * name, int namelen, int viewIndex)
 {
     viewEntry *vwp, *savedvwp = NULL;
 
-    debug(49,8)("in_view: called with index=%d\n",viewIndex);
+    debug(49, 8) ("in_view: called with index=%d\n", viewIndex);
     for (vwp = Config.Snmp.views; vwp; vwp = vwp->next) {
-        if (vwp->viewIndex != viewIndex)
-            continue;
-	debug(49,8)("in_view: found view for subtree:\n");
+	if (vwp->viewIndex != viewIndex)
+	    continue;
+	debug(49, 8) ("in_view: found view for subtree:\n");
 	print_oid(vwp->viewSubtree, vwp->viewSubtreeLen);
-        if (vwp->viewSubtreeLen > namelen
-            || memcmp(vwp->viewSubtree, name, vwp->viewSubtreeLen * sizeof(oid)))
-            continue;
-        /* no wildcards here yet */
-        if (!savedvwp) { 
-            savedvwp = vwp; 
-        } else {
-            if (vwp->viewSubtreeLen > savedvwp->viewSubtreeLen)
-                savedvwp = vwp; 
-        }
+	if (vwp->viewSubtreeLen > namelen
+	    || memcmp(vwp->viewSubtree, name, vwp->viewSubtreeLen * sizeof(oid)))
+	    continue;
+	/* no wildcards here yet */
+	if (!savedvwp) {
+	    savedvwp = vwp;
+	} else {
+	    if (vwp->viewSubtreeLen > savedvwp->viewSubtreeLen)
+		savedvwp = vwp;
+	}
     }
     if (!savedvwp)
-        return FALSE;
+	return FALSE;
     if (savedvwp->viewType == VIEWINCLUDED)
-        return TRUE;
+	return TRUE;
     return FALSE;
 }
 
 
 static int
-community_check(char *b, oid *name, int namelen)
+community_check(char *b, oid * name, int namelen)
 {
     communityEntry *cp;
-    debug(49,8)("community_check: %s against:\n",b);
-    print_oid(name,namelen);
-    for (cp = Config.Snmp.communities; cp; cp = cp->next) 
-        if (!strcmp(b, cp->name)) {
+    debug(49, 8) ("community_check: %s against:\n", b);
+    print_oid(name, namelen);
+    for (cp = Config.Snmp.communities; cp; cp = cp->next)
+	if (!strcmp(b, cp->name)) {
 #if 0
-	    debug(49,6)("community_check: found %s, comparing with\n",cp->name);
+	    debug(49, 6) ("community_check: found %s, comparing with\n", cp->name);
 #endif
-            return in_view(name, namelen, cp->readView);
+	    return in_view(name, namelen, cp->readView);
 	}
     return 0;
 }
@@ -778,8 +776,8 @@ variable_list *
 snmp_prfProtoFn(variable_list * Var, long *ErrP)
 {
     variable_list *Answer;
-    static StatCounters *f=NULL;
-    static StatCounters *l=NULL;
+    static StatCounters *f = NULL;
+    static StatCounters *l = NULL;
     double x;
     int minutes;
 
@@ -788,8 +786,8 @@ snmp_prfProtoFn(variable_list * Var, long *ErrP)
     Answer = snmp_var_new(Var->name, Var->name_length);
     *ErrP = SNMP_ERR_NOERROR;
 
-    switch(Var->name[9]) { 
-    case PERF_PROTOSTAT_AGGR: 	/* cacheProtoAggregateStats */
+    switch (Var->name[9]) {
+    case PERF_PROTOSTAT_AGGR:	/* cacheProtoAggregateStats */
 	Answer->type = SMI_COUNTER32;
 	Answer->val_len = sizeof(long);
 	Answer->val.integer = xmalloc(Answer->val_len);
@@ -803,12 +801,12 @@ snmp_prfProtoFn(variable_list * Var, long *ErrP)
 	case PERF_PROTOSTAT_AGGR_HTTP_ERRORS:
 	    *(Answer->val.integer) = (long) Counter.client_http.errors;
 	    break;
-        case PERF_PROTOSTAT_AGGR_HTTP_KBYTES_IN:
-            *(Answer->val.integer) = (long) Counter.client_http.kbytes_in.kb;
-            break;
-        case PERF_PROTOSTAT_AGGR_HTTP_KBYTES_OUT:
-            *(Answer->val.integer) = (long) Counter.client_http.kbytes_out.kb;
-            break;
+	case PERF_PROTOSTAT_AGGR_HTTP_KBYTES_IN:
+	    *(Answer->val.integer) = (long) Counter.client_http.kbytes_in.kb;
+	    break;
+	case PERF_PROTOSTAT_AGGR_HTTP_KBYTES_OUT:
+	    *(Answer->val.integer) = (long) Counter.client_http.kbytes_out.kb;
+	    break;
 	case PERF_PROTOSTAT_AGGR_ICP_S:
 	    *(Answer->val.integer) = (long) Counter.icp.pkts_sent;
 	    break;
@@ -820,13 +818,13 @@ snmp_prfProtoFn(variable_list * Var, long *ErrP)
 	    break;
 	case PERF_PROTOSTAT_AGGR_ICP_RKB:
 	    *(Answer->val.integer) = (long) Counter.icp.kbytes_recv.kb;
-	    break; 
-        case PERF_PROTOSTAT_AGGR_REQ:
-            *(Answer->val.integer) = (long) Counter.server.requests;
-            break;
-        case PERF_PROTOSTAT_AGGR_ERRORS:
-            *(Answer->val.integer) = (long) Counter.server.errors;
-            break;
+	    break;
+	case PERF_PROTOSTAT_AGGR_REQ:
+	    *(Answer->val.integer) = (long) Counter.server.requests;
+	    break;
+	case PERF_PROTOSTAT_AGGR_ERRORS:
+	    *(Answer->val.integer) = (long) Counter.server.errors;
+	    break;
 	case PERF_PROTOSTAT_AGGR_KBYTES_IN:
 	    *(Answer->val.integer) = (long) Counter.server.kbytes_in.kb;
 	    break;
@@ -844,60 +842,60 @@ snmp_prfProtoFn(variable_list * Var, long *ErrP)
 	    snmp_var_free(Answer);
 	    return (NULL);
 	}
-    	return Answer;
+	return Answer;
     case PERF_PROTOSTAT_MEDIAN:
-	
-	minutes= Var->name[12];
 
-	f= snmpStatGet(0);
-        l= snmpStatGet(minutes);
+	minutes = Var->name[12];
+
+	f = snmpStatGet(0);
+	l = snmpStatGet(minutes);
 
-	debug(49,8)("median: min= %d, %d l= %x , f = %x\n",minutes, 
-			Var->name[11], l, f);
+	debug(49, 8) ("median: min= %d, %d l= %x , f = %x\n", minutes,
+	    Var->name[11], l, f);
 	Answer->type = SMI_INTEGER;
 	Answer->val_len = sizeof(long);
 	Answer->val.integer = xmalloc(Answer->val_len);
 
-	debug(49,8)("median: l= %x , f = %x\n",l, f);
+	debug(49, 8) ("median: l= %x , f = %x\n", l, f);
 	switch (Var->name[11]) {
-		case PERF_MEDIAN_TIME:
-			x= minutes;
-			break;
-		case PERF_MEDIAN_HTTP_ALL:
-			x = statHistDeltaMedian(&l->client_http.all_svc_time,
-        			&f->client_http.all_svc_time);
-			break;
-		case PERF_MEDIAN_HTTP_MISS:
-	    		x = statHistDeltaMedian(&l->client_http.miss_svc_time,
-        			&f->client_http.miss_svc_time);
-			break;
-		case PERF_MEDIAN_HTTP_NM:
-			x = statHistDeltaMedian(&l->client_http.nm_svc_time,
-        			&f->client_http.nm_svc_time);
-			break;
-		case PERF_MEDIAN_HTTP_HIT:
-			x = statHistDeltaMedian(&l->client_http.hit_svc_time,
-				&f->client_http.hit_svc_time);
-			break;
-		case PERF_MEDIAN_ICP_QUERY:
-			x = statHistDeltaMedian(&l->icp.query_svc_time, &f->icp.query_svc_time);
-			break;
-		case PERF_MEDIAN_ICP_REPLY:
-			x = statHistDeltaMedian(&l->icp.reply_svc_time, &f->icp.reply_svc_time);
-			break;
-		case PERF_MEDIAN_DNS:
-			x = statHistDeltaMedian(&l->dns.svc_time, &f->dns.svc_time);
-			break;
-		default:
+	case PERF_MEDIAN_TIME:
+	    x = minutes;
+	    break;
+	case PERF_MEDIAN_HTTP_ALL:
+	    x = statHistDeltaMedian(&l->client_http.all_svc_time,
+		&f->client_http.all_svc_time);
+	    break;
+	case PERF_MEDIAN_HTTP_MISS:
+	    x = statHistDeltaMedian(&l->client_http.miss_svc_time,
+		&f->client_http.miss_svc_time);
+	    break;
+	case PERF_MEDIAN_HTTP_NM:
+	    x = statHistDeltaMedian(&l->client_http.nm_svc_time,
+		&f->client_http.nm_svc_time);
+	    break;
+	case PERF_MEDIAN_HTTP_HIT:
+	    x = statHistDeltaMedian(&l->client_http.hit_svc_time,
+		&f->client_http.hit_svc_time);
+	    break;
+	case PERF_MEDIAN_ICP_QUERY:
+	    x = statHistDeltaMedian(&l->icp.query_svc_time, &f->icp.query_svc_time);
+	    break;
+	case PERF_MEDIAN_ICP_REPLY:
+	    x = statHistDeltaMedian(&l->icp.reply_svc_time, &f->icp.reply_svc_time);
+	    break;
+	case PERF_MEDIAN_DNS:
+	    x = statHistDeltaMedian(&l->dns.svc_time, &f->dns.svc_time);
+	    break;
+	default:
 #if 0
-	    		xfree(Answer->val.integer);
+	    xfree(Answer->val.integer);
 #endif
-        		*ErrP = SNMP_ERR_NOSUCHNAME;
-		        snmp_var_free(Answer);
-		        return (NULL);
+	    *ErrP = SNMP_ERR_NOSUCHNAME;
+	    snmp_var_free(Answer);
+	    return (NULL);
 	}
 	*(Answer->val.integer) = (long) x;
-    	return Answer;
+	return Answer;
     }
     *ErrP = SNMP_ERR_NOSUCHNAME;
     snmp_var_free(Answer);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.209 1998/02/26 09:01:16 kostas Exp $
+ * $Id: stat.cc,v 1.210 1998/02/26 18:00:53 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -116,7 +116,7 @@ static void statAvgDump(StoreEntry *, int minutes);
 static void statCountersInit(StatCounters *);
 static void statCountersInitSpecial(StatCounters *);
 static void statCountersClean(StatCounters *);
-static void statCountersCopy(StatCounters *dest, const StatCounters *orig);
+static void statCountersCopy(StatCounters * dest, const StatCounters * orig);
 static void statCountersDump(StoreEntry * sentry);
 static OBJH stat_io_get;
 static OBJH stat_objects_get;
@@ -134,9 +134,9 @@ static void info_get_mallstat(int, int, StoreEntry *);
 /*
  * An hour's worth, plus the 'current' counter
  */
-#if 0 /* moved to defines.h to get from snmp_oidlist.c */
+#if 0				/* moved to defines.h to get from snmp_oidlist.c */
 #define N_COUNT_HIST 61
-#endif 
+#endif
 StatCounters CountHist[N_COUNT_HIST];
 static int NCountHist = 0;
 
@@ -656,7 +656,7 @@ statInit(void)
 {
     int i;
     debug(18, 5) ("statInit: Initializing...\n");
-#if 0 /* we do it in statCountersInit */
+#if 0				/* we do it in statCountersInit */
     memset(CountHist, '\0', N_COUNT_HIST * sizeof(StatCounters));
 #endif
     for (i = 0; i < N_COUNT_HIST; i++)
@@ -702,7 +702,7 @@ statAvgTick(void *notused)
     c->cputime = rusage_cputime(&rusage);
     c->timestamp = current_time;
     /* even if NCountHist is small, we already Init()ed the tail */
-    statCountersClean(CountHist+N_COUNT_HIST-1);
+    statCountersClean(CountHist + N_COUNT_HIST - 1);
     xmemmove(p, t, (N_COUNT_HIST - 1) * sizeof(StatCounters));
 #if 0
     memcpy(t, c, sizeof(StatCounters));
@@ -712,7 +712,7 @@ statAvgTick(void *notused)
 }
 
 static void
-statCountersInit(StatCounters *C)
+statCountersInit(StatCounters * C)
 {
     assert(C);
     memset(C, 0, sizeof(*C));
@@ -723,7 +723,7 @@ statCountersInit(StatCounters *C)
 
 /* add special cases here as they arrive */
 static void
-statCountersInitSpecial(StatCounters *C)
+statCountersInitSpecial(StatCounters * C)
 {
     /*
      * HTTP svc_time hist is kept in milli-seconds; max of 3 hours.
@@ -745,7 +745,7 @@ statCountersInitSpecial(StatCounters *C)
 
 /* add special cases here as they arrive */
 void
-statCountersClean(StatCounters *C)
+statCountersClean(StatCounters * C)
 {
     assert(C);
     statHistClean(&C->client_http.all_svc_time);
@@ -759,7 +759,7 @@ statCountersClean(StatCounters *C)
 
 /* add special cases here as they arrive */
 void
-statCountersCopy(StatCounters *dest, const StatCounters *orig)
+statCountersCopy(StatCounters * dest, const StatCounters * orig)
 {
     assert(dest && orig);
     /* this should take care of all the fields, but "special" ones */
@@ -897,5 +897,5 @@ get_median_svc(int interval, int which)
 StatCounters *
 snmpStatGet(int minutes)
 {
-  return &CountHist[minutes];
+    return &CountHist[minutes];
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.386 1998/02/21 18:56:48 rousskov Exp $
+ * $Id: store.cc,v 1.387 1998/02/26 18:00:55 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -214,7 +214,7 @@ destroy_MemObject(StoreEntry * e)
     httpReplyDestroy(mem->reply);
     requestUnlink(mem->request);
     mem->request = NULL;
-    ctx_exit(ctx); /* must exit before we free mem->url */
+    ctx_exit(ctx);		/* must exit before we free mem->url */
     safe_free(mem->url);
     safe_free(mem->log_url);
     memFree(MEM_MEMOBJECT, mem);
@@ -456,7 +456,7 @@ storeAppend(StoreEntry * e, const char *buf, int len)
 	debug(20, 5) ("storeAppend: appending %d bytes for '%s'\n",
 	    len,
 	    storeKeyText(e->key));
-	tmp_debug(here) ("bytes: '%.20s'\n", buf); /* @?@ @?@ */
+	tmp_debug(here) ("bytes: '%.20s'\n", buf);	/* @?@ @?@ */
 	storeGetMemSpace(len);
 	stmemAppend(mem->data, buf, len);
 	mem->inmem_hi += len;
@@ -974,7 +974,7 @@ storeTimestampsSet(StoreEntry * entry)
 {
     time_t served_date = -1;
     HttpReply *reply = entry->mem_obj->reply;
-#if 0 /* new interface */
+#if 0				/* new interface */
     served_date = reply->date > -1 ? reply->date : squid_curtime;
     entry->expires = reply->expires;
     if (reply->last_modified > -1)
@@ -1098,7 +1098,7 @@ storeCreateMemObject(StoreEntry * e, const char *url, const char *log_url)
     e->mem_obj = new_MemObject(url, log_url);
 }
 
-#if 0 /* moved to HttpReply.c (has nothing to do with store.c) */
+#if 0				/* moved to HttpReply.c (has nothing to do with store.c) */
 void
 storeCopyNotModifiedReplyHeaders(MemObject * oldmem, MemObject * newmem)
 {
@@ -200,7 +200,7 @@ storeSwapOutFileClose(StoreEntry * e)
     MemObject *mem = e->mem_obj;
     swapout_ctrl_t *ctrlp;
     assert(mem != NULL);
-    debug(20,3)("storeSwapOutFileClose: %s\n", storeKeyText(e->key));
+    debug(20, 3) ("storeSwapOutFileClose: %s\n", storeKeyText(e->key));
     if (mem->swapout.fd < 0) {
 #if USE_ASYNC_IO
 	aioCancel(-1, e);	/* Make doubly certain pending ops are gone */
@@ -1,6 +1,4 @@
 
-
-
 struct _acl_ip_data {
     struct in_addr addr1;	/* if addr2 non-zero then its a range */
     struct in_addr addr2;
@@ -54,16 +52,16 @@ struct _snmpconf {
 };
 
 struct _snmp_request_t {
-	char *buf;
-	char *outbuf;
-	int len;
-	int sock;
-        long reqid;
-	int outlen;
-	struct sockaddr_in from;
-	struct snmp_pdu *PDU;
-	aclCheck_t *acl_checklist;
-        char *community;
+    char *buf;
+    char *outbuf;
+    int len;
+    int sock;
+    long reqid;
+    int outlen;
+    struct sockaddr_in from;
+    struct snmp_pdu *PDU;
+    aclCheck_t *acl_checklist;
+    char *community;
 };
 
 typedef struct _viewEntry {
@@ -448,7 +446,7 @@ struct _hash_table {
 struct _HttpStatusLine {
     /* public, read only */
     double version;
-    const char *reason; /* points to a _constant_ string (default or supplied), never free()d */
+    const char *reason;		/* points to a _constant_ string (default or supplied), never free()d */
     http_status status;
 };
 
@@ -458,8 +456,8 @@ struct _HttpStatusLine {
  */
 struct _HttpBody {
     /* private, never dereference these */
-    char *buf;      /* null terminating _text_ buffer, not for binary stuff */
-    FREE *freefunc; /* used to free() .buf */
+    char *buf;			/* null terminating _text_ buffer, not for binary stuff */
+    FREE *freefunc;		/* used to free() .buf */
     int size;
 };
 
@@ -482,26 +480,26 @@ union _field_store {
 
 struct _HttpHeader {
     /* public, read only */
-    int emask;           /* bits set for present entries */
+    int emask;			/* bits set for present entries */
 
     /* protected, do not use these, use interface functions instead */
-    int capacity;        /* max #entries before we have to grow */
-    int ucount;          /* #entries used, including holes */
+    int capacity;		/* max #entries before we have to grow */
+    int ucount;			/* #entries used, including holes */
     HttpHeaderEntry *entries;
 };
 
 
 struct _HttpReply {
     /* unsupported, writable, may disappear/change in the future */
-    int hdr_sz;   /* sums _stored_ status-line, headers, and <CRLF> */
+    int hdr_sz;			/* sums _stored_ status-line, headers, and <CRLF> */
 
     /* public, readable */
-    HttpMsgParseState pstate; /* the current parsing state */
+    HttpMsgParseState pstate;	/* the current parsing state */
 
     /* public, writable, but use interfaces below when possible */
     HttpStatusLine sline;
     HttpHeader hdr;
-    HttpBody body;  /* used for small constant memory-resident text bodies only */
+    HttpBody body;		/* used for small constant memory-resident text bodies only */
 };
 
 
@@ -831,20 +829,20 @@ struct _iostats {
 struct _MemBuf {
     /* public, read-only */
     char *buf;
-    mb_size_t size;  /* used space, does not count 0-terminator */
+    mb_size_t size;		/* used space, does not count 0-terminator */
 
     /* private, stay away; use interface function instead */
-    mb_size_t max_capacity; /* when grows: assert(new_capacity <= max_capacity) */
-    mb_size_t capacity;     /* allocated space */
-    FREE *freefunc;  /* what to use to free the buffer, NULL after memBufFreeFunc() is called */
+    mb_size_t max_capacity;	/* when grows: assert(new_capacity <= max_capacity) */
+    mb_size_t capacity;		/* allocated space */
+    FREE *freefunc;		/* what to use to free the buffer, NULL after memBufFreeFunc() is called */
 };
 
 /* see Packer.c for description */
 struct _Packer {
     /* protected, use interface functions instead */
     append_f append;
     vprintf_f vprintf;
-    void *real_handler; /* first parameter to real append and vprintf */
+    void *real_handler;		/* first parameter to real append and vprintf */
 };
 
 
@@ -1021,8 +1019,8 @@ struct _StatHist {
     double min;
     double max;
     double scale;
-    hbase_f val_in;   /* e.g., log() for log-based histogram */
-    hbase_f val_out;  /* e.g., exp() for log based histogram */
+    hbase_f val_in;		/* e.g., log() for log-based histogram */
+    hbase_f val_out;		/* e.g., exp() for log based histogram */
 };
 
 /*
@@ -42,7 +42,7 @@ typedef struct _fileMap fileMap;
 typedef struct _fqdncache_entry fqdncache_entry;
 typedef struct _hash_link hash_link;
 typedef struct _hash_table hash_table;
-#if 0 /* use new interfaces */
+#if 0				/* use new interfaces */
 typedef struct _http_reply http_reply;
 #else
 typedef struct _HttpReply http_reply;
@@ -127,15 +127,15 @@ typedef void OBJH(StoreEntry *);
 typedef void SIGHDLR(int sig);
 typedef void STVLDCB(void *, int, int);
 
-typedef double (*hbase_f)(double);
-typedef void (*StatHistBinDumper)(StoreEntry *, int idx, double val, double size, int count);
+typedef double (*hbase_f) (double);
+typedef void (*StatHistBinDumper) (StoreEntry *, int idx, double val, double size, int count);
 
 /* append/vprintf's for Packer */
-typedef void (*append_f)(void *, const char *buf, int size);
+typedef void (*append_f) (void *, const char *buf, int size);
 #ifdef __STDC__
-typedef void (*vprintf_f)(void *, const char *fmt, ...);
+typedef void (*vprintf_f) (void *, const char *fmt,...);
 #else
-typedef void (*vprintf_f)();
+typedef void (*vprintf_f) ();
 #endif
 
 /* MD5 cache keys */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.80 1998/02/25 07:12:18 wessels Exp $
+ * $Id: url.cc,v 1.81 1998/02/26 18:00:59 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -60,18 +60,18 @@ const char *ProtocolStr[] =
 static int url_ok[256];
 static const char *const hex = "0123456789abcdef";
 static request_t *urnParse(method_t method, char *urn);
-static const char *const valid_hostname_chars = 
+static const char *const valid_hostname_chars =
 #if ALLOW_HOSTNAME_UNDERSCORES
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-        "abcdefghijklmnopqrstuvwxyz"
-        "0123456789-._";
+"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+"abcdefghijklmnopqrstuvwxyz"
+"0123456789-._";
 #else
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-        "abcdefghijklmnopqrstuvwxyz"
-        "0123456789-.";
+"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+"abcdefghijklmnopqrstuvwxyz"
+"0123456789-.";
 #endif
-static const char *const valid_url_chars = 
-    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
+static const char *const valid_url_chars =
+"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
 
 /* convert %xx in url string to a character 
  * Allocate a new string and return a pointer to converted string */
@@ -107,9 +107,9 @@ urlInitialize(void)
     int i;
     debug(23, 5) ("urlInitialize: Initializing...\n");
     assert(sizeof(ProtocolStr) == (PROTO_MAX + 1) * sizeof(char *));
-    for (i=0; i<256; i++)
+    for (i = 0; i < 256; i++)
 	url_ok[i] = strchr(valid_url_chars, (char) i) ? 1 : 0;
-	
+
 }
 
 /* Encode prohibited char in string */
@@ -247,8 +247,8 @@ urlParse(method_t method, char *url)
     for (t = host; *t; t++)
 	*t = tolower(*t);
     if (strspn(host, valid_hostname_chars) != strlen(host)) {
-        debug(23, 1)("urlParse: Illegal character in hostname '%s'\n", host);
-        return NULL;
+	debug(23, 1) ("urlParse: Illegal character in hostname '%s'\n", host);
+	return NULL;
     }
     /* remove trailing dots from hostnames */
     while ((l = strlen(host)) > 0 && host[--l] == '.')
@@ -245,8 +245,8 @@ urnHandleReply(void *data, char *buf, ssize_t size)
 	"</ADDRESS>\n",
 	appname, version_string, getMyHostname());
     stringAppend(S, line, l);
-#if 0 /* use new interface */ 
-   hdr = httpReplyHeader(1.0,
+#if 0				/* use new interface */
+    hdr = httpReplyHeader(1.0,
 	HTTP_MOVED_TEMPORARILY,
 	"text/html",
 	stringLength(S),
@@ -269,11 +269,10 @@ urnHandleReply(void *data, char *buf, ssize_t size)
 	"text/html", stringLength(S), 0, squid_curtime);
     if (EBIT_TEST(urnState->flags, URN_FORCE_MENU)) {
 	debug(51, 3) ("urnHandleReply: forcing menu\n");
-    } else
-    if (min_w) {
+    } else if (min_w) {
 	httpHeaderSetStr(&rep->hdr, HDR_LOCATION, min_w->key);
     }
-    httpBodySet(&rep->body, S->buf, stringLength(S)+1, NULL);
+    httpBodySet(&rep->body, S->buf, stringLength(S) + 1, NULL);
     httpReplySwapOut(rep, e);
 #endif
     storeComplete(e);