----++++src/client_side.cc
@@ -2603,7 +2603,7 @@ Squid_SSL_accept(ConnStateData *conn, PF *callback)
                 debugs(83, 2, &quot;Error negotiating SSL connection on FD &quot; &lt;&lt; fd &lt;&lt; &quot;: Aborted by client: &quot; &lt;&lt; ssl_error);
             } else {
                 debugs(83, (xerrno == ECONNRESET) ? 1 : 2, &quot;Error negotiating SSL connection on FD &quot; &lt;&lt; fd &lt;&lt; &quot;: &quot; &lt;&lt;
-                       (xerrno == 0 ? ERR_error_string(ssl_error, NULL) : xstrerr(xerrno)));
+                       (xerrno == 0 ? Security::ErrorString(ssl_error) : xstrerr(xerrno)));
             }
             return -1;
 
@@ -2613,7 +2613,7 @@ Squid_SSL_accept(ConnStateData *conn, PF *callback)
 
         default:
             debugs(83, DBG_IMPORTANT, &quot;Error negotiating SSL connection on FD &quot; &lt;&lt;
-                   fd &lt;&lt; ": " &lt;&lt; ERR_error_string(ERR_get_error(), NULL) &lt;&lt;
+                   fd &lt;&lt; ": " &lt;&lt; Security::ErrorString(ERR_get_error()) &lt;&lt;
                    &quot; (&quot; &lt;&lt; ssl_error &lt;&lt; &quot;/&quot; &lt;&lt; ret &lt;&lt; &quot;)&quot;);
             return -1;
         }
----++++src/security/PeerConnector.cc
@@ -104,9 +104,11 @@ Security::PeerConnector::initialize(Security::SessionPointer &amp;serverSession)
     assert(ctx);
 
     if (!Ssl::CreateClient(ctx, serverConnection(), &quot;server https start&quot;)) {
+        const auto xerrno = errno;
+        const auto ssl_error = ERR_get_error();
         ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request.getRaw());
-        anErr-&gt;xerrno = errno;
-        debugs(83, DBG_IMPORTANT, "Error allocating TLS handle: " &lt;&lt; ERR_error_string(ERR_get_error(), NULL));
+        anErr-&gt;xerrno = xerrno;
+        debugs(83, DBG_IMPORTANT, "Error allocating TLS handle: " &lt;&lt; Security::ErrorString(ssl_error));
         noteNegotiationDone(anErr);
         bail(anErr);
         return false;
@@ -443,7 +445,7 @@ Security::PeerConnector::noteNegotiationError(const int ret, const int ssl_error
 
     const int fd = serverConnection()-&gt;fd;
     debugs(83, DBG_IMPORTANT, &quot;Error negotiating SSL on FD &quot; &lt;&lt; fd &lt;&lt;
-           ": " &lt;&lt; ERR_error_string(ssl_lib_error, NULL) &lt;&lt; " (" &lt;&lt;
+           ": " &lt;&lt; Security::ErrorString(ssl_lib_error) &lt;&lt; " (" &lt;&lt;
            ssl_error &lt;&lt; &quot;/&quot; &lt;&lt; ret &lt;&lt; &quot;/&quot; &lt;&lt; errno &lt;&lt; &quot;)&quot;);
 
     ErrorState *anErr = NULL;
----++++src/security/PeerOptions.cc
@@ -228,16 +228,16 @@ Security::PeerOptions::createBlankContext() const
     SSL_CTX *t = SSL_CTX_new(SSLv23_client_method());
 #endif
     if (!t) {
-        const auto x = ERR_error_string(ERR_get_error(), nullptr);
-        fatalf("Failed to allocate TLS client context: %s\n", x);
+        const auto x = ERR_get_error();
+        fatalf("Failed to allocate TLS client context: %s\n", Security::ErrorString(x));
     }
     ctx.resetWithoutLocking(t);
 
 #elif USE_GNUTLS
     // Initialize for X.509 certificate exchange
     gnutls_certificate_credentials_t t;
     if (const int x = gnutls_certificate_allocate_credentials(&amp;t)) {
-        fatalf("Failed to allocate TLS client context: error=%d\n", x);
+        fatalf("Failed to allocate TLS client context: %s\n", Security::ErrorString(x));
     }
     ctx.resetWithoutLocking(t);
 
@@ -574,12 +574,12 @@ loadSystemTrustedCa(Security::ContextPointer &amp;ctx)
 {
 #if USE_OPENSSL
     if (SSL_CTX_set_default_verify_paths(ctx.get()) == 0)
-        return ERR_error_string(ERR_get_error(), nullptr);
+        return Security::ErrorString(ERR_get_error());
 
 #elif USE_GNUTLS
     auto x = gnutls_certificate_set_x509_system_trust(ctx.get());
     if (x &lt; 0)
-        return gnutls_strerror(x);
+        return Security::ErrorString(x);
 
 #endif
     return nullptr;
@@ -595,12 +595,15 @@ Security::PeerOptions::updateContextCa(Security::ContextPointer &amp;ctx)
     for (auto i : caFiles) {
 #if USE_OPENSSL
         if (!SSL_CTX_load_verify_locations(ctx.get(), i.c_str(), path)) {
-            const int ssl_error = ERR_get_error();
-            debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate locations: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
+            const auto x = ERR_get_error();
+            debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate location &quot; &lt;&lt;
+                   i &lt;&lt; &quot;: &quot; &lt;&lt; Security::ErrorString(x));
         }
 #elif USE_GNUTLS
-        if (gnutls_certificate_set_x509_trust_file(ctx.get(), i.c_str(), GNUTLS_X509_FMT_PEM) &lt; 0) {
-            debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate location: &quot; &lt;&lt; i);
+        const auto x = gnutls_certificate_set_x509_trust_file(ctx.get(), i.c_str(), GNUTLS_X509_FMT_PEM);
+        if (x &lt; 0) {
+            debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate location &quot; &lt;&lt;
+                   i &lt;&lt; &quot;: &quot; &lt;&lt; Security::ErrorString(x));
         }
 #endif
     }
----++++src/security/ServerOptions.cc
@@ -98,16 +98,16 @@ Security::ServerOptions::createBlankContext() const
     SSL_CTX *t = SSL_CTX_new(SSLv23_server_method());
 #endif
     if (!t) {
-        const auto x = ERR_error_string(ERR_get_error(), nullptr);
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: " &lt;&lt; x);
+        const auto x = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: " &lt;&lt; Security::ErrorString(x));
     }
     ctx.resetWithoutLocking(t);
 
 #elif USE_GNUTLS
     // Initialize for X.509 certificate exchange
     gnutls_certificate_credentials_t t;
     if (const int x = gnutls_certificate_allocate_credentials(&amp;t)) {
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: error=" &lt;&lt; x);
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: " &lt;&lt; Security::ErrorString(x));
     }
     ctx.resetWithoutLocking(t);
 
@@ -183,14 +183,14 @@ Security::ServerOptions::updateContextEecdh(Security::ContextPointer &amp;ctx)
 
         auto ecdh = EC_KEY_new_by_curve_name(nid);
         if (!ecdh) {
-            auto ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Unable to configure Ephemeral ECDH: " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            const auto x = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Unable to configure Ephemeral ECDH: " &lt;&lt; Security::ErrorString(x));
             return;
         }
 
         if (!SSL_CTX_set_tmp_ecdh(ctx.get(), ecdh)) {
-            auto ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Unable to set Ephemeral ECDH: " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            const auto x = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Unable to set Ephemeral ECDH: " &lt;&lt; Security::ErrorString(x));
         }
         EC_KEY_free(ecdh);
 
----++++src/security/Session.cc
@@ -43,7 +43,7 @@ Security::MaybeGetSessionResumeData(const Security::SessionPointer &amp;s, Security:
         gnutls_datum_t *tmp = nullptr;
         const auto x = gnutls_session_get_data2(s.get(), tmp);
         if (x != GNUTLS_E_SUCCESS) {
-            debugs(83, 3, "session=" &lt;&lt; (void*)s.get() &lt;&lt; " error: " &lt;&lt; gnutls_strerror(x));
+            debugs(83, 3, "session=" &lt;&lt; (void*)s.get() &lt;&lt; " error: " &lt;&lt; Security::ErrorString(x));
         }
         data.reset(tmp);
 #endif
@@ -61,13 +61,13 @@ Security::SetSessionResumeData(const Security::SessionPointer &amp;s, const Security
         if (!SSL_set_session(s.get(), data.get())) {
             const auto ssl_error = ERR_get_error();
             debugs(83, 3, &quot;session=&quot; &lt;&lt; (void*)s.get() &lt;&lt; &quot; data=&quot; &lt;&lt; (void*)data.get() &lt;&lt;
-                   " resume error: " &lt;&lt; ERR_error_string(ssl_error, nullptr));
+                   " resume error: " &lt;&lt; Security::ErrorString(ssl_error));
         }
 #elif USE_GNUTLS
         const auto x = gnutls_session_set_data(s.get(), data-&gt;data, data-&gt;size);
         if (x != GNUTLS_E_SUCCESS) {
             debugs(83, 3, &quot;session=&quot; &lt;&lt; (void*)s.get() &lt;&lt; &quot; data=&quot; &lt;&lt; (void*)data.get() &lt;&lt;
-                   " resume error: " &lt;&lt; gnutls_strerror(x));
+                   " resume error: " &lt;&lt; Security::ErrorString(x));
         }
 #else
         // critical because, how did it get here?
----++++src/security/forward.h
@@ -13,12 +13,13 @@
 #include &quot;security/Context.h&quot;
 #include &quot;security/Session.h&quot;
 
-#if USE_GNUTLS
-#if HAVE_GNUTLS_X509_H
+#if USE_GNUTLS &amp;&amp; HAVE_GNUTLS_X509_H
 #include &lt;gnutls/x509.h&gt;
 #endif
-#endif
 #include &lt;list&gt;
+#if USE_OPENSSL &amp;&amp; HAVE_OPENSSL_ERR_H
+#include &lt;openssl/err.h&gt;
+#endif
 #include &lt;unordered_set&gt;
 
 #if USE_OPENSSL
@@ -93,6 +94,16 @@ class EncryptorAnswer;
 /// Squid defined error code (&lt;0), an error code returned by X.509 API, or SSL_ERROR_NONE
 typedef int ErrorCode;
 
+inline const char *ErrorString(const ErrorCode code) {
+#if USE_OPENSSL
+    return ERR_error_string(code, nullptr);
+#elif USE_GNUTLS
+    return gnutls_strerror(code);
+#else
+    return &quot;[no TLS library]&quot;;
+#endif
+}
+
 /// set of Squid defined TLS error codes
 /// \note using std::unordered_set ensures values are unique, with fast lookup
 typedef std::unordered_set&lt;Security::ErrorCode&gt; Errors;
----++++src/ssl/ErrorDetail.cc
@@ -553,7 +553,7 @@ const char *Ssl::ErrorDetail::err_lib_error() const
     if (errReason.size() &gt; 0)
         return errReason.termedBuf();
     else if (lib_error_no != SSL_ERROR_NONE)
-        return ERR_error_string(lib_error_no, NULL);
+        return Security::ErrorString(lib_error_no);
     else
         return &quot;[No Error]&quot;;
 }
@@ -564,7 +564,7 @@ const char *Ssl::ErrorDetail::err_lib_error() const
  * Error meta information:
  * %err_name: The name of a high-level SSL error (e.g., X509_V_ERR_*)
  * %ssl_error_descr: A short description of the SSL error
- * %ssl_lib_error: human-readable low-level error string by ERR_error_string(3SSL)
+ * %ssl_lib_error: human-readable low-level error string by Security::ErrorString()
  *
  * Certificate information extracted from broken (not necessarily peer!) cert
  * %ssl_cn: The comma-separated list of common and alternate names
----++++src/ssl/PeekingPeerConnector.cc
@@ -308,7 +308,7 @@ Ssl::PeekingPeerConnector::noteNegotiationError(const int result, const int ssl_
             (srvBio-&gt;bumpMode() == Ssl::bumpPeek  || srvBio-&gt;bumpMode() == Ssl::bumpStare) &amp;&amp; srvBio-&gt;holdWrite()) {
         Security::CertPointer serverCert(SSL_get_peer_certificate(session.get()));
         if (serverCert) {
-            debugs(81, 3, "Error ("  &lt;&lt; ERR_error_string(ssl_lib_error, NULL) &lt;&lt;  ") but, hold write on SSL connection on FD " &lt;&lt; fd);
+            debugs(81, 3, "Error ("  &lt;&lt; Security::ErrorString(ssl_lib_error) &lt;&lt;  ") but, hold write on SSL connection on FD " &lt;&lt; fd);
             checkForPeekAndSplice();
             return;
         }
----++++src/ssl/support.cc
@@ -455,7 +455,7 @@ Ssl::Initialize(void)
 
         if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
             const int ssl_error = ERR_get_error();
-            fatalf("Failed to initialise SSL engine: %s\n", ERR_error_string(ssl_error, NULL));
+            fatalf("Failed to initialise SSL engine: %s\n", Security::ErrorString(ssl_error));
         }
     }
 #else
@@ -519,7 +519,7 @@ configureSslContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
 
         if (!SSL_CTX_set_cipher_list(ctx.get(), port.secure.sslCipher.c_str())) {
             ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" &lt;&lt; port.secure.sslCipher &lt;&lt; "': " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" &lt;&lt; port.secure.sslCipher &lt;&lt; "': " &lt;&lt; Security::ErrorString(ssl_error));
             return false;
         }
     }
@@ -536,7 +536,7 @@ configureSslContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
             SSL_CTX_set_client_CA_list(ctx.get(), clientca);
         } else {
             ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Failed to dupe the client CA list: " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to dupe the client CA list: " &lt;&lt; Security::ErrorString(ssl_error));
             return false;
         }
 
@@ -572,14 +572,14 @@ Ssl::InitServerContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
     if (!SSL_CTX_use_certificate(ctx.get(), port.signingCert.get())) {
         const int ssl_error = ERR_get_error();
         const auto &amp;keys = port.secure.certs.front();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS certificate '" &lt;&lt; keys.certFile &lt;&lt; "': " &lt;&lt; ERR_error_string(ssl_error, NULL));
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS certificate '" &lt;&lt; keys.certFile &lt;&lt; "': " &lt;&lt; Security::ErrorString(ssl_error));
         return false;
     }
 
     if (!SSL_CTX_use_PrivateKey(ctx.get(), port.signPkey.get())) {
         const int ssl_error = ERR_get_error();
         const auto &amp;keys = port.secure.certs.front();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS private key '" &lt;&lt; keys.privateKeyFile &lt;&lt; "': " &lt;&lt; ERR_error_string(ssl_error, NULL));
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS private key '" &lt;&lt; keys.privateKeyFile &lt;&lt; "': " &lt;&lt; Security::ErrorString(ssl_error));
         return false;
     }
 
@@ -590,7 +590,7 @@ Ssl::InitServerContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
 
         if (!SSL_CTX_use_certificate_chain_file(ctx.get(), certfile)) {
             ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" &lt;&lt; certfile &lt;&lt; "': " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" &lt;&lt; certfile &lt;&lt; "': " &lt;&lt; Security::ErrorString(ssl_error));
             return false;
         }
 
@@ -599,7 +599,7 @@ Ssl::InitServerContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
 
         if (!SSL_CTX_use_PrivateKey_file(ctx.get(), keyfile, SSL_FILETYPE_PEM)) {
             ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" &lt;&lt; keyfile &lt;&lt; "': " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" &lt;&lt; keyfile &lt;&lt; "': " &lt;&lt; Security::ErrorString(ssl_error));
             return false;
         }
 
@@ -608,7 +608,7 @@ Ssl::InitServerContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
         if (!SSL_CTX_check_private_key(ctx.get())) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, &quot;ERROR: SSL private key &#39;&quot; &lt;&lt; certfile &lt;&lt; &quot;&#39; does not match public key &#39;&quot; &lt;&lt;
-                   keyfile &lt;&lt; "': " &lt;&lt; ERR_error_string(ssl_error, NULL));
+                   keyfile &lt;&lt; "': " &lt;&lt; Security::ErrorString(ssl_error));
             return false;
         }
     */
@@ -640,7 +640,7 @@ Ssl::InitClientContext(Security::ContextPointer &amp;ctx, Security::PeerOptions &amp;pee
         if (!SSL_CTX_set_cipher_list(ctx.get(), cipher)) {
             const int ssl_error = ERR_get_error();
             fatalf(&quot;Failed to set SSL cipher suite &#39;%s&#39;: %s\n&quot;,
-                   cipher, ERR_error_string(ssl_error, NULL));
+                   cipher, Security::ErrorString(ssl_error));
         }
     }
 
@@ -654,7 +654,7 @@ Ssl::InitClientContext(Security::ContextPointer &amp;ctx, Security::PeerOptions &amp;pee
             if (!SSL_CTX_use_certificate_chain_file(ctx.get(), certfile)) {
                 const int ssl_error = ERR_get_error();
                 fatalf(&quot;Failed to acquire SSL certificate &#39;%s&#39;: %s\n&quot;,
-                       certfile, ERR_error_string(ssl_error, NULL));
+                       certfile, Security::ErrorString(ssl_error));
             }
 
             debugs(83, DBG_IMPORTANT, &quot;Using private key in &quot; &lt;&lt; keys.privateKeyFile);
@@ -664,15 +664,15 @@ Ssl::InitClientContext(Security::ContextPointer &amp;ctx, Security::PeerOptions &amp;pee
             if (!SSL_CTX_use_PrivateKey_file(ctx.get(), keyfile, SSL_FILETYPE_PEM)) {
                 const int ssl_error = ERR_get_error();
                 fatalf(&quot;Failed to acquire SSL private key &#39;%s&#39;: %s\n&quot;,
-                       keyfile, ERR_error_string(ssl_error, NULL));
+                       keyfile, Security::ErrorString(ssl_error));
             }
 
             debugs(83, 5, &quot;Comparing private and public SSL keys.&quot;);
 
             if (!SSL_CTX_check_private_key(ctx.get())) {
                 const int ssl_error = ERR_get_error();
                 fatalf(&quot;SSL private key &#39;%s&#39; does not match public key &#39;%s&#39;: %s\n&quot;,
-                       certfile, keyfile, ERR_error_string(ssl_error, NULL));
+                       certfile, keyfile, Security::ErrorString(ssl_error));
             }
         }
     }
@@ -978,7 +978,7 @@ Ssl::chainCertificatesToSSLContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg
         X509_up_ref(signingCert);
     } else {
         const int ssl_error = ERR_get_error();
-        debugs(33, DBG_IMPORTANT, "WARNING: can not add signing certificate to SSL context chain: " &lt;&lt; ERR_error_string(ssl_error, NULL));
+        debugs(33, DBG_IMPORTANT, "WARNING: can not add signing certificate to SSL context chain: " &lt;&lt; Security::ErrorString(ssl_error));
     }
     Ssl::addChainToSslContext(ctx, port.certsToChain.get());
 }
@@ -1069,7 +1069,7 @@ Ssl::setClientSNI(SSL *ssl, const char *fqdn)
     if (!SSL_set_tlsext_host_name(ssl, fqdn)) {
         const int ssl_error = ERR_get_error();
         debugs(83, 3,  &quot;WARNING: unable to set TLS servername extension (SNI): &quot; &lt;&lt;
-               ERR_error_string(ssl_error, NULL) &lt;&lt; "\n");
+               Security::ErrorString(ssl_error) &lt;&lt; "\n");
         return false;
     }
     return true;
@@ -1092,7 +1092,7 @@ Ssl::addChainToSslContext(Security::ContextPointer &amp;ctx, STACK_OF(X509) *chain)
             X509_up_ref(cert);
         } else {
             const int ssl_error = ERR_get_error();
-            debugs(83, DBG_IMPORTANT, "WARNING: can not add certificate to SSL context chain: " &lt;&lt; ERR_error_string(ssl_error, NULL));
+            debugs(83, DBG_IMPORTANT, "WARNING: can not add certificate to SSL context chain: " &lt;&lt; Security::ErrorString(ssl_error));
         }
     }
 }
@@ -1439,7 +1439,7 @@ SslCreate(const Security::ContextPointer &amp;ctx, const Comm::ConnectionPointer &amp;co
     }
 
     debugs(83, DBG_IMPORTANT, &quot;ERROR: &quot; &lt;&lt; squidCtx &lt;&lt; &#39; &#39; &lt;&lt; errAction &lt;&lt;
-           ": " &lt;&lt; ERR_error_string(errCode, NULL));
+           ": " &lt;&lt; Security::ErrorString(errCode));
     return false;
 }
 
----++++GitHub