@@ -901,8 +901,10 @@ AC_MSG_RESULT([$squid_opt_use_ecap, explicitly])
     ]
 )
 
+dnl Necessary if the first PKG_CHECK_MODULES call is conditional
+PKG_PROG_PKG_CONFIG
+
 dnl Perform configuration consistency checks for eCAP
-ECAPLIB=""
 if test "x$squid_opt_use_ecap" = "xyes";
 then
     dnl eCAP support requires loadable modules, which are enabled by default
@@ -911,27 +913,25 @@ then
         AC_MSG_ERROR([eCAP support requires loadable modules. Please do not use --disable-loadable-modules with --enable-ecap.]);
     fi
 
-    dnl eCAP support requires libecap
-    AC_CHECK_LIB([ecap], [main],
-        [ECAPLIB="-lecap"],
-        [AC_MSG_FAILURE([eCAP support requires libecap library, but no usable library was found])]
-    )
+    dnl eCAP support requires libecap.
+    dnl This Squid supports libecap v0.2.x.
+    dnl Use EXT_ prefix to distinguish external libecap (that we check for
+    dnl here) from our own convenience ecap library in Makefiles.
+    PKG_CHECK_MODULES(EXT_LIBECAP, [libecap > 0.2 libecap < 0.3])
 fi
 
 AM_CONDITIONAL(USE_ECAP, test "x$squid_opt_use_ecap" = "xyes")
 if test "x$squid_opt_use_ecap" = "xyes";
 then
     AC_DEFINE(USE_ECAP,1,[Enable eCAP support])
-    ECAP_LIBS="ecap/libecap.la $ECAP_LIBS"
+    ECAP_LIBS="ecap/libsquid-ecap.la"
     squid_opt_use_adaptation=yes
 else
     AC_DEFINE(USE_ECAP,0,[Disable eCAP support])
     ECAP_LIBS=""
 fi
 dnl convenience library
 AC_SUBST(ECAP_LIBS)
-dnl -lecap if needed
-AC_SUBST(ECAPLIB)
 
 
 dnl enable adaptation if requested by specific adaptation mechanisms
@@ -155,8 +155,8 @@ class AccessLogEntry
         Headers() : request(NULL),
                 adapted_request(NULL),
 
-#if ICAP_CLIENT
-                icap(NULL),
+#if USE_ADAPTATION
+                adapt_last(NULL),
 #endif
                 reply(NULL) {}
 
@@ -165,8 +165,9 @@ class AccessLogEntry
         char *adapted_request; //< HTTP request headers after adaptation and redirection
 
 
-#if ICAP_CLIENT
-        char * icap;    ///< last matching ICAP response header.
+#if USE_ADAPTATION
+
+        char *adapt_last; ///< last ICAP response header or eCAP meta received
 #endif
         char *reply;
     } headers;
@@ -10,24 +10,25 @@ CBDATA_CLASS_INIT(BodyPipe);
 // data from a BodyPipe
 class BodySink: public BodyConsumer
 {
-    bool done;
 public:
-    BodySink():AsyncJob("BodySink"), done(false) {}
-    virtual ~BodySink() {}
+    BodySink(const BodyPipe::Pointer &bp): AsyncJob("BodySink"), body_pipe(bp) {}
+    virtual ~BodySink() { assert(!body_pipe); }
 
     virtual void noteMoreBodyDataAvailable(BodyPipe::Pointer bp) {
         size_t contentSize = bp->buf().contentSize();
         bp->consume(contentSize);
     }
     virtual void noteBodyProductionEnded(BodyPipe::Pointer bp) {
-        stopConsumingFrom(bp);
-        done = true;
+        stopConsumingFrom(body_pipe);
     }
     virtual void noteBodyProducerAborted(BodyPipe::Pointer bp) {
-        stopConsumingFrom(bp);
-        done = true;
+        stopConsumingFrom(body_pipe);
     }
-    bool doneAll() const {return done && AsyncJob::doneAll();}
+    bool doneAll() const {return !body_pipe && AsyncJob::doneAll();}
+
+private:
+    BodyPipe::Pointer body_pipe; ///< the pipe we are consuming from
+
     CBDATA_CLASS2(BodySink);
 };
 
@@ -317,7 +318,7 @@ BodyPipe::startAutoConsumption()
 {
     Must(mustAutoConsume);
     Must(!theConsumer);
-    theConsumer = new BodySink;
+    theConsumer = new BodySink(this);
     debugs(91,7, HERE << "starting auto consumption" << status());
     scheduleBodyDataNotification();
 }
@@ -33,6 +33,7 @@
  */
 
 #include "squid.h"
+#include "acl/Gadgets.h"
 #include "base/TextException.h"
 #include "comm/Write.h"
 #include "Server.h"
@@ -660,10 +661,28 @@ ServerStateData::noteBodyConsumerAborted(BodyPipe::Pointer)
 
 // received adapted response headers (body may follow)
 void
-ServerStateData::noteAdaptationAnswer(HttpMsg *msg)
+ServerStateData::noteAdaptationAnswer(const Adaptation::Answer &answer)
 {
     clearAdaptation(adaptedHeadSource); // we do not expect more messages
 
+    switch (answer.kind) {
+    case Adaptation::Answer::akForward:
+        handleAdaptedHeader(answer.message);
+        break;
+
+    case Adaptation::Answer::akBlock:
+        handleAdaptationBlocked(answer);
+        break;
+
+    case Adaptation::Answer::akError:
+        handleAdaptationAborted(!answer.final);
+        break;
+    }
+}
+
+void
+ServerStateData::handleAdaptedHeader(HttpMsg *msg)
+{
     if (abortOnBadEntry("entry went bad while waiting for adapted headers"))
         return;
 
@@ -685,14 +704,6 @@ ServerStateData::noteAdaptationAnswer(HttpMsg *msg)
     }
 }
 
-// will not receive adapted response headers (and, hence, body)
-void
-ServerStateData::noteAdaptationQueryAbort(bool final)
-{
-    clearAdaptation(adaptedHeadSource);
-    handleAdaptationAborted(!final);
-}
-
 // more adapted response body is available
 void
 ServerStateData::handleMoreAdaptedBodyAvailable()
@@ -778,6 +789,37 @@ ServerStateData::handleAdaptationAborted(bool bypassable)
     abortTransaction("ICAP failure");
 }
 
+// adaptation service wants us to deny HTTP client access to this response
+void
+ServerStateData::handleAdaptationBlocked(const Adaptation::Answer &answer)
+{
+    debugs(11,5, HERE << answer.ruleId);
+
+    if (abortOnBadEntry("entry went bad while ICAP aborted"))
+        return;
+
+    if (!entry->isEmpty()) { // too late to block (should not really happen)
+       if (request)
+           request->detailError(ERR_ICAP_FAILURE, ERR_DETAIL_RESPMOD_BLOCK_LATE);
+       abortTransaction("late adaptation block");
+       return;
+    }
+      
+    debugs(11,7, HERE << "creating adaptation block response");
+
+    err_type page_id =
+        aclGetDenyInfoPage(&Config.denyInfoList, answer.ruleId.termedBuf(), 1);
+    if (page_id == ERR_NONE)
+        page_id = ERR_ACCESS_DENIED;
+
+    ErrorState *err = errorCon(page_id, HTTP_FORBIDDEN, request);
+    err->xerrno = ERR_DETAIL_RESPMOD_BLOCK_EARLY;
+    fwd->fail(err);
+    fwd->dontRetry(true);
+
+    abortTransaction("timely adaptation block");
+}
+
 void
 ServerStateData::adaptationAclCheckDone(Adaptation::ServiceGroupPointer group)
 {
@@ -90,8 +90,7 @@ class ServerStateData:
     static void adaptationAclCheckDoneWrapper(Adaptation::ServiceGroupPointer group, void *data);
 
     // ICAPInitiator: start an ICAP transaction and receive adapted headers.
-    virtual void noteAdaptationAnswer(HttpMsg *message);
-    virtual void noteAdaptationQueryAbort(bool final);
+    virtual void noteAdaptationAnswer(const Adaptation::Answer &answer);
 
     // BodyProducer: provide virgin response body to ICAP.
     virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer );
@@ -154,7 +153,9 @@ class ServerStateData:
     void handleAdaptedBodyProductionEnded();
     void handleAdaptedBodyProducerAborted();
 
+    void handleAdaptedHeader(HttpMsg *msg);
     void handleAdaptationCompleted();
+    void handleAdaptationBlocked(const Adaptation::Answer &answer);
     void handleAdaptationAborted(bool bypassable = false);
 #endif
 
@@ -47,11 +47,21 @@
 bool Adaptation::Config::Enabled = false;
 char *Adaptation::Config::masterx_shared_name = NULL;
 int Adaptation::Config::service_iteration_limit = 16;
+int Adaptation::Config::send_client_ip = false;
+int Adaptation::Config::send_username = false;
+int Adaptation::Config::use_indirect_client = true;
+
+
+Adaptation::ServiceConfig*
+Adaptation::Config::newServiceConfig() const
+{
+    return new ServiceConfig();
+}
 
 void
 Adaptation::Config::parseService()
 {
-    ServiceConfig *cfg = new ServiceConfig;
+    ServiceConfigPointer cfg = newServiceConfig();
     if (!cfg->parse()) {
         fatalf("%s:%d: malformed adaptation service configuration",
                cfg_filename, config_lineno);
@@ -67,10 +77,7 @@ Adaptation::Config::freeService()
 
     DetachServices();
 
-    while (!serviceConfigs.empty()) {
-        delete serviceConfigs.back();
-        serviceConfigs.pop_back();
-    }
+    serviceConfigs.clean();
 }
 
 void
@@ -91,23 +98,28 @@ void
 Adaptation::Config::finalize()
 {
     // create service reps from service configs
-    typedef Vector<ServiceConfig*>::const_iterator VISCI;
-    const Vector<ServiceConfig*> &configs = serviceConfigs;
-    debugs(93,3, HERE << "Found " << configs.size() << " service configs.");
+    int created = 0;
+
+    typedef ServiceConfigs::const_iterator VISCI;
+    const ServiceConfigs &configs = serviceConfigs;
     for (VISCI i = configs.begin(); i != configs.end(); ++i) {
-        const ServiceConfig &cfg = **i;
-        if (FindService(cfg.key) != NULL) {
+        const ServiceConfigPointer cfg = *i;
+        if (FindService(cfg->key) != NULL) {
             debugs(93,0, "ERROR: Duplicate adaptation service name: " <<
-                   cfg.key);
+                   cfg->key);
             continue; // TODO: make fatal
         }
-        ServicePointer s = createService(**i);
-        if (s != NULL)
+        ServicePointer s = createService(cfg);
+        if (s != NULL) {
             AllServices().push_back(s);
+            created++;
+        }
     }
 
-    debugs(93,3, HERE << "Created " << configs.size() <<
-           " message adaptation services.");
+    debugs(93,3, HERE << "Created " << created << " adaptation services");
+
+    // services remember their configs; we do not have to
+    serviceConfigs.clean();
 }
 
 // poor man for_each
@@ -32,17 +32,19 @@ class Config
     // these are global squid.conf options, documented elsewhere
     static char *masterx_shared_name; // global TODO: do we need TheConfig?
     static int service_iteration_limit;
+    static int send_client_ip;
+    static int send_username;
+    static int use_indirect_client;
+
     // Options below are accessed via Icap::TheConfig or Ecap::TheConfig
     // TODO: move ICAP-specific options to Icap::Config and add TheConfig
     int onoff;
-    int send_client_ip;
-    int send_client_username;
     int service_failure_limit;
     time_t oldest_service_failure;
     int service_revival_delay;
-    int icap_uses_indirect_client;
 
-    Vector<ServiceConfig*> serviceConfigs;
+    typedef Vector<ServiceConfigPointer> ServiceConfigs;
+    ServiceConfigs serviceConfigs;
 
     Config();
     virtual ~Config();
@@ -54,11 +56,15 @@ class Config
 
     virtual void finalize();
 
+protected:
+    /// creates service configuration object that will parse and keep cfg info
+    virtual ServiceConfig *newServiceConfig() const;
+
 private:
     Config(const Config &); // unsupported
     Config &operator =(const Config &); // unsupported
 
-    virtual ServicePointer createService(const ServiceConfig &cfg) = 0;
+    virtual ServicePointer createService(const ServiceConfigPointer &cfg) = 0;
 
     static void ParseServiceGroup(ServiceGroupPointer group);
     static void FreeServiceGroups(void);
@@ -33,7 +33,10 @@ int Adaptation::History::Entry::rptm()
 }
 
 
-Adaptation::History::History(): theNextServices(TheNullServices)
+Adaptation::History::History():
+        lastMeta(hoReply),
+        allMeta(hoReply),
+        theNextServices(TheNullServices)
 {
 }
 
@@ -136,3 +139,12 @@ bool Adaptation::History::extractNextServices(String &value)
     theNextServices = TheNullServices; // prevents resetting the plan twice
     return true;
 }
+
+void Adaptation::History::recordMeta(const HttpHeader *lm)
+{
+    lastMeta.clean();
+    lastMeta.update(lm, NULL);
+
+    allMeta.update(lm, NULL);
+    allMeta.compact();
+}
@@ -1,8 +1,9 @@
 #ifndef SQUID_ADAPT_HISTORY_H
 #define SQUID_ADAPT_HISTORY_H
 
-#include "RefCount.h"
 #include "Array.h"
+#include "HttpHeader.h"
+#include "RefCount.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -41,6 +42,15 @@ class History: public RefCountable
     /// returns true, fills the value, and resets iff next services were set
     bool extractNextServices(String &value);
 
+    /// store the last meta header fields received from the adaptation service
+    void recordMeta(const HttpHeader *lm);
+
+public:
+    /// Last received meta header (REQMOD or RESPMOD, whichever comes last).
+    HttpHeader lastMeta;
+    /// All REQMOD and RESPMOD meta headers merged. Last field wins conflicts.
+    HttpHeader allMeta;
+
 private:
     /// single Xaction stats (i.e., a historical record entry)
     class Entry
@@ -8,29 +8,6 @@
 #include "adaptation/Initiate.h"
 #include "base/AsyncJobCalls.h"
 
-namespace Adaptation
-{
-
-// AdaptInitiator::noteAdaptionAnswer Dialer locks/unlocks the message in transit
-// TODO: replace HTTPMSGLOCK with general RefCounting and delete this class
-class AnswerDialer: public UnaryMemFunT<Initiator, HttpMsg*>
-{
-public:
-    typedef UnaryMemFunT<Initiator, HttpMsg*> Parent;
-
-    AnswerDialer(const Parent::JobPointer &job, Parent::Method meth,
-                 HttpMsg *msg): Parent(job, meth, msg) { HTTPMSGLOCK(arg1); }
-    AnswerDialer(const AnswerDialer &d): Parent(d) { HTTPMSGLOCK(arg1); }
-    virtual ~AnswerDialer() { HTTPMSGUNLOCK(arg1); }
-
-private:
-    AnswerDialer &operator =(const AnswerDialer &); // not implemented
-};
-
-} // namespace Adaptation
-
-
-/* Initiate */
 
 Adaptation::Initiate::Initiate(const char *aTypeName): AsyncJob(aTypeName)
 {
@@ -70,20 +47,18 @@ void Adaptation::Initiate::clearInitiator()
     theInitiator.clear();
 }
 
-void Adaptation::Initiate::sendAnswer(HttpMsg *msg)
+void Adaptation::Initiate::sendAnswer(const Answer &answer)
 {
-    assert(msg);
+    typedef UnaryMemFunT<Initiator, Answer, const Answer &> MyDialer;
     CallJob(93, 5, __FILE__, __LINE__, "Initiator::noteAdaptationAnswer",
-            AnswerDialer(theInitiator, &Initiator::noteAdaptationAnswer, msg));
+            MyDialer(theInitiator, &Initiator::noteAdaptationAnswer, answer));
     clearInitiator();
 }
 
 
 void Adaptation::Initiate::tellQueryAborted(bool final)
 {
-    CallJobHere1(93, 5, theInitiator,
-                 Initiator, noteAdaptationQueryAbort, final);
-    clearInitiator();
+    sendAnswer(Answer::Error(final));
 }
 
 const char *Adaptation::Initiate::status() const
@@ -5,8 +5,6 @@
 #include "base/CbcPointer.h"
 #include "adaptation/forward.h"
 
-class HttpMsg;
-
 namespace Adaptation
 {
 
@@ -34,7 +32,7 @@ class Initiate: virtual public AsyncJob
     virtual void noteInitiatorAborted() = 0;
 
 protected:
-    void sendAnswer(HttpMsg *msg); // send to the initiator
+    void sendAnswer(const Answer &answer); // send to the initiator
     void tellQueryAborted(bool final); // tell initiator
     void clearInitiator(); // used by noteInitiatorAborted; TODO: make private
 
@@ -28,3 +28,46 @@ Adaptation::Initiator::announceInitiatorAbort(CbcPointer<Initiate> &x)
     CallJobHere(93, 5, x, Initiate, noteInitiatorAborted);
     clearAdaptation(x);
 }
+
+
+/* Adaptation::Answer */
+
+// TODO: Move to src/adaptation/Answer.*
+
+Adaptation::Answer
+Adaptation::Answer::Error(bool final)
+{
+    Answer answer(akError);
+    answer.final = final;
+    debugs(93, 4, HERE << "error: " << final);
+    return answer;
+}
+
+Adaptation::Answer
+Adaptation::Answer::Forward(HttpMsg *aMsg)
+{
+    Answer answer(akForward);
+    answer.message = aMsg;
+    debugs(93, 4, HERE << "forwarding: " << (void*)aMsg);
+    return answer;
+}
+
+
+Adaptation::Answer
+Adaptation::Answer::Block(const String &aRule)
+{
+    Answer answer(akBlock);
+    answer.ruleId = aRule;
+    debugs(93, 4, HERE << "blocking rule: " << aRule);
+    return answer;
+}
+
+std::ostream &
+Adaptation::Answer::print(std::ostream &os) const
+{
+    return os << kind; // TODO: add more details
+}
+
+Adaptation::Answer::Answer(Kind aKind): final(true), kind(aKind)
+{
+}
@@ -4,6 +4,9 @@
 #include "base/AsyncJob.h"
 #include "base/CbcPointer.h"
 #include "adaptation/forward.h"
+#include "HttpMsg.h"
+
+#include <iosfwd>
 
 /*
  * The ICAP Initiator is an ICAP vectoring point that initates ICAP
@@ -14,23 +17,50 @@
  * or aborting an ICAP transaction.
  */
 
-class HttpMsg;
-
 namespace Adaptation
 {
 
+/// summarizes adaptation service answer for the noteAdaptationAnswer() API
+class Answer {
+public:
+    /// helps interpret other members without a class hierarchy
+    typedef enum {
+        akForward, ///< forward the supplied adapted HTTP message
+        akBlock, ///< block or deny the master xaction; see authority
+        akError, ///< no adapted message will come; see bypassable
+    } Kind;
+
+    static Answer Error(bool final); ///< create an akError answer
+    static Answer Forward(HttpMsg *aMsg); ///< create an akForward answer
+    static Answer Block(const String &aRule); ///< create an akBlock answer
+
+    std::ostream &print(std::ostream &os) const;
+
+public:
+    HttpMsgPointerT<HttpMsg> message; ///< HTTP request or response to forward
+    String ruleId; ///< ACL (or similar rule) name that blocked forwarding
+    bool final; ///< whether the error, if any, cannot be bypassed
+    Kind kind; ///< the type of the answer
+
+private:
+    explicit Answer(Kind aKind); ///< use static creators instead
+};
+
+inline
+std::ostream &operator <<(std::ostream &os, const Answer &answer)
+{
+    return answer.print(os);
+}
+
 class Initiator: virtual public AsyncJob
 {
 public:
     Initiator(): AsyncJob("Initiator") {}
     virtual ~Initiator() {}
 
-    // called when ICAP response headers are successfully interpreted
-    virtual void noteAdaptationAnswer(HttpMsg *message) = 0;
-
-    // called when valid ICAP response headers are no longer expected
-    // the final parameter is set to disable bypass or retries
-    virtual void noteAdaptationQueryAbort(bool final) = 0;
+    /// called with the initial adaptation decision (adapt, block, error);
+    /// virgin and/or adapted body transmission may continue after this
+    virtual void noteAdaptationAnswer(const Answer &answer) = 0;
 
 protected:
     ///< starts freshly created initiate and returns a safe pointer to it
@@ -51,7 +51,7 @@ void Adaptation::Iterator::step()
     Must(!theLauncher);
 
     if (thePlan.exhausted()) { // nothing more to do
-        sendAnswer(theMsg);
+        sendAnswer(Answer::Forward(theMsg));
         Must(done());
         return;
     }
@@ -74,7 +74,26 @@ void Adaptation::Iterator::step()
     Must(!done());
 }
 
-void Adaptation::Iterator::noteAdaptationAnswer(HttpMsg *aMsg)
+void
+Adaptation::Iterator::noteAdaptationAnswer(const Answer &answer)
+{
+    switch (answer.kind) {
+    case Answer::akForward:
+        handleAdaptedHeader(answer.message);
+        break;
+
+    case Answer::akBlock:
+        handleAdaptationBlock(answer);
+        break;
+
+    case Answer::akError:
+        handleAdaptationError(answer.final);
+        break;
+    }
+}
+
+void
+Adaptation::Iterator::handleAdaptedHeader(HttpMsg *aMsg)
 {
     // set theCause if we switched to request satisfaction mode
     if (!theCause) { // probably sent a request message
@@ -106,7 +125,16 @@ void Adaptation::Iterator::noteInitiatorAborted()
     mustStop("initiator gone");
 }
 
-void Adaptation::Iterator::noteAdaptationQueryAbort(bool final)
+void Adaptation::Iterator::handleAdaptationBlock(const Answer &answer)
+{
+    debugs(93,5, HERE << "blocked by " << answer);
+    clearAdaptation(theLauncher);
+    updatePlan(false);
+    sendAnswer(answer);
+    mustStop("blocked");
+}
+
+void Adaptation::Iterator::handleAdaptationError(bool final)
 {
     debugs(93,5, HERE << "final: " << final << " plan: " << thePlan);
     clearAdaptation(theLauncher);
@@ -130,7 +158,7 @@ void Adaptation::Iterator::noteAdaptationQueryAbort(bool final)
 
     if (canIgnore && srcIntact && adapted) {
         debugs(85,3, HERE << "responding with older adapted msg");
-        sendAnswer(theMsg);
+        sendAnswer(Answer::Forward(theMsg));
         mustStop("sent older adapted msg");
         return;
     }
@@ -29,8 +29,7 @@ class Iterator: public Initiate, public Initiator
     void noteInitiatorAborted();
 
     // Adaptation::Initiator: asynchronous communication with the current launcher
-    virtual void noteAdaptationAnswer(HttpMsg *message);
-    virtual void noteAdaptationQueryAbort(bool final);
+    virtual void noteAdaptationAnswer(const Answer &answer);
 
 protected:
     // Adaptation::Initiate API implementation
@@ -47,6 +46,10 @@ class Iterator: public Initiate, public Initiator
     /// creates service filter for the current step
     ServiceFilter filter() const;
 
+    void handleAdaptedHeader(HttpMsg *msg);
+    void handleAdaptationBlock(const Answer &answer);
+    void handleAdaptationError(bool final);
+
     ServiceGroupPointer theGroup; ///< the service group we are iterating
     ServicePlan thePlan; ///< which services to use and in what order
     HttpMsg *theMsg; ///< the message being adapted (virgin for each step)
@@ -45,6 +45,6 @@ libadaptation_la_SOURCES = \
 	History.h 
 
 # add libraries for specific adaptation schemes
-libadaptation_la_LIBADD = $(ECAP_LIBS) $(ECAPLIB) $(ICAP_LIBS)
+libadaptation_la_LIBADD = $(ECAP_LIBS) $(ICAP_LIBS)
 
 libadaptation_la_DEPENDENCIES = $(ECAP_LIBS) $(ICAP_LIBS)
@@ -7,9 +7,10 @@
 #include "adaptation/ServiceFilter.h"
 #include "adaptation/Service.h"
 
-Adaptation::Service::Service(const ServiceConfig &aConfig): theConfig(aConfig)
+Adaptation::Service::Service(const ServiceConfigPointer &aConfig): theConfig(aConfig)
 {
-    debugs(93,3, HERE << "creating adaptation service " << theConfig.key);
+    Must(theConfig != NULL);
+    debugs(93,3, HERE << "creating adaptation service " << cfg().key);
 }
 
 Adaptation::Service::~Service()
@@ -24,7 +24,7 @@ class Service: public RefCountable
     typedef String Id;
 
 public:
-    Service(const ServiceConfig &aConfig);
+    explicit Service(const ServiceConfigPointer &aConfig);
     virtual ~Service();
 
     virtual bool probed() const = 0; // see comments above
@@ -41,7 +41,7 @@ class Service: public RefCountable
     // called by transactions to report service failure
     virtual void noteFailure() = 0;
 
-    const ServiceConfig &cfg() const { return theConfig; }
+    const ServiceConfig &cfg() const { return *theConfig; }
 
     virtual void finalize(); // called after creation
 
@@ -52,10 +52,10 @@ class Service: public RefCountable
     virtual bool detached() const = 0;
 
 protected:
-    ServiceConfig &writeableCfg() { return theConfig; }
+    ServiceConfig &writeableCfg() { return *theConfig; }
 
 private:
-    ServiceConfig theConfig;
+    ServiceConfigPointer theConfig;
 };
 
 typedef Service::Pointer ServicePointer;
@@ -69,6 +69,7 @@ Adaptation::ServiceConfig::parse()
 
     // handle optional service name=value parameters
     const char *lastOption = NULL;
+    bool grokkedUri = false;
     while (char *option = strtok(NULL, w_space)) {
         if (strcmp(option, "0") == 0) { // backward compatibility
             bypass = false;
@@ -94,20 +95,21 @@ Adaptation::ServiceConfig::parse()
             grokked = grokBool(bypass, name, value);
         else if (strcmp(name, "routing") == 0)
             grokked = grokBool(routing, name, value);
+        else if (strcmp(name, "uri") == 0)
+            grokked = grokkedUri = grokUri(value);
         else if (strcmp(name, "ipv6") == 0) {
             grokked = grokBool(ipv6, name, value);
             if (grokked && ipv6 && !Ip::EnableIpv6)
                 debugs(3, DBG_IMPORTANT, "WARNING: IPv6 is disabled. ICAP service option ignored.");
-        } else {
-            debugs(3, 0, cfg_filename << ':' << config_lineno << ": " <<
-                   "unknown adaptation service option: " << name << '=' << value);
-        }
+        } else
+            grokked = grokExtension(name, value);
+
         if (!grokked)
             return false;
     }
 
     // what is left must be the service URI
-    if (!grokUri(lastOption))
+    if (!grokkedUri && !grokUri(lastOption))
         return false;
 
     // there should be nothing else left
@@ -243,3 +245,13 @@ Adaptation::ServiceConfig::grokBool(bool &var, const char *name, const char *val
 
     return true;
 }
+
+bool
+Adaptation::ServiceConfig::grokExtension(const char *name, const char *value)
+{
+    // we do not accept extensions by default
+    debugs(3, DBG_CRITICAL, cfg_filename << ':' << config_lineno << ": " <<
+           "ERROR: unknown adaptation service option: " <<
+           name << '=' << value);
+    return false;
+}
@@ -9,7 +9,7 @@ namespace Adaptation
 {
 
 // manages adaptation service configuration in squid.conf
-class ServiceConfig
+class ServiceConfig: public RefCountable
 {
 public:
     ServiceConfig();
@@ -42,6 +42,8 @@ class ServiceConfig
     /// interpret parsed values
     bool grokBool(bool &var, const char *name, const char *value);
     bool grokUri(const char *value);
+    /// handle name=value configuration option with name unknown to Squid
+    virtual bool grokExtension(const char *name, const char *value);
 };
 
 } // namespace Adaptation
@@ -26,10 +26,25 @@ Adaptation::Ecap::Config::finalize()
     CheckUnusedAdapterServices(AllServices());
 }
 
+Adaptation::ServiceConfig *
+Adaptation::Ecap::Config::newServiceConfig() const
+{
+    return new ServiceConfig();
+}
+
 Adaptation::ServicePointer
-Adaptation::Ecap::Config::createService(const Adaptation::ServiceConfig &cfg)
+Adaptation::Ecap::Config::createService(const ServiceConfigPointer &cfg)
+{
+    return new Adaptation::Ecap::ServiceRep(cfg);
+}
+
+
+/* ServiceConfig */
+
+bool
+Adaptation::Ecap::ServiceConfig::grokExtension(const char *name, const char *value)
 {
-    Adaptation::ServicePointer s = new Adaptation::Ecap::ServiceRep(cfg);
-    return s.getRaw();
+    extensions.push_back(std::make_pair(name, value));
+    return true;
 }
 
@@ -7,12 +7,29 @@
 #define SQUID_ECAP_CONFIG_H
 
 #include "adaptation/Config.h"
+#include "adaptation/ServiceConfig.h"
+#include <list>
+#include <utility>
 
 namespace Adaptation
 {
 namespace Ecap
 {
 
+/// eCAP service configuration
+class ServiceConfig: public Adaptation::ServiceConfig {
+public:
+    // Adaptation::ServiceConfig API
+    virtual bool grokExtension(const char *name, const char *value);
+
+public:
+    typedef std::pair<std::string, std::string> Extension; // name=value in cfg
+    typedef std::list<Extension> Extensions;
+    Extensions extensions;
+};
+
+
+/// General eCAP configuration
 class Config: public Adaptation::Config
 {
 
@@ -22,11 +39,14 @@ class Config: public Adaptation::Config
 
     virtual void finalize();
 
+protected:
+    virtual Adaptation::ServiceConfig *newServiceConfig() const;
+
 private:
     Config(const Config &); // not implemented
     Config &operator =(const Config &); // not implemented
 
-    virtual Adaptation::ServicePointer createService(const Adaptation::ServiceConfig &cfg);
+    virtual Adaptation::ServicePointer createService(const ServiceConfigPointer &cfg);
 };
 
 extern Config TheConfig;
@@ -18,6 +18,10 @@ const libecap::Name Adaptation::Ecap::protocolIcp("ICP", libecap::Name::NextId()
 #if USE_HTCP
 const libecap::Name Adaptation::Ecap::protocolHtcp("Htcp", libecap::Name::NextId());
 #endif
+const libecap::Name Adaptation::Ecap::protocolIcy("ICY", libecap::Name::NextId());
+const libecap::Name Adaptation::Ecap::protocolUnknown("_unknown_", libecap::Name::NextId());
+
+const libecap::Name Adaptation::Ecap::metaBypassable("bypassable", libecap::Name::NextId());
 
 /// the host application (i.e., Squid) wrapper registered with libecap
 static libecap::shared_ptr<Adaptation::Ecap::Host> TheHost;
@@ -27,8 +31,12 @@ Adaptation::Ecap::Host::Host()
     // assign our host-specific IDs to well-known names
     // this code can run only once
 
+    libecap::headerTransferEncoding.assignHostId(HDR_TRANSFER_ENCODING);
     libecap::headerReferer.assignHostId(HDR_REFERER);
     libecap::headerContentLength.assignHostId(HDR_CONTENT_LENGTH);
+    libecap::headerVia.assignHostId(HDR_VIA);
+    // TODO: libecap::headerXClientIp.assignHostId(HDR_X_CLIENT_IP);
+    // TODO: libecap::headerXServerIp.assignHostId(HDR_X_SERVER_IP);
 
     libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);
     libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);
@@ -43,6 +51,11 @@ Adaptation::Ecap::Host::Host()
 #if USE_HTCP
     protocolHtcp.assignHostId(AnyP::PROTO_HTCP);
 #endif
+    protocolIcy.assignHostId(AnyP::PROTO_ICY);
+    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);
+
+    // allows adapter to safely ignore this in adapter::Service::configure()
+    metaBypassable.assignHostId(1);
 }
 
 std::string
@@ -74,7 +87,7 @@ SquidLogLevel(libecap::LogVerbosity lv)
         return DBG_DATA; // is it a good idea to ignore other flags?
 
     if (lv.application())
-        return DBG_DATA; // is it a good idea to ignore other flags?
+        return DBG_IMPORTANT; // is it a good idea to ignore other flags?
 
     return 2 + 2*lv.debugging() + 3*lv.operation() + 2*lv.xaction();
 }
@@ -44,9 +44,12 @@ class Host : public libecap::host::Host
 extern const libecap::Name protocolInternal;
 extern const libecap::Name protocolCacheObj;
 extern const libecap::Name protocolIcp;
+extern const libecap::Name protocolIcy;
+extern const libecap::Name protocolUnknown;
 #if USE_HTCP
 extern const libecap::Name protocolHtcp;
 #endif
+extern const libecap::Name metaBypassable; ///< an ecap_service parameter
 
 } // namespace Ecap
 } // namespace Adaptation
@@ -1,9 +1,9 @@
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
-noinst_LTLIBRARIES = libecap.la
+noinst_LTLIBRARIES = libsquid-ecap.la
 
-libecap_la_SOURCES = \
+libsquid_ecap_la_SOURCES = \
 	Config.h \
 	Config.cc \
 	Host.h \
@@ -16,3 +16,7 @@ libecap_la_SOURCES = \
 	XactionRep.cc \
 	\
 	Registry.h
+
+# add libecap using its pkg-config-produced configuration variables
+libsquid_ecap_la_CXXFLAGS = $(EXT_LIBECAP_CFLAGS)
+libsquid_ecap_la_LIBADD = $(EXT_LIBECAP_LIBS) 
@@ -8,6 +8,7 @@
 #include <libecap/common/names.h>
 #include <libecap/common/area.h>
 #include <libecap/common/version.h>
+#include <libecap/common/named_values.h>
 #include "adaptation/ecap/MessageRep.h"
 #include "adaptation/ecap/XactionRep.h"
 #include "adaptation/ecap/Host.h" /* for protocol constants */
@@ -66,6 +67,17 @@ Adaptation::Ecap::HeaderRep::removeAny(const Name &name)
         theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
 }
 
+void
+Adaptation::Ecap::HeaderRep::visitEach(libecap::NamedValueVisitor &visitor) const
+{
+    HttpHeaderPos pos = HttpHeaderInitPos;
+    while (HttpHeaderEntry *e = theHeader.getEntry(&pos)) {
+        const Name name(e->name.termedBuf()); // optimize: find std Names
+        name.assignHostId(e->id);
+        visitor.visit(name, Value(e->value.rawBuf(), e->value.size()));
+    }
+}
+
 libecap::Area
 Adaptation::Ecap::HeaderRep::image() const
 {
@@ -149,7 +161,9 @@ Adaptation::Ecap::FirstLineRep::protocol() const
     case AnyP::PROTO_INTERNAL:
         return protocolInternal;
     case AnyP::PROTO_ICY:
-        return Name();
+        return protocolIcy;
+    case AnyP::PROTO_UNKNOWN:
+        return protocolUnknown; // until we remember the protocol image
     case AnyP::PROTO_NONE:
         return Name();
 
@@ -168,12 +182,12 @@ Adaptation::Ecap::FirstLineRep::protocol(const Name &p)
     theMessage.protocol = TranslateProtocolId(p);
 }
 
-protocol_t
+AnyP::ProtocolType
 Adaptation::Ecap::FirstLineRep::TranslateProtocolId(const Name &name)
 {
     if (name.assignedHostId())
-        return static_cast<protocol_t>(name.hostId());
-    return AnyP::PROTO_NONE; // no AnyP::PROTO_OTHER
+        return static_cast<AnyP::ProtocolType>(name.hostId());
+    return AnyP::PROTO_UNKNOWN;
 }
 
 
@@ -10,6 +10,7 @@
 #include "BodyPipe.h"
 #include "adaptation/forward.h"
 #include "adaptation/Message.h"
+#include "anyp/ProtocolType.h"
 #include <libecap/common/message.h>
 #include <libecap/common/header.h>
 #include <libecap/common/body.h>
@@ -41,6 +42,8 @@ class HeaderRep: public libecap::Header
     virtual void add(const Name &name, const Value &value);
     virtual void removeAny(const Name &name);
 
+    virtual void visitEach(libecap::NamedValueVisitor &visitor) const;
+
     virtual Area image() const;
     virtual void parse(const Area &buf); // throws on failures
 
@@ -68,7 +71,7 @@ class FirstLineRep
     void protocol(const Name &aProtocol);
 
 protected:
-    static protocol_t TranslateProtocolId(const Name &name);
+    static AnyP::ProtocolType TranslateProtocolId(const Name &name);
 
 private:
     HttpMsg &theMessage; // the message which first line is being translated
@@ -4,14 +4,81 @@
 #include "squid.h"
 #include <list>
 #include <libecap/adapter/service.h>
+#include <libecap/common/options.h>
+#include <libecap/common/name.h>
+#include <libecap/common/named_values.h>
+#include "adaptation/ecap/Config.h"
+#include "adaptation/ecap/Host.h"
 #include "adaptation/ecap/ServiceRep.h"
 #include "adaptation/ecap/XactionRep.h"
 #include "base/TextException.h"
 
 // configured eCAP service wrappers
 static std::list<Adaptation::Ecap::ServiceRep::AdapterService> TheServices;
 
-Adaptation::Ecap::ServiceRep::ServiceRep(const Adaptation::ServiceConfig &cfg):
+namespace Adaptation
+{
+namespace Ecap
+{
+
+/// wraps Adaptation::Ecap::ServiceConfig to allow eCAP visitors
+class ConfigRep: public libecap::Options
+{
+public:
+    typedef Adaptation::Ecap::ServiceConfig Master;
+    typedef libecap::Name Name;
+    typedef libecap::Area Area;
+
+    ConfigRep(const Master &aMaster);
+
+    // libecap::Options API
+    virtual const libecap::Area option(const libecap::Name &name) const;
+    virtual void visitEachOption(libecap::NamedValueVisitor &visitor) const;
+
+    const Master &master; ///< the configuration being wrapped
+};
+
+} // namespace Ecap
+} // namespace Adaptation
+
+
+Adaptation::Ecap::ConfigRep::ConfigRep(const Master &aMaster): master(aMaster)
+{
+}
+
+const libecap::Area
+Adaptation::Ecap::ConfigRep::option(const libecap::Name &name) const
+{
+    // we may supply the params we know about, but only when names have host ID
+    if (name == metaBypassable)
+        return Area(master.bypass ? "1" : "0", 1);
+
+    // TODO: We could build a by-name index, but is it worth it? Good adapters
+    // should use visitEachOption() instead, to check for name typos/errors.
+    typedef Master::Extensions::const_iterator MECI;
+    for (MECI i = master.extensions.begin(); i != master.extensions.end(); ++i) {
+        if (name == i->first)
+            return Area(i->second.data(), i->second.size());
+    }
+
+    return Area();
+}
+
+void
+Adaptation::Ecap::ConfigRep::visitEachOption(libecap::NamedValueVisitor &visitor) const
+{
+    // we may supply the params we know about too, but only if we set host ID
+    visitor.visit(metaBypassable, Area(master.bypass ? "1" : "0", 1));
+
+    // visit adapter-specific options (i.e., those not recognized by Squid)
+    typedef Master::Extensions::const_iterator MECI;
+    for (MECI i = master.extensions.begin(); i != master.extensions.end(); ++i)
+        visitor.visit(Name(i->first), Area::FromTempString(i->second));
+}
+
+
+
+Adaptation::Ecap::ServiceRep::ServiceRep(const ServiceConfigPointer &cfg):
         /*AsyncJob("Adaptation::Ecap::ServiceRep"),*/ Adaptation::Service(cfg),
         isDetached(false)
 {
@@ -32,6 +99,10 @@ Adaptation::Ecap::ServiceRep::finalize()
     Adaptation::Service::finalize();
     theService = FindAdapterService(cfg().uri);
     if (theService) {
+        debugs(93,3, HERE << "configuring eCAP service: " << theService->uri());
+        const ConfigRep cfgRep(dynamic_cast<const ServiceConfig&>(cfg()));
+        theService->configure(cfgRep);
+
         debugs(93,3, HERE << "starting eCAP service: " << theService->uri());
         theService->start();
     } else {
@@ -23,7 +23,7 @@ namespace Ecap
 class ServiceRep : public Adaptation::Service
 {
 public:
-    ServiceRep(const Adaptation::ServiceConfig &config);
+    explicit ServiceRep(const ServiceConfigPointer &aConfig);
     virtual ~ServiceRep();
 
     typedef libecap::shared_ptr<libecap::adapter::Service> AdapterService;
@@ -4,26 +4,48 @@
 #include "squid.h"
 #include <libecap/common/area.h>
 #include <libecap/common/delay.h>
+#include <libecap/common/named_values.h>
+#include <libecap/common/names.h>
 #include <libecap/adapter/xaction.h>
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "SquidTime.h"
 #include "adaptation/ecap/XactionRep.h"
+#include "adaptation/ecap/Config.h"
+#include "adaptation/Initiator.h"
 #include "base/TextException.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Ecap::XactionRep, XactionRep);
 
 
+/// a libecap Visitor for converting adapter transaction options to HttpHeader
+class OptionsExtractor: public libecap::NamedValueVisitor
+{
+public:
+    typedef libecap::Name Name;
+    typedef libecap::Area Area;
+
+    OptionsExtractor(HttpHeader &aMeta): meta(aMeta) {}
+
+    // libecap::NamedValueVisitor API
+    virtual void visit(const Name &name, const Area &value)
+    {
+        meta.putExt(name.image().c_str(), value.toString().c_str());
+    }
+
+    HttpHeader &meta; ///< where to put extracted options
+};
+
 Adaptation::Ecap::XactionRep::XactionRep(
     HttpMsg *virginHeader, HttpRequest *virginCause,
     const Adaptation::ServicePointer &aService):
         AsyncJob("Adaptation::Ecap::XactionRep"),
         Adaptation::Initiate("Adaptation::Ecap::XactionRep"),
         theService(aService),
         theVirginRep(virginHeader), theCauseRep(NULL),
-        proxyingVb(opUndecided), proxyingAb(opUndecided),
+        makingVb(opUndecided), proxyingAb(opUndecided),
         adaptHistoryId(-1),
-        canAccessVb(false),
+        vbProductionFinished(false),
         abProductionFinished(false), abProductionAtEnd(false)
 {
     if (virginCause)
@@ -52,15 +74,99 @@ Adaptation::Ecap::XactionRep::service()
     return *theService;
 }
 
+const libecap::Area
+Adaptation::Ecap::XactionRep::option(const libecap::Name &name) const
+{
+    if (name == libecap::metaClientIp)
+        return clientIpValue();
+    if (name == libecap::metaUserName)
+        return usernameValue();
+    if (name == Adaptation::Config::masterx_shared_name)
+        return masterxSharedValue(name);
+
+    // TODO: metaServerIp, metaAuthenticatedUser, and metaAuthenticatedGroups
+    return libecap::Area();
+}
+
+void
+Adaptation::Ecap::XactionRep::visitEachOption(libecap::NamedValueVisitor &visitor) const
+{
+    if (const libecap::Area value = clientIpValue())
+       visitor.visit(libecap::metaClientIp, value);
+    if (const libecap::Area value = usernameValue())
+       visitor.visit(libecap::metaUserName, value);
+
+    if (Adaptation::Config::masterx_shared_name) {
+       const libecap::Name name(Adaptation::Config::masterx_shared_name);
+       if (const libecap::Area value = masterxSharedValue(name))
+           visitor.visit(name, value);
+    }
+
+    // TODO: metaServerIp, metaAuthenticatedUser, and metaAuthenticatedGroups
+}
+
+const libecap::Area
+Adaptation::Ecap::XactionRep::clientIpValue() const
+{
+    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+                                 theCauseRep->raw().header : theVirginRep.raw().header);
+    Must(request);
+    // TODO: move this logic into HttpRequest::clientIp(bool) and
+    // HttpRequest::clientIpString(bool) and reuse everywhere
+    if (TheConfig.send_client_ip && request) {
+        Ip::Address client_addr;
+#if FOLLOW_X_FORWARDED_FOR
+        if (TheConfig.use_indirect_client) {
+            client_addr = request->indirect_client_addr;
+		} else
+#endif
+            client_addr = request->client_addr;
+        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr()) {
+            char ntoabuf[MAX_IPSTRLEN] = "";
+            client_addr.NtoA(ntoabuf,MAX_IPSTRLEN);
+            return libecap::Area::FromTempBuffer(ntoabuf, strlen(ntoabuf));
+        }
+	}
+    return libecap::Area();
+}
+
+const libecap::Area
+Adaptation::Ecap::XactionRep::usernameValue() const
+{
+    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+                                 theCauseRep->raw().header : theVirginRep.raw().header);
+    Must(request);
+    if (request->auth_user_request != NULL) {
+        if (char const *name = request->auth_user_request->username())
+            return libecap::Area::FromTempBuffer(name, strlen(name));
+	}
+    return libecap::Area();
+}
+
+const libecap::Area
+Adaptation::Ecap::XactionRep::masterxSharedValue(const libecap::Name &name) const
+{
+    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+                                 theCauseRep->raw().header : theVirginRep.raw().header);
+    Must(request);
+    if (name.known()) { // must check to avoid empty names matching unset cfg
+        Adaptation::History::Pointer ah = request->adaptHistory(false);
+        if (ah != NULL) {
+            String name, value;
+            if (ah->getXxRecord(name, value))
+                return libecap::Area::FromTempBuffer(value.rawBuf(), value.size());
+        }
+    }
+    return libecap::Area();
+}
+
 void
 Adaptation::Ecap::XactionRep::start()
 {
     Must(theMaster);
 
-    if (theVirginRep.raw().body_pipe != NULL)
-        canAccessVb = true; /// assumes nobody is consuming; \todo check
-    else
-        proxyingVb = opNever;
+    if (!theVirginRep.raw().body_pipe)
+        makingVb = opNever; // there is nothing to deliver
 
     const HttpRequest *request = dynamic_cast<const HttpRequest*> (theCauseRep ?
                                  theCauseRep->raw().header : theVirginRep.raw().header);
@@ -88,13 +194,9 @@ Adaptation::Ecap::XactionRep::swanSong()
         }
     }
 
-    if (proxyingVb == opOn) {
-        BodyPipe::Pointer body_pipe = theVirginRep.raw().body_pipe;
-        if (body_pipe != NULL) {
-            Must(body_pipe->stillConsuming(this));
-            stopConsumingFrom(body_pipe);
-        }
-    }
+    BodyPipe::Pointer &body_pipe = theVirginRep.raw().body_pipe;
+    if (body_pipe != NULL && body_pipe->stillConsuming(this))
+        stopConsumingFrom(body_pipe);
 
     terminateMaster();
 
@@ -149,26 +251,54 @@ Adaptation::Ecap::XactionRep::terminateMaster()
 bool
 Adaptation::Ecap::XactionRep::doneAll() const
 {
-    return proxyingVb >= opComplete && proxyingAb >= opComplete &&
+    return makingVb >= opComplete && proxyingAb >= opComplete &&
            Adaptation::Initiate::doneAll();
 }
 
-// stops receiving virgin and enables auto-consumption
+// stops receiving virgin and enables auto-consumption, dropping any vb bytes
 void
-Adaptation::Ecap::XactionRep::dropVirgin(const char *reason)
+Adaptation::Ecap::XactionRep::sinkVb(const char *reason)
 {
-    debugs(93,4, HERE << "because " << reason << "; status:" << status());
-    Must(proxyingVb = opOn);
+    debugs(93,4, HERE << "sink for " << reason << "; status:" << status());
+
+    // we reset raw().body_pipe when we are done, so use this one for checking
+    const BodyPipePointer &permPipe = theVirginRep.raw().header->body_pipe;
+    if (permPipe != NULL)
+        permPipe->enableAutoConsumption();
+
+    forgetVb(reason);
+}
+
+// stops receiving virgin but preserves it for others to use
+void
+Adaptation::Ecap::XactionRep::preserveVb(const char *reason)
+{
+    debugs(93,4, HERE << "preserve for " << reason << "; status:" << status());
+
+    // we reset raw().body_pipe when we are done, so use this one for checking
+    const BodyPipePointer &permPipe = theVirginRep.raw().header->body_pipe;
+    if (permPipe != NULL) {
+        // if libecap consumed, we cannot preserve
+        Must(!permPipe->consumedSize());
+    }
+
+    forgetVb(reason);
+}
+
+// disassociates us from vb; the last step of sinking or preserving vb
+void
+Adaptation::Ecap::XactionRep::forgetVb(const char *reason)
+{
+    debugs(93,9, HERE << "forget vb " << reason << "; status:" << status());
 
     BodyPipePointer &p = theVirginRep.raw().body_pipe;
-    Must(p != NULL);
-    Must(p->stillConsuming(this));
-    stopConsumingFrom(p);
-    p->enableAutoConsumption();
-    proxyingVb = opComplete;
-    canAccessVb = false;
+    if (p != NULL && p->stillConsuming(this))
+        stopConsumingFrom(p);
 
-    // called from adapter handler so does not inform adapter
+    if (makingVb == opUndecided)
+        makingVb = opNever;
+    else if (makingVb == opOn)
+        makingVb = opComplete;
 }
 
 void
@@ -178,25 +308,14 @@ Adaptation::Ecap::XactionRep::useVirgin()
     Must(proxyingAb == opUndecided);
     proxyingAb = opNever;
 
-    BodyPipePointer &vbody_pipe = theVirginRep.raw().body_pipe;
+    preserveVb("useVirgin");
 
     HttpMsg *clone = theVirginRep.raw().header->clone();
     // check that clone() copies the pipe so that we do not have to
-    Must(!vbody_pipe == !clone->body_pipe);
-
-    if (proxyingVb == opOn) {
-        Must(vbody_pipe->stillConsuming(this));
-        // if libecap consumed, we cannot shortcircuit
-        Must(!vbody_pipe->consumedSize());
-        stopConsumingFrom(vbody_pipe);
-        canAccessVb = false;
-        proxyingVb = opComplete;
-    } else if (proxyingVb == opUndecided) {
-        vbody_pipe = NULL; // it is not our pipe anymore
-        proxyingVb = opNever;
-    }
+    Must(!theVirginRep.raw().header->body_pipe == !clone->body_pipe);
 
-    sendAnswer(clone);
+    updateHistory();
+    sendAnswer(Answer::Forward(clone));
     Must(done());
 }
 
@@ -211,7 +330,8 @@ Adaptation::Ecap::XactionRep::useAdapted(const libecap::shared_ptr<libecap::Mess
     HttpMsg *msg = answer().header;
     if (!theAnswerRep->body()) { // final, bodyless answer
         proxyingAb = opNever;
-        sendAnswer(msg);
+        updateHistory();
+        sendAnswer(Answer::Forward(msg));
     } else { // got answer headers but need to handle body
         proxyingAb = opOn;
         Must(!msg->body_pipe); // only host can set body pipes
@@ -220,54 +340,118 @@ Adaptation::Ecap::XactionRep::useAdapted(const libecap::shared_ptr<libecap::Mess
         rep->tieBody(this); // sets us as a producer
         Must(msg->body_pipe != NULL); // check tieBody
 
-        sendAnswer(msg);
+        updateHistory();
+        sendAnswer(Answer::Forward(msg));
 
         debugs(93,4, HERE << "adapter will produce body" << status());
         theMaster->abMake(); // libecap will produce
     }
 }
 
+void
+Adaptation::Ecap::XactionRep::blockVirgin()
+{
+    debugs(93,3, HERE << status());
+    Must(proxyingAb == opUndecided);
+    proxyingAb = opNever;
+
+    sinkVb("blockVirgin");
+
+    updateHistory();
+    sendAnswer(Answer::Block(service().cfg().key));
+    Must(done());
+}
+
+/// Called just before sendAnswer() to record adapter meta-information
+/// which may affect answer processing and may be needed for logging.
+void
+Adaptation::Ecap::XactionRep::updateHistory()
+{
+    if (!theMaster) // all updates rely on being able to query the adapter
+        return;
+
+    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+                                 theCauseRep->raw().header : theVirginRep.raw().header);
+    Must(request);
+
+    // TODO: move common ICAP/eCAP logic to Adaptation::Xaction or similar
+    // TODO: optimize Area-to-String conversion
+
+    // update the cross-transactional database if needed
+    if (const char *xxNameStr = Adaptation::Config::masterx_shared_name) {
+        Adaptation::History::Pointer ah = request->adaptHistory(true);
+        if (ah != NULL) {
+            libecap::Name xxName(xxNameStr); // TODO: optimize?
+            if (const libecap::Area val = theMaster->option(xxName))
+                ah->updateXxRecord(xxNameStr, val.toString().c_str());
+        }
+    }
+
+    // update the adaptation plan if needed
+    if (service().cfg().routing) {
+        String services;
+        if (const libecap::Area services = theMaster->option(libecap::metaNextServices)) {
+            Adaptation::History::Pointer ah = request->adaptHistory(true);
+            if (ah != NULL)
+                ah->updateNextServices(services.toString().c_str());
+        }
+    } // TODO: else warn (occasionally!) if we got libecap::metaNextServices
+
+    // Store received meta headers for adapt::<last_h logformat code use.
+    // If we already have stored headers from a previous adaptation transaction
+    // related to the same master transction, they will be replaced.
+    Adaptation::History::Pointer ah = request->adaptLogHistory();
+    if (ah != NULL) {
+        HttpHeader meta(hoReply);
+        OptionsExtractor extractor(meta);
+        theMaster->visitEachOption(extractor);
+        ah->recordMeta(&meta);
+    }
+}
+
+
 void
 Adaptation::Ecap::XactionRep::vbDiscard()
 {
-    Must(proxyingVb == opUndecided);
+    Must(makingVb == opUndecided);
     // if adapter does not need vb, we do not need to send it
-    dropVirgin("vbDiscard");
-    Must(proxyingVb == opNever);
+    sinkVb("vbDiscard");
+    Must(makingVb == opNever);
 }
 
 void
 Adaptation::Ecap::XactionRep::vbMake()
 {
-    Must(proxyingVb == opUndecided);
+    Must(makingVb == opUndecided);
     BodyPipePointer &p = theVirginRep.raw().body_pipe;
     Must(p != NULL);
-    Must(p->setConsumerIfNotLate(this)); // to make vb, we must receive vb
-    proxyingVb = opOn;
+    Must(p->setConsumerIfNotLate(this)); // to deliver vb, we must receive vb
+    makingVb = opOn;
 }
 
 void
 Adaptation::Ecap::XactionRep::vbStopMaking()
 {
+    Must(makingVb == opOn);
     // if adapter does not need vb, we do not need to receive it
-    if (proxyingVb == opOn)
-        dropVirgin("vbStopMaking");
-    Must(proxyingVb == opComplete);
+    sinkVb("vbStopMaking");
+    Must(makingVb == opComplete);
 }
 
 void
 Adaptation::Ecap::XactionRep::vbMakeMore()
 {
-    Must(proxyingVb == opOn); // cannot make more if done proxying
+    Must(makingVb == opOn); // cannot make more if done proxying
     // we cannot guarantee more vb, but we can check that there is a chance
-    Must(!theVirginRep.raw().body_pipe->exhausted());
+    const BodyPipePointer &p = theVirginRep.raw().body_pipe;
+    Must(p != NULL && p->stillConsuming(this)); // we are plugged in
+    Must(!p->productionEnded() && p->mayNeedMoreData()); // and may get more
 }
 
 libecap::Area
 Adaptation::Ecap::XactionRep::vbContent(libecap::size_type o, libecap::size_type s)
 {
-    Must(canAccessVb);
-    // We may not be proxyingVb yet. It should be OK, but see vbContentShift().
+    // We may not be makingVb yet. It should be OK, but see vbContentShift().
 
     const BodyPipePointer &p = theVirginRep.raw().body_pipe;
     Must(p != NULL);
@@ -291,8 +475,7 @@ Adaptation::Ecap::XactionRep::vbContent(libecap::size_type o, libecap::size_type
 void
 Adaptation::Ecap::XactionRep::vbContentShift(libecap::size_type n)
 {
-    Must(canAccessVb);
-    // We may not be proxyingVb yet. It should be OK now, but if BodyPipe
+    // We may not be makingVb yet. It should be OK now, but if BodyPipe
     // consume() requirements change, we would have to return empty vbContent
     // until the adapter registers as a consumer
 
@@ -372,27 +555,27 @@ Adaptation::Ecap::XactionRep::noteBodyConsumerAborted(RefCount<BodyPipe> bp)
 void
 Adaptation::Ecap::XactionRep::noteMoreBodyDataAvailable(RefCount<BodyPipe> bp)
 {
-    Must(proxyingVb == opOn);
+    Must(makingVb == opOn); // or we would not be registered as a consumer
     Must(theMaster);
     theMaster->noteVbContentAvailable();
 }
 
 void
 Adaptation::Ecap::XactionRep::noteBodyProductionEnded(RefCount<BodyPipe> bp)
 {
-    Must(proxyingVb == opOn);
+    Must(makingVb == opOn); // or we would not be registered as a consumer
     Must(theMaster);
     theMaster->noteVbContentDone(true);
-    proxyingVb = opComplete;
+    vbProductionFinished = true;
 }
 
 void
 Adaptation::Ecap::XactionRep::noteBodyProducerAborted(RefCount<BodyPipe> bp)
 {
-    Must(proxyingVb == opOn);
+    Must(makingVb == opOn); // or we would not be registered as a consumer
     Must(theMaster);
     theMaster->noteVbContentDone(false);
-    proxyingVb = opComplete;
+    vbProductionFinished = true;
 }
 
 void
@@ -426,24 +609,34 @@ Adaptation::Ecap::XactionRep::status() const
 
     buf.append(" [", 2);
 
-    if (proxyingVb == opOn) {
-        const BodyPipePointer &vp = theVirginRep.raw().body_pipe;
-        if (!canAccessVb)
-            buf.append("x", 1);
-        if (vp != NULL) { // XXX: but may not be stillConsuming()
-            buf.append("Vb", 2);
-        } else
-            buf.append("V.", 2);
-    }
+    if (makingVb)
+        buf.Printf("M%d", static_cast<int>(makingVb));
+
+    const BodyPipePointer &vp = theVirginRep.raw().body_pipe;
+    if (!vp)
+        buf.append(" !V", 3);
+    else
+    if (vp->stillConsuming(const_cast<XactionRep*>(this)))
+        buf.append(" Vc", 3);
+    else
+        buf.append(" V?", 3);
+
+    if (vbProductionFinished)
+        buf.append(".", 1);
+
+
+    buf.Printf(" A%d", static_cast<int>(proxyingAb));
 
     if (proxyingAb == opOn) {
         MessageRep *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
         Must(rep);
         const BodyPipePointer &ap = rep->raw().body_pipe;
-        if (ap != NULL) { // XXX: but may not be stillProducing()
-            buf.append(" Ab", 3);
-        } else
-            buf.append(" A.", 3);
+        if (!ap)
+            buf.append(" !A", 3);
+        else if (ap->stillProducing(const_cast<XactionRep*>(this)))
+            buf.append(" Ap", 3);
+        else
+            buf.append(" A?", 3);
     }
 
     buf.Printf(" %s%u]", id.Prefix, id.value);
@@ -35,11 +35,14 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
     void master(const AdapterXaction &aMaster); // establish a link
 
     // libecap::host::Xaction API
+    virtual const libecap::Area option(const libecap::Name &name) const;
+    virtual void visitEachOption(libecap::NamedValueVisitor &visitor) const;
     virtual libecap::Message &virgin();
     virtual const libecap::Message &cause();
     virtual libecap::Message &adapted();
     virtual void useVirgin();
     virtual void useAdapted(const libecap::shared_ptr<libecap::Message> &msg);
+    virtual void blockVirgin();
     virtual void adaptationDelayed(const libecap::Delay &);
     virtual void adaptationAborted();
     virtual void vbDiscard();
@@ -77,12 +80,20 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
 
     Adaptation::Message &answer();
 
-    void dropVirgin(const char *reason);
+    void sinkVb(const char *reason);
+    void preserveVb(const char *reason);
+    void forgetVb(const char *reason);
+
     void moveAbContent();
 
+    void updateHistory();
     void terminateMaster();
     void scheduleStop(const char *reason);
 
+    const libecap::Area clientIpValue() const;
+    const libecap::Area usernameValue() const;
+    const libecap::Area masterxSharedValue(const libecap::Name &name) const;
+
 private:
     AdapterXaction theMaster; // the actual adaptation xaction we represent
     Adaptation::ServicePointer theService; ///< xaction's adaptation service
@@ -94,10 +105,10 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
     MessagePtr theAnswerRep;
 
     typedef enum { opUndecided, opOn, opComplete, opNever } OperationState;
-    OperationState proxyingVb; // delivering virgin body from core to adapter
+    OperationState makingVb; //< delivering virgin body from pipe to adapter
     OperationState proxyingAb; // delivering adapted body from adapter to core
     int adaptHistoryId;        ///< adaptation history slot reservation
-    bool canAccessVb;          // virgin BodyPipe content is accessible
+    bool vbProductionFinished; // whether there can be no more vb bytes
     bool abProductionFinished; // whether adapter has finished producing ab
     bool abProductionAtEnd;    // whether adapter produced a complete ab
 
@@ -25,8 +25,10 @@ class ServiceGroup;
 class ServicePlan;
 class ServiceFilter;
 class Message;
+class Answer;
 
 typedef RefCount<Service> ServicePointer;
+typedef RefCount<ServiceConfig> ServiceConfigPointer;
 typedef RefCount<ServiceGroup> ServiceGroupPointer;
 
 } // namespace Adaptation
@@ -58,7 +58,7 @@ Adaptation::Icap::Config::~Config()
 }
 
 Adaptation::ServicePointer
-Adaptation::Icap::Config::createService(const Adaptation::ServiceConfig &cfg)
+Adaptation::Icap::Config::createService(const ServiceConfigPointer &cfg)
 {
     return new Adaptation::Icap::ServiceRep(cfg);
 }
@@ -76,7 +76,7 @@ class Config: public Adaptation::Config
     Config(const Config &); // not implemented
     Config &operator =(const Config &); // not implemented
 
-    virtual Adaptation::ServicePointer createService(const Adaptation::ServiceConfig &cfg);
+    virtual Adaptation::ServicePointer createService(const ServiceConfigPointer &cfg);
 };
 
 extern Config TheConfig;
@@ -3,68 +3,12 @@
 #include "globals.h"
 #include "SquidTime.h"
 
-Adaptation::Icap::History::History(): mergeOfIcapHeaders(hoRequest),
-        lastIcapHeader(hoRequest), logType(LOG_TAG_NONE), req_sz(0),
+Adaptation::Icap::History::History():
+        logType(LOG_TAG_NONE), req_sz(0),
         pastTime(0), concurrencyLevel(0)
 {
 }
 
-Adaptation::Icap::History::History(const Adaptation::Icap::History& ih)
-{
-    assign(ih);
-}
-
-Adaptation::Icap::History::~History()
-{
-    mergeOfIcapHeaders.clean();
-    lastIcapHeader.clean();
-    rfc931.clean();
-#if USE_SSL
-    ssluser.clean();
-#endif
-    log_uri.clean();
-}
-
-void Adaptation::Icap::History::assign(const Adaptation::Icap::History& ih)
-{
-    mergeOfIcapHeaders.clean();
-    mergeOfIcapHeaders.update(&ih.mergeOfIcapHeaders, NULL);
-    lastIcapHeader.clean();
-    lastIcapHeader.update(&ih.lastIcapHeader, NULL);
-    rfc931 = ih.rfc931;
-
-#if USE_SSL
-    ssluser = ih.ssluser;
-#endif
-
-    logType = ih.logType;
-    log_uri = ih.log_uri;
-    req_sz = ih.req_sz;
-    pastTime = ih.pastTime;
-    currentStart = ih.currentStart;
-    concurrencyLevel = ih.concurrencyLevel;
-    debugs(93,7, HERE << this << " = " << &ih);
-}
-
-Adaptation::Icap::History& Adaptation::Icap::History::operator=(const History& ih)
-{
-    if (this != &ih)
-        assign(ih);
-    return *this;
-}
-
-void Adaptation::Icap::History::setIcapLastHeader(const HttpHeader * lih)
-{
-    lastIcapHeader.clean();
-    lastIcapHeader.update(lih, NULL);
-}
-
-void Adaptation::Icap::History::mergeIcapHeaders(const HttpHeader * lih)
-{
-    mergeOfIcapHeaders.update(lih, NULL);
-    mergeOfIcapHeaders.compact();
-}
-
 void Adaptation::Icap::History::start(const char *context)
 {
     if (!concurrencyLevel++)
@@ -2,7 +2,6 @@
 #define SQUID_ICAPHISTORY_H
 
 #include "RefCount.h"
-#include "HttpHeader.h"
 #include "enums.h"
 
 namespace Adaptation
@@ -17,16 +16,6 @@ class History: public RefCountable
     typedef RefCount<History> Pointer;
 
     History();
-    History(const History& ih);
-
-    ~History();
-
-    History& operator=(const History& ih);
-
-    ///store the last reply header from ICAP server
-    void setIcapLastHeader(const HttpHeader * lih);
-    ///merge new header and stored one
-    void mergeIcapHeaders(const HttpHeader * lih);
 
     /// record the start of an ICAP processing interval
     void start(const char *context);
@@ -36,8 +25,6 @@ class History: public RefCountable
     /// returns the total time of all ICAP processing intervals
     int processingTime() const;
 
-    HttpHeader mergeOfIcapHeaders; ///< Merge of REQMOD and RESPMOD responses. If both responses contain the header, the one from the last response will be used
-    HttpHeader lastIcapHeader; ///< Last received reply from ICAP server
     String rfc931; ///< the username from ident
 #if USE_SSL
     String ssluser; ///< the username from SSL
@@ -48,8 +35,6 @@ class History: public RefCountable
     size_t req_sz; ///< the request size
 
 private:
-    void assign(const History &);
-
     int currentTime() const; ///< time since current start or zero
 
     timeval currentStart; ///< when the current processing interval started
@@ -50,12 +50,16 @@ void Adaptation::Icap::Launcher::launchXaction(const char *xkind)
     Must(initiated(theXaction));
 }
 
-void Adaptation::Icap::Launcher::noteAdaptationAnswer(HttpMsg *message)
+void Adaptation::Icap::Launcher::noteAdaptationAnswer(const Answer &answer)
 {
-    sendAnswer(message);
+    debugs(93,5, HERE << "launches: " << theLaunches << " answer: " << answer);
+
+    // XXX: akError is unused by ICAPXaction in favor of noteXactAbort()
+    Must(answer.kind != Answer::akError);
+
+    sendAnswer(answer);
     clearAdaptation(theXaction);
     Must(done());
-    debugs(93,3, HERE << "Adaptation::Icap::Launcher::noteAdaptationAnswer exiting ");
 }
 
 void Adaptation::Icap::Launcher::noteInitiatorAborted()
@@ -67,15 +71,6 @@ void Adaptation::Icap::Launcher::noteInitiatorAborted()
 
 }
 
-// XXX: this call is unused by ICAPXaction in favor of ICAPLauncher::noteXactAbort
-void Adaptation::Icap::Launcher::noteAdaptationQueryAbort(bool final)
-{
-    debugs(93,5, HERE << "launches: " << theLaunches << "; final: " << final);
-    clearAdaptation(theXaction);
-
-    Must(done()); // swanSong will notify the initiator
-}
-
 void Adaptation::Icap::Launcher::noteXactAbort(XactAbortInfo info)
 {
     debugs(93,5, HERE << "theXaction:" << theXaction << " launches: " << theLaunches);
@@ -80,13 +80,12 @@ class Launcher: public Adaptation::Initiate, public Adaptation::Initiator
     void noteInitiatorAborted();
 
     // Adaptation::Initiator: asynchronous communication with the current transaction
-    virtual void noteAdaptationAnswer(HttpMsg *message);
+    virtual void noteAdaptationAnswer(const Answer &answer);
     virtual void noteXactAbort(XactAbortInfo info);
 
 private:
     bool canRetry(XactAbortInfo &info) const; //< true if can retry in the case of persistent connection failures
     bool canRepeat(XactAbortInfo &info) const; //< true if can repeat in the case of no or unsatisfactory response
-    virtual void noteAdaptationQueryAbort(bool final);
 
 protected:
     // Adaptation::Initiate API implementation
@@ -714,7 +714,7 @@ void Adaptation::Icap::ModXact::startSending()
 {
     disableRepeats("sent headers");
     disableBypass("sent headers", true);
-    sendAnswer(adapted.header);
+    sendAnswer(Answer::Forward(adapted.header));
 
     if (state.sending == State::sendingVirgin)
         echoMore();
@@ -770,7 +770,7 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // update the cross-transactional database if needed (all status codes!)
     if (const char *xxName = Adaptation::Config::masterx_shared_name) {
         Adaptation::History::Pointer ah = request->adaptHistory(true);
-        if (ah != NULL) {
+        if (ah != NULL) { // TODO: reorder checks to avoid creating history
             const String val = icapReply->header.getByName(xxName);
             if (val.size() > 0) // XXX: HttpHeader lacks empty value detection
                 ah->updateXxRecord(xxName, val);
@@ -791,11 +791,9 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // If we already have stored headers from previous ICAP transaction related to this
     // request, old headers will be replaced with the new one.
 
-    Adaptation::Icap::History::Pointer h = request->icapHistory();
-    if (h != NULL) {
-        h->mergeIcapHeaders(&icapReply->header);
-        h->setIcapLastHeader(&icapReply->header);
-    }
+    Adaptation::History::Pointer ah = request->adaptLogHistory();
+    if (ah != NULL)
+        ah->recordMeta(&icapReply->header);
 
     // handle100Continue() manages state.writing on its own.
     // Non-100 status means the server needs no postPreview data from us.
@@ -1302,6 +1300,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 
     // share the cross-transactional database records if needed
     if (Adaptation::Config::masterx_shared_name) {
+        // XXX: do not create history here: there can be no values in empty ah
         Adaptation::History::Pointer ah = request->adaptHistory(true);
         if (ah != NULL) {
             String name, value;
@@ -1357,7 +1356,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     if (TheConfig.send_client_ip && request) {
         Ip::Address client_addr;
 #if FOLLOW_X_FORWARDED_FOR
-        if (TheConfig.icap_uses_indirect_client) {
+        if (TheConfig.use_indirect_client) {
             client_addr = request->indirect_client_addr;
         } else
 #endif
@@ -1366,7 +1365,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
             buf.Printf("X-Client-IP: %s\r\n", client_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
     }
 
-    if (TheConfig.send_client_username && request)
+    if (TheConfig.send_username && request)
         makeUsernameHeader(request, buf);
 
     // fprintf(stderr, "%s\n", buf.content());
@@ -79,7 +79,7 @@ void Adaptation::Icap::OptXact::handleCommRead(size_t)
         debugs(93, 7, HERE << "readAll=" << readAll);
         icap_tio_finish = current_time;
         setOutcome(xoOpt);
-        sendAnswer(icapReply);
+        sendAnswer(Answer::Forward(icapReply));
         Must(done()); // there should be nothing else to do
         return;
     }
@@ -15,7 +15,7 @@
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 
-Adaptation::Icap::ServiceRep::ServiceRep(const Adaptation::ServiceConfig &svcCfg):
+Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &svcCfg):
         AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(svcCfg),
         theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
         isSuspended(0), notifying(false),
@@ -304,11 +304,19 @@ void Adaptation::Icap::ServiceRep::announceStatusChange(const char *downPhrase,
 }
 
 // we are receiving ICAP OPTIONS response headers here or NULL on failures
-void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(HttpMsg *msg)
+void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(const Answer &answer)
 {
     Must(initiated(theOptionsFetcher));
     clearAdaptation(theOptionsFetcher);
 
+    if (answer.kind == Answer::akError) {
+        debugs(93,3, HERE << "failed to fetch options " << status());
+        handleNewOptions(0);
+        return;
+    }
+
+    Must(answer.kind == Answer::akForward); // no akBlock for OPTIONS requests
+    HttpMsg *msg = answer.message;
     Must(msg);
 
     debugs(93,5, HERE << "is interpreting new options " << status());
@@ -324,15 +332,6 @@ void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(HttpMsg *msg)
     handleNewOptions(newOptions);
 }
 
-void Adaptation::Icap::ServiceRep::noteAdaptationQueryAbort(bool)
-{
-    Must(initiated(theOptionsFetcher));
-    clearAdaptation(theOptionsFetcher);
-
-    debugs(93,3, HERE << "failed to fetch options " << status());
-    handleNewOptions(0);
-}
-
 // we (a) must keep trying to get OPTIONS and (b) are RefCounted so we
 // must keep our job alive (XXX: until nobody needs us)
 void Adaptation::Icap::ServiceRep::callException(const std::exception &e)
@@ -87,7 +87,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     typedef RefCount<ServiceRep> Pointer;
 
 public:
-    ServiceRep(const Adaptation::ServiceConfig &config);
+    explicit ServiceRep(const ServiceConfigPointer &aConfig);
     virtual ~ServiceRep();
 
     virtual void finalize();
@@ -119,8 +119,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     void noteTimeToNotify();
 
     // receive either an ICAP OPTIONS response header or an abort message
-    virtual void noteAdaptationAnswer(HttpMsg *msg);
-    virtual void noteAdaptationQueryAbort(bool);
+    virtual void noteAdaptationAnswer(const Answer &answer);
 
 private:
     // stores Prepare() callback info
@@ -2932,22 +2932,21 @@ DOC_START
 				sent to the first selected peer. The timer stops
 				with the last I/O with the last peer.
 
-	If ICAP is enabled, the following two codes become available (as
+	If ICAP is enabled, the following code becomes available (as
 	well as ICAP log codes documented with the icap_log option):
 
 		icap::tt        Total ICAP processing time for the HTTP
 				transaction. The timer ticks when ICAP
 				ACLs are checked and when ICAP
 				transaction is in progress.
 
-		icap::<last_h	The header of the last ICAP response
-				related to the HTTP transaction. Like
-				<h, accepts an optional header name
-				argument.  Will not change semantics
-				when multiple ICAP transactions per HTTP
-				transaction are supported.
+	If adaptation is enabled the following three codes become available:
 
-	If adaptation is enabled the following two codes become available:
+		adapt::<last_h	The header of the last ICAP response or
+				meta-information from the last eCAP
+				transaction related to the HTTP transaction.
+				Like <h, accepts an optional header name
+				argument.
 
 		adapt::sum_trs Summed adaptation transaction response
 				times recorded as a comma-separated list in
@@ -3125,7 +3124,7 @@ DOC_START
 
 logformat icap_squid %ts.%03tu %6icap::tr %>a %icap::to/%03icap::Hs %icap::<size %icap::rm %icap::ru% %un -/%icap::<A -
 
-	See also: logformat, log_icap, and %icap::<last_h 
+	See also: logformat, log_icap, and %adapt::<last_h 
 DOC_END
 
 NAME: logfile_daemon
@@ -4148,12 +4147,12 @@ Example:
  broken_posts allow buggy_server
 DOC_END
 
-NAME: icap_uses_indirect_client
+NAME: adaptation_uses_indirect_client icap_uses_indirect_client
 COMMENT: on|off
 TYPE: onoff
-IFDEF: FOLLOW_X_FORWARDED_FOR&&ICAP_CLIENT
+IFDEF: FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
 DEFAULT: on
-LOC: Adaptation::Icap::TheConfig.icap_uses_indirect_client
+LOC: Adaptation::Config::use_indirect_client
 DOC_START
    Controls whether the indirect client address
    (see follow_x_forwarded_for) instead of the
@@ -5962,6 +5961,8 @@ DOC_START
 	  the first authentication related acl encountered
 	- When none of the http_access lines matches. It's then the last
 	  acl processed on the last http_access line.
+	- When the decision to deny access was made by an adaptation service,
+	  the acl name is the corresponding eCAP or ICAP service_name.
 
 	NP: If providing your own custom error pages with error_directory
 	    you may also specify them by your custom file name:
@@ -6400,25 +6401,27 @@ DOC_START
 	an ICAP server.
 DOC_END
 
-NAME: icap_send_client_ip
+NAME: adaptation_send_client_ip icap_send_client_ip
 TYPE: onoff
-IFDEF: ICAP_CLIENT
+IFDEF: USE_ADAPTATION
 COMMENT: on|off
-LOC: Adaptation::Icap::TheConfig.send_client_ip
+LOC: Adaptation::Config::send_client_ip
 DEFAULT: off
 DOC_START
 	This adds the header "X-Client-IP" to ICAP requests.
 DOC_END
 
-NAME: icap_send_client_username
+NAME: adaptation_send_username icap_send_client_username
 TYPE: onoff
-IFDEF: ICAP_CLIENT
+IFDEF: USE_ADAPTATION
 COMMENT: on|off
-LOC: Adaptation::Icap::TheConfig.send_client_username
+LOC: Adaptation::Config::send_username
 DEFAULT: off
 DOC_START
 	This sends authenticated HTTP client username (if available) to
-	the ICAP service. The username value is encoded based on the
+	the adaptation service.
+
+	For ICAP, the username value is encoded based on the
 	icap_client_username_encode option and is sent using the header
 	specified by the icap_client_username_header option.
 DOC_END
@@ -6429,7 +6432,7 @@ IFDEF: ICAP_CLIENT
 LOC: Adaptation::Icap::TheConfig.client_username_header
 DEFAULT: X-Client-Username
 DOC_START
-	ICAP request header name to use for send_client_username.
+	ICAP request header name to use for send_username.
 DOC_END
 
 NAME: icap_client_username_encode
@@ -6755,8 +6758,14 @@ DOC_START
 
 	An ICAP REQMOD or RESPMOD transaction may set an entry in the 
 	shared table by returning an ICAP header field with a name 
-	specified in adaptation_masterx_shared_names. Squid will store 
-	and forward that ICAP header field to subsequent ICAP 
+	specified in adaptation_masterx_shared_names.
+
+	An eCAP REQMOD or RESPMOD transaction may set an entry in the
+	shared table by implementing the libecap::visitEachOption() API
+	to provide an option with a name specified in
+	adaptation_masterx_shared_names.
+
+	Squid will store and forward the set entry to subsequent adaptation
 	transactions within the same master transaction scope.
 
 	Only one shared entry name is supported at this time.
@@ -8,7 +8,7 @@ BEGIN {
 	define["USE_DELAY_POOLS"]="--enable-delay-pools"
 	define["FOLLOW_X_FORWARDED_FOR"]="--enable-follow-x-forwarded-for"
 	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
-	define["FOLLOW_X_FORWARDED_FOR&&ICAP_CLIENT"]="--enable-follow-x-forwarded-for and --enable-icap-client"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
 	define["FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER"]="--enable-follow-x-forwarded-for and --enable-linux-netfilter"
 	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
 	define["ICAP_CLIENT"]="--enable-icap-client"
@@ -554,9 +554,6 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogEntry)
     assert(request);
     assert(aLogEntry);
 
-#if ICAP_CLIENT
-    Adaptation::Icap::History::Pointer ih = request->icapHistory();
-#endif
     if (Config.onoff.log_mime_hdrs) {
         Packer p;
         MemBuf mb;
@@ -575,21 +572,23 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogEntry)
             aLogEntry->headers.request = xstrdup(mb.buf);
         }
 
-#if ICAP_CLIENT
-        packerClean(&p);
-        mb.reset();
-        packerToMemInit(&p, &mb);
-
-        if (ih != NULL)
-            ih->lastIcapHeader.packInto(&p);
-        aLogEntry->headers.icap = xstrdup(mb.buf);
+#if USE_ADAPTATION
+        const Adaptation::History::Pointer ah = request->adaptLogHistory();
+        if (ah != NULL) {
+            packerClean(&p);
+            mb.reset();
+            packerToMemInit(&p, &mb);
+            ah->lastMeta.packInto(&p);
+            aLogEntry->headers.adapt_last = xstrdup(mb.buf);
+        }
 #endif
 
         packerClean(&p);
         mb.clean();
     }
 
 #if ICAP_CLIENT
+    const Adaptation::Icap::History::Pointer ih = request->icapHistory();
     if (ih != NULL)
         aLogEntry->icap.processingTime = ih->processingTime();
 #endif
@@ -1405,9 +1405,30 @@ ClientHttpRequest::startAdaptation(const Adaptation::ServiceGroupPointer &g)
 }
 
 void
-ClientHttpRequest::noteAdaptationAnswer(HttpMsg *msg)
+ClientHttpRequest::noteAdaptationAnswer(const Adaptation::Answer &answer)
 {
     assert(cbdataReferenceValid(this));		// indicates bug
+    clearAdaptation(virginHeadSource);
+    assert(!adaptedBodySource);
+
+    switch (answer.kind) {
+    case Adaptation::Answer::akForward:
+        handleAdaptedHeader(answer.message);
+        break;
+
+    case Adaptation::Answer::akBlock:
+        handleAdaptationBlock(answer);
+        break;
+
+    case Adaptation::Answer::akError:
+        handleAdaptationFailure(ERR_DETAIL_CLT_REQMOD_ABORT, !answer.final);
+        break;
+    }
+}
+
+void
+ClientHttpRequest::handleAdaptedHeader(HttpMsg *msg)    
+{
     assert(msg);
 
     if (HttpRequest *new_req = dynamic_cast<HttpRequest*>(msg)) {
@@ -1456,11 +1477,13 @@ ClientHttpRequest::noteAdaptationAnswer(HttpMsg *msg)
 }
 
 void
-ClientHttpRequest::noteAdaptationQueryAbort(bool final)
+ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
 {
-    clearAdaptation(virginHeadSource);
-    assert(!adaptedBodySource);
-    handleAdaptationFailure(ERR_DETAIL_CLT_REQMOD_ABORT, !final);
+    request->detailError(ERR_ACCESS_DENIED, ERR_DETAIL_REQMOD_BLOCK);
+    AclMatchedName = answer.ruleId.termedBuf();
+    assert(calloutContext);
+    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
+    AclMatchedName = NULL;
 }
 
 void
@@ -166,8 +166,9 @@ class ClientHttpRequest
 
 private:
     // Adaptation::Initiator API
-    virtual void noteAdaptationAnswer(HttpMsg *message);
-    virtual void noteAdaptationQueryAbort(bool final);
+    virtual void noteAdaptationAnswer(const Adaptation::Answer &answer);
+    void handleAdaptedHeader(HttpMsg *msg);
+    void handleAdaptationBlock(const Adaptation::Answer &answer);
 
     // BodyConsumer API, called by BodyPipe
     virtual void noteMoreBodyDataAvailable(BodyPipe::Pointer);
@@ -9,6 +9,9 @@ typedef enum {
     ERR_DETAIL_CLT_REQMOD_RESP_BODY, // client-side detected REQMOD satisfaction reply body failure
     ERR_DETAIL_ICAP_RESPMOD_EARLY, // RESPMOD failed w/o store entry
     ERR_DETAIL_ICAP_RESPMOD_LATE,  // RESPMOD failed with a store entry
+    ERR_DETAIL_REQMOD_BLOCK, // REQMOD denied client access
+    ERR_DETAIL_RESPMOD_BLOCK_EARLY, // RESPMOD denied client access to HTTP response, before any part of the response was sent
+    ERR_DETAIL_RESPMOD_BLOCK_LATE, // RESPMOD denied client access to HTTP response, after [a part of] the response was sent
     ERR_DETAIL_ICAP_XACT_START, // transaction start failure
     ERR_DETAIL_ICAP_XACT_BODY_CONSUMER_ABORT, // transaction body consumer gone
     ERR_DETAIL_ICAP_INIT_GONE, // initiator gone
@@ -312,27 +312,26 @@ Log::Format::SquidCustom(AccessLogEntry * al, customlog * log)
                 out = sb.termedBuf();
             }
             break;
-#endif
 
-#if ICAP_CLIENT
-        case LFT_ICAP_LAST_MATCHED_HEADER:
+        case LFT_ADAPTATION_LAST_HEADER:
             if (al->request) {
-                Adaptation::Icap::History::Pointer ih = al->request->icapHistory();
-                if (ih != NULL)
-                    sb = ih->mergeOfIcapHeaders.getByName(fmt->data.header.header);
+                const Adaptation::History::Pointer ah = al->request->adaptHistory();
+                if (ah != NULL) // XXX: add adapt::<all_h but use lastMeta here
+                    sb = ah->allMeta.getByName(fmt->data.header.header);
             }
 
+            // XXX: here and elsewhere: move such code inside the if guard
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
-        case LFT_ICAP_LAST_MATCHED_HEADER_ELEM:
+        case LFT_ADAPTATION_LAST_HEADER_ELEM:
             if (al->request) {
-                Adaptation::Icap::History::Pointer ih = al->request->icapHistory();
-                if (ih != NULL)
-                    sb = ih->mergeOfIcapHeaders.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
+                const Adaptation::History::Pointer ah = al->request->adaptHistory();
+                if (ah != NULL) // XXX: add adapt::<all_h but use lastMeta here
+                    sb = ah->allMeta.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
             }
 
             out = sb.termedBuf();
@@ -341,13 +340,15 @@ Log::Format::SquidCustom(AccessLogEntry * al, customlog * log)
 
             break;
 
-        case LFT_ICAP_LAST_MATCHED_ALL_HEADERS:
-            out = al->headers.icap;
+        case LFT_ADAPTATION_LAST_ALL_HEADERS:
+            out = al->headers.adapt_last;
 
             quote = 1;
 
             break;
+#endif
 
+#if ICAP_CLIENT
         case LFT_ICAP_ADDR:
             if (!out)
                 out = al->icap.hostAddr.NtoA(tmp,1024);
@@ -161,11 +161,12 @@ struct logformat_token_table_entry logformat_token_table[] = {
 #if USE_ADAPTATION
     {"adapt::all_trs", LTF_ADAPTATION_ALL_XACT_TIMES},
     {"adapt::sum_trs", LTF_ADAPTATION_SUM_XACT_TIMES},
+    {"adapt::<last_h", LFT_ADAPTATION_LAST_HEADER},
 #endif
 
 #if ICAP_CLIENT
     {"icap::tt", LFT_ICAP_TOTAL_TIME},
-    {"icap::<last_h", LFT_ICAP_LAST_MATCHED_HEADER},
+    {"icap::<last_h", LFT_ADAPTATION_LAST_HEADER}, // deprecated
 
     {"icap::<A",  LFT_ICAP_ADDR},
     {"icap::<service_name",  LFT_ICAP_SERV_NAME},
@@ -336,9 +337,11 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
 
     switch (lt->type) {
 
-#if ICAP_CLIENT
-    case LFT_ICAP_LAST_MATCHED_HEADER:
+#if USE_ADAPTATION
+    case LFT_ADAPTATION_LAST_HEADER:
+#endif
 
+#if ICAP_CLIENT
     case LFT_ICAP_REQ_HEADER:
 
     case LFT_ICAP_REP_HEADER:
@@ -376,10 +379,12 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
                 case LFT_REPLY_HEADER:
                     lt->type = LFT_REPLY_HEADER_ELEM;
                     break;
-#if ICAP_CLIENT
-                case LFT_ICAP_LAST_MATCHED_HEADER:
-                    lt->type = LFT_ICAP_LAST_MATCHED_HEADER_ELEM;
+#if USE_ADAPTATION
+                case LFT_ADAPTATION_LAST_HEADER:
+                    lt->type = LFT_ADAPTATION_LAST_HEADER_ELEM;
                     break;
+#endif
+#if ICAP_CLIENT
                 case LFT_ICAP_REQ_HEADER:
                     lt->type = LFT_ICAP_REQ_HEADER_ELEM;
                     break;
@@ -406,10 +411,12 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
             case LFT_REPLY_HEADER:
                 lt->type = LFT_REPLY_ALL_HEADERS;
                 break;
-#if ICAP_CLIENT
-            case LFT_ICAP_LAST_MATCHED_HEADER:
-                lt->type = LFT_ICAP_LAST_MATCHED_ALL_HEADERS;
+#if USE_ADAPTATION
+            case LFT_ADAPTATION_LAST_HEADER:
+                lt->type = LFT_ADAPTATION_LAST_ALL_HEADERS;
                 break;
+#endif
+#if ICAP_CLIENT
             case LFT_ICAP_REQ_HEADER:
                 lt->type = LFT_ICAP_REQ_ALL_HEADERS;
                 break;
@@ -510,8 +517,10 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
 
                 case LFT_STRING:
                     break;
+#if USE_ADAPTATION
+                case LFT_ADAPTATION_LAST_HEADER_ELEM:
+#endif
 #if ICAP_CLIENT
-                case LFT_ICAP_LAST_MATCHED_HEADER_ELEM:
                 case LFT_ICAP_REQ_HEADER_ELEM:
                 case LFT_ICAP_REP_HEADER_ELEM:
 #endif
@@ -528,18 +537,20 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
 
                     switch (type) {
                     case LFT_REQUEST_HEADER_ELEM:
-                        type = LFT_REQUEST_HEADER_ELEM;
+                        type = LFT_REQUEST_HEADER_ELEM; // XXX: remove _ELEM?
                         break;
                     case LFT_ADAPTED_REQUEST_HEADER_ELEM:
-                        type = LFT_ADAPTED_REQUEST_HEADER_ELEM;
+                        type = LFT_ADAPTED_REQUEST_HEADER_ELEM; // XXX: remove _ELEM?
                         break;
                     case LFT_REPLY_HEADER_ELEM:
-                        type = LFT_REPLY_HEADER_ELEM;
+                        type = LFT_REPLY_HEADER_ELEM; // XXX: remove _ELEM?
                         break;
-#if ICAP_CLIENT
-                    case LFT_ICAP_LAST_MATCHED_HEADER_ELEM:
-                        type = LFT_ICAP_LAST_MATCHED_HEADER;
+#if USE_ADAPTATION
+                    case LFT_ADAPTATION_LAST_HEADER_ELEM:
+                        type = LFT_ADAPTATION_LAST_HEADER;
                         break;
+#endif
+#if ICAP_CLIENT
                     case LFT_ICAP_REQ_HEADER_ELEM:
                         type = LFT_ICAP_REQ_HEADER;
                         break;
@@ -557,8 +568,10 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
                 case LFT_ADAPTED_REQUEST_ALL_HEADERS:
                 case LFT_REPLY_ALL_HEADERS:
 
+#if USE_ADAPTATION
+                case LFT_ADAPTATION_LAST_ALL_HEADERS:
+#endif
 #if ICAP_CLIENT
-                case LFT_ICAP_LAST_MATCHED_ALL_HEADERS:
                 case LFT_ICAP_REQ_ALL_HEADERS:
                 case LFT_ICAP_REP_ALL_HEADERS:
 #endif
@@ -573,10 +586,12 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
                     case LFT_REPLY_ALL_HEADERS:
                         type = LFT_REPLY_HEADER;
                         break;
-#if ICAP_CLIENT
-                    case LFT_ICAP_LAST_MATCHED_ALL_HEADERS:
-                        type = LFT_ICAP_LAST_MATCHED_HEADER;
+#if USE_ADAPTATION
+                    case LFT_ADAPTATION_LAST_ALL_HEADERS:
+                        type = LFT_ADAPTATION_LAST_HEADER;
                         break;
+#endif
+#if ICAP_CLIENT
                     case LFT_ICAP_REQ_ALL_HEADERS:
                         type = LFT_ICAP_REQ_HEADER;
                         break;
@@ -132,14 +132,14 @@ typedef enum {
 #if USE_ADAPTATION
     LTF_ADAPTATION_SUM_XACT_TIMES,
     LTF_ADAPTATION_ALL_XACT_TIMES,
+    LFT_ADAPTATION_LAST_HEADER,
+    LFT_ADAPTATION_LAST_HEADER_ELEM,
+    LFT_ADAPTATION_LAST_ALL_HEADERS,
 #endif
 
 #if ICAP_CLIENT
 
     LFT_ICAP_TOTAL_TIME,
-    LFT_ICAP_LAST_MATCHED_HEADER,
-    LFT_ICAP_LAST_MATCHED_HEADER_ELEM,
-    LFT_ICAP_LAST_MATCHED_ALL_HEADERS,
 
     LFT_ICAP_ADDR,
     LFT_ICAP_SERV_NAME,
@@ -311,18 +311,17 @@ accessLogInit(void)
 
         LogfileStatus = LOG_ENABLE;
 
-#if USE_ADAPTATION || ICAP_CLIENT
-        for (logformat_token * curr_token = (log->logFormat?log->logFormat->format:NULL); curr_token; curr_token = curr_token->next) {
 #if USE_ADAPTATION
+        for (logformat_token * curr_token = (log->logFormat?log->logFormat->format:NULL); curr_token; curr_token = curr_token->next) {
             if (curr_token->type == LTF_ADAPTATION_SUM_XACT_TIMES ||
-                    curr_token->type == LTF_ADAPTATION_ALL_XACT_TIMES) {
+                    curr_token->type == LTF_ADAPTATION_ALL_XACT_TIMES ||
+                    curr_token->type == LFT_ADAPTATION_LAST_HEADER ||
+                    curr_token->type == LFT_ADAPTATION_LAST_HEADER_ELEM ||
+                    curr_token->type == LFT_ADAPTATION_LAST_ALL_HEADERS) {
                 alLogformatHasAdaptToken = true;
             }
-#endif
 #if ICAP_CLIENT
-            if (curr_token->type == LFT_ICAP_LAST_MATCHED_HEADER ||
-                    curr_token->type == LFT_ICAP_LAST_MATCHED_HEADER_ELEM ||
-                    curr_token->type == LFT_ICAP_LAST_MATCHED_ALL_HEADERS) {
+            if (curr_token->type == LFT_ICAP_TOTAL_TIME) {
                 alLogformatHasIcapToken = true;
             }
 #endif
@@ -573,7 +572,7 @@ accessLogFreeMemory(AccessLogEntry * aLogEntry)
     safe_free(aLogEntry->headers.request);
 
 #if ICAP_CLIENT
-    safe_free(aLogEntry->headers.icap);
+    safe_free(aLogEntry->headers.adapt_last);
 #endif
 
     safe_free(aLogEntry->headers.reply);