@@ -31,6 +31,7 @@
 #include "gopher.h"
 #include "hier_code.h"
 #include "http.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
@@ -10,6 +10,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -20,6 +20,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "http/RegisteredHeaders.h"
+#include "http/StreamContext.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
@@ -19,6 +19,7 @@
 #include "gopher.h"
 #include "http.h"
 #include "http/one/RequestParser.h"
+#include "http/StreamContext.h"
 #include "HttpHdrCc.h"
 #include "HttpHeaderRange.h"
 #include "HttpRequest.h"
@@ -13,6 +13,7 @@
 #include "client_side.h"
 #include "ConfigParser.h"
 #include "globals.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -13,22 +13,23 @@
 #include "anyp/PortCfg.h"
 #include "client_side.h"
 #include "Debug.h"
+#include "http/StreamContext.h"
 #include "Pipeline.h"
 
 void
-Pipeline::add(const ClientSocketContextPointer &c)
+Pipeline::add(const Http::StreamContextPointer &c)
 {
     requests.push_back(c);
     ++nrequests;
     debugs(33, 3, "Pipeline " << (void*)this << " add request " << nrequests << ' ' << c);
 }
 
-ClientSocketContextPointer
+Http::StreamContextPointer
 Pipeline::front() const
 {
     if (requests.empty()) {
         debugs(33, 3, "Pipeline " << (void*)this << " empty");
-        return ClientSocketContextPointer();
+        return Http::StreamContextPointer();
     }
 
     debugs(33, 3, "Pipeline " << (void*)this << " front " << requests.front());
@@ -39,7 +40,7 @@ void
 Pipeline::terminateAll(int xerrno)
 {
     while (!requests.empty()) {
-        ClientSocketContextPointer context = requests.front();
+        Http::StreamContextPointer context = requests.front();
         debugs(33, 3, "Pipeline " << (void*)this << " notify(" << xerrno << ") " << context);
         context->noteIoError(xerrno);
         context->finished();  // cleanup and self-deregister
@@ -48,7 +49,7 @@ Pipeline::terminateAll(int xerrno)
 }
 
 void
-Pipeline::popMe(const ClientSocketContextPointer &which)
+Pipeline::popMe(const Http::StreamContextPointer &which)
 {
     if (requests.empty())
         return;
@@ -10,12 +10,10 @@
 #define SQUID_SRC_PIPELINE_H
 
 #include "base/RefCount.h"
+#include "http/forward.h"
 
 #include <list>
 
-class ClientSocketContext;
-typedef RefCount<ClientSocketContext> ClientSocketContextPointer;
-
 /**
  * A queue of transactions awaiting completion.
  *
@@ -43,10 +41,10 @@ class Pipeline
     ~Pipeline() = default;
 
     /// register a new request context to the pipeline
-    void add(const ClientSocketContextPointer &);
+    void add(const Http::StreamContextPointer &);
 
     /// get the first request context in the pipeline
-    ClientSocketContextPointer front() const;
+    Http::StreamContextPointer front() const;
 
     /// how many requests are currently pipelined
     size_t count() const {return requests.size();}
@@ -58,15 +56,15 @@ class Pipeline
     void terminateAll(const int xerrno);
 
     /// deregister the front request from the pipeline
-    void popMe(const ClientSocketContextPointer &);
+    void popMe(const Http::StreamContextPointer &);
 
     /// Number of requests seen in this pipeline (so far).
     /// Includes incomplete transactions.
     uint32_t nrequests;
 
 private:
     /// requests parsed from the connection but not yet completed.
-    std::list<ClientSocketContextPointer> requests;
+    std::list<Http::StreamContextPointer> requests;
 };
 
 #endif /* SQUID_SRC_PIPELINE_H */
@@ -14,6 +14,7 @@
 #include "acl/AtStepData.h"
 #include "acl/Checklist.h"
 #include "client_side.h"
+#include "http/StreamContext.h"
 #include "ssl/ServerBump.h"
 
 int
@@ -21,6 +21,7 @@
 #include "client_side.h"
 #include "fde.h"
 #include "globals.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 
 int
@@ -13,6 +13,7 @@
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "comm/Connection.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
@@ -16,6 +16,7 @@
 #include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/UserData.h"
+#include "http/StreamContext.h"
 #include "client_side.h"
 
 ACLExtUser::~ACLExtUser()
@@ -12,6 +12,7 @@
 #include "comm/Connection.h"
 #include "comm/forward.h"
 #include "ExternalACLEntry.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -11,10 +11,9 @@
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
 #include "anyp/PortCfg.h"
-#include "HttpRequest.h"
-
-/* for ConnStateData */
 #include "client_side.h"
+#include "http/StreamContext.h"
+#include "HttpRequest.h"
 
 int
 ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
@@ -15,6 +15,7 @@
 #include "acl/ServerCertificate.h"
 #include "client_side.h"
 #include "fde.h"
+#include "http/StreamContext.h"
 #include "ssl/ServerBump.h"
 
 int
@@ -15,6 +15,7 @@
 #include "acl/ServerName.h"
 #include "client_side.h"
 #include "fde.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "SquidString.h"
@@ -14,6 +14,7 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "fatal.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 
 /**
@@ -18,6 +18,7 @@
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "client_side.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 
 ACLProxyAuth::~ACLProxyAuth()
@@ -28,6 +28,7 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "globals.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -21,6 +21,7 @@
 #include "comm/Connection.h"
 #include "fatal.h"
 #include "format/Format.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -22,6 +22,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "helper.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -22,6 +22,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "helper.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/StreamContext.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "client_side_request.h"
 #include "clientStream.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -87,6 +87,7 @@
 #include "http.h"
 #include "http/one/RequestParser.h"
 #include "http/one/TeChunkedParser.h"
+#include "http/StreamContext.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -188,13 +189,13 @@ static void clientUpdateStatCounters(const LogTags &logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
-static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
+static void ClientSocketContextPushDeferredIfNeeded(Http::StreamContextPointer deferredRequest, ConnStateData * conn);
 static void clientUpdateSocketStats(const LogTags &logType, size_t size);
 
 char *skipLeadingSpace(char *aString);
 
 clientStreamNode *
-ClientSocketContext::getTail() const
+Http::StreamContext::getTail() const
 {
     if (http->client_stream.tail)
         return (clientStreamNode *)http->client_stream.tail->data;
@@ -203,46 +204,44 @@ ClientSocketContext::getTail() const
 }
 
 clientStreamNode *
-ClientSocketContext::getClientReplyContext() const
+Http::StreamContext::getClientReplyContext() const
 {
     return (clientStreamNode *)http->client_stream.tail->prev->data;
 }
 
 ConnStateData *
-ClientSocketContext::getConn() const
+Http::StreamContext::getConn() const
 {
     return http->getConn();
 }
 
-ClientSocketContext::~ClientSocketContext()
+Http::StreamContext::~StreamContext()
 {
     clientStreamNode *node = getTail();
 
     if (node) {
-        ClientSocketContext *streamContext = dynamic_cast<ClientSocketContext *> (node->data.getRaw());
-
-        if (streamContext) {
+        if (auto ctx = dynamic_cast<Http::StreamContext *>(node->data.getRaw())) {
             /* We are *always* the tail - prevent recursive free */
-            assert(this == streamContext);
-            node->data = NULL;
+            assert(this == ctx);
+            node->data = nullptr;
         }
     }
 
     httpRequestFree(http);
 }
 
 void
-ClientSocketContext::registerWithConn()
+Http::StreamContext::registerWithConn()
 {
     assert (!connRegistered_);
     assert (http);
     assert (http->getConn() != NULL);
     connRegistered_ = true;
-    http->getConn()->pipeline.add(ClientSocketContext::Pointer(this));
+    http->getConn()->pipeline.add(Http::StreamContextPointer(this));
 }
 
 void
-ClientSocketContext::finished()
+Http::StreamContext::finished()
 {
     assert (http);
     assert (http->getConn() != NULL);
@@ -254,10 +253,10 @@ ClientSocketContext::finished()
     assert(connRegistered_);
     connRegistered_ = false;
     assert(conn->pipeline.front() == this); // XXX: still assumes HTTP/1 semantics
-    conn->pipeline.popMe(ClientSocketContext::Pointer(this));
+    conn->pipeline.popMe(Http::StreamContextPointer(this));
 }
 
-ClientSocketContext::ClientSocketContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
+Http::StreamContext::StreamContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
     clientConnection(aConn),
     http(aReq),
     reply(NULL),
@@ -766,7 +765,7 @@ clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength)
 }
 
 void
-ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData)
+Http::StreamContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData)
 {
     debugs(33, 2, "clientSocketRecipient: Deferring request " << http->uri);
     assert(flags.deferred == 0);
@@ -778,13 +777,13 @@ ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply *
 }
 
 bool
-ClientSocketContext::startOfOutput() const
+Http::StreamContext::startOfOutput() const
 {
     return http->out.size == 0;
 }
 
 size_t
-ClientSocketContext::lengthToSend(Range<int64_t> const &available)
+Http::StreamContext::lengthToSend(Range<int64_t> const &available)
 {
     /*the size of available range can always fit in a size_t type*/
     size_t maximum = (size_t)available.size();
@@ -807,7 +806,7 @@ ClientSocketContext::lengthToSend(Range<int64_t> const &available)
 }
 
 void
-ClientSocketContext::noteSentBodyBytes(size_t bytes)
+Http::StreamContext::noteSentBodyBytes(size_t bytes)
 {
     debugs(33, 7, bytes << " body bytes");
 
@@ -832,13 +831,13 @@ ClientHttpRequest::multipartRangeRequest() const
 }
 
 bool
-ClientSocketContext::multipartRangeRequest() const
+Http::StreamContext::multipartRangeRequest() const
 {
     return http->multipartRangeRequest();
 }
 
 void
-ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
+Http::StreamContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
 {
     assert(rep == NULL);
 
@@ -867,7 +866,7 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
  * if bodyData is empty.
  */
 void
-ClientSocketContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
+Http::StreamContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
 {
     const uint64_t length =
         static_cast<uint64_t>(lengthToSend(bodyData.range()));
@@ -918,7 +917,7 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
  * all offsets and such.
  */
 void
-ClientSocketContext::packRange(StoreIOBuffer const &source, MemBuf * mb)
+Http::StreamContext::packRange(StoreIOBuffer const &source, MemBuf * mb)
 {
     HttpHdrRangeIter * i = &http->range_iter;
     Range<int64_t> available (source.range());
@@ -1093,7 +1092,7 @@ ClientHttpRequest::rangeBoundaryStr() const
 
 /** adds appropriate Range headers if needed */
 void
-ClientSocketContext::buildRangeHeader(HttpReply * rep)
+Http::StreamContext::buildRangeHeader(HttpReply * rep)
 {
     HttpHeader *hdr = rep ? &rep->header : 0;
     const char *range_err = NULL;
@@ -1207,7 +1206,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
 }
 
 void
-ClientSocketContext::prepareReply(HttpReply * rep)
+Http::StreamContext::prepareReply(HttpReply * rep)
 {
     reply = rep;
 
@@ -1216,7 +1215,7 @@ ClientSocketContext::prepareReply(HttpReply * rep)
 }
 
 void
-ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
+Http::StreamContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
 {
     prepareReply(rep);
     assert (rep);
@@ -1277,7 +1276,7 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
      */
     assert(cbdataReferenceValid(node));
     assert(node->node.next == NULL);
-    ClientSocketContext::Pointer context = dynamic_cast<ClientSocketContext *>(node->data.getRaw());
+    Http::StreamContextPointer context = dynamic_cast<Http::StreamContext *>(node->data.getRaw());
     assert(context != NULL);
 
     /* TODO: check offset is what we asked for */
@@ -1310,7 +1309,7 @@ clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
     /* Set null by ContextFree */
     assert(node->node.next == NULL);
     /* this is the assert discussed above */
-    assert(NULL == dynamic_cast<ClientSocketContext *>(node->data.getRaw()));
+    assert(NULL == dynamic_cast<Http::StreamContext *>(node->data.getRaw()));
     /* We are only called when the client socket shutsdown.
      * Tell the prev pipeline member we're finished
      */
@@ -1336,7 +1335,7 @@ ConnStateData::readNextRequest()
 }
 
 static void
-ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn)
+ClientSocketContextPushDeferredIfNeeded(Http::StreamContextPointer deferredRequest, ConnStateData * conn)
 {
     debugs(33, 2, HERE << conn->clientConnection << " Sending next");
 
@@ -1425,7 +1424,7 @@ ConnStateData::kick()
      * then look at processing it. If not, simply kickstart
      * another read.
      */
-    ClientSocketContext::Pointer deferredRequest = pipeline.front();
+    Http::StreamContextPointer deferredRequest = pipeline.front();
     if (deferredRequest != nullptr) {
         debugs(33, 3, clientConnection << ": calling PushDeferredIfNeeded");
         ClientSocketContextPushDeferredIfNeeded(deferredRequest, this);
@@ -1458,7 +1457,7 @@ clientUpdateSocketStats(const LogTags &logType, size_t size)
  \retval false
  */
 bool
-ClientSocketContext::canPackMoreRanges() const
+Http::StreamContext::canPackMoreRanges() const
 {
     /** first update iterator "i" if needed */
 
@@ -1475,12 +1474,12 @@ ClientSocketContext::canPackMoreRanges() const
 
     /* paranoid sync condition */
     /* continue condition: need_more_data */
-    debugs(33, 5, "ClientSocketContext::canPackMoreRanges: returning " << (http->range_iter.currentSpec() ? true : false));
+    debugs(33, 5, "Http::StreamContext::canPackMoreRanges: returning " << (http->range_iter.currentSpec() ? true : false));
     return http->range_iter.currentSpec() ? true : false;
 }
 
 int64_t
-ClientSocketContext::getNextRangeOffset() const
+Http::StreamContext::getNextRangeOffset() const
 {
     debugs (33, 5, "range: " << http->request->range <<
             "; http offset " << http->out.offset <<
@@ -1526,7 +1525,7 @@ ClientSocketContext::getNextRangeOffset() const
 }
 
 void
-ClientSocketContext::pullData()
+Http::StreamContext::pullData()
 {
     debugs(33, 5, reply << " written " << http->out.size << " into " << clientConnection);
 
@@ -1545,7 +1544,7 @@ ClientSocketContext::pullData()
  *
  */
 clientStream_status_t
-ClientSocketContext::socketState()
+Http::StreamContext::socketState()
 {
     switch (clientStreamStatus(getTail(), http)) {
 
@@ -1599,7 +1598,7 @@ ClientSocketContext::socketState()
 
 /// remembers the abnormal connection termination for logging purposes
 void
-ClientSocketContext::noteIoError(const int xerrno)
+Http::StreamContext::noteIoError(const int xerrno)
 {
     if (http) {
         http->logType.err.timedout = (xerrno == ETIMEDOUT);
@@ -1609,14 +1608,14 @@ ClientSocketContext::noteIoError(const int xerrno)
 }
 
 void
-ClientSocketContext::doClose()
+Http::StreamContext::doClose()
 {
     clientConnection->close();
 }
 
 /// called when we encounter a response-related error
 void
-ClientSocketContext::initiateClose(const char *reason)
+Http::StreamContext::initiateClose(const char *reason)
 {
     debugs(33, 4, clientConnection << " because " << reason);
     http->getConn()->stopSending(reason); // closes ASAP
@@ -1657,7 +1656,7 @@ ConnStateData::afterClientWrite(size_t size)
 
 // TODO: make this only need size parameter, ConnStateData handles the rest
 void
-ClientSocketContext::writeComplete(size_t size)
+Http::StreamContext::writeComplete(size_t size)
 {
     const StoreEntry *entry = http->storeEntry();
     debugs(33, 5, clientConnection << ", sz " << size <<
@@ -1698,18 +1697,18 @@ ClientSocketContext::writeComplete(size_t size)
         return;
 
     default:
-        fatal("Hit unreachable code in ClientSocketContext::writeComplete\n");
+        fatal("Hit unreachable code in Http::StreamContext::writeComplete\n");
     }
 }
 
-ClientSocketContext *
+Http::StreamContext *
 ConnStateData::abortRequestParsing(const char *const uri)
 {
     ClientHttpRequest *http = new ClientHttpRequest(this);
     http->req_sz = inBuf.length();
     http->uri = xstrdup(uri);
     setLogUri (http, uri);
-    ClientSocketContext *context = new ClientSocketContext(clientConnection, http);
+    auto *context = new Http::StreamContext(clientConnection, http);
     StoreIOBuffer tempBuffer;
     tempBuffer.data = context->reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
@@ -1985,9 +1984,9 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
  *          parsing failure
  *  \param[out] http_ver will be set as a side-effect of the parsing
  *  \return NULL on incomplete requests,
- *          a ClientSocketContext structure on success or failure.
+ *          a Http::StreamContext on success or failure.
  */
-ClientSocketContext *
+Http::StreamContext *
 parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
 {
     /* Attempt to parse the first line; this will define where the method, url, version and header begin */
@@ -2055,7 +2054,7 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
     ClientHttpRequest *http = new ClientHttpRequest(csd);
 
     http->req_sz = hp->messageHeaderSize();
-    ClientSocketContext *result = new ClientSocketContext(csd->clientConnection, http);
+    Http::StreamContext *result = new Http::StreamContext(csd->clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result->reqbuf;
@@ -2166,7 +2165,7 @@ ConnStateData::quitAfterError(HttpRequest *request)
 }
 
 #if USE_OPENSSL
-bool ConnStateData::serveDelayedError(ClientSocketContext *context)
+bool ConnStateData::serveDelayedError(Http::StreamContext *context)
 {
     ClientHttpRequest *http = context->http;
 
@@ -2256,7 +2255,7 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
  * or false otherwise
  */
 bool
-clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
+clientTunnelOnError(ConnStateData *conn, Http::StreamContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
 {
     if (conn->port->flags.isIntercepted() &&
             Config.accessList.on_unsupported_protocol && conn->pipeline.nrequests <= 1) {
@@ -2273,7 +2272,7 @@ clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpReque
                 // The below may leak client streams BodyPipe objects. BUT, we need
                 // to check if client-streams detatch is safe to do here (finished() will detatch).
                 assert(conn->pipeline.front() == context); // XXX: still assumes HTTP/1 semantics
-                conn->pipeline.popMe(ClientSocketContextPointer(context));
+                conn->pipeline.popMe(Http::StreamContextPointer(context));
             }
             Comm::SetSelect(conn->clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
             conn->fakeAConnectRequest("unknown-protocol", conn->preservedClientData);
@@ -2314,7 +2313,7 @@ clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &re
 }
 
 void
-clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, ClientSocketContext *context)
+clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, Http::StreamContext *context)
 {
     ClientHttpRequest *http = context->http;
     bool chunked = false;
@@ -2850,7 +2849,7 @@ ConnStateData::clientParseRequests()
         if (needProxyProtocolHeader_ && !parseProxyProtocolHeader())
             break;
 
-        if (ClientSocketContext *context = parseOneRequest()) {
+        if (Http::StreamContext *context = parseOneRequest()) {
             debugs(33, 5, clientConnection << ": done parsing a request");
 
             AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "clientLifetimeTimeout",
@@ -3021,7 +3020,7 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
     // but if we fail when the server connection is used already, the server may send
     // us its response too, causing various assertions. How to prevent that?
 #if WE_KNOW_HOW_TO_SEND_ERRORS
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     if (context != NULL && !context->http->out.offset) { // output nothing yet
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext*>(node->data.getRaw());
@@ -3968,7 +3967,7 @@ ConnStateData::splice()
         transferProtocol = Http::ProtocolVersion();
         // inBuf still has the "CONNECT ..." request data, reset it to SSL hello message
         inBuf.append(rbuf.content(), rbuf.contentSize());
-        ClientSocketContext::Pointer context = pipeline.front();
+        Http::StreamContextPointer context = pipeline.front();
         ClientHttpRequest *http = context->http;
         tunnelStart(http);
     }
@@ -4416,7 +4415,7 @@ ConnStateData::finishDechunkingRequest(bool withSuccess)
         Must(!bodyPipe); // we rely on it being nil after we are done with body
         if (withSuccess) {
             Must(myPipe->bodySizeKnown());
-            ClientSocketContext::Pointer context = pipeline.front();
+            Http::StreamContextPointer context = pipeline.front();
             if (context != NULL && context->http && context->http->request)
                 context->http->request->setContentLength(myPipe->bodySize());
         }
@@ -30,125 +30,6 @@
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
-namespace AnyP
-{
-class PortCfg;
-} // namespace Anyp
-
-/**
- * Badly named.
- * This is in fact the processing context for a single HTTP transaction.
- *
- * A context lifetime extends from directly after a request has been parsed
- * off the client connection buffer, until the last byte of both request
- * and reply payload (if any) have been written.
- *
- * (NOTE: it is not certain yet if an early reply to a POST/PUT is sent by
- * the server whether the context will remain in the pipeline until its
- * request payload has finished being read. It is supposed to, but may not)
- *
- * Contexts self-register with the Pipeline being managed by the Server
- * for the connection on which the request was received.
- *
- * When HTTP/1 pipeline is operating there may be multiple transactions using
- * the clientConnection. Only the back() context may read from the connection,
- * and only the front() context may write to it. A context which needs to read
- * or write to the connection but does not meet those criteria must be shifted
- * to the deferred state.
- *
- * When a context is completed the finished() method needs to be called which
- * will perform all cleanup and deregistration operations. If the reason for
- * finishing is an error, then notifyIoError() needs to be called prior to
- * the finished() method.
- * The caller should follow finished() with a call to ConnStateData::kick()
- * to resume processing of other transactions or I/O on the connection.
- *
- * Alternatively the initiateClose() method can be called to terminate the
- * whole client connection and all other pending contexts.
- *
- * The socket level management is done by a Server which owns us.
- * The scope of this objects control over a socket consists of the data
- * buffer received from the Server with an initially unknown length.
- * When that length is known it sets the end boundary of our access to the
- * buffer.
- *
- * The individual processing actions are done by other Jobs which we
- * kick off as needed.
- *
- * XXX: If an async call ends the ClientHttpRequest job, ClientSocketContext
- * (and ConnStateData) may not know about it, leading to segfaults and
- * assertions. This is difficult to fix
- * because ClientHttpRequest lacks a good way to communicate its ongoing
- * destruction back to the ClientSocketContext which pretends to "own" *http.
- */
-class ClientSocketContext : public RefCountable
-{
-    MEMPROXY_CLASS(ClientSocketContext);
-
-public:
-    typedef RefCount<ClientSocketContext> Pointer;
-    ClientSocketContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq);
-    ~ClientSocketContext();
-    bool startOfOutput() const;
-    void writeComplete(size_t size);
-
-    Comm::ConnectionPointer clientConnection; /// details about the client connection socket.
-    ClientHttpRequest *http;    /* we pretend to own that job */
-    HttpReply *reply;
-    char reqbuf[HTTP_REQBUF_SZ];
-
-    struct {
-
-        unsigned deferred:1; /* This is a pipelined request waiting for the current object to complete */
-
-        unsigned parsed_ok:1; /* Was this parsed correctly? */
-    } flags;
-    bool mayUseConnection() const {return mayUseConnection_;}
-
-    void mayUseConnection(bool aBool) {
-        mayUseConnection_ = aBool;
-        debugs(33,3, HERE << "This " << this << " marked " << aBool);
-    }
-
-    class DeferredParams
-    {
-
-    public:
-        clientStreamNode *node;
-        HttpReply *rep;
-        StoreIOBuffer queuedBuffer;
-    };
-
-    DeferredParams deferredparams;
-    int64_t writtenToSocket;
-    void pullData();
-    int64_t getNextRangeOffset() const;
-    bool canPackMoreRanges() const;
-    clientStream_status_t socketState();
-    void sendBody(HttpReply * rep, StoreIOBuffer bodyData);
-    void sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData);
-    size_t lengthToSend(Range<int64_t> const &available);
-    void noteSentBodyBytes(size_t);
-    void buildRangeHeader(HttpReply * rep);
-    clientStreamNode * getTail() const;
-    clientStreamNode * getClientReplyContext() const;
-    ConnStateData *getConn() const;
-    void finished(); ///< cleanup when the transaction has finished. may destroy 'this'
-    void deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData);
-    bool multipartRangeRequest() const;
-    void registerWithConn();
-    void noteIoError(const int xerrno); ///< update state to reflect I/O error
-    void initiateClose(const char *reason); ///< terminate due to a send/write error (may continue reading)
-
-private:
-    void prepareReply(HttpReply * rep);
-    void packChunk(const StoreIOBuffer &bodyData, MemBuf &mb);
-    void packRange(StoreIOBuffer const &, MemBuf * mb);
-    void doClose();
-
-    bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
-    bool connRegistered_;
-};
 
 class ConnectionDetail;
 #if USE_OPENSSL
@@ -174,7 +55,7 @@ class ServerBump;
  * processed.
  *
  * Performs HTTP message processing to kick off the actual HTTP request
- * handling objects (ClientSocketContext, ClientHttpRequest, HttpRequest).
+ * handling objects (Http::StreamContext, ClientHttpRequest, HttpRequest).
  *
  * Performs SSL-Bump processing for switching between HTTP and HTTPS protocols.
  *
@@ -372,7 +253,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /// Returns false if no [delayed] error should be written to the client.
     /// Otherwise, writes the error to the client and returns true. Also checks
     /// for SQUID_X509_V_ERR_DOMAIN_MISMATCH on bumped requests.
-    bool serveDelayedError(ClientSocketContext *context);
+    bool serveDelayedError(Http::StreamContext *);
 
     Ssl::BumpMode sslBumpMode; ///< ssl_bump decision (Ssl::bumpEnd if n/a).
 
@@ -388,7 +269,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     virtual void writeControlMsgAndCall(HttpReply *rep, AsyncCall::Pointer &call) = 0;
 
     /// ClientStream calls this to supply response header (once) and data
-    /// for the current ClientSocketContext.
+    /// for the current Http::StreamContext.
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData) = 0;
 
     /// remove no longer needed leading bytes from the input buffer
@@ -397,7 +278,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /* TODO: Make the methods below (at least) non-public when possible. */
 
     /// stop parsing the request and create context for relaying error info
-    ClientSocketContext *abortRequestParsing(const char *const errUri);
+    Http::StreamContext *abortRequestParsing(const char *const errUri);
 
     /// generate a fake CONNECT request with the given payload
     /// at the beginning of the client I/O buffer
@@ -429,10 +310,10 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /// parse input buffer prefix into a single transfer protocol request
     /// return NULL to request more header bytes (after checking any limits)
     /// use abortRequestParsing() to handle parsing errors w/o creating request
-    virtual ClientSocketContext *parseOneRequest() = 0;
+    virtual Http::StreamContext *parseOneRequest() = 0;
 
     /// start processing a freshly parsed request
-    virtual void processParsedRequest(ClientSocketContext *context) = 0;
+    virtual void processParsedRequest(Http::StreamContext *) = 0;
 
     /// returning N allows a pipeline of 1+N requests (see pipeline_prefetch)
     virtual int pipelinePrefetchMax() const;
@@ -513,8 +394,8 @@ CSCB clientSocketRecipient;
 CSD clientSocketDetach;
 
 /* TODO: Move to HttpServer. Warning: Move requires large code nonchanges! */
-ClientSocketContext *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &);
-void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &, ClientSocketContext *);
+Http::StreamContext *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &);
+void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &, Http::StreamContext *);
 void clientPostHttpsAccept(ConnStateData *);
 
 #endif /* SQUID_CLIENTSIDE_H */
@@ -21,6 +21,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "globals.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -37,6 +37,7 @@
 #include "helper.h"
 #include "helper/Reply.h"
 #include "http.h"
+#include "http/StreamContext.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -19,6 +19,7 @@
 #include "errorpage.h"
 #include "fd.h"
 #include "ftp/Parsing.h"
+#include "http/StreamContext.h"
 #include "ip/tools.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
@@ -15,6 +15,7 @@
 #include "clients/FtpClient.h"
 #include "ftp/Elements.h"
 #include "ftp/Parsing.h"
+#include "http/StreamContext.h"
 #include "HttpHdrCc.h"
 #include "HttpRequest.h"
 #include "SBuf.h"
@@ -17,6 +17,7 @@
 
 #include "client_side_request.h"
 #include "esi/Context.h"
+#include "http/StreamContext.h"
 #include "Store.h"
 
 void
@@ -30,6 +30,7 @@
 #include "esi/Segment.h"
 #include "esi/VarState.h"
 #include "fatal.h"
+#include "http/StreamContext.h"
 #include "HttpHdrSc.h"
 #include "HttpHdrScTarget.h"
 #include "HttpReply.h"
@@ -17,6 +17,7 @@
 #include "esi/Include.h"
 #include "esi/VarState.h"
 #include "fatal.h"
+#include "http/StreamContext.h"
 #include "HttpReply.h"
 #include "log/access_log.h"
 
@@ -22,6 +22,7 @@
 #include "format/Token.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -17,6 +17,7 @@
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "fqdncache.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
@@ -32,6 +32,7 @@
 #include "http.h"
 #include "http/one/ResponseParser.h"
 #include "http/one/TeChunkedParser.h"
+#include "http/StreamContext.h"
 #include "HttpControlMsg.h"
 #include "HttpHdrCc.h"
 #include "HttpHdrContRange.h"
@@ -26,7 +26,8 @@ libsquid_http_la_SOURCES = \
 	StatusCode.cc \
 	StatusCode.h \
 	StatusLine.cc \
-	StatusLine.h
+	StatusLine.h \
+	StreamContext.h
 
 libsquid_http_la_LIBADD= one/libhttp1.la
 
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_HTTP_STREAMCONTEXT_H
+#define SQUID_SRC_HTTP_STREAMCONTEXT_H
+
+#include "http/forward.h"
+#include "mem/forward.h"
+#include "StoreIOBuffer.h"
+
+class clientStreamNode;
+class ClientHttpRequest;
+
+namespace Http
+{
+
+/**
+ * The processing context for a single HTTP transaction (stream).
+ *
+ * A context lifetime extends from directly after a request has been parsed
+ * off the client connection buffer, until the last byte of both request
+ * and reply payload (if any) have been written.
+ *
+ * Contexts self-register with the Http::Server Pipeline being managed by the
+ * Server for the connection on which the request was received.
+ *
+ * The socket level management and I/O is done by a Server which owns us.
+ * The scope of this objects control over a socket consists of the data
+ * buffer received from the Server with an initially unknown length.
+ * When that length is known it sets the end boundary of our access to the
+ * buffer.
+ *
+ * The individual processing actions are done by other Jobs which we start.
+ *
+ * When a context is completed the finished() method needs to be called which
+ * will perform all cleanup and deregistration operations. If the reason for
+ * finishing is an error, then notifyIoError() needs to be called prior to
+ * the finished() method.
+ * The caller should follow finished() with a call to ConnStateData::kick()
+ * to resume processing of other transactions or I/O on the connection.
+ *
+ * Alternatively the initiateClose() method can be called to terminate the
+ * whole client connection and all other pending contexts.
+ *
+ * HTTP/1.x:
+ *
+ * When HTTP/1 pipeline is operating there may be multiple transactions using
+ * the client connection. Only the back() context may read from the connection,
+ * and only the front() context may write to it. A context which needs to read
+ * or write to the connection but does not meet those criteria must be shifted
+ * to the deferred state.
+ *
+ *
+ * XXX: If an async call ends the ClientHttpRequest job, Http::StreamContext
+ * (and ConnStateData) may not know about it, leading to segfaults and
+ * assertions. This is difficult to fix
+ * because ClientHttpRequest lacks a good way to communicate its ongoing
+ * destruction back to the Http::StreamContext which pretends to "own" *http.
+ */
+class StreamContext : public RefCountable
+{
+    MEMPROXY_CLASS(StreamContext);
+
+public:
+    /// construct with HTTP/1.x details
+    StreamContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq);
+    ~StreamContext();
+
+    bool startOfOutput() const;
+    void writeComplete(size_t size);
+
+public: // HTTP/1.x state data
+
+    Comm::ConnectionPointer clientConnection; ///< details about the client connection socket
+    ClientHttpRequest *http;    /* we pretend to own that Job */
+    HttpReply *reply;
+    char reqbuf[HTTP_REQBUF_SZ];
+    struct {
+
+        unsigned deferred:1; /* This is a pipelined request waiting for the current object to complete */
+
+        unsigned parsed_ok:1; /* Was this parsed correctly? */
+    } flags;
+    bool mayUseConnection() const {return mayUseConnection_;}
+
+    void mayUseConnection(bool aBool) {
+        mayUseConnection_ = aBool;
+        debugs(33,3, HERE << "This " << this << " marked " << aBool);
+    }
+
+    class DeferredParams
+    {
+
+    public:
+        clientStreamNode *node;
+        HttpReply *rep;
+        StoreIOBuffer queuedBuffer;
+    };
+
+    DeferredParams deferredparams;
+    int64_t writtenToSocket;
+
+    void pullData();
+    int64_t getNextRangeOffset() const;
+    bool canPackMoreRanges() const;
+    clientStream_status_t socketState();
+    void sendBody(HttpReply * rep, StoreIOBuffer bodyData);
+    void sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData);
+    size_t lengthToSend(Range<int64_t> const &available);
+    void noteSentBodyBytes(size_t);
+    void buildRangeHeader(HttpReply * rep);
+    clientStreamNode * getTail() const;
+    clientStreamNode * getClientReplyContext() const;
+    ConnStateData *getConn() const;
+    void finished(); ///< cleanup when the transaction has finished. may destroy 'this'
+    void deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData);
+    bool multipartRangeRequest() const;
+    void registerWithConn();
+    void noteIoError(const int xerrno); ///< update state to reflect I/O error
+    void initiateClose(const char *reason); ///< terminate due to a send/write error (may continue reading)
+
+private:
+    void prepareReply(HttpReply * rep);
+    void packChunk(const StoreIOBuffer &bodyData, MemBuf &mb);
+    void packRange(StoreIOBuffer const &, MemBuf * mb);
+    void doClose();
+
+private:
+    bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
+    bool connRegistered_;
+};
+
+} // namespace Http
+
+#endif /* SQUID_SRC_HTTP_STREAMCONTEXT_H */
@@ -11,6 +11,14 @@
 
 #include "http/one/forward.h"
 
+namespace Http
+{
+
+class StreamContext;
+typedef RefCount<Http::StreamContext> StreamContextPointer;
+
+} // namespace Http
+
 // TODO move these classes into Http namespace
 class HttpRequestMethod;
 typedef RefCount<HttpRequestMethod> HttpRequestMethodPointer;
@@ -18,6 +18,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "globals.h"
+#include "http/StreamContext.h"
 #include "ident/AclIdent.h"
 #include "ident/Ident.h"
 
@@ -37,6 +37,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
+#include "http/StreamContext.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
 #include "icmp/IcmpSquid.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "hier_code.h"
 #include "htcp.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "ICP.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "redirect.h"
@@ -26,6 +26,7 @@
 #include "ftp/Parsing.h"
 #include "globals.h"
 #include "http/one/RequestParser.h"
+#include "http/StreamContext.h"
 #include "HttpHdrCc.h"
 #include "ip/tools.h"
 #include "ipc/FdNotes.h"
@@ -125,7 +126,7 @@ Ftp::Server::doProcessRequest()
 {
     // zero pipelinePrefetchMax() ensures that there is only parsed request
     Must(pipeline.count() == 1);
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     Must(context != nullptr);
 
     ClientHttpRequest *const http = context->http;
@@ -149,7 +150,7 @@ Ftp::Server::doProcessRequest()
 }
 
 void
-Ftp::Server::processParsedRequest(ClientSocketContext *)
+Ftp::Server::processParsedRequest(Http::StreamContext *)
 {
     Must(pipeline.count() == 1);
 
@@ -288,7 +289,7 @@ void
 Ftp::Server::notePeerConnection(Comm::ConnectionPointer conn)
 {
     // find request
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     Must(context != nullptr);
     ClientHttpRequest *const http = context->http;
     Must(http != NULL);
@@ -548,7 +549,7 @@ Ftp::CommandHasPathParameter(const SBuf &cmd)
 }
 
 /// creates a context filled with an error message for a given early error
-ClientSocketContext *
+Http::StreamContext *
 Ftp::Server::earlyError(const EarlyErrorKind eek)
 {
     /* Default values, to be updated by the switch statement below */
@@ -602,7 +603,7 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
         // no default so that a compiler can check that we have covered all cases
     }
 
-    ClientSocketContext *context = abortRequestParsing(errUri);
+    Http::StreamContext *context = abortRequestParsing(errUri);
     clientStreamNode *node = context->getClientReplyContext();
     Must(node);
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
@@ -616,9 +617,9 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
 }
 
 /// Parses a single FTP request on the control connection.
-/// Returns a new ClientSocketContext on valid requests and all errors.
+/// Returns a new Http::StreamContext on valid requests and all errors.
 /// Returns NULL on incomplete requests that may still succeed given more data.
-ClientSocketContext *
+Http::StreamContext *
 Ftp::Server::parseOneRequest()
 {
     flags.readMore = false; // common for all but one case below
@@ -696,7 +697,7 @@ Ftp::Server::parseOneRequest()
 
         // process USER request now because it sets FTP peer host name
         if (cmd == cmdUser()) {
-            if (ClientSocketContext *errCtx = handleUserRequest(cmd, params))
+            if (Http::StreamContext *errCtx = handleUserRequest(cmd, params))
                 return errCtx;
         }
     }
@@ -740,8 +741,8 @@ Ftp::Server::parseOneRequest()
     http->req_sz = tok.parsedSize();
     http->uri = newUri;
 
-    ClientSocketContext *const result =
-        new ClientSocketContext(clientConnection, http);
+    Http::StreamContext *const result =
+        new Http::StreamContext(clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result->reqbuf;
@@ -761,7 +762,7 @@ void
 Ftp::Server::handleReply(HttpReply *reply, StoreIOBuffer data)
 {
     // the caller guarantees that we are dealing with the current context only
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     assert(context != nullptr);
 
     if (context->http && context->http->al != NULL &&
@@ -869,7 +870,7 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
 void
 Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
 {
-    const ClientSocketContext::Pointer context(pipeline.front());
+    const Http::StreamContextPointer context(pipeline.front());
     assert(context != nullptr);
 
     if (context->http->request->errType != ERR_NONE) {
@@ -1227,7 +1228,7 @@ Ftp::Server::wroteEarlyReply(const CommIoCbParams &io)
         return;
     }
 
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     if (context != nullptr && context->http) {
         context->http->out.size += io.size;
         context->http->out.headers_sz += io.size;
@@ -1249,7 +1250,7 @@ Ftp::Server::wroteReply(const CommIoCbParams &io)
         return;
     }
 
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     assert(context->http);
     context->http->out.size += io.size;
     context->http->out.headers_sz += io.size;
@@ -1339,7 +1340,7 @@ Ftp::Server::handleRequest(HttpRequest *request)
 
 /// Called to parse USER command, which is required to create an HTTP request
 /// wrapper. W/o request, the errors are handled by returning earlyError().
-ClientSocketContext *
+Http::StreamContext *
 Ftp::Server::handleUserRequest(const SBuf &, SBuf &params)
 {
     if (params.isEmpty())
@@ -1665,7 +1666,7 @@ Ftp::Server::connectedForData(const CommConnectCbParams &params)
         if (params.conn != NULL)
             params.conn->close();
         setReply(425, "Cannot open data connection.");
-        ClientSocketContext::Pointer context = pipeline.front();
+        Http::StreamContextPointer context = pipeline.front();
         Must(context->http);
         Must(context->http->storeEntry() != NULL);
     } else {
@@ -1680,7 +1681,7 @@ Ftp::Server::connectedForData(const CommConnectCbParams &params)
 void
 Ftp::Server::setReply(const int code, const char *msg)
 {
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     ClientHttpRequest *const http = context->http;
     assert(http != NULL);
     assert(http->storeEntry() == NULL);
@@ -81,8 +81,8 @@ class Server: public ConnStateData
     };
 
     /* ConnStateData API */
-    virtual ClientSocketContext *parseOneRequest();
-    virtual void processParsedRequest(ClientSocketContext *context);
+    virtual Http::StreamContext *parseOneRequest();
+    virtual void processParsedRequest(Http::StreamContext *context);
     virtual void notePeerConnection(Comm::ConnectionPointer conn);
     virtual void clientPinnedConnectionClosed(const CommCloseCbParams &io);
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData);
@@ -112,7 +112,7 @@ class Server: public ConnStateData
 
     void calcUri(const SBuf *file);
     void changeState(const Ftp::ServerState newState, const char *reason);
-    ClientSocketContext *handleUserRequest(const SBuf &cmd, SBuf &params);
+    Http::StreamContext *handleUserRequest(const SBuf &cmd, SBuf &params);
     bool checkDataConnPost() const;
     void replyDataWritingCheckpoint();
     void maybeReadUploadData();
@@ -126,7 +126,7 @@ class Server: public ConnStateData
     void writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Pointer &call);
     void writeReply(MemBuf &mb);
 
-    ClientSocketContext *earlyError(const EarlyErrorKind eek);
+    Http::StreamContext *earlyError(const EarlyErrorKind eek);
     bool handleRequest(HttpRequest *);
     void setDataCommand();
     bool checkDataConnPre();
@@ -15,6 +15,7 @@
 #include "client_side_request.h"
 #include "comm/Write.h"
 #include "http/one/RequestParser.h"
+#include "http/StreamContext.h"
 #include "HttpHeaderTools.h"
 #include "profiler/Profiler.h"
 #include "servers/Http1Server.h"
@@ -70,7 +71,7 @@ Http::One::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
     readSomeData();
 }
 
-ClientSocketContext *
+Http::StreamContext *
 Http::One::Server::parseOneRequest()
 {
     PROF_start(HttpServer_parseOneRequest);
@@ -82,17 +83,17 @@ Http::One::Server::parseOneRequest()
         parser_ = new Http1::RequestParser();
 
     /* Process request */
-    ClientSocketContext *context = parseHttpRequest(this, parser_);
+    Http::StreamContext *context = parseHttpRequest(this, parser_);
 
     PROF_stop(HttpServer_parseOneRequest);
     return context;
 }
 
 void clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request);
-bool clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
+bool clientTunnelOnError(ConnStateData *conn, Http::StreamContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
 
 bool
-Http::One::Server::buildHttpRequest(ClientSocketContext *context)
+Http::One::Server::buildHttpRequest(Http::StreamContext *context)
 {
     HttpRequest::Pointer request;
     ClientHttpRequest *http = context->http;
@@ -179,14 +180,14 @@ Http::One::Server::buildHttpRequest(ClientSocketContext *context)
 }
 
 void
-Http::One::Server::proceedAfterBodyContinuation(ClientSocketContext::Pointer context)
+Http::One::Server::proceedAfterBodyContinuation(Http::StreamContextPointer context)
 {
     debugs(33, 5, "Body Continuation written");
     clientProcessRequest(this, parser_, context.getRaw());
 }
 
 void
-Http::One::Server::processParsedRequest(ClientSocketContext *context)
+Http::One::Server::processParsedRequest(Http::StreamContext *context)
 {
     if (!buildHttpRequest(context))
         return;
@@ -221,8 +222,8 @@ Http::One::Server::processParsedRequest(ClientSocketContext *context)
                 HttpReply::Pointer rep = new HttpReply;
                 rep->sline.set(Http::ProtocolVersion(), Http::scContinue);
 
-                typedef UnaryMemFunT<Http1::Server, ClientSocketContext::Pointer> CbDialer;
-                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, ClientSocketContext::Pointer(context)));
+                typedef UnaryMemFunT<Http1::Server, Http::StreamContextPointer> CbDialer;
+                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, Http::StreamContextPointer(context)));
                 sendControlMsg(HttpControlMsg(rep, cb));
                 return;
             }
@@ -242,7 +243,7 @@ void
 Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
 {
     // the caller guarantees that we are dealing with the current context only
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamContextPointer context = pipeline.front();
     Must(context != nullptr);
     const ClientHttpRequest *http = context->http;
     Must(http != NULL);
@@ -29,8 +29,8 @@ class Server: public ConnStateData
 
 protected:
     /* ConnStateData API */
-    virtual ClientSocketContext *parseOneRequest();
-    virtual void processParsedRequest(ClientSocketContext *context);
+    virtual Http::StreamContext *parseOneRequest();
+    virtual void processParsedRequest(Http::StreamContext *context);
     virtual void handleReply(HttpReply *rep, StoreIOBuffer receivedData);
     virtual void writeControlMsgAndCall(HttpReply *rep, AsyncCall::Pointer &call);
     virtual time_t idleTimeout() const;
@@ -42,17 +42,17 @@ class Server: public ConnStateData
     /* AsyncJob API */
     virtual void start();
 
-    void proceedAfterBodyContinuation(ClientSocketContext::Pointer context);
+    void proceedAfterBodyContinuation(Http::StreamContextPointer context);
 
 private:
-    void processHttpRequest(ClientSocketContext *const context);
+    void processHttpRequest(Http::StreamContext *const context);
     void handleHttpRequestData();
 
     /// Handles parsing results. May generate and deliver an error reply
     /// to the client if parsing is failed, or parses the url and build the
     /// HttpRequest object using parsing results.
     /// Return false if parsing is failed, true otherwise.
-    bool buildHttpRequest(ClientSocketContext *context);
+    bool buildHttpRequest(Http::StreamContext *context);
 
     Http1::RequestParserPointer parser_;
     HttpRequestMethod method_; ///< parsed HTTP method
@@ -14,6 +14,7 @@
 #include "Debug.h"
 #include "fd.h"
 #include "fde.h"
+#include "http/StreamContext.h"
 #include "MasterXaction.h"
 #include "servers/Server.h"
 #include "SquidConfig.h"
@@ -18,6 +18,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "helper/ResultCode.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "neighbors.h"
 #include "security/NegotiationHistory.h"
@@ -12,6 +12,7 @@
 
 #include "client_side.h"
 #include "FwdState.h"
+#include "http/StreamContext.h"
 #include "ssl/ServerBump.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -19,6 +19,7 @@
 #include "fde.h"
 #include "format/Token.h"
 #include "globals.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "IoStats.h"
 #include "mem/Pool.h"
@@ -8,30 +8,31 @@
 
 #include "squid.h"
 #include "client_side.h"
+#include "http/StreamContext.h"
 
 #define STUB_API "client_side.cc"
 #include "tests/STUB.h"
 
-//ClientSocketContext::ClientSocketContext(const ConnectionPointer&, ClientHttpRequest*) STUB
-//ClientSocketContext::~ClientSocketContext() STUB
-bool ClientSocketContext::startOfOutput() const STUB_RETVAL(false)
-void ClientSocketContext::writeComplete(size_t size) STUB
-void ClientSocketContext::pullData() STUB
-int64_t ClientSocketContext::getNextRangeOffset() const STUB_RETVAL(0)
-bool ClientSocketContext::canPackMoreRanges() const STUB_RETVAL(false)
-clientStream_status_t ClientSocketContext::socketState() STUB_RETVAL(STREAM_NONE)
-void ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData) STUB
-void ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData) STUB
-size_t ClientSocketContext::lengthToSend(Range<int64_t> const &available) STUB_RETVAL(0)
-void ClientSocketContext::noteSentBodyBytes(size_t) STUB
-void ClientSocketContext::buildRangeHeader(HttpReply * rep) STUB
-clientStreamNode * ClientSocketContext::getTail() const STUB_RETVAL(NULL)
-clientStreamNode * ClientSocketContext::getClientReplyContext() const STUB_RETVAL(NULL)
-void ClientSocketContext::finished() STUB
-void ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData) STUB
-bool ClientSocketContext::multipartRangeRequest() const STUB_RETVAL(false)
-void ClientSocketContext::registerWithConn() STUB
-void ClientSocketContext::noteIoError(const int xerrno) STUB
+//Http::StreamContext::Http::StreamContext(const ConnectionPointer&, ClientHttpRequest*) STUB
+//Http::StreamContext::~Http::StreamContext() STUB
+bool Http::StreamContext::startOfOutput() const STUB_RETVAL(false)
+void Http::StreamContext::writeComplete(size_t size) STUB
+void Http::StreamContext::pullData() STUB
+int64_t Http::StreamContext::getNextRangeOffset() const STUB_RETVAL(0)
+bool Http::StreamContext::canPackMoreRanges() const STUB_RETVAL(false)
+clientStream_status_t Http::StreamContext::socketState() STUB_RETVAL(STREAM_NONE)
+void Http::StreamContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData) STUB
+void Http::StreamContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData) STUB
+size_t Http::StreamContext::lengthToSend(Range<int64_t> const &available) STUB_RETVAL(0)
+void Http::StreamContext::noteSentBodyBytes(size_t) STUB
+void Http::StreamContext::buildRangeHeader(HttpReply * rep) STUB
+clientStreamNode * Http::StreamContext::getTail() const STUB_RETVAL(NULL)
+clientStreamNode * Http::StreamContext::getClientReplyContext() const STUB_RETVAL(NULL)
+void Http::StreamContext::finished() STUB
+void Http::StreamContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData) STUB
+bool Http::StreamContext::multipartRangeRequest() const STUB_RETVAL(false)
+void Http::StreamContext::registerWithConn() STUB
+void Http::StreamContext::noteIoError(const int xerrno) STUB
 
 bool ConnStateData::clientParseRequests() STUB_RETVAL(false)
 void ConnStateData::readNextRequest() STUB
@@ -66,7 +67,7 @@ void ConnStateData::sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &r
 void ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply) STUB
 void ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode) STUB
 void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &certProperties) STUB
-bool ConnStateData::serveDelayedError(ClientSocketContext *context) STUB_RETVAL(false)
+bool ConnStateData::serveDelayedError(Http::StreamContext *context) STUB_RETVAL(false)
 #endif
 
 void setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl) STUB
@@ -8,6 +8,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
+#include "http/StreamContext.h"
 #include "Store.h"
 
 #if !_USE_INLINE_
@@ -17,6 +17,7 @@
 #include "fqdncache.h"
 #include "fs_io.h"
 #include "htcp.h"
+#include "http/StreamContext.h"
 #include "ICP.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
@@ -25,6 +25,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "http.h"
+#include "http/StreamContext.h"
 #include "HttpRequest.h"
 #include "HttpStateFlags.h"
 #include "ip/QosConfig.h"
@@ -1240,7 +1241,7 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     tunnelState = new TunnelStateData;
     tunnelState->url = SBufToCstring(url);
     tunnelState->request = request;
-    tunnelState->server.size_ptr = NULL; //Set later if ClientSocketContext is available
+    tunnelState->server.size_ptr = NULL; //Set later if Http::StreamContext is available
 
     // Temporary static variable to store the unneeded for our case status code
     static int status_code = 0;
@@ -1249,7 +1250,7 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
 
     ConnStateData *conn;
     if ((conn = request->clientConnectionManager.get())) {
-        ClientSocketContext::Pointer context = conn->pipeline.front();
+        Http::StreamContextPointer context = conn->pipeline.front();
         if (context != nullptr && context->http != nullptr) {
             tunnelState->logTag_ptr = &context->http->logType;
             tunnelState->server.size_ptr = &context->http->out.size;