@@ -1,5 +1,5 @@
 /*
- * $Id: util.h,v 1.54 1999/10/04 05:04:49 wessels Exp $
+ * $Id: util.h,v 1.55 2000/10/17 08:06:01 adrian Exp $
  *
  * AUTHOR: Harvest Derived
  *
@@ -85,7 +85,7 @@ extern char *rfc1738_escape_part(const char *);
 extern void rfc1738_unescape(char *);
 
 #if XMALLOC_STATISTICS
-extern void malloc_statistics(void (*)(int, int, void *), void *);
+extern void malloc_statistics(void (*)(int, int, int, void *), void *);
 #endif
 
 #if XMALLOC_TRACE
@@ -1,6 +1,6 @@
 
 /*
- * $Id: util.c,v 1.71 2000/08/19 06:10:00 hno Exp $
+ * $Id: util.c,v 1.72 2000/10/17 08:06:01 adrian Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -106,19 +106,34 @@ log_trace_done()
 
 #if XMALLOC_STATISTICS
 #define DBG_MAXSIZE   (1024*1024)
+#define DBG_SPLIT     (256)	/* mallocs below this value are tracked with DBG_GRAIN_SM precision instead of DBG_GRAIN */
 #define DBG_GRAIN     (16)
-#define DBG_MAXINDEX  (DBG_MAXSIZE/DBG_GRAIN)
-#define DBG_INDEX(sz) (sz<DBG_MAXSIZE?(sz+DBG_GRAIN-1)/DBG_GRAIN:DBG_MAXINDEX)
+#define DBG_GRAIN_SM  (4)
+#define DBG_OFFSET    (DBG_SPLIT/DBG_GRAIN_SM - DBG_SPLIT/DBG_GRAIN )
+#define DBG_MAXINDEX  (DBG_MAXSIZE/DBG_GRAIN + DBG_OFFSET)
+// #define DBG_INDEX(sz) (sz<DBG_MAXSIZE?(sz+DBG_GRAIN-1)/DBG_GRAIN:DBG_MAXINDEX)
 static int malloc_sizes[DBG_MAXINDEX + 1];
+static int malloc_histo[DBG_MAXINDEX + 1];
 static int dbg_stat_init = 0;
 
+static int
+DBG_INDEX(int sz)
+{
+    if (sz >= DBG_MAXSIZE)
+	return DBG_MAXINDEX;
+
+    if (sz <= DBG_SPLIT)
+	return (sz+DBG_GRAIN_SM-1)/DBG_GRAIN_SM;
+
+    return (sz+DBG_GRAIN-1)/DBG_GRAIN + DBG_OFFSET;
+}
 
 static void
 stat_init(void)
 {
     int i;
     for (i = 0; i <= DBG_MAXINDEX; i++)
-	malloc_sizes[i] = 0;
+	malloc_sizes[i] = malloc_histo[i] = 0;
     dbg_stat_init = 1;
 }
 
@@ -131,11 +146,15 @@ malloc_stat(int sz)
 }
 
 void
-malloc_statistics(void (*func) (int, int, void *), void *data)
+malloc_statistics(void (*func) (int, int, int, void *), void *data)
 {
     int i;
-    for (i = 0; i <= DBG_MAXSIZE; i += DBG_GRAIN)
-	func(i, malloc_sizes[DBG_INDEX(i)], data);
+    for (i = 0; i <= DBG_SPLIT; i += DBG_GRAIN_SM)
+	func(i, malloc_sizes[DBG_INDEX(i)], malloc_histo[DBG_INDEX(i)], data);
+    i -= DBG_GRAIN_SM;
+    for (i = i; i <= DBG_MAXSIZE; i += DBG_GRAIN)
+	func(i, malloc_sizes[DBG_INDEX(i)], malloc_histo[DBG_INDEX(i)], data);
+    xmemcpy(&malloc_histo, &malloc_sizes, sizeof(malloc_sizes));
 }
 #endif /* XMALLOC_STATISTICS */
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: MemBuf.cc,v 1.25 2000/06/06 19:34:30 hno Exp $
+ * $Id: MemBuf.cc,v 1.26 2000/10/17 08:06:01 adrian Exp $
  *
  * DEBUG: section 59    auto-growing Memory Buffer with printf
  * AUTHOR: Alex Rousskov
@@ -317,6 +317,14 @@ memBufGrow(MemBuf * mb, mb_size_t min_cap)
 	mb->buf = memAllocate(MEM_8K_BUF);
 	mb->freefunc = &memFree8K;
 	break;
+    case 16384:
+	mb->buf = memAllocate(MEM_16K_BUF);
+	mb->freefunc = &memFree16K;
+	break;
+    case 32768:
+	mb->buf = memAllocate(MEM_32K_BUF);
+	mb->freefunc = &memFree32K;
+	break;
     default:
 	/* recycle if old buffer was not "pool"ed */
 	if (old_mb.freefunc == &xfree) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cbdata.cc,v 1.29 2000/03/06 16:23:29 wessels Exp $
+ * $Id: cbdata.cc,v 1.30 2000/10/17 08:06:02 adrian Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * AUTHOR: Duane Wessels
@@ -87,6 +87,7 @@ static HASHCMP cbdata_cmp;
 static HASHHASH cbdata_hash;
 static void cbdataReallyFree(cbdata * c);
 static OBJH cbdataDump;
+static MemPool *cbdata_pool = NULL;
 
 static int
 cbdata_cmp(const void *p1, const void *p2)
@@ -105,6 +106,9 @@ void
 cbdataInit(void)
 {
     debug(45, 3) ("cbdataInit\n");
+    if (cbdata_pool == NULL) {
+	cbdata_pool = memPoolCreate("cbdata", sizeof(cbdata));
+    }
     htable = hash_create(cbdata_cmp, 1 << 8, cbdata_hash);
     cachemgrRegister("cbdata",
 	"Callback Data Registry Contents",
@@ -123,7 +127,7 @@ cbdataAdd(const void *p, CBDUNL * unlock_func, int id)
     debug(45, 3) ("cbdataAdd: %p\n", p);
     assert(htable != NULL);
     assert(hash_lookup(htable, p) == NULL);
-    c = xcalloc(1, sizeof(cbdata));
+    c = memPoolAlloc(cbdata_pool);
     c->key = p;
     c->valid = 1;
     c->unlock_func = unlock_func;
@@ -144,7 +148,7 @@ cbdataReallyFree(cbdata * c)
     int id = c->id;
     hash_remove_link(htable, (hash_link *) c);
     cbdataCount--;
-    xfree(c);
+    memPoolFree(cbdata_pool,c);
     debug(45, 3) ("cbdataReallyFree: Freeing %p\n", p);
     if (unlock_func)
 	unlock_func(p, id);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.505 2000/10/04 17:09:24 wessels Exp $
+ * $Id: client_side.cc,v 1.506 2000/10/17 08:06:02 adrian Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -70,7 +70,6 @@
 
 static const char *const crlf = "\r\n";
 
-#define REQUEST_BUF_SIZE 4096
 #define FAILURE_MODE_TIME 300
 
 /* Local functions */
@@ -799,7 +798,10 @@ connStateFree(int fd, void *data)
 	assert(connState->chr != connState->chr->next);
 	httpRequestFree(http);
     }
-    safe_free(connState->in.buf);
+    if (connState->in.size == CLIENT_REQ_BUF_SZ)
+	memFree(connState->in.buf, MEM_CLIENT_REQ_BUF);
+    else
+	safe_free(connState->in.buf);
     /* XXX account connState->in.buf */
     pconnHistCount(0, connState->nrequests);
     cbdataFree(connState);
@@ -2184,8 +2186,8 @@ clientProcessMiss(clientHttpRequest * http)
 static clientHttpRequest *
 parseHttpRequestAbort(ConnStateData * conn, const char *uri)
 {
-    clientHttpRequest *http = xcalloc(1, sizeof(clientHttpRequest));
-    cbdataAdd(http, cbdataXfree, 0);
+    clientHttpRequest *http = memAllocate(MEM_CLIENTHTTPREQUEST);
+    cbdataAdd(http, memFree, MEM_CLIENTHTTPREQUEST);
     http->conn = conn;
     http->start = current_time;
     http->req_sz = conn->in.offset;
@@ -2318,8 +2320,8 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     assert(prefix_sz <= conn->in.offset);
 
     /* Ok, all headers are received */
-    http = xcalloc(1, sizeof(clientHttpRequest));
-    cbdataAdd(http, cbdataXfree, 0);
+    http = memAllocate(MEM_CLIENTHTTPREQUEST);
+    cbdataAdd(http, memFree, MEM_CLIENTHTTPREQUEST);
     http->http_ver = http_ver;
     http->conn = conn;
     http->start = current_time;
@@ -2462,6 +2464,7 @@ clientReadRequest(int fd, void *data)
     int k;
     request_t *request = NULL;
     int size;
+    void *p;
     method_t method;
     clientHttpRequest *http = NULL;
     clientHttpRequest **H = NULL;
@@ -2695,8 +2698,14 @@ clientReadRequest(int fd, void *data)
 		    return;
 		}
 		/* Grow the request memory area to accomodate for a large request */
-		conn->in.size += REQUEST_BUF_SIZE;
-		conn->in.buf = xrealloc(conn->in.buf, conn->in.size);
+		conn->in.size += CLIENT_REQ_BUF_SZ;
+		if (conn->in.size == 2 * CLIENT_REQ_BUF_SZ) {
+		    p = conn->in.buf;	/* get rid of fixed size Pooled buffer */
+		    conn->in.buf = xcalloc(2, CLIENT_REQ_BUF_SZ);
+		    xmemcpy(conn->in.buf, p, CLIENT_REQ_BUF_SZ);
+		    memFree(p, MEM_CLIENT_REQ_BUF);
+		} else
+		    conn->in.buf = xrealloc(conn->in.buf, conn->in.size);
 		/* XXX account conn->in.buf */
 		debug(33, 3) ("Handling a large request, offset=%d inbufsize=%d\n",
 		    (int) conn->in.offset, conn->in.size);
@@ -2800,14 +2809,14 @@ httpAccept(int sock, void *data)
 	}
 	debug(33, 4) ("httpAccept: FD %d: accepted\n", fd);
 	connState = memAllocate(MEM_CONNSTATEDATA);
+	cbdataAdd(connState, memFree, MEM_CONNSTATEDATA);
 	connState->peer = peer;
 	connState->log_addr = peer.sin_addr;
 	connState->log_addr.s_addr &= Config.Addrs.client_netmask.s_addr;
 	connState->me = me;
 	connState->fd = fd;
-	connState->in.size = REQUEST_BUF_SIZE;
-	connState->in.buf = xcalloc(connState->in.size, 1);
-	cbdataAdd(connState, memFree, MEM_CONNSTATEDATA);
+	connState->in.size = CLIENT_REQ_BUF_SZ;
+	connState->in.buf = memAllocate(MEM_CLIENT_REQ_BUF);
 	/* XXX account connState->in.buf */
 	comm_add_close_handler(fd, connStateFree, connState);
 	if (Config.onoff.log_fqdn)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.309 2000/10/10 02:22:25 wessels Exp $
+ * $Id: comm.cc,v 1.310 2000/10/17 08:06:02 adrian Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -73,6 +73,7 @@ static CBDUNL commConnectDataFree;
 
 static MemPool *comm_write_pool = NULL;
 static MemPool *conn_state_pool = NULL;
+static MemPool *conn_close_pool = NULL;
 
 static void
 CommWriteStateCallbackAndFree(int fd, int code)
@@ -533,7 +534,7 @@ commCallCloseHandlers(int fd)
 	if (cbdataValid(ch->data))
 	    ch->handler(fd, ch->data);
 	cbdataUnlock(ch->data);
-	safe_free(ch);
+	memPoolFree(conn_close_pool, ch);	// AAA
     }
 }
 
@@ -653,7 +654,7 @@ commSetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t
 void
 comm_add_close_handler(int fd, PF * handler, void *data)
 {
-    close_handler *new = xmalloc(sizeof(*new));
+    close_handler *new = memPoolAlloc(conn_close_pool);	// AAA
     close_handler *c;
     debug(5, 5) ("comm_add_close_handler: FD %d, handler=%p, data=%p\n",
 	fd, handler, data);
@@ -684,7 +685,7 @@ comm_remove_close_handler(int fd, PF * handler, void *data)
     else
 	fd_table[fd].close_handler = p->next;
     cbdataUnlock(p->data);
-    safe_free(p);
+    memPoolFree(conn_close_pool,p);	// AAA
 }
 
 static void
@@ -785,6 +786,7 @@ comm_init(void)
     RESERVED_FD = XMIN(100, Squid_MaxFD / 4);
     comm_write_pool = memPoolCreate("CommWriteStateData", sizeof(CommWriteStateData));
     conn_state_pool = memPoolCreate("ConnectStateData", sizeof(ConnectStateData));
+    conn_close_pool = memPoolCreate("close_handler", sizeof(close_handler));
 }
 
 /* Write to FD. */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: defines.h,v 1.82 2000/07/18 06:16:41 wessels Exp $
+ * $Id: defines.h,v 1.83 2000/10/17 08:06:03 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -172,6 +172,7 @@
 
 #define AUTH_MSG_SZ 4096
 #define HTTP_REPLY_BUF_SZ 4096
+#define CLIENT_REQ_BUF_SZ 4096
 
 #if !defined(ERROR_BUF_SZ) && defined(MAX_URL)
 #define ERROR_BUF_SZ (MAX_URL << 2)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: disk.cc,v 1.150 2000/06/27 22:06:00 hno Exp $
+ * $Id: disk.cc,v 1.151 2000/10/17 08:06:03 adrian Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -146,7 +146,7 @@ diskCombineWrites(struct _fde_disk *fdd)
 	len = 0;
 	for (q = fdd->write_q; q != NULL; q = q->next)
 	    len += q->len - q->buf_offset;
-	wq = xcalloc(1, sizeof(dwrite_q));
+	wq = memAllocate(MEM_DWRITE_Q);
 	wq->buf = xmalloc(len);
 	wq->len = 0;
 	wq->buf_offset = 0;
@@ -160,7 +160,7 @@ diskCombineWrites(struct _fde_disk *fdd)
 	    fdd->write_q = q->next;
 	    if (q->free_func)
 		(q->free_func) (q->buf);
-	    safe_free(q);
+	    if (q) { memFree(q, MEM_DWRITE_Q); q = NULL; }
 	} while (fdd->write_q != NULL);
 	fdd->write_q_tail = wq;
 	fdd->write_q = wq;
@@ -224,7 +224,7 @@ diskHandleWrite(int fd, void *notused)
 		fdd->write_q = q->next;
 		if (q->free_func)
 		    (q->free_func) (q->buf);
-		safe_free(q);
+		if (q) { memFree(q, MEM_DWRITE_Q); q = NULL; }
 	    } while ((q = fdd->write_q));
 	}
 	len = 0;
@@ -241,7 +241,7 @@ diskHandleWrite(int fd, void *notused)
 	    fdd->write_q = q->next;
 	    if (q->free_func)
 		(q->free_func) (q->buf);
-	    safe_free(q);
+	    if (q) { memFree(q, MEM_DWRITE_Q); q = NULL; }
 	}
     }
     if (fdd->write_q == NULL) {
@@ -295,7 +295,7 @@ file_write(int fd,
     assert(fd >= 0);
     assert(F->flags.open);
     /* if we got here. Caller is eligible to write. */
-    wq = xcalloc(1, sizeof(dwrite_q));
+    wq = memAllocate(MEM_DWRITE_Q);
     wq->file_offset = file_offset;
     wq->buf = ptr_to_buf;
     wq->len = len;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.173 2000/10/04 00:24:17 wessels Exp $
+ * $Id: enums.h,v 1.174 2000/10/17 08:06:03 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -506,6 +506,9 @@ typedef enum {
     MEM_2K_BUF,
     MEM_4K_BUF,
     MEM_8K_BUF,
+    MEM_16K_BUF,
+    MEM_32K_BUF,
+    MEM_64K_BUF,
     MEM_ACCESSLOGENTRY,
     MEM_ACL,
     MEM_ACLCHECK_T,
@@ -529,6 +532,7 @@ typedef enum {
 #if USE_CACHE_DIGESTS
     MEM_DIGEST_FETCH_STATE,
 #endif
+    MEM_LINK_LIST,
     MEM_DLINK_LIST,
     MEM_DLINK_NODE,
     MEM_DNSSERVER_T,
@@ -598,6 +602,11 @@ typedef enum {
     MEM_IDNS_QUERY,
 #endif
     MEM_EVENT,
+    MEM_TLV,
+    MEM_SWAP_LOG_DATA,
+    MEM_GEN_CBDATA,
+    MEM_PUMP_STATE_DATA,
+    MEM_CLIENT_REQ_BUF,
     MEM_MAX
 } mem_type;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.140 2000/10/04 19:34:13 wessels Exp $
+ * $Id: fqdncache.cc,v 1.141 2000/10/17 08:06:03 adrian Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -367,9 +367,9 @@ fqdncache_nbgethostbyaddr(struct in_addr addr, FQDNH * handler, void *handlerDat
     f->handlerData = handlerData;
     cbdataLock(handlerData);
     f->request_time = current_time;
-    c = xcalloc(1, sizeof(*c));
+    c = memAllocate(MEM_GEN_CBDATA);
     c->data = f;
-    cbdataAdd(c, cbdataXfree, 0);
+    cbdataAdd(c, memFree, MEM_GEN_CBDATA);
 #if USE_DNSSERVERS
     dnsSubmit(f->name, fqdncacheHandleReply, c);
 #else
@@ -1,5 +1,5 @@
 /*
- * $Id: aiops.cc,v 1.2 2000/06/27 08:33:53 hno Exp $
+ * $Id: aiops.cc,v 1.3 2000/10/17 08:06:07 adrian Exp $
  *
  * DEBUG: section 43    AIOPS
  * AUTHOR: Stewart Forster <slf@connect.com.au>
@@ -140,6 +140,16 @@ static void aio_poll_threads(void);
 static aio_thread_t *threads;
 static int aio_initialised = 0;
 
+#define AIO_LARGE_BUFS  16384
+#define AIO_MEDIUM_BUFS	AIO_LARGE_BUFS >> 1
+#define AIO_SMALL_BUFS	AIO_LARGE_BUFS >> 2
+#define AIO_TINY_BUFS	AIO_LARGE_BUFS >> 3
+
+static MemPool *aio_large_bufs = NULL;		// 16K
+static MemPool *aio_medium_bufs = NULL;		// 8K
+static MemPool *aio_small_bufs = NULL;		// 4K
+static MemPool *aio_tiny_bufs = NULL;		// 2K
+
 static int request_queue_len = 0;
 static MemPool *aio_request_pool = NULL;
 static aio_request_t *request_queue_head = NULL;
@@ -153,6 +163,49 @@ static pthread_attr_t globattr;
 static struct sched_param globsched;
 static pthread_t main_thread;
 
+static MemPool *
+aio_get_pool(int size)
+{
+    MemPool *p;
+    if (size <= AIO_LARGE_BUFS) {
+        if (size <= AIO_TINY_BUFS)
+           p = aio_tiny_bufs;
+        else if (size <= AIO_SMALL_BUFS)
+           p = aio_small_bufs;
+        else if (size <= AIO_MEDIUM_BUFS)
+           p = aio_medium_bufs;
+        else
+           p = aio_large_bufs;
+    } else
+	p = NULL;
+    return p;
+}
+
+static void *
+aio_xmalloc(int size)
+{
+    void *p;
+    MemPool *pool;
+
+    if ( (pool = aio_get_pool(size)) != NULL) {
+	p = memPoolAlloc(pool);
+    } else
+	p = xmalloc(size);
+
+    return p;
+}
+
+static void
+aio_xfree(void *p, int size)
+{
+    MemPool *pool;
+
+    if ( (pool = aio_get_pool(size)) != NULL) {
+        memPoolFree(pool, p);
+    } else
+        xfree(p);
+}
+
 static void
 aio_init(void)
 {
@@ -206,6 +259,10 @@ aio_init(void)
 
     /* Create request pool */
     aio_request_pool = memPoolCreate("aio_request", sizeof(aio_request_t));
+    aio_large_bufs = memPoolCreate("aio_large_bufs", AIO_LARGE_BUFS);
+    aio_medium_bufs = memPoolCreate("aio_medium_bufs", AIO_MEDIUM_BUFS);
+    aio_small_bufs = memPoolCreate("aio_small_bufs", AIO_SMALL_BUFS);
+    aio_tiny_bufs = memPoolCreate("aio_tiny_bufs", AIO_TINY_BUFS);
 
     aio_initialised = 1;
 }
@@ -463,7 +520,7 @@ aio_cleanup_request(aio_request_t * requestp)
     case _AIO_OP_STAT:
 	if (!cancelled && requestp->ret == 0)
 	    xmemcpy(requestp->statp, requestp->tmpstatp, sizeof(struct stat));
-	xfree(requestp->tmpstatp);
+	aio_xfree(requestp->tmpstatp, sizeof(struct stat));
     case _AIO_OP_OPEN:
 	if (cancelled && requestp->ret >= 0)
 	    /* The open() was cancelled but completed */
@@ -484,7 +541,7 @@ aio_cleanup_request(aio_request_t * requestp)
 	if (!cancelled && requestp->ret > 0)
 	    xmemcpy(requestp->bufferp, requestp->tmpbufp, requestp->ret);
     case _AIO_OP_WRITE:
-	xfree(requestp->tmpbufp);
+	aio_xfree(requestp->tmpbufp, requestp->buflen);
 	break;
     default:
 	break;
@@ -576,11 +633,7 @@ aio_read(int fd, char *bufp, int bufs, off_t offset, int whence, aio_result_t *
     }
     requestp->fd = fd;
     requestp->bufferp = bufp;
-    if ((requestp->tmpbufp = (char *) xmalloc(bufs)) == NULL) {
-	memPoolFree(aio_request_pool, requestp);
-	errno = ENOMEM;
-	return -1;
-    }
+    requestp->tmpbufp = (char *) aio_xmalloc(bufs);
     requestp->buflen = bufs;
     requestp->offset = offset;
     requestp->whence = whence;
@@ -614,11 +667,7 @@ aio_write(int fd, char *bufp, int bufs, off_t offset, int whence, aio_result_t *
 	return -1;
     }
     requestp->fd = fd;
-    if ((requestp->tmpbufp = (char *) xmalloc(bufs)) == NULL) {
-	memPoolFree(aio_request_pool, requestp);
-	errno = ENOMEM;
-	return -1;
-    }
+    requestp->tmpbufp = (char *) aio_xmalloc(bufs);
     xmemcpy(requestp->tmpbufp, bufp, bufs);
     requestp->buflen = bufs;
     requestp->offset = offset;
@@ -682,19 +731,10 @@ aio_stat(const char *path, struct stat *sb, aio_result_t * resultp)
 	return -1;
     }
     len = strlen(path) + 1;
-    if ((requestp->path = (char *) xmalloc(len)) == NULL) {
-	memPoolFree(aio_request_pool, requestp);
-	errno = ENOMEM;
-	return -1;
-    }
+    requestp->path = (char *) xmalloc(len);
     strncpy(requestp->path, path, len);
     requestp->statp = sb;
-    if ((requestp->tmpstatp = (struct stat *) xmalloc(sizeof(struct stat))) == NULL) {
-	xfree(requestp->path);
-	memPoolFree(aio_request_pool, requestp);
-	errno = ENOMEM;
-	return -1;
-    }
+    requestp->tmpstatp = (struct stat *) aio_xmalloc(sizeof(struct stat));
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_STAT;
     requestp->cancelled = 0;
@@ -725,11 +765,7 @@ aio_unlink(const char *path, aio_result_t * resultp)
 	return -1;
     }
     len = strlen(path) + 1;
-    if ((requestp->path = (char *) xmalloc(len)) == NULL) {
-	memPoolFree(aio_request_pool, requestp);
-	errno = ENOMEM;
-	return -1;
-    }
+    requestp->path = (char *) xmalloc(len);
     strncpy(requestp->path, path, len);
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_UNLINK;
@@ -74,11 +74,28 @@ struct _aiostate_t {
     link_list *pending_reads;
 };
 
+struct _queued_write {
+    char *buf;
+    size_t size;
+    off_t offset;
+    FREE *free_func;
+};
+
+struct _queued_read {
+    char *buf;
+    size_t size;
+    off_t offset;
+    STRCB *callback;
+    void *callback_data;
+};
+
 typedef struct _aioinfo_t aioinfo_t;
 typedef struct _aiostate_t aiostate_t;
 
-/* The aio_state memory pool */
+/* The aio_state memory pools */
 extern MemPool *aio_state_pool;
+extern MemPool *aio_qread_pool;
+extern MemPool *aio_qwrite_pool;
 
 extern void storeAufsDirMapBitReset(SwapDir *, sfileno);
 extern int storeAufsDirMapBitAllocate(SwapDir *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_aufs.cc,v 1.9 2000/10/13 06:35:54 wessels Exp $
+ * $Id: store_dir_aufs.cc,v 1.10 2000/10/17 08:06:07 adrian Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -72,6 +72,8 @@ struct _RebuildState {
 static int n_asyncufs_dirs = 0;
 static int *asyncufs_dir_index = NULL;
 MemPool *aio_state_pool = NULL;
+MemPool *aio_qread_pool = NULL;
+MemPool *aio_qwrite_pool = NULL;
 static int asyncufs_initialised = 0;
 
 static char *storeAufsDirSwapSubDir(SwapDir *, int subdirn);
@@ -1075,11 +1077,17 @@ storeAufsDirWriteCleanDone(SwapDir * sd)
     sd->log.clean.write = NULL;
 }
 
+static void
+storeSwapLogDataFree(void *s)
+{
+    memFree(s, MEM_SWAP_LOG_DATA);
+}
+
 static void
 storeAufsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
     aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
-    storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
+    storeSwapLogData *s = memAllocate(MEM_SWAP_LOG_DATA);
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
     s->timestamp = e->timestamp;
@@ -1096,7 +1104,7 @@ storeAufsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 	sizeof(storeSwapLogData),
 	NULL,
 	NULL,
-	xfree);
+	(FREE *) storeSwapLogDataFree);
 }
 
 static void
@@ -1689,6 +1697,8 @@ storeAufsDirDone(void)
 {
     aioDone();
     memPoolDestroy(aio_state_pool);
+    memPoolDestroy(aio_qread_pool);
+    memPoolDestroy(aio_qwrite_pool);
     asyncufs_initialised = 0;
 }
 
@@ -1700,6 +1710,11 @@ storeFsSetup_aufs(storefs_entry_t * storefs)
     storefs->reconfigurefunc = storeAufsDirReconfigure;
     storefs->donefunc = storeAufsDirDone;
     aio_state_pool = memPoolCreate("AUFS IO State data", sizeof(aiostate_t));
+    aio_qread_pool = memPoolCreate("AUFS Queued read data",
+        sizeof(queued_read));
+    aio_qwrite_pool = memPoolCreate("AUFS Queued write data",
+        sizeof(queued_write));
+
     asyncufs_initialised = 1;
     aioInit();
 }
@@ -14,21 +14,6 @@ static int storeAufsSomethingPending(storeIOState *);
 static int storeAufsKickWriteQueue(storeIOState * sio);
 static void storeAufsIOFreeEntry(void *, int);
 
-struct _queued_write {
-    char *buf;
-    size_t size;
-    off_t offset;
-    FREE *free_func;
-};
-
-struct _queued_read {
-    char *buf;
-    size_t size;
-    off_t offset;
-    STRCB *callback;
-    void *callback_data;
-};
-
 /* === PUBLIC =========================================================== */
 
 /* open for reading */
@@ -137,7 +122,7 @@ storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t of
 	debug(78, 3) ("storeAufsRead: queueing read because FD < 0\n");
 	assert(aiostate->flags.opening);
 	assert(aiostate->pending_reads == NULL);
-	q = xcalloc(1, sizeof(*q));
+	q = memPoolAlloc(aio_qread_pool);
 	q->buf = buf;
 	q->size = size;
 	q->offset = offset;
@@ -169,7 +154,7 @@ storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t o
 	/* disk file not opened yet */
 	struct _queued_write *q;
 	assert(aiostate->flags.opening);
-	q = xcalloc(1, sizeof(*q));
+	q = memPoolAlloc(aio_qwrite_pool);
 	q->buf = buf;
 	q->size = size;
 	q->offset = offset;
@@ -180,7 +165,7 @@ storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t o
     if (aiostate->flags.writing) {
 	struct _queued_write *q;
 	debug(78, 3) ("storeAufsWrite: queuing write\n");
-	q = xcalloc(1, sizeof(*q));
+	q = memPoolAlloc(aio_qwrite_pool);
 	q->buf = buf;
 	q->size = size;
 	q->offset = offset;
@@ -220,7 +205,7 @@ storeAufsKickWriteQueue(storeIOState * sio)
     debug(78, 3) ("storeAufsKickWriteQueue: writing queued chunk of %d bytes\n",
 	q->size);
     storeAufsWrite(INDEXSD(sio->swap_dirn), sio, q->buf, q->size, q->offset, q->free_func);
-    xfree(q);
+    memPoolFree(aio_qwrite_pool, q);
     return 1;
 }
 
@@ -234,7 +219,7 @@ storeAufsKickReadQueue(storeIOState * sio)
     debug(78, 3) ("storeAufsKickReadQueue: reading queued request of %d bytes\n",
 	q->size);
     storeAufsRead(INDEXSD(sio->swap_dirn), sio, q->buf, q->size, q->offset, q->callback, q->callback_data);
-    xfree(q);
+    memPoolFree(aio_qread_pool, q);
     return 1;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_coss.cc,v 1.3 2000/06/08 18:05:38 hno Exp $
+ * $Id: store_dir_coss.cc,v 1.4 2000/10/17 08:06:07 adrian Exp $
  *
  * DEBUG: section 81    Store COSS Directory Routines
  * AUTHOR: Eric Stern
@@ -605,11 +605,17 @@ storeCossDirWriteCleanDone(SwapDir * sd)
     sd->log.clean.write = NULL;
 }
 
+static void
+storeSwapLogDataFree(void *s)
+{
+    memFree(s, MEM_SWAP_LOG_DATA);
+}
+
 static void
 storeCossDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
     CossInfo *cs = (CossInfo *) sd->fsdata;
-    storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
+    storeSwapLogData *s = memAllocate(MEM_SWAP_LOG_DATA);
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
     s->timestamp = e->timestamp;
@@ -626,7 +632,7 @@ storeCossDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 	sizeof(storeSwapLogData),
 	NULL,
 	NULL,
-	xfree);
+	(FREE *) storeSwapLogDataFree);
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_diskd.cc,v 1.20 2000/10/13 06:35:57 wessels Exp $
+ * $Id: store_dir_diskd.cc,v 1.21 2000/10/17 08:06:08 adrian Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -1268,11 +1268,17 @@ storeDiskdDirWriteCleanDone(SwapDir * sd)
     sd->log.clean.write = NULL;
 }
 
+static void
+storeSwapLogDataFree(void *s)
+{
+    memFree(s, MEM_SWAP_LOG_DATA);
+}
+
 static void
 storeDiskdDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
     diskdinfo_t *diskdinfo = sd->fsdata;
-    storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
+    storeSwapLogData *s = memAllocate(MEM_SWAP_LOG_DATA);
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
     s->timestamp = e->timestamp;
@@ -1289,7 +1295,7 @@ storeDiskdDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 	sizeof(storeSwapLogData),
 	NULL,
 	NULL,
-	xfree);
+	(FREE *) storeSwapLogDataFree);
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_ufs.cc,v 1.9 2000/10/13 06:35:57 wessels Exp $
+ * $Id: store_dir_ufs.cc,v 1.10 2000/10/17 08:06:09 adrian Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -959,7 +959,7 @@ storeUfsDirWriteCleanStart(SwapDir * sd)
     unlink(state->cln);
     state->fd = file_open(state->new, O_WRONLY | O_CREAT | O_TRUNC);
     if (state->fd < 0)
-	return -1;
+	return -1;	/* state not free'd - possible leak */
     debug(20, 3) ("storeDirWriteCleanLogs: opened %s, FD %d\n",
 	state->new, state->fd);
 #if HAVE_FCHMOD
@@ -1075,11 +1075,17 @@ storeUfsDirWriteCleanDone(SwapDir * sd)
     sd->log.clean.write = NULL;
 }
 
+static void
+storeSwapLogDataFree(void *s)
+{
+    memFree(s, MEM_SWAP_LOG_DATA);
+}
+
 static void
 storeUfsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
     ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
-    storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
+    storeSwapLogData *s = memAllocate(MEM_SWAP_LOG_DATA);
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
     s->timestamp = e->timestamp;
@@ -1096,7 +1102,7 @@ storeUfsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 	sizeof(storeSwapLogData),
 	NULL,
 	NULL,
-	xfree);
+	(FREE *) storeSwapLogDataFree);
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.225 2000/10/07 16:10:13 wessels Exp $
+ * $Id: ipcache.cc,v 1.226 2000/10/17 08:06:03 adrian Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -413,9 +413,9 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     i->handlerData = handlerData;
     cbdataLock(handlerData);
     i->request_time = current_time;
-    c = xcalloc(1, sizeof(*c));
+    c = memAllocate(MEM_GEN_CBDATA);
     c->data = i;
-    cbdataAdd(c, cbdataXfree, 0);
+    cbdataAdd(c, memFree, MEM_GEN_CBDATA);
 #if USE_DNSSERVERS
     dnsSubmit(i->name, ipcacheHandleReply, c);
 #else
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.317 2000/07/16 01:11:49 hno Exp $
+ * $Id: main.cc,v 1.318 2000/10/17 08:06:03 adrian Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -621,11 +621,11 @@ main(int argc, char **argv)
 	if (!ConfigFile)
 	    ConfigFile = xstrdup(DefaultConfigFile);
 	assert(!configured_once);
+	memInit();		/* memInit is required for config parsing */
 	cbdataInit();
 #if USE_LEAKFINDER
 	leakInit();
 #endif
-	memInit();		/* memInit is required for config parsing */
 	eventInit();		/* eventInit() is required for config parsing */
 	storeFsInit();		/* required for config parsing */
 	parse_err = parseConfigFile(ConfigFile);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.48 2000/10/04 00:24:17 wessels Exp $
+ * $Id: mem.cc,v 1.49 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -189,6 +189,9 @@ memInit(void)
     memDataInit(MEM_2K_BUF, "2K Buffer", 2048, 10);
     memDataInit(MEM_4K_BUF, "4K Buffer", 4096, 10);
     memDataInit(MEM_8K_BUF, "8K Buffer", 8192, 10);
+    memDataInit(MEM_16K_BUF, "16K Buffer", 16384, 10);
+    memDataInit(MEM_32K_BUF, "32K Buffer", 32768, 10);
+    memDataInit(MEM_64K_BUF, "64K Buffer", 65536, 10);
     memDataInit(MEM_CLIENT_SOCK_BUF, "Client Socket Buffer", CLIENT_SOCK_SZ, 0);
     memDataInit(MEM_ACCESSLOGENTRY, "AccessLogEntry",
 	sizeof(AccessLogEntry), 10);
@@ -217,6 +220,7 @@ memInit(void)
 #if USE_CACHE_DIGESTS
     memDataInit(MEM_DIGEST_FETCH_STATE, "DigestFetchState", sizeof(DigestFetchState), 0);
 #endif
+    memDataInit(MEM_LINK_LIST, "link_list", sizeof(link_list), 10);
     memDataInit(MEM_DLINK_LIST, "dlink_list", sizeof(dlink_list), 10);
     memDataInit(MEM_DLINK_NODE, "dlink_node", sizeof(dlink_node), 10);
     memDataInit(MEM_DNSSERVER_T, "dnsserver_t", sizeof(dnsserver_t), 0);
@@ -285,6 +289,12 @@ memInit(void)
     memDataInit(MEM_HELPER_SERVER, "helper_server",
 	sizeof(helper_server), 0);
     memDataInit(MEM_STORE_IO, "storeIOState", sizeof(storeIOState), 0);
+    memDataInit(MEM_TLV, "storeSwapTLV", sizeof(tlv), 0);
+    memDataInit(MEM_GEN_CBDATA, "generic_cbdata", sizeof(generic_cbdata), 0);
+    memDataInit(MEM_PUMP_STATE_DATA, "PumpStateData", sizeof(PumpStateData), 0);
+    memDataInit(MEM_CLIENT_REQ_BUF, "clientRequestBuffer", CLIENT_REQ_BUF_SZ, 0);
+    memDataInit(MEM_SWAP_LOG_DATA, "storeSwapLogData", sizeof(storeSwapLogData), 0);
+
     /* init string pools */
     for (i = 0; i < mem_str_pool_count; i++) {
 	StrPools[i].pool = memPoolCreate(StrPoolsAttrs[i].name, StrPoolsAttrs[i].obj_size);
@@ -343,3 +353,21 @@ memFree8K(void *p)
 {
     memFree(p, MEM_8K_BUF);
 }
+
+void
+memFree16K(void *p)
+{
+    memFree(p, MEM_16K_BUF);
+}
+
+void
+memFree32K(void *p)
+{
+    memFree(p, MEM_32K_BUF);
+}
+
+void
+memFree64K(void *p)
+{
+    memFree(p, MEM_64K_BUF);
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: pconn.cc,v 1.27 2000/06/27 22:06:03 hno Exp $
+ * $Id: pconn.cc,v 1.28 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 48    Persistent Connections
  * AUTHOR: Duane Wessels
@@ -43,6 +43,7 @@ struct _pconn {
     int nfds;
 };
 
+#define PCONN_FDS_SZ	8		/* pconn set size, increase for better memcache hit rate */
 #define PCONN_HIST_SZ (1<<16)
 int client_pconn_hist[PCONN_HIST_SZ];
 int server_pconn_hist[PCONN_HIST_SZ];
@@ -55,6 +56,8 @@ static struct _pconn *pconnNew(const char *key);
 static void pconnDelete(struct _pconn *p);
 static void pconnRemoveFD(struct _pconn *p, int fd);
 static OBJH pconnHistDump;
+static MemPool *pconn_data_pool = NULL;
+static MemPool *pconn_fds_pool = NULL;
 
 static const char *
 pconnKey(const char *host, u_short port)
@@ -67,10 +70,10 @@ pconnKey(const char *host, u_short port)
 static struct _pconn *
 pconnNew(const char *key)
 {
-    struct _pconn *p = xcalloc(1, sizeof(struct _pconn));
+    struct _pconn *p = memPoolAlloc(pconn_data_pool);
     p->key = xstrdup(key);
-    p->nfds_alloc = 2;
-    p->fds = xcalloc(p->nfds_alloc, sizeof(int));
+    p->nfds_alloc = PCONN_FDS_SZ;
+    p->fds = memPoolAlloc(pconn_fds_pool);
     debug(48, 3) ("pconnNew: adding %s\n", p->key);
     hash_join(table, (hash_link *) p);
     return p;
@@ -81,9 +84,12 @@ pconnDelete(struct _pconn *p)
 {
     debug(48, 3) ("pconnDelete: deleting %s\n", p->key);
     hash_remove_link(table, (hash_link *) p);
-    xfree(p->fds);
+    if (p->nfds_alloc == PCONN_FDS_SZ)
+	memPoolFree(pconn_fds_pool,p->fds);
+    else
+	xfree(p->fds);
     xfree(p->key);
-    xfree(p);
+    memPoolFree(pconn_data_pool, p);
 }
 
 static void
@@ -168,6 +174,9 @@ pconnInit(void)
 	client_pconn_hist[i] = 0;
 	server_pconn_hist[i] = 0;
     }
+    pconn_data_pool = memPoolCreate("pconn_data", sizeof(struct _pconn));
+    pconn_fds_pool = memPoolCreate("pconn_fds", PCONN_FDS_SZ * sizeof(int));
+
     cachemgrRegister("pconn",
 	"Persistent Connection Utilization Histograms",
 	pconnHistDump, 0, 1);
@@ -200,7 +209,10 @@ pconnPush(int fd, const char *host, u_short port)
 	old = p->fds;
 	p->fds = xmalloc(p->nfds_alloc * sizeof(int));
 	xmemcpy(p->fds, old, p->nfds * sizeof(int));
-	xfree(old);
+	if (p->nfds == PCONN_FDS_SZ)
+	    memPoolFree(pconn_fds_pool,old);
+	else
+	    xfree(old);
     }
     p->fds[p->nfds++] = fd;
     commSetSelect(fd, COMM_SELECT_READ, pconnRead, p, 0);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.108 2000/05/02 18:37:59 hno Exp $
+ * $Id: peer_select.cc,v 1.109 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -134,12 +134,12 @@ peerSelect(request_t * request,
     PSC * callback,
     void *callback_data)
 {
-    ps_state *psstate = xcalloc(1, sizeof(ps_state));
+    ps_state *psstate = memAllocate(MEM_PS_STATE);
     if (entry)
 	debug(44, 3) ("peerSelect: %s\n", storeUrl(entry));
     else
 	debug(44, 3) ("peerSelect: %s\n", RequestMethodStr[request->method]);
-    cbdataAdd(psstate, cbdataXfree, 0);
+    cbdataAdd(psstate, memFree, MEM_PS_STATE);
     psstate->request = requestLink(request);
     psstate->entry = entry;
     psstate->callback = callback;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.382 2000/10/10 18:15:30 wessels Exp $
+ * $Id: protos.h,v 1.383 2000/10/17 08:06:04 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -767,6 +767,9 @@ extern void memFreeBuf(size_t size, void *);
 extern void memFree2K(void *);
 extern void memFree4K(void *);
 extern void memFree8K(void *);
+extern void memFree16K(void *);
+extern void memFree32K(void *);
+extern void memFree64K(void *);
 extern int memInUse(mem_type);
 extern size_t memTotalAllocated(void);
 extern void memDataInit(mem_type, const char *, size_t, int);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.338 2000/10/06 00:58:39 wessels Exp $
+ * $Id: stat.cc,v 1.339 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -79,7 +79,9 @@ static OBJH statCountersHistograms;
 static OBJH statClientRequests;
 
 #ifdef XMALLOC_STATISTICS
-static void info_get_mallstat(int, int, void *);
+static void info_get_mallstat(int, int, int, void *);
+static double xm_time;
+static double xm_deltat;
 #endif
 
 StatCounters CountHist[N_COUNT_HIST];
@@ -388,11 +390,11 @@ statOpenfdObj(StoreEntry * sentry)
 
 #ifdef XMALLOC_STATISTICS
 static void
-info_get_mallstat(int size, int number, void *data)
+info_get_mallstat(int size, int number, int oldnum, void *data)
 {
     StoreEntry *sentry = data;
     if (number > 0)
-	storeAppendPrintf(sentry, "\t%d = %d\n", size, number);
+	storeAppendPrintf(sentry, "%d\t %d\t %d\t %.1f\n", size, number, number - oldnum , xdiv((number - oldnum),xm_deltat));
 }
 #endif
 
@@ -622,7 +624,10 @@ info_get(StoreEntry * sentry)
 	n_disk_objects);
 
 #if XMALLOC_STATISTICS
-    storeAppendPrintf(sentry, "Memory allocation statistics\n");
+    xm_deltat = current_dtime - xm_time;
+    xm_time = current_dtime;
+    storeAppendPrintf(sentry, "\nMemory allocation statistics\n");
+    storeAppendPrintf(sentry, "Allocation Size\t Alloc Count\t Alloc Delta\t Allocs/sec \n");
     malloc_statistics(info_get_mallstat, sentry);
 #endif
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stmem.cc,v 1.65 2000/03/06 16:23:34 wessels Exp $
+ * $Id: stmem.cc,v 1.66 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 19    Store Memory Primitives
  * AUTHOR: Harvest Derived
@@ -43,7 +43,7 @@ stmemFree(mem_hdr * mem)
 	mem->head = p->next;
 	memFree(p->data, MEM_STMEM_BUF);
 	store_mem_size -= SM_PAGE_SIZE;
-	safe_free(p);
+	if (p) { memFree(p, MEM_MEM_NODE); p = NULL; }
     }
     mem->head = mem->tail = NULL;
     mem->origin_offset = 0;
@@ -67,7 +67,7 @@ stmemFreeDataUpto(mem_hdr * mem, int target_offset)
 	    current_offset += lastp->len;
 	    memFree(lastp->data, MEM_STMEM_BUF);
 	    store_mem_size -= SM_PAGE_SIZE;
-	    safe_free(lastp);
+	    if (lastp) { memFree(lastp, MEM_MEM_NODE); lastp = NULL; }
 	}
     }
     mem->head = p;
@@ -102,7 +102,7 @@ stmemAppend(mem_hdr * mem, const char *data, int len)
     }
     while (len > 0) {
 	len_to_copy = XMIN(len, SM_PAGE_SIZE);
-	p = xcalloc(1, sizeof(mem_node));
+	p = memAllocate(MEM_MEM_NODE);
 	p->next = NULL;
 	p->len = len_to_copy;
 	p->data = memAllocate(MEM_STMEM_BUF);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapmeta.cc,v 1.11 2000/07/18 06:16:42 wessels Exp $
+ * $Id: store_swapmeta.cc,v 1.12 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -38,7 +38,7 @@
 static tlv **
 storeSwapTLVAdd(int type, const void *ptr, size_t len, tlv ** tail)
 {
-    tlv *t = xcalloc(1, sizeof(tlv));
+    tlv *t = memAllocate(MEM_TLV);
     t->type = (char) type;
     t->length = (int) len;
     t->value = xmalloc(len);
@@ -54,7 +54,7 @@ storeSwapTLVFree(tlv * n)
     while ((t = n) != NULL) {
 	n = t->next;
 	xfree(t->value);
-	xfree(t);
+	memFree(t, MEM_TLV);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapout.cc,v 1.75 2000/08/15 07:14:04 adrian Exp $
+ * $Id: store_swapout.cc,v 1.76 2000/10/17 08:06:04 adrian Exp $
  *
  * DEBUG: section 20    Storage Manager Swapout Functions
  * AUTHOR: Duane Wessels
@@ -61,9 +61,9 @@ storeSwapOutStart(StoreEntry * e)
     storeSwapTLVFree(tlv_list);
     mem->swap_hdr_sz = (size_t) swap_hdr_sz;
     /* Create the swap file */
-    c = xcalloc(1, sizeof(*c));
+    c = memAllocate(MEM_GEN_CBDATA);
     c->data = e;
-    cbdataAdd(c, cbdataXfree, 0);
+    cbdataAdd(c, memFree, MEM_GEN_CBDATA);
     mem->swapout.sio = storeCreate(e, storeSwapOutFileNotify, storeSwapOutFileClosed, c);
     if (NULL == mem->swapout.sio) {
 	e->swap_status = SWAPOUT_NONE;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.355 2000/10/10 18:15:30 wessels Exp $
+ * $Id: structs.h,v 1.356 2000/10/17 08:06:05 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -1845,6 +1845,24 @@ struct _store_rebuild_data {
     int zero_object_sz;
 };
 
+struct _PumpStateData {
+    FwdState *fwd;
+    request_t *req;
+    store_client *sc;           /* The store client we're using */
+    int c_fd;                   /* client fd */
+    int s_fd;                   /* server end */
+    int rcvd;                   /* bytes received from client */
+    int sent;                   /* bytes sent to server */
+    StoreEntry *request_entry;  /* the request entry */
+    StoreEntry *reply_entry;    /* the reply entry */
+    CWCB *callback;             /* what to do when we finish sending */
+    void *cbdata;               /* callback data passed to callback func */
+    struct {
+        int closing:1;
+    } flags;
+    struct _PumpStateData *next;
+};
+
 /*
  * This defines an fs type
  */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.196 2000/10/10 02:10:43 wessels Exp $
+ * $Id: tools.cc,v 1.197 2000/10/17 08:06:05 adrian Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -858,7 +858,7 @@ stringHasWhitespace(const char *s)
 void
 linklistPush(link_list ** L, void *p)
 {
-    link_list *l = xmalloc(sizeof(*l));
+    link_list *l = memAllocate(MEM_LINK_LIST);
     l->next = NULL;
     l->ptr = p;
     while (*L)
@@ -876,7 +876,7 @@ linklistShift(link_list ** L)
     l = *L;
     p = l->ptr;
     *L = (*L)->next;
-    xfree(l);
+    memFree(l, MEM_LINK_LIST);
     return p;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.109 2000/10/04 00:24:18 wessels Exp $
+ * $Id: typedefs.h,v 1.110 2000/10/17 08:06:05 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -163,7 +163,10 @@ typedef struct _helper_server helper_server;
 typedef struct _helper_request helper_request;
 typedef struct _generic_cbdata generic_cbdata;
 typedef struct _storeIOState storeIOState;
+typedef struct _queued_read queued_read;
+typedef struct _queued_write queued_write;
 typedef struct _link_list link_list;
+typedef struct _PumpStateData PumpStateData;
 typedef struct _storefs_entry storefs_entry_t;
 typedef struct _storerepl_entry storerepl_entry_t;
 typedef struct _diskd_queue diskd_queue;