@@ -115,7 +115,7 @@ Modified to work with strings instead of files.
 
 ==============================================================================
 
-snmplib/*:
+lib/snmplib/*:
 include/{asn1.h,parse.h,snmp*}:
 
 The SNMP library code is developed by Carnegie Mellon University.
@@ -1,4 +1,26 @@
-Changes to squid-3.4.0.1 (-- --- 2013):
+Changes to squid-3.4.0.3 (01 Dec 2013):
+
+	- Bug 3941: Release notes error
+	- Receive annotations from authentication and external ACL helpers
+	- basic_nis_auth: Improved portability
+	- ... and several documentation updates
+	- ... and all bug fixes from 3.3.9, 3.3.10, 3.3.11
+
+Changes to squid-3.4.0.2 (03 Oct 2013):
+
+	- Regression Bug 3891: squid.conf parser errors in 3.4.0.1
+	- Regression Fix: re-disable MinGW C++11 support
+	- Bug 3914: partial: make squidclient tool build cleanly with -Wconversion
+	- Fix memory leak in refresh_pattern parsing
+	- negotiate_kerberos_auth: upgrade to present group= keys
+	- Handle NTLM helper returning OK without user= value
+	- Add dns_multicast_local to control mDNS operation
+	- Add --disable-arch-native build option
+	- Display Build-Info in cache manager info report
+	- ... and all changes from squid 3.3.9
+	- ... and some code and debug output polishing
+
+Changes to squid-3.4.0.1 (29 Jul 2013):
 
 	- Port from 2.7: StoreURL (renamed Store-ID) support
 	- Bug 3795: fix several mistakes in the MIB file
@@ -40,6 +62,60 @@ Changes to squid-3.4.0.1 (-- --- 2013):
 	- ... and many documentation changes
 	- ... and much code cleanup and polishing
 
+Changes to squid-3.3.11 (01 Dec 2013):
+
+	- Regression Bug 3936: error-details.txt parse error with OpenSSL since 3.3.9
+	- Bug 3972: Segfault when getting the deny_info page ID after a reconfigure
+	- Bug 3970: max_filedescriptors disabled due to missing setrlimit
+	- Bug 3967: ipc/Kid.cc compilation failure: 'time' was not declared in this scope
+	- Bug 3960: DEAD cache_peer are not revived
+	- Bug 3956: xstrndup: tried to dup a NULL pointer
+	- Bug 3906: Filedescriptor leaks in SNMP
+	- Bug 3782: Digest authentication not obeying nonce_max_count
+	- HTTP/1.1: Make header parser obey relaxed_header_parser
+	- HTTP/1.1: Re-compute Range response content offset after an FTP response was adapted
+	- SMP: Replace blocking sleep(3) and close UDS socket on failures
+	- Windows: fix several compile errors
+
+Changes to squid-3.3.10 (03 Nov 2013):
+
+	- Bug 3929: request_header_add not working for tunnel requests
+	- Bug 3923: cbdata and undefined behavior due to dynamic runtime enumeration
+	- Bug 3918: Self Test Failures on Mac OS X 10.8
+	- Bug 3887: tcp_outgoing_tos not working for IPv6
+	- Bug 3836: Fix issues with automake 1.13+ and make check
+	- Bug 3480: StoreEntry::kickProducer() segfaults in store_client::copy()
+	- Fix pinning hierarchy log information
+	- Fix close idle client connections associated with closed idle pinned connections.
+	- Fix cbdata 'error: expression result unused' errors
+	- Avoid "hot idle": A series of rapid select() calls with zero timeout.
+	- Append Connection:close to OPTIONS requests when icap_persistent_connections is off
+	- ntlm_fake_auth: pass DOMAIN data to Squid in original case
+	- kerberos_ldap_group: fix LDAP string duplication
+	- Use IPv6 localhost nameserver on DNS configuration errors
+	- Add cache_miss_revalidate
+	- ... and several portability improvements
+
+Changes to squid-3.3.9 (11 Sep 2013):
+
+	- Regression Bug 3077: off-by-one error in Digest header decoding
+	- Bug 3895: fix acl_uses_indirect_client and cache_peer_access
+	- Bug 3879: assertion failed ConnStateData::validatePinnedConnection
+	- Bug 3863: myportname acl causes segmentation fault
+	- Bug 3849: Duplicate certificate sent when using https_port
+	- Bug 2287: Better fix for unsupported HTTP version handling
+	- Bug 2112: Reload into If-None-Match
+	- Fix several assert with side effects in ICAP/eCAP response handling
+	- Fix myportname ACL on ICAP/eCAP transactions
+	- Fix external ACL user:pass detail logging after adaptation
+	- Fix SMP mgr:info report 'Largest file desc currently in use'
+	- Handle infinite certificate validation loops caused by OpenSSL Bug 3090.
+	- Improved compatibility with gcc 4.8, clang and icc
+	- Show number of available filedescriptors when reserved FD changes
+	- Sync with newest OpenSSL error codes
+	- Register Http2-Settings header
+	- ... and many Windows portability fixes
+
 Changes to squid-3.3.8 (13 Jul 2013):
 
 	- Bug 3869: assertion failed: MemBuf.cc:272: size < capacity
@@ -2,8 +2,8 @@
 #
 
 AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5 foreign
-DIST_SUBDIRS	= compat lib libltdl snmplib scripts icons errors contrib doc helpers src test-suite tools
-SUBDIRS		= compat lib $(makesnmplib)
+DIST_SUBDIRS	= compat lib libltdl scripts icons errors contrib doc helpers src test-suite tools
+SUBDIRS		= compat lib
 if USE_LOADABLE_MODULES
 SUBDIRS += libltdl
 endif
@@ -2,24 +2,7 @@ In addition to the numerous volunteer developers (see CONTRIBUTORS),
 the following organizations have provided non-financial support for
 the Squid Project:
 
-@Squid-3.3:
-Netbox Blue Pty (http://netboxblue.com/)
-
-	Netbox Blue Pty. contributed development resources towards
-	testing and stabilizing of authentication systems in Squid-3.2
-	and Squid-3.3.
-
-@Squid-3.2:
-iiNet Ltd - http://www.iinet.net.au/
-
-	iiNet Ltd contributed significant development resources to
-	Squid during its early stages and was instrumental in its
-	early adoption in the local internet community.
-	In Squid-2.6 and 3.0 iiNet supplied equipment to help develop
-	and test the WCCPv2 implementation.
-	In Squid-3.2 iiNet sponsored development time to resolve
-	authentication problems.
-
+@Squid-3.4:
 LaunchPad - http://launchpad.net/
 
 	Provide Bazaar mirroring services and host the Squid-3 developer
@@ -30,9 +13,11 @@ Messagenet - http://messagenet.it/
 	Messagenet donated hardware and bandwidth for the wiki server
 	and most continuous integration testing.
 
-Palisade Systems - http://www.palisadesys.com/
+RackSpace - http://www.rackspace.com/
 
-	Palisade Systems funded SSL Bump feature development in Squid3.
+	RackSpace donated a number of virtual machines from their cloud
+	infrastructure to support and extend the continuous integration
+	testing infrastructure.
 
 The Measurement Factory - http://www.measurement-factory.com/
 
@@ -45,6 +30,33 @@ Treehouse Networks, NZ - http://treenet.co.nz/
 	toward Squid-3 development and maintenance for their customer
 	gateways and CDN.
 
+@Squid-3.3:
+iCelero - http://icelero.com/
+
+	iCelero.com contributed development resources towards
+	testing and stabilization of Squid-3.3 on Windows.
+
+Netbox Blue Pty - http://netboxblue.com/
+
+	Netbox Blue Pty. contributed development resources towards
+	testing and stabilizing of authentication systems in Squid-3.2
+	and Squid-3.3.
+
+@Squid-3.2:
+iiNet Ltd - http://www.iinet.net.au/
+
+	iiNet Ltd contributed significant development resources to
+	Squid during its early stages and was instrumental in its
+	early adoption in the local internet community.
+	In Squid-2.6 and 3.0 iiNet supplied equipment to help develop
+	and test the WCCPv2 implementation.
+	In Squid-3.2 iiNet sponsored development time to resolve
+	authentication problems.
+
+Palisade Systems - http://www.palisadesys.com/
+
+	Palisade Systems funded SSL Bump feature development in Squid3.
+
 @Squid-3.1:
 Barefruit - http://www.barefruit.com/
 
@@ -38,7 +38,7 @@ AC_DEFUN([SQUID_CC_CHECK_ARGUMENT],[
     AC_REQUIRE([AC_PROG_CC])
     SAVED_FLAGS="$CFLAGS"
     SAVED_CXXFLAGS="$CXXFLAGS"
-    CFLAGS="$CXXFLAGS $2"
+    CFLAGS="$CFLAGS $2"
     CXXFLAGS="$CXXFLAGS $2"
     AC_TRY_LINK([],[int foo; ],
       [$1=yes],[$1=no])
@@ -170,8 +170,8 @@ AC_DEFUN([SQUID_CC_GUESS_OPTIONS], [
    squid_cv_cc_arg_pipe=""
    ;;
   clang) 
-   squid_cv_cxx_option_werror="-Werror -Wno-error=parentheses-equality -Qunused-arguments"
-   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
+   squid_cv_cxx_option_werror="-Werror -Qunused-arguments"
+   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror"
    squid_cv_cc_option_wall="-Wall"
    squid_cv_cc_option_optimize="-O2"
    squid_cv_cc_arg_pipe=""
@@ -216,10 +216,8 @@ AC_DEFUN([SQUID_EMBED_BUILD_INFO],[
       ;;
   esac
   ])
-  if test "x${squid_build_info:=no}" != "xno"; then
-    AC_DEFINE_UNQUOTED([SQUID_BUILD_INFO],["$squid_build_info"],
-       [Squid extended build info field for "squid -v" output])
-  fi
+  AC_DEFINE_UNQUOTED([SQUID_BUILD_INFO],["$squid_build_info"],
+     [Squid extended build info field for "squid -v" output])
 ])
 
 dnl like AC_SEARCH_LIBS, with an extra argument which is
@@ -90,8 +90,6 @@ init_syntax_once(void)
 
 #endif /* not SYNTAX_TABLE */
 
-#define SYNTAX(c) re_syntax_table[c]
-
 /* Get the interface, including the syntax bits.  */
 #include "compat/GnuRegex.h"
 
@@ -889,9 +887,6 @@ static reg_errcode_t compile_range(const char **p_ptr, const char *pend, char *t
 
 #define INIT_COMPILE_STACK_SIZE 32
 
-#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
-#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
-
 /* The next available element.  */
 #define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
 
@@ -1420,7 +1415,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                 bufp->re_nsub++;
                 regnum++;
 
-                if (COMPILE_STACK_FULL) {
+                if (compile_stack.avail == compile_stack.size) {
                     RETALLOC(compile_stack.stack, compile_stack.size << 1,
                              compile_stack_elt_t);
                     if (compile_stack.stack == NULL)
@@ -1461,7 +1456,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                 if (syntax & RE_NO_BK_PARENS)
                     goto normal_backslash;
 
-                if (COMPILE_STACK_EMPTY) {
+                if (compile_stack.avail == 0) {
                     if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                         goto normal_backslash;
                     else
@@ -1479,7 +1474,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                     STORE_JUMP(jump_past_alt, fixup_alt_jump, b - 1);
                 }
                 /* See similar code for backslashed left paren above.  */
-                if (COMPILE_STACK_EMPTY) {
+                if (compile_stack.avail == 0) {
                     if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                         goto normal_char;
                     else
@@ -1832,7 +1827,7 @@ handle_interval: {
     if (fixup_alt_jump)
         STORE_JUMP(jump_past_alt, fixup_alt_jump, b);
 
-    if (!COMPILE_STACK_EMPTY)
+    if (compile_stack.avail != 0)
         return REG_EPAREN;
 
     free(compile_stack.stack);
@@ -2374,13 +2369,13 @@ struct re_pattern_buffer *bufp;
 
         case wordchar:
             for (j = 0; j < (1 << BYTEWIDTH); j++)
-                if (SYNTAX(j) == Sword)
+                if (re_syntax_table[j] == Sword)
                     fastmap[j] = 1;
             break;
 
         case notwordchar:
             for (j = 0; j < (1 << BYTEWIDTH); j++)
-                if (SYNTAX(j) != Sword)
+                if (re_syntax_table[j] != Sword)
                     fastmap[j] = 1;
             break;
 
@@ -2732,21 +2727,31 @@ static boolean group_match_null_string_p(unsigned char **p, unsigned char *end,
 /* Test if at very beginning or at very end of the virtual concatenation
  * of `string1' and `string2'.  If only one string, it's `string2'.  */
 #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
-#define AT_STRINGS_END(d) ((d) == end2)
+static int at_strings_end(const char *d, const char *end2)
+{
+    return d == end2;
+}
 
 /* Test if D points to a character which is word-constituent.  We have
  * two special cases to check for: if past the end of string1, look at
  * the first character in string2; and if before the beginning of
  * string2, look at the last character in string1.  */
 #define WORDCHAR_P(d)							\
-  (SYNTAX ((d) == end1 ? *string2					\
-           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
+  (re_syntax_table[(d) == end1 ? *string2					\
+           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]			\
    == Sword)
+static int
+wordchar_p(const char *d, const char *end1, const char *string2)
+{
+    return re_syntax_table[(d) == end1 ? *string2
+                           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]
+           == Sword;
+}
 
 /* Test if the character before D and the one at D differ with respect
  * to being word-constituent.  */
 #define AT_WORD_BOUNDARY(d)						\
-  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
+  (AT_STRINGS_BEG (d) || at_strings_end(d,end2)				\
    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
 
 /* Free everything we malloc.  */
@@ -3440,7 +3445,7 @@ int stop;
         case endline:
             DEBUG_PRINT1("EXECUTING endline.\n");
 
-            if (AT_STRINGS_END(d)) {
+            if (at_strings_end(d,end2)) {
                 if (!bufp->not_eol)
                     break;
             }
@@ -3461,7 +3466,7 @@ int stop;
             /* Match at the very end of the data.  */
         case endbuf:
             DEBUG_PRINT1("EXECUTING endbuf.\n");
-            if (AT_STRINGS_END(d))
+            if (at_strings_end(d,end2))
                 break;
             goto fail;
 
@@ -3739,21 +3744,21 @@ int stop;
 
         case wordbeg:
             DEBUG_PRINT1("EXECUTING wordbeg.\n");
-            if (WORDCHAR_P(d) && (AT_STRINGS_BEG(d) || !WORDCHAR_P(d - 1)))
+            if (wordchar_p(d,end1,string2) && (AT_STRINGS_BEG(d) || !WORDCHAR_P(d - 1)))
                 break;
             goto fail;
 
         case wordend:
             DEBUG_PRINT1("EXECUTING wordend.\n");
             if (!AT_STRINGS_BEG(d) && WORDCHAR_P(d - 1)
-                    && (!WORDCHAR_P(d) || AT_STRINGS_END(d)))
+                    && (!wordchar_p(d,end1,string2) || at_strings_end(d,end2)))
                 break;
             goto fail;
 
         case wordchar:
             DEBUG_PRINT1("EXECUTING non-Emacs wordchar.\n");
             PREFETCH();
-            if (!WORDCHAR_P(d))
+            if (!wordchar_p(d,end1,string2))
                 goto fail;
             SET_REGS_MATCHED();
             d++;
@@ -3762,7 +3767,7 @@ int stop;
         case notwordchar:
             DEBUG_PRINT1("EXECUTING non-Emacs notwordchar.\n");
             PREFETCH();
-            if (WORDCHAR_P(d))
+            if (wordchar_p(d,end1,string2))
                 goto fail;
             SET_REGS_MATCHED();
             d++;
@@ -9,6 +9,12 @@
 #include <sys/socket.h>
 #endif
 
+// WinSock2.h defines these for Windows
+#if HAVE_WINSOCK2_H
+#include <winsock2.h>
+#define CMSG_H_ // prevent re-definition
+#endif
+
 #ifndef CMSG_H_
 #define CMSG_H_
 
@@ -76,9 +76,9 @@
 /* components as found to be needed                  */
 /*****************************************************/
 
+#include "compat/assert.h"
 #include "compat/compat_shared.h"
 #include "compat/stdvarargs.h"
-#include "compat/assert.h"
 
 /* cstdio has a bunch of problems with 64-bit definitions */
 #include "compat/stdio.h"
@@ -208,10 +208,10 @@ extern "C" {
  * Several function definitions which we provide for security and code safety.
  */
 #include "compat/xalloc.h"
+#include "compat/xis.h"
 #include "compat/xstrerror.h"
 #include "compat/xstring.h"
 #include "compat/xstrto.h"
-#include "compat/xis.h"
 
 /*
  * strtoll() is needed. Squid provides a portable definition.
@@ -75,8 +75,8 @@
 
 #if !HAVE_GETNAMEINFO
 
-#include "compat/inet_ntop.h"
 #include "compat/getaddrinfo.h"
+#include "compat/inet_ntop.h"
 
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
@@ -71,6 +71,11 @@
 #define NOMINMAX
 #endif
 
+/// some builds of MinGW do not define IPV6_V6ONLY socket option
+#if !defined(IPV6_V6ONLY)
+#define IPV6_V6ONLY 27
+#endif
+
 #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
 # define __USE_FILE_OFFSET64	1
 #endif
@@ -469,6 +474,18 @@ namespace Squid
 {
 /** \endcond */
 
+/*
+ * Each of these functions is defined in the Squid namespace so as not to
+ * clash with the winsock.h and winsock2.h definitions.
+ * It is then paired with a #define to cause these wrappers to be used by
+ * the main code instead of those system definitions.
+ *
+ * We do this wrapper in order to:
+ * - cast the parameter types in only one place, and
+ * - record errors in POSIX errno variable, and
+ * - map the FD value used by Squid to the socket handes used by Windows.
+ */
+
 inline int
 accept(int s, struct sockaddr * a, socklen_t * l)
 {
@@ -720,6 +737,7 @@ WSAAsyncSelect(int s, HWND h, unsigned int w, long e)
     } else
         return 0;
 }
+#define WSAAsyncSelect(s,h,w,e) Squid::WSAAsyncSelect(s,h,w,e)
 
 #undef WSADuplicateSocket
 inline int
@@ -735,6 +753,7 @@ WSADuplicateSocket(int s, DWORD n, LPWSAPROTOCOL_INFO l)
     } else
         return 0;
 }
+#define WSADuplicateSocket(s,n,l) Squid::WSADuplicateSocket(s,n,l)
 
 #undef WSASocket
 inline int
@@ -752,6 +771,7 @@ WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
     } else
         return _open_osfhandle(result, 0);
 }
+#define WSASocket(a,t,p,i,g,f) Squid::WSASocket(a,t,p,i,g,f)
 
 } /* namespace Squid */
 
@@ -782,6 +802,11 @@ WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
 #define open       _open /* Needed in win32lib.c */
 #endif /* #ifdef __cplusplus */
 
+/* provide missing definitions from resoruce.h */
+/* NP: sys/resource.h and sys/time.h are apparently order-dependant. */
+#if HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
 #if HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #else
@@ -35,9 +35,22 @@ AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
-# Clang 3.2 on some CPUs requires -march-native to detect correctly
-# GCC 4.3+ can also produce faster executables when its used
-SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+# Clang 3.2 on some CPUs requires -march-native to detect correctly.
+# GCC 4.3+ can also produce faster executables when its used.
+# But building inside a virtual machine environment has been found to
+# cause random Illegal Instruction errors due to mis-detection of CPU.
+AC_ARG_ENABLE(arch-native,
+  AS_HELP_STRING([--disable-arch-native],[Some compilers offer CPU-specific
+                 optimizations with the -march=native parameter.
+                 This flag disables the optimization. The default is to
+                 auto-detect compiler support and use where available.]), [
+  SQUID_YESNO([$enableval],
+    [Unrecognized argument to --disable-arch-native: $enableval])
+])
+AC_MSG_NOTICE([CPU -march=native optimization enabled: ${enable_arch_native:=auto}])
+if test "x${enable_arch_native}" != "xno"; then
+  SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+fi
 
 # might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
@@ -71,7 +84,8 @@ fi
 
 # Check for C++0x compiler support
 AX_CXX_COMPILE_STDCXX_0X
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" ; then
+if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
+  "x$squid_host_os" != "xmingw" ; then
     #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
     # in the system libraries, which makes some c99 methods unavailable
     # (e.g. strtoll), yet configure detects them as avilable.
@@ -793,8 +807,6 @@ if test "x$squid_opt_enable_storeio" = "xauto"; then
   squid_opt_enable_storeio=yes
   AC_MSG_CHECKING([for available StoreIO modules])
   SQUID_LOOK_FOR_MODULES([$srcdir/src/fs],[squid_storeio_module_candidates])
-  # disable coss
-  squid_storeio_module_candidates=`echo $squid_storeio_module_candidates|sed 's/coss//'`
   AC_MSG_RESULT([$squid_storeio_module_candidates])
 fi
 
@@ -816,33 +828,26 @@ for fs in $squid_storeio_module_candidates none; do
         AC_MSG_ERROR([Storage module aufs requires DiskIO module: Blocking or DiskThreads])
       fi
       ;;
-    coss)
-      AC_MSG_WARN([COSS Support is not stable yet in Squid-3. Please do not use.])
-      if ! test "x$squid_disk_module_candidates_AIO" = "xyes"; then
-        AC_MSG_ERROR([COSS requires POSIX AIO which is not available.])
-      fi
-      # Automake on MinGW needs explicit exe extension
-      # for STORE_TESTS substition
-      STORE_TESTS="$STORE_TESTS tests/testCoss$EXEEXT"
-      ;;
     rock)
 	if test "x$squid_disk_module_candidates_IpcIo" != "xyes" -a \
 	  "x$squid_disk_module_candidates_Blocking" != "xyes"; then
 	  AC_MSG_ERROR([Storage module Rock requires IpcIo or Blocking DiskIO module])
 	fi
-	STORE_TESTS="$STORE_TESTS tests/testRock$EXEEXT"
+	squid_do_build_rock=true
 	;;
     ufs)
-      STORE_TESTS="$STORE_TESTS tests/testUfs$EXEEXT"
+	squid_do_build_ufs=true
+	;;
     esac
 done
-
+ 
+AM_CONDITIONAL(HAVE_FS_UFS,[test "x$squid_do_build_ufs" = "xtrue" ])
+AM_CONDITIONAL(HAVE_FS_ROCK,[test "x$squid_do_build_rock" = "xtrue" ])
 dnl hack: need to define those even if not used in the build system to
 dnl make sure that global FS objects are linked to the squid binary.
 AH_TEMPLATE(HAVE_FS_UFS, "Define to 1 if ufs filesystem module is build")
 AH_TEMPLATE(HAVE_FS_AUFS, "Define to 1 if aufs filesystem module is build")
 AH_TEMPLATE(HAVE_FS_DISKD, "Define to 1 if diskd filesystem module is build")
-AH_TEMPLATE(HAVE_FS_COSS, "Define to 1 if coss filesystem module is build")
 AH_TEMPLATE(HAVE_FS_ROCK, "Define to 1 if rock filesystem module is build")
 
 
@@ -1035,10 +1040,10 @@ then
 
   if test -n "$PKG_CONFIG"; then
     dnl eCAP support requires libecap.
-    dnl This Squid supports libecap v0.2.x.
+    dnl This Squid supports libecap v1.0.x.
     dnl Use EXT_ prefix to distinguish external libecap (that we check for
     dnl here) from our own convenience ecap library in Makefiles.
-    PKG_CHECK_MODULES([EXT_LIBECAP],[libecap >= 0.2.0 libecap < 0.3])
+    PKG_CHECK_MODULES([EXT_LIBECAP],[libecap >= 1.0 libecap < 1.1])
   else
     AC_MSG_NOTICE([eCAP support requires pkg-config to verify the correct library version. Trouble may follow.])
   fi
@@ -1121,7 +1126,7 @@ SQUID_DEFINE_BOOL(SQUID_SNMP,${enable_snmp:=yes},
    [Define to enable SNMP monitoring of Squid])
 AM_CONDITIONAL(ENABLE_SNMP, [test "x$enable_snmp" = "xyes"])
 if test "x$enable_snmp" = "xyes"; then
-    SNMPLIB='../snmplib/libsnmplib.a'
+    SNMPLIB='../lib/snmplib/libsnmplib.a'
     makesnmplib=snmplib
 fi
 AC_MSG_NOTICE([SNMP support enabled: $enable_snmp])
@@ -1305,20 +1310,6 @@ SQUID_DEFINE_BOOL(USE_CACHE_DIGESTS,${enable_cache_digests:=no},
 AC_MSG_NOTICE([Cache Digests enabled: $enable_cache_digests])
 
 
-dnl Size of COSS memory buffer
-squid_opt_coss_membuf_size=1048576
-AC_ARG_WITH(coss-membuf-size,
-  AS_HELP_STRING([--with-coss-membuf-size=size],
-             [COSS membuf size (default $squid_opt_coss_membuf_size bytes)]), [
-case $withval in
-  [[0-9]]*) squid_opt_coss_membuf_size=$withval ;;
-  *) AC_MSG_ERROR([--with-coss-membuf-size expects a numeric argument]) ;;
-esac
-])
-AC_MSG_NOTICE([Setting COSS membuf size to $squid_opt_coss_membuf_size bytes])
-AC_DEFINE_UNQUOTED(COSS_MEMBUF_SZ, $squid_opt_coss_membuf_size,
-   [Default COSS membuf size])
-
 ################################
 # check for netio plugin stuff #
 ################################
@@ -1678,21 +1669,6 @@ AC_ARG_ENABLE(ident-lookups,
 AC_MSG_NOTICE([Support for Ident lookups enabled: ${enable_ident_lookups:=yes}])
 SQUID_DEFINE_BOOL(USE_IDENT,$enable_ident_lookups,[Support for Ident (RFC 931) lookups])
 
-squid_opt_use_dnshelper="no"
-AC_ARG_ENABLE(internal-dns,
-  AS_HELP_STRING([--disable-internal-dns],
-           [Prevents Squid from directly sending and receiving DNS messages, 
-            and instead enables the old external 'dnsserver' processes.]), [
-  if test "x$enableval" = "xno" ; then
-    AC_MSG_WARN([Disabling Internal DNS queries])
-    squid_opt_use_dnshelper="yes"
-  fi
-])
-SQUID_DEFINE_BOOL(USE_DNSHELPER,$squid_opt_use_dnshelper,
-  [Use dnsserver processes instead of the internal DNS protocol support])
-AM_CONDITIONAL([ENABLE_DNSHELPER],[test "x$squid_opt_use_dnshelper" = "xyes" ])
-
-
 AM_CONDITIONAL(USE_SSL_CRTD, false)
 AC_ARG_ENABLE(ssl-crtd,
   AC_HELP_STRING([--enable-ssl-crtd],
@@ -1906,6 +1882,10 @@ if test "x$ac_krb5_config" = "xyes" ; then
     AC_DEFINE(HAVE_KRB5_GET_ERROR_MESSAGE,1,
       [Define to 1 if you have krb5_get_error_message]),)
   AC_CHECK_DECLS(krb5_kt_free_entry,,,[#include <krb5.h>])
+  AC_CHECK_TYPE(krb5_pac,
+    AC_DEFINE(HAVE_KRB5_PAC,1,
+      [Define to 1 if you have krb5_pac]),,
+      [#include <krb5.h>])
   AC_CHECK_LIB(krb5,krb5_kt_free_entry,
     AC_DEFINE(HAVE_KRB5_KT_FREE_ENTRY,1,
       [Define to 1 if you have krb5_kt_free_entry]),)
@@ -1924,6 +1904,33 @@ if test "x$ac_krb5_config" = "xyes" ; then
   AC_CHECK_LIB(krb5,profile_release,
     AC_DEFINE(HAVE_PROFILE_RELEASE,1,
       [Define to 1 if you have profile_release]),)
+  AC_CHECK_LIB(krb5,krb5_get_renewed_creds,
+    AC_DEFINE(HAVE_KRB5_GET_RENEWED_CREDS,1,
+      [Define to 1 if you have krb5_get_renewed_creds]),)
+  AC_CHECK_LIB(krb5,krb5_principal_get_realm,
+    AC_DEFINE(HAVE_KRB5_PRINCIPAL_GET_REALM,1,
+      [Define to 1 if you have krb5_principal_get_realm]),)
+  AC_CHECK_LIB(krb5, krb5_get_init_creds_opt_alloc,
+    AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC,1,
+      [Define to 1 if you have krb5_get_init_creds_opt_alloc]),)
+  AC_MSG_CHECKING([for krb5_get_init_creds_free requires krb5_context])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	#include <krb5.h>
+    ]],[[krb5_context context;
+	 krb5_get_init_creds_opt *options;
+	 krb5_get_init_creds_opt_free(context, options)]])],[
+	AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT,1,
+		  [Define to 1 if you krb5_get_init_creds_free requires krb5_context])
+	AC_MSG_RESULT(yes)
+    ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
+
+
+  AC_CHECK_FUNCS(gss_map_name_to_any,
+    AC_DEFINE(HAVE_GSS_MAP_ANY_TO_ANY,1,
+      [Define to 1 if you have gss_map_name_to_any]),)
+  AC_CHECK_FUNCS(gsskrb5_extract_authz_data_from_sec_context,
+    AC_DEFINE(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT,1,
+      [Define to 1 if you have gsskrb5_extract_authz_data_from_sec_context]),)
 
   SQUID_CHECK_KRB5_CONTEXT_MEMORY_CACHE
   SQUID_DEFINE_BOOL(HAVE_KRB5_MEMORY_CACHE,$squid_cv_memory_cache,
@@ -2527,14 +2534,14 @@ case "$squid_host_os" in
     ;;
 esac
 
-
 dnl --with-maxfd present for compatibility with Squid-2.
 dnl undocumented in ./configure --help  to encourage using the Squid-3 directive
 AC_ARG_WITH(maxfd,,
 [ 
   case ${withval} in
     [[0-9]]*)
       squid_filedescriptors_num=$withval
+      AC_MSG_NOTICE([forcing default of $squid_filedescriptors_num filedescriptors (user-forced)])
       ;;
     *)
       AC_MSG_ERROR(--with-maxfd expects a numeric argument)
@@ -2549,6 +2556,7 @@ AC_ARG_WITH(filedescriptors,
   case ${withval} in
     [[0-9]]*)
       squid_filedescriptors_num=$withval
+      AC_MSG_NOTICE([forcing default of $squid_filedescriptors_num filedescriptors (user-forced)])
       ;;
     *)
       AC_MSG_ERROR(--with-filedescriptors expects a numeric argument)
@@ -2557,10 +2565,9 @@ AC_ARG_WITH(filedescriptors,
 ])
 
 SQUID_CHECK_DEFAULT_FD_SETSIZE
-if test "x$squid_filedescriptors_num" = "x"; then
-  SQUID_CHECK_MAXFD
-else
-  AC_MSG_NOTICE([forcing use of $squid_filedescriptors_num filedescriptors (user-forced)])
+SQUID_CHECK_MAXFD
+if test "x$squid_filedescriptors_num" != "x"; then
+  AC_MSG_NOTICE([Default number of fieldescriptors: $squid_filedescriptors_num])
 fi
 if test "$squid_filedescriptors_num" -lt 512 ; then
     AC_MSG_WARN([$squid_filedescriptors_num may not be enough filedescriptors if your])
@@ -3309,10 +3316,8 @@ SQUID_CHECK_RECV_ARG_TYPE
 SQUID_CHECK_NEED_SYS_ERRLIST
 SQUID_CHECK_MAXPATHLEN
 
-if test "x$squid_opt_use_dnshelper" = "xyes"; then
-  SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
-  SQUID_CHECK_RESOLVER_FIELDS
-fi
+SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
+SQUID_CHECK_RESOLVER_FIELDS
 
 if test "x$ac_cv_header_sys_statvfs_h" = "xyes" ; then
   SQUID_CHECK_WORKING_STATVFS
@@ -3386,99 +3391,99 @@ AC_MSG_NOTICE([BUILD EXTRA C++ FLAGS: $SQUID_CXXFLAGS])
 dnl Clean up after OSF/1 core dump bug
 rm -f core 
 
-AC_CONFIG_FILES([\
-	Makefile \
-	compat/Makefile \
-	lib/Makefile \
-	lib/ntlmauth/Makefile \
-	lib/libTrie/Makefile \
-	lib/libTrie/test/Makefile \
-	lib/profiler/Makefile \
-	lib/rfcnb/Makefile \
-	lib/smblib/Makefile \
-	scripts/Makefile \
-	src/Makefile \
-	src/anyp/Makefile \
-	src/base/Makefile \
-	src/acl/Makefile \
-	src/fs/Makefile \
-	src/repl/Makefile \
-	src/auth/Makefile \
-	src/auth/basic/Makefile \
-	src/auth/digest/Makefile \
-	src/auth/negotiate/Makefile \
-	src/auth/ntlm/Makefile \
-	src/adaptation/Makefile \
-	src/adaptation/icap/Makefile \
-	src/adaptation/ecap/Makefile \
-	src/comm/Makefile \
-	src/esi/Makefile \
-	src/eui/Makefile \
-	src/format/Makefile \
-	src/http/Makefile \
-	src/icmp/Makefile \
-	src/ident/Makefile \
-	src/ip/Makefile \
-	src/log/Makefile \
-	src/ipc/Makefile \
-	src/ssl/Makefile \
-	src/mgr/Makefile \
-	src/snmp/Makefile \
-	contrib/Makefile \
-	snmplib/Makefile \
-	icons/Makefile \
-	errors/Makefile \
-	test-suite/Makefile \
-	doc/Makefile \
-	doc/manuals/Makefile \
-	helpers/Makefile \
-	helpers/basic_auth/Makefile \
-	helpers/basic_auth/DB/Makefile \
-	helpers/basic_auth/fake/Makefile \
-	helpers/basic_auth/getpwnam/Makefile \
-	helpers/basic_auth/LDAP/Makefile \
-	helpers/basic_auth/MSNT/Makefile \
-	helpers/basic_auth/MSNT-multi-domain/Makefile \
-	helpers/basic_auth/NCSA/Makefile \
-	helpers/basic_auth/NIS/Makefile \
-	helpers/basic_auth/PAM/Makefile \
-	helpers/basic_auth/POP3/Makefile \
-	helpers/basic_auth/RADIUS/Makefile \
-	helpers/basic_auth/SASL/Makefile \
-	helpers/basic_auth/SMB/Makefile \
-	helpers/basic_auth/SSPI/Makefile \
-	helpers/digest_auth/Makefile \
-	helpers/digest_auth/eDirectory/Makefile \
-	helpers/digest_auth/file/Makefile \
-	helpers/digest_auth/LDAP/Makefile \
-	helpers/ntlm_auth/Makefile \
-	helpers/ntlm_auth/fake/Makefile \
-	helpers/ntlm_auth/smb_lm/Makefile \
-	helpers/ntlm_auth/SSPI/Makefile \
-	helpers/negotiate_auth/Makefile \
-	helpers/negotiate_auth/kerberos/Makefile \
-	helpers/negotiate_auth/SSPI/Makefile \
-	helpers/negotiate_auth/wrapper/Makefile \
-	helpers/external_acl/Makefile \
-	helpers/external_acl/AD_group/Makefile \
-	helpers/external_acl/eDirectory_userip/Makefile \
-	helpers/external_acl/file_userip/Makefile \
-	helpers/external_acl/kerberos_ldap_group/Makefile \
-	helpers/external_acl/LDAP_group/Makefile \
-	helpers/external_acl/LM_group/Makefile \
-	helpers/external_acl/session/Makefile \
-	helpers/external_acl/SQL_session/Makefile \
-	helpers/external_acl/unix_group/Makefile \
-	helpers/external_acl/wbinfo_group/Makefile \
-	helpers/external_acl/time_quota/Makefile \
-	helpers/log_daemon/Makefile \
-	helpers/log_daemon/DB/Makefile \
-	helpers/log_daemon/file/Makefile \
-	helpers/url_rewrite/Makefile \
-	helpers/url_rewrite/fake/Makefile \
-	helpers/ssl/Makefile \
-	helpers/storeid_rewrite/Makefile \
-	helpers/storeid_rewrite/file/Makefile \
+AC_CONFIG_FILES([
+	Makefile
+	compat/Makefile
+	lib/Makefile
+	lib/ntlmauth/Makefile
+	lib/libTrie/Makefile
+	lib/libTrie/test/Makefile
+	lib/profiler/Makefile
+	lib/rfcnb/Makefile
+	lib/smblib/Makefile
+	lib/snmplib/Makefile
+	scripts/Makefile
+	src/Makefile
+	src/anyp/Makefile
+	src/base/Makefile
+	src/acl/Makefile
+	src/fs/Makefile
+	src/repl/Makefile
+	src/auth/Makefile
+	src/auth/basic/Makefile
+	src/auth/digest/Makefile
+	src/auth/negotiate/Makefile
+	src/auth/ntlm/Makefile
+	src/adaptation/Makefile
+	src/adaptation/icap/Makefile
+	src/adaptation/ecap/Makefile
+	src/comm/Makefile
+	src/esi/Makefile
+	src/eui/Makefile
+	src/format/Makefile
+	src/http/Makefile
+	src/icmp/Makefile
+	src/ident/Makefile
+	src/ip/Makefile
+	src/log/Makefile
+	src/ipc/Makefile
+	src/ssl/Makefile
+	src/mgr/Makefile
+	src/snmp/Makefile
+	contrib/Makefile
+	icons/Makefile
+	errors/Makefile
+	test-suite/Makefile
+	doc/Makefile
+	doc/manuals/Makefile
+	helpers/Makefile
+	helpers/basic_auth/Makefile
+	helpers/basic_auth/DB/Makefile
+	helpers/basic_auth/fake/Makefile
+	helpers/basic_auth/getpwnam/Makefile
+	helpers/basic_auth/LDAP/Makefile
+	helpers/basic_auth/MSNT/Makefile
+	helpers/basic_auth/MSNT-multi-domain/Makefile
+	helpers/basic_auth/NCSA/Makefile
+	helpers/basic_auth/NIS/Makefile
+	helpers/basic_auth/PAM/Makefile
+	helpers/basic_auth/POP3/Makefile
+	helpers/basic_auth/RADIUS/Makefile
+	helpers/basic_auth/SASL/Makefile
+	helpers/basic_auth/SMB/Makefile
+	helpers/basic_auth/SSPI/Makefile
+	helpers/digest_auth/Makefile
+	helpers/digest_auth/eDirectory/Makefile
+	helpers/digest_auth/file/Makefile
+	helpers/digest_auth/LDAP/Makefile
+	helpers/ntlm_auth/Makefile
+	helpers/ntlm_auth/fake/Makefile
+	helpers/ntlm_auth/smb_lm/Makefile
+	helpers/ntlm_auth/SSPI/Makefile
+	helpers/negotiate_auth/Makefile
+	helpers/negotiate_auth/kerberos/Makefile
+	helpers/negotiate_auth/SSPI/Makefile
+	helpers/negotiate_auth/wrapper/Makefile
+	helpers/external_acl/Makefile
+	helpers/external_acl/AD_group/Makefile
+	helpers/external_acl/eDirectory_userip/Makefile
+	helpers/external_acl/file_userip/Makefile
+	helpers/external_acl/kerberos_ldap_group/Makefile
+	helpers/external_acl/LDAP_group/Makefile
+	helpers/external_acl/LM_group/Makefile
+	helpers/external_acl/session/Makefile
+	helpers/external_acl/SQL_session/Makefile
+	helpers/external_acl/unix_group/Makefile
+	helpers/external_acl/wbinfo_group/Makefile
+	helpers/external_acl/time_quota/Makefile
+	helpers/log_daemon/Makefile
+	helpers/log_daemon/DB/Makefile
+	helpers/log_daemon/file/Makefile
+	helpers/url_rewrite/Makefile
+	helpers/url_rewrite/fake/Makefile
+	helpers/ssl/Makefile
+	helpers/storeid_rewrite/Makefile
+	helpers/storeid_rewrite/file/Makefile
 	tools/Makefile
 	tools/purge/Makefile
 ])
@@ -0,0 +1 @@
+</div>
@@ -7,7 +7,6 @@ section --    Unlink Daemon
 section --    WWW Client
 section 00    Announcement Server
 section 00    Client Database
-section 00    DNS Resolver Daemon
 section 00    Debug Routines
 section 00    Hash Tables
 section 00    UFS Store Dump Tool
@@ -68,7 +67,6 @@ section 30    Ident (RFC 931)
 section 31    Hypertext Caching Protocol
 section 32    Asynchronous Disk I/O
 section 33    Client-side Routines
-section 34    Dnsserver interface
 section 35    FQDN Cache
 section 37    ICMP Routines
 section 38    Network Measurement Database
@@ -89,7 +87,6 @@ section 46    Access Log - Squid ICAP Logging
 section 46    Access Log - Squid format
 section 46    Access Log - Squid referer format
 section 46    Access Log - Squid useragent format
-section 47    Store COSS Directory Routines
 section 47    Store Directory Routines
 section 48    Persistent Connections
 section 49    SNMP Interface
@@ -128,7 +125,6 @@ section 78    DNS lookups; interacts with lib/rfc1035.c
 section 79    Disk IO Routines
 section 79    Squid-side DISKD I/O functions.
 section 79    Squid-side Disk I/O functions.
-section 79    Storage Manager COSS Interface
 section 79    Storage Manager UFS Interface
 section 79   Disk IO Routines
 section 80    WCCP Support
@@ -8,15 +8,17 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: FULL NAME <EMAIL@ADDRESS>\n"
 "POT-Creation-Date: 2012-02-06 18:42+1400\n"
-"PO-Revision-Date: 2009-07-22 09:45+0000\n"
-"Last-Translator: Amos Jeffries <Unknown>\n"
+"PO-Revision-Date: 2013-10-31 11:22+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Arabic <ar@li.org>\n"
 "Language: ar\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=6; plural=n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 "
+"&& n%100<=10 ? 3 : n%100>=11 && n%100<=99 ? 4 : 5;\n"
+"X-Generator: Pootle 2.1.6\n"
 "X-Launchpad-Export-Date: 2009-07-22 09:52+0000\n"
-"X-Generator: Launchpad (build Unknown)\n"
 
 #. type: SH
 #: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:3
@@ -599,9 +601,8 @@ msgstr ""
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:18
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:33
 #: helpers/external_acl/LDAP_group/ext_ldap_group_acl.8:20
-#, fuzzy
 msgid "LDAP server name"
-msgstr "B<-s >I<service-name>"
+msgstr ""
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:20
@@ -1059,9 +1060,8 @@ msgstr ""
 
 #. type: Plain text
 #: helpers/basic_auth/PAM/basic_pam_auth.8:11
-#, fuzzy
 msgid "service name"
-msgstr "B<-s >I<service-name>"
+msgstr ""
 
 #. type: Plain text
 #: helpers/basic_auth/PAM/basic_pam_auth.8:13
@@ -1163,9 +1163,8 @@ msgstr ""
 
 #. type: Plain text
 #: helpers/basic_auth/RADIUS/basic_radius_auth.8:16
-#, fuzzy
 msgid "server name"
-msgstr "B<-s >I<service-name>"
+msgstr ""
 
 #. type: Plain text
 #: helpers/basic_auth/RADIUS/basic_radius_auth.8:20
@@ -1180,9 +1179,8 @@ msgstr ""
 #. type: Plain text
 #: helpers/basic_auth/RADIUS/basic_radius_auth.8:24
 #: helpers/external_acl/session/ext_session_acl.8:14 tools/squidclient.1:38
-#, fuzzy
 msgid "timeout"
-msgstr "B<-s >I<service-name>"
+msgstr ""
 
 #. type: Plain text
 #: helpers/basic_auth/RADIUS/basic_radius_auth.8:30
@@ -2066,9 +2064,8 @@ msgstr ""
 
 #. type: Plain text
 #: helpers/external_acl/file_userip/ext_file_userip_acl.8:14
-#, fuzzy
 msgid "file name"
-msgstr "B<-s >I<service-name>"
+msgstr ""
 
 #. type: Plain text
 #: helpers/external_acl/file_userip/ext_file_userip_acl.8:19
@@ -8,15 +8,15 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: FULL NAME <EMAIL@ADDRESS>\n"
 "POT-Creation-Date: 2012-02-06 18:42+1400\n"
-"PO-Revision-Date: 2010-06-06 10:48+0200\n"
-"Last-Translator: Robert Förster <Dessa@gmake.de>\n"
+"PO-Revision-Date: 2013-10-31 13:20+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: German <de@li.org>\n"
 "Language: de\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Pootle 2.0.1\n"
+"X-Generator: Pootle 2.1.6\n"
 "X-Launchpad-Export-Date: 2010-01-10 09:12+0000\n"
 
 #. type: SH
@@ -863,7 +863,7 @@ msgstr ""
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:182
 #: helpers/external_acl/LDAP_group/ext_ldap_group_acl.8:170
 msgid "Do not follow referrals"
-msgstr ""
+msgstr "Folge nicht den Verweisen"
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:187
@@ -909,7 +909,7 @@ msgstr ""
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:222
 #: helpers/external_acl/LDAP_group/ext_ldap_group_acl.8:210
 msgid "Use TLS encryption"
-msgstr ""
+msgstr "Nutze TLS Verschlüsselung"
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:226
@@ -928,7 +928,7 @@ msgstr ""
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:237
 #: helpers/external_acl/LDAP_group/ext_ldap_group_acl.8:192
 msgid "Specify time limit on LDAP search operations"
-msgstr ""
+msgstr "Definiert das Zeitlimit bei LDAP-Suchanfragen"
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:243
@@ -7,7 +7,7 @@ msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2010-02-13 00:05+1400\n"
-"PO-Revision-Date: 2012-04-06 19:32+0200\n"
+"PO-Revision-Date: 2012-07-19 14:51+0200\n"
 "Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "Language: fr\n"
@@ -47,7 +47,7 @@ msgid ""
 "to validate the user name and password of Basic HTTP authentication."
 msgstr ""
 "B<basic_getpwnam_auth> permet d'authentifier les comptes utilisateurs locaux "
-"de Squid, pour valider le nom d'utilisateur et le mot de passe de "
+"de Squid, pour valider le nom d'utilisateur et le mot de passe via "
 "l'authentification HTTP de base."
 
 #. type: Plain text
@@ -276,7 +276,7 @@ msgid ""
 "separated by a space."
 msgstr ""
 "B<basic_ldap_auth> permet à Squid de se connecter à un annuaire LDAP pour "
-"valider le nom d'utilisateur et le mot de passe de l'authentification HTTP "
+"valider le nom d'utilisateur et le mot de passe via l'authentification HTTP "
 "de base. Les options LDAP sont spécifiées par des paramètres en ligne de "
 "commande, le(s) nom(s) d'utilisateur(s) et le(s) mot(s) de passe(s) sont "
 "vérifiés dans l'annuaire LDAP, les entrées sont indiquées sur la ligne "
@@ -551,7 +551,7 @@ msgstr ""
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:216 helpers/external_acl/ldap_group/squid_ldap_group.8:204
 msgid "LDAP protocol version. Defaults to 2 if not specified."
-msgstr "Version du protocole LDAP. Par défaut 2 S'il n'est pas spécifié."
+msgstr "Version du protocole LDAP. Par défaut 2 s'il n'est pas spécifié."
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:220 helpers/external_acl/ldap_group/squid_ldap_group.8:208
@@ -585,7 +585,7 @@ msgid ""
 "Debug mode where each step taken will get reported in detail.  Useful for "
 "understanding what goes wrong if the results is not what is expected."
 msgstr ""
-"Mode Déboguage, chaque étape sera enregistrée en détail. S'utilise pour "
+"Mode déboguage, chaque étape sera enregistrée en détail. S'utilise pour "
 "comprendre ce qui a mal tourne ou si les résultats ne sont pas ceux "
 "attendus."
 
@@ -655,7 +655,7 @@ msgid ""
 msgstr ""
 "B<NOTE:> lors de la construction du filtre de recherche, il est fortement "
 "recommandé de tester le filtre en utilisant B<ldapsearch>, avant d'essayer "
-"d'utiliser B<basic_ldap_auth>. Ceci pour vérifier que le filtre correspond "
+"d'utiliser B<basic_ldap_auth>. Cela sert à vérifier que le filtre correspond "
 "bien à ce que vous attendez."
 
 #. type: Plain text
@@ -708,9 +708,9 @@ msgid ""
 "HTTP authentication."
 msgstr ""
 "B<basic_ncsa_auth> permet à Squid de lire les informations "
-"d'authentification de l'utilisateur et du mot de passe dans NCSA/Apache "
-"httpd/style à partir du fichier mot de passe, lorsque l'on utilise "
-"l'authentification HTTP de base."
+"d'authentification de l'utilisateur et du mot de passe, à partir du fichier "
+"mot de passe dans Apache/NCSA avec le style-httpd,via l'authentification "
+"HTTP de base."
 
 #. type: Plain text
 #: helpers/basic_auth/NCSA/basic_ncsa_auth.8:19
@@ -786,7 +786,7 @@ msgid ""
 msgstr ""
 "B<basic_pam_auth> permet à Squid de se connecter sur n'importe quelle base "
 "de données PAM disponible, pour valider le nom d'utilisateur et le mot de "
-"passe pour l'authentification HTTP de base."
+"passe via l'authentification HTTP de base."
 
 #. type: Plain text
 #: helpers/basic_auth/PAM/basic_pam_auth.8:26
@@ -923,7 +923,7 @@ msgid ""
 "the user name and password of Basic HTTP authentication."
 msgstr ""
 "B<basic_radius_auth> permet à Squid de se connecter à un serveur RADIUS pour "
-"valider le nom d'utilisateur et le mot de passe avec l'authentification "
+"valider le nom d'utilisateur et le mot de passe, via l'authentification "
 "HTTP de base."
 
 #. type: Plain text
@@ -1507,10 +1507,10 @@ msgid ""
 "lookups, supports non-blocking DNS lookups, and implements negative caching "
 "of failed requests."
 msgstr ""
-"Squid conserve au chaud (la mis en cache) des meta-données et des données "
-"les plus utilisées sont cachées dans la RAM, il conserve aussi les DNS dans "
-"la mémoire, les DNS sont non bloquante et applique la mise en cache négative "
-"des requêtes ayant échouées."
+"Squid conserve au chaud (mis en cache) dans la RAM les meta-données et plus "
+"particulièrement les données fréquemment utilisées, il conserve aussi en "
+"mémoire les requêtes DNS, ainsi que les requêtes ayant échoué, les requêtes "
+"DNS sont non bloquante."
 
 #. type: Plain text
 #: src/squid.8.in:41
@@ -1537,9 +1537,9 @@ msgstr ""
 "Le programme Squid se compose d'un serveur principal B<squid>, de programmes "
 "facultatifs pour le traitement personnalisé d'authentification et d'outils "
 "pour la gestion des clients. Lorsque squid démarre, il génère un nombre de "
-"processus configurable avec ca documentation, ainsi chaque processus peut "
-"exécuter des recherches en parallèle. Cela réduit le temps attend pour la "
-"recherche de résultats."
+"processus configurable avec ça documentation, chaque processus peut exécuter "
+"des recherches en parallèle, cela réduit le temps attend de la recherche "
+"des résultats."
 
 #. type: Plain text
 #: src/squid.8.in:51
@@ -1802,8 +1802,8 @@ msgid ""
 "CONTRIBUTORS for a full list of individuals who contributed code.  see "
 "CREDITS for a list of major code contributing copyright holders."
 msgstr ""
-"Avec la contribution de nombreuse personnes qui crées la communauté Squid. "
-"La liste de tous ce qui ont CONTRIBUÉ le plus et ceux qui détiennent les "
+"Avec la contribution de nombreuses personnes qui crée la communauté Squid. "
+"La liste de tous ceux qui ont CONTRIBUÉ le plus et ceux qui détiennent les "
 "droits d'auteur sont dans le fichier CREDITS."
 
 #. type: Plain text
@@ -1979,7 +1979,7 @@ msgstr "intervalle du ping"
 #. type: Plain text
 #: tools/squidclient.1:22
 msgid "Host header"
-msgstr "En-tête de l'hôte"
+msgstr "en-tête de l'hôte"
 
 #. type: Plain text
 #: tools/squidclient.1:24
@@ -2098,14 +2098,14 @@ msgstr ""
 "I<GET.>\n"
 "Squid prend également en charge une méthode non-standard appelée\n"
 "I<PURGE.>\n"
-"Vous pouvez l'utiliser pour purger une URL spécifique à partir du cache.\n"
-"Vous devez avoir\n"
+"Vous pouvez l'utiliser pour purger une URL spécifique dans le cache.\n"
+"Vous pouvez avoir accès au setup de\n"
 "I<purge>\n"
-"pour accéder au setup dans\n"
+"dans le fichier\n"
 "B<squid.conf>\n"
 "similaire à\n"
 "I<manager>\n"
-"qui peut aussi y accéder. Voici un exemple:\n"
+"pour accéder au setup. Voici un exemple:\n"
 
 #. type: Plain text
 #: tools/squidclient.1:116
@@ -7,15 +7,15 @@ msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2010-02-13 00:05+1400\n"
-"PO-Revision-Date: 2010-05-06 12:33+0200\n"
-"Last-Translator: Francesco Chemolli <kinkie@squid-cache.org>\n"
+"PO-Revision-Date: 2013-10-31 11:53+0200\n"
+"Last-Translator: Francesco <kinkie@squid-cache.org>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "Language: it\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Pootle 2.0.1\n"
+"X-Generator: Pootle 2.1.6\n"
 
 #. type: SH
 #: helpers/basic_auth/getpwnam/basic_getpwnam_auth.8:3 helpers/basic_auth/LDAP/basic_ldap_auth.8:3 helpers/basic_auth/NCSA/basic_ncsa_auth.8:3 helpers/basic_auth/PAM/basic_pam_auth.8:3 helpers/basic_auth/RADIUS/basic_radius_auth.8:3 helpers/external_acl/ldap_group/squid_ldap_group.8:3 helpers/external_acl/session/squid_session.8:3 helpers/external_acl/unix_group/squid_unix_group.8:3 src/squid.8.in:3 tools/cachemgr.cgi.8.in:3 tools/squidclient.1:3
@@ -509,7 +509,7 @@ msgid ""
 "while B<search ing> or only to B<find> the base object."
 msgstr ""
 "B<never>: non risolvere mai gli alias, B<always>: risolvi sempre gli alias, "
-"B<search ing>: solo durante le ricerche, o B<find>: solo per la ricerca dell"
+"B<search>: solo durante le ricerche, o B<find>: solo per la ricerca dell"
 "'oggetto-base."
 
 #. type: Plain text
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.8 release notes</title>
+<title>Squid 3.3.11 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.8.
+The Squid Team are pleased to announce the release of Squid-3.3.11.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
 <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -180,6 +180,12 @@ This section gives a thorough account of those changes in three categories:
 <sect1>New tags<label id="newtags">
 <p>
 <descrip>
+	<tag>cache_miss_revalidate</tag>
+	<p>Whether Squid is to pass-through If-Modified-Since and If-None-Match headers on cache MISS.
+	   Revalidation requests can prevent cache gathering objects to HIT on.
+	<p>Based on the Squid-2.7 <em>ignore_ims_on_miss</em> feature.
+	<p><em>IMPORTANT:</em> the meaning for on/off values has changed along with the name since 2.7.
+
 	<tag>request_header_add</tag>
 	<p>New directive to add custom headers on HTTP traffic sent to upstream servers.
 
@@ -230,8 +236,8 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
-
-	<p><em>There are no removed squid.conf options in Squid-3.3.</em>
+	<tag>ignore_ims_on_miss</tag>
+	<p>This option has been replaced by the <em>cache_miss_revalidate</em> feature.
 
 </descrip>
 
@@ -318,9 +324,6 @@ This section gives an account of those changes in three categories:
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>ignore_ims_on_miss</tag>
-	<p>Not yet ported from 2.7
-
 	<tag>location_rewrite_access</tag>
 	<p>Not yet ported from 2.6
 
@@ -26,7 +26,10 @@ <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></
 <UL>
 <LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
 <LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
-<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">Store-ID</A>
+<LI><A NAME="toc2.4">2.4</A> <A HREF="#ss2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<LI><A NAME="toc2.5">2.5</A> <A HREF="#ss2.5">Transaction Annotations</A>
+<LI><A NAME="toc2.6">2.6</A> <A HREF="#ss2.6">Multicast DNS</A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
@@ -84,7 +87,10 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></
 <UL>
 <LI>Helper protocol extensions</LI>
 <LI>SSL Server Certificate Validator</LI>
+<LI>Store-ID</LI>
 <LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
+<LI>Transaction Annotations</LI>
+<LI>Multicast DNS</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
@@ -146,7 +152,39 @@ <H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</
 <EM>ssl_crtd</EM> related options. </P>
 
 
-<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">Store-ID</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/StoreID">http://wiki.squid-cache.org/Features/StoreID</A>.</P>
+
+<P>This feature is a redesigned equivalent to the Squid-2.7 feature known as StoreURL-rewrite.</P>
+
+<P><EM>Notice</EM> that this is not a direct portage of the Squid-2.7 feature so behaviour
+differences do exist. Although the new feature works in similar enough ways that the old
+helper scripts used for Squid-2.7 are expected to work in this and later versions of Squid.</P>
+
+<P>Squid traditionally uses the requested URL as an index key ID to locate objects in cache.
+It is not the only key possible and the Store-ID feature exposes an API for external
+helpers to provide Squid with an alternative key name for any URL.</P>
+
+<P>When any client request is received which requires a cache lookup the URL is passed to
+a helper specified with the <EM>store_id_program</EM> directive to check for an alternative
+Store ID. This allows the helper to identify URLs which refer to duplicate resources and
+de-duplicate the cache content. <EM>store_id_access</EM> is provided to allow ACL-based
+tuning of which traffic gets sent to the helper and reduce overheads.</P>
+
+<P>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
+this feature is that <EM>refresh_pattern</EM> applies its regex argument against the Store
+ID key and not the transaction URL. So using the Store-ID feature to alter the value
+affects which <EM>refresh_pattern</EM> directive will be matched.</P>
+
+<P>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
+options which is added in this version. Currently there is a <EM>file</EM> helper
+provided.</P>
+
+
+<H2><A NAME="ss2.4">2.4</A> <A HREF="#toc2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
 </H2>
 
 <P>Details at 
@@ -170,9 +208,66 @@ <H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ an
 These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
 
 
+<H2><A NAME="ss2.5">2.5</A> <A HREF="#toc2.5">Transaction Annotations</A>
+</H2>
+
+<P>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
+or external ACL <EM>tag=</EM> result code. Each of which had only limited possibilities
+for use and little or no correlation.</P>
+
+<P>It is now possible to add annotations to a client transaction from several sources:
+<UL>
+<LI>    Directly from squid.conf using the <EM>note</EM> directive with
+ACL-based selection of which annotation is linked to any
+particular transaction.
+</LI>
+<LI>    By configured helper processes returning a key=value pair.
+The key name becomes the annotation name.</LI>
+</UL>
+</P>
+
+<P>Annotations on the transaction can be passed to ICAP services or eCAP modules using the
+<EM>adaptation_meta</EM> directive to send them as headers.
+They can also be logged using the <EM>%note</EM> log format code in custom logs. With
+the new helper response syntax changes this means all helper response key=value details
+such as URL-rewrite or store-id changes, external ACL tag etc. are now able to be logged.</P>
+
+<P>Annotations which are already assigned to a transaction can be checked using an ACL test
+of the new <EM>note</EM> ACL type. This can match a particular note by name and value,
+of for any notes with a given name.</P>
+
+<P>NOTE: not all helper interfaces are yet enabled to convert key=value into annotations
+and the external ACL interface does not yet send annotations to the helper.</P>
+
+
+<H2><A NAME="ss2.6">2.6</A> <A HREF="#toc2.6">Multicast DNS</A>
+</H2>
+
+<P>The internal DNS component fof Squid now supports multicast DNS (mDNS) resolution in
+accordance with RFC 6762.</P>
+
+<P>There is no additional or special configuration required. The multicast DNS group IP
+addresses for IPv4 and IPv6 resolving are added to the set of available DNS resolvers
+and used automatically for domain names ending in <EM>.local</EM> before attempting a
+secondary resolution on the configured resolvers. Domains without <EM>.local</EM> are
+resolved using only the configured DNS resolvers.</P>
+
+<P>Statistics for multicast DNS resolution can be found on the <EM>idns</EM> cache manager
+report.</P>
+
+
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <P>There have been changes to Squid's configuration file since Squid-3.3.</P>
+
+<P>Squid supports reading configuration option parameters from external
+files using the syntax <EM>parameters("/path/filename")</EM>. For example:
+<PRE>
+    acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
+</PRE>
+</P>
+
+<P>There hasve also been changes to individual directives in the config file.</P>
 <P>This section gives a thorough account of those changes in three categories:</P>
 <P>
 <UL>
@@ -191,6 +286,10 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 
 <P>
 <DL>
+<DT><B>configuration_includes_quoted_values</B><DD>
+<P>Whether Squid supports directive parameters with spaces, quotes, and other
+special characters. Surround such parameters with "double quotes".</P>
+
 <DT><B>note</B><DD>
 <P>Use ACLs to annotate a transaction with customized annotations
 which can be logged in access.log</P>
@@ -205,6 +304,28 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 <DT><B>sslcrtvalidator_program</B><DD>
 <P>Specifies the location of a SSL server certificate validator helper.</P>
 
+<DT><B>store_id_access</B><DD>
+<P>Whether the URL for a given request is passed to the Store-ID helper process.
+Used to improve StoreID performance by quickly eliminating helper delays using ACL tests.</P>
+<P>Ported equivalent to <EM>storeurl_access</EM> from 2.7</P>
+
+<DT><B>store_id_bypass</B><DD>
+<P>Whether the StoreID helper may be bypassed when overloaded.</P>
+
+<DT><B>store_id_children</B><DD>
+<P>Controls the number of StoreID helper processes.</P>
+<P>Options <EM>startup=N</EM>, <EM>idle=N</EM>, <EM>concurrency=N</EM>
+<UL>
+<LI>startup=N allow finer tuning of how many helpers are started initially.</LI>
+<LI>idle=N allow fine tuning of how many helper to retain as buffer against sudden traffic loads.</LI>
+<LI>concurrency=N was previously called url_rewrite_concurrency as a distinct directive.</LI>
+</UL>
+</P>
+
+<DT><B>storeurl_rewrite_program</B><DD>
+<P>A helper program to provide cache storage internal key ID value for a request.</P>
+<P>Ported equivalent to <EM>storeurl_rewrite_program</EM> from 2.7</P>
+
 </DL>
 </P>
 
@@ -213,9 +334,24 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 
 <P>
 <DL>
+<DT><B>access_log</B><DD>
+<P>Configuration syntax extended to support name=value options.
+<EM>New Syntax:</EM> access_log module:place [option ...] [acl ...]</P>
+<P>New option <EM>logformat=</EM> to specify the logging format name.</P>
+<P>New option <EM>buffer-size=</EM> to specify how large the log buffer
+for this log is to be when <EM>buffered_logs</EM> is enabled.</P>
+<P>New option <EM>on-error=</EM> to specify what handling is to be done
+if the logging module encounters a non-recoverable error writing logs.
+With the value <EM>die</EM> (the default) Squid halts operation.
+With the value <EM>drop</EM> Squid drops log lines and continue running.</P>
+
 <DT><B>acl</B><DD>
 <P>New test type <EM>server_cert_fingerprint</EM> to match against 
 server SSL certificate fingerprint.</P>
+<P>New test type <EM>note</EM> to match against transaction annotations
+by name and value, or just by name.</P>
+<P>New test type <EM>any-of</EM> to match if any one of a set of named ACLs.</P>
+<P>New test type <EM>all-of</EM> to match against all of a set of named ACLs.</P>
 
 <DT><B>auth_param</B><DD>
 <P>New result code <EM>BH</EM> to signal helper internal errors
@@ -235,6 +371,10 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
 <DT><B>http_port</B><DD>
+<P>Support IPv6 for <EM>intercept</EM> mode. Requires ip6tables support on Linux,
+PF support on OpenBSD and IPFW support on FreeBSD. Squid will no longer complain
+about misconfiguration if IPv6 support is missing, we now rely on the firewall
+tools reporting misconfiguration when the NAT rules are created.</P>
 <P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
 (OpenBSD 5+, FreeBSD 9+ so far).</P>
 <P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
@@ -243,6 +383,18 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <DT><B>logformat</B><DD>
 <P>New format code <EM>%note</EM> to log a transaction annotation linked to the
 transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
+<P>New format code <EM>%&gt;qos</EM> to log client connection TOS/DSCP value set by Squid.</P>
+<P>New format code <EM>%&lt;qos</EM> to log server connection TOS/DSCP value set by Squid.</P>
+<P>New format code <EM>%&gt;nfmark</EM> to log client connection netfilter mark set by Squid.</P>
+<P>New format code <EM>%&lt;nfmark</EM> to log server connection netfilter mark set by Squid.</P>
+
+<DT><B>pipeline_prefetch</B><DD>
+<P>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.</P>
+
+<DT><B>refresh_pattern</B><DD>
+<P><EM>NOTE:</EM> the regular expression pattern operates on the cache Store-ID value.
+Which by default is identical to the requested URL, but may differ for some
+objects if the Store-ID feature is in use.</P>
 
 <DT><B>unlinkd_program</B><DD>
 <P>New helper response format utilizing result codes <EM>OK</EM> and <EM>BH</EM>,
@@ -266,19 +418,17 @@ <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed
 
 <P>
 <DL>
-<P><EM>There are no removed squid.conf tags in Squid-3.4.</EM></P>
-
 <DT><B>storeurl_access</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_access</EM>.</P>
 
 <DT><B>storeurl_rewrite_children</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_children</EM>.</P>
 
 <DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_children</EM> with <EM>concurrency=N</EM> option.</P>
 
 <DT><B>storeurl_rewrite_program</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_program</EM>.</P>
 
 </DL>
 </P>
@@ -305,6 +455,12 @@ <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New opti
 
 <P>
 <DL>
+<DT><B>--enable-storeid-rewrite-helpers</B><DD>
+<P>New option to control which Store-ID helpers are built. As with other
+helper options use --disable-* to prevent any helpers building and
+omit to get all helper auto-detected.</P>
+<P>Currenly only a helper using <EM>file</EM> for backend is provided.</P>
+
 <DT><B>--with-nat-pf</B><DD>
 <P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
 in squid.conf.</P>
@@ -346,7 +502,7 @@ <H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Remo
 
 <H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
 
-<P>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3</P>
+<P>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.4</P>
 
 <P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.0.0 release notes</title>
+<title>Squid 3.4.0.3 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,9 +13,9 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.0.3 for testing.
 
-This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.HEAD/"> or the
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
 While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
@@ -28,10 +28,10 @@ We welcome feedback and bug reports. If you find a bug, please see <url url="htt
 Although this release is deemed good enough for use in many setups, please note the existence of 
 <url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4" name="open bugs against Squid-3.4">.
 
-
 <sect1>Changes since earlier releases of Squid-3.4
 <p>
-The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.HEAD/changesets/" name="viewed here">.
+The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.4/changesets/" name="viewed here">.
+
 
 <sect>Major new features since Squid-3.3
 <p>Squid 3.4 represents a new feature release above 3.3.
@@ -43,6 +43,7 @@ The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Store-ID
 	<item>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
 	<item>Transaction Annotations
+	<item>Multicast DNS
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -62,7 +63,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 
 <p>Arbitrary key-value pairs can be returned from any helper.
    Allowing future helpers to be forward- and backward- compatible
-   with this and future version of Squid.
+   with this and future versions of Squid.
 
 
 <sect1>SSL Server Certificate Validator
@@ -110,18 +111,18 @@ Most user-facing changes are reflected in squid.conf (see below).
    helpers to provide Squid with an alternative key name for any URL.
 
 <p>When any client request is received which requires a cache lookup the URL is passed to
-   a helper specified with the <em>store_id_rewrite_program</em> directive to check for
-   an alternative Store ID. This allows the helper to identify URLs which refer to duplicate
-   resources and de-duplicate the cache content. <em>store_id_access</em> is provided to
-   allow ACL-based tuning of which traffic gets sent to the helper and reduce overheads.
+   a helper specified with the <em>store_id_program</em> directive to check for an alternative
+   Store ID. This allows the helper to identify URLs which refer to duplicate resources and
+   de-duplicate the cache content. <em>store_id_access</em> is provided to allow ACL-based
+   tuning of which traffic gets sent to the helper and reduce overheads.
 
 <p>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
    this feature is that <em>refresh_pattern</em> applies its regex argument against the Store
    ID key and not the transaction URL. So using the Store-ID feature to alter the value
    affects which <em>refresh_pattern</em> directive will be matched.
 
 <p>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
-   options which is added in this version. Currently there is a <em>file</em> helper
+   option which is added in this version. Currently there is a <em>file</em> helper
    provided.
 
 
@@ -145,6 +146,7 @@ Most user-facing changes are reflected in squid.conf (see below).
    which do not yet support the getsockname() API.
    These systems require <em>--with-nat-devpf</em> to enable /dev/pf support when using PF firewall.
 
+
 <sect1>Transaction Annotations
 <p>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
    or external ACL <em>tag=</em> result code. Each of which had only limited possibilities
@@ -174,10 +176,38 @@ Most user-facing changes are reflected in squid.conf (see below).
 	 and the external ACL interface does not yet send annotations to the helper.
 
 
+<sect1>Multicast DNS
+<p>The internal DNS component of Squid now supports multicast DNS (mDNS) resolution in
+    accordance with RFC 6762.
+
+<p>The <em>dns_multicast_local</em> directive must be set to <em>on</em> to enable this
+   feature.
+
+<p>The multicast DNS group IP addresses for IPv4 and IPv6 resolving are added to the set
+   of available DNS resolvers and used automatically for domain names ending in <em>.local</em>
+   and reverse-DNS lookups before attempting a secondary resolution on the configured
+   resolvers. Domains without <em>.local</em> are resolved using only the configured resolvers.
+
+<p>Statistics for multicast DNS resolution can be found on the <em>idns</em> cache manager
+   report.
+
+<p><em>NOTE</em> that the external DNS helper interface is now deprecated and has been
+  removed from future Squid versions. Any installations still using it for local hostname
+  resolution need to upgrade to mDNS resolution with this Squid version.
+
+
 <sect>Changes to squid.conf since Squid-3.3
 <p>
 There have been changes to Squid's configuration file since Squid-3.3.
 
+<p>Squid supports reading configuration option parameters from external
+   files using the syntax <em>parameters("/path/filename")</em>. For example:
+<verb>
+    acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
+</verb>
+
+<p>There hasve also been changes to individual directives in the config file.
+
 This section gives a thorough account of those changes in three categories:
 
 <itemize>
@@ -190,6 +220,15 @@ This section gives a thorough account of those changes in three categories:
 <sect1>New tags<label id="newtags">
 <p>
 <descrip>
+	<tag>configuration_includes_quoted_values</tag>
+	<p>Whether Squid supports directive parameters with spaces, quotes, and other
+	   special characters. Surround such parameters with "double quotes" and
+	   also set this directive on/off around the relevant squid.conf line(s)
+	   making use of such quoting.
+
+	<tag>dns_multicast_local</tag>
+	<p>Use multicast DNS for <em>.local</em> domains and reverse-DNS resolution.
+
 	<tag>note</tag>
 	<p>Use ACLs to annotate a transaction with customized annotations
 	   which can be logged in access.log
@@ -204,6 +243,27 @@ This section gives a thorough account of those changes in three categories:
 	<tag>sslcrtvalidator_program</tag>
 	<p>Specifies the location of a SSL server certificate validator helper.
 
+	<tag>store_id_access</tag>
+	<p>Whether the URL for a given request is passed to the Store-ID helper process.
+	   Used to improve StoreID performance by quickly eliminating helper delays using ACL tests.
+	<p>Ported equivalent to <em>storeurl_access</em> from 2.7
+
+	<tag>store_id_bypass</tag>
+	<p>Whether the StoreID helper may be bypassed when overloaded.
+
+	<tag>store_id_children</tag>
+	<p>Controls the number of StoreID helper processes.
+        <p>Options <em>startup=N</em>, <em>idle=N</em>, <em>concurrency=N</em>
+        <itemize>
+                <item>startup=N allow finer tuning of how many helpers are started initially.
+                <item>idle=N allow fine tuning of how many helper to retain as buffer against sudden traffic loads.
+                <item>concurrency=N was previously called url_rewrite_concurrency as a distinct directive.
+        </itemize>
+
+	<tag>store_id_rewrite_program</tag>
+	<p>A helper program to provide cache storage internal key ID value for a request.
+	<p>Ported equivalent to <em>storeurl_rewrite_program</em> from 2.7
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -256,10 +316,19 @@ This section gives a thorough account of those changes in three categories:
 	<tag>logformat</tag>
 	<p>New format code <em>%note</em> to log a transaction annotation linked to the
 	   transaction by ICAP, eCAP, a helper, or the <em>note</em> squid.conf directive.
+	<p>New format code <em>%&gt;qos</em> to log client connection TOS/DSCP value set by Squid.
+	<p>New format code <em>%&lt;qos</em> to log server connection TOS/DSCP value set by Squid.
+	<p>New format code <em>%&gt;nfmark</em> to log client connection netfilter mark set by Squid.
+	<p>New format code <em>%&lt;nfmark</em> to log server connection netfilter mark set by Squid.
 
 	<tag>pipeline_prefetch</tag>
 	<p>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.
 
+	<tag>refresh_pattern</tag>
+	<p><em>NOTE:</em> the regular expression pattern operates on the cache Store-ID value.
+	   Which by default is identical to the requested URL, but may differ for some
+	   objects if the Store-ID feature is in use.
+
 	<tag>unlinkd_program</tag>
 	<p>New helper response format utilizing result codes <em>OK</em> and <em>BH</em>,
 	   to signal helper lookup results. Also, key-value response values to return
@@ -277,8 +346,18 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
-	<p><em>There are no removed squid.conf tags in Squid-3.4.</em>
+	<tag>storeurl_access</tag>
+	<p>Replaced by <em>store_id_access</em>.
 
+	<tag>storeurl_rewrite_children</tag>
+	<p>Replaced by <em>store_id_children</em>.
+
+	<tag>storeurl_rewrite_concurrency</tag>
+	<p>Replaced by <em>store_id_children</em> with <em>concurrency=N</em> option.
+
+	<tag>storeurl_rewrite_program</tag>
+	<p>Replaced by <em>store_id_program</em>.
+	
 </descrip>
 
 
@@ -304,7 +383,14 @@ This section gives an account of those changes in three categories:
 	   omit to get all helper auto-detected.
 	<p>Currenly only a helper using <em>file</em> for backend is provided.
 
-	<tag>--with-nat-pf</tag>
+	<tag>--disable-arch-native</tag>
+	<p>New option to disable use of -march=native compiler flag.
+	<p>The new flag auto-enables CPU-specific optimizations in GCC and is
+	  required by Clang++ v3.2 for correct 64-bit environment detection.
+	  It does not always work well however, so this build option is provided
+	  to remove it when necessary.
+
+	<tag>--with-nat-devpf</tag>
 	<p>New option to alter the behaviour of <em>http_port ... intercept</em> option
 	   in squid.conf.
 	<p>When this option is used Squid performs the /dev/pf lookups required to
@@ -340,7 +426,7 @@ This section gives an account of those changes in three categories:
 
 <sect>Regressions since Squid-2.7
 
-<p>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3
+<p>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.4
 
 <p>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.
 
@@ -376,9 +462,6 @@ This section gives an account of those changes in three categories:
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>ignore_ims_on_miss</tag>
-	<p>Not yet ported from 2.7
-
 	<tag>location_rewrite_access</tag>
 	<p>Not yet ported from 2.6
 
@@ -399,18 +482,6 @@ This section gives an account of those changes in three categories:
 	<tag>refresh_stale_hit</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>storeurl_access</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>storeurl_rewrite_children</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>storeurl_rewrite_concurrency</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>storeurl_rewrite_program</tag>
-	<p>Not yet ported from 2.7
-	
 	<tag>update_headers</tag>
 	<p>Not yet ported from 2.7
 
@@ -4,15 +4,15 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-09-01 11:50+0200\n"
-"Last-Translator: F Wolff <friedel@translate.org.za>\n"
+"PO-Revision-Date: 2013-10-31 11:16+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: translate-discuss-af@lists.sourceforge.net\n"
 "Language: af\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Virtaal 0.7.0\n"
+"X-Generator: Pootle 2.1.6\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -48,13 +48,13 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.detail:69
 msgid "%ssl_error_descr"
-msgstr "%ssl_error_descr"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.detail:97
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.detail:117
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.detail:125
 msgid "%ssl_error_descr: %ssl_ca_name"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.detail:1
 #, fuzzy
@@ -82,7 +82,7 @@ msgstr "%ssl_error_descr: %ssl_ca_name"
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.detail:129
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.detail:133
 msgid "%ssl_error_descr: %ssl_subject"
-msgstr "%ssl_error_descr: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
@@ -185,7 +185,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Application verification failure"
+msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -195,23 +195,23 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.descr:125
 msgid "Authority and issuer serial number mismatch"
-msgstr "Authority and issuer serial number mismatch"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_AKID_SKID_MISMATCH.descr:121
 msgid "Authority and subject key identifier mismatch"
-msgstr "Authority and subject key identifier mismatch"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_HAS_EXPIRED.descr:49
 msgid "CRL has expired"
-msgstr "CRL has expired"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_NOT_YET_VALID.descr:45
 msgid "CRL is not yet valid"
-msgstr "CRL is not yet valid"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_SIGNATURE_FAILURE.descr:33
 msgid "CRL signature failure"
-msgstr "CRL signature failure"
+msgstr ""
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.blockquote.p:23
@@ -229,7 +229,7 @@ msgstr "Kan nie URN oplos nie"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_CHAIN_TOO_LONG.descr:89
 msgid "Certificate chain too long"
-msgstr "Certificate chain too long"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.descr:5
 #, fuzzy
@@ -238,27 +238,27 @@ msgstr "Certificate is not yet valid"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.descr:41
 msgid "Certificate has expired"
-msgstr "Certificate has expired"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.descr:37
 msgid "Certificate is not yet valid"
-msgstr "Certificate is not yet valid"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_UNTRUSTED.descr:109
 msgid "Certificate not trusted"
-msgstr "Certificate not trusted"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REJECTED.descr:113
 msgid "Certificate rejected"
-msgstr "Certificate rejected"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REVOKED.descr:93
 msgid "Certificate revoked"
-msgstr "Certificate revoked"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_SIGNATURE_FAILURE.descr:29
 msgid "Certificate signature failure"
-msgstr "Certificate signature failure"
+msgstr ""
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
@@ -426,19 +426,19 @@ msgstr "Vir Opera-blaaiers, gaan na: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
-msgstr "Format error in CRL's lastUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD.descr:65
 msgid "Format error in CRL's nextUpdate field"
-msgstr "Format error in CRL's nextUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Format error in certificate's notAfter field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
-msgstr "Format error in certificate's notBefore field"
+msgstr ""
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
@@ -546,19 +546,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.descr:97
 msgid "Invalid CA certificate"
-msgstr "Invalid CA certificate"
+msgstr ""
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
 msgid "Invalid URL"
 msgstr "Ongeldige URL"
 
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.descr:129
 msgid "Key usage does not include certificate signing"
-msgstr "Key usage does not include certificate signing"
+msgstr ""
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:30
 msgid "Missing HTTP Identifier (HTTP/1.0)."
-msgstr "Ontbrekende HTTP-identifiseerder (HTTP/1.0)"
+msgstr "Ontbrekende HTTP-identifiseerder (HTTP/1.0)."
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:29
 msgid "Missing URL."
@@ -590,11 +590,11 @@ msgstr "Bewerking suksesvol"
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.descr:69
 msgid "Out of memory"
-msgstr "Out of memory"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_PATH_LENGTH_EXCEEDED.descr:101
 msgid "Path length constraint exceeded"
-msgstr "Path length constraint exceeded"
+msgstr ""
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:28
 msgid ""
@@ -629,29 +629,26 @@ msgstr "Navraag is te groot."
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
 msgid "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
-msgstr "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.detail:37
 msgid "SSL Certficate is not valid before: %ssl_notbefore"
-msgstr "SSL Certficate is not valid before: %ssl_notbefore"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.detail:41
 msgid "SSL Certificate expired on: %ssl_notafter"
-msgstr "SSL Certificate expired on: %ssl_notafter"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.detail:57
 msgid ""
 "SSL Certificate has invalid expiration date (the 'not after' field): "
 "%ssl_subject"
 msgstr ""
-"SSL Certificate has invalid expiration date (the 'not after' field): "
-"%ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.detail:53
 msgid ""
 "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 msgstr ""
-"SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
 msgid "Select Auto-detect proxy settings for this network"
@@ -667,19 +664,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Self signed certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Self signed certificate in certificate chain"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Self-signed SSL Certificate in chain: %ssl_subject"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Self-signed SSL Certificate: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 msgid "Socket Failure"
@@ -747,7 +744,7 @@ msgstr "Squid het die volgende FTP-opdrag gestuur:"
 
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.descr:117
 msgid "Subject issuer mismatch"
-msgstr "Subject issuer mismatch"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
@@ -1036,19 +1033,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.detail:25
 msgid "Unable to decode issuer (CA) public key: %ssl_ca_name"
-msgstr "Unable to decode issuer (CA) public key: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.descr:25
 msgid "Unable to decode issuer public key"
-msgstr "Unable to decode issuer public key"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE.descr:21
 msgid "Unable to decrypt CRL's signature"
-msgstr "Unable to decrypt CRL's signature"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE.descr:17
 msgid "Unable to decrypt certificate's signature"
-msgstr "Unable to decrypt certificate's signature"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
@@ -1060,19 +1057,19 @@ msgstr "Kan nie dié versoek nou aanstuur nie"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
-msgstr "Unable to get certificate CRL"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.descr:9
 msgid "Unable to get issuer certificate"
-msgstr "Unable to get issuer certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.descr:81
 msgid "Unable to get local issuer certificate"
-msgstr "Unable to get local issuer certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE.descr:85
 msgid "Unable to verify the first certificate"
-msgstr "Unable to verify the first certificate"
+msgstr ""
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
@@ -1085,7 +1082,7 @@ msgstr "Niegesteunde versoekmetode en -protokol"
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
-msgstr "Unsupported certificate purpose"
+msgstr ""
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
 msgid ""
@@ -29,11 +29,12 @@ ro	ro-ro ro-md
 ru	ru-ru
 sk	sk-sk
 sl	sl-si
-sr-latn	sr sr-sp sr-latn-cs
+sr-cyrl sr-rs sr-cyrl-cs sr-cyrl-rs
+sr-latn	sr sr-sp sr-latn-cs sr-latn-rs
 sv	sv-fi sv-se
 th	th-th
 tr	tr-tr
 uk	uk-ua
 vi	vi-vn
-zh-tw	zh-hk zh-mo
-zh-cn	zh-sg
+zh-hant	zh-hant-tw zh-hant-hk zh-hant-mo zh-tw zh-hk zh-mo
+zh-hans	zh-hans-cn zh-cn zh-hans-sg zh-sg
@@ -8,15 +8,17 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2009-01-27 20:36+0000\n"
-"Last-Translator: MaXeR <Unknown>\n"
+"PO-Revision-Date: 2013-10-31 12:16+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Arabic <ar@li.org>\n"
 "Language: ar\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=6; plural=n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 "
+"&& n%100<=10 ? 3 : n%100>=11 && n%100<=99 ? 4 : 5;\n"
+"X-Generator: Pootle 2.1.6\n"
 "X-Launchpad-Export-Date: 2009-01-31 11:56+0000\n"
-"X-Generator: Launchpad (build Unknown)\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -52,13 +54,13 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.detail:69
 msgid "%ssl_error_descr"
-msgstr "%ssl_error_descr"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.detail:97
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.detail:117
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.detail:125
 msgid "%ssl_error_descr: %ssl_ca_name"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.detail:1
 #, fuzzy
@@ -86,7 +88,7 @@ msgstr "%ssl_error_descr: %ssl_ca_name"
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.detail:129
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.detail:133
 msgid "%ssl_error_descr: %ssl_subject"
-msgstr "%ssl_error_descr: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
@@ -107,7 +109,7 @@ msgstr ""
 msgid ""
 "<b>Invalid Response</b> error was encountered while trying to process the "
 "request:"
-msgstr ""
+msgstr "طلب مرفوض.خطأ أثناء اجراء الطلب"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
 msgid ""
@@ -177,7 +179,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Application verification failure"
+msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -187,23 +189,23 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.descr:125
 msgid "Authority and issuer serial number mismatch"
-msgstr "Authority and issuer serial number mismatch"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_AKID_SKID_MISMATCH.descr:121
 msgid "Authority and subject key identifier mismatch"
-msgstr "Authority and subject key identifier mismatch"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_HAS_EXPIRED.descr:49
 msgid "CRL has expired"
-msgstr "CRL has expired"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_NOT_YET_VALID.descr:45
 msgid "CRL is not yet valid"
-msgstr "CRL is not yet valid"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_SIGNATURE_FAILURE.descr:33
 msgid "CRL signature failure"
-msgstr "CRL signature failure"
+msgstr ""
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.blockquote.p:23
@@ -221,7 +223,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_CHAIN_TOO_LONG.descr:89
 msgid "Certificate chain too long"
-msgstr "Certificate chain too long"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.descr:5
 #, fuzzy
@@ -230,27 +232,27 @@ msgstr "Certificate is not yet valid"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.descr:41
 msgid "Certificate has expired"
-msgstr "Certificate has expired"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.descr:37
 msgid "Certificate is not yet valid"
-msgstr "Certificate is not yet valid"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_UNTRUSTED.descr:109
 msgid "Certificate not trusted"
-msgstr "Certificate not trusted"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REJECTED.descr:113
 msgid "Certificate rejected"
-msgstr "Certificate rejected"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REVOKED.descr:93
 msgid "Certificate revoked"
-msgstr "Certificate revoked"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_SIGNATURE_FAILURE.descr:29
 msgid "Certificate signature failure"
-msgstr "Certificate signature failure"
+msgstr ""
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
@@ -418,19 +420,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
-msgstr "Format error in CRL's lastUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD.descr:65
 msgid "Format error in CRL's nextUpdate field"
-msgstr "Format error in CRL's nextUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Format error in certificate's notAfter field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
-msgstr "Format error in certificate's notBefore field"
+msgstr ""
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
@@ -535,15 +537,15 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.descr:97
 msgid "Invalid CA certificate"
-msgstr "Invalid CA certificate"
+msgstr ""
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
 msgid "Invalid URL"
 msgstr "مسار غير صحيح"
 
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.descr:129
 msgid "Key usage does not include certificate signing"
-msgstr "Key usage does not include certificate signing"
+msgstr ""
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:30
 msgid "Missing HTTP Identifier (HTTP/1.0)."
@@ -577,11 +579,11 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.descr:69
 msgid "Out of memory"
-msgstr "Out of memory"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_PATH_LENGTH_EXCEEDED.descr:101
 msgid "Path length constraint exceeded"
-msgstr "Path length constraint exceeded"
+msgstr ""
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:28
 msgid ""
@@ -616,29 +618,26 @@ msgstr ""
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
 msgid "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
-msgstr "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.detail:37
 msgid "SSL Certficate is not valid before: %ssl_notbefore"
-msgstr "SSL Certficate is not valid before: %ssl_notbefore"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.detail:41
 msgid "SSL Certificate expired on: %ssl_notafter"
-msgstr "SSL Certificate expired on: %ssl_notafter"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.detail:57
 msgid ""
 "SSL Certificate has invalid expiration date (the 'not after' field): "
 "%ssl_subject"
 msgstr ""
-"SSL Certificate has invalid expiration date (the 'not after' field): "
-"%ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.detail:53
 msgid ""
 "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 msgstr ""
-"SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
 msgid "Select Auto-detect proxy settings for this network"
@@ -654,19 +653,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Self signed certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Self signed certificate in certificate chain"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Self-signed SSL Certificate in chain: %ssl_subject"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Self-signed SSL Certificate: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 msgid "Socket Failure"
@@ -728,7 +727,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.descr:117
 msgid "Subject issuer mismatch"
-msgstr "Subject issuer mismatch"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
@@ -1000,19 +999,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.detail:25
 msgid "Unable to decode issuer (CA) public key: %ssl_ca_name"
-msgstr "Unable to decode issuer (CA) public key: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.descr:25
 msgid "Unable to decode issuer public key"
-msgstr "Unable to decode issuer public key"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE.descr:21
 msgid "Unable to decrypt CRL's signature"
-msgstr "Unable to decrypt CRL's signature"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE.descr:17
 msgid "Unable to decrypt certificate's signature"
-msgstr "Unable to decrypt certificate's signature"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
@@ -1024,19 +1023,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
-msgstr "Unable to get certificate CRL"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.descr:9
 msgid "Unable to get issuer certificate"
-msgstr "Unable to get issuer certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.descr:81
 msgid "Unable to get local issuer certificate"
-msgstr "Unable to get local issuer certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE.descr:85
 msgid "Unable to verify the first certificate"
-msgstr "Unable to verify the first certificate"
+msgstr ""
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
@@ -1049,7 +1048,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
-msgstr "Unsupported certificate purpose"
+msgstr ""
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
 msgid ""
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:08+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 11:36+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: az\n"
 "MIME-Version: 1.0\n"
@@ -48,13 +48,13 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.detail:69
 msgid "%ssl_error_descr"
-msgstr "%ssl_error_descr"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.detail:97
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.detail:117
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.detail:125
 msgid "%ssl_error_descr: %ssl_ca_name"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.detail:1
 #, fuzzy
@@ -82,7 +82,7 @@ msgstr "%ssl_error_descr: %ssl_ca_name"
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.detail:129
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.detail:133
 msgid "%ssl_error_descr: %ssl_subject"
-msgstr "%ssl_error_descr: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
@@ -191,7 +191,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Application verification failure"
+msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -201,23 +201,23 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.descr:125
 msgid "Authority and issuer serial number mismatch"
-msgstr "Authority and issuer serial number mismatch"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_AKID_SKID_MISMATCH.descr:121
 msgid "Authority and subject key identifier mismatch"
-msgstr "Authority and subject key identifier mismatch"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_HAS_EXPIRED.descr:49
 msgid "CRL has expired"
-msgstr "CRL has expired"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_NOT_YET_VALID.descr:45
 msgid "CRL is not yet valid"
-msgstr "CRL is not yet valid"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CRL_SIGNATURE_FAILURE.descr:33
 msgid "CRL signature failure"
-msgstr "CRL signature failure"
+msgstr ""
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.blockquote.p:23
@@ -235,7 +235,7 @@ msgstr "URN tapılmadı"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_CHAIN_TOO_LONG.descr:89
 msgid "Certificate chain too long"
-msgstr "Certificate chain too long"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.descr:5
 #, fuzzy
@@ -244,27 +244,27 @@ msgstr "Certificate is not yet valid"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.descr:41
 msgid "Certificate has expired"
-msgstr "Certificate has expired"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.descr:37
 msgid "Certificate is not yet valid"
-msgstr "Certificate is not yet valid"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_UNTRUSTED.descr:109
 msgid "Certificate not trusted"
-msgstr "Certificate not trusted"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REJECTED.descr:113
 msgid "Certificate rejected"
-msgstr "Certificate rejected"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REVOKED.descr:93
 msgid "Certificate revoked"
-msgstr "Certificate revoked"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_SIGNATURE_FAILURE.descr:29
 msgid "Certificate signature failure"
-msgstr "Certificate signature failure"
+msgstr ""
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
@@ -435,19 +435,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
-msgstr "Format error in CRL's lastUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD.descr:65
 msgid "Format error in CRL's nextUpdate field"
-msgstr "Format error in CRL's nextUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Format error in certificate's notAfter field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
-msgstr "Format error in certificate's notBefore field"
+msgstr ""
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
@@ -557,7 +557,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.descr:97
 msgid "Invalid CA certificate"
-msgstr "Invalid CA certificate"
+msgstr ""
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
 #, fuzzy
@@ -566,7 +566,7 @@ msgstr "Səhv URL"
 
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.descr:129
 msgid "Key usage does not include certificate signing"
-msgstr "Key usage does not include certificate signing"
+msgstr ""
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:30
 msgid "Missing HTTP Identifier (HTTP/1.0)."
@@ -601,11 +601,11 @@ msgstr "Əməliyyat müvəfəqiyyətlə başa çatdı"
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.descr:69
 msgid "Out of memory"
-msgstr "Out of memory"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_PATH_LENGTH_EXCEEDED.descr:101
 msgid "Path length constraint exceeded"
-msgstr "Path length constraint exceeded"
+msgstr ""
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:28
 #, fuzzy
@@ -649,29 +649,26 @@ msgstr "Sorğu həddən ziyadə böyükdür."
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
 msgid "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
-msgstr "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.detail:37
 msgid "SSL Certficate is not valid before: %ssl_notbefore"
-msgstr "SSL Certficate is not valid before: %ssl_notbefore"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.detail:41
 msgid "SSL Certificate expired on: %ssl_notafter"
-msgstr "SSL Certificate expired on: %ssl_notafter"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.detail:57
 msgid ""
 "SSL Certificate has invalid expiration date (the 'not after' field): "
 "%ssl_subject"
 msgstr ""
-"SSL Certificate has invalid expiration date (the 'not after' field): "
-"%ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.detail:53
 msgid ""
 "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 msgstr ""
-"SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
 msgid "Select Auto-detect proxy settings for this network"
@@ -687,19 +684,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Self signed certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Self signed certificate in certificate chain"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Self-signed SSL Certificate in chain: %ssl_subject"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Self-signed SSL Certificate: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 #, fuzzy
@@ -776,7 +773,7 @@ msgstr "Squid Keş FTP-nin növbəti əmrini göndərmişdir:"
 
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.descr:117
 msgid "Subject issuer mismatch"
-msgstr "Subject issuer mismatch"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
@@ -1077,19 +1074,19 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.detail:25
 msgid "Unable to decode issuer (CA) public key: %ssl_ca_name"
-msgstr "Unable to decode issuer (CA) public key: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.descr:25
 msgid "Unable to decode issuer public key"
-msgstr "Unable to decode issuer public key"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE.descr:21
 msgid "Unable to decrypt CRL's signature"
-msgstr "Unable to decrypt CRL's signature"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE.descr:17
 msgid "Unable to decrypt certificate's signature"
-msgstr "Unable to decrypt certificate's signature"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
@@ -1101,19 +1098,19 @@ msgstr "Hal-hazırda sorğunuzu yönlədirmək mümkün deyildir."
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
-msgstr "Unable to get certificate CRL"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.descr:9
 msgid "Unable to get issuer certificate"
-msgstr "Unable to get issuer certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.descr:81
 msgid "Unable to get local issuer certificate"
-msgstr "Unable to get local issuer certificate"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE.descr:85
 msgid "Unable to verify the first certificate"
-msgstr "Unable to verify the first certificate"
+msgstr ""
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
@@ -1126,7 +1123,7 @@ msgstr "Dəstəklənməyən sorğu metodu və protokol"
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
-msgstr "Unsupported certificate purpose"
+msgstr ""
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
 msgid ""
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2012-02-02 00:54+0200\n"
-"Last-Translator: Evgeni <etg@setcom.bg>\n"
+"PO-Revision-Date: 2013-10-31 12:25+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: bg\n"
 "MIME-Version: 1.0\n"
@@ -56,9 +56,8 @@ msgid "%ssl_error_descr: %ssl_ca_name"
 msgstr "%ssl_error_descr: %ssl_ca_name"
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.detail:1
-#, fuzzy
 msgid "%ssl_error_descr: %ssl_lib_error"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.detail:5
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.detail:13
@@ -86,7 +85,7 @@ msgstr "%ssl_error_descr: %ssl_subject"
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
 msgid "%z"
-msgstr "%z"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:08+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 12:21+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: ca\n"
 "MIME-Version: 1.0\n"
@@ -90,7 +90,7 @@ msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
-msgstr ""
+msgstr "<a href=\"../\">Directori Rail</a> (<a href=\"/\">Directori Rail</a>)"
 
 #: templates/ERR_INVALID_REQ+html.body.div.p:20
 msgid ""
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-06-25 02:39+0200\n"
-"Last-Translator: Robert <Dessa@gmake.de>\n"
+"PO-Revision-Date: 2012-06-12 13:28+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: de\n"
 "MIME-Version: 1.0\n"
@@ -456,7 +456,7 @@ msgstr "Weiterleitung verweigert."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.blockquote.p:23
 msgid "Gateway Proxy Failure"
-msgstr ""
+msgstr "Gateway Proxy Fehler"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:34
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:35
@@ -1041,6 +1041,9 @@ msgid ""
 "This proxy limits your time online with a quota. Your time budget is now "
 "empty but will be refilled when the configured time period starts again."
 msgstr ""
+"Ihr Zugriff auf diesen Proxy unterliegt einer Zeitbegrenzung. Ihr Online-"
+"Zeitguthaben ist nun aufgebraucht. Es wird automatisch erneuert, sobald der "
+"nächste vereinbarte Zyklus beginnt."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.p:26
 msgid ""
@@ -1050,7 +1053,7 @@ msgstr ""
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.blockquote.p:23
 msgid "Time Quota Exceeded."
-msgstr ""
+msgstr "Zeitguthaben aufgebraucht"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:37
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:37
@@ -3,14 +3,15 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2010-06-07 23:05+0330\n"
-"Last-Translator: Mohsen Saeedi <mohsen.saeedi@gmail.com>\n"
+"PO-Revision-Date: 2013-10-31 14:45+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
-"Language: \n"
+"Language: fa\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: Translate Toolkit 1.1.1\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+"X-Generator: Pootle 2.1.6\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -95,7 +96,7 @@ msgstr "<a href=\"../\">مسیر اصلی</a> (<a href=\"/\">مسیر ریشه</
 msgid ""
 "<b>Invalid Request</b> error was encountered while trying to process the "
 "request:"
-msgstr "<b>درخواست نامعتبر</b> این خطا در زمان پردازش درخواست روی داده بود:"
+msgstr "<b>درخواست نامعتبر</b> این خطا در زمان پردازش این درخواست روی داده بود:"
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:20
 msgid ""
@@ -262,7 +263,7 @@ msgstr "Certificate signature failure"
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
-msgstr "دوره عمر ارتباط شما به پایان رسید."
+msgstr "زمان ارتباط منقضی شد."
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Connection to %I failed."
@@ -335,7 +336,7 @@ msgstr "خطا: رد شدن دسترسی به نهانگاه"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Manager Access Denied"
-msgstr "خطا: اجازه دسترسی به مدیریت Cache وجود ندارد."
+msgstr "خطا: رد شدن دسترسی برای مدیریت نهانگاه"
 
 #: templates/ERR_FTP_PUT_ERROR+html.head.title:4
 msgid "ERROR: FTP upload failed"
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:08+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 13:25+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: fi\n"
 "MIME-Version: 1.0\n"
@@ -276,15 +276,15 @@ msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table:-1
 msgid "Directory Listing"
-msgstr ""
+msgstr "Hakemistolistaus"
 
 #: templates/ERR_DIR_LISTING+html.head.title:4
 msgid "Directory: %U"
 msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.h2:14
 msgid "Directory: <a href=\"%U\">%U</a>/"
-msgstr ""
+msgstr "Hakemisto: <a href=\"%U\">%U</a>/"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h1:14
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h1:14
@@ -513,7 +513,7 @@ msgstr ""
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.blockquote.p:23
 msgid "ICAP protocol error."
-msgstr ""
+msgstr "ICAP protokollavirhe."
 
 #: templates/ERR_TOO_BIG+html.body.div.p:27
 msgid ""
@@ -666,7 +666,7 @@ msgstr ""
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
-msgstr ""
+msgstr "Valitse Automaattisesti haetut asetukset"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:46
 msgid "Select Use Automatic proxy configuration"
@@ -702,7 +702,7 @@ msgstr "Joku osa URL-osoitetta on virheellinen."
 #: templates/ERR_INVALID_REQ+html.body.div.p:26
 #: templates/ERR_INVALID_URL+html.body.div.p:28
 msgid "Some possible problems are:"
-msgstr "Mahdollisia ongelmia:"
+msgstr "Muutamia mahdollisia ongelmia ovat:"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:26
 msgid ""
@@ -766,7 +766,7 @@ msgstr "DNS-palvelin palautti viestin:"
 
 #: templates/ERR_ESI+html.body.div.p:26
 msgid "The ESI processor returned:"
-msgstr ""
+msgstr "ESI prosessori palautti:"
 
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.p:20
 msgid "The FTP server was too busy to retrieve the URL: <a href=\"%U\">%U</a>"
@@ -783,7 +783,7 @@ msgstr ""
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:32
 msgid "The ICAP server is not reachable."
-msgstr ""
+msgstr "ICAP palvelin ei ole tavoitettavissa."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:32
 msgid ""
@@ -846,7 +846,7 @@ msgstr "Kohdepalvelin tai -verkko saattaa olla alhaalla. Uusi hakupyyntösi."
 
 #: templates/ERR_TOO_BIG+html.body.div.blockquote.p:23
 msgid "The request or reply is too large."
-msgstr ""
+msgstr "Pyyntö tai paluuvastaus on liian iso."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h2:15
@@ -888,7 +888,7 @@ msgstr "Pyydettyä URL-osoitetta ei voitu hakea"
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.p:27
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.p:28
 msgid "The server responded with:"
-msgstr ""
+msgstr "Palvelin vastasi:"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.p:26
 #: templates/ERR_ICAP_FAILURE+html.body.div.p:26
@@ -986,7 +986,7 @@ msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.p:26
 msgid "This means:"
-msgstr ""
+msgstr "Tämä tarkoittaa:"
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:33
 msgid ""
@@ -1084,7 +1084,7 @@ msgstr "Unable to verify the first certificate"
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
 msgid "Unsupported HTTP version"
-msgstr ""
+msgstr "Tätä HTTP versiota ei tueta"
 
 #: templates/ERR_UNSUP_REQ+html.body.div.blockquote.p:23
 msgid "Unsupported Request Method and Protocol"
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2012-04-01 21:32+0200\n"
-"Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
+"PO-Revision-Date: 2013-10-31 13:24+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: fr\n"
 "MIME-Version: 1.0\n"
@@ -192,7 +192,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Échec lors de la vérification d'application"
+msgstr "Échec lors de la vérification de l'application"
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -503,7 +503,7 @@ msgstr "Défaillance de la passerelle Proxy"
 #: templates/ERR_WRITE_ERROR+html.body.div.p:36
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.p:34
 msgid "Generated %T by %h (%s)"
-msgstr "Générer le %T par %h (%s)"
+msgstr "Générée le %T par %h (%s)"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:34
 msgid ""
@@ -516,7 +516,7 @@ msgstr ""
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:26
 msgid "Hey, don't expect too much from URNs on %T :)"
-msgstr "Hé! Il ne faut pas attendre grand-chose des URNs avec %T :)"
+msgstr "Hé! Il ne faut pas vous attendre à grand-chose des URNs dans %T :)"
 
 # Suggestion2 OK
 # Bernard
@@ -702,19 +702,19 @@ msgstr "Utilisez la sélection automatique pour configurer le proxy"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Certificat auto-signé"
+msgstr "Auto signature du certificat"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Certificat auto-signé dans la chaîne du certificat"
+msgstr "Auto signature du certificat dans la chaîne de certificat"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Certificat SSL auto-signé dans la chaîne : %ssl_subject"
+msgstr "Le certificat SSL c'est auto-signé dans la chaîne : %ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Certificat SSL auto-signé : %ssl_subject"
+msgstr "Le certificat SSL c'est auto-signé : %ssl_subject"
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 msgid "Socket Failure"
@@ -4,15 +4,15 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2012-06-16 18:26+0400\n"
-"Last-Translator: Arthur Tumanyan <arthurtumanyan@yahoo.com>\n"
+"PO-Revision-Date: 2013-10-31 11:58+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Arthur Tumanyan\n"
 "Language: hy\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Virtaal 0.6.1\n"
+"X-Generator: Pootle 2.1.6\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -37,27 +37,26 @@ msgstr "%Z"
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:25
 msgid "%f"
-msgstr "%f"
+msgstr ""
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:31
 msgid "%g"
-msgstr "%g"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.detail:69
 msgid "%ssl_error_descr"
-msgstr "%ssl_error_descr"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.detail:97
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.detail:117
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.detail:125
 msgid "%ssl_error_descr: %ssl_ca_name"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.detail:1
-#, fuzzy
 msgid "%ssl_error_descr: %ssl_lib_error"
 msgstr "%ssl_error_descr: %ssl_ca_name"
 
@@ -82,12 +81,12 @@ msgstr "%ssl_error_descr: %ssl_ca_name"
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.detail:129
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.detail:133
 msgid "%ssl_error_descr: %ssl_subject"
-msgstr "%ssl_error_descr: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
 msgid "%z"
-msgstr "%z"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
@@ -547,11 +546,11 @@ msgstr "Անթույլատրելի կրկնակի կառավարող նիշ URL-
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:46
 msgid "In the HTTP proxy box type the proxy name %h and port %b."
-msgstr "HTTP proxy դաշտում նշիր proxy name %h և port 3128."
+msgstr "HTTP proxy դաշտում նշիր proxy name %h և port %b."
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.descr:97
 msgid "Invalid CA certificate"
-msgstr "Invalid CA certificate"
+msgstr ""
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
 msgid "Invalid URL"
@@ -612,7 +611,6 @@ msgstr ""
 "\"mailto:%w%W\">քեշի կառավարիչին</a>."
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.p:28
-#, fuzzy
 msgid ""
 "Please contact the <a href=\"mailto:%w%W\">cache administrator</a> if you "
 "have difficulties authenticating yourself."
@@ -759,7 +757,7 @@ msgstr "Squid-ը ուղարկեց հետևյալ FTP հրամանը:"
 
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.descr:117
 msgid "Subject issuer mismatch"
-msgstr "Subject issuer mismatch"
+msgstr ""
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
@@ -1141,8 +1139,8 @@ msgid ""
 "revalidation prohibited by the <q>only-if-cached</q> directive."
 msgstr ""
 "Դուք իրականացրեցիք հարցում <q>only-if-cached</q> քեշի կառավարման դիրեկտիվով: "
-"Փաստաթուղթը քեշում բացակայում է <em>կամ</em> պահանջվում է <q>only-if-cached</"
-"q> դիրեկտիվի կողմից արգելված հաստատում:"
+"Փաստաթուղթը քեշում բացակայում է <em>կամ</em պահանջվում է <q>only-if-"
+"cached</q> դիրեկտիվի կողմից արգելված հաստատում:"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.blockquote.p:21
 #: templates/ERR_AGENT_WPAD+html.body.div.blockquote.p:21
@@ -8,14 +8,15 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2008-11-02 03:46+1300\n"
-"Last-Translator: Ramdhani Fathurrohman <kontak@ramdhani.net>\n"
+"PO-Revision-Date: 2013-10-31 13:12+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Indonesian <id@li.org>\n"
 "Language: id\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: Pootle 1.1.0\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+"X-Generator: Pootle 2.1.6\n"
 "X-Launchpad-Export-Date: 2008-07-31 11:24+0000\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
@@ -102,15 +103,15 @@ msgid ""
 "<b>Invalid Request</b> error was encountered while trying to process the "
 "request:"
 msgstr ""
-"<b>Cacat Meminta</b> kesalahan ditemukan sedangkan mencoba mengolah "
-"permintaan:"
+"<b>Permintaan tidak valid</ b> telah menemui kesalahan ketika mencoba "
+"memproses permintaan:"
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:20
 msgid ""
 "<b>Invalid Response</b> error was encountered while trying to process the "
 "request:"
 msgstr ""
-"<b>Cacat Jawaban</b> kesalahan ditemukan sedangkan mencoba mengolah "
+"<b>Respon tidak valid</ b> telah menemui kesalahan ketika mencoba memproses "
 "permintaan:"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
@@ -169,7 +170,7 @@ msgstr ""
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:33
 msgid "An Illegal response was received from the ICAP server."
-msgstr "Sebuah tanggapan Illegal diterima dari ICAP server."
+msgstr "Jawaban Ilegal diterima dari server ICAP."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:30
 msgid ""
@@ -3,63 +3,63 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-08-07 17:33+0200\n"
-"Last-Translator: Francesco <kinkie@squid-cache.org>\n"
+"PO-Revision-Date: 2013-11-10 22:27+0200\n"
+"Last-Translator: Francesco <gkinkie@gmail.com>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "Language: it\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Pootle 2.1.6\n"
+"X-Generator: Pootle 2.5.0\n"
 "X-Launchpad-Export-Date: 2009-07-22 10:00+0000\n"
+"X-POOTLE-MTIME: 1384118865.0\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:30
 msgid "%F"
-msgstr "%F"
+msgstr ""
 
 #: templates/ERR_INVALID_REQ+html.body.div.blockquote.pre:23
 #: templates/ERR_INVALID_RESP+html.body.div.blockquote.pre:23
 msgid "%R"
-msgstr "%R"
+msgstr ""
 
 #: templates/ERR_ESI+html.body.div.blockquote.pre:28
 msgid "%Z"
-msgstr "%Z"
+msgstr ""
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:25
 msgid "%f"
-msgstr "%f"
+msgstr ""
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:31
 msgid "%g"
-msgstr "%g"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.detail:69
 msgid "%ssl_error_descr"
-msgstr "%ssl_error_descr"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.detail:97
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.detail:117
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.detail:125
 msgid "%ssl_error_descr: %ssl_ca_name"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.detail:1
-#, fuzzy
 msgid "%ssl_error_descr: %ssl_lib_error"
-msgstr "%ssl_error_descr: %ssl_ca_name"
+msgstr ""
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.detail:5
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.detail:13
@@ -82,12 +82,12 @@ msgstr "%ssl_error_descr: %ssl_ca_name"
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.detail:129
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.detail:133
 msgid "%ssl_error_descr: %ssl_subject"
-msgstr "%ssl_error_descr: %ssl_subject"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
 msgid "%z"
-msgstr "%z"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
@@ -123,13 +123,15 @@ msgstr ""
 #: templates/ERR_URN_RESOLVE+html.body.div.h2:15
 msgid "A URL for the requested URN could not be retrieved"
 msgstr ""
-"Non è stato possibile ottenere una URL corrispondente alla URN richiesta."
+"Non è stato possibile ottenere una URL corrispondente alla URN richiesta"
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:26
 msgid ""
 "A non-recoverable internal failure or configuration problem prevents this "
 "request from being completed."
 msgstr ""
+"Un errore interno non recuperabile o un problema di configurazione impedisce "
+"di portare a termine questa richiesta."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.blockquote.p:23
 msgid "Access Denied."
@@ -147,14 +149,16 @@ msgstr ""
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:31
 msgid "All configured parent caches may be currently unreachable."
 msgstr ""
+"Tutte le cache di livello superiore potrebbero non essere raggiungibili in "
+"questo momento."
 
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:20
 msgid ""
 "An FTP authentication failure occurred while trying to retrieve the URL: <a "
 "href=\"%U\">%U</a>"
 msgstr ""
-"Le credenziali fornite per l'accesso al server FTP relativo alla URL <a href="
-"\"%U\">%U</a> sono invalide."
+"Le credenziali fornite per l'accesso al server FTP relativo alla URL <a "
+"href=\"%U\">%U</a> sono invalide"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.p:20
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.p:20
@@ -163,7 +167,7 @@ msgid ""
 "\">%U</a>"
 msgstr ""
 "Si è verificato un errore di protocollo FTP durante l'accesso alla URL <a "
-"href=\"%U\">%U</a>."
+"href=\"%U\">%U</a>"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:33
 msgid "An Illegal response was received from the ICAP server."
@@ -174,6 +178,8 @@ msgid ""
 "An Internet connection needed to access this domains origin servers may be "
 "down."
 msgstr ""
+"Una connessione ad Internet necessaria per raggiungere i server per questo "
+"dominio potrebbe essere indisponibile."
 
 #: templates/ERR_READ_ERROR+html.body.div.p:28
 msgid ""
@@ -193,33 +199,38 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Application verification failure"
+msgstr "Fallimento nella verifica dell'applicazione"
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
 "At least one precondition specified by the HTTP client in the request header "
 "has failed."
 msgstr ""
+"Almeno una delle precondizioni specificate dal client HTTP negli header "
+"della richiesta è fallita."
 
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.descr:125
 msgid "Authority and issuer serial number mismatch"
-msgstr "Authority and issuer serial number mismatch"
+msgstr ""
+"Mancata corrispondenza tra numero di serie della autorità di certificazione "
+"e dell'emettitore"
 
 #: templates/error-details.txt+X509_V_ERR_AKID_SKID_MISMATCH.descr:121
 msgid "Authority and subject key identifier mismatch"
-msgstr "Authority and subject key identifier mismatch"
+msgstr ""
+"Mancata corrispondenza tra autorità e chiave di identificazione del soggetto"
 
 #: templates/error-details.txt+X509_V_ERR_CRL_HAS_EXPIRED.descr:49
 msgid "CRL has expired"
-msgstr "CRL has expired"
+msgstr "La lista dei certificati revocati (CRL) è scaduta"
 
 #: templates/error-details.txt+X509_V_ERR_CRL_NOT_YET_VALID.descr:45
 msgid "CRL is not yet valid"
-msgstr "CRL is not yet valid"
+msgstr "La lista dei certificati revocati (CRL) non è ancora valida"
 
 #: templates/error-details.txt+X509_V_ERR_CRL_SIGNATURE_FAILURE.descr:33
 msgid "CRL signature failure"
-msgstr "CRL signature failure"
+msgstr "Fallimento nella firma della lista dei certificati revocati (CRL)"
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.blockquote.p:23
@@ -233,44 +244,43 @@ msgstr "L'accesso al cache manager è negato."
 
 #: templates/ERR_URN_RESOLVE+html.body.div.blockquote.p:23
 msgid "Cannot Resolve URN"
-msgstr "Impossibile risolvere la URN."
+msgstr "Impossibile risolvere la URN"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_CHAIN_TOO_LONG.descr:89
 msgid "Certificate chain too long"
-msgstr "Certificate chain too long"
+msgstr "Catena di certificati troppo lunga"
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.descr:5
-#, fuzzy
 msgid "Certificate does not match domainname"
-msgstr "Certificate is not yet valid"
+msgstr "Il certificato non corrisponde al nome di dominio"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.descr:41
 msgid "Certificate has expired"
-msgstr "Certificate has expired"
+msgstr "Il certificato è scaduto"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.descr:37
 msgid "Certificate is not yet valid"
-msgstr "Certificate is not yet valid"
+msgstr "Il certificato non è ancora valido"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_UNTRUSTED.descr:109
 msgid "Certificate not trusted"
-msgstr "Certificate not trusted"
+msgstr "Certificato non fidato"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REJECTED.descr:113
 msgid "Certificate rejected"
-msgstr "Certificate rejected"
+msgstr "Certificato rifiutato"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REVOKED.descr:93
 msgid "Certificate revoked"
-msgstr "Certificate revoked"
+msgstr "Certificato revocato"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_SIGNATURE_FAILURE.descr:29
 msgid "Certificate signature failure"
-msgstr "Certificate signature failure"
+msgstr "Fallimento nella firma del certificato"
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
-msgstr "Il tempo di mantenimento di connessioni inattive è scaduto."
+msgstr "Il tempo di vita della connessione è scaduto"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Connection to %I failed."
@@ -290,11 +300,11 @@ msgstr "Elenco della directory"
 
 #: templates/ERR_DIR_LISTING+html.head.title:4
 msgid "Directory: %U"
-msgstr "Directory: %U"
+msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.h2:14
 msgid "Directory: <a href=\"%U\">%U</a>/"
-msgstr "Directory: <a href=\"%U\">%U</a>/"
+msgstr ""
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h1:14
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h1:14
@@ -339,15 +349,15 @@ msgstr "ERRORE"
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Access Denied"
-msgstr "ERRORE: accesso alla cache negato."
+msgstr "ERRORE: accesso alla cache negato"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Manager Access Denied"
-msgstr "ERRORE: accesso al Cache Manager negato."
+msgstr "ERRORE: accesso al Cache Manager negato"
 
 #: templates/ERR_FTP_PUT_ERROR+html.head.title:4
 msgid "ERROR: FTP upload failed"
-msgstr "ERRORE: l'invio del file via FTP non è riuscito."
+msgstr "ERRORE: l'invio del file via FTP non è riuscito"
 
 #: templates/ERR_ACCESS_DENIED+html.head.title:4
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.head.title:4
@@ -394,30 +404,28 @@ msgstr "L'elaborazione ESI è fallita."
 
 #: templates/ERR_FTP_PUT_CREATED+html.head.title:4
 #: templates/ERR_FTP_PUT_MODIFIED+html.head.title:4
-#, fuzzy
 msgid "FTP PUT Successful."
-msgstr "Comando FTP PUT eseguito correttamente: il file è stato creato."
+msgstr "Comando FTP PUT eseguito correttamente."
 
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.h2:15
-#, fuzzy
 msgid "FTP PUT upload failed"
-msgstr "Comando FTP PUT non riuscito."
+msgstr "Comando FTP PUT non riuscito"
 
 #: templates/ERR_FTP_DISABLED+html.body.div.blockquote.p:23
 msgid "FTP is Disabled"
-msgstr "Il protocollo FTP è disabilitato."
+msgstr "Il protocollo FTP è disabilitato"
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Failed to establish a secure connection to %I"
 msgstr "Non è stato possibile stabilire una connessione sicura verso %I"
 
 #: templates/ERR_FTP_PUT_CREATED+html.body.div.h2:15
 msgid "File created"
-msgstr "Il file è stato creato."
+msgstr "Il file è stato creato"
 
 #: templates/ERR_FTP_PUT_MODIFIED+html.body.div.h2:15
 msgid "File updated"
-msgstr "Il file è stato aggiornato."
+msgstr "Il file è stato aggiornato"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:26
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:26
@@ -436,27 +444,31 @@ msgstr "Per configurare i browser Opera: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
-msgstr "Format error in CRL's lastUpdate field"
+msgstr ""
+"Errore nel formato del campo lastUpdate della lista dei certificati revocati "
+"(CRL)"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD.descr:65
 msgid "Format error in CRL's nextUpdate field"
-msgstr "Format error in CRL's nextUpdate field"
+msgstr ""
+"Errore nel formato del campo nextUpdate della lista dei certificati revocati "
+"(CRL)"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Format error in certificate's notAfter field"
+msgstr "Errore di formato nel campo notAfter del certificato"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
-msgstr "Format error in certificate's notBefore field"
+msgstr "Errore di formato nel campo notBeforedel certificato"
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
 msgstr "Inoltro negato."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.blockquote.p:23
 msgid "Gateway Proxy Failure"
-msgstr ""
+msgstr "Errore nel Proxy Gateway"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:34
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:35
@@ -500,7 +512,7 @@ msgstr ""
 #: templates/ERR_WRITE_ERROR+html.body.div.p:36
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.p:34
 msgid "Generated %T by %h (%s)"
-msgstr "Generato da %h (%s) il %T."
+msgstr "Generato da %h (%s) il %T"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:34
 msgid ""
@@ -511,7 +523,7 @@ msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.descr:1
 msgid "Handshake with SSL server failed"
-msgstr ""
+msgstr "Fallita la negoziazione del protocollo SSL con il server"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:26
 msgid "Hey, don't expect too much from URNs on %T :)"
@@ -550,27 +562,26 @@ msgstr ""
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
 msgid "Illegal double-escape in the URL-Path"
-msgstr "Doppia codifica (\"double-escape\") non valida nella path della URL."
+msgstr "Doppia codifica (\"double-escape\") non valida nella path della URL"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:46
-#, fuzzy
 msgid "In the HTTP proxy box type the proxy name %h and port %b."
 msgstr ""
-"Nel box \"Proxy HTTP\" inserisci l'indirizzo del proxy (%h) e la porta 3128."
+"Nel box \"Proxy HTTP\" inserisci l'indirizzo del proxy (%h) e la porta %b."
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_CA.descr:97
 msgid "Invalid CA certificate"
-msgstr "Invalid CA certificate"
+msgstr "Certificato dell'emettitore invalido"
 
 #: templates/ERR_INVALID_URL+html.body.div.blockquote.p:23
 msgid "Invalid URL"
 msgstr "URL non valida"
 
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.descr:129
 msgid "Key usage does not include certificate signing"
-msgstr "Key usage does not include certificate signing"
+msgstr "Gli utilizzi validi per la chiave non includono la firma di certificati"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:30
 msgid "Missing HTTP Identifier (HTTP/1.0)."
@@ -582,22 +593,22 @@ msgstr "URL non specificata."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:31
 msgid "Missing hostname"
-msgstr "Nome host non specificato."
+msgstr "Nome host non specificato"
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:30
 msgid ""
 "Missing or incorrect access protocol (should be <q>http://</q> or similar)"
 msgstr ""
-"Protocollo di accesso mancante o non corretto (dovrebbe essere <q>http://</"
-"q> o simile)."
+"Protocollo di accesso mancante o non corretto (dovrebbe essere "
+"<q>http://</q> o simile)"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:28
 msgid "Missing or unknown request method."
 msgstr "Metodo della richiesta non specificato o sconoscito."
 
 #: templates/ERR_NO_RELAY+html.body.div.blockquote.p:23
 msgid "No Wais Relay"
-msgstr "Le funzioni di inoltro Wais non sono implementate."
+msgstr "Le funzioni di inoltro Wais non sono implementate"
 
 #: templates/ERR_FTP_PUT_CREATED+html.body.div.h1:14
 #: templates/ERR_FTP_PUT_MODIFIED+html.body.div.h1:14
@@ -606,11 +617,11 @@ msgstr "Operazione eseguita correttamente"
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.descr:69
 msgid "Out of memory"
-msgstr "Out of memory"
+msgstr "Memoria esaurita"
 
 #: templates/error-details.txt+X509_V_ERR_PATH_LENGTH_EXCEEDED.descr:101
 msgid "Path length constraint exceeded"
-msgstr "Path length constraint exceeded"
+msgstr "Limite alla lunghezza del percorso superato"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:28
 msgid ""
@@ -626,7 +637,6 @@ msgstr ""
 "del servizio alla ricerca informazioni più dettagliate sull'errore."
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.p:28
-#, fuzzy
 msgid ""
 "Please contact the <a href=\"mailto:%w%W\">cache administrator</a> if you "
 "have difficulties authenticating yourself."
@@ -638,7 +648,7 @@ msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:23
 msgid "Precondition Failed."
-msgstr ""
+msgstr "Precondizione non soddisfatta."
 
 #: templates/ERR_READ_ERROR+html.body.div.blockquote.p:23
 msgid "Read Error"
@@ -655,34 +665,34 @@ msgstr "La richiesta è di dimensioni troppo grandi."
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
 msgid "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
-msgstr "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
+msgstr "Errore nel certificato SSL: l'emettitore (CA) non è noto: %ssl_ca_name"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.detail:37
 msgid "SSL Certficate is not valid before: %ssl_notbefore"
-msgstr "SSL Certficate is not valid before: %ssl_notbefore"
+msgstr "Il certificato SSL non è valido prima del: %ssl_notbefore"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.detail:41
 msgid "SSL Certificate expired on: %ssl_notafter"
-msgstr "SSL Certificate expired on: %ssl_notafter"
+msgstr "Il certificato SSL è scaduto il: %ssl_notafter"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.detail:57
 msgid ""
 "SSL Certificate has invalid expiration date (the 'not after' field): "
 "%ssl_subject"
 msgstr ""
-"SSL Certificate has invalid expiration date (the 'not after' field): "
-"%ssl_subject"
+"Il certificato SSL per %ssl_subject ha una data di scadenza (il campo 'not "
+"after') non valida"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.detail:53
 msgid ""
 "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 msgstr ""
-"SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
+"Il certificato SSL per %ssl_subject ha una data di inizio validità (il campo "
+"'not before') non valida"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
-#, fuzzy
 msgid "Select Auto-detect proxy settings for this network"
-msgstr "Seleziona \"Rileva automaticamente impostazioni\""
+msgstr "Seleziona \"Rileva automaticamente impostazioni proxy per questa rete\""
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
@@ -694,27 +704,27 @@ msgstr "Seleziona \"Usa script di configurazione automatica\""
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Self signed certificate"
+msgstr "Certificato autofirmato"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Self signed certificate in certificate chain"
+msgstr "Certificato autofirmato nella catena di certificati"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Self-signed SSL Certificate in chain: %ssl_subject"
+msgstr "Certificato SSL autofirmato nella catena: %ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Self-signed SSL Certificate: %ssl_subject"
+msgstr "Certificato SSL autofirmato: %ssl_subject"
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 msgid "Socket Failure"
-msgstr "L'operazione di rete (socket) è fallita."
+msgstr "L'operazione di rete (socket) è fallita"
 
 #: templates/ERR_INVALID_URL+html.body.div.p:26
 msgid "Some aspect of the requested URL is incorrect."
-msgstr "Qualcosa nella URL richiesta non è corretto."
+msgstr "Qualche elemento della URL richiesta non è corretto."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.p:28
 #: templates/ERR_CONFLICT_HOST+html.body.div.p:28
@@ -775,7 +785,7 @@ msgstr "Il comando FTP inviato da Squid era:"
 
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.descr:117
 msgid "Subject issuer mismatch"
-msgstr "Subject issuer mismatch"
+msgstr "Mancata corrispondenza dell'emettitore (CA) del certificato"
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
@@ -809,11 +819,15 @@ msgid ""
 "The administrator may not allow this cache to make direct connections to "
 "origin servers."
 msgstr ""
+"L'amministratore potrebbe non consentire a questa cache di fare collegamenti "
+"diretti ai server di origine."
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.ul.li:30
 msgid ""
 "The domain may have moved very recently. Trying again will resolve that."
 msgstr ""
+"Questo dominio potrebbe essere stato spostato molto di recente. Un nuovo "
+"tentativo dovrebbe risolvere la situazione."
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:20
 msgid "The following URL could not be retrieved: <a href=\"%U\">%U</a>"
@@ -929,6 +943,9 @@ msgid ""
 "The website may require you to use a local country-based version. Using your "
 "ISP provided DNS server(s) should resolve that."
 msgstr ""
+"Il sito web potrebbe richiedere di usare una versione localizzata. Facendo "
+"riferimento ai server DNS forniti dal vostro ISP dovrebbe risolvere "
+"l'inconveniente."
 
 #: templates/ERR_NO_RELAY+html.body.div.p:26
 msgid ""
@@ -977,13 +994,12 @@ msgstr ""
 "configurato in modo errato."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:28
-#, fuzzy
 msgid ""
 "This may be due to limits established by the Internet Service Provider who "
 "operates this cache. Please contact them directly for more information."
 msgstr ""
-"Questi limiti sono stati stabiliti dall'ISP che gestisce questo proxy. Se "
-"ritieni sia un errore, contatta il fornitore del servizio."
+"Questi limiti sono stati stabiliti dall'ISP che gestisce questo proxy. "
+"Contatta il fornitore del servizio se cerchi maggiori informazioni."
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.p:28
 msgid "This means that some aspect of the ICAP communication failed."
@@ -1022,10 +1038,12 @@ msgid ""
 "This means the domain name you are trying to access apparently no longer "
 "exists on the machine you are requesting it from."
 msgstr ""
+"Questo significa che il nome di dominio che stai cercando di daggiungere non "
+"esiste più sul server da cui lo state richiedendo."
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.p:26
 msgid "This means:"
-msgstr ""
+msgstr "Questo significa:"
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:33
 msgid ""
@@ -1053,16 +1071,21 @@ msgid ""
 "This proxy limits your time online with a quota. Your time budget is now "
 "empty but will be refilled when the configured time period starts again."
 msgstr ""
+"Questo proxy impone un limite al tempo a tua disposizione online, che "
+"&egrave; terminato. Verr&agrave; automaticamente riempito al momento "
+"opportuno."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.p:26
 msgid ""
 "This request could not be forwarded to the origin server or to any parent "
 "caches."
 msgstr ""
+"Non è stato possibile inoltrare questa richiesta nè al server di origine nè "
+"a alcuna cache di livello superiore."
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.blockquote.p:23
 msgid "Time Quota Exceeded."
-msgstr ""
+msgstr "Tempo disponibile esaurito."
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:37
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:37
@@ -1089,23 +1112,25 @@ msgstr ""
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.blockquote.pre:23
 msgid "URI Host Conflict"
-msgstr ""
+msgstr "Conflitto nell'host della URI"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.detail:25
 msgid "Unable to decode issuer (CA) public key: %ssl_ca_name"
-msgstr "Unable to decode issuer (CA) public key: %ssl_ca_name"
+msgstr ""
+"Impossibile decodificare la chiave pubblica dell'emettitore (CA) %"
+"ssl_ca_name"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.descr:25
 msgid "Unable to decode issuer public key"
-msgstr "Unable to decode issuer public key"
+msgstr "Impossibile decodificare la chiave pubblica dell'emettitore"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE.descr:21
 msgid "Unable to decrypt CRL's signature"
-msgstr "Unable to decrypt CRL's signature"
+msgstr "Impossibile decifrare la firma della CRL"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE.descr:17
 msgid "Unable to decrypt certificate's signature"
-msgstr "Unable to decrypt certificate's signature"
+msgstr "Impossibile decifrare la firma del certificato"
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
@@ -1119,19 +1144,19 @@ msgstr "Non è possibile inoltrare la richiesta in questo momento."
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
-msgstr "Unable to get certificate CRL"
+msgstr "Impossibile ottenere la CRL per questo certificato"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.descr:9
 msgid "Unable to get issuer certificate"
-msgstr "Unable to get issuer certificate"
+msgstr "Non sono riuscito a ottenere il certificato dell'emettitore (CA)"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.descr:81
 msgid "Unable to get local issuer certificate"
-msgstr "Unable to get local issuer certificate"
+msgstr "Non sno riuscito a ottenere il certificato dell'emettitore locale"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE.descr:85
 msgid "Unable to verify the first certificate"
-msgstr "Unable to verify the first certificate"
+msgstr "Impossibile verificare il primo certificato"
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
@@ -1144,7 +1169,7 @@ msgstr "Metodo e protocollo della richiesta non sono supportati."
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
-msgstr "Unsupported certificate purpose"
+msgstr "Finalità del certificato non supportata"
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
 msgid ""
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:09+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 13:08+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: ja\n"
 "MIME-Version: 1.0\n"
@@ -97,31 +97,26 @@ msgstr ""
 msgid ""
 "<b>Invalid Request</b> error was encountered while trying to process the "
 "request:"
-msgstr ""
-"<b>不正なリクエスト</b>のエラーが以下のリクエストを処理しようとしている間に発"
-"生しました:"
+msgstr "<b>不正な要求</b>のエラーが以下のリクエストを処理しようとしている間に発生しました:"
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:20
 msgid ""
 "<b>Invalid Response</b> error was encountered while trying to process the "
 "request:"
-msgstr ""
-"<b>不正なリクエスト</b>のエラーが以下のリクエストを処理しようとしている間に発"
-"生しました:"
+msgstr "<b>不正な応答</b>のエラーが以下のリクエストの処理中に発生しました:"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
 #, fuzzy
 msgid ""
 "A Timeout occurred while waiting to read data from the network. The network "
 "or server may be down or congested. Please retry your request."
 msgstr ""
-"ネットワークからデータを読もうと待っている間にタイムアウトが発生しました。"
-"ネットワークもしくはサーバが稼働していないか、あるいは混雑しています。再度リ"
-"クエストしてください。"
+"ネットワークからデータの読み込み待ち中にタイムアウトとなりました。ネットワークやサーバが動作していないか、または混雑しています。再度リクエストしてみてく"
+"ださい。"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.h2:15
 msgid "A URL for the requested URN could not be retrieved"
-msgstr "リクエストされたURNのURLを調べられませんでした。"
+msgstr "要求されたURNのURLを取得できませんでした。"
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:26
 msgid ""
@@ -140,9 +135,7 @@ msgid ""
 "this time. Please contact your service provider if you feel this is "
 "incorrect."
 msgstr ""
-"設定されているアクセス制御の設定のため、今回はあなたからのリクエストは受けつ"
-"けられません。この設定が正しくないと思われる場合には、このサービスの提供者へ"
-"連絡してください。"
+"設定されたアクセス制御によって、現時点ではあなたによる要求は許可できません。この制限が誤っている思われる場合は、このサービスの提供者に連絡してください。"
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:31
 msgid "All configured parent caches may be currently unreachable."
@@ -152,18 +145,14 @@ msgstr ""
 msgid ""
 "An FTP authentication failure occurred while trying to retrieve the URL: <a "
 "href=\"%U\">%U</a>"
-msgstr ""
-"FTP認証の失敗が、以下のURLから情報を得ようとしている間に発生しました: <a "
-"href=\"%U\">%U</a>"
+msgstr "以下のURLから情報の取得しようとしている間に、FTPの認証に失敗しました: <a href=\"%U\">%U</a>"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.p:20
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.p:20
 msgid ""
 "An FTP protocol error occurred while trying to retrieve the URL: <a href=\"%U"
 "\">%U</a>"
-msgstr ""
-"FTPのプロトコル・エラーが、以下のURLから情報を得ようとしている間に発生しまし"
-"た: <a href=\"%U\">%U</a>"
+msgstr "以下のURLから情報を取得しようとしている間に、FTPでプロトコル上のエラーが発生しました: <a href=\"%U\">%U</a>"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:33
 msgid "An Illegal response was received from the ICAP server."
@@ -180,18 +169,14 @@ msgstr ""
 msgid ""
 "An error condition occurred while reading data from the network. Please "
 "retry your request."
-msgstr ""
-"ネットワークからデータを受信している間にエラーが発生しました。再度、リクエス"
-"トしてください。"
+msgstr "ネットワークからデータの読み込み待ち中にエラーが発生しました。再度リクエストしてみてください。"
 
 #: templates/ERR_WRITE_ERROR+html.body.div.p:28
 #, fuzzy
 msgid ""
 "An error condition occurred while writing to the network. Please retry your "
 "request."
-msgstr ""
-"ネットワークにデータを送信している間にエラーが発生しました。再度リクエストし"
-"てください。"
+msgstr "ネットワークへデータを送信中にエラーが発生しました。再度リクエストしてみてください。"
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
@@ -231,11 +216,11 @@ msgstr "キャッシュへのアクセスを拒否されました．"
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.blockquote.p:23
 msgid "Cache Manager Access Denied."
-msgstr "キャッシュマネジャへのアクセスを拒否されました．"
+msgstr "キャッシュマネージャへのアクセスを拒否されました．"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.blockquote.p:23
 msgid "Cannot Resolve URN"
-msgstr "URN の解決ができませんでした。"
+msgstr "URN を解決できませんでした。"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_CHAIN_TOO_LONG.descr:89
 msgid "Certificate chain too long"
@@ -272,15 +257,15 @@ msgstr "Certificate signature failure"
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
-msgstr "接続の存続時間が終了しました。"
+msgstr "接続の有効期間が切れました。"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Connection to %I failed."
-msgstr "%I への接続に失敗しました。"
+msgstr "%I に接続できませんでした。"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:32
 msgid "Content-Length missing for POST or PUT requests."
-msgstr "POSTまたはPUTのリクエストにContent-Lengthヘッダがありません。"
+msgstr "Content-Lengthヘッダが、POSTまたはPUTの要求に含まれていません。"
 
 #: templates/ERR_DIR_LISTING+html.body.div.h4:19
 msgid "Directory Content:"
@@ -343,15 +328,15 @@ msgstr "エラー"
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Access Denied"
-msgstr "エラー: キャッシュにアクセスを拒否されました。"
+msgstr "エラー: キャッシュへのアクセスを拒否されました。"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Manager Access Denied"
-msgstr "エラー: キャッシュ・マネージャにアクセスを拒否されました。"
+msgstr "エラー: キャッシュマネージャへのアクセスを拒否されました。"
 
 #: templates/ERR_FTP_PUT_ERROR+html.head.title:4
 msgid "ERROR: FTP upload failed"
-msgstr "エラー: FTP アップロードは失敗しました"
+msgstr "エラー: FTPでのアップロードに失敗しました。"
 
 #: templates/ERR_ACCESS_DENIED+html.head.title:4
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.head.title:4
@@ -414,7 +399,7 @@ msgstr "FTPは無効です。"
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Failed to establish a secure connection to %I"
-msgstr "%Iへの安全な接続を確立に失敗しました。"
+msgstr "%Iに安全な接続を確立できませんでした。"
 
 #: templates/ERR_FTP_PUT_CREATED+html.body.div.h2:15
 msgid "File created"
@@ -427,17 +412,17 @@ msgstr "ファイルを更新しました。"
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:26
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:26
 msgid "For Firefox browsers go to: <ul>"
-msgstr ""
+msgstr "Firefoxブラウザをご利用の方はこちらに: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:34
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:34
 msgid "For Internet Explorer browsers go to: <ul>"
-msgstr ""
+msgstr "ブラウザにInternet Exploreをご利用の方はこちらに: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:42
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:42
 msgid "For Opera browsers go to: <ul>"
-msgstr ""
+msgstr "ブラウザにOperaをご利用の方はこちらに: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
@@ -457,7 +442,7 @@ msgstr "Format error in certificate's notBefore field"
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
-msgstr "転送は拒否されました。"
+msgstr "転送を拒否されました。"
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.blockquote.p:23
 msgid "Gateway Proxy Failure"
@@ -523,7 +508,7 @@ msgstr "やあ、%Tの時点でURNには多くを期待しないでください
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.p:24
 #: templates/ERR_AGENT_WPAD+html.body.div.p:24
 msgid "How to find these settings in your browser:"
-msgstr ""
+msgstr "ご利用のブラウザを設定する方法の探し方:"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.blockquote.p:23
 msgid "ICAP protocol error."
@@ -533,24 +518,22 @@ msgstr "ICAPのプロトコル・エラーです。"
 msgid ""
 "If you are making a GET request, then the item you are trying to download is "
 "too large."
-msgstr ""
-"GETの要求をしていたなら、ダウンロードしようとしていた対象が大きすぎます。"
+msgstr "GETの要求をしていたなら、ダウンロードしようとしたサイズが大きすぎます。"
 
 #: templates/ERR_TOO_BIG+html.body.div.p:26
 msgid ""
 "If you are making a POST or PUT request, then the item you are trying to "
 "upload is too large."
-msgstr ""
-"POSTまたはPUTの要求をしていたなら、アップロードしていた対象が大きすぎます。"
+msgstr "POSTまたはPUTの要求をしていたなら、アップロードしようとしたサイズが大きすぎます。"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:33
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:33
 msgid "Illegal character in hostname; underscores are not allowed."
-msgstr "ホスト名に不正な文字が使われています: アンダースコアは使えません。"
+msgstr "ホスト名に不正な文字が含まれています: アンダースコア(下線)は使えません。"
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
 msgid "Illegal double-escape in the URL-Path"
-msgstr "不正な二重のエスケープがURLパスにあります。"
+msgstr "不正な二重のエスケープがURLパスに含まれています。"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
@@ -590,7 +573,7 @@ msgstr ""
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:28
 msgid "Missing or unknown request method."
-msgstr "要求の方法が抜けているか不明です。"
+msgstr "リクエスト・メソッドが欠けているか、不明なメソッドです。"
 
 #: templates/ERR_NO_RELAY+html.body.div.blockquote.p:23
 msgid "No Wais Relay"
@@ -645,7 +628,7 @@ msgstr "読み込みタイムアウト"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:31
 msgid "Request is too large."
-msgstr "リクエストが長すぎます。"
+msgstr "要求が大きすぎます。"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
@@ -680,11 +663,11 @@ msgstr ""
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
-msgstr ""
+msgstr "自動検出の設定を選択してください。"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:46
 msgid "Select Use Automatic proxy configuration"
-msgstr ""
+msgstr "proxyの自動構成を選択してください。"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
@@ -708,57 +691,51 @@ msgstr "ソケット作成に失敗"
 
 #: templates/ERR_INVALID_URL+html.body.div.p:26
 msgid "Some aspect of the requested URL is incorrect."
-msgstr "リクエストされたURLに不正な部分があります。"
+msgstr "指定されたURLに正しくない部分があります。"
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.p:28
 #: templates/ERR_CONFLICT_HOST+html.body.div.p:28
 #: templates/ERR_ICAP_FAILURE+html.body.div.p:30
 #: templates/ERR_INVALID_REQ+html.body.div.p:26
 #: templates/ERR_INVALID_URL+html.body.div.p:28
 msgid "Some possible problems are:"
-msgstr "ありそうな問題: "
+msgstr "考えられる問題: "
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:26
 msgid ""
 "Sorry, you are not currently allowed to request %U from this cache manager "
 "until you have authenticated yourself."
-msgstr ""
-"申し訳ありませんが、あなた自身の認証を済ませるまで、このキャッシュマネージャ"
-"に %U をリクエストすることは現在許可されていません。"
+msgstr "申し訳ありませんが、あなた自身を認証するまで、このキャッシュマネージャは %U の要求を許可しません。"
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.p:26
 msgid ""
 "Sorry, you are not currently allowed to request %U from this cache until you "
 "have authenticated yourself."
-msgstr ""
-"申し訳ありませんが、あなた自身の認証を済ませるまで、このキャッシュに %U をリ"
-"クエストすることは現在許可されていません。"
+msgstr "申し訳ありませんが、あなた自身を認証するまで、このキャッシュは %U の要求を許可しません。"
 
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.p:26
 msgid "Squid did not receive any data for this request."
-msgstr "このリクエストにに対してSquidは何もデータを受け取りませんでした。"
+msgstr "この要求に対して、Squidは何もデータを受け取りませんでした。"
 
 #: templates/ERR_UNSUP_REQ+html.body.div.p:26
 msgid ""
 "Squid does not support all request methods for all access protocols. For "
 "example, you can not POST a Gopher request."
 msgstr ""
-"Squidはすべてのプロトコルに対して、すべてのリクエスト方式をサポートしているわ"
-"けではありません。例えば、POSTをGopherのリクエストで行うことはできません。"
+"Squidはすべてのアクセス・プロトコルに対して、すべてのリクエストメソッドをサポートしているわけではありません。例えば、POSTをGopherのリクエ"
+"ストで行うことはできません。"
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.p:26
 msgid ""
 "Squid has terminated the request because it has exceeded the maximum "
 "connection lifetime."
-msgstr "最大の接続有効時間が過ぎたため、Squidはリクエストを終了しました。"
+msgstr "最大の接続の有効時間が過ぎたため、Squidは要求を終了しました。"
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.p:28
 msgid ""
 "Squid is unable to create a TCP socket, presumably due to excessive load. "
 "Please retry your request."
-msgstr ""
-"おそらく過大な負荷のため、SquidはTCPソケットを作成できませんでした。再度リク"
-"エストしてください。"
+msgstr "おそらく過大な負荷のため、SquidはTCPソケットを作成できませんでした。再度リクエストしてみてください。"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.p:22
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:22
@@ -778,23 +755,21 @@ msgstr "DNSサーバの応答:"
 
 #: templates/ERR_ESI+html.body.div.p:26
 msgid "The ESI processor returned:"
-msgstr ""
+msgstr "ESI処理からの応答:"
 
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.p:20
 msgid "The FTP server was too busy to retrieve the URL: <a href=\"%U\">%U</a>"
-msgstr ""
-"以下のURLを取得しようとしているとき、FTPサーバの負荷が高すぎました: <a href="
-"\"%U\">%U</a>"
+msgstr "以下のURLを取得しようとしましたが、FTPサーバの負荷が高すぎました: <a href=\"%U\">%U</a>"
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:26
 msgid ""
 "The HTTP Response message received from the contacted server could not be "
 "understood or was otherwise malformed. Please contact the site operator."
-msgstr ""
+msgstr "接続したサーバからのHTTP応答メッセージが解釈できないか、不正な形式です。サイトの運営担当者に連絡してください。"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:32
 msgid "The ICAP server is not reachable."
-msgstr "ICAPサーバに到達到達できません。"
+msgstr "ICAPサーバに到達できません。"
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:32
 msgid ""
@@ -842,24 +817,22 @@ msgstr "以下のURLを取得できませんでした: <a href=\"%U\">%U</a>"
 msgid ""
 "The following error was encountered while trying to retrieve the URL: <a "
 "href=\"%U\">%U</a>"
-msgstr ""
+msgstr "URL: <a href=\"%U\">%U</a> の取得中に以下のエラーが発生しました。"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:20
 msgid ""
 "The following error was encountered while trying to retrieve the URN: <a "
 "href=\"%U\">%U</a>"
-msgstr ""
+msgstr "URN: <a href=\"%U\">%U</a> の取得中に以下のエラーが発生しました。"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.p:28
 #, fuzzy
 msgid "The remote host or network may be down. Please try the request again."
-msgstr ""
-"接続先のホストもしくはネットワークが稼働していません．しばらく待ってからもう"
-"一度試して下さい．"
+msgstr "接続先のホストかネットワークが稼働していません。再び試してください。"
 
 #: templates/ERR_TOO_BIG+html.body.div.blockquote.p:23
 msgid "The request or reply is too large."
-msgstr "リクエストまたはリプライが大きすぎます。"
+msgstr "要求か応答が大きすぎます。"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h2:15
@@ -893,15 +866,15 @@ msgstr "リクエストまたはリプライが大きすぎます。"
 #: templates/ERR_WRITE_ERROR+html.body.div.h2:15
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.h2:15
 msgid "The requested URL could not be retrieved"
-msgstr "リクエストされた URL は取得できませんでした"
+msgstr "指定された URL を取得できませんでした"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.p:27
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:27
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:27
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.p:27
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.p:28
 msgid "The server responded with:"
-msgstr ""
+msgstr "サーバの応答: "
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.p:26
 #: templates/ERR_ICAP_FAILURE+html.body.div.p:26
@@ -924,7 +897,7 @@ msgstr ""
 msgid ""
 "There is no WAIS Relay host defined for this Cache! Yell at the "
 "administrator."
-msgstr "WAIS リレー用ホストが定義されていません! 管理者に連絡してください．"
+msgstr "WAISの中継に使用するホストがキャッシュに設定されていません! 管理者に連絡してください．"
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:27
 #: templates/ERR_TOO_BIG+html.body.div.p:28
@@ -934,25 +907,23 @@ msgid ""
 "operates this cache. Please contact them directly if you feel this is an "
 "error."
 msgstr ""
-"これらの制限は、このキャッシュの運用者によって課されています。これがエラーだ"
-"と感じるときは直接運用者に連絡して下さい。"
+"これらの制限は、このキャッシュを運用しているインターネット・サービスの提供者が課しています。これが間違いだと感じるときは、直接サービスの提供者に連絡して"
+"下さい。"
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.p:26
 msgid "This Squid does not accept the HTTP version you are attempting to use."
-msgstr ""
+msgstr "使用しようとされているHTTPのバージョンをSquidは受け付けません。"
 
 #: templates/ERR_FTP_DISABLED+html.body.div.p:26
 msgid "This cache does not support FTP."
-msgstr "キャッシュは FTP をサポートしていません．"
+msgstr "このキャッシュは FTP をサポートしていません．"
 
 #: templates/ERR_SHUTTING_DOWN+html.body.div.p:22
 #, fuzzy
 msgid ""
 "This cache is in the process of shutting down and can not service your "
 "request at this time. Please retry your request again soon."
-msgstr ""
-"このキャッシュは稼働停止の処理に入っていて、現在あなたのリクエストへのサービ"
-"スを提供できません。後で再度リクエストしてください．"
+msgstr "このキャッシュは稼働停止の処理の段階で、現在あなたの要求に応えることができません。後で、再び試してください。"
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.p:26
 #, fuzzy
@@ -961,9 +932,8 @@ msgid ""
 "sibling relationship. Perhaps the client at %i is a cache which has been "
 "misconfigured."
 msgstr ""
-"キャッシュ間における関係を強制的に兄弟関係となるようにしているため，キャッ"
-"シュはあなたのリクエストを転送できませんでした．%i のキャッシュが誤った設定と"
-"なっているかもしれません．"
+"キャッシュ間を強制的に兄弟関係となるようにしているため、キャッシュはあなたの要求を転送できませんでした。おそらく、%i "
+"のクライアントは、謝った設定のキャッシュでしょう。"
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:28
 #, fuzzy
@@ -976,29 +946,30 @@ msgstr ""
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.p:28
 msgid "This means that some aspect of the ICAP communication failed."
-msgstr ""
+msgstr "これはICAPの通信で何か失敗した面があったことを意味しています。"
 
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.p:32
 msgid ""
 "This means that the FTP server may not have permission or space to store the "
 "file. Check the path, permissions, diskspace and try again."
 msgstr ""
+"これはFTPサーバにアクセス権がないか、ファイルを保存する領域が足りなかったことを意味しています。パス、アクセス権、ディスクの空き容量を確認して、再び試"
+"してください。"
 
 # 'address' in this text means the domain name.
 #: templates/ERR_DNS_FAIL+html.body.div.p:31
 #, fuzzy
 msgid ""
 "This means that the cache was not able to resolve the hostname presented in "
 "the URL. Check if the address is correct."
-msgstr ""
-"この意味は次の通りですキャッシュは URL 中のホスト名から IP address を調べるこ"
-"とができませんでした． アドレスが間違っていないか確認してください．"
+msgstr "これはURLで示されているホスト名を、キャッシュがIPアドレスに解決できなかったことを意味します。URLが正しいかどうか確認してください。"
 
 #: templates/ERR_ESI+html.body.div.p:31
 msgid ""
 "This means that the surrogate was not able to process the ESI template. "
 "Please report this error to the webmaster."
 msgstr ""
+"これはESIのテンプレートの処理を代理サーバで行えなかったことを意味します。このエラーはサイトの管理者(webmaster)に報告してください。"
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.p:26
 msgid ""
@@ -1017,9 +988,8 @@ msgid ""
 "comply with RFC 1738). If this is the cause, then the file can be found at "
 "<a href=\"%B\">%B</a>."
 msgstr ""
-"これは(RFC 1738に従っていない)絶対パスを含んだFTPのURLによる可能性がありま"
-"す。その場合に該当するなら、ファイルは<a href=\"%B\">%B</a>に見つかるかもしれ"
-"ません。"
+"これは(RFC 1738に従っていない)絶対パスを含んだFTPのURLによる可能性があります。もしそうなら、ファイルは<a href=\"%B\">%"
+"B</a>に見つかるかもしれません。"
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.p:28
 msgid ""
@@ -1028,6 +998,8 @@ msgid ""
 "host does not support secure connections, or the proxy is not satisfied with "
 "the host security credentials."
 msgstr ""
+"このプロキシーと接続先のホストは互いに受け入れられる、あなたの要求を扱うためのセキュリティの設定を得ることができませんでした。接続先のホストが安全な接続"
+"をサポートしていないか、プロキシーは接続先ホストが要求する証明書を満たせなかったといったことが考えられます．"
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:26
 msgid ""
@@ -1049,19 +1021,19 @@ msgstr ""
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:37
 msgid ""
 "Tools -&gt; Internet Options -&gt; Connection -&gt; LAN Settings -&gt;Proxy"
-msgstr ""
+msgstr "ツール -&gt; インターネット オプション -&gt; 接続 -&gt; LAN の設定 -&gt; プロキシ サーバー"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:29
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:29
 msgid ""
 "Tools -&gt; Options -&gt; Advanced -&gt; Network -&gt; Connection Settings"
-msgstr ""
+msgstr "ツール -&gt; オプション -&gt; 詳細 -&gt; ネットワーク -&gt; 接続設定"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:45
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:45
 msgid ""
 "Tools -&gt; Preferences -&gt; Advanced -&gt; Network -&gt; Proxy Servers"
-msgstr ""
+msgstr "ツール -&gt; 設定 -&gt; 詳細 -&gt; ネットワーク -&gt; プロキシサーバー"
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.blockquote.pre:23
 msgid "URI Host Conflict"
@@ -1085,11 +1057,11 @@ msgstr "Unable to decrypt certificate's signature"
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
-msgstr "以下のホスト名の IP address を調べられません．<q>%H</q>"
+msgstr "ホスト名 <q>%H</q> の IPアドレスがわかりません。"
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.blockquote.p:23
 msgid "Unable to forward this request at this time."
-msgstr "現在，リクエストの転送はできません．"
+msgstr "現在要求を送信できません。"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
@@ -1110,11 +1082,11 @@ msgstr "Unable to verify the first certificate"
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
 msgid "Unsupported HTTP version"
-msgstr ""
+msgstr "サポートしていないHTTPのバージョンです。"
 
 #: templates/ERR_UNSUP_REQ+html.body.div.blockquote.p:23
 msgid "Unsupported Request Method and Protocol"
-msgstr "サポートされていないリクエスト/プロトコルです．"
+msgstr "サポートしていないリクエストメソッドとプロトコルです。"
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
@@ -1124,20 +1096,18 @@ msgstr "Unsupported certificate purpose"
 msgid ""
 "Valid document was not found in the cache and <q>only-if-cached</q> "
 "directive was specified."
-msgstr ""
-"<q>only-if-cached</q> の指定がありましたが，その文書がキャッシュに存在してい"
-"ません．"
+msgstr "<q>only-if-cached</q>を指定されていましたが、有効な文書はキャッシュに存在していませんでした。"
 
 #: templates/ERR_AGENT_CONFIGURE+html.head.title:4
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.h2:15
 #: templates/ERR_AGENT_WPAD+html.head.title:4
 #: templates/ERR_AGENT_WPAD+html.body.div.h2:15
 msgid "Web Browser Configuration"
-msgstr ""
+msgstr "Webブラウザの設定"
 
 #: templates/ERR_WRITE_ERROR+html.body.div.blockquote.p:23
 msgid "Write Error"
-msgstr "送信処理中にエラーが発生しました．"
+msgstr "書き込み中にエラーが発生しました。"
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.p:26
 msgid ""
@@ -1204,7 +1174,7 @@ msgstr ""
 
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.blockquote.p:23
 msgid "Zero Sized Reply"
-msgstr "サイズがゼロの応答"
+msgstr "中身がありません．"
 
 #~ msgid "ERROR: The requested URN not be retrieved"
 #~ msgstr "エラー: 要求されたURNからデータを取り出せませんでした。"
@@ -1224,10 +1194,8 @@ msgid ""
 "origin servers, and all configured parent caches are currently "
 "unreachable."
 msgstr ""
-"あなたのリクエストは，元のサーバもしくは他の親キャッシュサーバへ転送できま"
-"せん．これは次の理由により発生したと考えられますキャッシュ管理者が元のサー"
-"バに直接接続しないように設定した． 設定されている全ての親キャッシュサーバ"
-"へ現在到達できない．"
+"あなたの要求を起源のサーバや、他のどの親キャッシュサーバに送ることができません。これはキャッシュの管理者が目的のサーバに直接接続しないように設定している"
+"か、設定されているすべての親のキャッシュサーバに現在到達できないことが理由として考えられます。"
 
 #~ msgid "While trying to PUT the following URL: <a href=\"%U\">%U</a>"
 #~ msgstr "以下の URL を PUT しようとした際に: <a href=\"%U\">%U</a>"
@@ -41,5 +41,5 @@ TRANSLATE_LANGUAGES= \
     uk.lang \
     uz.lang \
     vi.lang \
-    zh-cn.lang \
-    zh-tw.lang 
+    zh-hans.lang \
+    zh-hant.lang 
@@ -8,15 +8,16 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2009-06-05 23:33+0000\n"
-"Last-Translator: Mohamad Faizul bin Zulkifli <piju@mylinux.net.my>\n"
+"PO-Revision-Date: 2013-10-31 13:40+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Malay <ms@li.org>\n"
 "Language: ms\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+"X-Generator: Pootle 2.1.6\n"
 "X-Launchpad-Export-Date: 2009-06-06 12:04+0000\n"
-"X-Generator: Launchpad (build Unknown)\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -286,9 +287,8 @@ msgid "Directory: %U"
 msgstr "Direktori: %U"
 
 #: templates/ERR_DIR_LISTING+html.body.div.h2:14
-#, fuzzy
 msgid "Directory: <a href=\"%U\">%U</a>/"
-msgstr "Direktori: <a href=\"/\">%U</a>/"
+msgstr "Direktori: <a href=\"%U\">%U</a>/"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h1:14
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h1:14
@@ -745,7 +745,7 @@ msgstr "Subject issuer mismatch"
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
-msgstr ""
+msgstr "Pelayan DNS hantar :"
 
 #: templates/ERR_ESI+html.body.div.p:26
 msgid "The ESI processor returned:"
@@ -8,7 +8,7 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2010-08-17 06:55+0200\n"
+"PO-Revision-Date: 2013-10-31 13:29+0200\n"
 "Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Dutch <nl@li.org>\n"
 "Language: nl\n"
@@ -388,9 +388,8 @@ msgid "ERROR: The requested URL could not be retrieved"
 msgstr "FOUT: De gevraagde URL kon niet worden opgehaald"
 
 #: templates/ERR_URN_RESOLVE+html.head.title:4
-#, fuzzy
 msgid "ERROR: The requested URN could not be retrieved"
-msgstr "FOUT: De gevraagde URL kon niet worden opgehaald"
+msgstr "FOUT: De gevraagde URN kon niet worden opgehaald"
 
 #: templates/ERR_ESI+html.body.div.blockquote.p:23
 msgid "ESI Processing failed."
@@ -400,12 +399,12 @@ msgstr "ESI processing mislukt."
 #: templates/ERR_FTP_PUT_MODIFIED+html.head.title:4
 #, fuzzy
 msgid "FTP PUT Successful."
-msgstr "FTP PUT Succesvol: Bestand aangemaakt"
+msgstr "FTP PUT succesvol."
 
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.h2:15
 #, fuzzy
 msgid "FTP PUT upload failed"
-msgstr "FTP PUT/upload mislukt"
+msgstr "FTP PUT upload mislukt"
 
 #: templates/ERR_FTP_DISABLED+html.body.div.blockquote.p:23
 msgid "FTP is Disabled"
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:10+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 14:34+0200\n"
+"Last-Translator: Amos <squid3@treenet.co.nz>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: pt\n"
 "MIME-Version: 1.0\n"
@@ -90,19 +90,23 @@ msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
-msgstr ""
+msgstr "<a href=\"../\">Diretório Pai</a> (<a href=\"/\">Diretório Raiz</a>)"
 
 #: templates/ERR_INVALID_REQ+html.body.div.p:20
 msgid ""
 "<b>Invalid Request</b> error was encountered while trying to process the "
 "request:"
 msgstr ""
+"Erro de <b>Requisição Inválida</b> foi encontrado enquanto tentava proceder "
+"a requisição."
 
 #: templates/ERR_INVALID_RESP+html.body.div.p:20
 msgid ""
 "<b>Invalid Response</b> error was encountered while trying to process the "
 "request:"
 msgstr ""
+"Erro de <b>Resposta Inválida</b> foi encontrado enquanto tentava proceder a "
+"requisição."
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
 #, fuzzy
@@ -122,6 +126,8 @@ msgid ""
 "A non-recoverable internal failure or configuration problem prevents this "
 "request from being completed."
 msgstr ""
+"Uma falha não recuperável interna ou problema de configuração impede essa "
+"solicitação seja concluída."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.blockquote.p:23
 msgid "Access Denied."
@@ -161,7 +167,7 @@ msgstr ""
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:33
 msgid "An Illegal response was received from the ICAP server."
-msgstr ""
+msgstr "Uma resposta ilegal foi recebida do servidor ICAP."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:30
 msgid ""
@@ -270,27 +276,27 @@ msgstr "O tempo limite de conexão expirou"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Connection to %I failed."
-msgstr ""
+msgstr "Conexão com %I falhou."
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:32
 msgid "Content-Length missing for POST or PUT requests."
 msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.h4:19
 msgid "Directory Content:"
-msgstr ""
+msgstr "Diretório Conteúdo:"
 
 #: templates/ERR_DIR_LISTING+html.body.div.table:-1
 msgid "Directory Listing"
 msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.head.title:4
 msgid "Directory: %U"
-msgstr ""
+msgstr "Diretório: %U"
 
 #: templates/ERR_DIR_LISTING+html.body.div.h2:14
 msgid "Directory: <a href=\"%U\">%U</a>/"
-msgstr ""
+msgstr "Diretório: <a href=\"%U\">%U</a>/"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h1:14
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h1:14
@@ -381,81 +387,76 @@ msgid "ERROR: The requested URL could not be retrieved"
 msgstr "ERRO: A URL solicitada não pode ser recuperada"
 
 #: templates/ERR_URN_RESOLVE+html.head.title:4
-#, fuzzy
 msgid "ERROR: The requested URN could not be retrieved"
-msgstr "ERRO: A URL solicitada não pode ser recuperada"
+msgstr "ERRO: A URN solicitada não pode ser recuperada"
 
 #: templates/ERR_ESI+html.body.div.blockquote.p:23
 msgid "ESI Processing failed."
-msgstr ""
+msgstr "O Processamento do ESI falhou."
 
 #: templates/ERR_FTP_PUT_CREATED+html.head.title:4
 #: templates/ERR_FTP_PUT_MODIFIED+html.head.title:4
-#, fuzzy
 msgid "FTP PUT Successful."
-msgstr "Sucesso no FTP PUT: Arquivo criado"
+msgstr "FTP PUT obteve sucesso."
 
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.h2:15
-#, fuzzy
 msgid "FTP PUT upload failed"
-msgstr "FTP PUT/erro na carga"
+msgstr "O upload do FTP PUT falhou."
 
 #: templates/ERR_FTP_DISABLED+html.body.div.blockquote.p:23
 msgid "FTP is Disabled"
 msgstr "FTP desabilitado"
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.blockquote.p:23
 msgid "Failed to establish a secure connection to %I"
-msgstr ""
+msgstr "Falha ao estabelecer uma conexão segura com %I"
 
 #: templates/ERR_FTP_PUT_CREATED+html.body.div.h2:15
-#, fuzzy
 msgid "File created"
-msgstr "Arquivo atualizado"
+msgstr "Criado arquivo"
 
 #: templates/ERR_FTP_PUT_MODIFIED+html.body.div.h2:15
-#, fuzzy
 msgid "File updated"
 msgstr "Arquivo atualizado"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:26
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:26
 msgid "For Firefox browsers go to: <ul>"
-msgstr ""
+msgstr "Para o navegador FireFox va para: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:34
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:34
 msgid "For Internet Explorer browsers go to: <ul>"
-msgstr ""
+msgstr "Para o navegador Internet Explorer va para: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:42
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:42
 msgid "For Opera browsers go to: <ul>"
-msgstr ""
+msgstr "Para o navegador Opera va para: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
-msgstr "Format error in CRL's lastUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD.descr:65
 msgid "Format error in CRL's nextUpdate field"
-msgstr "Format error in CRL's nextUpdate field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Format error in certificate's notAfter field"
+msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
-msgstr "Format error in certificate's notBefore field"
+msgstr ""
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
 msgstr "Expedição proibida."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.blockquote.p:23
 msgid "Gateway Proxy Failure"
-msgstr ""
+msgstr "O Gateway do Proxy Falhou."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:34
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:35
@@ -499,12 +500,14 @@ msgstr ""
 #: templates/ERR_WRITE_ERROR+html.body.div.p:36
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.p:34
 msgid "Generated %T by %h (%s)"
-msgstr ""
+msgstr "Gerado %T por %h (%s)"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:34
 msgid ""
 "HTTP/1.1 <q>Expect:</q> feature is being asked from an HTTP/1.0 software."
 msgstr ""
+"HTTP/1.1 <q>Esperar:</q> recurso está sendo feita a partir de um programa "
+"HTTP/1.0."
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.descr:1
 msgid "Handshake with SSL server failed"
@@ -517,20 +520,19 @@ msgstr "Não espere muita coisa de URNS em %T :-)"
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.p:24
 #: templates/ERR_AGENT_WPAD+html.body.div.p:24
 msgid "How to find these settings in your browser:"
-msgstr ""
+msgstr "Como encontrar essas configurações em seu navegador:"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.blockquote.p:23
 msgid "ICAP protocol error."
-msgstr ""
+msgstr "Erro do protocolo ICAP."
 
 #: templates/ERR_TOO_BIG+html.body.div.p:27
-#, fuzzy
 msgid ""
 "If you are making a GET request, then the item you are trying to download is "
 "too large."
 msgstr ""
-"Se você estiver fazendo uma requisição GET, então o corpo da resposta (o que "
-"você está tentando baixar) é muito grande."
+"Se você estiver fazendo uma requisição GET, então o arquivo que esta "
+"tentando baixar é muito grande."
 
 #: templates/ERR_TOO_BIG+html.body.div.p:26
 msgid ""
@@ -547,7 +549,7 @@ msgstr "Hostname com caracter inválido; não são permitidos underscores."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
 msgid "Illegal double-escape in the URL-Path"
-msgstr ""
+msgstr "Escape-duplo Ilegal no URL-Path"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
@@ -591,7 +593,6 @@ msgid "Missing or unknown request method."
 msgstr "Método desconhecido ou faltando (GET, POST)"
 
 #: templates/ERR_NO_RELAY+html.body.div.blockquote.p:23
-#, fuzzy
 msgid "No Wais Relay"
 msgstr "Sem Wais"
 
@@ -632,11 +633,11 @@ msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:23
 msgid "Precondition Failed."
-msgstr ""
+msgstr "Falha na Pré-condição."
 
 #: templates/ERR_READ_ERROR+html.body.div.blockquote.p:23
 msgid "Read Error"
-msgstr "Erro de leitura"
+msgstr "Erro de Leitura"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.blockquote.p:23
 msgid "Read Timeout"
@@ -679,11 +680,11 @@ msgstr ""
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
-msgstr ""
+msgstr "Selecionar automaticamente a detecção de configurações."
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:46
 msgid "Select Use Automatic proxy configuration"
-msgstr ""
+msgstr "Selecione configuração automática do Proxy."
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
@@ -1206,7 +1207,7 @@ msgstr ""
 
 #: templates/ERR_ESI+html.body.div.p:33
 msgid "Your webmaster is <a href=\"mailto:%w\">%w</a>."
-msgstr ""
+msgstr "Seu webmaster é <a href=\"mailto:%w\">%w</a>."
 
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.blockquote.p:23
 msgid "Zero Sized Reply"
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2010-03-11 18:56+0200\n"
-"Last-Translator: Bratislav <batailic@gmail.com>\n"
+"PO-Revision-Date: 2013-10-31 13:15+0200\n"
+"Last-Translator: Francesco <kinkie@squid-cache.org>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: sr_LT\n"
 "MIME-Version: 1.0\n"
@@ -125,6 +125,8 @@ msgid ""
 "A non-recoverable internal failure or configuration problem prevents this "
 "request from being completed."
 msgstr ""
+"Interna greška ili problem sa konfiguracijom ne dozvoljava da se zahtev "
+"obradi."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.blockquote.p:23
 msgid "Access Denied."
@@ -190,7 +192,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Application verification failure"
+msgstr "Greška verifikacije aplikacije"
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:10+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 13:15+0200\n"
+"Last-Translator: Francesco <kinkie@squid-cache.org>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "Language: sv\n"
 "MIME-Version: 1.0\n"
@@ -90,7 +90,7 @@ msgstr ""
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
-msgstr ""
+msgstr "<a href=\"../\">Föregående katalog</a> (<a href=\"/\">Rootkatalog</a>)"
 
 #: templates/ERR_INVALID_REQ+html.body.div.p:20
 msgid ""
@@ -284,11 +284,11 @@ msgstr "Content-Length saknas i POST eller PUT beg&auml;ran."
 
 #: templates/ERR_DIR_LISTING+html.body.div.h4:19
 msgid "Directory Content:"
-msgstr "Kataloginnehåll:"
+msgstr "Mappinnehåll:"
 
 #: templates/ERR_DIR_LISTING+html.body.div.table:-1
 msgid "Directory Listing"
-msgstr ""
+msgstr "Mappinnehåll"
 
 #: templates/ERR_DIR_LISTING+html.head.title:4
 msgid "Directory: %U"
@@ -959,7 +959,7 @@ msgstr ""
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.p:26
 msgid "This Squid does not accept the HTTP version you are attempting to use."
-msgstr "Squid fungerar inte med den versionen av HTTP som du försöker använda"
+msgstr "Denna Squid accepterar inte den HTTP version du försöker använda."
 
 #: templates/ERR_FTP_DISABLED+html.body.div.p:26
 msgid "This cache does not support FTP."
@@ -1,3 +1,7 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
@@ -130,6 +134,90 @@ name: X509_V_ERR_KEYUSAGE_NO_CERTSIGN
 detail: "%ssl_error_descr: %ssl_subject"
 descr: "Key usage does not include certificate signing"
 
+name: X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unable to get CRL issuer certificate"
+
+name: X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unhandled critical extension"
+
+name: X509_V_ERR_KEYUSAGE_NO_CRL_SIGN
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "key usage does not include CRL signing"
+
+name: X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unhandled critical CRL extension"
+
+name: X509_V_ERR_INVALID_NON_CA
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "invalid non-CA certificate (has CA markings)"
+
+name: X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "proxy path length constraint exceeded"
+
+name: X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "key usage does not include digital signature"
+
+name: X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "proxy certificates not allowed, please set the appropriate flag"
+
+name: X509_V_ERR_INVALID_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "invalid or inconsistent certificate extension"
+
+name: X509_V_ERR_INVALID_POLICY_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "invalid or inconsistent certificate policy extension"
+
+name: X509_V_ERR_NO_EXPLICIT_POLICY
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "no explicit policy"
+
+name: X509_V_ERR_DIFFERENT_CRL_SCOPE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Different CRL scope"
+
+name: X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Unsupported extension feature"
+
+name: X509_V_ERR_UNNESTED_RESOURCE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "RFC 3779 resource not subset of parent's resources"
+
+name: X509_V_ERR_PERMITTED_VIOLATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "permitted subtree violation"
+
+name: X509_V_ERR_EXCLUDED_VIOLATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "excluded subtree violation"
+
+name: X509_V_ERR_SUBTREE_MINMAX
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "name constraints minimum and maximum not supported"
+
+name: X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unsupported name constraint type"
+
+name: X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unsupported or invalid name constraint syntax"
+
+name: X509_V_ERR_UNSUPPORTED_NAME_SYNTAX
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unsupported or invalid name syntax"
+
+name: X509_V_ERR_CRL_PATH_VALIDATION_ERROR
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "CRL path validation error"
+
 name: X509_V_ERR_APPLICATION_VERIFICATION
 detail: "%ssl_error_descr: %ssl_subject"
 descr: "Application verification failure"
@@ -3,8 +3,8 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:10+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 13:11+0200\n"
+"Last-Translator: Francesco <kinkie@squid-cache.org>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "Language: tr\n"
 "MIME-Version: 1.0\n"
@@ -158,7 +158,7 @@ msgid ""
 "\">%U</a>"
 msgstr ""
 "URL: <a href=\"%U\">%U</a> adresine erişilirken bir iletişim hatası meydana "
-"geldi."
+"geldi"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.ul.li.p:33
 msgid "An Illegal response was received from the ICAP server."
@@ -8,8 +8,8 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-15 08:10+0200\n"
-"Last-Translator: Anonymous Pootle User\n"
+"PO-Revision-Date: 2013-10-31 12:26+0200\n"
+"Last-Translator: Francesco <kinkie@squid-cache.org>\n"
 "Language-Team: Ukrainian <uk@li.org>\n"
 "Language: uk\n"
 "MIME-Version: 1.0\n"
@@ -26,31 +26,34 @@ msgstr ""
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:30
 msgid "%F"
-msgstr ""
+msgstr "%F"
 
 #: templates/ERR_INVALID_REQ+html.body.div.blockquote.pre:23
 #: templates/ERR_INVALID_RESP+html.body.div.blockquote.pre:23
 msgid "%R"
-msgstr ""
+msgstr "%R"
 
 #: templates/ERR_ESI+html.body.div.blockquote.pre:28
+#, fuzzy
 msgid "%Z"
-msgstr ""
+msgstr "%Z"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_PUT_ERROR+html.body.div.blockquote.pre:24
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:25
+#, fuzzy
 msgid "%f"
-msgstr ""
+msgstr "%f"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.blockquote.pre:30
 #: templates/ERR_FTP_UNAVAILABLE+html.body.div.blockquote.pre:31
+#, fuzzy
 msgid "%g"
-msgstr ""
+msgstr "%g"
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.detail:69
 msgid "%ssl_error_descr"
@@ -92,8 +95,9 @@ msgstr "%ssl_error_descr: %ssl_subject"
 
 #: templates/ERR_DIR_LISTING+html.body.div.blockquote.pre:22
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.pre:28
+#, fuzzy
 msgid "%z"
-msgstr ""
+msgstr "%z"
 
 #: templates/ERR_DIR_LISTING+html.body.div.table.tr.th:28
 msgid "<a href=\"../\">Parent Directory</a> (<a href=\"/\">Root Directory</a>)"
@@ -114,7 +118,6 @@ msgid ""
 msgstr "<b>Невірна відповідь</b> виникла при обробці запиту:"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
-#, fuzzy
 msgid ""
 "A Timeout occurred while waiting to read data from the network. The network "
 "or server may be down or congested. Please retry your request."
@@ -137,15 +140,14 @@ msgid "Access Denied."
 msgstr "Доступ заборонено"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:26
-#, fuzzy
 msgid ""
 "Access control configuration prevents your request from being allowed at "
 "this time. Please contact your service provider if you feel this is "
 "incorrect."
 msgstr ""
 "Налаштування контролю доступу забороняє обробку Вашого запиту в даний час. "
-"Будь-ласка, поспілкуйтесь з Вашим постачальником Інтернет послуг, якщо Ви "
-"вважаєте це неправильним."
+"Будь-ласка, зв'яжіться з Вашим постачальником Інтернет послуг, якщо Ви "
+"вважаєте, що це неправильно."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:31
 msgid "All configured parent caches may be currently unreachable."
@@ -177,15 +179,13 @@ msgid ""
 msgstr ""
 
 #: templates/ERR_READ_ERROR+html.body.div.p:28
-#, fuzzy
 msgid ""
 "An error condition occurred while reading data from the network. Please "
 "retry your request."
 msgstr ""
-"Під час читання даних з мережі сталася помилка. Будь-ласка, повторіть запит."
+"При читанні даних з мережі сталася помилка. Будь-ласка, повторіть запит."
 
 #: templates/ERR_WRITE_ERROR+html.body.div.p:28
-#, fuzzy
 msgid ""
 "An error condition occurred while writing to the network. Please retry your "
 "request."
@@ -425,17 +425,17 @@ msgstr "Файл поновлено"
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:26
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:26
 msgid "For Firefox browsers go to: <ul>"
-msgstr ""
+msgstr "Для браузерів Firefox перейдіть до: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:34
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:34
 msgid "For Internet Explorer browsers go to: <ul>"
-msgstr ""
+msgstr "Для браузерів Internet Explorer перейдіть до: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:42
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:42
 msgid "For Opera browsers go to: <ul>"
-msgstr ""
+msgstr "Для браузерів Opera перейдіть до: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
@@ -509,20 +509,21 @@ msgstr "Згенеровано %T на %h (%s)"
 msgid ""
 "HTTP/1.1 <q>Expect:</q> feature is being asked from an HTTP/1.0 software."
 msgstr ""
+"Запит з використанням заголовку <q>Expect:</q> протоколу HTTP/1.1 здійснено "
+"до програмного забезпечення яке підтримує протокол HTTP/1.0."
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.descr:1
 msgid "Handshake with SSL server failed"
 msgstr ""
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:26
-#, fuzzy
 msgid "Hey, don't expect too much from URNs on %T :)"
-msgstr "Не варто очікувати надто багато від URN'ів на %T."
+msgstr "Не очікуйте надто багато від URN'ів на %T."
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.p:24
 #: templates/ERR_AGENT_WPAD+html.body.div.p:24
 msgid "How to find these settings in your browser:"
-msgstr ""
+msgstr "Як знайти ці налаштування у Вашому браузері:"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.blockquote.p:23
 msgid "ICAP protocol error."
@@ -549,9 +550,8 @@ msgid "Illegal character in hostname; underscores are not allowed."
 msgstr "Неприпустимий символ в імені сервера; символ підкреслення заборонено."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
-#, fuzzy
 msgid "Illegal double-escape in the URL-Path"
-msgstr "В шляху URL присутній зайвий символ <q>/</q>;"
+msgstr ""
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
@@ -682,11 +682,11 @@ msgstr ""
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
-msgstr ""
+msgstr "Виберіть \"Автоматичне визначення параметрів\""
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:46
 msgid "Select Use Automatic proxy configuration"
-msgstr ""
+msgstr "Виберіть \" Автоматичне налаштування проксі\" "
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
@@ -854,10 +854,9 @@ msgid ""
 msgstr "При отриманні URN: <a href=\"%U\">%U</a> виникла помилка."
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.p:28
-#, fuzzy
 msgid "The remote host or network may be down. Please try the request again."
 msgstr ""
-"Віддалений вузел чи мережа не відповідають.  Будь-ласка, повторіть запит."
+"Віддалений вузел чи мережа можливо недоступні.  Будь-ласка, повторіть запит."
 
 #: templates/ERR_TOO_BIG+html.body.div.blockquote.p:23
 msgid "The request or reply is too large."
@@ -922,23 +921,21 @@ msgid ""
 msgstr ""
 
 #: templates/ERR_NO_RELAY+html.body.div.p:26
-#, fuzzy
 msgid ""
 "There is no WAIS Relay host defined for this Cache! Yell at the "
 "administrator."
 msgstr ""
-"Для даного кешу не визначено WAIS Relay вузол. Покричіть на Адміністратора."
+"Для даного кешу не визначений WAIS Relay вузел! Поскаржіться адміністратору."
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:27
 #: templates/ERR_TOO_BIG+html.body.div.p:28
-#, fuzzy
 msgid ""
 "These limits have been established by the Internet Service Provider who "
 "operates this cache. Please contact them directly if you feel this is an "
 "error."
 msgstr ""
-"Ці ліміти встановлено Інтернет постачальником, котрий керує даним кешом. "
-"Будь-ласка, зв'яжіться з ним, якщо Ви вважаєте дане повідомлення помилкою."
+"Ці ліміти встановлені Інтернет провайдером, який керує даним кешом. "
+"Будь-ласка, зв'яжіться безпосередньо з ним, якщо Ви вважаєте це помилкою."
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.p:26
 msgid "This Squid does not accept the HTTP version you are attempting to use."
@@ -949,23 +946,21 @@ msgid "This cache does not support FTP."
 msgstr "FTP відключено"
 
 #: templates/ERR_SHUTTING_DOWN+html.body.div.p:22
-#, fuzzy
 msgid ""
 "This cache is in the process of shutting down and can not service your "
 "request at this time. Please retry your request again soon."
 msgstr ""
-"Зараз кеш в процесі припинення роботи і не може виконати Ваш запит. Будь-"
-"ласка, повторіть запит через деякий час."
+"Зараз кеш в процесі припинення роботи і не може виконати Ваш запит в даний "
+"час. Будь-ласка, повторіть запит пізніше."
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.p:26
-#, fuzzy
 msgid ""
 "This cache will not forward your request because it is trying to enforce a "
 "sibling relationship. Perhaps the client at %i is a cache which has been "
 "misconfigured."
 msgstr ""
-"Цей кеш не перешле Ваш запит, через намагання встановити родинні "
-"взаємовідносини. Скоріш за все клієнт %i - невірно сконфігурований кеш."
+"Цей кеш не перешле Ваш запит, через намагання встановити родинні відносини. "
+"Скоріш за все клієнт %i - невірно сконфігурований кеш."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:28
 #, fuzzy
@@ -1012,18 +1007,17 @@ msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.p:26
 msgid "This means:"
-msgstr ""
+msgstr "Це означає:"
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:33
-#, fuzzy
 msgid ""
 "This might be caused by an FTP URL with an absolute path (which does not "
 "comply with RFC 1738). If this is the cause, then the file can be found at "
 "<a href=\"%B\">%B</a>."
 msgstr ""
-"Це може бути викликано FTP адресою з абсолютним URL шляхом (який не "
-"відповідає стандарту RFC 1738). В такому випадку, файл може бути знайдений "
-"за адресою <a href=\"%B\">%B</a>."
+"Це може бути викликано FTP адресою з абсолютним шляхом (що не відповідає "
+"стандарту RFC 1738). В такому випадку, файл може бути знайдений за адресою "
+"<a href=\"%B\">%B</a>."
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.p:28
 msgid ""
@@ -1057,18 +1051,24 @@ msgstr ""
 msgid ""
 "Tools -&gt; Internet Options -&gt; Connection -&gt; LAN Settings -&gt;Proxy"
 msgstr ""
+"Інструменти -&gt; Властивості браузера -&gt; З'єднання -&gt; Налаштування "
+"LAN -&gt; Проксі"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:29
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:29
 msgid ""
 "Tools -&gt; Options -&gt; Advanced -&gt; Network -&gt; Connection Settings"
 msgstr ""
+"Інструменти -&gt; Опції -&gt; Додатково -&gt; Мережа -&gt; Параметри "
+"з'єднання"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:45
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:45
 msgid ""
 "Tools -&gt; Preferences -&gt; Advanced -&gt; Network -&gt; Proxy Servers"
 msgstr ""
+"Інструменти -&gt; Налаштування -&gt; Додатково -&gt; Мережа -&gt; Проксі "
+"сервера"
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.blockquote.pre:23
 msgid "URI Host Conflict"
@@ -1117,7 +1117,7 @@ msgstr "Unable to verify the first certificate"
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
 msgid "Unsupported HTTP version"
-msgstr "Версія HTTP протоколу не підпримується"
+msgstr "Версія HTTP протоколу не підтримується"
 
 #: templates/ERR_UNSUP_REQ+html.body.div.blockquote.p:23
 msgid "Unsupported Request Method and Protocol"
@@ -1128,42 +1128,41 @@ msgid "Unsupported certificate purpose"
 msgstr "Unsupported certificate purpose"
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
-#, fuzzy
 msgid ""
 "Valid document was not found in the cache and <q>only-if-cached</q> "
 "directive was specified."
 msgstr ""
-"Необхідний документ не знайдений в кеші і визначена директива <q>only-if-"
-"cached</q> (<q>тільки в кеші</q>)"
+"Необхідний документ не знайдений в кеші і визначена директива <q>\"тільки в "
+"кеші\"</q>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.head.title:4
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.h2:15
 #: templates/ERR_AGENT_WPAD+html.head.title:4
 #: templates/ERR_AGENT_WPAD+html.body.div.h2:15
 msgid "Web Browser Configuration"
-msgstr ""
+msgstr "Конфігурація браузера"
 
 #: templates/ERR_WRITE_ERROR+html.body.div.blockquote.p:23
 msgid "Write Error"
 msgstr "Помилка запису"
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.p:26
-#, fuzzy
 msgid ""
 "You have issued a request with a <q>only-if-cached</q> cache control "
 "directive. The document was not found in the cache, <em>or</em> it required "
 "revalidation prohibited by the <q>only-if-cached</q> directive."
 msgstr ""
-"Ви надіслали запит з директивою керування кешу <q>only-if-cached</q> "
-"(<q>тільки в кеші</q>). Документ не знайдений в кеші, <em>або</em> він "
-"потребує оновлення, що заборонено директивою <q>only-if-cached</q> "
-"(<q>тільки в кеші</q>)."
+"Ви надіслали запит з директивою керування кешу <q>\"тільки в кеші\"</q>. "
+"Документ не знайдений в кеші, <em>або</em> він потребує оновлення, що "
+"заборонено директивою <q>\"тільки в кеші\"</q>."
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.blockquote.p:21
 #: templates/ERR_AGENT_WPAD+html.body.div.blockquote.p:21
 msgid ""
 "Your Web Browser configuration needs to be corrected to use this network."
 msgstr ""
+"Конфігурація Вашого браузера потребує коригувань для використання цієї "
+"мережі."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:28
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:29
@@ -1226,17 +1225,16 @@ msgstr "Відповідь нульової довжини"
 #~ msgid "Parent Directory"
 #~ msgstr "Попередня директорія"
 
-#, fuzzy
 msgid ""
 "This request could not be forwarded to the origin server or to any parent "
 "caches. The most likely cause for this error is that the cache "
 "administrator does not allow this cache to make direct connections to "
 "origin servers, and all configured parent caches are currently "
 "unreachable."
 msgstr ""
-"Даний запит не може бути пересланий ні до первинного сервера ні до будь-"
-"якого з батьківських кешів. Найбільш ймовірною причиною є те, що "
-"Адміністратор кешу заборонив здійснювати прямі з'єднання до первинних "
+"Даний запит не може бути пересланий ні до первинного сервера ні до "
+"будь-якого з батьківських кешів. Найбільш імовірною причиною є те, що "
+"адміністратор кешу заборонив здійснювати прямі з'єднання до первинних "
 "серверів, та всі визначені батьківські кеш-сервера зараз недосяжні."
 
 #~ msgid "While trying to PUT the following URL: <a href=\"%U\">%U</a>"
@@ -15,8 +15,8 @@
 #include <sys/types.h>
 #include <sys/param.h>
 #include <string.h>
-#include "usersfile.h"
 #include "msntauth.h"
+#include "usersfile.h"
 
 static usersfile AllowUsers;
 static int init = 0;
@@ -16,8 +16,8 @@
 #include <sys/types.h>
 #include <sys/param.h>
 #include <string.h>
-#include "usersfile.h"
 #include "msntauth.h"
+#include "usersfile.h"
 
 static usersfile DenyUsers;
 static int init = 0;
@@ -37,7 +37,6 @@
 #include <signal.h>
 #include <syslog.h>
 #include <string.h>
-#include <sys/time.h>
 
 #include "msntauth.h"
 
@@ -23,8 +23,8 @@
 #include <stdio.h>
 #endif
 
-#include "md5.h"
 #include "crypt_md5.h"
+#include "md5.h"
 
 static unsigned char itoa64[] =	/* 0 ... 63 => ascii - 64 */
     "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@@ -2,20 +2,36 @@
  * Written By Rabellino Sergio (rabellino@di.unito.it) For Solaris 2.x
  */
 #include "squid.h"
+
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if HAVE_STDIO_H
 #include <stdio.h>
+#endif
+#if HAVE_STRING_H
 #include <string.h>
+#endif
+#if HAVE_SYSLOG_H
 #include <syslog.h>
+#endif
+#if HAVE_SYS_TYPES_H
 #include <sys/types.h>
+#endif
+#if HAVE_RPC_RPC_H
 #include <rpc/rpc.h>
+#endif
 
 #if _SQUID_FREEBSD_  && !defined(BOOL_DEFINED)
 // BUG: FreeBSD rpcsvc/yp_* headers try to redefine bool unless we match their non-standard hack.
 #define BOOL_DEFINED
 #endif
 
 #include <rpcsvc/ypclnt.h>
+
+#if HAVE_RPCSVC_YP_PROT_H
 #include <rpcsvc/yp_prot.h>
+#endif
 
 #include "nis_support.h"
 
@@ -1 +1,5 @@
-AC_CHECK_HEADERS([rpcsvc/yp_prot.h],[BUILD_HELPER="NIS"])
+AC_CHECK_HEADERS([sys/types.h rpc/rpc.h rpcsvc/yp_prot.h],[BUILD_HELPER="NIS"],,AC_INCLUDES_DEFAULT([
+#if HAVE_RPC_RPC_H
+#include <rpc/rpc.h>
+#endif
+]))
@@ -48,8 +48,8 @@
 #include "squid.h"
 #include "helpers/defines.h"
 #include "md5.h"
-#include "radius.h"
 #include "radius-util.h"
+#include "radius.h"
 
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
@@ -36,9 +36,9 @@
 #include <crypt.h>
 #endif
 
-#include "util.h"
 #include "hash.h"
 #include "rfc2617.h"
+#include "util.h"
 
 typedef struct _request_data {
     char *user;
@@ -39,9 +39,9 @@
 #include <crypt.h>
 #endif
 
-#include "util.h"
 #include "hash.h"
 #include "rfc2617.h"
+#include "util.h"
 
 typedef struct _request_data {
     char *user;
@@ -89,10 +89,6 @@ PFldap_start_tls_s Win32_ldap_start_tls_s;
 
 #endif
 
-#if defined(LDAP_OPT_NETWORK_TIMEOUT)
-#include <sys/time.h>
-#endif
-
 #define PROGRAM_NAME "ext_ldap_group_acl"
 #define PROGRAM_VERSION "2.17"
 
@@ -31,8 +31,8 @@
  */
 #include "squid.h"
 #include "helpers/defines.h"
-#include "util.h"
 #include "rfc1738.h"
+#include "util.h"
 
 #ifdef HAVE_LDAP
 
@@ -65,7 +65,7 @@ init_args(struct main_args *margs)
 
 void clean_gd(struct gdstruct *gdsp);
 void clean_nd(struct ndstruct *ndsp);
-void clean_ls(struct ndstruct *lssp);
+void clean_ls(struct lsstruct *lssp);
 
 void
 clean_gd(struct gdstruct *gdsp)
@@ -78,22 +78,12 @@ clean_gd(struct gdstruct *gdsp)
             pp = p;
             p = p->next;
         }
-        if (p->group) {
-            xfree(p->group);
-            p->group = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == gdsp) {
-            xfree(gdsp);
-            gdsp = NULL;
-        }
+        safe_free(p->group);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == gdsp)
+            safe_free(gdsp);
         p = gdsp;
     }
 }
@@ -109,22 +99,12 @@ clean_nd(struct ndstruct *ndsp)
             pp = p;
             p = p->next;
         }
-        if (p->netbios) {
-            xfree(p->netbios);
-            p->netbios = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == ndsp) {
-            xfree(ndsp);
-            ndsp = NULL;
-        }
+        safe_free(p->netbios);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == ndsp)
+            safe_free(ndsp);
         p = ndsp;
     }
 }
@@ -140,73 +120,30 @@ clean_ls(struct lsstruct *lssp)
             pp = p;
             p = p->next;
         }
-        if (p->lserver) {
-            xfree(p->lserver);
-            p->lserver = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == lssp) {
-            xfree(lssp);
-            lssp = NULL;
-        }
+        safe_free(p->lserver);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == lssp)
+            safe_free(lssp);
         p = lssp;
     }
 }
 
 void
 clean_args(struct main_args *margs)
 {
-    if (margs->glist) {
-        xfree(margs->glist);
-        margs->glist = NULL;
-    }
-    if (margs->ulist) {
-        xfree(margs->ulist);
-        margs->ulist = NULL;
-    }
-    if (margs->tlist) {
-        xfree(margs->tlist);
-        margs->tlist = NULL;
-    }
-    if (margs->nlist) {
-        xfree(margs->nlist);
-        margs->nlist = NULL;
-    }
-    if (margs->llist) {
-        xfree(margs->llist);
-        margs->llist = NULL;
-    }
-    if (margs->luser) {
-        xfree(margs->luser);
-        margs->luser = NULL;
-    }
-    if (margs->lpass) {
-        xfree(margs->lpass);
-        margs->lpass = NULL;
-    }
-    if (margs->lbind) {
-        xfree(margs->lbind);
-        margs->lbind = NULL;
-    }
-    if (margs->lurl) {
-        xfree(margs->lurl);
-        margs->lurl = NULL;
-    }
-    if (margs->ssl) {
-        xfree(margs->ssl);
-        margs->ssl = NULL;
-    }
-    if (margs->ddomain) {
-        xfree(margs->ddomain);
-        margs->ddomain = NULL;
-    }
+    safe_free(margs->glist);
+    safe_free(margs->ulist);
+    safe_free(margs->tlist);
+    safe_free(margs->nlist);
+    safe_free(margs->llist);
+    safe_free(margs->luser);
+    safe_free(margs->lpass);
+    safe_free(margs->lbind);
+    safe_free(margs->lurl);
+    safe_free(margs->ssl);
+    safe_free(margs->ddomain);
     if (margs->groups) {
         clean_gd(margs->groups);
         margs->groups = NULL;
@@ -413,8 +350,8 @@ main(int argc, char *const argv[])
                 log((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, up, np);
             domain = get_netbios_name(&margs, netbios);
             user = nuser;
-            xfree(up);
-            xfree(np);
+            safe_free(up);
+            safe_free(np);
         } else if (domain) {
             strup(domain);
             *domain = '\0';
@@ -436,8 +373,8 @@ main(int argc, char *const argv[])
         else
             log((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, up, domain ? dp : "NULL");
 
-        xfree(up);
-        xfree(dp);
+        safe_free(up);
+        safe_free(dp);
         if (!strcmp(user, "QQ") && domain && !strcmp(domain, "QQ")) {
             clean_args(&margs);
             exit(-1);
@@ -477,7 +414,7 @@ void
 strup(char *s)
 {
     while (*s) {
-        *s = toupper((unsigned char) *s);
+        *s = (char)toupper((unsigned char) *s);
         ++s;
     }
 }
@@ -22,7 +22,7 @@
  * -----------------------------------------------------------------------------
  */
 
-#define KERBEROS_LDAP_GROUP_VERSION "1.3.0sq"
+#define KERBEROS_LDAP_GROUP_VERSION "1.3.1sq"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -156,13 +156,13 @@ int create_nd(struct main_args *margs);
 int create_ls(struct main_args *margs);
 
 #ifdef HAVE_KRB5
-int krb5_create_cache(struct main_args *margs, char *domain);
+int krb5_create_cache(char *domain);
 void krb5_cleanup(void);
 #endif
 
-int get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *domain);
-int get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *name);
-int free_hostname_list(struct hstruct **hlist, int nhosts);
+size_t get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nhosts, char *domain);
+size_t get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name);
+size_t free_hostname_list(struct hstruct **hlist, size_t nhosts);
 
 #if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
 int tool_sasl_bind(LDAP * ld, char *binddn, char *ssl);
@@ -31,6 +31,7 @@
 #include "support.h"
 
 struct gdstruct *init_gd(void);
+void free_gd(struct gdstruct *gdsp);
 
 struct gdstruct *
 init_gd(void) {
@@ -59,7 +60,8 @@ char *utf8dup(struct main_args *margs);
 char *
 utf8dup(struct main_args *margs)
 {
-    int c = 0, s;
+    size_t c = 0;
+    unsigned char s;
     size_t n;
     char *src;
     unsigned char *p, *dupp;
@@ -79,7 +81,7 @@ utf8dup(struct main_args *margs)
                 *p = 194;
                 ++p;
                 *p = s;
-            } else if (s > 191 && s < 256) {
+            } else if (s > 191) {
                 *p = 195;
                 ++p;
                 *p = s - 64;
@@ -121,7 +123,7 @@ hex_utf_char(struct main_args *margs, int flag)
         return NULL;
 
     char *upd = strrchr(up, '@');
-    size_t a = (upd ? (upd - up) : strlen(up) );
+    size_t a = (upd ? (size_t)(upd - up) : strlen(up) );
 
     char *ul = (char *) xmalloc(strlen(up)+1);
     size_t n = 0;
@@ -174,17 +176,17 @@ hex_utf_char(struct main_args *margs, int flag)
         if (iUTF2) {
             if (iUTF2 == 0xC2 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl - 1] = ichar;
+                ul[nl - 1] = (char)ichar;
             } else if (iUTF2 == 0xC3 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl - 1] = ichar + 64;
+                ul[nl - 1] = (char)(ichar + 64);
             } else if (iUTF2 > 0xC3 && iUTF2 < 0xE0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF2 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
@@ -193,27 +195,27 @@ hex_utf_char(struct main_args *margs, int flag)
         } else if (iUTF3) {
             if (iUTF3 == 0xE0 && ichar > 0x9F && ichar < 0xC0) {
                 iUTF3 = 1;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0xE0 && iUTF3 < 0xED && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 2;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 == 0xED && ichar > 0x7F && ichar < 0xA0) {
                 iUTF3 = 3;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0xED && iUTF3 < 0xF0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 4;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0 && iUTF3 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF3 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
@@ -222,52 +224,52 @@ hex_utf_char(struct main_args *margs, int flag)
         } else if (iUTF4) {
             if (iUTF4 == 0xF0 && ichar > 0x8F && ichar < 0xC0) {
                 iUTF4 = 1;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 > 0xF0 && iUTF3 < 0xF4 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF4 = 2;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 == 0xF4 && ichar > 0x7F && ichar < 0x90) {
                 iUTF4 = 3;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 > 0 && iUTF4 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 if (iUTF4 == 4)
                     iUTF4 = 0;
                 else
                     iUTF4 = 4;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF4 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
                 return NULL;
             }
         } else if (ichar < 0x80) {
             /* UTF1 */
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xC1 && ichar < 0xE0) {
             /* UTF2 (Latin) */
             iUTF2 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xDF && ichar < 0xF0) {
             /* UTF3 */
             iUTF3 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xEF && ichar < 0xF5) {
             /* UTF4 */
             iUTF4 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else {
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ul[nl + 1] = '\0';
             debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
             xfree(ul);
@@ -33,7 +33,9 @@ struct kstruct {
     krb5_context context;
     char *mem_cache_env;
     krb5_ccache cc;
-} kparam;
+};
+
+static struct kstruct kparam;
 
 #define KT_PATH_MAX 256
 
@@ -50,23 +52,20 @@ krb5_cleanup()
  * create Kerberos memory cache
  */
 int
-krb5_create_cache(struct main_args *margs, char *domain)
+krb5_create_cache(char *domain)
 {
 
     krb5_keytab keytab = 0;
     krb5_keytab_entry entry;
     krb5_kt_cursor cursor;
     krb5_creds *creds = NULL;
-    krb5_creds *tgt_creds = NULL;
     krb5_principal *principal_list = NULL;
     krb5_principal principal = NULL;
     char *service;
     char *keytab_name = NULL, *principal_name = NULL, *mem_cache = NULL;
     char buf[KT_PATH_MAX], *p;
-    int nprinc = 0;
-    int i;
+    size_t j,nprinc = 0;
     int retval = 0;
-    int found = 0;
     krb5_error_code code = 0;
 
     kparam.context = NULL;
@@ -112,6 +111,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
 
     nprinc = 0;
     while ((code = krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor)) == 0) {
+        int found = 0;
 
         principal_list = (krb5_principal *) xrealloc(principal_list, sizeof(krb5_principal) * (nprinc + 1));
         krb5_copy_principal(kparam.context, entry.principal, &principal_list[nprinc++]);
@@ -182,12 +182,14 @@ krb5_create_cache(struct main_args *margs, char *domain)
      * if no principal name found in keytab for domain use the prinipal name which can get a TGT
      */
     if (!principal_name) {
+        size_t i;
         debug((char *) "%s| %s: DEBUG: Did not find a principal in keytab for domain %s.\n", LogTime(), PROGRAM, domain);
         debug((char *) "%s| %s: DEBUG: Try to get principal of trusted domain.\n", LogTime(), PROGRAM);
-        creds = (krb5_creds *) xmalloc(sizeof(*creds));
-        memset(creds, 0, sizeof(*creds));
 
         for (i = 0; i < nprinc; ++i) {
+            krb5_creds *tgt_creds = NULL;
+            creds = (krb5_creds *) xmalloc(sizeof(*creds));
+            memset(creds, 0, sizeof(*creds));
             /*
              * get credentials
              */
@@ -205,8 +207,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
             snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
             creds->client = principal_list[i];
             code = krb5_parse_name(kparam.context, service, &creds->server);
-            if (service)
-                xfree(service);
+            xfree(service);
             code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
             if (code) {
@@ -233,8 +234,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
             snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3, "krbtgt/%s@%s", domain, krb5_princ_realm(kparam.context, principal_list[i])->data);
 #endif
             code = krb5_parse_name(kparam.context, service, &creds->server);
-            if (service)
-                xfree(service);
+            xfree(service);
             if (code) {
                 error((char *) "%s| %s: ERROR: Error while initialising TGT credentials : %s\n", LogTime(), PROGRAM, error_message(code));
                 goto loop_end;
@@ -245,19 +245,22 @@ krb5_create_cache(struct main_args *margs, char *domain)
                 goto loop_end;
             } else {
                 debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
-                found = 1;
                 break;
             }
 
 loop_end:
-            if (principal_name)
-                xfree(principal_name);
-            principal_name = NULL;
+            safe_free(principal_name);
+            if (tgt_creds) {
+                krb5_free_creds(kparam.context, tgt_creds);
+                tgt_creds = NULL;
+            }
+            if (creds)
+                krb5_free_creds(kparam.context, creds);
+            creds = NULL;
+
         }
 
-        if (tgt_creds)
-            krb5_free_creds(kparam.context, tgt_creds);
-        tgt_creds = NULL;
+        safe_free(principal_name);
         if (creds)
             krb5_free_creds(kparam.context, creds);
         creds = NULL;
@@ -287,8 +290,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
         snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
         creds->client = principal;
         code = krb5_parse_name(kparam.context, service, &creds->server);
-        if (service)
-            xfree(service);
+        xfree(service);
         code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
         if (code) {
@@ -316,20 +318,16 @@ krb5_create_cache(struct main_args *margs, char *domain)
 cleanup:
     if (keytab)
         krb5_kt_close(kparam.context, keytab);
-    if (keytab_name)
-        xfree(keytab_name);
-    if (principal_name)
-        xfree(principal_name);
-    if (mem_cache)
-        xfree(mem_cache);
+    xfree(keytab_name);
+    xfree(principal_name);
+    xfree(mem_cache);
     if (principal)
         krb5_free_principal(kparam.context, principal);
-    for (i = 0; i < nprinc; ++i) {
-        if (principal_list[i])
-            krb5_free_principal(kparam.context, principal_list[i]);
+    for (j = 0; j < nprinc; ++j) {
+        if (principal_list[j])
+            krb5_free_principal(kparam.context, principal_list[j]);
     }
-    if (principal_list)
-        xfree(principal_list);
+    xfree(principal_list);
     if (creds)
         krb5_free_creds(kparam.context, creds);
 
@@ -35,7 +35,7 @@
 char *convert_domain_to_bind_path(char *domain);
 char *escape_filter(char *filter);
 int check_AD(struct main_args *margs, LDAP * ld);
-int ldap_set_defaults(struct main_args *margs, LDAP * ld);
+int ldap_set_defaults(LDAP * ld);
 int ldap_set_ssl_defaults(struct main_args *margs);
 LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 
@@ -51,7 +51,7 @@ LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 #define FILTER_AD "(samaccountname=%s)"
 #define ATTRIBUTE_AD "memberof"
 
-int get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
+size_t get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
 int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth);
 
 #if defined(HAVE_SUN_LDAP_SDK) || defined(HAVE_MOZILLA_LDAP_SDK)
@@ -210,7 +210,7 @@ char *
 convert_domain_to_bind_path(char *domain)
 {
     char *dp, *bindp = NULL, *bp = NULL;
-    int i = 0;
+    size_t i = 0;
 
     if (!domain)
         return NULL;
@@ -243,8 +243,8 @@ convert_domain_to_bind_path(char *domain)
 char *
 escape_filter(char *filter)
 {
-    int i;
     char *ldap_filter_esc, *ldf;
+    size_t i;
 
     i = 0;
     for (ldap_filter_esc = filter; *ldap_filter_esc; ++ldap_filter_esc) {
@@ -278,16 +278,16 @@ escape_filter(char *filter)
     *ldf = '\0';
 
     return ldap_filter_esc;
-};
+}
 
 int
 check_AD(struct main_args *margs, LDAP * ld)
 {
     LDAPMessage *res;
     char **attr_value = NULL;
     struct timeval searchtime;
-    int max_attr = 0;
-    int j, rc = 0;
+    size_t max_attr = 0;
+    int rc = 0;
 
 #define FILTER_SCHEMA "(objectclass=*)"
 #define ATTRIBUTE_SCHEMA "schemaNamingContext"
@@ -301,7 +301,7 @@ check_AD(struct main_args *margs, LDAP * ld)
                            NULL, NULL, &searchtime, 0, &res);
 
     if (rc == LDAP_SUCCESS)
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_SCHEMA, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_SCHEMA, &attr_value);
 
     if (max_attr == 1) {
         ldap_msgfree(res);
@@ -318,11 +318,11 @@ check_AD(struct main_args *margs, LDAP * ld)
      * Cleanup
      */
     if (attr_value) {
+        size_t j;
         for (j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
-        xfree(attr_value);
-        attr_value = NULL;
+        safe_free(attr_value);
     }
     ldap_msgfree(res);
     return rc;
@@ -332,11 +332,10 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
 {
     LDAPMessage *res = NULL;
     char **attr_value = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
     char *filter = NULL;
     char *search_exp = NULL;
-    int j, rc = 0, retval = 0;
-    char *av = NULL, *avp = NULL;
+    int rc = 0, retval = 0;
     int ldepth;
     char *ldap_filter_esc = NULL;
     struct timeval searchtime;
@@ -378,38 +377,40 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
     debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
     if (margs->AD)
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_AD, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
     else
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE, &attr_value);
 
     /*
      * Compare group names
      */
     retval = 0;
     ldepth = depth + 1;
-    for (j = 0; j < max_attr; ++j) {
+    for (size_t j = 0; j < max_attr; ++j) {
+        char *av = NULL;
 
         /* Compare first CN= value assuming it is the same as the group name itself */
         av = attr_value[j];
         if (!strncasecmp("CN=", av, 3)) {
+            char *avp = NULL;
             av += 3;
             if ((avp = strchr(av, ','))) {
                 *avp = '\0';
             }
         }
         if (debug_enabled) {
             int n;
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
             for (n = 0; av[n] != '\0'; ++n)
                 fprintf(stderr, "%02x", (unsigned char) av[n]);
             fprintf(stderr, "\n");
         }
         if (!strcasecmp(group, av)) {
             retval = 1;
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
             break;
         } else
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
         /*
          * Do recursive group search
          */
@@ -418,13 +419,14 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
         if (search_group_tree(margs, ld, bindp, av, group, ldepth)) {
             retval = 1;
             if (!strncasecmp("CN=", av, 3)) {
+                char *avp = NULL;
                 av += 3;
                 if ((avp = strchr(av, ','))) {
                     *avp = '\0';
                 }
             }
             if (debug_enabled)
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
             else
                 break;
 
@@ -435,19 +437,18 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
      * Cleanup
      */
     if (attr_value) {
-        for (j = 0; j < max_attr; ++j) {
+        for (size_t j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
-        xfree(attr_value);
-        attr_value = NULL;
+        safe_free(attr_value);
     }
     ldap_msgfree(res);
 
     return retval;
 }
 
 int
-ldap_set_defaults(struct main_args *margs, LDAP * ld)
+ldap_set_defaults(LDAP * ld)
 {
     int val, rc = 0;
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
@@ -484,14 +485,14 @@ ldap_set_ssl_defaults(struct main_args *margs)
 #endif
 #ifdef HAVE_OPENLDAP
     int val;
-    char *ssl_cacertfile = NULL;
-    int free_path;
 #elif defined(HAVE_LDAPSSL_CLIENT_INIT)
     char *ssl_certdbpath = NULL;
 #endif
 
 #ifdef HAVE_OPENLDAP
     if (!margs->rc_allow) {
+        char *ssl_cacertfile = NULL;
+        int free_path;
         debug((char *) "%s| %s: DEBUG: Enable server certificate check for ldap server.\n", LogTime(), PROGRAM);
         val = LDAP_OPT_X_TLS_DEMAND;
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &val);
@@ -509,7 +510,6 @@ ldap_set_ssl_defaults(struct main_args *margs)
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE, ssl_cacertfile);
         if (ssl_cacertfile && free_path) {
             xfree(ssl_cacertfile);
-            ssl_cacertfile = NULL;
         }
         if (rc != LDAP_OPT_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_CACERTFILE for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
@@ -543,10 +543,7 @@ ldap_set_ssl_defaults(struct main_args *margs)
         rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0, NULL, 0);
         debug((char *) "%s| %s: DEBUG: Disable server certificate check for ldap server.\n", LogTime(), PROGRAM);
     }
-    if (ssl_certdbpath) {
-        xfree(ssl_certdbpath);
-        ssl_certdbpath = NULL;
-    }
+    xfree(ssl_certdbpath);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
         return rc;
@@ -557,13 +554,13 @@ ldap_set_ssl_defaults(struct main_args *margs)
     return LDAP_SUCCESS;
 }
 
-int
-get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
+size_t
+get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
 {
 
     LDAPMessage *msg;
     char **attr_value = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
 
     attr_value = *ret_value;
     /*
@@ -588,15 +585,15 @@ get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char
                     if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
                         for (il = 0; values[il] != NULL; ++il) {
 
-                            attr_value = (char **) xrealloc(attr_value, (il + 1) * sizeof(char *));
+                            attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
                             if (!attr_value)
                                 break;
 
-                            attr_value[il] = (char *) xmalloc(values[il]->bv_len + 1);
-                            memcpy(attr_value[il], values[il]->bv_val, values[il]->bv_len);
-                            attr_value[il][values[il]->bv_len] = 0;
+                            attr_value[max_attr] = (char *) xmalloc(values[il]->bv_len + 1);
+                            memcpy(attr_value[max_attr], values[il]->bv_val, values[il]->bv_len);
+                            attr_value[max_attr][values[il]->bv_len] = 0;
+                            max_attr++;
                         }
-                        max_attr = il;
                     }
                     ber_bvecfree(values);
                 }
@@ -615,7 +612,7 @@ get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char
         }
     }
 
-    debug((char *) "%s| %s: DEBUG: %d ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
+    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
 
     *ret_value = attr_value;
     return max_attr;
@@ -643,11 +640,11 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
     memset(url, 0, sizeof(*url));
 #ifdef HAVE_LDAP_URL_LUD_SCHEME
     if (ssl)
-        url->lud_scheme = (char *) "ldaps";
+        url->lud_scheme = xstrdup("ldaps");
     else
-        url->lud_scheme = (char *) "ldap";
+        url->lud_scheme = xstrdup("ldap");
 #endif
-    url->lud_host = host;
+    url->lud_host = xstrdup(host);
     url->lud_port = port;
 #ifdef HAVE_LDAP_SCOPE_DEFAULT
     url->lud_scope = LDAP_SCOPE_DEFAULT;
@@ -661,13 +658,13 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         xfree(ldapuri);
-        xfree(url);
+        ldap_free_urldesc(url);
         return NULL;
     }
 #else
 #error "No URL parsing function"
 #endif
-    safe_free(url);
+    ldap_free_urldesc(url);
     rc = ldap_initialize(&ld, ldapuri);
     xfree(ldapuri);
     if (rc != LDAP_SUCCESS) {
@@ -679,7 +676,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 #else
     ld = ldap_init(host, port);
 #endif
-    rc = ldap_set_defaults(margs, ld);
+    rc = ldap_set_defaults(ld);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind(ld);
@@ -710,9 +707,9 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             url = (LDAPURLDesc *) xmalloc(sizeof(*url));
             memset(url, 0, sizeof(*url));
 #ifdef HAVE_LDAP_URL_LUD_SCHEME
-            url->lud_scheme = (char *) "ldaps";
+            url->lud_scheme = xstrdup("ldaps");
 #endif
-            url->lud_host = host;
+            url->lud_host = xstrdup(host);
             url->lud_port = port;
 #ifdef HAVE_LDAP_SCOPE_DEFAULT
             url->lud_scope = LDAP_SCOPE_DEFAULT;
@@ -726,13 +723,13 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 xfree(ldapuri);
-                xfree(url);
+                ldap_free_urldesc(url);
                 return NULL;
             }
 #else
 #error "No URL parsing function"
 #endif
-            safe_free(url);
+            ldap_free_urldesc(url);
             rc = ldap_initialize(&ld, ldapuri);
             xfree(ldapuri);
             if (rc != LDAP_SUCCESS) {
@@ -741,7 +738,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
                 ld = NULL;
                 return NULL;
             }
-            rc = ldap_set_defaults(margs, ld);
+            rc = ldap_set_defaults(ld);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind(ld);
@@ -757,7 +754,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             ld = NULL;
             return NULL;
         }
-        rc = ldap_set_defaults(margs, ld);
+        rc = ldap_set_defaults(ld);
         if (rc != LDAP_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
             ldap_unbind(ld);
@@ -787,18 +784,12 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     char *filter = NULL;
     char *search_exp;
     struct timeval searchtime;
-    int i, j, rc = 0, kc = 1;
+    int rc = 0, kc = 1;
     int retval;
     char **attr_value = NULL;
-    char *av = NULL, *avp = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
     struct hstruct *hlist = NULL;
-    int nhosts = 0;
-    char *hostname;
-    char *host;
-    int port;
-    char *ssl = NULL;
-    char *p;
+    size_t nhosts = 0;
     char *ldap_filter_esc = NULL;
 
     searchtime.tv_sec = SEARCH_TIMEOUT;
@@ -810,7 +801,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n", LogTime(), PROGRAM);
 
 #ifdef HAVE_KRB5
-        kc = krb5_create_cache(margs, domain);
+        kc = krb5_create_cache(domain);
         if (kc) {
             error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
         }
@@ -847,8 +838,8 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Loop over list of ldap servers of users domain
          */
         nhosts = get_ldap_hostname_list(margs, &hlist, 0, domain);
-        for (i = 0; i < nhosts; ++i) {
-            port = 389;
+        for (size_t i = 0; i < nhosts; ++i) {
+            int port = 389;
             if (hlist[i].port != -1)
                 port = hlist[i].port;
             debug((char *) "%s| %s: DEBUG: Setting up connection to ldap server %s:%d\n", LogTime(), PROGRAM, hlist[i].host, port);
@@ -893,6 +884,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         bindp = convert_domain_to_bind_path(domain);
     }
     if ((!domain || !ld) && margs->lurl && strstr(margs->lurl, "://")) {
+        char *hostname;
+        char *host;
+        int port;
+        char *ssl = NULL;
+        char *p;
         /*
          * If username does not contain a domain and a url was given then try it
          */
@@ -912,9 +908,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             ++p;
             port = atoi(p);
         }
-        nhosts = get_hostname_list(margs, &hlist, 0, host);
-        safe_free(host);
-        for (i = 0; i < nhosts; ++i) {
+        nhosts = get_hostname_list(&hlist, 0, host);
+        xfree(host);
+        for (size_t i = 0; i < nhosts; ++i) {
 
             ld = tool_ldap_open(margs, hlist[i].host, port, ssl);
             if (!ld)
@@ -997,40 +993,41 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     if (ldap_count_entries(ld, res) != 0) {
 
         if (margs->AD)
-            max_attr = get_attributes(margs, ld, res, ATTRIBUTE_AD, &attr_value);
+            max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
         else {
-            max_attr = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value);
+            max_attr = get_attributes(ld, res, ATTRIBUTE, &attr_value);
         }
 
         /*
          * Compare group names
          */
         retval = 0;
-        for (j = 0; j < max_attr; ++j) {
+        for (size_t k = 0; k < max_attr; ++k) {
+            char *av = NULL;
 
             /* Compare first CN= value assuming it is the same as the group name itself */
-            av = attr_value[j];
+            av = attr_value[k];
             if (!strncasecmp("CN=", av, 3)) {
+                char *avp = NULL;
                 av += 3;
                 if ((avp = strchr(av, ','))) {
                     *avp = '\0';
                 }
             }
             if (debug_enabled) {
-                int n;
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
-                for (n = 0; av[n] != '\0'; ++n)
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, k + 1, av);
+                for (unsigned int n = 0; av[n] != '\0'; ++n)
                     fprintf(stderr, "%02x", (unsigned char) av[n]);
                 fprintf(stderr, "\n");
             }
             if (!strcasecmp(group, av)) {
                 retval = 1;
                 if (debug_enabled)
-                    debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                    debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
                 else
                     break;
             } else
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
         }
         /*
          * Do recursive group search for AD only since posixgroups can not contain other groups
@@ -1039,19 +1036,21 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             if (debug_enabled && max_attr > 0) {
                 debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
             }
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
+                char *av = NULL;
 
                 av = attr_value[j];
                 if (search_group_tree(margs, ld, bindp, av, group, 1)) {
                     retval = 1;
                     if (!strncasecmp("CN=", av, 3)) {
+                        char *avp = NULL;
                         av += 3;
                         if ((avp = strchr(av, ','))) {
                             *avp = '\0';
                         }
                     }
                     if (debug_enabled)
-                        debug((char *) "%s| %s: DEBUG: Entry %d group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                        debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
                     else
                         break;
                 }
@@ -1061,11 +1060,10 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
-            xfree(attr_value);
-            attr_value = NULL;
+            safe_free(attr_value);
         }
         ldap_msgfree(res);
     } else if (ldap_count_entries(ld, res) == 0 && margs->AD) {
@@ -1101,11 +1099,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
         debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_GID, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_GID, &attr_value);
 
         if (max_attr == 1) {
             char **attr_value_2 = NULL;
-            int max_attr_2 = 0;
+            size_t max_attr_2 = 0;
 
             ldap_msgfree(res);
             filter = (char *) FILTER_GID;
@@ -1123,15 +1121,14 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                                    NULL, NULL, &searchtime, 0, &res);
             xfree(search_exp);
 
-            max_attr_2 = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value_2);
+            max_attr_2 = get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
             /*
              * Compare group names
              */
             retval = 0;
             if (max_attr_2 == 1) {
-
                 /* Compare first CN= value assuming it is the same as the group name itself */
-                av = attr_value_2[0];
+                char *av = attr_value_2[0];
                 if (!strcasecmp(group, av)) {
                     retval = 1;
                     debug((char *) "%s| %s: DEBUG: \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, av, group);
@@ -1143,11 +1140,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
              * Cleanup
              */
             if (attr_value_2) {
+                size_t j;
                 for (j = 0; j < max_attr_2; ++j) {
                     xfree(attr_value_2[j]);
                 }
-                xfree(attr_value_2);
-                attr_value_2 = NULL;
+                safe_free(attr_value_2);
             }
             ldap_msgfree(res);
 
@@ -1161,11 +1158,10 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
-            xfree(attr_value);
-            attr_value = NULL;
+            safe_free(attr_value);
         }
     }
     rc = ldap_unbind(ld);
@@ -34,13 +34,13 @@
 const char *
 LogTime()
 {
-    struct tm *tm;
-    struct timeval now;
     static time_t last_t = 0;
+    struct timeval now;
     static char buf[128];
 
     gettimeofday(&now, NULL);
     if (now.tv_sec != last_t) {
+        struct tm *tm;
         time_t tmp = now.tv_sec;
         tm = localtime(&tmp);
         strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
@@ -29,6 +29,7 @@
 
 #include "support.h"
 struct lsstruct *init_ls(void);
+void free_ls(struct lsstruct *lssp);
 
 struct lsstruct *
 init_ls(void) {
@@ -30,6 +30,7 @@
 #include "support.h"
 
 struct ndstruct *init_nd(void);
+void free_nd(struct ndstruct *ndsp);
 
 struct ndstruct *
 init_nd(void) {
@@ -95,10 +95,10 @@ static void
 sort(struct hstruct *array, int nitems, int (*cmp) (struct hstruct *, struct hstruct *), int begin, int end)
 {
     if (end > begin) {
-        int pivot = begin;
         int l = begin + 1;
         int r = end;
         while (l < r) {
+            int pivot = begin;
             if (cmp(&array[l], &array[pivot]) <= 0) {
                 l += 1;
             } else {
@@ -116,7 +116,7 @@ sort(struct hstruct *array, int nitems, int (*cmp) (struct hstruct *, struct hst
 static void
 msort(struct hstruct *array, size_t nitems, int (*cmp) (struct hstruct *, struct hstruct *))
 {
-    sort(array, nitems, cmp, 0, nitems - 1);
+    sort(array, (int)nitems, cmp, 0, (int)(nitems - 1));
 }
 
 static int
@@ -145,33 +145,25 @@ compare_hosts(struct hstruct *host1, struct hstruct *host2)
     return 0;
 }
 
-int
-free_hostname_list(struct hstruct **hlist, int nhosts)
+size_t
+free_hostname_list(struct hstruct **hlist, size_t nhosts)
 {
     struct hstruct *hp = NULL;
-    int i;
+    size_t i;
 
     hp = *hlist;
     for (i = 0; i < nhosts; ++i) {
-        if (hp[i].host)
-            xfree(hp[i].host);
-        hp[i].host = NULL;
+        xfree(hp[i].host);
     }
 
-    if (hp)
-        xfree(hp);
-    hp = NULL;
+    safe_free(hp);
     *hlist = hp;
     return 0;
 }
 
-int
-get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *name)
+size_t
+get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name)
 {
-    /*
-     * char host[sysconf(_SC_HOST_NAME_MAX)];
-     */
-    char host[1024];
     struct addrinfo *hres = NULL, *hres_list;
     int rc, count;
     struct hstruct *hp = NULL;
@@ -194,6 +186,10 @@ get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, c
     hres_list = hres;
     count = 0;
     while (hres_list) {
+        /*
+         * char host[sysconf(_SC_HOST_NAME_MAX)];
+         */
+        char host[1024];
         rc = getnameinfo(hres_list->ai_addr, hres_list->ai_addrlen, host, sizeof(host), NULL, 0, 0);
         if (rc != 0) {
             error((char *) "%s| %s: ERROR: Error while resolving ip address with getnameinfo: %s\n", LogTime(), PROGRAM, gai_strerror(rc));
@@ -219,24 +215,21 @@ get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, c
     return (nhosts);
 }
 
-int
-get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh, char *domain)
+size_t
+get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nh, char *domain)
 {
 
     /*
      * char name[sysconf(_SC_HOST_NAME_MAX)];
      */
     char name[1024];
-    char host[NS_MAXDNAME];
     char *service = NULL;
     struct hstruct *hp = NULL;
     struct lsstruct *ls = NULL;
-    int nhosts = 0;
+    size_t nhosts = 0;
     int size;
-    int type, rdlength;
-    int priority, weight, port;
     int len, olen;
-    int i, j, k;
+    size_t i, j, k;
     u_char *buffer = NULL;
     u_char *p;
 
@@ -305,7 +298,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     }
     if (len > PACKETSZ_MULT * NS_PACKETSZ) {
         olen = len;
-        buffer = (u_char *) xrealloc(buffer, len);
+        buffer = (u_char *) xrealloc(buffer, (size_t)len);
         if ((len = res_search(service, ns_c_in, ns_t_srv, (u_char *) buffer, len)) < 0) {
             error((char *) "%s| %s: ERROR: Error while resolving service record %s with res_search\n", LogTime(), PROGRAM, service);
             nsError(h_errno, service);
@@ -322,7 +315,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         error((char *) "%s| %s: ERROR: Message to small: %d < header size\n", LogTime(), PROGRAM, len);
         goto finalise;
     }
-    if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
+    if ((size = dn_expand(buffer, buffer + len, p, name, sizeof(name))) < 0) {
         error((char *) "%s| %s: ERROR: Error while expanding query name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
         goto finalise;
     }
@@ -333,7 +326,8 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         goto finalise;
     }
     while (p < buffer + len) {
-        if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
+        int type, rdlength;
+        if ((size = dn_expand(buffer, buffer + len, p, name, sizeof(name))) < 0) {
             error((char *) "%s| %s: ERROR: Error while expanding answer name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
             goto finalise;
         }
@@ -351,6 +345,8 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         NS_GET16(rdlength, p);	/* RR data length (16bit) */
 
         if (type == ns_t_srv) {	/* SRV record */
+            int priority, weight, port;
+            char host[NS_MAXDNAME];
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl + RR data length\n", LogTime(), PROGRAM, len);
                 goto finalise;
@@ -400,7 +396,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     }
 
 finalise:
-    nhosts = get_hostname_list(margs, &hp, nh, domain);
+    nhosts = get_hostname_list(&hp, nh, domain);
 
     debug("%s| %s: DEBUG: Adding %s to list\n", LogTime(), PROGRAM, domain);
 
@@ -435,18 +431,16 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     }
 
     /* Sort by Priority / Weight */
-    msort(hp, nhosts, compare_hosts);
+    msort(hp, (size_t)nhosts, compare_hosts);
 
     if (debug_enabled) {
         debug((char *) "%s| %s: DEBUG: Sorted ldap server names for domain %s:\n", LogTime(), PROGRAM, domain);
         for (i = 0; i < nhosts; ++i) {
             debug((char *) "%s| %s: DEBUG: Host: %s Port: %d Priority: %d Weight: %d\n", LogTime(), PROGRAM, hp[i].host, hp[i].port, hp[i].priority, hp[i].weight);
         }
     }
-    if (buffer)
-        xfree(buffer);
-    if (service)
-        xfree(service);
+    xfree(buffer);
+    xfree(service);
     *hlist = hp;
     return (nhosts);
 }
@@ -196,18 +196,12 @@ lutil_sasl_freedefs(
 {
     lutilSASLdefaults *defs = (lutilSASLdefaults *) defaults;
 
-    if (defs->mech)
-        xfree(defs->mech);
-    if (defs->realm)
-        xfree(defs->realm);
-    if (defs->authcid)
-        xfree(defs->authcid);
-    if (defs->passwd)
-        xfree(defs->passwd);
-    if (defs->authzid)
-        xfree(defs->authzid);
-    if (defs->resps)
-        xfree(defs->resps);
+    xfree(defs->mech);
+    xfree(defs->realm);
+    xfree(defs->authcid);
+    xfree(defs->passwd);
+    xfree(defs->authzid);
+    xfree(defs->resps);
 
     xfree(defs);
 }
@@ -7,7 +7,7 @@ libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
 
-negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc
+negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc negotiate_kerberos_pac.cc negotiate_kerberos.h
 negotiate_kerberos_auth_LDFLAGS = 
 negotiate_kerberos_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -0,0 +1,154 @@
+/*
+ * -----------------------------------------------------------------------------
+ *
+ * Author: Markus Moeller (markus_moeller at compuserve.com)
+ *
+ * Copyright (C) 2013 Markus Moeller. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ *   As a special exemption, M Moeller gives permission to link this program
+ *   with MIT, Heimdal or other GSS/Kerberos libraries, and distribute
+ *   the resulting executable, without including the source code for
+ *   the Libraries in the source distribution.
+ *
+ * -----------------------------------------------------------------------------
+ */
+
+#if HAVE_STRING_H
+#include <string.h>
+#endif
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#if HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_TIME_H
+#include <time.h>
+#endif
+
+#include "base64.h"
+#include "util.h"
+
+#if HAVE_KRB5_H
+#if HAVE_BROKEN_SOLARIS_KRB5_H
+#warn "Warning! You have a broken Solaris <krb5.h> system header"
+#warn "http://bugs.opensolaris.org/bugdatabase/view_bug.do?bug_id=6837512"
+#if defined(__cplusplus)
+#define KRB5INT_BEGIN_DECLS     extern "C" {
+#define KRB5INT_END_DECLS
+KRB5INT_BEGIN_DECLS
+#endif
+#endif /* HAVE_BROKEN_SOLARIS_KRB5_H */
+#if HAVE_BROKEN_HEIMDAL_KRB5_H
+extern "C" {
+#include <krb5.h>
+}
+#else
+#include <krb5.h>
+#endif
+#endif /* HAVE_KRB5_H */
+
+#if HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#elif HAVE_GSSAPI_H
+#include <gssapi.h>
+#endif
+
+#if !HAVE_HEIMDAL_KERBEROS
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
+#include <gssapi/gssapi_krb5.h>
+#endif
+#if HAVE_GSSAPI_GSSAPI_GENERIC_H
+#include <gssapi/gssapi_generic.h>
+#endif
+#if HAVE_GSSAPI_GSSAPI_EXT_H
+#include <gssapi/gssapi_ext.h>
+#endif
+#else
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
+#include <gssapi/gssapi_krb5.h>
+#endif
+#endif
+
+#ifndef gss_nt_service_name
+#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
+#endif
+
+#define PROGRAM "negotiate_kerberos_auth"
+
+#ifndef MAX_AUTHTOKEN_LEN
+#define MAX_AUTHTOKEN_LEN   65535
+#endif
+#ifndef SQUID_KERB_AUTH_VERSION
+#define SQUID_KERB_AUTH_VERSION "3.0.4sq"
+#endif
+
+char *gethost_name(void);
+
+static const unsigned char ntlmProtocol[] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};
+
+inline const char *
+LogTime()
+{
+    struct tm *tm;
+    struct timeval now;
+    static time_t last_t = 0;
+    static char buf[128];
+
+    gettimeofday(&now, NULL);
+    if (now.tv_sec != last_t) {
+        tm = localtime((time_t *) & now.tv_sec);
+        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
+        last_t = now.tv_sec;
+    }
+    return buf;
+}
+
+int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
+                  const char *function, int log, int sout);
+
+char *gethost_name(void);
+
+#if (defined(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT) || defined(HAVE_GSS_MAP_NAME_TO_ANY)) && HAVE_KRB5_PAC
+#define HAVE_PAC_SUPPORT 1
+#define MAX_PAC_GROUP_SIZE 200*60
+typedef struct {
+    uint16_t length;
+    uint16_t maxlength;
+    uint32_t pointer;
+} RPC_UNICODE_STRING;
+
+int check_k5_err(krb5_context context, const char *msg, krb5_error_code code);
+void align(int n);
+void getustr(RPC_UNICODE_STRING *string);
+char **getgids(char **Rids, uint32_t GroupIds, uint32_t GroupCount);
+char *getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t  GroupCount);
+char *getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount);
+uint64_t get6byt_be(void);
+uint32_t get4byt(void);
+uint16_t get2byt(void);
+uint8_t get1byt(void);
+char *xstrcpy( char *src, const char*dst);
+char *xstrcat( char *src, const char*dst);
+int checkustr(RPC_UNICODE_STRING *string);
+char *get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac);
+#else
+#define HAVE_PAC_SUPPORT 0
+#endif
@@ -30,85 +30,13 @@
  * Hosted at http://sourceforge.net/projects/squidkerbauth
  */
 #include "squid.h"
-#include "rfc1738.h"
 #include "compat/getaddrinfo.h"
 #include "compat/getnameinfo.h"
+#include "rfc1738.h"
 
 #if HAVE_GSSAPI
 
-#if HAVE_STRING_H
-#include <string.h>
-#endif
-#if HAVE_STDOI_H
-#include <stdio.h>
-#endif
-#if HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#if HAVE_TIME_H
-#include <time.h>
-#endif
-
-#include "util.h"
-#include "base64.h"
-
-#if HAVE_GSSAPI_GSSAPI_H
-#include <gssapi/gssapi.h>
-#elif HAVE_GSSAPI_H
-#include <gssapi.h>
-#endif
-
-#if !HAVE_HEIMDAL_KERBEROS
-#if HAVE_GSSAPI_GSSAPI_KRB5_H
-#include <gssapi/gssapi_krb5.h>
-#endif
-#if HAVE_GSSAPI_GSSAPI_GENERIC_H
-#include <gssapi/gssapi_generic.h>
-#endif
-#if HAVE_GSSAPI_GSSAPI_EXT_H
-#include <gssapi/gssapi_ext.h>
-#endif
-#endif
-
-#ifndef gss_nt_service_name
-#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
-#endif
-
-#define PROGRAM "negotiate_kerberos_auth"
-
-#ifndef MAX_AUTHTOKEN_LEN
-#define MAX_AUTHTOKEN_LEN   65535
-#endif
-#ifndef SQUID_KERB_AUTH_VERSION
-#define SQUID_KERB_AUTH_VERSION "3.0.4sq"
-#endif
-
-int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-                  const char *function, int log);
-char *gethost_name(void);
-static const char *LogTime(void);
-
-static const unsigned char ntlmProtocol[] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};
-
-static const char *
-LogTime()
-{
-    struct tm *tm;
-    struct timeval now;
-    static time_t last_t = 0;
-    static char buf[128];
-
-    gettimeofday(&now, NULL);
-    if (now.tv_sec != last_t) {
-        tm = localtime((time_t *) & now.tv_sec);
-        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
-        last_t = now.tv_sec;
-    }
-    return buf;
-}
+#include "negotiate_kerberos.h"
 
 char *
 gethost_name(void)
@@ -155,7 +83,7 @@ gethost_name(void)
 
 int
 check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-              const char *function, int log)
+              const char *function, int log, int sout)
 {
     if (GSS_ERROR(major_status)) {
         OM_uint32 maj_stat, min_stat;
@@ -198,7 +126,8 @@ check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
             gss_release_buffer(&min_stat, &status_string);
         } while (msg_ctx);
         debug((char *) "%s| %s: ERROR: %s failed: %s\n", LogTime(), PROGRAM, function, buf);
-        fprintf(stdout, "BH %s failed: %s\n", function, buf);
+        if (sout)
+            fprintf(stdout, "BH %s failed: %s\n", function, buf);
         if (log)
             fprintf(stderr, "%s| %s: INFO: User not authenticated\n", LogTime(),
                     PROGRAM);
@@ -213,7 +142,20 @@ main(int argc, char *const argv[])
     char buf[MAX_AUTHTOKEN_LEN];
     char *c, *p;
     char *user = NULL;
-    int length = 0;
+    char *rfc_user = NULL;
+#if HAVE_PAC_SUPPORT
+    char ad_groups[MAX_PAC_GROUP_SIZE];
+    char *ag=NULL;
+    krb5_context context = NULL;
+    krb5_error_code ret;
+    krb5_pac pac;
+#if HAVE_HEIMDAL_KERBEROS
+    gss_buffer_desc data_set = GSS_C_EMPTY_BUFFER;
+#else
+    gss_buffer_desc type_id = GSS_C_EMPTY_BUFFER;
+#endif
+#endif
+    long length = 0;
     static int err = 0;
     int opt, log = 0, norealm = 0;
     OM_uint32 ret_flags = 0, spnego_flag = 0;
@@ -284,6 +226,7 @@ main(int argc, char *const argv[])
         snprintf((char *) service.value, strlen(service_name) + strlen(host_name) + 2,
                  "%s@%s", service_name, host_name);
         service.length = strlen((char *) service.value);
+        xfree(host_name);
     }
 
     while (1) {
@@ -312,7 +255,7 @@ main(int argc, char *const argv[])
             err = 0;
             continue;
         }
-        debug((char *) "%s| %s: DEBUG: Got '%s' from squid (length: %d).\n", LogTime(), PROGRAM, buf, length);
+        debug((char *) "%s| %s: DEBUG: Got '%s' from squid (length: %ld).\n", LogTime(), PROGRAM, buf, length);
 
         if (buf[0] == '\0') {
             debug((char *) "%s| %s: ERROR: Invalid request\n", LogTime(), PROGRAM);
@@ -338,23 +281,13 @@ main(int argc, char *const argv[])
             if (kerberosToken) {
                 /* Allocated by parseNegTokenInit, but no matching free function exists.. */
                 if (!spnego_flag)
-                    xfree((char *) kerberosToken);
-                kerberosToken = NULL;
+                    xfree(kerberosToken);
             }
             if (spnego_flag) {
                 /* Allocated by makeNegTokenTarg, but no matching free function exists.. */
-                if (spnegoToken)
-                    xfree((char *) spnegoToken);
-                spnegoToken = NULL;
-            }
-            if (token) {
-                xfree(token);
-                token = NULL;
-            }
-            if (host_name) {
-                xfree(host_name);
-                host_name = NULL;
+                xfree(spnegoToken);
             }
+            xfree(token);
             fprintf(stdout, "BH quit command\n");
             exit(0);
         }
@@ -373,12 +306,12 @@ main(int argc, char *const argv[])
             fprintf(stdout, "BH Invalid negotiate request\n");
             continue;
         }
-        input_token.length = base64_decode_len(buf+3);
+        input_token.length = (size_t)base64_decode_len(buf+3);
         debug((char *) "%s| %s: DEBUG: Decode '%s' (decoded length: %d).\n",
               LogTime(), PROGRAM, buf + 3, (int) input_token.length);
         input_token.value = xmalloc(input_token.length);
 
-        input_token.length = base64_decode((char *) input_token.value, input_token.length, buf+3);
+        input_token.length = (size_t)base64_decode((char *) input_token.value, (unsigned int)input_token.length, buf+3);
 
         if ((input_token.length >= sizeof ntlmProtocol + 1) &&
                 (!memcmp(input_token.value, ntlmProtocol, sizeof ntlmProtocol))) {
@@ -399,19 +332,20 @@ main(int argc, char *const argv[])
             } else {
                 server_name = GSS_C_NO_NAME;
                 major_status = GSS_S_COMPLETE;
+                minor_status = 0;
             }
         } else {
             major_status = gss_import_name(&minor_status, &service,
                                            gss_nt_service_name, &server_name);
         }
 
-        if (check_gss_err(major_status, minor_status, "gss_import_name()", log))
+        if (check_gss_err(major_status, minor_status, "gss_import_name()", log, 1))
             goto cleanup;
 
         major_status =
             gss_acquire_cred(&minor_status, server_name, GSS_C_INDEFINITE,
                              GSS_C_NO_OID_SET, GSS_C_ACCEPT, &server_creds, NULL, NULL);
-        if (check_gss_err(major_status, minor_status, "gss_acquire_cred()", log))
+        if (check_gss_err(major_status, minor_status, "gss_acquire_cred()", log, 1))
             goto cleanup;
 
         major_status = gss_accept_sec_context(&minor_status,
@@ -424,16 +358,16 @@ main(int argc, char *const argv[])
         if (output_token.length) {
             spnegoToken = (const unsigned char *) output_token.value;
             spnegoTokenLength = output_token.length;
-            token = (char *) xmalloc(base64_encode_len(spnegoTokenLength));
+            token = (char *) xmalloc((size_t)base64_encode_len((int)spnegoTokenLength));
             if (token == NULL) {
                 debug((char *) "%s| %s: ERROR: Not enough memory\n", LogTime(), PROGRAM);
                 fprintf(stdout, "BH Not enough memory\n");
                 goto cleanup;
             }
-            base64_encode_str(token, base64_encode_len(spnegoTokenLength),
-                              (const char *) spnegoToken, spnegoTokenLength);
+            base64_encode_str(token, base64_encode_len((int)spnegoTokenLength),
+                              (const char *) spnegoToken, (int)spnegoTokenLength);
 
-            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
+            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
                 goto cleanup;
             if (major_status & GSS_S_CONTINUE_NEEDED) {
                 debug((char *) "%s| %s: INFO: continuation needed\n", LogTime(), PROGRAM);
@@ -445,7 +379,7 @@ main(int argc, char *const argv[])
                 gss_display_name(&minor_status, client_name, &output_token,
                                  NULL);
 
-            if (check_gss_err(major_status, minor_status, "gss_display_name()", log))
+            if (check_gss_err(major_status, minor_status, "gss_display_name()", log, 1))
                 goto cleanup;
             user = (char *) xmalloc(output_token.length + 1);
             if (user == NULL) {
@@ -458,14 +392,49 @@ main(int argc, char *const argv[])
             if (norealm && (p = strchr(user, '@')) != NULL) {
                 *p = '\0';
             }
+
+#if HAVE_PAC_SUPPORT
+            ret = krb5_init_context(&context);
+            if (!check_k5_err(context, "krb5_init_context", ret)) {
+#if HAVE_HEIMDAL_KERBEROS
+#define ADWIN2KPAC 128
+                major_status = gsskrb5_extract_authz_data_from_sec_context(&minor_status,
+                               gss_context, ADWIN2KPAC, &data_set);
+                if (!check_gss_err(major_status, minor_status,
+                                   "gsskrb5_extract_authz_data_from_sec_context()", log, 0)) {
+                    ret = krb5_pac_parse(context, data_set.value, data_set.length, &pac);
+                    gss_release_buffer(&minor_status, &data_set);
+                    if (!check_k5_err(context, "krb5_pac_parse", ret)) {
+                        ag = get_ad_groups((char *)&ad_groups, context, pac);
+                        krb5_pac_free(context, pac);
+                    }
+                    krb5_free_context(context);
+                }
+#else
+                type_id.value = (void *)"mspac";
+                type_id.length = strlen((char *)type_id.value);
+#define KRB5PACLOGONINFO        1
+                major_status = gss_map_name_to_any(&minor_status, client_name, KRB5PACLOGONINFO, &type_id, (gss_any_t *)&pac);
+                if (!check_gss_err(major_status, minor_status, "gss_map_name_to_any()", log, 0)) {
+                    ag = get_ad_groups((char *)&ad_groups,context, pac);
+                }
+                (void)gss_release_any_name_mapping(&minor_status, client_name, &type_id, (gss_any_t *)&pac);
+                krb5_free_context(context);
+#endif
+            }
+            if (ag) {
+                debug((char *) "%s| %s: DEBUG: Groups %s\n", LogTime(), PROGRAM, ag);
+            }
+#endif
             fprintf(stdout, "AF %s %s\n", token, user);
-            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc1738_escape(user));
+            rfc_user = rfc1738_escape(user);
+            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc_user);
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
                         PROGRAM, rfc1738_escape(user));
             goto cleanup;
         } else {
-            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
+            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
                 goto cleanup;
             if (major_status & GSS_S_CONTINUE_NEEDED) {
                 debug((char *) "%s| %s: INFO: continuation needed\n", LogTime(), PROGRAM);
@@ -477,7 +446,7 @@ main(int argc, char *const argv[])
                 gss_display_name(&minor_status, client_name, &output_token,
                                  NULL);
 
-            if (check_gss_err(major_status, minor_status, "gss_display_name()", log))
+            if (check_gss_err(major_status, minor_status, "gss_display_name()", log, 1))
                 goto cleanup;
             /*
              *  Return dummy token AA. May need an extra return tag then AF
@@ -511,23 +480,14 @@ main(int argc, char *const argv[])
         if (kerberosToken) {
             /* Allocated by parseNegTokenInit, but no matching free function exists.. */
             if (!spnego_flag)
-                xfree((char *) kerberosToken);
-            kerberosToken = NULL;
+                safe_free(kerberosToken);
         }
         if (spnego_flag) {
             /* Allocated by makeNegTokenTarg, but no matching free function exists.. */
-            if (spnegoToken)
-                xfree((char *) spnegoToken);
-            spnegoToken = NULL;
-        }
-        if (token) {
-            xfree(token);
-            token = NULL;
-        }
-        if (user) {
-            xfree(user);
-            user = NULL;
+            safe_free(spnegoToken);
         }
+        safe_free(token);
+        safe_free(user);
         continue;
     }
 }
@@ -196,9 +196,9 @@ squid_kerb_proxy_auth(char *proxy)
         goto cleanup;
 
     if (output_token.length) {
-        token = (char *) xmalloc(base64_encode_len(output_token.length));
-        base64_encode_str(token, base64_encode_len(output_token.length),
-                          (const char *) output_token.value, output_token.length);
+        token = (char *) xmalloc((size_t)base64_encode_len((int)output_token.length));
+        base64_encode_str(token, base64_encode_len((int)output_token.length),
+                          (const char *) output_token.value, (int)output_token.length);
     }
 cleanup:
     gss_delete_sec_context(&minor_status, &gss_context, NULL);
@@ -0,0 +1,467 @@
+/*
+ * -----------------------------------------------------------------------------
+ *
+ * Author: Markus Moeller (markus_moeller at compuserve.com)
+ *
+ * Copyright (C) 2007 Markus Moeller. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ *   As a special exemption, M Moeller gives permission to link this program
+ *   with MIT, Heimdal or other GSS/Kerberos libraries, and distribute
+ *   the resulting executable, without including the source code for
+ *   the Libraries in the source distribution.
+ *
+ * -----------------------------------------------------------------------------
+ */
+
+#include "squid.h"
+#include "compat/getaddrinfo.h"
+#include "compat/getnameinfo.h"
+#include "rfc1738.h"
+
+#include "negotiate_kerberos.h"
+
+#if HAVE_PAC_SUPPORT
+
+static int bpos;
+static krb5_data *ad_data;
+static unsigned char *p;
+
+int
+check_k5_err(krb5_context context, const char *function, krb5_error_code code)
+{
+    const char *errmsg;
+
+    if (code) {
+        errmsg = krb5_get_error_message(context, code);
+        debug((char *) "%s| %s: ERROR: %s failed: %s\n", LogTime(), PROGRAM, function, errmsg);
+        fprintf(stderr, "%s| %s: ERROR: %s: %s\n", LogTime(), PROGRAM, function, errmsg);
+        krb5_free_error_message(context, errmsg);
+    }
+    return code;
+}
+
+void
+align(int n)
+{
+    if ( bpos % n != 0 ) {
+        int al;
+        al = (bpos/n);
+        bpos = bpos+(bpos-n*al);
+    }
+}
+
+void
+getustr(RPC_UNICODE_STRING *string)
+{
+
+    string->length = (uint16_t)((p[bpos]<<0) | (p[bpos+1]<<8));
+    string->maxlength = (uint16_t)((p[bpos+2]<<0) | (p[bpos+2+1]<<8));
+    string->pointer = (uint32_t)((p[bpos+4]<<0) | (p[bpos+4+1]<<8) | (p[bpos+4+2]<<16) | (p[bpos+4+3]<<24));
+    bpos = bpos+8;
+
+}
+
+uint64_t
+get6byt_be(void)
+{
+    uint64_t var;
+
+    var = ((uint64_t)p[bpos+5]<<0) | ((uint64_t)p[bpos+4]<<8) | ((uint64_t)p[bpos+3]<<16) | ((uint64_t)p[bpos+2]<<24) | ((uint64_t)p[bpos+1]<<32) | ((uint64_t)p[bpos]<<40);
+    bpos = bpos+6;
+
+    return var;
+}
+
+uint32_t
+get4byt(void)
+{
+    uint32_t var;
+
+    var=(uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+    bpos = bpos+4;
+
+    return var;
+}
+
+uint16_t
+get2byt(void)
+{
+    uint16_t var;
+
+    var=(uint16_t)((p[bpos]<<0) | (p[bpos+1]<<8));
+    bpos = bpos+2;
+
+    return var;
+}
+
+uint8_t
+get1byt(void)
+{
+    uint8_t var;
+
+    var=(uint8_t)((p[bpos]<<0));
+    bpos = bpos+1;
+
+    return var;
+}
+
+char *
+xstrcpy( char *src, const char *dst)
+{
+    if (dst) {
+        if (strlen(dst)>MAX_PAC_GROUP_SIZE)
+            return NULL;
+        else
+            return strcpy(src,dst);
+    } else
+        return src;
+}
+
+char *
+xstrcat( char *src, const char *dst)
+{
+    if (dst) {
+        if (strlen(src)+strlen(dst)+1>MAX_PAC_GROUP_SIZE)
+            return NULL;
+        else
+            return strcat(src,dst);
+    } else
+        return src;
+}
+
+int
+checkustr(RPC_UNICODE_STRING *string)
+{
+    uint32_t size,off,len;
+
+    if (string->pointer != 0) {
+        align(4);
+        size = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+        bpos = bpos+4;
+        off = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+        bpos = bpos+4;
+        len = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+        bpos = bpos+4;
+        if (len > size || off != 0 ||
+                string->length > string->maxlength || len != string->length/2) {
+            debug((char *) "%s| %s: ERROR: RPC_UNICODE_STRING encoding error => size: %d len: %d/%d maxlength: %d offset: %d\n",
+                  LogTime(), PROGRAM, size, len, string->length, string->maxlength, off);
+            return -1;
+        }
+        /* UNICODE string */
+        bpos = bpos+string->length;
+    }
+    return 0;
+}
+
+char **
+getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
+{
+    if (GroupIds!= 0) {
+        uint32_t ngroup;
+        uint32_t sauth;
+        int l;
+
+        align(4);
+        ngroup = get4byt();
+        if ( ngroup != GroupCount) {
+            debug((char *) "%s| %s: ERROR: Group encoding error => GroupCount: %d Array size: %d\n",
+                  LogTime(), PROGRAM, GroupCount, ngroup);
+            return NULL;
+        }
+        debug((char *) "%s| %s: INFO: Found %d rids\n", LogTime(), PROGRAM, GroupCount);
+
+        Rids=(char **)xcalloc(GroupCount*sizeof(char*),1);
+        for ( l=0; l<(int)GroupCount; l++) {
+            Rids[l]=(char *)xcalloc(4*sizeof(char),1);
+            memcpy((void *)Rids[l],(void *)&p[bpos],4);
+            sauth = get4byt();
+            debug((char *) "%s| %s: Info: Got rid: %u\n", LogTime(), PROGRAM, sauth);
+            /* attribute */
+            bpos = bpos+4;
+        }
+    }
+    return Rids;
+}
+
+char *
+getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t GroupCount)
+{
+    if (DomainLogonId!= 0) {
+        uint32_t nauth;
+        uint8_t rev;
+        uint64_t idauth;
+        uint32_t sauth;
+        char dli[256];
+        char *ag;
+        size_t length;
+        int l;
+
+        align(4);
+
+        nauth = get4byt();
+
+        /* prepend rids with DomainID */
+        length=1+1+6+nauth*4;
+        for (l=0; l<(int)GroupCount; l++) {
+            ag=(char *)xcalloc((length+4)*sizeof(char),1);
+            memcpy((void *)ag,(const void*)&p[bpos],1);
+            memcpy((void *)&ag[1],(const void*)&p[bpos+1],1);
+            ag[1] = ag[1]+1;
+            memcpy((void *)&ag[2],(const void*)&p[bpos+2],6+nauth*4);
+            memcpy((void *)&ag[length],(const void*)Rids[l],4);
+            if (l==0) {
+                if (!xstrcpy(ad_groups,"group=")) {
+                    debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                          LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                }
+            } else {
+                if (!xstrcat(ad_groups," group=")) {
+                    debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                          LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                }
+            }
+            if (!xstrcat(ad_groups,base64_encode_bin(ag, (int)(length+4)))) {
+                debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                      LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+            }
+            xfree(ag);
+        }
+
+        /* mainly for debug only */
+        rev = get1byt();
+        bpos = bpos + 1; /*nsub*/
+        idauth = get6byt_be();
+
+        snprintf(dli,sizeof(dli),"S-%d-%lu",rev,(long unsigned int)idauth);
+        for ( l=0; l<(int)nauth; l++ ) {
+            sauth = get4byt();
+            snprintf((char *)&dli[strlen(dli)],sizeof(dli)-strlen(dli),"-%u",sauth);
+        }
+        debug((char *) "%s| %s: INFO: Got DomainLogonId %s\n", LogTime(), PROGRAM, dli);
+    }
+    return ad_groups;
+}
+
+char *
+getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
+{
+    if (ExtraSids!= 0) {
+        uint32_t ngroup;
+        uint32_t *pa;
+        char *ag;
+        size_t length;
+        int l;
+
+        align(4);
+        ngroup = get4byt();
+        if ( ngroup != SidCount) {
+            debug((char *) "%s| %s: ERROR: Group encoding error => SidCount: %d Array size: %d\n",
+                  LogTime(), PROGRAM, SidCount, ngroup);
+            return NULL;
+        }
+        debug((char *) "%s| %s: INFO: Found %d ExtraSIDs\n", LogTime(), PROGRAM, SidCount);
+
+        pa=(uint32_t *)xmalloc(SidCount*sizeof(uint32_t));
+        for ( l=0; l < (int)SidCount; l++ ) {
+            pa[l] = get4byt();
+            bpos = bpos+4; /* attr */
+        }
+
+        for ( l=0; l<(int)SidCount; l++ ) {
+            char es[256];
+            uint32_t nauth;
+            uint8_t rev;
+            uint64_t idauth;
+            uint32_t sauth;
+            int k;
+
+            if (pa[l] != 0) {
+                nauth = get4byt();
+
+                length = 1+1+6+nauth*4;
+                ag = (char *)xcalloc((length)*sizeof(char),1);
+                memcpy((void *)ag,(const void*)&p[bpos],length);
+                if (!ad_groups) {
+                    if (!xstrcpy(ad_groups,"group=")) {
+                        debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                              LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                    }
+                } else {
+                    if (!xstrcat(ad_groups," group=")) {
+                        debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                              LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                    }
+                }
+                if (!xstrcat(ad_groups,base64_encode_bin(ag, (int)length))) {
+                    debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                          LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                }
+                xfree(ag);
+
+                rev = get1byt();
+                bpos = bpos + 1; /* nsub */
+                idauth = get6byt_be();
+
+                snprintf(es,sizeof(es),"S-%d-%lu",rev,(long unsigned int)idauth);
+                for ( k=0; k<(int)nauth; k++ ) {
+                    sauth = get4byt();
+                    snprintf((char *)&es[strlen(es)],sizeof(es)-strlen(es),"-%u",sauth);
+                }
+                debug((char *) "%s| %s: INFO: Got ExtraSid %s\n", LogTime(), PROGRAM, es);
+            }
+        }
+        xfree(pa);
+    }
+    return ad_groups;
+}
+
+char *
+get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac)
+{
+    krb5_error_code ret;
+    RPC_UNICODE_STRING EffectiveName;
+    RPC_UNICODE_STRING FullName;
+    RPC_UNICODE_STRING LogonScript;
+    RPC_UNICODE_STRING ProfilePath;
+    RPC_UNICODE_STRING HomeDirectory;
+    RPC_UNICODE_STRING HomeDirectoryDrive;
+    RPC_UNICODE_STRING LogonServer;
+    RPC_UNICODE_STRING LogonDomainName;
+    uint32_t GroupCount=0;
+    uint32_t GroupIds=0;
+    uint32_t LogonDomainId=0;
+    uint32_t SidCount=0;
+    uint32_t ExtraSids=0;
+    /*
+    uint32_t ResourceGroupDomainSid=0;
+    uint32_t ResourceGroupCount=0;
+    uint32_t ResourceGroupIds=0;
+    */
+    char **Rids=NULL;
+    int l=0;
+
+    ad_data = (krb5_data *)xmalloc(sizeof(krb5_data));
+
+#define KERB_LOGON_INFO 1
+    ret = krb5_pac_get_buffer(context, pac, KERB_LOGON_INFO, ad_data);
+    if (check_k5_err(context, "krb5_pac_get_buffer", ret))
+        goto k5clean;
+
+    p = (unsigned char *)ad_data->data;
+
+    debug((char *) "%s| %s: INFO: Got PAC data of lengh %d\n",
+          LogTime(), PROGRAM, (int)ad_data->length);
+
+    /* Skip 16 bytes icommon RPC header
+     * Skip 4 bytes RPC unique pointer referent
+     * http://msdn.microsoft.com/en-gb/library/cc237933.aspx
+     */
+    /* Some data are pointers to data which follows the main KRB5 LOGON structure =>
+     *         So need to read the data
+     * some logical consistency checks are done when analysineg the pointer data
+     */
+    bpos = 20;
+    /* 8 bytes LogonTime
+     * 8 bytes LogoffTime
+     * 8 bytes KickOffTime
+     * 8 bytes PasswordLastSet
+     * 8 bytes PasswordCanChange
+     * 8 bytes PasswordMustChange
+     */
+    bpos = bpos+48;
+    getustr(&EffectiveName);
+    getustr(&FullName);
+    getustr(&LogonScript);
+    getustr(&ProfilePath);
+    getustr(&HomeDirectory);
+    getustr(&HomeDirectoryDrive);
+    /* 2 bytes LogonCount
+     * 2 bytes BadPasswordCount
+     * 4 bytes UserID
+     * 4 bytes PrimaryGroupId
+     */
+    bpos = bpos+12;
+    GroupCount = get4byt();
+    GroupIds = get4byt();
+    /* 4 bytes UserFlags
+     * 16 bytes UserSessionKey
+     */
+    bpos = bpos+20;
+    getustr(&LogonServer);
+    getustr(&LogonDomainName);
+    LogonDomainId = get4byt();
+    /* 8 bytes Reserved1
+     * 4 bytes UserAccountControl
+     * 4 bytes SubAuthStatus
+     * 8 bytes LastSuccessfullLogon
+     * 8 bytes LastFailedLogon
+     * 4 bytes FailedLogonCount
+     * 4 bytes Reserved2
+     */
+    bpos = bpos+40;
+    SidCount = get4byt();
+    ExtraSids = get4byt();
+    /* 4 bytes ResourceGroupDomainSid
+     * 4 bytes ResourceGroupCount
+     * 4 bytes ResourceGroupIds
+     */
+    bpos = bpos+12;
+    /*
+     * Read all data from structure => Now check pointers
+     */
+    if (checkustr(&EffectiveName)<0)
+        goto k5clean;
+    if (checkustr(&FullName)<0)
+        goto k5clean;
+    if (checkustr(&LogonScript)<0)
+        goto k5clean;
+    if (checkustr(&ProfilePath)<0)
+        goto k5clean;
+    if (checkustr(&HomeDirectory)<0)
+        goto k5clean;
+    if (checkustr(&HomeDirectoryDrive)<0)
+        goto k5clean;
+    Rids = getgids(Rids,GroupIds,GroupCount);
+    if (checkustr(&LogonServer)<0)
+        goto k5clean;
+    if (checkustr(&LogonDomainName)<0)
+        goto k5clean;
+    ad_groups = getdomaingids(ad_groups,LogonDomainId,Rids,GroupCount);
+    if ((ad_groups = getextrasids(ad_groups,ExtraSids,SidCount))==NULL)
+        goto k5clean;
+
+    debug((char *) "%s| %s: INFO: Read %d of %d bytes \n", LogTime(), PROGRAM, bpos, (int)ad_data->length);
+    if (Rids) {
+        for ( l=0; l<(int)GroupCount; l++) {
+            xfree(Rids[l]);
+        }
+        xfree(Rids);
+    }
+    krb5_free_data(context, ad_data);
+    return ad_groups;
+k5clean:
+    if (Rids) {
+        for ( l=0; l<(int)GroupCount; l++) {
+            xfree(Rids[l]);
+        }
+        xfree(Rids);
+    }
+    krb5_free_data(context, ad_data);
+    return NULL;
+}
+#endif
@@ -0,0 +1,7 @@
+#!/bin/bash
+if [[ -z "$1" ]]; then
+	echo "Need squid hostname"
+	exit 0
+fi
+dir=`dirname $0`
+$dir/negotiate_kerberos_auth_test $1 | awk '{sub(/Token:/,"YR"); print $0}END{print "QQ"}' | $dir/negotiate_kerberos_auth -d
@@ -46,9 +46,6 @@
 #if HAVE_TIME_H
 #include <time.h>
 #endif
-#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
@@ -224,15 +224,13 @@ main(int argc, char *argv[])
             } else if (ntlm_validate_packet(packet, NTLM_AUTHENTICATE) == NTLM_ERR_NONE) {
                 if (ntlm_unpack_auth((ntlm_authenticate *)packet, user, domain, decodedLen) == NTLM_ERR_NONE) {
                     lc(user);
-                    lc(domain);
                     if (strip_domain_enabled) {
                         SEND2("AF %s", user);
                     } else {
                         SEND4("AF %s%s%s", domain, (*domain?"\\":""), user);
                     }
                 } else {
                     lc(user);
-                    lc(domain);
                     SEND4("NA invalid credentials, user=%s%s%s", domain, (*domain?"\\":""), user);
                 }
             } else {
@@ -10,8 +10,8 @@ typedef int64_t snint;
 #endif
 
 #include "snmp.h"
-#include "snmp_impl.h"
 #include "snmp_api.h"
+#include "snmp_impl.h"
 
 /* MIB definitions
  * SQUID-MIB
@@ -43,20 +43,20 @@
 #include "snmp_session.h"
 
 /* The various modules */
-#include "snmp_vars.h"
-#include "snmp_pdu.h"
 #include "snmp_msg.h"
+#include "snmp_pdu.h"
+#include "snmp_vars.h"
 
 /* Other functions */
+#include "snmp_api_error.h"
 #include "snmp_coexist.h"
-#include "version.h"
 #include "snmp_error.h"
-#include "snmp_api_error.h"
+#include "version.h"
 /* Other stuff I didn't touch */
-#include "snmp_impl.h"
-#include "snmp_api.h"
-#include "snmp-internal.h"
 #include "parse.h"
+#include "snmp-internal.h"
+#include "snmp_api.h"
 #include "snmp_debug.h"
+#include "snmp_impl.h"
 
 #endif /* SQUID_SNMP_H */
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
-DIST_SUBDIRS = ntlmauth profiler rfcnb smblib libTrie
-SUBDIRS=
+DIST_SUBDIRS = ntlmauth profiler rfcnb smblib libTrie snmplib
+SUBDIRS=$(makesnmplib)
 EXTRA_DIST=
 
 if USE_ESI
@@ -148,7 +148,7 @@ register char *pc;
 int n;
 {
     for (; n--; pc++, a++)
-        *a = e[*pc];
+        *a = e[(int)*pc];
 }
 
 static void
@@ -164,7 +164,7 @@ register char *schl;
 
     for (i = 0; i < 8; i++) {
         for (j = 0, sbval = 0; j < 6; j++)
-            sbval = (sbval << 1) | (nachr_r[*e++] ^ *schl++);
+            sbval = (sbval << 1) | (nachr_r[(int)*e++] ^ *schl++);
         sbval = S_BOX[i][sbval];
         for (tp += 4, j = 4; j--; sbval >>= 1)
             *--tp = sbval & 1;
@@ -173,7 +173,7 @@ register char *schl;
 
     e = PERM;
     for (i = 0; i < BS2; i++)
-        *nachr_l++ ^= tmp[*e++];
+        *nachr_l++ ^= tmp[(int)*e++];
 }
 
 void
@@ -45,7 +45,7 @@ char *optarg;			/* argument associated with option */
 
 #define	BADCH	(int)'?'
 #define	BADARG	(int)':'
-#define	EMSG	""
+#define	EMSG	(char*)""
 
 /*
  * getopt --
@@ -22,8 +22,8 @@
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#include "TrieNode.h"
 #include "TrieCharTransform.h"
+#include "TrieNode.h"
 
 #if !_USE_INLINE_
 #include "Trie.cci"
@@ -18,8 +18,8 @@
  */
 
 #include "squid.h"
-#include "TrieNode.h"
 #include "TrieCharTransform.h"
+#include "TrieNode.h"
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -18,8 +18,8 @@
  */
 
 #ifdef __cplusplus
-#include "TrieNode.h"
 #include "TrieCharTransform.h"
+#include "TrieNode.h"
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -99,8 +99,6 @@ ntlm_validate_packet(const ntlmhdr * hdr, const int32_t type)
     return NTLM_ERR_NONE;
 }
 
-#define lstring_zero(s) s.str=NULL; s.l=-1;
-
 /**
  * Fetches a string from the authentication packet.
  * The lstring data-part may point to inside the packet itself or a temporary static buffer.
@@ -119,7 +117,8 @@ ntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr
     lstring rv;
     char *d;
 
-    lstring_zero(rv);
+    rv.str = NULL;
+    rv.l = -1;
 
     l = le16toh(str->len);
     o = le32toh(str->offset);
@@ -130,6 +129,7 @@ ntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr
         return rv;
     }
     rv.str = (char *)packet + o;
+    rv.l = 0;
     if ((flags & NTLM_NEGOTIATE_ASCII) == 0) {
         /* UNICODE string */
         unsigned short *s = (unsigned short *)rv.str;
@@ -45,8 +45,8 @@
 
 #include "squid.h"
 #include <string.h>
-#include "rfc2617.h"
 #include "md5.h"
+#include "rfc2617.h"
 
 void
 CvtHex(const HASH Bin, HASHHEX Hex)
@@ -1,6 +1,6 @@
 #include "squid.h"
-#include "rfc2671.h"
 #include "rfc1035.h"
+#include "rfc2671.h"
 
 int
 rfc2671RROptPack(char *buf, size_t sz, ssize_t edns_sz)
@@ -76,8 +76,8 @@
 #include <strings.h>
 #endif
 
-#include "rfc3596.h"
 #include "rfc2671.h"
+#include "rfc3596.h"
 
 #ifndef SQUID_RFC1035_H
 #error RFC3596 Library depends on RFC1035
@@ -26,7 +26,7 @@
 #ifndef _RFCNB_RFCNB_COMMON_H
 #define _RFCNB_RFCNB_COMMON_H
 
-#ifdef __cplusplus
+#if defined(__cplusplus)
 extern "C" {
 #endif
 
@@ -40,8 +40,7 @@ extern "C" {
 
     } RFCNB_Pkt;
 
-#ifdef __cplusplus
+#if defined(__cplusplus)
 }
-
 #endif
-#endif                          /* _RFCNB_RFCNB_COMMON_H */
+#endif /* _RFCNB_RFCNB_COMMON_H */
@@ -25,10 +25,10 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "rfcnb/std-includes.h"
+#include "rfcnb/rfcnb-io.h"
 #include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
-#include "rfcnb/rfcnb-io.h"
+#include "rfcnb/std-includes.h"
 #include <sys/uio.h>
 #include <sys/signal.h>
 
@@ -1,3 +1,6 @@
+#ifndef _SQUID__LIB_RFCNB_RFCNB_IO_H
+#define _SQUID__LIB_RFCNB_RFCNB_IO_H
+
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
  *
  * Version 1.0
@@ -23,6 +26,10 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "rfcnb/rfcnb.h"
+
 int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
 
 int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
+
+#endif
@@ -32,9 +32,13 @@ typedef unsigned short uint16;
 
 #define GLOBAL extern
 
-#include "rfcnb/rfcnb-error.h"
-#include "rfcnb/rfcnb-common.h"
 #include "rfcnb/byteorder.h"
+#include "rfcnb/rfcnb-common.h"
+#include "rfcnb/rfcnb-error.h"
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
 
 #ifdef RFCNB_PORT
 #define RFCNB_Default_Port RFCNB_PORT
@@ -25,11 +25,11 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "rfcnb/rfcnb.h"
-#include "rfcnb/std-includes.h"
+#include "rfcnb/rfcnb-io.h"
 #include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
-#include "rfcnb/rfcnb-io.h"
+#include "rfcnb/rfcnb.h"
+#include "rfcnb/std-includes.h"
 
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
@@ -1,3 +1,6 @@
+#ifndef _RFCNB_RFCNB_UTIL_H
+#define _RFCNB_RFCNB_UTIL_H
+
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
  *
  * Version 1.0
@@ -23,6 +26,8 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "rfcnb/std-includes.h"
+
 void RFCNB_CvtPad_Name(char *name1, char *name2);
 
 void RFCNB_AName_To_NBName(char *AName, char *NBName);
@@ -48,3 +53,5 @@ int RFCNB_Session_Req(struct RFCNB_Con *con,
 
 typedef void RFCNB_Prot_Print_Routine(FILE * fd, int dir, struct RFCNB_Pkt *pkt, int header, int payload);
 extern RFCNB_Prot_Print_Routine *Prot_Print_Routine;
+
+#endif /* _RFCNB_RFCNB_UTIL_H */
@@ -28,8 +28,8 @@
 
 /* Error responses */
 
-#include "rfcnb/rfcnb-error.h"
 #include "rfcnb/rfcnb-common.h"
+#include "rfcnb/rfcnb-error.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -31,10 +31,10 @@ int RFCNB_saved_errno = 0;
 
 #include "rfcnb/std-includes.h"
 #include <netinet/tcp.h>
-#include "rfcnb/rfcnb.h"
-#include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-io.h"
+#include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
+#include "rfcnb/rfcnb.h"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -84,7 +84,7 @@ RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address, int port
     /* Resolve that name into an IP address */
 
     Service_Address = Called_Name;
-    if (strcmp(Called_Address, "") != 0) {      /* If the Called Address = "" */
+    if (strlen(Called_Address) != 0) {      /* If the Called Address = "" */
         Service_Address = Called_Address;
     }
     if ((errno = RFCNB_Name_To_IP(Service_Address, &Dest_IP)) < 0) {    /* Error */
@@ -29,10 +29,16 @@
 #define BOOL int
 typedef short int16;
 
+#if HAVE_NETDB_H
 #include <netdb.h>
+#endif
 #include <sys/types.h>
+#if HAVE_NETINET_IN_H
 #include <netinet/in.h>
+#endif
+#if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
+#endif
 #include <signal.h>
 #include <errno.h>
 #include <stdio.h>
@@ -24,8 +24,8 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#include "smblib/smblib-priv.h"
 #include "rfcnb/rfcnb.h"
+#include "smblib/smblib-priv.h"
 
 #include <signal.h>
 #if HAVE_STRING_H
@@ -24,8 +24,8 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#include "smblib/smblib-priv.h"
 #include "rfcnb/rfcnb.h"
+#include "smblib/smblib-priv.h"
 
 #include <signal.h>
 #if HAVE_STRING_H
@@ -24,8 +24,8 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#include "smblib/smblib-priv.h"
 #include "rfcnb/rfcnb.h"
+#include "smblib/smblib-priv.h"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -24,8 +24,8 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#include "smblib/smblib-priv.h"
 #include "rfcnb/rfcnb.h"
+#include "smblib/smblib-priv.h"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -26,8 +26,8 @@
 #ifndef _SMBLIB_PRIV_H_
 #define _SMBLIB_PRIV_H_
 
-#include "smblib/std-defines.h"
 #include "smblib/smblib-common.h"
+#include "smblib/std-defines.h"
 #include <sys/types.h>
 #include <unistd.h>
 
@@ -25,9 +25,9 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-#include "smblib/smblib.h"
-#include "smblib/smblib-priv.h"
 #include "rfcnb/rfcnb.h"
+#include "smblib/smblib-priv.h"
+#include "smblib/smblib.h"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -29,9 +29,9 @@ int SMBlib_errno;
 int SMBlib_SMB_Error;
 #define SMBLIB_ERRNO
 
-#include "smblib/smblib.h"
-#include "smblib/smblib-priv.h"
 #include "rfcnb/rfcnb.h"
+#include "smblib/smblib-priv.h"
+#include "smblib/smblib.h"
 
 #include <signal.h>
 #if HAVE_STRING_H
@@ -152,7 +152,7 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
-    if (strcmp(con -> address, "") == 0)
+    if (strlen(con -> address) == 0)
         address = con -> desthost;
     else
         address = con -> address;
@@ -268,7 +268,7 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
-    if (strcmp(con -> address, "") == 0)
+    if (strlen(con -> address) == 0)
         address = con -> desthost;
     else
         address = con -> address;
@@ -26,9 +26,9 @@
 #ifndef _SMBLIB_SMBLIB_H
 #define _SMBLIB_SMBLIB_H
 
-#include "std-defines.h"
 #include "smblib-common.h"
 #include "smblib/smbencrypt.h"
+#include "std-defines.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -76,12 +76,12 @@
 #include <netdb.h>
 #endif
 
-#include "snmp.h"
 #include "asn1.h"
-#include "snmp_vars.h"
-#include "snmp_pdu.h"
-#include "snmp_error.h"
+#include "snmp.h"
 #include "snmp_api_error.h"
+#include "snmp_error.h"
+#include "snmp_pdu.h"
+#include "snmp_vars.h"
 
 #include "util.h"
 
@@ -74,12 +74,12 @@ SOFTWARE.
 #include "asn1.h"
 #include "snmp.h"
 
+#include "parse.h"
+#include "snmp_api.h"
+#include "snmp_impl.h"
 #include "snmp_pdu.h"
-#include "snmp_vars.h"
 #include "snmp_session.h"
-#include "snmp_impl.h"
-#include "snmp_api.h"
-#include "parse.h"
+#include "snmp_vars.h"
 
 #include "util.h"
 
@@ -76,12 +76,12 @@
 #include "snmp.h"
 
 #include "snmp-internal.h"
+#include "snmp_error.h"
 #include "snmp_impl.h"
+#include "snmp_msg.h"
+#include "snmp_pdu.h"
 #include "snmp_session.h"
-#include "snmp_error.h"
 #include "snmp_vars.h"
-#include "snmp_pdu.h"
-#include "snmp_msg.h"
 
 #include "snmp_api.h"
 #include "snmp_api_error.h"
@@ -82,11 +82,11 @@
 #include <netdb.h>
 #endif
 
-#include "snmp.h"
 #include "asn1.h"
-#include "snmp_vars.h"
-#include "snmp_pdu.h"
+#include "snmp.h"
 #include "snmp_msg.h"
+#include "snmp_pdu.h"
+#include "snmp_vars.h"
 
 /*
  * RFC 1901: Introduction to Community-based SNMPv2
@@ -82,13 +82,13 @@
 #include <netdb.h>
 #endif
 
-#include "snmp.h"
 #include "asn1.h"
+#include "snmp.h"
+#include "snmp_api_error.h"
 #include "snmp_error.h"
-#include "snmp_vars.h"
-#include "snmp_pdu.h"
 #include "snmp_msg.h"
-#include "snmp_api_error.h"
+#include "snmp_pdu.h"
+#include "snmp_vars.h"
 
 #include "util.h"
 
@@ -81,15 +81,15 @@
 #include <netdb.h>
 #endif
 
-#include "snmp.h"
 #include "asn1.h"
+#include "snmp.h"
 #include "snmp_vars.h"
 #if 0
 #include "mibii.h"
 #endif
 #include "snmp_api_error.h"
-#include "snmp_pdu.h"
 #include "snmp_msg.h"
+#include "snmp_pdu.h"
 
 #include "util.h"
 
@@ -96,27 +96,30 @@ make_snapshot()
 set +e
 
 # autotool derived files not kept in trunk, but still need to bootstrap for make dist
-../commit/bootstrap squid-3
-make_snapshot ../commit/squid-3/mksnapshot.sh trunk v3 3.HEAD 6
-
-rm -f /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new
-cp ../commit/squid-3/CONTRIBUTORS /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new
-chmod 444 /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new
-mv -f /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new /server/httpd/htdocs/squid-cache.org/content/CONTRIBUTORS.txt
-
-rm -f /server/httpd/htdocs/squid-cache.org/SPONSORS.new
-cp ../commit/squid-3/SPONSORS /server/httpd/htdocs/squid-cache.org/SPONSORS.new
-chmod 444 /server/httpd/htdocs/squid-cache.org/SPONSORS.new
-mv -f /server/httpd/htdocs/squid-cache.org/SPONSORS.new /server/httpd/htdocs/squid-cache.org/content/SPONSORS.txt
+#../commit/bootstrap squid-3
+#make_snapshot ../commit/squid-3/mksnapshot.sh trunk v3 3.HEAD 6
+
+#rm -f /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new
+#cp ../commit/squid-3/CONTRIBUTORS /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new
+#chmod 444 /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new
+#mv -f /server/httpd/htdocs/squid-cache.org/CONTRIBUTORS.new /server/httpd/htdocs/squid-cache.org/content/CONTRIBUTORS.txt
+#
+#rm -f /server/httpd/htdocs/squid-cache.org/SPONSORS.new
+#cp ../commit/squid-3/SPONSORS /server/httpd/htdocs/squid-cache.org/SPONSORS.new
+#chmod 444 /server/httpd/htdocs/squid-cache.org/SPONSORS.new
+#mv -f /server/httpd/htdocs/squid-cache.org/SPONSORS.new /server/httpd/htdocs/squid-cache.org/content/SPONSORS.txt
+
+../commit/bootstrap squid-3.4
+make_snapshot ../commit/squid-3/mksnapshot.sh 3.4 v3 3.4 30
 
 ../commit/bootstrap squid-3.3
 make_snapshot ../commit/squid-3/mksnapshot.sh 3.3 v3 3.3 30
 
-../commit/bootstrap squid-3.2
-make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_2 v3 3.2 30
+#../commit/bootstrap squid-3.2
+#make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_2 v3 3.2 30
 
-../commit/bootstrap squid-3.1
-make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_1 v3 3.1 30
+#../commit/bootstrap squid-3.1
+#make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_1 v3 3.1 30
 
 #../commit/bootstrap squid-3.0
 #make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_0 v3 3.0 3
@@ -67,6 +67,17 @@ for FILENAME in `ls -1`; do
         	fi
 	fi
 
+	${ROOT}/scripts/sort-includes.pl ${FILENAME} >${FILENAME}.sorted
+	if test -e ${FILENAME} -a -e "${FILENAME}.sorted"; then
+		md51=`cat  ${FILENAME}| tr -d "\n \t\r" | $MD5`;
+		md52=`cat  ${FILENAME}.sorted| tr -d "\n \t\r" | $MD5`;
+
+		if test "$md51" != "$md52" ; then
+			echo "NOTICE: File $PWD/${FILENAME} changed #include order"
+		fi
+		mv ${FILENAME}.sorted ${FILENAME}
+	fi
+
 	#
 	# REQUIRE squid.h first #include
 	#
@@ -790,7 +790,7 @@ HTML_HEADER            = ./doc/Programming-Guide/doxygen.header.dyn
 # each generated HTML page. If it is left blank doxygen will generate a 
 # standard footer.
 
-#HTML_FOOTER            = ./doc/Programming-Guide/doxygen.footer.dyn
+HTML_FOOTER            = ./doc/Programming-Guide/doxygen.footer.dyn
 
 # The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
 # style sheet that is used by each HTML page. It can be used to 
@@ -1266,7 +1266,6 @@ PREDEFINED             = __cplusplus \
                          USE_CLASSFUL \
                          USE_DELAY_POOLS \
                          USE_DLMALLOC \
-                         USE_DNSHELPER \
                          USE_EPOLL \
                          USE_GNUREGEX \
                          USE_HEXDUMP \
@@ -33,13 +33,14 @@
 #include "anyp/PortCfg.h"
 #include "base/RefCount.h"
 #include "comm/Connection.h"
-#include "HttpHeader.h"
+#include "HierarchyLogEntry.h"
 #include "http/ProtocolVersion.h"
+#include "HttpHeader.h"
 #include "HttpRequestMethod.h"
-#include "HierarchyLogEntry.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
 #include "LogTags.h"
+#include "MessageSizes.h"
 #include "Notes.h"
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
@@ -84,7 +85,10 @@ class AccessLogEntry: public RefCountable
 
     public:
         HttpDetails() : method(Http::METHOD_NONE), code(0), content_type(NULL),
-                timedout(false), aborted(false) {}
+                timedout(false),
+                aborted(false),
+                clientRequestSz(),
+                clientReplySz() {}
 
         HttpRequestMethod method;
         int code;
@@ -97,6 +101,17 @@ class AccessLogEntry: public RefCountable
         const char *statusSfx() const {
             return timedout ? "_TIMEDOUT" : (aborted ? "_ABORTED" : "");
         }
+
+        /// counters for the original request received from client
+        // TODO calculate header and payload better (by parser)
+        // XXX payload encoding overheads not calculated at all yet.
+        MessageSizes clientRequestSz;
+
+        /// counters for the response sent to client
+        // TODO calculate header and payload better (by parser)
+        // XXX payload encoding overheads not calculated at all yet.
+        MessageSizes clientReplySz;
+
     } http;
 
     /** \brief This subclass holds log info for ICP protocol
@@ -144,10 +159,6 @@ class AccessLogEntry: public RefCountable
 
     public:
         CacheDetails() : caddr(),
-                requestSize(0),
-                replySize(0),
-                requestHeadersSize(0),
-                replyHeadersSize(0),
                 highOffset(0),
                 objectSize(0),
                 code (LOG_TAG_NONE),
@@ -158,17 +169,14 @@ class AccessLogEntry: public RefCountable
                 ssluser(NULL),
 #endif
                 port(NULL) {
-            ;
+            caddr.setNoAddr();
         }
 
         Ip::Address caddr;
-        int64_t requestSize;
-        int64_t replySize;
-        int requestHeadersSize; ///< received, including request line
-        int replyHeadersSize; ///< sent, including status line
         int64_t highOffset;
         int64_t objectSize;
         LogTags code;
+        struct timeval start_time; ///< The time the master transaction started
         int msec;
         const char *rfc931;
         const char *extuser;
@@ -5,6 +5,10 @@
     does not get linked in, because nobody is using these classes by name.
 */
 
+#if USE_ADAPTATION
+#include "acl/AdaptationService.h"
+#include "acl/AdaptationServiceData.h"
+#endif
 #include "acl/AllOf.h"
 #include "acl/AnyOf.h"
 #if USE_SQUID_EUI
@@ -24,8 +28,8 @@
 #endif
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
-#include "acl/HierCodeData.h"
 #include "acl/HierCode.h"
+#include "acl/HierCodeData.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/HttpRepHeader.h"
 #include "acl/HttpReqHeader.h"
@@ -35,14 +39,14 @@
 #include "acl/LocalIp.h"
 #include "acl/LocalPort.h"
 #include "acl/MaxConnection.h"
-#include "acl/MethodData.h"
 #include "acl/Method.h"
+#include "acl/MethodData.h"
 #include "acl/MyPortName.h"
 #include "acl/Note.h"
 #include "acl/NoteData.h"
 #include "acl/PeerName.h"
-#include "acl/ProtocolData.h"
 #include "acl/Protocol.h"
+#include "acl/ProtocolData.h"
 #include "acl/Random.h"
 #include "acl/Referer.h"
 #include "acl/RegexData.h"
@@ -54,10 +58,10 @@
 #include "acl/SourceDomain.h"
 #include "acl/SourceIp.h"
 #if USE_SSL
-#include "acl/SslErrorData.h"
-#include "acl/SslError.h"
-#include "acl/CertificateData.h"
 #include "acl/Certificate.h"
+#include "acl/CertificateData.h"
+#include "acl/SslError.h"
+#include "acl/SslErrorData.h"
 #endif
 #include "acl/Strategised.h"
 #include "acl/Strategy.h"
@@ -66,16 +70,16 @@
 #include "acl/ServerCertificate.h"
 #endif
 #include "acl/Tag.h"
-#include "acl/TimeData.h"
 #include "acl/Time.h"
+#include "acl/TimeData.h"
 #include "acl/Url.h"
 #include "acl/UrlLogin.h"
 #include "acl/UrlPath.h"
 #include "acl/UrlPort.h"
 #include "acl/UserData.h"
 #if USE_AUTH
-#include "auth/AclProxyAuth.h"
 #include "auth/AclMaxUserIp.h"
+#include "auth/AclProxyAuth.h"
 #endif
 #if USE_IDENT
 #include "ident/AclIdent.h"
@@ -193,3 +197,8 @@ Acl::AllOf Acl::AllOf::RegistryEntry_;
 
 ACL::Prototype ACLNote::RegistryProtoype(&ACLNote::RegistryEntry_, "note");
 ACLStrategised<HttpRequest *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteStrategy::Instance(), "note");
+
+#if USE_ADAPTATION
+ACL::Prototype ACLAdaptationService::RegistryProtoype(&ACLAdaptationService::RegistryEntry_, "adaptation_service");
+ACLStrategised<const char *> ACLAdaptationService::RegistryEntry_(new ACLAdaptationServiceData, ACLAdaptationServiceStrategy::Instance(), "adaptation_service");
+#endif
@@ -1,9 +1,9 @@
 #ifndef SQUID_BODY_PIPE_H
 #define SQUID_BODY_PIPE_H
 
-#include "MemBuf.h"
 #include "base/AsyncJob.h"
 #include "base/CbcPointer.h"
+#include "MemBuf.h"
 
 class BodyPipe;
 
@@ -1,9 +1,9 @@
 #include "squid.h"
 #include "base/TextException.h"
-#include "Debug.h"
-#include "Parsing.h"
 #include "ChunkedCodingParser.h"
+#include "Debug.h"
 #include "MemBuf.h"
+#include "Parsing.h"
 
 ChunkedCodingParser::Step ChunkedCodingParser::psChunkSize = &ChunkedCodingParser::parseChunkSize;
 ChunkedCodingParser::Step ChunkedCodingParser::psUnusedChunkExtension = &ChunkedCodingParser::parseUnusedChunkExtension;
@@ -1,12 +1,12 @@
 #ifndef SQUID__SRC_CLIENTINFO_H
 #define SQUID__SRC_CLIENTINFO_H
 
-#include "ip/Address.h"
+#include "cbdata.h"
+#include "enums.h"
 #include "hash.h"
+#include "ip/Address.h"
 #include "LogTags.h"
-#include "enums.h"
 #include "typedefs.h"
-#include "cbdata.h"
 #include <deque>
 
 #if USE_DELAY_POOLS
@@ -3,8 +3,8 @@
 
 #include "base/AsyncCall.h"
 #include "base/AsyncJobCalls.h"
-#include "comm_err_t.h"
 #include "comm/forward.h"
+#include "comm_err_t.h"
 #include "MasterXaction.h"
 
 /* CommCalls implement AsyncCall interface for comm_* callbacks.
@@ -34,10 +34,10 @@
 #ifndef COMMREAD_H
 #define COMMREAD_H
 
+#include "CbDataList.h"
 #include "comm.h"
-#include "CommCalls.h"
 #include "comm/forward.h"
-#include "CbDataList.h"
+#include "CommCalls.h"
 
 class CommRead
 {
@@ -37,8 +37,8 @@
 #define COMMONPOOL_H
 
 #if USE_DELAY_POOLS
-#include "SquidString.h"
 #include "CompositePoolNode.h"
+#include "SquidString.h"
 
 /*
  \ingroup DelayPoolsAPI
@@ -38,68 +38,103 @@
 #include "fatal.h"
 #include "globals.h"
 
-char *ConfigParser::lastToken = NULL;
-std::queue<std::string> ConfigParser::undo;
+bool ConfigParser::RecognizeQuotedValues = true;
+bool ConfigParser::StrictMode = true;
+std::stack<ConfigParser::CfgFile *> ConfigParser::CfgFiles;
+ConfigParser::TokenType ConfigParser::LastTokenType = ConfigParser::SimpleToken;
+const char *ConfigParser::CfgLine = NULL;
+const char *ConfigParser::CfgPos = NULL;
+std::queue<char *> ConfigParser::CfgLineTokens_;
+std::queue<std::string> ConfigParser::Undo_;
+bool ConfigParser::AllowMacros_ = false;
+bool ConfigParser::ParseQuotedOrToEol_ = false;
+bool ConfigParser::PreviewMode_ = false;
+
+static const char *SQUID_ERROR_TOKEN = "[invalid token]";
 
 void
 ConfigParser::destruct()
 {
     shutting_down = 1;
-    fatalf("Bungled %s line %d: %s",
-           cfg_filename, config_lineno, config_input_line);
+    if (!CfgFiles.empty()) {
+        std::ostringstream message;
+        CfgFile *f = CfgFiles.top();
+        message << "Bungled " << f->filePath << " line " << f->lineNo <<
+        ": " << f->currentLine << std::endl;
+        CfgFiles.pop();
+        delete f;
+        while (!CfgFiles.empty()) {
+            f = CfgFiles.top();
+            message << " included from " << f->filePath << " line " <<
+            f->lineNo << ": " << f->currentLine << std::endl;
+            CfgFiles.pop();
+            delete f;
+        }
+        message << " included from " <<  cfg_filename << " line " <<
+        config_lineno << ": " << config_input_line << std::endl;
+        std::string msg = message.str();
+        fatalf("%s", msg.c_str());
+    } else
+        fatalf("Bungled %s line %d: %s",
+               cfg_filename, config_lineno, config_input_line);
 }
 
 void
-ConfigParser::strtokFileUndo()
+ConfigParser::TokenPutBack(const char *tok)
 {
-    assert(lastToken);
-    undo.push(lastToken);
+    assert(tok);
+    Undo_.push(tok);
 }
 
-void
-ConfigParser::strtokFilePutBack(const char *tok)
+char *
+ConfigParser::Undo()
 {
-    assert(tok);
-    undo.push(tok);
+    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
+    if (!Undo_.empty()) {
+        strncpy(undoToken, Undo_.front().c_str(), sizeof(undoToken));
+        undoToken[sizeof(undoToken) - 1] = '\0';
+        if (!PreviewMode_)
+            Undo_.pop();
+        return undoToken;
+    }
+    return NULL;
 }
 
 char *
-ConfigParser::strtokFile(void)
+ConfigParser::strtokFile()
 {
+    if (RecognizeQuotedValues)
+        return ConfigParser::NextToken();
+
     static int fromFile = 0;
     static FILE *wordFile = NULL;
-    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
 
-    char *t, *fn;
+    char *t;
     LOCAL_ARRAY(char, buf, CONFIG_LINE_LIMIT);
 
-    if (!undo.empty()) {
-        strncpy(undoToken, undo.front().c_str(), sizeof(undoToken));
-        undoToken[sizeof(undoToken) - 1] = '\0';
-        undo.pop();
-        return undoToken;
-    }
+    if ((t = ConfigParser::Undo()))
+        return t;
 
-    lastToken = NULL;
     do {
 
         if (!fromFile) {
-            t = (strtok(NULL, w_space));
-
-            if (!t || *t == '#') {
+            ConfigParser::TokenType tokenType;
+            t = ConfigParser::NextElement(tokenType);
+            if (!t) {
                 return NULL;
             } else if (*t == '\"' || *t == '\'') {
                 /* quote found, start reading from file */
-                fn = ++t;
+                debugs(3, 8,"Quoted token found : " << t);
+                char *fn = ++t;
 
                 while (*t && *t != '\"' && *t != '\'')
                     ++t;
 
                 *t = '\0';
 
                 if ((wordFile = fopen(fn, "r")) == NULL) {
-                    debugs(28, DBG_CRITICAL, "strtokFile: " << fn << " not found");
-                    return (NULL);
+                    debugs(3, DBG_CRITICAL, "Can not open file " << t << " for reading");
+                    return NULL;
                 }
 
 #if _SQUID_WINDOWS_
@@ -108,7 +143,7 @@ ConfigParser::strtokFile(void)
 
                 fromFile = 1;
             } else {
-                return lastToken = t;
+                return t;
             }
         }
 
@@ -139,52 +174,313 @@ ConfigParser::strtokFile(void)
         /* skip blank lines */
     } while ( *t == '#' || !*t );
 
-    return lastToken = t;
+    return t;
 }
 
-void
-ConfigParser::ParseQuotedString(char **var, bool *wasQuoted)
+char *
+ConfigParser::UnQuote(const char *token, const char **next)
 {
-    String sVar;
-    ParseQuotedString(&sVar, wasQuoted);
-    *var = xstrdup(sVar.termedBuf());
+    const char *errorStr = NULL;
+    const char *errorPos = NULL;
+    char quoteChar = *token;
+    assert(quoteChar == '"' || quoteChar == '\'');
+    LOCAL_ARRAY(char, UnQuoted, CONFIG_LINE_LIMIT);
+    const char  *s = token + 1;
+    char *d = UnQuoted;
+    /* scan until the end of the quoted string, handling escape sequences*/
+    while (*s && *s != quoteChar && !errorStr && (size_t)(d - UnQuoted) < sizeof(UnQuoted)) {
+        if (*s == '\\') {
+            s++;
+            switch (*s) {
+            case 'r':
+                *d = '\r';
+                break;
+            case 'n':
+                *d = '\n';
+                break;
+            case 't':
+                *d = '\t';
+                break;
+            default:
+                if (isalnum(*s)) {
+                    errorStr = "Unsupported escape sequence";
+                    errorPos = s;
+                }
+                *d = *s;
+                break;
+            }
+#if 0
+        } else if (*s == '$' && quoteChar == '"') {
+            errorStr = "Unsupported cfg macro";
+            errorPos = s;
+#endif
+#if 0
+        } else if (*s == '%' && quoteChar == '"' && (!AllowMacros_ )) {
+            errorStr = "Macros are not supported here";
+            errorPos = s;
+#endif
+        } else
+            *d = *s;
+        ++s;
+        ++d;
+    }
+
+    if (*s != quoteChar && !errorStr) {
+        errorStr = "missing quote char at the end of quoted string";
+        errorPos = s - 1;
+    }
+    // The end of token
+    *d = '\0';
+
+    // We are expecting a separator after quoted string, space or one of "()#"
+    if (*(s + 1) != '\0' && !strchr(w_space "()#", *(s + 1)) && !errorStr) {
+        errorStr = "Expecting space after the end of quoted token";
+        errorPos = token;
+    }
+
+    if (errorStr) {
+        if (PreviewMode_)
+            strncpy(UnQuoted, SQUID_ERROR_TOKEN, sizeof(UnQuoted));
+        else {
+            debugs(3, DBG_CRITICAL, errorStr << ": " << errorPos);
+            self_destruct();
+        }
+    }
+
+    if (next)
+        *next = s + 1;
+    return UnQuoted;
 }
 
 void
-ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
+ConfigParser::SetCfgLine(char *line)
 {
-    // Get all of the remaining string
-    char *token = strtok(NULL, "");
-    if (token == NULL)
-        self_destruct();
+    CfgLine = line;
+    CfgPos = line;
+    while (!CfgLineTokens_.empty()) {
+        char *token = CfgLineTokens_.front();
+        CfgLineTokens_.pop();
+        free(token);
+    }
+}
 
-    if (*token != '"') {
-        token = strtok(token, w_space);
-        var->reset(token);
-        if (wasQuoted)
-            *wasQuoted = false;
-        return;
-    } else if (wasQuoted)
-        *wasQuoted = true;
-
-    char  *s = token + 1;
-    /* scan until the end of the quoted string, unescaping " and \  */
-    while (*s && *s != '"') {
-        if (*s == '\\') {
-            const char * next = s+1; // may point to 0
-            memmove(s, next, strlen(next) + 1);
+char *
+ConfigParser::TokenParse(const char * &nextToken, ConfigParser::TokenType &type)
+{
+    if (!nextToken || *nextToken == '\0')
+        return NULL;
+    type = ConfigParser::SimpleToken;
+    nextToken += strspn(nextToken, w_space);
+
+    if (*nextToken == '#')
+        return NULL;
+
+    if (ConfigParser::RecognizeQuotedValues && (*nextToken == '"' || *nextToken == '\'')) {
+        type = ConfigParser::QuotedToken;
+        char *token = xstrdup(UnQuote(nextToken, &nextToken));
+        CfgLineTokens_.push(token);
+        return token;
+    }
+
+    const char *tokenStart = nextToken;
+    const char *sep;
+    if (ConfigParser::ParseQuotedOrToEol_)
+        sep = "\n";
+    else if (!ConfigParser::RecognizeQuotedValues || *nextToken == '(')
+        sep = w_space;
+    else
+        sep = w_space "(";
+    nextToken += strcspn(nextToken, sep);
+
+    if (ConfigParser::RecognizeQuotedValues && *nextToken == '(') {
+        if (strncmp(tokenStart, "parameters", nextToken - tokenStart) == 0)
+            type = ConfigParser::FunctionParameters;
+        else {
+            if (PreviewMode_) {
+                char *err = xstrdup(SQUID_ERROR_TOKEN);
+                CfgLineTokens_.push(err);
+                return err;
+            } else {
+                debugs(3, DBG_CRITICAL, "Unknown cfg function: " << tokenStart);
+                self_destruct();
+            }
         }
-        ++s;
+    } else
+        type = ConfigParser::SimpleToken;
+
+    char *token = NULL;
+    if (nextToken - tokenStart) {
+        if (ConfigParser::StrictMode && type == ConfigParser::SimpleToken) {
+            bool tokenIsNumber = true;
+            for (const char *s = tokenStart; s != nextToken; ++s) {
+                const bool isValidChar = isalnum(*s) || strchr(".,()-=_/:", *s) ||
+                                         (tokenIsNumber && *s == '%' && (s + 1 == nextToken));
+
+                if (!isdigit(*s))
+                    tokenIsNumber = false;
+
+                if (!isValidChar) {
+                    if (PreviewMode_) {
+                        char *err = xstrdup(SQUID_ERROR_TOKEN);
+                        CfgLineTokens_.push(err);
+                        return err;
+                    } else {
+                        debugs(3, DBG_CRITICAL, "Not alphanumeric character '"<< *s << "' in unquoted token " << tokenStart);
+                        self_destruct();
+                    }
+                }
+            }
+        }
+        token = xstrndup(tokenStart, nextToken - tokenStart + 1);
+        CfgLineTokens_.push(token);
+    }
+
+    if (*nextToken != '\0' && *nextToken != '#') {
+        ++nextToken;
+    }
+
+    return token;
+}
+
+char *
+ConfigParser::NextElement(ConfigParser::TokenType &type)
+{
+    const char *pos = CfgPos;
+    char *token = TokenParse(pos, type);
+    // If not in preview mode the next call of this method should start
+    // parsing after the end of current token.
+    // For function "parameters(...)" we need always to update current parsing
+    // position to allow parser read the arguments of "parameters(..)"
+    if (!PreviewMode_ || type == FunctionParameters)
+        CfgPos = pos;
+    // else next call will read the same token
+    return token;
+}
+
+char *
+ConfigParser::NextToken()
+{
+    char *token = NULL;
+    if ((token = ConfigParser::Undo())) {
+        debugs(3, 6, "TOKEN (undone): " << token);
+        return token;
+    }
+
+    do {
+        while (token == NULL && !CfgFiles.empty()) {
+            ConfigParser::CfgFile *wordfile = CfgFiles.top();
+            token = wordfile->parse(LastTokenType);
+            if (!token) {
+                assert(!wordfile->isOpen());
+                CfgFiles.pop();
+                debugs(3, 4, "CfgFiles.pop " << wordfile->filePath);
+                delete wordfile;
+            }
+        }
+
+        if (!token)
+            token = NextElement(LastTokenType);
+
+        if (token &&  LastTokenType == ConfigParser::FunctionParameters) {
+            //Disable temporary preview mode, we need to parse function parameters
+            const bool savePreview = ConfigParser::PreviewMode_;
+            ConfigParser::PreviewMode_ = false;
+
+            char *path = NextToken();
+            if (LastTokenType != ConfigParser::QuotedToken) {
+                debugs(3, DBG_CRITICAL, "Quoted filename missing: " << token);
+                self_destruct();
+                return NULL;
+            }
+
+            // The next token in current cfg file line must be a ")"
+            char *end = NextToken();
+            ConfigParser::PreviewMode_ = savePreview;
+            if (LastTokenType != ConfigParser::SimpleToken || strcmp(end, ")") != 0) {
+                debugs(3, DBG_CRITICAL, "missing ')' after " << token << "(\"" << path << "\"");
+                self_destruct();
+                return NULL;
+            }
+
+            if (CfgFiles.size() > 16) {
+                debugs(3, DBG_CRITICAL, "WARNING: can't open %s for reading parameters: includes are nested too deeply (>16)!\n" << path);
+                self_destruct();
+                return NULL;
+            }
+
+            ConfigParser::CfgFile *wordfile = new ConfigParser::CfgFile();
+            if (!path || !wordfile->startParse(path)) {
+                debugs(3, DBG_CRITICAL, "Error opening config file: " << token);
+                delete wordfile;
+                self_destruct();
+                return NULL;
+            }
+            CfgFiles.push(wordfile);
+            token = NULL;
+        }
+    } while (token == NULL && !CfgFiles.empty());
+
+    return token;
+}
+
+char *
+ConfigParser::PeekAtToken()
+{
+    PreviewMode_ = true;
+    char *token = NextToken();
+    PreviewMode_ = false;
+    return token;
+}
+
+char *
+ConfigParser::NextQuotedOrToEol()
+{
+    ParseQuotedOrToEol_ = true;
+    char *token = NextToken();
+    ParseQuotedOrToEol_ = false;
+
+    // Assume end of current config line
+    // Close all open configuration files for this config line
+    while (!CfgFiles.empty()) {
+        ConfigParser::CfgFile *wordfile = CfgFiles.top();
+        CfgFiles.pop();
+        delete wordfile;
+    }
+
+    return token;
+}
+
+char *
+ConfigParser::RegexStrtokFile()
+{
+    if (ConfigParser::RecognizeQuotedValues) {
+        debugs(3, DBG_CRITICAL, "Can not read regex expresion while configuration_includes_quoted_values is enabled");
+        self_destruct();
     }
+    char * token = strtokFile();
+    return token;
+}
 
-    if (*s != '"') {
-        debugs(3, DBG_CRITICAL, "ParseQuotedString: missing '\"' at the end of quoted string" );
+char *
+ConfigParser::RegexPattern()
+{
+    if (ConfigParser::RecognizeQuotedValues) {
+        debugs(3, DBG_CRITICAL, "Can not read regex expresion while configuration_includes_quoted_values is enabled");
         self_destruct();
     }
-    strtok(s-1, "\""); /*Reset the strtok to point after the "  */
-    *s = '\0';
 
-    var->reset(token+1);
+    char * token = NextToken();
+    return token;
+}
+
+char *
+ConfigParser::NextQuotedToken()
+{
+    const bool saveRecognizeQuotedValues = ConfigParser::RecognizeQuotedValues;
+    ConfigParser::RecognizeQuotedValues = true;
+    char *token = NextToken();
+    ConfigParser::RecognizeQuotedValues = saveRecognizeQuotedValues;
+    return token;
 }
 
 const char *
@@ -210,3 +506,72 @@ ConfigParser::QuoteString(const String &var)
     quotedStr.append('"');
     return quotedStr.termedBuf();
 }
+
+bool
+ConfigParser::CfgFile::startParse(char *path)
+{
+    assert(wordFile == NULL);
+    debugs(3, 3, "Parsing from " << path);
+    if ((wordFile = fopen(path, "r")) == NULL) {
+        debugs(3, DBG_CRITICAL, "file :" << path << " not found");
+        return false;
+    }
+
+#if _SQUID_WINDOWS_
+    setmode(fileno(wordFile), O_TEXT);
+#endif
+
+    filePath = path;
+    return getFileLine();
+}
+
+bool
+ConfigParser::CfgFile::getFileLine()
+{
+    // Else get the next line
+    if (fgets(parseBuffer, CONFIG_LINE_LIMIT, wordFile) == NULL) {
+        /* stop reading from file */
+        fclose(wordFile);
+        wordFile = NULL;
+        parseBuffer[0] = '\0';
+        return false;
+    }
+    parsePos = parseBuffer;
+    currentLine = parseBuffer;
+    lineNo++;
+    return true;
+}
+
+char *
+ConfigParser::CfgFile::parse(ConfigParser::TokenType &type)
+{
+    if (!wordFile)
+        return NULL;
+
+    if (!*parseBuffer)
+        return NULL;
+
+    char *token;
+    while (!(token = nextElement(type))) {
+        if (!getFileLine())
+            return NULL;
+    }
+    return token;
+}
+
+char *
+ConfigParser::CfgFile::nextElement(ConfigParser::TokenType &type)
+{
+    const char *pos = parsePos;
+    char *token = TokenParse(pos, type);
+    if (!PreviewMode_ || type == FunctionParameters)
+        parsePos = pos;
+    // else next call will read the same token;
+    return token;
+}
+
+ConfigParser::CfgFile::~CfgFile()
+{
+    if (wordFile)
+        fclose(wordFile);
+}
@@ -36,6 +36,7 @@
 
 #include "SquidString.h"
 #include <queue>
+#include <stack>
 #if HAVE_STRING
 #include <string>
 #endif
@@ -65,26 +66,168 @@ class ConfigParser
 {
 
 public:
+    /**
+     * Parsed tokens type: simple tokens, quoted tokens or function
+     * like parameters.
+     */
+    enum TokenType {SimpleToken, QuotedToken, FunctionParameters};
+
     void destruct();
     static void ParseUShort(unsigned short *var);
     static void ParseBool(bool *var);
-    static void ParseString(char **var);
-    static void ParseString(String *var);
-    /// Parse an unquoted token (no spaces) or a "quoted string" that
-    /// may include spaces. In some contexts, quotes strings may also
-    /// include macros. Quoted strings may escape any character with
-    /// a backslash (\), which is currently only useful for inner
-    /// quotes. TODO: support quoted strings anywhere a token is accepted.
-    static void ParseQuotedString(char **var, bool *wasQuoted = NULL);
-    static void ParseQuotedString(String *var, bool *wasQuoted = NULL);
     static const char *QuoteString(const String &var);
     static void ParseWordList(wordlist **list);
+
+    /**
+     * Backward compatibility wrapper for the ConfigParser::NextToken method.
+     * If the configuration_includes_quoted_values configuration parameter is
+     * set to 'off' this interprets the quoted tokens as filenames.
+     */
     static char * strtokFile();
-    static void strtokFileUndo();
-    static void strtokFilePutBack(const char *);
-private:
-    static char *lastToken;
-    static std::queue<std::string> undo;
+
+    /**
+     * Returns the body of the next element. The element is either a token or
+     * a quoted string with optional escape sequences and/or macros. The body
+     * of a quoted string element does not include quotes or escape sequences.
+     * Future code will want to see Elements and not just their bodies.
+     */
+    static char *NextToken();
+
+    /**
+     * Backward compatibility wrapper for ConfigParser::RegexPattern method.
+     * If the configuration_includes_quoted_values configuration parameter is
+     * set to 'off' this interprets the quoted tokens as filenames.
+     */
+    static char *RegexStrtokFile();
+
+    /**
+     * Parse the next token as a regex patern. The regex patterns are non quoted
+     * tokens.
+     */
+    static char *RegexPattern();
+
+    /**
+     * Parse the next token with support for quoted values enabled even if
+     * the configuration_includes_quoted_values is set to off
+     */
+    static char *NextQuotedToken();
+
+    /// \return true if the last parsed token was quoted
+    static bool LastTokenWasQuoted() {return (LastTokenType == ConfigParser::QuotedToken);}
+
+    /**
+     * \return the next quoted string or the raw string data until the end of line.
+     * This method allows %macros in unquoted strings to keep compatibility
+     * for the logformat option.
+     */
+    static char *NextQuotedOrToEol();
+
+    /**
+     * Preview the next token. The next NextToken() and strtokFile() call
+     * will return the same token.
+     * On parse error (eg invalid characters in token) will return an
+     * error message as token.
+     */
+    static char *PeekAtToken();
+
+    /**
+     * The next NextToken call will return the token as next element
+     * It can be used repeatedly to add more than one tokens in a FIFO list.
+     */
+    static void TokenPutBack(const char *token);
+
+    /// Set the configuration file line to parse.
+    static void SetCfgLine(char *line);
+
+    /// Allow %macros inside quoted strings
+    static void EnableMacros() {AllowMacros_ = true;}
+
+    /// Do not allow %macros inside quoted strings
+    static void DisableMacros() {AllowMacros_ = false;}
+
+    /// configuration_includes_quoted_values in squid.conf
+    static bool RecognizeQuotedValues;
+
+    /**
+     * Strict syntax mode. Does not allow not alphanumeric characters in unquoted tokens.
+     * Controled by the  configuration_includes_quoted_values in squid.conf but remains
+     * false when the the legacy ConfigParser::NextQuotedToken() call forces
+     * RecognizeQuotedValues to be temporary true.
+     */
+    static bool StrictMode;
+
+protected:
+    /**
+     * Class used to store required information for the current
+     * configuration file.
+     */
+    class CfgFile
+    {
+    public:
+        CfgFile(): wordFile(NULL), parsePos(NULL), lineNo(0) { parseBuffer[0] = '\0';}
+        ~CfgFile();
+        /// True if the configuration file is open
+        bool isOpen() {return wordFile != NULL;}
+
+        /**
+         * Open the file given by 'path' and initializes the CfgFile object
+         * to start parsing
+         */
+        bool startParse(char *path);
+
+        /**
+         * Do the next parsing step:
+         * reads the next line from file if required.
+         * \return the body of next element or a NULL pointer if there are no more token elements in the file.
+         * \param type will be filled with the ConfigParse::TokenType for any element found, or left unchanged if NULL is returned.
+         */
+        char *parse(TokenType &type);
+
+    private:
+        bool getFileLine();   ///< Read the next line from the file
+        /**
+         * Return the body of the next element. If the wasQuoted is given
+         * set to true if the element was quoted.
+         */
+        char *nextElement(TokenType &type);
+        FILE *wordFile; ///< Pointer to the file.
+        char parseBuffer[CONFIG_LINE_LIMIT]; ///< Temporary buffer to store data to parse
+        const char *parsePos; ///< The next element position in parseBuffer string
+    public:
+        std::string filePath; ///< The file path
+        std::string currentLine; ///< The current line to parse
+        int lineNo; ///< Current line number
+    };
+
+    /// Return the last TokenPutBack() queued element or NULL if none exist
+    static char *Undo();
+
+    /**
+     * Unquotes the token, which must be quoted.
+     * \param next if it is not NULL, it is set after the end of token.
+     */
+    static char *UnQuote(const char *token, const char **next = NULL);
+
+    /**
+     * Does the real tokens parsing job: Ignore comments, unquote an
+     * element if required.
+     * \return the next token, or NULL if there are no available tokens in the nextToken string.
+     * \param nextToken updated to point to the pos after parsed token.
+     * \param type      The token type
+     */
+    static char *TokenParse(const char * &nextToken, TokenType &type);
+
+    /// Wrapper method for TokenParse.
+    static char *NextElement(TokenType &type);
+    static std::stack<CfgFile *> CfgFiles; ///< The stack of open cfg files
+    static TokenType LastTokenType; ///< The type of last parsed element
+    static const char *CfgLine; ///< The current line to parse
+    static const char *CfgPos; ///< Pointer to the next element in cfgLine string
+    static std::queue<char *> CfgLineTokens_; ///< Store the list of tokens for current configuration line
+    static std::queue<std::string> Undo_; ///< The list with TokenPutBack() queued elements
+    static bool AllowMacros_;
+    static bool ParseQuotedOrToEol_; ///< The next tokens will be handled as quoted or to_eol token
+    static bool PreviewMode_; ///< The next token will not poped from cfg files, will just previewd.
 };
 
 int parseConfigFile(const char *file_name);
@@ -37,10 +37,10 @@
 #include "squid.h"
 
 #if USE_DELAY_POOLS
-#include "DelayPool.h"
-#include "CommonPool.h"
 #include "acl/Acl.h"
 #include "acl/Gadgets.h"
+#include "CommonPool.h"
+#include "DelayPool.h"
 #include "Store.h"
 
 DelayPool::DelayPool() : pool (NULL), access (NULL)
@@ -38,8 +38,8 @@
 #define DELAYPOOL_H
 
 #if USE_DELAY_POOLS
-#include "CompositePoolNode.h"
 #include "acl/forward.h"
+#include "CompositePoolNode.h"
 
 class StoreEntry;
 
@@ -37,11 +37,11 @@
 #if USE_DELAY_POOLS
 
 #include "auth/Gadgets.h"
+#include "base/Vector.h"
 #include "CompositePoolNode.h"
-#include "DelayIdComposite.h"
 #include "DelayBucket.h"
+#include "DelayIdComposite.h"
 #include "DelaySpec.h"
-#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -38,11 +38,11 @@
 
 #include "auth/Gadgets.h"
 #include "auth/User.h"
+#include "base/Vector.h"
 #include "CompositePoolNode.h"
-#include "DelayIdComposite.h"
 #include "DelayBucket.h"
+#include "DelayIdComposite.h"
 #include "DelaySpec.h"
-#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -2,8 +2,8 @@
  * DEBUG: section 05    Comm
  */
 #include "squid.h"
-#include "globals.h" /* for Squid_MaxFD */
 #include "DescriptorSet.h"
+#include "globals.h" /* for Squid_MaxFD */
 
 // pre-allocates descriptor store and index for Squid_MaxFD descriptors
 DescriptorSet::DescriptorSet(): descriptors_(NULL), index_(NULL),
@@ -47,10 +47,10 @@
 #include "squid.h"
 #include "AIODiskFile.h"
 #include "AIODiskIOStrategy.h"
+#include "disk.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
-#include "disk.h"
 #include "globals.h"
 
 #if HAVE_ERRNO_H
@@ -33,9 +33,9 @@
 
 #if USE_DISKIO_AIO
 
-#include "DiskIO/DiskFile.h"
 #include "async_io.h"
 #include "cbdata.h"
+#include "DiskIO/DiskFile.h"
 #include "SquidString.h"
 
 class AIODiskIOStrategy;
@@ -50,7 +50,7 @@ AIODiskIOModule::init()
 {}
 
 void
-AIODiskIOModule::shutdown()
+AIODiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy *
@@ -42,7 +42,7 @@ class AIODiskIOModule : public DiskIOModule
     static AIODiskIOModule &GetInstance();
     AIODiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -41,8 +41,8 @@
  */
 
 #include "squid.h"
-#include "AIODiskIOStrategy.h"
 #include "AIODiskFile.h"
+#include "AIODiskIOStrategy.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
@@ -33,8 +33,8 @@
 
 #if USE_DISKIO_AIO
 
-#include "DiskIO/DiskIOStrategy.h"
 #include "async_io.h"
+#include "DiskIO/DiskIOStrategy.h"
 
 class AIODiskIOStrategy : public DiskIOStrategy
 {
@@ -33,7 +33,10 @@
 
 #include "squid.h"
 #include "comm.h"
-#include "aio_win32.h"
+#include "DiskIO/AIO/aio_win32.h"
+#include "fd.h"
+#include "StatCounters.h"
+#include "win32.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -49,7 +49,7 @@ BlockingDiskIOModule::init()
 {}
 
 void
-BlockingDiskIOModule::shutdown()
+BlockingDiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy*
@@ -41,7 +41,7 @@ class BlockingDiskIOModule : public DiskIOModule
     static BlockingDiskIOModule &GetInstance();
     BlockingDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -34,11 +34,11 @@
 #include "BlockingFile.h"
 #include "Debug.h"
 #include "defines.h"
-#include "globals.h"
+#include "disk.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
-#include "disk.h"
+#include "globals.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -32,8 +32,8 @@
  */
 
 #include "squid.h"
-#include "BlockingIOStrategy.h"
 #include "BlockingFile.h"
+#include "BlockingIOStrategy.h"
 #include "unlinkd.h"
 
 bool
@@ -79,7 +79,7 @@ DiskDaemonDiskIOModule::registerWithCacheManager(void)
 }
 
 void
-DiskDaemonDiskIOModule::shutdown()
+DiskDaemonDiskIOModule::gracefulShutdown()
 {
     initialised = false;
 }
@@ -41,7 +41,7 @@ class DiskDaemonDiskIOModule : public DiskIOModule
     static DiskDaemonDiskIOModule &GetInstance();
     DiskDaemonDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -7,8 +7,8 @@
 #define SQUID_DISKD_ACTION_H
 
 #include "ipc/forward.h"
-#include "mgr/forward.h"
 #include "mgr/Action.h"
+#include "mgr/forward.h"
 
 /// store disk daemon stats
 class DiskdActionData
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "DiskdFile.h"
 #include "ConfigOption.h"
 #include "diomsg.h"
+#include "DiskdFile.h"
 #include "DiskdIOStrategy.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
@@ -34,16 +34,16 @@
 #include "squid.h"
 #include "comm/Loops.h"
 #include "ConfigOption.h"
+#include "diomsg.h"
+#include "DiskdFile.h"
 #include "DiskdIOStrategy.h"
 #include "DiskIO/DiskFile.h"
-#include "DiskdFile.h"
-#include "diomsg.h"
 #include "fd.h"
-#include "Store.h"
-#include "StatCounters.h"
 #include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
+#include "StatCounters.h"
+#include "Store.h"
 #include "unlinkd.h"
 
 #if HAVE_SYS_IPC_H
@@ -95,7 +95,7 @@ DiskIOModule::FreeAllModules()
     while (GetModules().size()) {
         DiskIOModule *fs = GetModules().back();
         GetModules().pop_back();
-        fs->shutdown();
+        fs->gracefulShutdown();
     }
 }
 
@@ -65,7 +65,7 @@ class DiskIOModule
 
     virtual void init() = 0;
     //virtual void registerWithCacheManager(void);
-    virtual void shutdown() = 0;
+    virtual void gracefulShutdown() = 0;
     virtual DiskIOStrategy *createStrategy() = 0;
 
     virtual char const *type () const = 0;
@@ -37,6 +37,7 @@
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "fd.h"
 #include "globals.h"
+#include "win32.h"
 
 void
 CommIO::Initialize()
@@ -10,6 +10,12 @@
 #include "dlink.h"
 #include "typedefs.h"
 
+/* this non-standard-conformant include is needed in order to have stat(2) and struct stat
+   properly defined on some systems (e.g. OpenBSD 5.4) */
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+
 #if AUFS_IO_THREADS
 #define NUMTHREADS AUFS_IO_THREADS
 #else
@@ -33,10 +33,10 @@
 
 #include "squid.h"
 #include "disk.h"
-#include "DiskThreadsDiskFile.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
+#include "DiskThreadsDiskFile.h"
 #include "fd.h"
 #include "Generic.h"
 #include "globals.h"
@@ -52,7 +52,7 @@ DiskThreadsDiskIOModule::init()
 }
 
 void
-DiskThreadsDiskIOModule::shutdown()
+DiskThreadsDiskIOModule::gracefulShutdown()
 {
     DiskThreadsIOStrategy::Instance.done();
 }
@@ -42,7 +42,7 @@ class DiskThreadsDiskIOModule : public DiskIOModule
     DiskThreadsDiskIOModule();
     virtual void init();
     //virtual void registerWithCacheManager(void);
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -35,6 +35,7 @@
 #include "squid.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "DiskThreads.h"
+#include "fd.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -209,7 +210,7 @@ squidaio_xfree(void *p, int size)
     MemAllocator *pool;
 
     if ((pool = squidaio_get_pool(size)) != NULL) {
-        pool->free(p);
+        pool->freeOne(p);
     } else
         xfree(p);
 }
@@ -221,7 +222,7 @@ squidaio_xstrfree(char *str)
     int len = strlen(str) + 1;
 
     if ((pool = squidaio_get_pool(len)) != NULL) {
-        pool->free(str);
+        pool->freeOne(str);
     } else
         xfree(str);
 }
@@ -295,7 +296,9 @@ squidaio_init(void)
 
     done_queue.blocked = 0;
 
-    CommIO::NotifyIOCompleted();
+    // Initialize the thread I/O pipes before creating any threads
+    // see bug 3189 comment 5 about race conditions.
+    CommIO::Initialize();
 
     /* Create threads and get them to sit in their wait loop */
     squidaio_thread_pool = memPoolCreate("aio_thread", sizeof(squidaio_thread_t));
@@ -715,7 +718,7 @@ squidaio_cleanup_request(squidaio_request_t * requestp)
         resultp->aio_errno = requestp->err;
     }
 
-    squidaio_request_pool->free(requestp);
+    squidaio_request_pool->freeOne(requestp);
 }				/* squidaio_cleanup_request */
 
 int
@@ -34,10 +34,10 @@
 
 #include "squid.h"
 #include "DiskThreads.h"
-#include "Store.h"
-#include "fde.h"
 #include "DiskThreadsIOStrategy.h"
+#include "fde.h"
 #include "Generic.h"
+#include "Store.h"
 
 AIOCounts squidaio_counts;
 
@@ -18,7 +18,7 @@ IpcIoDiskIOModule::init()
 {}
 
 void
-IpcIoDiskIOModule::shutdown()
+IpcIoDiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy*
@@ -10,7 +10,7 @@ class IpcIoDiskIOModule : public DiskIOModule
     static IpcIoDiskIOModule &GetInstance();
     IpcIoDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -5,11 +5,11 @@
 #include "squid.h"
 #include "base/RunnersRegistry.h"
 #include "base/TextException.h"
+#include "disk.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/IpcIo/IpcIoFile.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
-#include "disk.h"
 #include "fd.h"
 #include "globals.h"
 #include "ipc/mem/Pages.h"
@@ -5,9 +5,9 @@
 #include "cbdata.h"
 #include "DiskIO/DiskFile.h"
 #include "DiskIO/IORequestor.h"
-#include "SquidString.h"
 #include "ipc/forward.h"
 #include "ipc/mem/Page.h"
+#include "SquidString.h"
 #include <list>
 #include <map>
 #include <memory>
@@ -18,7 +18,7 @@ MmappedDiskIOModule::init()
 {}
 
 void
-MmappedDiskIOModule::shutdown()
+MmappedDiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy*
@@ -10,7 +10,7 @@ class MmappedDiskIOModule : public DiskIOModule
     static MmappedDiskIOModule &GetInstance();
     MmappedDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -4,11 +4,11 @@
 
 #include "squid.h"
 #include "Debug.h"
+#include "disk.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/Mmapped/MmappedFile.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
-#include "disk.h"
 #include "globals.h"
 
 #if HAVE_SYS_MMAN_H
@@ -32,11 +32,13 @@
 
 #include "squid.h"
 #include "AsyncEngine.h"
+#include "base/AsyncCallQueue.h"
 #include "Debug.h"
 #include "EventLoop.h"
-#include "base/AsyncCallQueue.h"
 #include "SquidTime.h"
 
+EventLoop *EventLoop::Running = NULL;
+
 EventLoop::EventLoop() : errcount(0), last_loop(false), timeService(NULL),
         primaryEngine(NULL),
         loop_delay(EVENT_LOOP_TIMEOUT),
@@ -96,7 +98,12 @@ EventLoop::run()
 {
     prepareToRun();
 
+    assert(!Running);
+    Running = this;
+
     while (!runOnce());
+
+    Running = NULL;
 }
 
 bool
@@ -89,6 +89,10 @@ class EventLoop
 
     int errcount;
 
+    /// the [main program] loop running now; may be nil
+    /// for simplicity, we assume there are no concurrent loops
+    static EventLoop *Running;
+
 private:
     /** setup state variables prior to running */
     void prepareToRun();
@@ -49,7 +49,8 @@
 
 CBDATA_CLASS_INIT(ExternalACLEntry);
 
-ExternalACLEntry::ExternalACLEntry()
+ExternalACLEntry::ExternalACLEntry() :
+        notes()
 {
     lru.next = lru.prev = NULL;
     result = ACCESS_DENIED;
@@ -67,6 +68,11 @@ ExternalACLEntry::update(ExternalACLEntryData const &someData)
 {
     date = squid_curtime;
     result = someData.result;
+
+    // replace all notes. not combine
+    notes.entries.clean();
+    notes.append(&someData.notes);
+
 #if USE_AUTH
     user = someData.user;
     password = someData.password;
@@ -45,6 +45,7 @@
 #include "acl/Acl.h"
 #include "cbdata.h"
 #include "hash.h"
+#include "Notes.h"
 #include "SquidString.h"
 
 class external_acl;
@@ -62,6 +63,10 @@ class ExternalACLEntryData
     ExternalACLEntryData() : result(ACCESS_DUNNO) {}
 
     allow_t result;
+
+    /// list of all kv-pairs returned by the helper
+    NotePairs notes;
+
 #if USE_AUTH
     // TODO use an AuthUser to hold this info
     String user;
@@ -88,6 +93,10 @@ class ExternalACLEntry: public hash_link
     dlink_node lru;
     allow_t result;
     time_t date;
+
+    /// list of all kv-pairs returned by the helper
+    NotePairs notes;
+
 #if USE_AUTH
     String user;
     String password;
@@ -1,7 +1,7 @@
 #include "squid.h"
 #include "base/TextException.h"
-#include "SquidTime.h"
 #include "FadingCounter.h"
+#include "SquidTime.h"
 
 #if HAVE_MATH_H
 #include <math.h>
@@ -36,8 +36,8 @@
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
-#include "CachePeer.h"
 #include "CacheManager.h"
+#include "CachePeer.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
@@ -74,10 +74,10 @@
 #if USE_SSL
 #include "ssl/cert_validate_message.h"
 #include "ssl/Config.h"
-#include "ssl/helper.h"
-#include "ssl/support.h"
 #include "ssl/ErrorDetail.h"
+#include "ssl/helper.h"
 #include "ssl/ServerBump.h"
+#include "ssl/support.h"
 #endif
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -163,7 +163,7 @@ void FwdState::start(Pointer aSelf)
 #endif
 
     // do full route options selection
-    peerSelect(&serverDestinations, request, entry, fwdPeerSelectionCompleteWrapper, this);
+    peerSelect(&serverDestinations, request, al, entry, fwdPeerSelectionCompleteWrapper, this);
 }
 
 #if STRICT_ORIGINAL_DST
@@ -713,17 +713,17 @@ FwdState::negotiateSSL(int fd)
                     if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
                         serverBump->sslErrors = cbdataReference(errs);
                 }
-            }
 
-            // For intercepted connections, set the host name to the server
-            // certificate CN. Otherwise, we just hope that CONNECT is using
-            // a user-entered address (a host name or a user-entered IP).
-            const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
-            if (request->flags.sslPeek && !isConnectRequest) {
-                if (X509 *srvX509 = errDetails->peerCert()) {
-                    if (const char *name = Ssl::CommonHostName(srvX509)) {
-                        request->SetHost(name);
-                        debugs(83, 3, HERE << "reset request host: " << name);
+                // For intercepted connections, set the host name to the server
+                // certificate CN. Otherwise, we just hope that CONNECT is using
+                // a user-entered address (a host name or a user-entered IP).
+                const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
+                if (request->flags.sslPeek && !isConnectRequest) {
+                    if (X509 *srvX509 = errDetails->peerCert()) {
+                        if (const char *name = Ssl::CommonHostName(srvX509)) {
+                            request->SetHost(name);
+                            debugs(83, 3, HERE << "reset request host: " << name);
+                        }
                     }
                 }
             }
@@ -964,7 +964,8 @@ FwdState::initiateSSL()
         // unless it was the CONNECT request with a user-typed address.
         const char *hostname = request->GetHost();
         const bool hostnameIsIp = request->GetHostIsNumeric();
-        const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
+        const bool isConnectRequest = request->clientConnectionManager.valid() &&
+                                      !request->clientConnectionManager->port->flags.isIntercepted();
         if (!request->flags.sslPeek || isConnectRequest)
             SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
 
@@ -1100,7 +1101,7 @@ FwdState::connectStart()
         ctimeout = ftimeout;
 
     if (serverDestinations[0]->getPeer() && request->flags.sslBumped) {
-        debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parrent proxy are not allowed");
+        debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request);
         fail(anErr);
         self = NULL; // refcounted
@@ -1119,9 +1120,11 @@ FwdState::connectStart()
         else
             serverConn = NULL;
         if (Comm::IsConnOpen(serverConn)) {
+            pinned_connection->stopPinnedConnectionMonitoring();
             flags.connected_okay = true;
             ++n_tries;
             request->flags.pinned = true;
+            request->hier.note(serverConn, pinned_connection->pinning.host);
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = true;
             comm_add_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
@@ -1,8 +1,8 @@
 #ifndef SQUID_FORWARD_H
 #define SQUID_FORWARD_H
 
-#include "base/Vector.h"
 #include "base/RefCount.h"
+#include "base/Vector.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "err_type.h"
@@ -1,8 +1,9 @@
 #include "squid.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
-#include "HelperChildConfig.h"
 #include "globals.h"
+#include "HelperChildConfig.h"
 #include "Parsing.h"
 
 #include <string.h>
@@ -44,7 +45,7 @@ HelperChildConfig::needNew() const
 void
 HelperChildConfig::parseConfig()
 {
-    char const *token = strtok(NULL, w_space);
+    char const *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
@@ -58,7 +59,7 @@ HelperChildConfig::parseConfig()
     }
 
     /* Parse extension options */
-    for (; (token = strtok(NULL, w_space)) ;) {
+    for (; (token = ConfigParser::NextToken()) ;) {
         if (strncmp(token, "startup=", 8) == 0) {
             n_startup = xatoui(token + 8);
         } else if (strncmp(token, "idle=", 5) == 0) {
@@ -4,11 +4,11 @@
  */
 #include "squid.h"
 #include "ConfigParser.h"
-#include "HelperReply.h"
+#include "Debug.h"
 #include "helper.h"
+#include "HelperReply.h"
 #include "rfc1738.h"
 #include "SquidString.h"
-#include "Debug.h"
 
 HelperReply::HelperReply(char *buf, size_t len) :
         result(HelperReply::Unknown),
@@ -37,8 +37,8 @@
 #include "hier_code.h"
 #include "http/StatusCode.h"
 #include "lookup_t.h"
-#include "rfc2181.h"
 #include "PingData.h"
+#include "rfc2181.h"
 
 class HierarchyLogEntry
 {
@@ -1,8 +1,8 @@
 #ifndef SQUID_HTTP_CONTROL_MSG_H
 #define SQUID_HTTP_CONTROL_MSG_H
 
-#include "HttpReply.h"
 #include "base/AsyncCall.h"
+#include "HttpReply.h"
 
 class HttpControlMsg;
 
@@ -31,12 +31,12 @@
  */
 
 #include "squid.h"
-#include "base/StringArea.h"
+#include "HttpHdrCc.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
-#include "HttpHdrCc.h"
+#include "SBuf.h"
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
@@ -71,7 +71,7 @@ static HttpHeaderCcFields CcAttrs[CC_ENUM_END] = {
 };
 
 /// Map an header name to its type, to expedite parsing
-typedef std::map<const StringArea,http_hdr_cc_type> CcNameToIdMap_t;
+typedef std::map<const SBuf,http_hdr_cc_type> CcNameToIdMap_t;
 static CcNameToIdMap_t CcNameToIdMap;
 
 /// used to walk a table of http_header_cc_type structs
@@ -90,7 +90,7 @@ httpHdrCcInitModule(void)
     for (int32_t i = 0; i < CC_ENUM_END; ++i) {
         const HttpHeaderCcFields &f=CcAttrs[i];
         assert(i == f.id); /* verify assumption: the id is the key into the array */
-        const StringArea k(f.name,strlen(f.name));
+        const SBuf k(f.name);
         CcNameToIdMap[k]=f.id;
     }
 }
@@ -131,7 +131,7 @@ HttpHdrCc::parse(const String & str)
         }
 
         /* find type */
-        const CcNameToIdMap_t::const_iterator i=CcNameToIdMap.find(StringArea(item,nlen));
+        const CcNameToIdMap_t::const_iterator i=CcNameToIdMap.find(SBuf(item,nlen));
         if (i==CcNameToIdMap.end())
             type=CC_OTHER;
         else
@@ -30,8 +30,8 @@
  *
  */
 
-#include "defines.h"
 #include "Debug.h"
+#include "defines.h"
 
 bool
 HttpHdrCc::isSet(http_hdr_cc_type id) const
@@ -78,7 +78,7 @@ class HttpHdrCc
     void Private(String &v) {
         setMask(CC_PRIVATE,true);
         // uses append for multi-line headers
-        if (private_.defined())
+        if (private_.size() > 0)
             private_.append(",");
         private_.append(v);
     }
@@ -90,7 +90,7 @@ class HttpHdrCc
     void noCache(String &v) {
         setMask(CC_NO_CACHE,true);
         // uses append for multi-line headers
-        if (no_cache.defined())
+        if (no_cache.size() > 0)
             no_cache.append(",");
         no_cache.append(v);
     }
@@ -32,11 +32,11 @@
  */
 
 #include "squid.h"
-#include "Store.h"
-#include "HttpHeaderRange.h"
 #include "client_side_request.h"
-#include "HttpReply.h"
+#include "HttpHeaderRange.h"
 #include "HttpHeaderTools.h"
+#include "HttpReply.h"
+#include "Store.h"
 #include "StrList.h"
 
 /*
@@ -364,9 +364,9 @@ HttpHdrSc::findTarget(const char *target)
     while (node) {
         HttpHdrScTarget *sct = (HttpHdrScTarget *)node->data;
 
-        if (target && sct->target.defined() && !strcmp (target, sct->target.termedBuf()))
+        if (target && sct->target.size() > 0 && !strcmp(target, sct->target.termedBuf()))
             return sct;
-        else if (!target && sct->target.undefined())
+        else if (!target && sct->target.size() == 0)
             return sct;
 
         node = node->next;
@@ -30,9 +30,9 @@
 #ifndef SQUID_HTTPHDRSURROGATECONTROLTARGET_H
 #define SQUID_HTTPHDRSURROGATECONTROLTARGET_H
 
-#include "MemPool.h"
 #include "defines.h"
 #include "dlink.h"
+#include "MemPool.h"
 #include "SquidString.h"
 #include "typedefs.h"
 
@@ -43,11 +43,11 @@
 #include "mgr/Registration.h"
 #include "profiler/Profiler.h"
 #include "rfc1123.h"
+#include "SquidConfig.h"
+#include "SquidString.h"
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
-#include "SquidConfig.h"
-#include "SquidString.h"
 #include "TimeOrTag.h"
 
 /*
@@ -107,6 +107,7 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] = {
     {"Expires", HDR_EXPIRES, ftDate_1123},
     {"From", HDR_FROM, ftStr},
     {"Host", HDR_HOST, ftStr},
+    {"HTTP2-Settings", HDR_HTTP2_SETTINGS, ftStr}, /* for now */
     {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
     {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
     {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
@@ -254,6 +255,7 @@ static http_hdr_type ReplyHeadersArr[] = {
 static HttpHeaderMask RequestHeadersMask;	/* set run-time using RequestHeaders */
 static http_hdr_type RequestHeadersArr[] = {
     HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
+    HDR_HTTP2_SETTINGS,
     HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
     HDR_IF_RANGE, HDR_MAX_FORWARDS,
     HDR_ORIGIN,
@@ -264,7 +266,7 @@ static http_hdr_type RequestHeadersArr[] = {
 
 static HttpHeaderMask HopByHopHeadersMask;
 static http_hdr_type HopByHopHeadersArr[] = {
-    HDR_CONNECTION, HDR_KEEP_ALIVE, /*HDR_PROXY_AUTHENTICATE,*/ HDR_PROXY_AUTHORIZATION,
+    HDR_CONNECTION, HDR_HTTP2_SETTINGS, HDR_KEEP_ALIVE, /*HDR_PROXY_AUTHENTICATE,*/ HDR_PROXY_AUTHORIZATION,
     HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE, HDR_PROXY_CONNECTION
 };
 
@@ -547,6 +549,7 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 {
     const char *field_ptr = header_start;
     HttpHeaderEntry *e, *e2;
+    bool warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
 
     PROF_start(HttpHeaderParse);
 
@@ -558,7 +561,8 @@ HttpHeader::parse(const char *header_start, const char *header_end)
     if ((nulpos = (char*)memchr(header_start, '\0', header_end - header_start))) {
         debugs(55, DBG_IMPORTANT, "WARNING: HTTP header contains NULL characters {" <<
                getStringPrefix(header_start, nulpos) << "}\nNULL\n{" << getStringPrefix(nulpos+1, header_end));
-        goto reset;
+        PROF_stop(HttpHeaderParse);
+        return reset();
     }
 
     /* common format headers are "<name>:[ws]<value>" lines delimited by <CRLF>.
@@ -571,8 +575,11 @@ HttpHeader::parse(const char *header_start, const char *header_end)
             const char *this_line = field_ptr;
             field_ptr = (const char *)memchr(field_ptr, '\n', header_end - field_ptr);
 
-            if (!field_ptr)
-                goto reset;	/* missing <LF> */
+            if (!field_ptr) {
+                // missing <LF>
+                PROF_stop(HttpHeaderParse);
+                return reset();
+            }
 
             field_end = field_ptr;
 
@@ -588,17 +595,18 @@ HttpHeader::parse(const char *header_start, const char *header_end)
                             cr_only = false;
                     }
                     if (cr_only) {
-                        debugs(55, DBG_IMPORTANT, "WARNING: Rejecting HTTP request with a CR+ "
+                        debugs(55, DBG_IMPORTANT, "SECURITY WARNING: Rejecting HTTP request with a CR+ "
                                "header field to prevent request smuggling attacks: {" <<
                                getStringPrefix(header_start, header_end) << "}");
-                        goto reset;
+                        PROF_stop(HttpHeaderParse);
+                        return reset();
                     }
                 }
             }
 
             /* Barf on stray CR characters */
             if (memchr(this_line, '\r', field_end - this_line)) {
-                debugs(55, DBG_IMPORTANT, "WARNING: suspicious CR characters in HTTP header {" <<
+                debugs(55, warnOnError, "WARNING: suspicious CR characters in HTTP header {" <<
                        getStringPrefix(field_start, field_end) << "}");
 
                 if (Config.onoff.relaxed_header_parser) {
@@ -608,49 +616,53 @@ HttpHeader::parse(const char *header_start, const char *header_end)
                         *p = ' ';
                         ++p;
                     }
-                } else
-                    goto reset;
+                } else {
+                    PROF_stop(HttpHeaderParse);
+                    return reset();
+                }
             }
 
             if (this_line + 1 == field_end && this_line > field_start) {
-                debugs(55, DBG_IMPORTANT, "WARNING: Blank continuation line in HTTP header {" <<
+                debugs(55, warnOnError, "WARNING: Blank continuation line in HTTP header {" <<
                        getStringPrefix(header_start, header_end) << "}");
-                goto reset;
+                PROF_stop(HttpHeaderParse);
+                return reset();
             }
         } while (field_ptr < header_end && (*field_ptr == ' ' || *field_ptr == '\t'));
 
         if (field_start == field_end) {
             if (field_ptr < header_end) {
-                debugs(55, DBG_IMPORTANT, "WARNING: unparseable HTTP header field near {" <<
+                debugs(55, warnOnError, "WARNING: unparseable HTTP header field near {" <<
                        getStringPrefix(field_start, header_end) << "}");
-                goto reset;
+                PROF_stop(HttpHeaderParse);
+                return reset();
             }
 
             break;		/* terminating blank line */
         }
 
         if ((e = HttpHeaderEntry::parse(field_start, field_end)) == NULL) {
-            debugs(55, DBG_IMPORTANT, "WARNING: unparseable HTTP header field {" <<
+            debugs(55, warnOnError, "WARNING: unparseable HTTP header field {" <<
                    getStringPrefix(field_start, field_end) << "}");
-            debugs(55, Config.onoff.relaxed_header_parser <= 0 ? 1 : 2,
-                   " in {" << getStringPrefix(header_start, header_end) << "}");
+            debugs(55, warnOnError, " in {" << getStringPrefix(header_start, header_end) << "}");
 
             if (Config.onoff.relaxed_header_parser)
                 continue;
-            else
-                goto reset;
+
+            PROF_stop(HttpHeaderParse);
+            return reset();
         }
 
         if (e->id == HDR_CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
-//            if (e->value.cmp(e2->value.termedBuf()) != 0) {
             if (e->value != e2->value) {
                 int64_t l1, l2;
-                debugs(55, Config.onoff.relaxed_header_parser <= 0 ? 1 : 2,
-                       "WARNING: found two conflicting content-length headers in {" << getStringPrefix(header_start, header_end) << "}");
+                debugs(55, warnOnError, "WARNING: found two conflicting content-length headers in {" <<
+                       getStringPrefix(header_start, header_end) << "}");
 
                 if (!Config.onoff.relaxed_header_parser) {
                     delete e;
-                    goto reset;
+                    PROF_stop(HttpHeaderParse);
+                    return reset();
                 }
 
                 if (!httpHeaderParseOffset(e->value.termedBuf(), &l1)) {
@@ -667,27 +679,25 @@ HttpHeader::parse(const char *header_start, const char *header_end)
                     continue;
                 }
             } else {
-                debugs(55, Config.onoff.relaxed_header_parser <= 0 ? 1 : 2,
-                       "NOTICE: found double content-length header");
+                debugs(55, warnOnError, "NOTICE: found double content-length header");
+                delete e;
 
-                if (Config.onoff.relaxed_header_parser) {
-                    delete e;
+                if (Config.onoff.relaxed_header_parser)
                     continue;
-                } else {
-                    delete e;
-                    goto reset;
-                }
+
+                PROF_stop(HttpHeaderParse);
+                return reset();
             }
         }
 
         if (e->id == HDR_OTHER && stringHasWhitespace(e->name.termedBuf())) {
-            debugs(55, Config.onoff.relaxed_header_parser <= 0 ? 1 : 2,
-                   "WARNING: found whitespace in HTTP header name {" <<
+            debugs(55, warnOnError, "WARNING: found whitespace in HTTP header name {" <<
                    getStringPrefix(field_start, field_end) << "}");
 
             if (!Config.onoff.relaxed_header_parser) {
                 delete e;
-                goto reset;
+                PROF_stop(HttpHeaderParse);
+                return reset();
             }
         }
 
@@ -701,9 +711,6 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 
     PROF_stop(HttpHeaderParse);
     return 1;			/* even if no fields where found, it is a valid header */
-reset:
-    PROF_stop(HttpHeaderParse);
-    return reset();
 }
 
 /* packs all the entries using supplied packer */
@@ -83,6 +83,7 @@ typedef enum {
     HDR_EXPIRES,                        /**< RFC 2608, 2616 */
     HDR_FROM,                           /**< RFC 2608, 2616 */
     HDR_HOST,                           /**< RFC 2608, 2616 */
+    HDR_HTTP2_SETTINGS,                 /**< HTTP/2.0 upgrade header. see draft-ietf-httpbis-http2-04 */
     /*HDR_IF,*/                         /* RFC 2518 */
     HDR_IF_MATCH,                       /**< RFC 2608, 2616 */
     HDR_IF_MODIFIED_SINCE,              /**< RFC 2608, 2616 */
@@ -29,8 +29,8 @@
  *
  */
 
-#include "SquidString.h"
 #include "HttpHeaderFieldStat.h"
+#include "SquidString.h"
 
 /// compiled version of HttpHeaderFieldAttrs plus stats. Currently a POD.
 class HttpHeaderFieldInfo
@@ -31,15 +31,15 @@
  */
 
 #include "squid.h"
-#include "globals.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
-#include "client_side_request.h"
 #include "client_side.h"
+#include "client_side_request.h"
 #include "comm/Connection.h"
 #include "compat/strtoll.h"
 #include "ConfigParser.h"
 #include "fde.h"
+#include "globals.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
@@ -294,7 +294,7 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
         return 0;
     }
     /* Make sure it's defined even if empty "" */
-    if (!val->defined())
+    if (!val->termedBuf())
         val->limitInit("", 0);
     return 1;
 }
@@ -33,10 +33,10 @@
 
 #include "base/Lock.h"
 #include "BodyPipe.h"
+#include "http/ProtocolVersion.h"
+#include "http/StatusCode.h"
 #include "HttpHeader.h"
 #include "HttpRequestMethod.h"
-#include "http/StatusCode.h"
-#include "http/ProtocolVersion.h"
 
 /// common parts of HttpRequest and HttpReply
 class HttpMsg : public RefCountable
@@ -270,7 +270,7 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
 
     two = otherRep->header.getStrOrList(HDR_ETAG);
 
-    if (one.undefined() || two.undefined() || one.caseCmp(two)!=0 ) {
+    if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
         two.clean();
         return 0;
@@ -284,7 +284,7 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
 
     two = otherRep->header.getStrOrList(HDR_CONTENT_MD5);
 
-    if (one.undefined() || two.undefined() || one.caseCmp(two) != 0 ) {
+    if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
         two.clean();
         return 0;
@@ -30,10 +30,10 @@
 #ifndef SQUID_HTTPREPLY_H
 #define SQUID_HTTPREPLY_H
 
+#include "http/StatusLine.h"
 #include "HttpBody.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
-#include "http/StatusLine.h"
 
 void httpReplyInitModule(void);
 
@@ -228,7 +228,6 @@ HttpRequest::clone() const
     copy->vary_headers = vary_headers ? xstrdup(vary_headers) : NULL;
     // XXX: what to do with copy->peer_domain?
 
-    copy->myportname = myportname;
     copy->tag = tag;
     copy->extacl_log = extacl_log;
     copy->extacl_message = extacl_message;
@@ -273,6 +272,8 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     extacl_passwd = aReq->extacl_passwd;
 #endif
 
+    myportname = aReq->myportname;
+
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
@@ -39,8 +39,8 @@
 #include "comm/forward.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
-#include "StoreClient.h"
 #include "LogTags.h"
+#include "StoreClient.h"
 
 class HttpRequest;
 
@@ -39,8 +39,8 @@
 #if USE_LEAKFINDER
 
 #include "LeakFinder.h"
-#include "Store.h"
 #include "SquidTime.h"
+#include "Store.h"
 
 /* ========================================================================= */
 
@@ -8,23 +8,36 @@ include $(top_srcdir)/src/Common.am
 
 AUTOMAKE_OPTIONS = subdir-objects
 
-if ENABLE_DNSHELPER
-DNSSOURCE = dns.cc
-DNSHELPER = dnsserver
-else
-DNSSOURCE = dns_internal.cc
-DNSHELPER =
-endif
-
-DNSSOURCE += \
+DNSSOURCE = \
+	dns_internal.cc \
 	SquidDns.h \
 	DnsLookupDetails.h \
 	DnsLookupDetails.cc
 
 SBUF_SOURCE= \
 	base/InstanceId.h \
 	MemBlob.h \
-	MemBlob.cc
+	MemBlob.cc \
+	OutOfBoundsException.h \
+	SBuf.h \
+	SBuf.cc \
+	SBufExceptions.h \
+	SBufExceptions.cc
+
+STOREMETA_SOURCE = \
+	StoreMeta.cc \
+	StoreMeta.h \
+	StoreMetaMD5.cc \
+	StoreMetaMD5.h \
+	StoreMetaSTD.cc \
+	StoreMetaSTD.h \
+	StoreMetaSTDLFS.cc \
+	StoreMetaSTDLFS.h \
+	StoreMetaObjSize.h \
+	StoreMetaURL.cc \
+	StoreMetaURL.h \
+	StoreMetaVary.cc \
+	StoreMetaVary.h
 
 LOADABLE_MODULES_SOURCES = \
 	LoadableModule.h \
@@ -192,10 +205,8 @@ noinst_LTLIBRARIES = libsquid.la
 EXTRA_PROGRAMS = \
 	DiskIO/DiskDaemon/diskd \
 	unlinkd \
-	dnsserver \
 	recv-announce \
 	tests/testUfs \
-	tests/testCoss \
 	tests/testRock \
 	ufsdump
 
@@ -212,7 +223,6 @@ bin_PROGRAMS =
 
 
 libexec_PROGRAMS = \
-	$(DNSHELPER) \
 	$(DISK_PROGRAMS) \
 	$(UNLINKD)
 
@@ -434,6 +444,7 @@ squid_SOURCES = \
 	MemBuf.cc \
 	MemObject.cc \
 	MemObject.h \
+	MessageSizes.h \
 	mime.h \
 	mime.cc \
 	mime_header.h \
@@ -442,8 +453,8 @@ squid_SOURCES = \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
-	Notes.cc \
 	Notes.h \
+	Notes.cc \
 	Packer.cc \
 	Packer.h \
 	Parsing.cc \
@@ -472,6 +483,10 @@ squid_SOURCES = \
 	send-announce.h \
 	send-announce.cc \
 	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	SBufDetailedStats.cc \
+	SBufStatsAction.h \
+	SBufStatsAction.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
@@ -513,21 +528,9 @@ squid_SOURCES = \
 	store_swapin.cc \
 	store_swapmeta.cc \
 	store_swapout.cc \
-	StoreMeta.cc \
-	StoreMeta.h \
-	StoreMetaMD5.cc \
-	StoreMetaMD5.h \
-	StoreMetaSTD.cc \
-	StoreMetaSTD.h \
-	StoreMetaSTDLFS.cc \
-	StoreMetaSTDLFS.h \
-	StoreMetaObjSize.h \
 	StoreMetaUnpacker.cc \
 	StoreMetaUnpacker.h \
-	StoreMetaURL.cc \
-	StoreMetaURL.h \
-	StoreMetaVary.cc \
-	StoreMetaVary.h \
+	$(STOREMETA_SOURCE) \
 	StoreSearch.h \
 	StoreStats.cc \
 	StoreStats.h \
@@ -571,11 +574,6 @@ EXTRA_squid_SOURCES = \
 	$(all_AUTHMODULES) \
 	ConfigOption.h \
 	$(DELAY_POOL_ALL_SOURCE) \
-	dns.cc \
-	dnsserver.cc \
-	dns_internal.cc \
-	DnsLookupDetails.cc \
-	DnsLookupDetails.h \
 	htcp.cc \
 	htcp.h \
 	ipc.cc \
@@ -699,12 +697,6 @@ unlinkd_LDADD = \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
-## dnsserver is a standalone helper. Do not link to any internal libraries
-dnsserver_SOURCES = dnsserver.cc
-dnsserver_LDADD = \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-
 recv_announce_SOURCES = recv-announce.cc
 
 ## What requires what..
@@ -741,16 +733,11 @@ ufsdump_SOURCES = \
 	Parsing.h \
 	store_key_md5.h \
 	store_key_md5.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	String.cc \
 	SquidNew.cc \
-	time.cc \
+	tests/stub_time.cc \
 	ufsdump.cc \
 	dlink.h \
 	dlink.cc \
@@ -762,12 +749,10 @@ ufsdump_SOURCES = \
 	fd.h \
 	tests/stub_fd.cc
 ufsdump_LDADD = \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -785,12 +770,10 @@ ufsdump_LDADD = \
 	$(MINGW_LIBS) \
 	$(XTRA_LIBS)
 ufsdump_DEPENDENCIES = \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -926,7 +909,6 @@ DEFAULT_PREFIX		= $(prefix)
 DEFAULT_CONFIG_DIR	= $(sysconfdir)
 DEFAULT_CONFIG_FILE	= $(DEFAULT_CONFIG_DIR)/squid.conf
 DEFAULT_MIME_TABLE	= $(DEFAULT_CONFIG_DIR)/mime.conf
-DEFAULT_DNSSERVER	= $(libexecdir)/`echo dnsserver | sed '$(transform);s/$$/$(EXEEXT)/'`
 DEFAULT_SSL_CRTD	= $(libexecdir)/`echo ssl_crtd  | sed '$(transform);s/$$/$(EXEEXT)/'`
 DEFAULT_LOG_PREFIX	= $(DEFAULT_LOG_DIR)
 DEFAULT_CACHE_LOG	= $(DEFAULT_LOG_PREFIX)/cache.log
@@ -944,7 +926,7 @@ DEFAULT_ERROR_DIR	= $(datadir)/errors
 # Make location configure settings available to the code
 DEFS += -DDEFAULT_CONFIG_FILE=\"$(DEFAULT_CONFIG_FILE)\" -DDEFAULT_SQUID_DATA_DIR=\"$(datadir)\" -DDEFAULT_SQUID_CONFIG_DIR=\"$(sysconfdir)\"
 
-snmp_core.o snmp_agent.o: ../snmplib/libsnmplib.a $(top_srcdir)/include/cache_snmp.h
+snmp_core.o snmp_agent.o: ../lib/snmplib/libsnmplib.a $(top_srcdir)/include/cache_snmp.h
 
 globals.cc: globals.h mk-globals-c.awk
 	$(AWK) -f $(srcdir)/mk-globals-c.awk < $(srcdir)/globals.h > $@ || ($(RM) -f $@ && exit 1)
@@ -1008,7 +990,6 @@ cf.data: cf.data.pre Makefile
 	-e "s%[@]DEFAULT_ICP_PORT[@]%$(DEFAULT_ICP_PORT)%g" \
 	-e "s%[@]DEFAULT_CACHE_EFFECTIVE_USER[@]%$(CACHE_EFFECTIVE_USER)%g" \
 	-e "s%[@]DEFAULT_MIME_TABLE[@]%$(DEFAULT_MIME_TABLE)%g" \
-	-e "s%[@]DEFAULT_DNSSERVER[@]%$(DEFAULT_DNSSERVER)%g" \
 	-e "s%[@]DEFAULT_SSL_CRTD[@]%$(DEFAULT_SSL_CRTD)%g" \
 	-e "s%[@]DEFAULT_UNLINKD[@]%$(DEFAULT_UNLINKD)%g" \
 	-e "s%[@]DEFAULT_PINGER[@]%$(DEFAULT_PINGER)%g" \
@@ -1095,10 +1076,17 @@ check_PROGRAMS+=\
 	tests/testStore \
 	tests/testString \
 	tests/testURL \
+	tests/testSBuf \
 	tests/testConfigParser \
 	tests/testStatHist \
-	tests/testVector \
-	$(STORE_TESTS)
+	tests/testVector
+
+if HAVE_FS_ROCK
+check_PROGRAMS += tests/testRock
+endif
+if HAVE_FS_UFS
+check_PROGRAMS += tests/testUfs
+endif
 
 ## NP: required to run the above list. check_PROGRAMS only builds the binaries...
 TESTS += $(check_PROGRAMS)
@@ -1131,7 +1119,7 @@ tests_testHttpReply_SOURCES=\
 	cbdata.cc \
 	cbdata.h \
 	ConfigParser.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	HttpBody.h \
@@ -1159,17 +1147,22 @@ tests_testHttpReply_SOURCES=\
 	HttpReply.cc \
 	HttpReply.h \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	RegexList.h \
 	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
 	mime_header.h \
 	mime_header.cc \
+	Notes.h \
+	Notes.cc \
 	Packer.cc \
 	Packer.h \
 	SquidString.h \
 	SquidTime.h \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
@@ -1183,6 +1176,7 @@ tests_testHttpReply_SOURCES=\
 	tests/stub_errorpage.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_libformat.cc \
+	tests/stub_libauth.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -1196,7 +1190,7 @@ tests_testHttpReply_SOURCES=\
 	tests/testHttpReply.cc \
 	tests/testHttpReply.h \
 	tests/testMain.cc \
-	time.cc \
+	tests/stub_time.cc \
 	url.cc \
 	URLScheme.cc \
 	wordlist.h \
@@ -1209,7 +1203,6 @@ tests_testHttpReply_LDADD=\
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	anyp/libanyp.la \
 	ip/libip.la \
 	base/libbase.la \
@@ -1231,7 +1224,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	ConfigParser.cc \
 	DiskIO/ReadRequest.cc \
 	DiskIO/WriteRequest.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	event.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
@@ -1259,6 +1252,8 @@ tests_testACLMaxUserIP_SOURCES= \
 	int.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
+	Notes.cc \
+	Notes.h \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
@@ -1272,22 +1267,20 @@ tests_testACLMaxUserIP_SOURCES= \
 	StrList.cc \
 	tests/stub_StatHist.cc \
 	stmem.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	store_dir.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
 	swap_log_op.cc \
 	swap_log_op.h \
-	SwapDir.cc \
+	tests/stub_SwapDir.cc \
 	SwapDir.h \
 	log/access_log.h \
 	tests/stub_access_log.cc \
@@ -1304,6 +1297,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_HttpRequest.cc \
 	tests/stub_HttpReply.cc \
 	tests/stub_ipc_TypedMsgHdr.cc \
+	tests/stub_libauth.cc \
 	tests/stub_libcomm.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libsslsquid.cc \
@@ -1326,13 +1320,13 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/testACLMaxUserIP.cc \
 	tests/testACLMaxUserIP.h \
 	tests/testMain.cc \
-	time.cc \
+	tests/stub_time.cc \
 	url.cc \
 	URL.h \
 	URLScheme.cc \
 	URLScheme.h \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	MemBuf.cc \
 	wordlist.h \
 	wordlist.cc
@@ -1345,7 +1339,6 @@ tests_testACLMaxUserIP_LDADD= \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	base/libbase.la \
@@ -1372,7 +1365,7 @@ tests_testBoilerplate_SOURCES = \
 	tests/testBoilerplate.cc \
 	tests/testMain.cc \
 	tests/testBoilerplate.h \
-	time.cc
+	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	$(TESTSOURCES)
 tests_testBoilerplate_LDADD= \
@@ -1387,7 +1380,6 @@ tests_testBoilerplate_DEPENDENCIES = \
 ## Tests of the CacheManager module.
 tests_testCacheManager_SOURCES = \
 	AccessLogEntry.cc \
-	$(ACL_REGISTRATION_SOURCES) \
 	debug.cc \
 	HttpParser.cc \
 	HttpParser.h \
@@ -1396,14 +1388,15 @@ tests_testCacheManager_SOURCES = \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	String.cc \
 	tests/testCacheManager.cc \
 	tests/testCacheManager.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
+	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
@@ -1414,9 +1407,9 @@ tests_testCacheManager_SOURCES = \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	carp.h \
-	carp.cc \
+	tests/stub_carp.cc \
 	cbdata.cc \
 	ChunkedCodingParser.cc \
 	client_db.h \
@@ -1441,7 +1434,7 @@ tests_testCacheManager_SOURCES = \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	event.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
@@ -1501,7 +1494,6 @@ tests_testCacheManager_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
-	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1524,11 +1516,14 @@ tests_testCacheManager_SOURCES = \
 	peer_userhash.h \
 	peer_userhash.cc \
 	redirect.h \
-	redirect.cc \
+	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	Server.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
@@ -1540,13 +1535,15 @@ tests_testCacheManager_SOURCES = \
 	StatHist.h \
 	StrList.h \
 	StrList.cc \
+	tests/stub_libauth_acls.cc \
+	tests/stub_libauth.cc \
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	repl_modules.h \
 	store.cc \
 	store_client.cc \
 	store_digest.h \
-	store_digest.cc \
+	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
@@ -1561,29 +1558,24 @@ tests_testCacheManager_SOURCES = \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	tools.h \
 	tools.cc \
 	Transients.cc \
-	tunnel.cc \
-	SwapDir.cc \
+	tests/stub_tunnel.cc \
+	tests/stub_SwapDir.cc \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
-	wccp2.cc \
+	tests/stub_wccp2.cc \
 	whois.h \
-	whois.cc \
+	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
@@ -1594,11 +1586,9 @@ nodist_tests_testCacheManager_SOURCES = \
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
 	http/libsquid-http.la \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -1636,7 +1626,7 @@ tests_testCacheManager_DEPENDENCIES = \
 
 tests_testDiskIO_SOURCES = \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	client_db.h \
 	ClientInfo.h \
@@ -1646,7 +1636,7 @@ tests_testDiskIO_SOURCES = \
 	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
@@ -1685,7 +1675,9 @@ tests_testDiskIO_SOURCES = \
 	MemObject.cc \
 	mem_node.cc \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
+	Notes.h \
+	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	refresh.h \
@@ -1698,15 +1690,13 @@ tests_testDiskIO_SOURCES = \
 	StatHist.h \
 	tests/stub_StatHist.cc \
 	stmem.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	store_dir.cc \
 	store_io.cc \
@@ -1719,7 +1709,7 @@ tests_testDiskIO_SOURCES = \
 	String.cc \
 	StrList.h \
 	StrList.cc \
-	SwapDir.cc \
+	tests/stub_SwapDir.cc \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
@@ -1741,6 +1731,8 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libauth_acls.cc \
+	tests/stub_libauth.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
@@ -1759,7 +1751,7 @@ tests_testDiskIO_SOURCES = \
 	tests/testMain.cc \
 	tests/testStoreSupport.cc \
 	tests/testStoreSupport.h \
-	time.cc \
+	tests/stub_time.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	URLScheme.cc \
@@ -1779,11 +1771,9 @@ tests_testDiskIO_LDADD = \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	libsquid.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
@@ -1816,10 +1806,9 @@ tests_testDiskIO_DEPENDENCIES = \
 ## Tests of the Even module.
 tests_testEvent_SOURCES = \
 	AccessLogEntry.cc \
-	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
@@ -1828,7 +1817,7 @@ tests_testEvent_SOURCES = \
 	cache_cf.cc \
 	cache_manager.cc \
 	carp.h \
-	carp.cc \
+	tests/stub_carp.cc \
 	cbdata.cc \
 	ChunkedCodingParser.cc \
 	client_db.h \
@@ -1854,7 +1843,7 @@ tests_testEvent_SOURCES = \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	event.cc \
 	EventLoop.h \
 	EventLoop.cc \
@@ -1920,9 +1909,8 @@ tests_testEvent_SOURCES = \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	mem_node.cc \
-	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1947,13 +1935,16 @@ tests_testEvent_SOURCES = \
 	peer_userhash.h \
 	peer_userhash.cc \
 	redirect.h \
-	redirect.cc \
+	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	Server.cc \
 	StrList.h \
 	StrList.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
@@ -1969,7 +1960,7 @@ tests_testEvent_SOURCES = \
 	store.cc \
 	store_client.cc \
 	store_digest.h \
-	store_digest.cc \
+	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
@@ -1984,39 +1975,36 @@ tests_testEvent_SOURCES = \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
-	SwapDir.cc \
+	tests/stub_SwapDir.cc \
 	tests/CapturingStoreEntry.h \
 	tests/testEvent.cc \
 	tests/testEvent.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libauth_acls.cc \
+	tests/stub_libauth.cc \
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
 	Transients.cc \
-	tunnel.cc \
+	tests/stub_tunnel.cc \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
-	wccp2.cc \
+	tests/stub_wccp2.cc \
 	whois.h \
-	whois.cc \
+	tests/stub_whois.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
@@ -2025,11 +2013,9 @@ nodist_tests_testEvent_SOURCES = \
 	$(DISKIO_GEN_SOURCE)
 tests_testEvent_LDADD = \
 	http/libsquid-http.la \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -2067,10 +2053,9 @@ tests_testEvent_DEPENDENCIES = \
 ## Tests of the EventLoop module.
 tests_testEventLoop_SOURCES = \
 	AccessLogEntry.cc \
-	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -2079,7 +2064,7 @@ tests_testEventLoop_SOURCES = \
 	RefreshPattern.h \
 	cache_cf.cc \
 	carp.h \
-	carp.cc \
+	tests/stub_carp.cc \
 	cbdata.cc \
 	ChunkedCodingParser.cc \
 	client_db.h \
@@ -2105,7 +2090,7 @@ tests_testEventLoop_SOURCES = \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	EventLoop.h \
 	EventLoop.cc \
 	event.cc \
@@ -2170,11 +2155,10 @@ tests_testEventLoop_SOURCES = \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
-	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	mem_node.cc \
 	mime.h \
 	mime.cc \
@@ -2199,10 +2183,13 @@ tests_testEventLoop_SOURCES = \
 	peer_userhash.cc \
 	RemovalPolicy.cc \
 	redirect.h \
-	redirect.cc \
+	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	Server.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
@@ -2219,7 +2206,7 @@ tests_testEventLoop_SOURCES = \
 	store.cc \
 	store_client.cc \
 	store_digest.h \
-	store_digest.cc \
+	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
@@ -2234,40 +2221,37 @@ tests_testEventLoop_SOURCES = \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
-	SwapDir.cc \
+	tests/stub_SwapDir.cc \
 	tests/testEventLoop.cc \
 	tests/testEventLoop.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libauth_acls.cc \
+	tests/stub_libauth.cc \
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
 	Transients.cc \
-	tunnel.cc \
+	tests/stub_tunnel.cc \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
-	wccp2.cc \
+	tests/stub_wccp2.cc \
 	whois.h \
-	whois.cc \
+	tests/stub_whois.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
@@ -2276,11 +2260,9 @@ nodist_tests_testEventLoop_SOURCES = \
 	$(DISKIO_GEN_SOURCE)
 tests_testEventLoop_LDADD = \
 	http/libsquid-http.la \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -2317,7 +2299,6 @@ tests_testEventLoop_DEPENDENCIES = \
 
 tests_test_http_range_SOURCES = \
 	AccessLogEntry.cc \
-	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -2327,9 +2308,9 @@ tests_test_http_range_SOURCES = \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	carp.h \
-	carp.cc \
+	tests/stub_carp.cc \
 	cbdata.cc \
 	ChunkedCodingParser.cc \
 	client_db.h \
@@ -2355,12 +2336,11 @@ tests_test_http_range_SOURCES = \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	event.cc \
-	external_acl.cc \
-	ExternalACLEntry.cc \
 	FadingCounter.cc \
 	fatal.h \
+	tests/stub_libauth.cc \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
@@ -2418,11 +2398,10 @@ tests_test_http_range_SOURCES = \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
-	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	mem_node.cc \
 	mime.h \
 	mime.cc \
@@ -2446,11 +2425,14 @@ tests_test_http_range_SOURCES = \
 	peer_userhash.cc \
 	pconn.cc \
 	redirect.h \
-	redirect.cc \
+	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	Server.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
@@ -2466,7 +2448,7 @@ tests_test_http_range_SOURCES = \
 	store.cc \
 	store_client.cc \
 	store_digest.h \
-	store_digest.cc \
+	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
@@ -2481,37 +2463,34 @@ tests_test_http_range_SOURCES = \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
-	SwapDir.cc \
+	tests/stub_SwapDir.cc \
 	tests/test_http_range.cc \
+	tests/stub_external_acl.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_libeui.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
+	tests/stub_EventLoop.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
-	tunnel.cc \
+	tests/stub_tunnel.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
-	wccp2.cc \
+	tests/stub_wccp2.cc \
 	whois.h \
-	whois.cc \
+	tests/stub_whois.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
@@ -2520,11 +2499,9 @@ nodist_tests_test_http_range_SOURCES = \
 	$(DISKIO_GEN_SOURCE)
 tests_test_http_range_LDADD = \
 	http/libsquid-http.la \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2565,7 +2542,7 @@ tests_testHttpParser_SOURCES = \
 	MemBuf.cc \
 	MemBuf.h \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	String.cc \
 	cache_cf.h \
 	YesNoNone.h \
@@ -2580,7 +2557,7 @@ tests_testHttpParser_SOURCES = \
 	tests/testHttpParser.cc \
 	tests/testHttpParser.h \
 	tests/testMain.cc \
-	time.cc \
+	tests/stub_time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpParser_SOURCES = \
@@ -2601,26 +2578,27 @@ tests_testHttpParser_DEPENDENCIES = \
 ## Tests of the HttpRequest module.
 tests_testHttpRequest_SOURCES = \
 	AccessLogEntry.cc \
-	$(ACL_REGISTRATION_SOURCES) \
 	HttpParser.cc \
 	HttpParser.h \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	String.cc \
 	tests/testHttpRequest.h \
 	tests/testHttpRequest.cc \
 	tests/testHttpRequestMethod.h \
 	tests/testHttpRequestMethod.cc \
 	tests/testMain.cc \
 	tests/stub_DiskIOModule.cc \
+	tests/stub_libauth.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
+	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
@@ -2632,9 +2610,9 @@ tests_testHttpRequest_SOURCES = \
 	cache_cf.cc \
 	debug.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	carp.h \
-	carp.cc \
+	tests/stub_carp.cc \
 	cbdata.cc \
 	ChunkedCodingParser.cc \
 	client_db.h \
@@ -2658,7 +2636,7 @@ tests_testHttpRequest_SOURCES = \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
-	ETag.cc \
+	tests/stub_ETag.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	fatal.h \
@@ -2714,7 +2692,6 @@ tests_testHttpRequest_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
-	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -2737,11 +2714,15 @@ tests_testHttpRequest_SOURCES = \
 	peer_userhash.h \
 	peer_userhash.cc \
 	redirect.h \
-	redirect.cc \
+	tests/stub_libauth_acls.cc \
+	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	Server.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
@@ -2757,7 +2738,7 @@ tests_testHttpRequest_SOURCES = \
 	store.cc \
 	store_client.cc \
 	store_digest.h \
-	store_digest.cc \
+	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
@@ -2772,43 +2753,36 @@ tests_testHttpRequest_SOURCES = \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	StrList.h \
 	StrList.cc \
 	event.cc \
 	tools.h \
 	tools.cc \
 	Transients.cc \
-	tunnel.cc \
-	SwapDir.cc \
+	tests/stub_tunnel.cc \
+	tests/stub_SwapDir.cc \
 	MemStore.cc \
 	url.cc \
 	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
-	wccp2.cc \
+	tests/stub_wccp2.cc \
 	whois.h \
-	whois.cc \
+	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpRequest_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testHttpRequest_LDADD = \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2847,7 +2821,7 @@ tests_testHttpRequest_DEPENDENCIES = \
 ## first line - what we are testing.
 tests_testStore_SOURCES= \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	ClientInfo.h \
 	ConfigOption.cc \
@@ -2888,10 +2862,12 @@ tests_testStore_SOURCES= \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
+	Notes.h \
+	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
@@ -2908,16 +2884,14 @@ tests_testStore_SOURCES= \
 	store_io.cc \
 	store_swapout.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
@@ -2941,6 +2915,7 @@ tests_testStore_SOURCES= \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libauth.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	HttpBody.h \
@@ -2973,7 +2948,7 @@ tests_testStore_SOURCES= \
 	tests/testStoreSupport.h \
 	tests/TestSwapDir.cc \
 	tests/TestSwapDir.h \
-	time.cc \
+	tests/stub_time.cc \
 	url.cc \
 	URLScheme.cc \
 	wordlist.h \
@@ -2987,11 +2962,9 @@ nodist_tests_testStore_SOURCES= \
 
 tests_testStore_LDADD= \
 	http/libsquid-http.la \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -3021,7 +2994,7 @@ tests_testStore_DEPENDENCIES = \
 tests_testString_SOURCES = \
 	ClientInfo.h \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	MemBuf.cc \
 	String.cc \
 	tests/testMain.cc \
@@ -3035,7 +3008,7 @@ tests_testString_SOURCES = \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
 	tests/stub_tools.cc \
-	time.cc \
+	tests/stub_time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testString_SOURCES = \
@@ -3057,11 +3030,9 @@ tests_testString_DEPENDENCIES = \
 SWAP_TEST_DS =\
 	repl_modules.o \
 	$(DISK_LIBS) \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -3081,7 +3052,9 @@ tests_testUfs_SOURCES = \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
+	tests/stub_ipcache.cc \
 	tests/stub_libeui.cc \
+	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
@@ -3115,15 +3088,12 @@ tests_testUfs_SOURCES = \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemObject.cc \
+	Notes.h \
+	Notes.cc \
 	StoreSwapLogData.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
+	$(STOREMETA_SOURCE) \
 	StoreFileSystem.cc \
 	store_io.cc \
 	store_swapout.cc \
@@ -3133,7 +3103,7 @@ tests_testUfs_SOURCES = \
 	event.cc \
 	$(DELAY_POOL_SOURCE) \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	ConfigParser.cc \
 	EventLoop.cc \
 	HttpMsg.cc \
@@ -3153,10 +3123,14 @@ tests_testUfs_SOURCES = \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	tests/stub_debug.cc \
 	tests/stub_client_side_request.cc \
 	tests/stub_http.cc \
+	tests/stub_libauth.cc \
 	mem_node.cc \
 	stmem.cc \
 	mime.h \
@@ -3214,11 +3188,9 @@ tests_testUfs_LDADD = \
 	http/libsquid-http.la \
 	CommCalls.o \
 	DnsLookupDetails.o \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
@@ -3264,9 +3236,9 @@ testRefCount_LDADD = \
 tests_testRock_SOURCES = \
 	cbdata.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
 	CollapsedForwarding.h \
 	CollapsedForwarding.cc \
+	tests/stub_CacheDigest.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	disk.h \
@@ -3300,7 +3272,6 @@ tests_testRock_SOURCES = \
 	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
-	$(SBUF_SOURCE) \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
@@ -3310,6 +3281,8 @@ tests_testRock_SOURCES = \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
+	Notes.h \
+	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
@@ -3324,20 +3297,18 @@ tests_testRock_SOURCES = \
 	store.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
-	StoreMetaURL.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaVary.cc \
+	$(STOREMETA_SOURCE) \
 	StoreSwapLogData.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
 	store_swapmeta.cc \
 	store_swapout.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
@@ -3354,21 +3325,23 @@ tests_testRock_SOURCES = \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
-	tests/stub_cache_manager.cc \
 	client_db.h \
+	tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc \
 	tests/stub_client_side_request.cc \
 	tests/stub_debug.cc \
 	tests/stub_errorpage.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
 	tests/stub_HttpRequest.cc \
+	tests/stub_libauth.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
+	tests/stub_libmgr.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
@@ -3401,7 +3374,6 @@ tests_testRock_LDADD = \
 	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
-	$(AUTH_LIBS) \
 	$(COMMON_LIBS) \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
@@ -3410,7 +3382,6 @@ tests_testRock_LDADD = \
 	acl/libapi.la \
 	acl/libstate.la \
 	ipc/libipc.la \
-	mgr/libmgr.la \
 	base/libbase.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -3425,187 +3396,22 @@ tests_testRock_LDFLAGS = $(INCLUDES) $(LIBADD_DL)
 tests_testRock_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
-tests_testCoss_SOURCES = \
-	tests/testCoss.cc \
-	tests/testMain.cc \
-	tests/testCoss.h \
-	tests/stub_cache_manager.cc \
-	client_db.h \
-	tests/stub_client_db.cc \
-	tests/stub_debug.cc \
-	tests/stub_HelperChildConfig.cc \
-	internal.h \
-	tests/stub_internal.cc \
-	tests/stub_ipc.cc \
-	tests/stub_libeui.cc \
-	tests/stub_pconn.cc \
-	store_rebuild.h \
-	tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc \
-	fatal.h \
-	tests/stub_fatal.cc \
-	fd.h \
-	fd.cc \
-	fde.h \
-	fde.cc \
-	disk.h \
-	disk.cc \
-	FileMap.h \
-	filemap.cc \
-	HttpBody.h \
-	HttpBody.cc \
-	HttpReply.cc \
-	int.h \
-	int.cc \
-	SquidList.h \
-	SquidList.cc \
-	MemObject.cc \
-	StoreSwapLogData.cc \
-	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
-	StoreFileSystem.cc \
-	store_io.cc \
-	store_swapout.cc \
-	store_swapmeta.cc \
-	$(UNLINKDSOURCE) \
-	$(WIN32_SOURCE) \
-	event.cc \
-	$(DELAY_POOL_SOURCE) \
-	CacheDigest.h \
-	CacheDigest.cc \
-	ConfigParser.cc \
-	EventLoop.cc \
-	HttpMsg.cc \
-	RemovalPolicy.cc \
-	store_dir.cc \
-	repl_modules.h \
-	store.cc \
-	HttpRequestMethod.cc \
-	store_key_md5.h \
-	store_key_md5.cc \
-	Parsing.cc \
-	ConfigOption.cc \
-	SwapDir.cc \
-	tests/stub_acl.cc \
-	cache_cf.h \
-	YesNoNone.h \
-	tests/stub_cache_cf.cc \
-	tests/stub_helper.cc \
-	cbdata.cc \
-	String.cc \
-	tests/stub_client_side_request.cc \
-	tests/stub_http.cc \
-	mem_node.cc \
-	stmem.cc \
-	mime.h \
-	tests/stub_mime.cc \
-	HttpHeaderFieldInfo.h \
-	HttpHeaderTools.h \
-	HttpHeaderTools.cc \
-	HttpHeader.h \
-	HttpHeader.cc \
-	Mem.h \
-	mem.cc \
-	ClientInfo.h \
-	MemBuf.cc \
-	HttpHdrContRange.cc \
-	Packer.cc \
-	HttpHeaderFieldStat.h \
-	HttpHdrCc.h \
-	HttpHdrCc.cc \
-	HttpHdrCc.cci \
-	HttpHdrSc.cc \
-	HttpHdrScTarget.cc \
-	url.cc \
-	StatCounters.h \
-	StatCounters.cc \
-	StatHist.h \
-	tests/stub_StatHist.cc \
-	tests/stub_errorpage.cc \
-	tests/stub_HttpRequest.cc \
-	log/access_log.h \
-	tests/stub_access_log.cc \
-	refresh.h \
-	refresh.cc \
-	tests/stub_MemStore.cc \
-	tests/stub_Port.cc \
-	tests/stub_store_client.cc \
-	tests/stub_store_stats.cc \
-	tools.h \
-	tests/stub_tools.cc \
-	tests/stub_UdsOp.cc \
-	tests/testStoreSupport.cc \
-	tests/testStoreSupport.h \
-	time.cc \
-	URLScheme.cc \
-	wordlist.h \
-	wordlist.cc \
-	$(DISKIO_SOURCE)
-
-nodist_tests_testCoss_SOURCES = \
-	swap_log_op.cc \
-	SquidMath.cc \
-	SquidMath.h \
-	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE)
-tests_testCoss_LDADD = \
-	anyp/libanyp.la \
-	libsquid.la \
-	$(REGEXLIB) \
-	$(AUTH_ACL_LIBS) \
-	ident/libident.la \
-	acl/libacls.la \
-	acl/libstate.la \
-	$(AUTH_LIBS) \
-	acl/libapi.la \
-	libsquid.la \
-	comm/libcomm.la \
-	ip/libip.la \
-	fs/libfs.la \
-	mgr/libmgr.la \
-	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
-	$(COMMON_LIBS) \
-	$(SSL_LIBS) \
-	acl/libapi.la \
-	ipc/libipc.la \
-	base/libbase.la \
-	$(top_builddir)/lib/libmisccontainers.la \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(REGEXLIB) \
-	$(SSLLIB) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-tests_testCoss_LDFLAGS = $(LIBADD_DL)
-tests_testCoss_DEPENDENCIES = \
-	$(SWAP_TEST_DS)
-
 ## Tests of the URL module.
 ## TODO: Trim this down once the insanity is over.
 tests_testURL_SOURCES = \
 	AccessLogEntry.cc \
-	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
-	cache_manager.cc \
+	tests/stub_cache_manager.cc \
 	CacheDigest.h \
-	CacheDigest.cc \
+	tests/stub_CacheDigest.cc \
 	carp.h \
-	carp.cc \
+	tests/stub_carp.cc \
 	cbdata.cc \
 	ChunkedCodingParser.cc \
 	client_db.h \
@@ -3696,9 +3502,8 @@ tests_testURL_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	Mem.h \
-	mem.cc \
+	tests/stub_mem.cc \
 	mem_node.cc \
-	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -3707,8 +3512,8 @@ tests_testURL_SOURCES = \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
-	Notes.cc \
 	Notes.h \
+	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
@@ -3721,11 +3526,14 @@ tests_testURL_SOURCES = \
 	peer_userhash.h \
 	peer_userhash.cc \
 	redirect.h \
-	redirect.cc \
+	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	Server.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
@@ -3741,7 +3549,7 @@ tests_testURL_SOURCES = \
 	store.cc \
 	store_client.cc \
 	store_digest.h \
-	store_digest.cc \
+	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
@@ -3756,22 +3564,19 @@ tests_testURL_SOURCES = \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
+	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
-	SwapDir.cc \
 	Transients.cc \
+	tests/stub_SwapDir.cc \
 	MemStore.cc \
 	tests/stub_debug.cc \
 	tests/stub_DiskIOModule.cc \
+	tests/stub_libauth_acls.cc \
+	tests/stub_libauth.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
@@ -3780,18 +3585,19 @@ tests_testURL_SOURCES = \
 	tests/testURLScheme.cc \
 	tests/testURLScheme.h \
 	tests/testMain.cc \
-	time.cc \
+	tests/stub_time.cc \
+	tests/stub_EventLoop.cc \
 	tools.h \
 	tools.cc \
-	tunnel.cc \
+	tests/stub_tunnel.cc \
 	url.cc \
 	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
-	wccp2.cc \
+	tests/stub_wccp2.cc \
 	whois.h \
-	whois.cc \
+	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
@@ -3801,12 +3607,10 @@ nodist_tests_testURL_SOURCES = \
 tests_testURL_LDADD = \
 	http/libsquid-http.la \
 	anyp/libanyp.la \
-	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
-	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -3840,11 +3644,50 @@ tests_testURL_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
+tests_testSBuf_SOURCES= \
+	tests/testSBuf.h \
+	tests/testSBuf.cc \
+	tests/testMain.cc \
+	tests/SBufFindTest.h \
+	tests/SBufFindTest.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
+	SBufStream.h \
+	tests/stub_time.cc \
+	mem.cc \
+	tests/stub_debug.cc \
+	tests/stub_fatal.cc \
+	tests/stub_HelperChildConfig.cc \
+	tests/stub_cache_cf.cc \
+	tests/stub_cache_manager.cc \
+	tests/stub_store.cc \
+	tests/stub_store_stats.cc \
+	tests/stub_tools.cc \
+	SquidString.h \
+	String.cc \
+	tests/stub_wordlist.cc \
+	tests/stub_MemBuf.cc
+nodist_tests_testSBuf_SOURCES=$(TESTSOURCES)
+tests_testSBuf_LDFLAGS = $(LIBADD_DL)
+tests_testSBuf_LDADD=\
+	$(SQUID_CPPUNIT_LIBS) \
+	$(SQUID_CPPUNIT_LA) \
+	$(COMPAT_LIB) \
+	libsquid.la \
+	ip/libip.la \
+	mgr/libmgr.la \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMMON_LIBS)
+tests_testSBuf_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
+
 tests_testConfigParser_SOURCES = \
 	ClientInfo.h \
 	Mem.h \
-	mem.cc \
-	MemBuf.cc \
+	tests/stub_mem.cc \
+	tests/stub_MemBuf.cc \
+	tests/stub_time.cc \
 	String.cc \
 	ConfigParser.cc \
 	fatal.h \
@@ -3860,7 +3703,6 @@ tests_testConfigParser_SOURCES = \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
 	tests/stub_tools.cc \
-	time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testConfigParser_SOURCES = \
@@ -3880,10 +3722,10 @@ tests_testConfigParser_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 	
 tests_testStatHist_SOURCES = \
-	cbdata.cc \
+	tests/stub_cbdata.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
-	MemBuf.cc \
+	tests/stub_MemBuf.cc \
 	StatHist.cc \
 	StatHist.h \
 	String.cc \
@@ -3906,8 +3748,7 @@ tests_testStatHist_SOURCES = \
 	tests/stub_tools.cc \
 	tests/testMain.cc \
 	tests/testStatHist.cc \
-	tests/testStatHist.h \
-	time.cc
+	tests/testStatHist.h
 nodist_tests_testStatHist_SOURCES = \
 	$(TESTSOURCES)
 tests_testStatHist_LDFLAGS = $(LIBADD_DL)
@@ -3923,8 +3764,7 @@ tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 tests_testVector_SOURCES = \
 	tests/testVector.cc \
 	tests/testMain.cc \
-	tests/testVector.h \
-	time.cc
+	tests/testVector.h
 nodist_tests_testVector_SOURCES = \
 	$(TESTSOURCES)
 tests_testVector_LDADD= \
@@ -1,6 +1,4 @@
 /*
- * MemBlob.cc (C) 2009 Francesco Chemolli <kinkie@squid-cache.org>
- *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
  *
@@ -33,6 +31,7 @@
 #include "Debug.h"
 #include "Mem.h"
 #include "MemBlob.h"
+#include "SBufDetailedStats.h"
 
 #if HAVE_IOSTREAM
 #include <iostream>
@@ -46,6 +45,17 @@ InstanceIdDefinitions(MemBlob, "blob");
 MemBlobStats::MemBlobStats(): alloc(0), live(0), append(0), liveBytes(0)
 {}
 
+MemBlobStats&
+MemBlobStats::operator += (const MemBlobStats& s)
+{
+    alloc+=s.alloc;
+    live+=s.live;
+    append+=s.append;
+    liveBytes+=s.liveBytes;
+
+    return *this;
+}
+
 std::ostream&
 MemBlobStats::dump(std::ostream &os) const
 {
@@ -87,6 +97,7 @@ MemBlob::~MemBlob()
         memFreeString(capacity,mem);
     Stats.liveBytes -= capacity;
     --Stats.live;
+    recordMemBlobSizeAtDestruct(size);
 
     debugs(MEMBLOB_DEBUGSECTION,9, HERE << "destructed, this="
            << static_cast<void*>(this) << " id=" << id
@@ -1,6 +1,4 @@
 /*
- * MemBlob.h (C) 2009 Francesco Chemolli <kinkie@squid-cache.org>
- *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
  *
@@ -46,6 +44,8 @@ class MemBlobStats
     /// dumps class-wide statistics
     std::ostream& dump(std::ostream& os) const;
 
+    MemBlobStats& operator += (const MemBlobStats&);
+
 public:
     uint64_t alloc;     ///< number of MemBlob instances created so far
     uint64_t live;      ///< number of MemBlob instances currently alive
@@ -66,7 +66,7 @@ class MemBlob: public RefCountable
 {
 public:
     typedef RefCount<MemBlob> Pointer;
-    typedef size_t size_type;
+    typedef uint32_t size_type;
 
     MEMPROXY_CLASS(MemBlob);
 
@@ -76,7 +76,7 @@ MemObject::inUseCount()
 
 const char *
 MemObject::storeId() const {
-    if (!storeId_.defined()) {
+    if (!storeId_.size()) {
         debugs(20, DBG_IMPORTANT, "Bug: Missing MemObject::storeId value");
         dump();
         storeId_ = "[unknown_URI]";
@@ -86,12 +86,12 @@ MemObject::storeId() const {
 
 const char *
 MemObject::logUri() const {
-    return logUri_.defined() ? logUri_.termedBuf() : storeId();
+    return logUri_.size() ? logUri_.termedBuf() : storeId();
 }
 
 bool
 MemObject::hasUris() const {
-    return storeId_.defined();
+    return storeId_.size();
 }
 
 void
@@ -0,0 +1,24 @@
+#ifndef SQUID_SRC_MESSAGESIZES_H
+#define SQUID_SRC_MESSAGESIZES_H
+
+/**
+ * Counters used to collate the traffic size measurements
+ * for a transaction message.
+ */
+class MessageSizes
+{
+public:
+    MessageSizes() : header(0), payloadData(0) {}
+
+    /// size of message header block (if any)
+    /// including message Request-Line or Start-Line.
+    uint64_t header;
+
+    /// total size of payload block(s) excluding transfer encoding overheads
+    uint64_t payloadData;
+
+    /// total message size
+    uint64_t messageTotal() const {return header + payloadData;}
+};
+
+#endif  /* SQUID_SRC_MESSAGESIZES_H */
@@ -28,13 +28,13 @@
  */
 
 #include "squid.h"
-#include "globals.h"
 #include "AccessLogEntry.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
-#include "HttpRequest.h"
+#include "globals.h"
 #include "HttpReply.h"
+#include "HttpRequest.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StrList.h"
@@ -56,7 +56,7 @@ Note::addValue(const String &value)
 }
 
 const char *
-Note::match(HttpRequest *request, HttpReply *reply)
+Note::match(HttpRequest *request, HttpReply *reply, const AccessLogEntry::Pointer &al)
 {
 
     typedef Values::iterator VLI;
@@ -69,8 +69,15 @@ Note::match(HttpRequest *request, HttpReply *reply)
         const int ret= ch.fastCheck((*i)->aclList);
         debugs(93, 5, HERE << "Check for header name: " << key << ": " << (*i)->value
                <<", HttpRequest: " << request << " HttpReply: " << reply << " matched: " << ret);
-        if (ret == ACCESS_ALLOWED)
-            return (*i)->value.termedBuf();
+        if (ret == ACCESS_ALLOWED) {
+            if (al != NULL && (*i)->valueFormat != NULL) {
+                static MemBuf mb;
+                mb.reset();
+                (*i)->valueFormat->assemble(mb, al, 0);
+                return mb.content();
+            } else
+                return (*i)->value.termedBuf();
+        }
     }
     return NULL;
 }
@@ -92,17 +99,22 @@ Notes::add(const String &noteKey)
 Note::Pointer
 Notes::parse(ConfigParser &parser)
 {
-    String key, value;
-    ConfigParser::ParseString(&key);
-    ConfigParser::ParseQuotedString(&value);
+    String key = ConfigParser::NextToken();
+    ConfigParser::EnableMacros();
+    String value = ConfigParser::NextQuotedToken();
+    ConfigParser::DisableMacros();
+    bool valueWasQuoted = ConfigParser::LastTokenWasQuoted();
     Note::Pointer note = add(key);
     Note::Value::Pointer noteValue = note->addValue(value);
 
     String label(key);
     label.append('=');
     label.append(value);
     aclParseAclList(parser, &noteValue->aclList, label.termedBuf());
-
+    if (formattedValues && valueWasQuoted) {
+        noteValue->valueFormat =  new Format::Format(descr ? descr : "Notes");
+        noteValue->valueFormat->parse(value.termedBuf());
+    }
     if (blacklisted) {
         for (int i = 0; blacklisted[i] != NULL; ++i) {
             if (note->key.caseCmp(blacklisted[i]) == 0) {
@@ -206,7 +218,7 @@ bool
 NotePairs::hasPair(const char *key, const char *value) const
 {
     for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
-        if ((*i)->name.cmp(key) == 0 || (*i)->value.cmp(value) == 0)
+        if ((*i)->name.cmp(key) == 0 && (*i)->value.cmp(value) == 0)
             return true;
     }
     return false;
@@ -220,12 +232,25 @@ NotePairs::append(const NotePairs *src)
     }
 }
 
+void
+NotePairs::appendNewOnly(const NotePairs *src)
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+        if (!hasPair((*i)->name.termedBuf(), (*i)->value.termedBuf()))
+            entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
+    }
+}
+
 NotePairs &
 SyncNotes(AccessLogEntry &ale, HttpRequest &request)
 {
+    // XXX: auth code only has access to HttpRequest being authenticated
+    // so we must handle the case where HttpRequest is set without ALE being set.
+
     if (!ale.notes) {
-        assert(!request.notes);
-        ale.notes = request.notes = new NotePairs;
+        if (!request.notes)
+            request.notes = new NotePairs;
+        ale.notes = request.notes;
     } else {
         assert(ale.notes == request.notes);
     }
@@ -2,9 +2,10 @@
 #define SQUID_NOTES_H
 
 #include "acl/forward.h"
-#include "base/Vector.h"
 #include "base/RefCount.h"
+#include "base/Vector.h"
 #include "CbDataList.h"
+#include "format/Format.h"
 #include "MemPool.h"
 #include "SquidString.h"
 #include "typedefs.h"
@@ -15,6 +16,7 @@
 
 class HttpRequest;
 class HttpReply;
+typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 
 /**
  * Used to store a note configuration. The notes are custom key:value
@@ -31,9 +33,11 @@ class Note: public RefCountable
     {
     public:
         typedef RefCount<Value> Pointer;
-        String value; ///< a note value
+        String value; ///< Configured annotation value, possibly with %macros
         ACLList *aclList; ///< The access list used to determine if this value is valid for a request
-        explicit Value(const String &aVal) : value(aVal), aclList(NULL) {}
+        /// Compiled annotation value format
+        Format::Format *valueFormat;
+        explicit Value(const String &aVal) : value(aVal), aclList(NULL), valueFormat(NULL) {}
         ~Value();
     };
     typedef Vector<Value::Pointer> Values;
@@ -50,8 +54,10 @@ class Note: public RefCountable
      * Walks through the  possible values list of the note and selects
      * the first value which matches the given HttpRequest and HttpReply
      * or NULL if none matches.
+     * If an AccessLogEntry given and Value::valueFormat is not null, the
+     * formatted value returned.
      */
-    const char *match(HttpRequest *request, HttpReply *reply);
+    const char *match(HttpRequest *request, HttpReply *reply, const AccessLogEntryPointer &al);
 
     String key; ///< The note key
     Values values; ///< The possible values list for the note
@@ -68,7 +74,7 @@ class Notes
     typedef NotesList::iterator iterator; ///< iterates over the notes list
     typedef NotesList::const_iterator const_iterator; ///< iterates over the notes list
 
-    Notes(const char *aDescr, const char **metasBlacklist): descr(aDescr), blacklisted(metasBlacklist) {}
+    Notes(const char *aDescr, const char **metasBlacklist, bool allowFormatted = false): descr(aDescr), blacklisted(metasBlacklist), formattedValues(allowFormatted) {}
     Notes(): descr(NULL), blacklisted(NULL) {}
     ~Notes() { notes.clean(); }
     /**
@@ -92,6 +98,7 @@ class Notes
     NotesList notes; ///< The Note::Pointer objects array list
     const char *descr; ///< A short description for notes list
     const char **blacklisted; ///< Null terminated list of blacklisted note keys
+    bool formattedValues; ///< Whether the formatted values are supported
 
 private:
     /**
@@ -130,6 +137,12 @@ class NotePairs: public RefCountable
      */
     void append(const NotePairs *src);
 
+    /**
+     * Append any new entries of the src NotePairs list to our list.
+     * Entries which already exist in the destination set are ignored.
+     */
+    void appendNewOnly(const NotePairs *src);
+
     /**
      * Returns a comma separated list of notes with key 'noteKey'.
      * Use findFirst instead when a unique kv-pair is needed.
@@ -0,0 +1,22 @@
+#ifndef _SQUID_SRC_OUTOFBOUNDSEXCEPTION_H
+#define _SQUID_SRC_OUTOFBOUNDSEXCEPTION_H
+
+#include "base/TextException.h"
+#include "SBuf.h"
+
+/**
+ * Exception raised when the user is going out of bounds when accessing
+ * a char within the SBuf
+ */
+class OutOfBoundsException : public TextException
+{
+public:
+    OutOfBoundsException(const SBuf &buf, SBuf::size_type &pos, const char *aFileName = 0, int aLineNo = -1);
+    virtual ~OutOfBoundsException() throw();
+
+protected:
+    SBuf theThrowingBuf;
+    SBuf::size_type accessedPosition;
+};
+
+#endif /* _SQUID_SRC_OUTOFBOUNDSEXCEPTION_H */
@@ -68,8 +68,8 @@
  */
 
 #include "squid.h"
-#include "Store.h"
 #include "MemBuf.h"
+#include "Store.h"
 
 /* local types */
 
@@ -34,9 +34,9 @@
 #include "cache_cf.h"
 #include "compat/strtoll.h"
 #include "ConfigParser.h"
-#include "Parsing.h"
-#include "globals.h"
 #include "Debug.h"
+#include "globals.h"
+#include "Parsing.h"
 
 /*
  * These functions is the same as atoi/l/f, except that they check for errors
@@ -147,7 +147,7 @@ xatos(const char *token)
 int64_t
 GetInteger64(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -162,7 +162,7 @@ GetInteger64(void)
 int
 GetInteger(void)
 {
-    char *token = ConfigParser::strtokFile();
+    char *token = ConfigParser::NextToken();
     int i;
 
     if (token == NULL)
@@ -189,8 +189,7 @@ GetInteger(void)
 int
 GetPercentage(void)
 {
-    int p;
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (!token) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: A percentage value is missing.");
@@ -203,7 +202,7 @@ GetPercentage(void)
         *end = '\0';
     }
 
-    p = xatoi(token);
+    int p = xatoi(token);
 
     if (p < 0 || p > 100) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is out of range. A percentage should be within [0, 100].");
@@ -216,7 +215,7 @@ GetPercentage(void)
 unsigned short
 GetShort(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -33,21 +33,22 @@
 #ifndef   SQUID_PEERSELECTSTATE_H
 #define   SQUID_PEERSELECTSTATE_H
 
+#include "AccessLogEntry.h"
 #include "acl/Checklist.h"
 #include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
-#include "PingData.h"
 #include "ip/Address.h"
+#include "PingData.h"
 
 class HttpRequest;
 class StoreEntry;
 class ErrorState;
 
 typedef void PSC(Comm::ConnectionList *, ErrorState *, void *);
 
-void peerSelect(Comm::ConnectionList *, HttpRequest *, StoreEntry *, PSC *, void *data);
+void peerSelect(Comm::ConnectionList *, HttpRequest *, AccessLogEntry::Pointer const&, StoreEntry *, PSC *, void *data);
 void peerSelectInit(void);
 
 /**
@@ -79,6 +80,7 @@ class ps_state
     const char * url() const;
 
     HttpRequest *request;
+    AccessLogEntry::Pointer al; ///< info for the future access.log entry
     StoreEntry *entry;
     allow_t always_direct;
     allow_t never_direct;
@@ -29,6 +29,8 @@
  *
  */
 
+#include "compat/GnuRegex.h"
+
 /// a representation of a refresh pattern. Currently a POD.
 class RefreshPattern
 {
@@ -0,0 +1,870 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "squid.h"
+#include "base/RefCount.h"
+#include "Debug.h"
+#include "OutOfBoundsException.h"
+#include "SBuf.h"
+#include "SBufDetailedStats.h"
+#include "SBufExceptions.h"
+#include "util.h"
+
+#if HAVE_STRING_H
+#include <string.h>
+#endif
+
+#if HAVE_SSTREAM
+#include <sstream>
+#endif
+
+#if HAVE_IOSTREAM
+#include <iostream>
+#endif
+
+#ifdef VA_COPY
+#undef VA_COPY
+#endif
+#if defined HAVE_VA_COPY
+#define VA_COPY va_copy
+#elif defined HAVE___VA_COPY
+#define VA_COPY __va_copy
+#endif
+
+InstanceIdDefinitions(SBuf, "SBuf");
+
+SBufStats SBuf::stats;
+const SBuf::size_type SBuf::npos;
+const SBuf::size_type SBuf::maxSize;
+
+SBufStats::SBufStats()
+        : alloc(0), allocCopy(0), allocFromString(0), allocFromCString(0),
+        assignFast(0), clear(0), append(0), toStream(0), setChar(0),
+        getChar(0), compareSlow(0), compareFast(0), copyOut(0),
+        rawAccess(0), chop(0), trim(0), find(0), scanf(0),
+        caseChange(0), cowFast(0), cowSlow(0), live(0)
+{}
+
+SBufStats&
+SBufStats::operator +=(const SBufStats& ss)
+{
+    alloc += ss.alloc;
+    allocCopy += ss.allocCopy;
+    allocFromString += ss.allocFromString;
+    allocFromCString += ss.allocFromCString;
+    assignFast += ss.assignFast;
+    clear += ss.clear;
+    append += ss.append;
+    toStream += ss.toStream;
+    setChar += ss.setChar;
+    getChar += ss.getChar;
+    compareSlow += ss.compareSlow;
+    compareFast += ss.compareFast;
+    copyOut += ss.copyOut;
+    rawAccess += ss.rawAccess;
+    chop += ss.chop;
+    trim += ss.trim;
+    find += ss.find;
+    scanf += ss.scanf;
+    caseChange += ss.caseChange;
+    cowFast += ss.cowFast;
+    cowSlow += ss.cowSlow;
+    live += ss.live;
+
+    return *this;
+}
+
+SBuf::SBuf()
+        : store_(GetStorePrototype()), off_(0), len_(0)
+{
+    debugs(24, 8, id << " created");
+    ++stats.alloc;
+    ++stats.live;
+}
+
+SBuf::SBuf(const SBuf &S)
+        : store_(S.store_), off_(S.off_), len_(S.len_)
+{
+    debugs(24, 8, id << " created from id " << S.id);
+    ++stats.alloc;
+    ++stats.allocCopy;
+    ++stats.live;
+}
+
+SBuf::SBuf(const String &S)
+        : store_(GetStorePrototype()), off_(0), len_(0)
+{
+    debugs(24, 8, id << " created from string");
+    assign(S.rawBuf(), S.size());
+    ++stats.alloc;
+    ++stats.allocFromString;
+    ++stats.live;
+}
+
+SBuf::SBuf(const std::string &s)
+        : store_(GetStorePrototype()), off_(0), len_(0)
+{
+    debugs(24, 8, id << " created from std::string");
+    lowAppend(s.data(),s.length());
+    ++stats.alloc;
+    ++stats.allocFromString;
+    ++stats.live;
+}
+
+SBuf::SBuf(const char *S, size_type n)
+        : store_(GetStorePrototype()), off_(0), len_(0)
+{
+    append(S,n);
+    ++stats.alloc;
+    ++stats.allocFromCString;
+    ++stats.live;
+}
+
+SBuf::~SBuf()
+{
+    debugs(24, 8, id << " destructed");
+    --stats.live;
+    recordSBufSizeAtDestruct(len_);
+}
+
+MemBlob::Pointer
+SBuf::GetStorePrototype()
+{
+    static MemBlob::Pointer InitialStore = new MemBlob(0);
+    return InitialStore;
+}
+
+SBuf&
+SBuf::assign(const SBuf &S)
+{
+    debugs(24, 7, "assigning " << id << " from " <<  S.id);
+    if (&S == this) //assignment to self. Noop.
+        return *this;
+    ++stats.assignFast;
+    store_ = S.store_;
+    off_ = S.off_;
+    len_ = S.len_;
+    return *this;
+}
+
+SBuf&
+SBuf::assign(const char *S, size_type n)
+{
+    debugs(24, 6, id << " from c-string, n=" << n << ")");
+    clear();
+    return append(S, n); //bounds checked in append()
+}
+
+void
+SBuf::reserveCapacity(size_type minCapacity)
+{
+    Must(minCapacity <= maxSize);
+    cow(minCapacity);
+}
+
+char *
+SBuf::rawSpace(size_type minSpace)
+{
+    Must(length() <= maxSize - minSpace);
+    debugs(24, 7, "reserving " << minSpace << " for " << id);
+    ++stats.rawAccess;
+    // we're not concerned about RefCounts here,
+    // the store knows the last-used portion. If
+    // it's available, we're effectively claiming ownership
+    // of it. If it's not, we need to go away (realloc)
+    if (store_->canAppend(off_+len_, minSpace)) {
+        debugs(24, 7, "not growing");
+        return bufEnd();
+    }
+    // TODO: we may try to memmove before realloc'ing in order to avoid
+    //   one allocation operation, if we're the sole owners of a MemBlob.
+    //   Maybe some heuristic on off_ and length()?
+    cow(minSpace+length());
+    return bufEnd();
+}
+
+void
+SBuf::clear()
+{
+#if 0
+    //enabling this code path, the store will be freed and reinitialized
+    store_ = GetStorePrototype(); //uncomment to actually free storage upon clear()
+#else
+    //enabling this code path, we try to release the store without deallocating it.
+    // will be lazily reallocated if needed.
+    if (store_->LockCount() == 1)
+        store_->clear();
+#endif
+    len_ = 0;
+    off_ = 0;
+    ++stats.clear;
+}
+
+SBuf&
+SBuf::append(const SBuf &S)
+{
+    return lowAppend(S.buf(), S.length());
+}
+
+SBuf &
+SBuf::append(const char * S, size_type Ssize)
+{
+    if (S == NULL)
+        return *this;
+    if (Ssize == npos)
+        Ssize = strlen(S);
+    debugs(24, 7, "from c-string to id " << id);
+    return lowAppend(S, Ssize);
+}
+
+SBuf&
+SBuf::Printf(const char *fmt, ...)
+{
+    va_list args;
+    va_start(args, fmt);
+    clear();
+    vappendf(fmt, args);
+    va_end(args);
+    return *this;
+}
+
+SBuf&
+SBuf::appendf(const char *fmt, ...)
+{
+    va_list args;
+    va_start(args, fmt);
+    vappendf(fmt, args);
+    va_end(args);
+    return *this;
+}
+
+SBuf&
+SBuf::vappendf(const char *fmt, va_list vargs)
+{
+    Must(fmt != NULL);
+    int sz = 0;
+    //reserve twice the format-string size, it's a likely heuristic
+    size_type requiredSpaceEstimate = strlen(fmt)*2;
+
+    char *space = rawSpace(requiredSpaceEstimate);
+#ifdef VA_COPY
+    va_list ap;
+    VA_COPY(ap, vargs);
+    sz = vsnprintf(space, spaceSize(), fmt, ap);
+    va_end(ap);
+#else
+    sz = vsnprintf(space, spaceSize(), fmt, vargs);
+#endif
+
+    /* check for possible overflow */
+    /* snprintf on Linux returns -1 on output errors, or the size
+     * that would have been written if enough space had been available */
+    /* vsnprintf is standard in C99 */
+
+    if (sz >= static_cast<int>(spaceSize())) {
+        // not enough space on the first go, we now know how much we need
+        requiredSpaceEstimate = sz*2; // TODO: tune heuristics
+        space = rawSpace(requiredSpaceEstimate);
+        sz = vsnprintf(space, spaceSize(), fmt, vargs);
+        if (sz < 0) // output error in vsnprintf
+            throw TextException("output error in second-go vsnprintf",__FILE__,
+                                __LINE__);
+    }
+
+    if (sz < 0) // output error in either vsnprintf
+        throw TextException("output error in vsnprintf",__FILE__, __LINE__);
+
+    // data was appended, update internal state
+    len_ += sz;
+
+    /* C99 specifies that the final '\0' is not counted in vsnprintf's
+     * return value. Older compilers/libraries might instead count it */
+    /* check whether '\0' was appended and counted */
+    static bool snPrintfTerminatorChecked = false;
+    static bool snPrintfTerminatorCounted = false;
+    if (!snPrintfTerminatorChecked) {
+        char testbuf[16];
+        snPrintfTerminatorCounted = snprintf(testbuf, sizeof(testbuf),
+                                             "%s", "1") == 2;
+        snPrintfTerminatorChecked = true;
+    }
+    if (snPrintfTerminatorCounted) {
+        --sz;
+        --len_;
+    }
+
+    store_->size += sz;
+    ++stats.append;
+
+    return *this;
+}
+
+std::ostream&
+SBuf::print(std::ostream &os) const
+{
+    os.write(buf(), length());
+    ++stats.toStream;
+    return os;
+}
+
+std::ostream&
+SBuf::dump(std::ostream &os) const
+{
+    os << id
+    << ": ";
+    store_->dump(os);
+    os << ", offset:" << off_
+    << ", len:" << len_
+    << ") : '";
+    print(os);
+    os << '\'' << std::endl;
+    return os;
+# if 0
+    // alternate implementation, based on Raw() API.
+    os << Raw("SBuf", buf(), length()) <<
+    ". id: " << id <<
+    ", offset:" << off_ <<
+    ", len:" << len_ <<
+    ", store: ";
+    store_->dump(os);
+    os << std::endl;
+    return os;
+#endif
+}
+
+void
+SBuf::setAt(size_type pos, char toset)
+{
+    checkAccessBounds(pos);
+    cow();
+    store_->mem[off_+pos] = toset;
+    ++stats.setChar;
+}
+
+static int
+memcasecmp(const char *b1, const char *b2, SBuf::size_type len)
+{
+    int rv=0;
+    while (len > 0) {
+        rv = tolower(*b1)-tolower(*b2);
+        if (rv != 0)
+            return rv;
+        ++b1;
+        ++b2;
+        --len;
+    }
+    return rv;
+}
+
+int
+SBuf::compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n) const
+{
+    if (n != npos)
+        return substr(0,n).compare(S.substr(0,n),isCaseSensitive);
+
+    size_type byteCompareLen = min(S.length(), length());
+    ++stats.compareSlow;
+    int rv = 0;
+    if (isCaseSensitive == caseSensitive) {
+        rv = memcmp(buf(), S.buf(), byteCompareLen);
+    } else {
+        rv = memcasecmp(buf(), S.buf(), byteCompareLen);
+    }
+    if (rv != 0)
+        return rv;
+    if (length() == S.length())
+        return 0;
+    if (length() > S.length())
+        return 1;
+    return -1;
+}
+
+bool
+SBuf::startsWith(const SBuf &S, SBufCaseSensitive isCaseSensitive) const
+{
+    debugs(24, 8, id << " startsWith " << S.id << ", caseSensitive: " <<
+           isCaseSensitive);
+    if (length() < S.length()) {
+        debugs(24, 8, "no, too short");
+        ++stats.compareFast;
+        return false;
+    }
+    return (compare(S, isCaseSensitive, S.length()) == 0);
+}
+
+bool
+SBuf::operator ==(const SBuf & S) const
+{
+    debugs(24, 8, id << " == " << S.id);
+    if (length() != S.length()) {
+        debugs(24, 8, "no, different lengths");
+        ++stats.compareFast;
+        return false; //shortcut: must be equal length
+    }
+    if (store_ == S.store_ && off_ == S.off_) {
+        debugs(24, 8, "yes, same length and backing store");
+        ++stats.compareFast;
+        return true;  //shortcut: same store, offset and length
+    }
+    ++stats.compareSlow;
+    const bool rv = (0 == memcmp(buf(), S.buf(), length()));
+    debugs(24, 8, "returning " << rv);
+    return rv;
+}
+
+bool
+SBuf::operator !=(const SBuf & S) const
+{
+    return !(*this == S);
+}
+
+SBuf
+SBuf::consume(size_type n)
+{
+    if (n == npos)
+        n = length();
+    else
+        n = min(n, length());
+    SBuf rv(substr(0, n));
+    chop(n);
+    return rv;
+}
+
+const
+SBufStats& SBuf::GetStats()
+{
+    return stats;
+}
+
+SBuf::size_type
+SBuf::copy(char *dest, size_type n) const
+{
+    size_type toexport = min(n,length());
+    memcpy(dest, buf(), toexport);
+    ++stats.copyOut;
+    return toexport;
+}
+
+const char*
+SBuf::rawContent() const
+{
+    ++stats.rawAccess;
+    return buf();
+}
+
+void
+SBuf::forceSize(size_type newSize)
+{
+    Must(store_->LockCount() == 1);
+    if (newSize > min(maxSize,store_->capacity-off_))
+        throw SBufTooBigException(__FILE__,__LINE__);
+    len_ = newSize;
+    store_->size = newSize;
+}
+
+const char*
+SBuf::c_str()
+{
+    ++stats.rawAccess;
+    /* null-terminate the current buffer, by hand-appending a \0 at its tail but
+     * without increasing its length. May COW, the side-effect is to guarantee that
+     * the MemBlob's tail is availabe for us to use */
+    *rawSpace(1) = '\0';
+    ++store_->size;
+    ++stats.setChar;
+    return buf();
+}
+
+SBuf&
+SBuf::chop(size_type pos, size_type n)
+{
+    if (pos == npos || pos > length() || n == 0) {
+        clear();
+        return *this;
+    }
+    if (n == npos || (pos+n) > length())
+        n = length()-pos;
+    ++stats.chop;
+    off_ += pos;
+    len_ = n;
+    return *this;
+}
+
+SBuf&
+SBuf::trim(const SBuf &toRemove, bool atBeginning, bool atEnd)
+{
+    ++stats.trim;
+    if (atEnd) {
+        const char *p = bufEnd()-1;
+        while (!isEmpty() && memchr(toRemove.buf(), *p, toRemove.length()) != NULL) {
+            //current end-of-buf is in the searched set
+            --len_;
+            --p;
+        }
+    }
+    if (atBeginning) {
+        const char *p = buf();
+        while (!isEmpty() && memchr(toRemove.buf(), *p, toRemove.length()) != NULL) {
+            --len_;
+            ++off_;
+            ++p;
+        }
+    }
+    if (isEmpty())
+        clear();
+    return *this;
+}
+
+SBuf
+SBuf::substr(size_type pos, size_type n) const
+{
+    SBuf rv(*this);
+    rv.chop(pos, n); //stats handled by callee
+    return rv;
+}
+
+SBuf::size_type
+SBuf::find(char c, size_type startPos) const
+{
+    ++stats.find;
+
+    if (startPos == npos) // can't find anything if we look past end of SBuf
+        return npos;
+
+    // std::string returns npos if needle is outside hay
+    if (startPos > length())
+        return npos;
+
+    const void *i = memchr(buf()+startPos, (int)c, (size_type)length()-startPos);
+
+    if (i == NULL)
+        return npos;
+
+    return (static_cast<const char *>(i)-buf());
+}
+
+SBuf::size_type
+SBuf::find(const SBuf &needle, size_type startPos) const
+{
+    if (startPos == npos) { // can't find anything if we look past end of SBuf
+        ++stats.find;
+        return npos;
+    }
+
+    // std::string allows needle to overhang hay but not start outside
+    if (startPos > length()) {
+        ++stats.find;
+        return npos;
+    }
+
+    // for empty needle std::string returns startPos
+    if (needle.length() == 0) {
+        ++stats.find;
+        return startPos;
+    }
+
+    // if needle length is 1 use the char search
+    if (needle.length() == 1)
+        return find(needle[0], startPos);
+
+    ++stats.find;
+
+    char *begin = buf()+startPos;
+    char *lastPossible = buf()+length()-needle.length()+1;
+    char needleBegin = needle[0];
+
+    debugs(24, 7, "looking for " << needle << "starting at " << startPos <<
+           " in id " << id);
+    while (begin < lastPossible) {
+        char *tmp;
+        debugs(24, 8, " begin=" << (void *) begin <<
+               ", lastPossible=" << (void*) lastPossible );
+        tmp = static_cast<char *>(memchr(begin, needleBegin, lastPossible-begin));
+        if (tmp == NULL) {
+            debugs(24, 8 , "First byte not found");
+            return npos;
+        }
+        // lastPossible guarrantees no out-of-bounds with memcmp()
+        if (0 == memcmp(needle.buf(), tmp, needle.length())) {
+            debugs(24, 8, "Found at " << (tmp-buf()));
+            return (tmp-buf());
+        }
+        begin = tmp+1;
+    }
+    debugs(24, 8, "not found");
+    return npos;
+}
+
+SBuf::size_type
+SBuf::rfind(const SBuf &needle, SBuf::size_type endPos) const
+{
+    // when the needle is 1 char, use the 1-char rfind()
+    if (needle.length() == 1)
+        return rfind(needle[0], endPos);
+
+    ++stats.find;
+
+    // on npos input std::string scans from the end of hay
+    if (endPos == npos || endPos > length())
+        endPos = length();
+
+    // on empty hay std::string returns npos
+    if (length() < needle.length())
+        return npos;
+
+    // consistent with std::string: on empty needle return min(endpos,length())
+    if (needle.length() == 0)
+        return endPos;
+
+    char *bufBegin = buf();
+    char *cur = bufBegin+endPos;
+    char needleBegin = needle[0];
+    while (cur >= bufBegin) {
+        if (*cur == needleBegin) {
+            if (0 == memcmp(needle.buf(), cur, needle.length())) {
+                // found
+                return (cur-buf());
+            }
+        }
+        --cur;
+    }
+    return npos;
+}
+
+SBuf::size_type
+SBuf::rfind(char c, SBuf::size_type endPos) const
+{
+    ++stats.find;
+
+    // shortcut: haystack is empty, can't find anything by definition
+    if (length() == 0)
+        return npos;
+
+    // on npos input std::string compares last octet of hay
+    if (endPos == npos || endPos >= length()) {
+        endPos = length();
+    } else {
+        // NP: off-by-one weirdness:
+        // endPos is an offset ... 0-based
+        // length() is a count ... 1-based
+        // memrhr() requires a 1-based count of space to scan.
+        ++endPos;
+    }
+
+    if (length() == 0)
+        return endPos;
+
+    const void *i = memrchr(buf(), (int)c, (size_type)endPos);
+
+    if (i == NULL)
+        return npos;
+
+    return (static_cast<const char *>(i)-buf());
+}
+
+SBuf::size_type
+SBuf::find_first_of(const SBuf &set, size_type startPos) const
+{
+    // if set is 1 char big, use the char search. Stats updated there
+    if (set.length() == 1)
+        return find(set[0], startPos);
+
+    ++stats.find;
+
+    if (startPos == npos)
+        return npos;
+
+    if (startPos >= length())
+        return npos;
+
+    if (set.length() == 0)
+        return npos;
+
+    debugs(24, 7, "any of '" << set << "' " << " in id " << id);
+    char *cur = buf()+startPos, *end = bufEnd();
+    while (cur < end) {
+        if (memchr(set.buf(), *cur, set.length()))
+            return (cur-buf());
+        ++cur;
+    }
+    debugs(24, 7, "not found");
+    return npos;
+}
+
+/*
+ * TODO: borrow a sscanf implementation from Linux or similar?
+ * we'd really need a vsnscanf(3)... ? As an alternative, a
+ * light-regexp-like domain-specific syntax might be an idea.
+ */
+int
+SBuf::scanf(const char *format, ...)
+{
+    va_list arg;
+    int rv;
+    ++stats.scanf;
+    va_start(arg, format);
+    rv = vsscanf(c_str(), format, arg);
+    va_end(arg);
+    return rv;
+}
+
+std::ostream &
+SBufStats::dump(std::ostream& os) const
+{
+    MemBlobStats ststats = MemBlob::GetStats();
+    os <<
+    "SBuf stats:\nnumber of allocations: " << alloc <<
+    "\ncopy-allocations: " << allocCopy <<
+    "\ncopy-allocations from SquidString: " << allocFromString <<
+    "\ncopy-allocations from C String: " << allocFromCString <<
+    "\nlive references: " << live <<
+    "\nno-copy assignments: " << assignFast <<
+    "\nclearing operations: " << clear <<
+    "\nappend operations: " << append <<
+    "\ndump-to-ostream: " << toStream <<
+    "\nset-char: " << setChar <<
+    "\nget-char: " << getChar <<
+    "\ncomparisons with data-scan: " << compareSlow <<
+    "\ncomparisons not requiring data-scan: " << compareFast <<
+    "\ncopy-out ops: " << copyOut <<
+    "\nraw access to memory: " << rawAccess <<
+    "\nchop operations: " << chop <<
+    "\ntrim operations: " << trim <<
+    "\nfind: " << find <<
+    "\nscanf: " << scanf <<
+    "\ncase-change ops: " << caseChange <<
+    "\nCOW not actually requiring a copy: " << cowFast <<
+    "\nCOW: " << cowSlow <<
+    "\naverage store share factor: " <<
+    (ststats.live != 0 ? static_cast<float>(live)/ststats.live : 0) <<
+    std::endl;
+    return os;
+}
+
+SBuf
+SBuf::toLower() const
+{
+    debugs(24, 8, "\"" << *this << "\"");
+    SBuf rv(*this);
+    for (size_type j = 0; j < length(); ++j) {
+        const int c = (*this)[j];
+        if (isupper(c))
+            rv.setAt(j, tolower(c)); //will cow() if needed
+    }
+    debugs(24, 8, "result: \"" << rv << "\"");
+    ++stats.caseChange;
+    return rv;
+}
+
+SBuf
+SBuf::toUpper() const
+{
+    debugs(24, 8, "\"" << *this << "\"");
+    SBuf rv(*this);
+    for (size_type j = 0; j < length(); ++j) {
+        const int c = (*this)[j];
+        if (islower(c))
+            rv.setAt(j, toupper(c)); //will cow() if needed
+    }
+    debugs(24, 8, "result: \"" << rv << "\"");
+    ++stats.caseChange;
+    return rv;
+}
+
+/**
+ * checks whether the requested 'pos' is within the bounds of the SBuf
+ * \throw OutOfBoundsException if access is out of bounds
+ */
+void
+SBuf::checkAccessBounds(size_type pos) const
+{
+    if (pos >= length())
+        throw OutOfBoundsException(*this, pos, __FILE__, __LINE__);
+}
+
+String
+SBuf::toString() const
+{
+    String rv;
+    rv.limitInit(buf(), length());
+    ++stats.copyOut;
+    return rv;
+}
+
+/** re-allocate the backing store of the SBuf.
+ *
+ * If there are contents in the SBuf, they will be copied over.
+ * NO verifications are made on the size parameters, it's up to the caller to
+ * make sure that the new size is big enough to hold the copied contents.
+ * The re-allocated storage MAY be bigger than the requested size due to size-chunking
+ * algorithms in MemBlock, it is guarranteed NOT to be smaller.
+ */
+void
+SBuf::reAlloc(size_type newsize)
+{
+    debugs(24, 8, "new size: " << newsize);
+    if (newsize > maxSize)
+        throw SBufTooBigException(__FILE__, __LINE__);
+    MemBlob::Pointer newbuf = new MemBlob(newsize);
+    if (length() > 0)
+        newbuf->append(buf(), length());
+    store_ = newbuf;
+    off_ = 0;
+    ++stats.cowSlow;
+    debugs(24, 7, "new store capacity: " << store_->capacity);
+}
+
+SBuf&
+SBuf::lowAppend(const char * memArea, size_type areaSize)
+{
+    rawSpace(areaSize); //called method also checks n <= maxSize()
+    store_->append(memArea, areaSize);
+    len_ += areaSize;
+    ++stats.append;
+    return *this;
+}
+
+/**
+ * copy-on-write: make sure that we are the only holder of the backing store.
+ * If not, reallocate. If a new size is specified, and it is greater than the
+ * current length, the backing store will be extended as needed
+ */
+void
+SBuf::cow(SBuf::size_type newsize)
+{
+    debugs(24, 8, "new size:" << newsize);
+    if (newsize == npos || newsize < length())
+        newsize = length();
+
+    if (store_->LockCount() == 1 && newsize == length()) {
+        debugs(24, 8, "no cow needed");
+        ++stats.cowFast;
+        return;
+    }
+    reAlloc(newsize);
+}
@@ -0,0 +1,610 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#ifndef SQUID_SBUF_H
+#define SQUID_SBUF_H
+
+#include "base/InstanceId.h"
+#include "MemBlob.h"
+#include "SBufExceptions.h"
+#include "SquidString.h"
+
+#if HAVE_CLIMITS
+#include <climits>
+#elif HAVE_LIMITS_H
+#include <limits.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_STDARG_H
+#include <stdarg.h>
+#endif
+#if HAVE_IOSFWD
+#include <iosfwd>
+#endif
+
+/* SBuf placeholder for printf */
+#ifndef SQUIDSBUFPH
+#define SQUIDSBUFPH "%.*s"
+#define SQUIDSBUFPRINT(s) (s).plength(),(s).rawContent()
+#endif /* SQUIDSBUFPH */
+
+typedef enum {
+    caseSensitive,
+    caseInsensitive
+} SBufCaseSensitive;
+
+/**
+ * Container for various SBuf class-wide statistics.
+ *
+ * The stats are not completely accurate; they're mostly meant to
+ * understand whether Squid is leaking resources
+ * and whether SBuf is paying off the expected gains.
+ */
+class SBufStats
+{
+public:
+    uint64_t alloc; ///<number of calls to SBuf constructors
+    uint64_t allocCopy; ///<number of calls to SBuf copy-constructor
+    uint64_t allocFromString; ///<number of copy-allocations from Strings
+    uint64_t allocFromCString; ///<number of copy-allocations from c-strings
+    uint64_t assignFast; ///<number of no-copy assignment operations
+    uint64_t clear; ///<number of clear operations
+    uint64_t append; ///<number of append operations
+    uint64_t toStream;  ///<number of write operations to ostreams
+    uint64_t setChar; ///<number of calls to setAt
+    uint64_t getChar; ///<number of calls to at() and operator[]
+    uint64_t compareSlow; ///<number of comparison operations requiring data scan
+    uint64_t compareFast; ///<number of comparison operations not requiring data scan
+    uint64_t copyOut; ///<number of data-copies to other forms of buffers
+    uint64_t rawAccess; ///<number of accesses to raw contents
+    uint64_t chop;  ///<number of chop operations
+    uint64_t trim;  ///<number of trim operations
+    uint64_t find;  ///<number of find operations
+    uint64_t scanf;  ///<number of scanf operations
+    uint64_t caseChange; ///<number of toUpper and toLower operations
+    uint64_t cowFast; ///<number of cow operations not actually requiring a copy
+    uint64_t cowSlow; ///<number of cow operations requiring a copy
+    uint64_t live;  ///<number of currently-allocated SBuf
+
+    ///Dump statistics to an ostream.
+    std::ostream& dump(std::ostream &os) const;
+    SBufStats();
+
+    SBufStats& operator +=(const SBufStats&);
+};
+
+/**
+ * A String or Buffer.
+ * Features: refcounted backing store, cheap copy and sub-stringing
+ * operations, copy-on-write to isolate change operations to each instance.
+ * Where possible, we're trying to mimic std::string's interface.
+ */
+class SBuf
+{
+public:
+    typedef MemBlob::size_type size_type;
+    static const size_type npos = 0xffffffff; // max(uint32_t)
+
+    /// Maximum size of a SBuf. By design it MUST be < MAX(size_type)/2. Currently 256Mb.
+    static const size_type maxSize = 0xfffffff;
+
+    /// create an empty (zero-size) SBuf
+    SBuf();
+    SBuf(const SBuf &S);
+
+    /** Constructor: import c-style string
+     *
+     * Create a new SBuf containing a COPY of the contents of the
+     * c-string
+     * \param S the c string to be copied
+     * \param n how many bytes to import into the SBuf. If it is npos
+     *              or unspecified, imports to end-of-cstring
+     * \note it is the caller's responsibility not to go out of bounds
+     * \note bounds is 0 <= pos < length(); caller must pay attention to signedness
+     */
+    explicit SBuf(const char *S, size_type n = npos);
+
+    /** Constructor: import SquidString, copying contents.
+     *
+     * This method will be removed once SquidString has gone.
+     */
+    explicit SBuf(const String &S);
+
+    /// Constructor: import std::string. Contents are copied.
+    explicit SBuf(const std::string &s);
+
+    ~SBuf();
+
+    /** Explicit assignment.
+     *
+     * Current SBuf will share backing store with the assigned one.
+     */
+    SBuf& assign(const SBuf &S);
+
+    /** Assignment operator.
+     *
+     * Current SBuf will share backing store with the assigned one.
+     */
+    SBuf& operator =(const SBuf & S) {return assign(S);}
+
+    /** Import a c-string into a SBuf, copying the data.
+     *
+     * It is the caller's duty to free the imported string, if needed.
+     * \param S the c string to be copied
+     * \param n how many bytes to import into the SBuf. If it is npos
+     *              or unspecified, imports to end-of-cstring
+     * \note it is the caller's responsibility not to go out of bounds
+     * \note to assign a std::string use the pattern:
+     *    assign(stdstr.data(), stdstd.length())
+     */
+    SBuf& assign(const char *S, size_type n = npos);
+
+    /** Assignment operator. Copy a NULL-terminated c-style string into a SBuf.
+     *
+     * Copy a c-style string into a SBuf. Shortcut for SBuf.assign(S)
+     * It is the caller's duty to free the imported string, if needed.
+     * \note not \0-clean
+     */
+    SBuf& operator =(const char *S) {return assign(S);}
+
+    /** reset the SBuf as if it was just created.
+     *
+     * Resets the SBuf to empty, memory is freed lazily.
+     */
+    void clear();
+
+    /** Append operation
+     *
+     * Append the supplied SBuf to the current one; extend storage as needed.
+     */
+    SBuf& append(const SBuf & S);
+
+    /** Append operation for C-style strings.
+     *
+     * Append the supplied c-string to the SBuf; extend storage
+     * as needed.
+     *
+     * \param S the c string to be copied. Can be NULL.
+     * \param Ssize how many bytes to import into the SBuf. If it is npos
+     *              or unspecified, imports to end-of-cstring. If S is NULL,
+     *              Ssize is ignored.
+     * \note to append a std::string use the pattern
+     *     cstr_append(stdstr.data(), stdstd.length())
+     */
+    SBuf& append(const char * S, size_type Ssize = npos);
+
+    /** Assignment operation with printf(3)-style definition
+     * \note arguments may be evaluated more than once, be careful
+     *       of side-effects
+     */
+    SBuf& Printf(const char *fmt, ...);
+
+    /** Append operation with printf-style arguments
+     * \note arguments may be evaluated more than once, be careful
+     *       of side-effects
+     */
+    SBuf& appendf(const char *fmt, ...);
+
+    /** Append operation, with vsprintf(3)-style arguments.
+     * \note arguments may be evaluated more than once, be careful
+     *       of side-effects
+     */
+    SBuf& vappendf(const char *fmt, va_list vargs);
+
+    /// print the SBuf contents to the supplied ostream
+    std::ostream& print(std::ostream &os) const;
+
+    /** print SBuf contents and debug information about the SBuf to an ostream
+     *
+     * Debug function, dumps to a stream informations on the current SBuf,
+     * including low-level details and statistics.
+     */
+    std::ostream& dump(std::ostream &os) const;
+
+    /** random-access read to any char within the SBuf
+     *
+     * does not check access bounds. If you need that, use at()
+     */
+    char operator [](size_type pos) const {++stats.getChar; return store_->mem[off_+pos];}
+
+    /** random-access read to any char within the SBuf.
+     *
+     * \throw OutOfBoundsException when access is out of bounds
+     * \note bounds is 0 <= pos < length(); caller must pay attention to signedness
+     */
+    char at(size_type pos) const {checkAccessBounds(pos); return operator[](pos);}
+
+    /** direct-access set a byte at a specified operation.
+     *
+     * \param pos the position to be overwritten
+     * \param toset the value to be written
+     * \throw OutOfBoundsException when pos is of bounds
+     * \note bounds is 0 <= pos < length(); caller must pay attention to signedness
+     * \note performs a copy-on-write if needed.
+     */
+    void setAt(size_type pos, char toset);
+
+    /** compare to other SBuf, str(case)cmp-style
+     *
+     * \param isCaseSensitive one of caseSensitive or caseInsensitive
+     * \param n compare up to this many bytes. if npos (default), compare whole SBufs
+     * \retval >0 argument of the call is greater than called SBuf
+     * \retval <0 argument of the call is smaller than called SBuf
+     * \retval 0  argument of the call has the same contents of called SBuf
+     */
+    int compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n = npos) const;
+
+    /// shorthand version for compare
+    inline int cmp(const SBuf &S, size_type n = npos) const {
+        return compare(S,caseSensitive,n);
+    }
+
+    /// shorthand version for case-insensitive comparison
+    inline int caseCmp(const SBuf &S, size_type n = npos) const {
+        return compare(S,caseInsensitive,n);
+    }
+
+    /** check whether the entire supplied argument is a prefix of the SBuf.
+     *  \param S the prefix to match against
+     *  \param isCaseSensitive one of caseSensitive or caseInsensitive
+     *  \retval true argument is a prefix of the SBuf
+     */
+    bool startsWith(const SBuf &S, SBufCaseSensitive isCaseSensitive = caseSensitive) const;
+
+    bool operator ==(const SBuf & S) const;
+    bool operator !=(const SBuf & S) const;
+    bool operator <(const SBuf &S) const {return (cmp(S) < 0);}
+    bool operator >(const SBuf &S) const {return (cmp(S) > 0);}
+    bool operator <=(const SBuf &S) const {return (cmp(S) <= 0);}
+    bool operator >=(const SBuf &S) const {return (cmp(S) >= 0);}
+
+    /** Consume bytes at the head of the SBuf
+     *
+     * Consume N chars at SBuf head, or to SBuf's end,
+     * whichever is shorter. If more bytes are consumed than available,
+     * the SBuf is emptied
+     * \param n how many bytes to remove; could be zero.
+     *     npos (or no argument) means 'to the end of SBuf'
+     * \return a new SBuf containing the consumed bytes.
+     */
+    SBuf consume(size_type n = npos);
+
+    /// gets global statistic informations
+    static const SBufStats& GetStats();
+
+    /** Copy SBuf contents into user-supplied C buffer.
+     *
+     * Export a copy of the SBuf's contents into the user-supplied
+     * buffer, up to the user-supplied-length. No zero-termination is performed
+     * \return num the number of actually-copied chars.
+     */
+    size_type copy(char *dest, size_type n) const;
+
+    /** exports a pointer to the SBuf internal storage.
+     * \warning ACCESSING RAW STORAGE IS DANGEROUS!
+     *
+     * Returns a ead-only pointer to SBuf's content. No terminating null
+     * character is appended (use c_str() for that).
+     * The returned value points to an internal location whose contents
+     * are guaranteed to remain unchanged only until the next call
+     * to a non-constant member function of the SBuf object. Such a
+     * call may be implicit (e.g., when SBuf is destroyed
+     * upon leaving the current context).
+     * This is a very UNSAFE way of accessing the data.
+     * This call never returns NULL.
+     * \see c_str
+     * \note the memory management system guarantees that the exported region
+     *    of memory will remain valid if the caller keeps holding
+     *    a valid reference to the SBuf object and does not write or append to
+     *    it. For example:
+     * \code
+     * SBuf foo("some string");
+     * const char *bar = foo.rawContent();
+     * doSomething(bar); //safe
+     * foo.append(" other string");
+     * doSomething(bar); //unsafe
+     * \endcode
+     */
+    const char* rawContent() const;
+
+    /** Exports a writable pointer to the SBuf internal storage.
+     * \warning Use with EXTREME caution, this is a dangerous operation.
+     *
+     * Returns a pointer to the first unused byte in the SBuf's storage,
+     * which can be be used for appending. At least minSize bytes will
+     * be available for writing.
+     * The returned pointer must not be stored by the caller, as it will
+     * be invalidated by the first call to a non-const method call
+     * on the SBuf.
+     * This call guarantees to never return NULL.
+     * \see reserveSpace
+     * \note Unlike reserveSpace(), this method does not guarantee exclusive
+     *       buffer ownership. It is instead optimized for a one writer
+     *       (appender), many readers scenario by avoiding unnecessary
+     *       copying and allocations.
+     * \throw SBufTooBigException if the user tries to allocate too big a SBuf
+     */
+    char *rawSpace(size_type minSize);
+
+    /** Obtain how much free space is available in the backing store.
+     *
+     * \note: unless the client just cow()ed, it is not guaranteed that
+     *        the free space can be used.
+     */
+    size_type spaceSize() const { return store_->spaceSize(); }
+
+    /** Force a SBuf's size
+     * \warning use with EXTREME caution, this is a dangerous operation
+     *
+     * Adapt the SBuf internal state after external interference
+     * such as writing into it via rawSpace.
+     * \throw TextException if SBuf doesn't have exclusive ownership of store
+     * \throw SBufTooBigException if new size is bigger than available store space
+     */
+    void forceSize(size_type newSize);
+
+    /** exports a null-terminated reference to the SBuf internal storage.
+     * \warning ACCESSING RAW STORAGE IS DANGEROUS! DO NOT EVER USE
+     *  THE RETURNED POINTER FOR WRITING
+     *
+     * The returned value points to an internal location whose contents
+     * are guaranteed to remain unchanged only until the next call
+     * to a non-constant member function of the SBuf object. Such a
+     * call may be implicit (e.g., when SBuf is destroyed
+     * upon leaving the current context).
+     * This is a very UNSAFE way of accessing the data.
+     * This call never returns NULL.
+     * \see rawContent
+     * \note the memory management system guarantees that the exported region
+     *    of memory will remain valid will remain valid only if the
+     *    caller keeps holding a valid reference to the SBuf object and
+     *    does not write or append to it
+     */
+    const char* c_str();
+
+    /// Returns the number of bytes stored in SBuf.
+    size_type length() const {return len_;}
+
+    /** Get the length of the SBuf, as a signed integer
+     *
+     * Compatibility function for printf(3) which requires a signed int
+     * \throw SBufTooBigException if the SBuf is too big for a signed integer
+     */
+    int plength() const {
+        if (length()>INT_MAX)
+            throw SBufTooBigException(__FILE__, __LINE__);
+        return static_cast<int>(length());
+    }
+
+    /** Check whether the SBuf is empty
+     *
+     * \return true if length() == 0
+     */
+    bool isEmpty() const {return (len_==0);}
+
+    /** Request to guarantee the SBuf's free store space.
+     *
+     * After the reserveSpace request, the SBuf is guaranteed to have at
+     * least minSpace bytes of unused backing store following the currently
+     * used portion and single ownership of the backing store.
+     * \throw SBufTooBigException if the user tries to allocate too big a SBuf
+     */
+    void reserveSpace(size_type minSpace) {
+        Must(minSpace <= maxSize);
+        Must(length() <= maxSize - minSpace);
+        reserveCapacity(length()+minSpace);
+    }
+
+    /** Request to guarantee the SBuf's store capacity
+     *
+     * After this method is called, the SBuf is guaranteed to have at least
+     * minCapacity bytes of total buffer size, including the currently-used
+     * portion; it is also guaranteed that after this call this SBuf
+     * has unique ownership of the underlying memory store.
+     * \throw SBufTooBigException if the user tries to allocate too big a SBuf
+     */
+    void reserveCapacity(size_type minCapacity);
+
+    /** slicing method
+     *
+     * Removes SBuf prefix and suffix, leaving a sequence of 'n'
+     * bytes starting from position 'pos', first byte is at pos 0.
+     * It is an in-place-modifying version of substr.
+     * \param pos start sub-stringing from this byte. If it is
+     *      npos or it is greater than the SBuf length, the SBuf is cleared and
+     *      an empty SBuf is returned.
+     * \param n maximum number of bytes of the resulting SBuf.
+     *     npos means "to end of SBuf".
+     *     if it is 0, the SBuf is cleared and an empty SBuf is returned.
+     *     if it overflows the end of the SBuf, it is capped to the end of SBuf
+     * \see substr, trim
+     */
+    SBuf& chop(size_type pos, size_type n = npos);
+
+    /** Remove characters in the toremove set at the beginning, end or both
+     *
+     * \param toremove characters to be removed. Stops chomping at the first
+     *        found char not in the set
+     * \param atBeginning if true (default), strips at the beginning of the SBuf
+     * \param atEnd if true (default), strips at the end of the SBuf
+     */
+    SBuf& trim(const SBuf &toRemove, bool atBeginning = true, bool atEnd = true);
+
+    /** Extract a part of the current SBuf.
+     *
+     * Return a fresh a fresh copy of a portion the current SBuf, which is
+     * left untouched. The same parameter convetions apply as for chop.
+     * \see trim, chop
+     */
+    SBuf substr(size_type pos, size_type n = npos) const;
+
+    /** Find first occurrence of character in SBuf
+     *
+     * Returns the index in the SBuf of the first occurrence of char c.
+     * \return npos if the char was not found
+     * \param startPos if specified, ignore any occurrences before that position
+     *     if startPos is npos or greater than length() npos is always returned
+     *     if startPos is less than zero, it is ignored
+     */
+    size_type find(char c, size_type startPos = 0) const;
+
+    /** Find first occurrence of SBuf in SBuf.
+     *
+     * Returns the index in the SBuf of the first occurrence of the
+     * sequence contained in the str argument.
+     * \param startPos if specified, ignore any occurrences before that position
+     *     if startPos is npos or greater than length() npos is always returned
+     * \return npos if the SBuf was not found
+     */
+    size_type find(const SBuf & str, size_type startPos = 0) const;
+
+    /** Find last occurrence of character in SBuf
+     *
+     * Returns the index in the SBuf of the last occurrence of char c.
+     * \return npos if the char was not found
+     * \param endPos if specified, ignore any occurrences after that position.
+     *   if npos or greater than length(), the whole SBuf is considered
+     */
+    size_type rfind(char c, size_type endPos = npos) const;
+
+    /** Find last occurrence of SBuf in SBuf
+     *
+     * Returns the index in the SBuf of the last occurrence of the
+     * sequence contained in the str argument.
+     * \return npos if the sequence  was not found
+     * \param endPos if specified, ignore any occurrences after that position
+     *   if npos or greater than length(), the whole SBuf is considered
+     */
+    size_type rfind(const SBuf &str, size_type endPos = npos) const;
+
+    /** Find first occurrence of character of set in SBuf
+     *
+     * Finds the first occurrence of ANY of the characters in the supplied set in
+     * the SBuf.
+     * \return npos if no character in the set could be found
+     * \param startPos if specified, ignore any occurrences before that position
+     *   if npos, then npos is always returned
+     */
+    size_type find_first_of(const SBuf &set, size_type startPos = 0) const;
+
+    /** sscanf-alike
+     *
+     * sscanf re-implementation. Non-const, and not \0-clean.
+     * \return same as sscanf
+     * \see man sscanf(3)
+     */
+    int scanf(const char *format, ...);
+
+    /** Lower-case SBuf
+     *
+     * Returns a lower-cased COPY of the SBuf
+     * \see man tolower(3)
+     */
+    SBuf toLower() const;
+
+    /** Upper-case SBuf
+     *
+     * Returns an upper-cased COPY of the SBuf
+     * \see man toupper(3)
+     */
+    SBuf toUpper() const;
+
+    /** String export function
+     * converts the SBuf to a legacy String, by copy.
+     * \deprecated
+     */
+    String toString() const;
+
+    /// std::string export function
+    std::string toStdString() const { return std::string(buf(),length()); }
+
+    // TODO: possibly implement erase() similar to std::string's erase
+    // TODO: possibly implement a replace() call
+private:
+
+    MemBlob::Pointer store_; ///< memory block, possibly shared with other SBufs
+    size_type off_; ///< our content start offset from the beginning of shared store_
+    size_type len_; ///< number of our content bytes in shared store_
+    static SBufStats stats; ///< class-wide statistics
+
+    /// SBuf object identifier; does not change when contents do,
+    ///   including during assignment
+    const InstanceId<SBuf> id;
+
+    /** obtain prototype store
+     *
+     * Just-created SBufs all share to the same MemBlob.
+     * This call instantiates and returns it.
+     */
+    static MemBlob::Pointer GetStorePrototype();
+
+    /**
+     * obtains a char* to the beginning of this SBuf in memory.
+     * \note the obtained string is NOT null-terminated.
+     */
+    char * buf() const {return (store_->mem+off_);}
+
+    /** returns the pointer to the first char after this SBuf end
+     *
+     *  No checks are made that the space returned is safe, checking that is
+     *  up to the caller.
+     */
+    char * bufEnd() const {return (store_->mem+off_+len_);}
+
+    /**
+     * Try to guesstimate how big a MemBlob to allocate.
+     * The result is guarranteed to be to be at least the desired size.
+     */
+    size_type estimateCapacity(size_type desired) const {return (2*desired);}
+
+    void reAlloc(size_type newsize);
+
+    void cow(size_type minsize = npos);
+
+    void checkAccessBounds(size_type pos) const;
+
+    /** Low-level append operation
+     *
+     * Takes as input a contiguous area of memory and appends its contents
+     * to the SBuf, taking care of memory management. Does no bounds checking
+     * on the supplied memory buffer, it is the duty of the caller to ensure
+     * that the supplied area is valid.
+     */
+    SBuf& lowAppend(const char * memArea, size_type areaSize);
+};
+
+/// ostream output operator
+inline std::ostream &
+operator <<(std::ostream& os, const SBuf& S)
+{
+    return S.print(os);
+}
+
+#endif /* SQUID_SBUF_H */
@@ -0,0 +1,47 @@
+#include "squid.h"
+#include "SBufDetailedStats.h"
+#include "StatHist.h"
+
+/*
+ * Implementation note: the purpose of this construct is to avoid adding
+ * external dependencies to the SBuf code
+ */
+
+static StatHist sbufDestructTimeStats;
+static StatHist memblobDestructTimeStats;
+
+namespace SBufDetailedStatsHistInitializer {
+    // run the post-instantiation initialization methods for StatHist objects
+    struct Initializer
+    {
+        Initializer() {
+            sbufDestructTimeStats.logInit(300,30.0,128000.0);
+            memblobDestructTimeStats.logInit(300,30.0,128000.0);
+        }
+    };
+    Initializer initializer;
+}
+
+void
+recordSBufSizeAtDestruct(SBuf::size_type sz)
+{
+    sbufDestructTimeStats.count(static_cast<double>(sz));
+}
+
+const StatHist *
+collectSBufDestructTimeStats()
+{
+    return &sbufDestructTimeStats;
+}
+
+void
+recordMemBlobSizeAtDestruct(SBuf::size_type sz)
+{
+    memblobDestructTimeStats.count(static_cast<double>(sz));
+}
+
+const StatHist *
+collectMemBlobDestructTimeStats()
+{
+    return &memblobDestructTimeStats;
+}
@@ -0,0 +1,27 @@
+
+#ifndef SQUID_SBUFDETAILEDSTATS_H
+#define SQUID_SBUFDETAILEDSTATS_H
+
+#include "SBuf.h"
+
+class StatHist;
+
+/// Record the size a SBuf had when it was destructed
+void recordSBufSizeAtDestruct(SBuf::size_type sz);
+
+/** Collect the SBuf size-at-destruct-time histogram
+ *
+ * \note the returned StatHist object must not be freed
+ */
+const StatHist * collectSBufDestructTimeStats();
+
+/// Record the size a MemBlob had when it was destructed
+void recordMemBlobSizeAtDestruct(MemBlob::size_type sz);
+
+/** Collect the MemBlob size-at-destruct-time histogram
+ *
+ * \note the returned StatHist object must not be freed
+ */
+const StatHist * collectMemBlobDestructTimeStats();
+
+#endif /* SQUID_SBUFDETAILEDSTATS_H */
@@ -1,7 +1,4 @@
 /*
- * StringArea.h
- *
- *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
  *
@@ -29,48 +26,37 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  */
 
-#ifndef SQUID_STRINGAREA_H
-#define SQUID_STRINGAREA_H
-
-#if HAVE_CSTRING
-#include <cstring>
-#endif
-#include <ostream>
+#include "squid.h"
+#include "OutOfBoundsException.h"
+#include "SBuf.h"
+#include "SBufExceptions.h"
 
-/** A char* plus length combination. Useful for temporary storing
- * and quickly looking up strings.
- *
- * The pointed-to string may not be null-terminated.
- * The pointed-to string is not copied.
- *
- * Not meant for stand-alone storage. Validity of the
- * pointed-to string is responsibility of the caller.
- */
-class StringArea
+OutOfBoundsException::OutOfBoundsException(const SBuf &throwingBuf,
+        SBuf::size_type &pos,
+        const char *aFileName, int aLineNo)
+        : TextException(NULL, aFileName, aLineNo),
+        theThrowingBuf(throwingBuf),
+        accessedPosition(pos)
 {
-public:
-    /// build a StringArea by explicitly assigning pointed-to area and and length
-    StringArea(const char * ptr, size_t len): theStart(ptr), theLen(len) {}
-    bool operator==(const StringArea &s) const { return theLen==s.theLen && memcmp(theStart,s.theStart,theLen)==0; }
-    bool operator!=(const StringArea &s) const { return !operator==(s); }
-    bool operator< ( const StringArea &s) const {
-        return (theLen < s.theLen || (theLen == s.theLen && memcmp(theStart,s.theStart,theLen) < 0)) ;
-    }
-
-    void print(std::ostream &os) const { os.write(theStart, theLen); }
+    SBuf explanatoryText("OutOfBoundsException");
+    if (aLineNo != -1)
+        explanatoryText.appendf(" at line %d", aLineNo);
+    if (aFileName != NULL)
+        explanatoryText.appendf(" in file %s", aFileName);
+    explanatoryText.appendf(" while accessing position %d in a SBuf long %d",
+                            pos, throwingBuf.length());
+    // we can safely alias c_str as both are local to the object
+    //  and will not further manipulated.
+    message = xstrndup(explanatoryText.c_str(),explanatoryText.length());
+}
 
-private:
-    /// pointed to the externally-managed memory area
-    const char *theStart;
-    /// length of the string
-    size_t theLen;
-};
+OutOfBoundsException::~OutOfBoundsException() throw()
+{ }
 
-inline std::ostream &
-operator <<(std::ostream &os, const StringArea &a)
-{
-    a.print(os);
-    return os;
-}
+InvalidParamException::InvalidParamException(const char *aFilename, int aLineNo)
+        : TextException("Invalid parameter", aFilename, aLineNo)
+{ }
 
-#endif /* SQUID_STRINGAREA_H */
+SBufTooBigException::SBufTooBigException(const char *aFilename, int aLineNo)
+        : TextException("Trying to create an oversize SBuf", aFilename, aLineNo)
+{ }
@@ -1,7 +1,4 @@
 /*
- * DEBUG: section 29    Authenticator
- * AUTHOR:  Robert Collins
- *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
  *
@@ -27,23 +24,30 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
-char const *
-Auth::User::username () const
+#ifndef SQUID_SBUFEXCEPTIONS_H
+#define SQUID_SBUFEXCEPTIONS_H
+
+#include "base/TextException.h"
+
+/**
+ * Exception raised when call parameters are not valid
+ * \todo move to an Exceptions.h?
+ */
+class InvalidParamException : public TextException
 {
-    return username_;
-}
+public:
+    explicit InvalidParamException(const char *aFilename = 0, int aLineNo = -1);
+};
 
-void
-Auth::User::username(char const *aString)
+/**
+ * Exception raised when an attempt to resize a SBuf would cause it to reserve too big
+ */
+class SBufTooBigException : public TextException
 {
-    if (aString) {
-        assert(!username_);
-        username_ = xstrdup(aString);
-    } else {
-        safe_free(username_);
-    }
-}
+public:
+    explicit SBufTooBigException(const char *aFilename = 0, int aLineNo = -1);
+};
+
+#endif /* SQUID_SBUFEXCEPTIONS_H */
@@ -0,0 +1,99 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "squid.h"
+#include "ipc/Messages.h"
+#include "ipc/TypedMsgHdr.h"
+#include "mgr/Registration.h"
+#include "SBufDetailedStats.h"
+#include "SBufStatsAction.h"
+#include "StoreEntryStream.h"
+
+SBufStatsAction::SBufStatsAction(const Mgr::CommandPointer &cmd_):
+        Action(cmd_)
+{ } //default constructor is OK for data member
+
+SBufStatsAction::Pointer
+SBufStatsAction::Create(const Mgr::CommandPointer &cmd)
+{
+    return new SBufStatsAction(cmd);
+}
+
+void
+SBufStatsAction::add(const Mgr::Action& action)
+{
+    sbdata += dynamic_cast<const SBufStatsAction&>(action).sbdata;
+    mbdata += dynamic_cast<const SBufStatsAction&>(action).mbdata;
+    sbsizesatdestruct += dynamic_cast<const SBufStatsAction&>(action).sbsizesatdestruct;
+    mbsizesatdestruct += dynamic_cast<const SBufStatsAction&>(action).mbsizesatdestruct;
+}
+
+void
+SBufStatsAction::collect()
+{
+    sbdata = SBuf::GetStats();
+    mbdata = MemBlob::GetStats();
+    sbsizesatdestruct = *collectSBufDestructTimeStats();
+    mbsizesatdestruct = *collectMemBlobDestructTimeStats();
+}
+
+void
+SBufStatsAction::dump(StoreEntry* entry)
+{
+    StoreEntryStream ses(entry);
+    ses << "\n\n\nThese statistics are experimental; their format and contents "
+        "should not be relied upon, they are bound to change as "
+        "the SBuf feature is evolved\n";
+    sbdata.dump(ses);
+    mbdata.dump(ses);
+    ses << "\n";
+    ses << "SBuf size distribution at destruct time:\n";
+    sbsizesatdestruct.dump(entry,NULL);
+    ses << "MemBlob size distribution at destruct time:\n";
+    mbsizesatdestruct.dump(entry,NULL);
+}
+
+void
+SBufStatsAction::pack(Ipc::TypedMsgHdr& msg) const
+{
+    msg.setType(Ipc::mtCacheMgrResponse);
+    msg.putPod(sbdata);
+    msg.putPod(mbdata);
+}
+
+void
+SBufStatsAction::unpack(const Ipc::TypedMsgHdr& msg)
+{
+    msg.checkType(Ipc::mtCacheMgrResponse);
+    msg.getPod(sbdata);
+    msg.getPod(mbdata);
+}
+
+static const bool Registered = (Mgr::RegisterAction("sbuf",
+                                "String-Buffer statistics", &SBufStatsAction::Create, 0 , 1),
+                                true);
@@ -24,73 +24,40 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-#ifndef SQUID_STOREFSCOSS_H
-#define SQUID_STOREFSCOSS_H
-
-class StoreEntry;
-
-/**
- \defgroup COSS COSS Storage Filesystem
- \ingroup FileSystems
- */
-
-/// \ingroup COSS
-class CossStats
-{
 
-public:
-    void stat(StoreEntry * sentry);
-    int stripes;
-
-    struct {
-        int alloc;
-        int realloc;
-        int collisions;
-    } alloc;
-    int disk_overflows;
-    int stripe_overflows;
-    int open_mem_hits;
-    int open_mem_misses;
+#ifndef SQUID_SBUFEXTRAS_H
+#define SQUID_SBUFEXTRAS_H
 
-    struct {
-        int ops;
-        int success;
-        int fail;
-    }
-
-    open, create, close, unlink, read, write, stripe_write;
-};
+#include "mgr/Action.h"
+#include "SBuf.h"
+#include "StatHist.h"
 
-class CacheManager;
-
-#include "StoreFileSystem.h"
+class StoreEntry;
 
-/// \ingroup COSS, FileSystems
-class StoreFScoss : public StoreFileSystem
+/// SBuf stats for cachemgr
+class SBufStatsAction: public Mgr::Action
 {
-
 public:
-    static StoreFScoss &GetInstance();
-    static void Stats(StoreEntry * sentry);
-    StoreFScoss();
-    virtual ~StoreFScoss() {}
+    /// Mgr::ClassActionCreationHandler for Mgr::RegisterAction()
+    static Pointer Create(const Mgr::CommandPointer &cmd);
 
-    virtual char const *type() const;
-    virtual SwapDir *createSwapDir();
-    virtual void done();
-    virtual void registerWithCacheManager(void);
-    virtual void setup();
-    /* Not implemented */
-    StoreFScoss (StoreFScoss const &);
-    StoreFScoss &operator=(StoreFScoss const &);
-    void stat(StoreEntry * sentry);
-    CossStats stats;
+protected:
+    explicit SBufStatsAction(const Mgr::CommandPointer &cmd);
+    /* Mgr::Action API */
+    virtual void collect();
+    virtual void dump(StoreEntry* entry);
 
 private:
-    static StoreFScoss _instance;
+    /* Mgr::Action API */
+    virtual void add(const Mgr::Action& action);
+    virtual void pack(Ipc::TypedMsgHdr& msg) const;
+    virtual void unpack(const Ipc::TypedMsgHdr& msg);
+
+    SBufStats sbdata;
+    MemBlobStats mbdata;
+    StatHist sbsizesatdestruct;
+    StatHist mbsizesatdestruct;
 };
 
-#endif /* SQUID_STOREFSCOSS_H */
+#endif /* SQUID_SBUFSTATSACTION_H */
@@ -0,0 +1,144 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_SBUFSTREAM_H
+#define SQUID_SBUFSTREAM_H
+
+#include "SBuf.h"
+
+#if HAVE_OSTREAM
+#include <ostream>
+#endif
+
+/** streambuf class for a SBuf-backed stream interface.
+ *
+ * Auxiliary class to be able to leverage an ostream generating SBuf's
+ * analogous to std::ostrstream.
+ */
+class SBufStreamBuf : public std::streambuf
+{
+public:
+    /// initialize streambuf; use supplied SBuf as backing store
+    explicit SBufStreamBuf(SBuf aBuf) : theBuf(aBuf) {}
+
+    /// get a copy of the stream's contents
+    SBuf getBuf() {
+        return theBuf;
+    }
+
+    /// clear the stream's store
+    void clearBuf() {
+        theBuf.clear();
+    }
+
+protected:
+    virtual int_type overflow(int_type aChar = traits_type::eof()) {
+        std::streamsize pending(pptr() - pbase());
+
+        if (pending && sync())
+            return traits_type::eof();
+
+        if (aChar != traits_type::eof()) {
+            char chars[1] = {static_cast<char>(aChar)};
+
+            if (aChar != traits_type::eof())
+                theBuf.append(chars, 1);
+        }
+
+        pbump(-pending);  // Reset pptr().
+        return aChar;
+    }
+
+    /// push the streambuf to the backing SBuf
+    virtual int sync() {
+        std::streamsize pending(pptr() - pbase());
+
+        if (pending)
+            theBuf.append(pbase(), pending);
+
+        return 0;
+    }
+
+    /** write multiple characters to the store entry
+     * \note this is an optimisation consistent with std::streambuf API
+     */
+    virtual std::streamsize xsputn(const char * chars, std::streamsize number) {
+        if (number)
+            theBuf.append(chars, number);
+
+        return number;
+    }
+
+private:
+    SBuf theBuf;
+    SBufStreamBuf(); // no default constructor
+};
+
+/** Stream interface to write to a SBuf.
+ *
+ * Data is appended using standard operator << semantics, and extracted
+ * using the buf() method, in analogy with std::strstream .
+ */
+class SBufStream : public std::ostream
+{
+public:
+    /** Create a SBufStream preinitialized with the contents of a SBuf
+     *
+     * The supplied SBuf copied: in order to retrieve the written-to contents
+     * they must be later fetched using the buf() class method.
+     */
+    SBufStream(SBuf aBuf): std::ostream(0), theBuffer(aBuf) {
+        rdbuf(&theBuffer); // set the buffer to now-initialized theBuffer
+        clear(); //clear badbit set by calling init(0)
+    }
+
+    /// Create an empty SBufStream
+    SBufStream(): std::ostream(0), theBuffer(SBuf()) {
+        rdbuf(&theBuffer); // set the buffer to now-initialized theBuffer
+        clear(); //clear badbit set by calling init(0)
+    }
+
+    /// Retrieve a copy of the current stream status
+    SBuf buf() {
+        flush();
+        return theBuffer.getBuf();
+    }
+
+    /// Clear the stream's backing store
+    SBufStream& clearBuf() {
+        flush();
+        theBuffer.clearBuf();
+        return *this;
+    }
+
+private:
+    SBufStreamBuf theBuffer;
+};
+
+#endif /* SQUID_SBUFSTREAM_H */
@@ -36,9 +36,10 @@
 #include "comm/Connection.h"
 #include "comm/forward.h"
 #include "comm/Write.h"
-#include "fd.h"
 #include "err_detail_type.h"
 #include "errorpage.h"
+#include "fd.h"
+#include "HttpHdrContRange.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Server.h"
@@ -525,6 +526,11 @@ ServerStateData::haveParsedReplyHeaders()
 {
     Must(theFinalReply);
     maybePurgeOthers();
+
+    // adaptation may overwrite old offset computed using the virgin response
+    const bool partial = theFinalReply->content_range &&
+                         theFinalReply->sline.status() == Http::scPartialContent;
+    currentOffset = partial ? theFinalReply->content_range->spec.offset : 0;
 }
 
 HttpRequest *
@@ -555,7 +561,7 @@ ServerStateData::startAdaptation(const Adaptation::ServiceGroupPointer &group, H
     }
 
     adaptedHeadSource = initiateAdaptation(
-                            new Adaptation::Iterator(vrep, cause, group));
+                            new Adaptation::Iterator(vrep, cause, fwd->al, group));
     startedAdaptation = initiated(adaptedHeadSource);
     Must(startedAdaptation);
 }
@@ -699,7 +705,8 @@ ServerStateData::handleAdaptedHeader(HttpMsg *msg)
         // subscribe to receive adapted body
         adaptedBodySource = rep->body_pipe;
         // assume that ICAP does not auto-consume on failures
-        assert(adaptedBodySource->setConsumerIfNotLate(this));
+        const bool result = adaptedBodySource->setConsumerIfNotLate(this);
+        assert(result);
     } else {
         // no body
         if (doneWithAdaptation()) // we may still be sending virgin response
@@ -917,7 +924,7 @@ ServerStateData::adaptOrFinalizeReply()
     // The callback can be called with a NULL service if adaptation is off.
     adaptationAccessCheckPending = Adaptation::AccessCheck::Start(
                                        Adaptation::methodRespmod, Adaptation::pointPreCache,
-                                       originalRequest(), virginReply(), this);
+                                       originalRequest(), virginReply(), fwd->al, this);
     debugs(11,5, HERE << "adaptationAccessCheckPending=" << adaptationAccessCheckPending);
     if (adaptationAccessCheckPending)
         return;
@@ -32,8 +32,8 @@
 #ifndef SQUID_SERVER_H
 #define SQUID_SERVER_H
 
-#include "BodyPipe.h"
 #include "base/AsyncJob.h"
+#include "BodyPipe.h"
 #include "CommCalls.h"
 #include "FwdState.h"
 #include "StoreIOBuffer.h"
@@ -111,12 +111,8 @@ class SquidConfig
         int icp_query_max;  /* msec */
         int icp_query_min;  /* msec */
         int mcast_icp_query;    /* msec */
-
-#if !USE_DNSHELPER
         time_msec_t idns_retransmit;
         time_msec_t idns_query;
-#endif
-
     } Timeout;
     size_t maxRequestHeaderSize;
     int64_t maxRequestBodySize;
@@ -195,10 +191,6 @@ class SquidConfig
     char *effectiveGroup;
 
     struct {
-#if USE_DNSHELPER
-        char *dnsserver;
-#endif
-
         wordlist *redirect;
         wordlist *store_id;
 #if USE_UNLINKD
@@ -213,9 +205,6 @@ class SquidConfig
 #endif
 
     } Program;
-#if USE_DNSHELPER
-    HelperChildConfig dnsChildren;
-#endif
 
     HelperChildConfig redirectChildren;
     HelperChildConfig storeIdChildren;
@@ -337,6 +326,7 @@ class SquidConfig
         int check_hostnames;
         int allow_underscore;
         int via;
+        int cache_miss_revalidate;
         int emailErrData;
         int httpd_suppress_version_string;
         int global_internal_static;
@@ -356,6 +346,7 @@ class SquidConfig
         int memory_cache_disk;
         int hostStrictVerify;
         int client_dst_passthru;
+        int dns_mdns;
     } onoff;
 
     int pipeline_max_prefetch;
@@ -1,10 +1,6 @@
 #ifndef SQUID_DNS_H
 #define SQUID_DNS_H
 
-#if USE_DNSHELPER
-#include "helper.h"
-#endif
-
 namespace Ip
 {
 class Address;
@@ -14,13 +10,8 @@ class Address;
 void dnsInit(void);
 void dnsShutdown(void);
 
-#if USE_DNSHELPER
-// external DNS helper API
-void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
-#else
 // internal DNS client API
 void idnsALookup(const char *, IDNSCB *, void *);
 void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
-#endif
 
 #endif /* SQUID_DNS_H */
@@ -43,40 +43,6 @@
 #define SQUIDSTRINGPRINT(s) (s).psize(),(s).rawBuf()
 #endif /* SQUIDSTRINGPH */
 
-#define DEBUGSTRINGS 0
-#if DEBUGSTRINGS
-#include "splay.h"
-
-class String;
-
-class StringRegistry
-{
-
-public:
-    static StringRegistry &Instance();
-
-    void add(String const *);
-
-    StringRegistry();
-
-    void remove(String const *);
-
-private:
-    static OBJH Stat;
-
-    static StringRegistry Instance_;
-
-    static SplayNode<String const *>::SPLAYWALKEE Stater;
-
-    Splay<String const *> entries;
-
-    bool registered;
-
-};
-
-class StoreEntry;
-#endif
-
 class String
 {
 
@@ -87,7 +53,7 @@ class String
     ~String();
 
     typedef size_t size_type; //storage size intentionally unspecified
-    const static size_type npos = std::string::npos;
+    const static size_type npos = -1;
 
     String &operator =(char const *);
     String &operator =(String const &);
@@ -105,14 +71,6 @@ class String
     /// throws when size() > MAXINT
     int psize() const;
 
-    /**
-     * \retval true the String has some contents
-     */
-    _SQUID_INLINE_ bool defined() const;
-    /**
-     * \retval true the String does not hold any contents
-     */
-    _SQUID_INLINE_ bool undefined() const;
     /**
      * Returns a raw pointer to the underlying backing store. The caller has been
      * verified not to make any assumptions about null-termination
@@ -150,15 +108,14 @@ class String
 
     _SQUID_INLINE_ void cut(size_type newLength);
 
-#if DEBUGSTRINGS
-    void stat(StoreEntry *) const;
-#endif
-
 private:
     void allocAndFill(const char *str, int len);
     void allocBuffer(size_type sz);
     void setBuffer(char *buf, size_type sz);
 
+    bool defined() const {return buf_!=NULL;}
+    bool undefined() const {return !defined();}
+
     _SQUID_INLINE_ bool nilCmp(bool, bool, int &) const;
 
     /* never reference these directly! */
@@ -205,6 +205,26 @@ StatHist::dump(StoreEntry * sentry, StatHistBinDumper * bd) const
     }
 }
 
+StatHist &
+StatHist::operator += (const StatHist &B)
+{
+    Must(capacity_ == B.capacity_);
+    Must(min_ == B.min_);
+    Must(max_ == B.max_);
+
+    if (B.bins == NULL) { // B was not yet initializted
+        return *this;
+    }
+    if (bins == NULL) { // this histogram was not yet initialized
+        *this = B;
+        return *this;
+    }
+    for (unsigned int i = 0; i < capacity_; ++i) {
+        bins[i] += B.bins[i];
+    }
+    return *this;
+}
+
 /* log based histogram */
 double
 Math::Log(double x)
@@ -73,23 +73,36 @@ class StatHist
      *  this and the supplied histogram.
      */
     double deltaPctile(const StatHist &B, double pctile) const;
+
     /** obtain the output-transformed value from the specified bin
      *
      */
     double val(unsigned int bin) const;
+
     /** increment the counter for the histogram entry
      * associated to the supplied value
      */
     void count(double val);
+
     /** iterate the supplied bd function over the histogram values
      */
     void dump(StoreEntry *sentry, StatHistBinDumper * bd) const;
+
     /** Initialize the Histogram using a logarithmic values distribution
      */
     void logInit(unsigned int capacity, double min, double max);
+
     /** initialize the histogram to count occurrences in an enum-represented set
      */
     void enumInit(unsigned int last_enum);
+
+    /** Import values from another histogram
+     *
+     * \note: the two histograms MUST have the same capicity, min and max or
+     *      an exception will be raised
+     */
+    StatHist &operator += (const StatHist &B);
+
 protected:
     /** low-level initialize function. called by *Init high-level functions
      * \note Important restrictions on val_in and val_out functions:
@@ -103,16 +116,21 @@ class StatHist
      *  See log and linear based histograms for examples
      */
     void init(unsigned int capacity, hbase_f * val_in, hbase_f * val_out, double min, double max);
+
     /// find what entry in the histogram corresponds to v, by applying
     /// the preset input transformation function
     unsigned int findBin(double v);
+
     /// the histogram counters
     bins_type *bins;
     unsigned int capacity_;
+
     /// minimum value to be stored, corresponding to the first bin
     double min_;
+
     /// value of the maximum counter in the histogram
     double max_;
+
     /// scaling factor when looking for a bin
     double scale_;
     hbase_f *val_in;        /* e.g., log() for log-based histogram */
@@ -30,8 +30,8 @@
  *
  */
 
-#include "MemObject.h"
 #include "HttpReply.h"
+#include "MemObject.h"
 
 /**
  \retval true	Store contains 0 bytes of data.
@@ -70,7 +70,7 @@
  * configure will take a list of storage types through the
  * --enable-store-io parameter. This parameter takes a list of
  * space seperated storage types. For example,
- * --enable-store-io="ufs coss" .
+ * --enable-store-io="ufs aufs" .
  *
  \par
  * Each storage type must create an archive file
@@ -34,8 +34,8 @@
 #define SQUID_STOREIOBUFFER_H
 
 /* TODO: move this and the range() method into a .cci */
-#include "Range.h"
 #include "MemBuf.h"
+#include "Range.h"
 
 class StoreIOBuffer
 {
@@ -32,15 +32,15 @@
  */
 
 #include "squid.h"
-#include "StoreMeta.h"
-#include "Store.h"
 #include "MemObject.h"
+#include "Store.h"
+#include "StoreMeta.h"
 #include "StoreMetaMD5.h"
-#include "StoreMetaURL.h"
+#include "StoreMetaObjSize.h"
 #include "StoreMetaSTD.h"
 #include "StoreMetaSTDLFS.h"
+#include "StoreMetaURL.h"
 #include "StoreMetaVary.h"
-#include "StoreMetaObjSize.h"
 
 bool
 StoreMeta::validType(char type)
@@ -30,8 +30,8 @@
 #ifndef SQUID_STOREMETAOBJSIZE_H
 #define SQUID_STOREMETAOBJSIZE_H
 
-#include "StoreMeta.h"
 #include "MemPool.h"
+#include "StoreMeta.h"
 
 class StoreMetaObjSize : public StoreMeta
 {
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "StoreMetaSTD.h"
-#include "Store.h"
 #include "MemObject.h"
+#include "Store.h"
+#include "StoreMetaSTD.h"
 
 bool
 StoreMetaSTD::validLength(int len) const
@@ -31,9 +31,9 @@
  */
 
 #include "squid.h"
-#include "StoreMetaSTDLFS.h"
-#include "Store.h"
 #include "MemObject.h"
+#include "Store.h"
+#include "StoreMetaSTDLFS.h"
 
 bool
 StoreMetaSTDLFS::validLength(int len) const
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "StoreMetaURL.h"
-#include "Store.h"
 #include "MemObject.h"
+#include "Store.h"
+#include "StoreMetaURL.h"
 
 bool
 StoreMetaURL::checkConsistency(StoreEntry *e) const
@@ -32,10 +32,10 @@
  */
 
 #include "squid.h"
-#include "defines.h"
 #include "Debug.h"
-#include "StoreMetaUnpacker.h"
+#include "defines.h"
 #include "StoreMeta.h"
+#include "StoreMetaUnpacker.h"
 
 int const StoreMetaUnpacker::MinimumBufferLength = sizeof(char) + sizeof(int);
 
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "StoreMetaVary.h"
-#include "Store.h"
 #include "MemObject.h"
+#include "Store.h"
+#include "StoreMetaVary.h"
 
 bool
 StoreMetaVary::checkConsistency(StoreEntry *e) const
@@ -4,8 +4,8 @@
  */
 
 #include "squid.h"
-#include "tools.h"
 #include "StoreStats.h"
+#include "tools.h"
 
 /* StoreInfoStats */
 
@@ -99,7 +99,7 @@ operator <<(std::ostream &os, const SwapChecksum24 &sum)
  *
  \par
  * Defines the structure of a binary swap.state file entry for UFS stores.
- * TODO: Move to fs/ufs (and remove from COSS).
+ * TODO: Move to fs/ufs
  *
  \note StoreSwapLogData entries are written in native machine byte order
  *     They are not necessarily portable across architectures.
@@ -53,16 +53,6 @@ String::size() const
     return len_;
 }
 
-bool String::defined() const
-{
-    return buf_!=NULL;
-}
-
-bool String::undefined() const
-{
-    return buf_==NULL;
-}
-
 char const *
 String::rawBuf() const
 {
@@ -34,6 +34,7 @@
 #include "cache_cf.h"
 #include "compat/strtoll.h"
 #include "ConfigOption.h"
+#include "ConfigParser.h"
 #include "globals.h"
 #include "Parsing.h"
 #include "SquidConfig.h"
@@ -276,7 +277,7 @@ SwapDir::parseOptions(int isaReconfig)
 
     ConfigOption *newOption = getOptionTree();
 
-    while ((name = strtok(NULL, w_space)) != NULL) {
+    while ((name = ConfigParser::NextToken()) != NULL) {
         value = strchr(name, '=');
 
         if (value) {
@@ -32,7 +32,10 @@
  */
 
 #include "squid.h"
+#include "Debug.h"
+#include "globals.h"
 #include "protos.h"
+#include "SquidConfig.h"
 
 #if _SQUID_WINDOWS_
 #ifndef _MSWSOCK_
@@ -46,17 +49,17 @@
 
 /* forward declarations */
 static void WIN32_Exit(void);
-static void WIN32_Abort(int);
-
 static unsigned int GetOSVersion();
 void WIN32_svcstatusupdate(DWORD, DWORD);
 void WINAPI WIN32_svcHandler(DWORD);
+extern "C" void WINAPI SquidWinSvcMain(DWORD, char **);
+
 #if USE_WIN32_SERVICE
+static void WIN32_Abort(int);
 static int WIN32_StoreKey(const char *, DWORD, unsigned char *, int);
 static int WIN32_create_key(void);
 static void WIN32_build_argv (char *);
 #endif
-extern "C" void WINAPI SquidWinSvcMain(DWORD, char **);
 
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
 void Squid_Win32InvalidParameterHandler(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
@@ -68,8 +71,6 @@ void WIN32_ExceptionHandlerCleanup(void);
 static int s_iInitCount = 0;
 static HANDLE NotifyAddrChange_thread = INVALID_HANDLE_VALUE;
 
-static int Squid_Aborting = 0;
-
 #undef NotifyAddrChange
 typedef DWORD(WINAPI * PFNotifyAddrChange) (OUT PHANDLE, IN LPOVERLAPPED);
 #define NOTIFYADDRCHANGE "NotifyAddrChange"
@@ -108,6 +109,8 @@ static char *keys[] = {
     NULL,	    /* key[3] */
     NULL	    /* key[4] */
 };
+
+static int Squid_Aborting = 0;
 #endif
 
 /* ====================================================================== */
@@ -388,17 +391,16 @@ GetOSVersion()
 /* PUBLIC FUNCTIONS */
 /* ====================================================================== */
 
+#if USE_WIN32_SERVICE
 void
 WIN32_Abort(int sig)
 {
-#if USE_WIN32_SERVICE
     svcStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
     svcStatus.dwServiceSpecificExitCode = 1;
-#endif
-
     Squid_Aborting = 1;
     WIN32_Exit();
 }
+#endif
 
 void
 WIN32_IpAddrChangeMonitorExit()
@@ -924,6 +926,7 @@ int main(int argc, char **argv)
     char *c;
     char stderr_path[256];
 
+    SetErrorMode(SEM_NOGPFAULTERRORBOX);
     if ((argc == 2) && strstr(argv[1], _WIN_SQUID_SERVICE_OPTION)) {
         strcpy(stderr_path, argv[0]);
         strcat(stderr_path,".log");
@@ -55,8 +55,8 @@ void
 ACLFlags::parseFlags()
 {
     char *nextToken;
-    while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
-
+    while ((nextToken = ConfigParser::PeekAtToken()) != NULL && nextToken[0] == '-') {
+        (void)ConfigParser::NextToken(); //Get token from cfg line
         //if token is the "--" break flag
         if (strcmp(nextToken, "--") == 0)
             break;
@@ -73,10 +73,7 @@ ACLFlags::parseFlags()
 
     /*Regex code needs to parse -i file*/
     if ( isSet(ACL_F_REGEX_CASE))
-        ConfigParser::strtokFilePutBack("-i");
-
-    if (nextToken != NULL && strcmp(nextToken, "--") != 0 )
-        ConfigParser::strtokFileUndo();
+        ConfigParser::TokenPutBack("-i");
 }
 
 const char *
@@ -200,7 +197,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 
     /* snarf the ACL name */
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseAclLine: missing ACL name.");
         parser.destruct();
         return;
@@ -217,7 +214,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
     /* snarf the ACL type */
     const char *theType;
 
-    if ((theType = strtok(NULL, w_space)) == NULL) {
+    if ((theType = ConfigParser::NextToken()) == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseAclLine: missing ACL type.");
         parser.destruct();
         return;
@@ -298,13 +295,11 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
                A->cfgline);
     }
 
-    /* append */
+    // prepend so that ACLs declared later (and possibly using earlier ACLs)
+    // are destroyed earlier (before the ACLs they use are destroyed)
     assert(head && *head == Config.aclList);
     A->registered = true;
-
-    while (*head)
-        head = &(*head)->next;
-
+    A->next = *head;
     *head = A;
 }
 
@@ -135,7 +135,7 @@ class ACL
 
     char name[ACL_NAME_SZ];
     char *cfgline;
-    ACL *next;
+    ACL *next; // XXX: remove or at least use refcounting
     ACLFlags flags; ///< The list of given ACL flags
     bool registered; ///< added to Config.aclList and can be reused via by FindByName()
 
@@ -244,6 +244,7 @@ class acl_proxy_auth_match_cache
 MEMPROXY_CLASS_INLINE(acl_proxy_auth_match_cache);
 
 /// \ingroup ACLAPI
+/// XXX: find a way to remove or at least use a refcounted ACL pointer
 extern const char *AclMatchedName;	/* NULL */
 
 #endif /* SQUID_ACL_H */
@@ -29,8 +29,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  */
 
-#include "ip/Address.h"
 #include "acl/Acl.h"
+#include "ip/Address.h"
 
 /// list of address-based ACLs. Currently a POD.
 class AclAddress
@@ -0,0 +1,34 @@
+#include "squid.h"
+#include "acl/AdaptationService.h"
+#include "acl/Checklist.h"
+#include "acl/IntRange.h"
+#include "adaptation/Config.h"
+#include "adaptation/History.h"
+#include "HttpRequest.h"
+
+int
+ACLAdaptationServiceStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+{
+    HttpRequest::Pointer request = checklist->request;
+    if (request == NULL)
+        return 0;
+    Adaptation::History::Pointer ah = request->adaptHistory();
+    if (ah == NULL)
+        return 0;
+
+    Adaptation::History::AdaptationServices::iterator it;
+    for (it = ah->theAdaptationServices.begin(); it != ah->theAdaptationServices.end(); ++it) {
+        if (data->match(it->c_str()))
+            return 1;
+    }
+
+    return 0;
+}
+
+ACLAdaptationServiceStrategy *
+ACLAdaptationServiceStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLAdaptationServiceStrategy ACLAdaptationServiceStrategy::Instance_;
@@ -0,0 +1,35 @@
+#ifndef SQUID_ACLADAPTATIONSERVICE_H
+#define SQUID_ACLADAPTATIONSERVICE_H
+
+#include "acl/Strategised.h"
+#include "acl/Strategy.h"
+
+/// \ingroup ACLAPI
+class ACLAdaptationServiceStrategy : public ACLStrategy<const char *>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    static ACLAdaptationServiceStrategy *Instance();
+    /**
+     * Not implemented to prevent copies of the instance.
+     */
+    ACLAdaptationServiceStrategy(ACLAdaptationServiceStrategy const &);
+
+private:
+    static ACLAdaptationServiceStrategy Instance_;
+    ACLAdaptationServiceStrategy() {}
+
+    ACLAdaptationServiceStrategy &operator = (ACLAdaptationServiceStrategy const &);
+};
+
+/// \ingroup ACLAPI
+class ACLAdaptationService
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<const char *> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLADAPTATIONSERVICE_H */
@@ -0,0 +1,39 @@
+#include "squid.h"
+#include "acl/AdaptationServiceData.h"
+#include "acl/Checklist.h"
+#include "adaptation/Config.h"
+#include "adaptation/ecap/Config.h"
+#include "adaptation/icap/Config.h"
+#include "adaptation/Service.h"
+#include "adaptation/ServiceGroups.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "wordlist.h"
+
+void
+ACLAdaptationServiceData::parse()
+{
+    Adaptation::Config::needHistory = true;
+    while (char *t = ConfigParser::strtokFile()) {
+        if (
+#if USE_ECAP
+            Adaptation::Ecap::TheConfig.findServiceConfig(t) == NULL &&
+#endif
+#if ICAP_CLIENT
+            Adaptation::Icap::TheConfig.findServiceConfig(t) == NULL &&
+#endif
+            Adaptation::FindGroup(t) == NULL) {
+            debugs(28, DBG_CRITICAL, "FATAL: Adaptation service/group " << t << " in adaptation_service acl is not defined");
+            self_destruct();
+        }
+        insert(t);
+    }
+}
+
+ACLData<char const *> *
+ACLAdaptationServiceData::clone() const
+{
+    return new ACLAdaptationServiceData(*this);
+}
+
@@ -0,0 +1,21 @@
+
+#ifndef SQUID_ADAPTATIONSERVICEDATA_H
+#define SQUID_ADAPTATIONSERVICEDATA_H
+
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/StringData.h"
+
+/// \ingroup ACLAPI
+class ACLAdaptationServiceData : public ACLStringData
+{
+public:
+    ACLAdaptationServiceData() : ACLStringData() {}
+    ACLAdaptationServiceData(ACLAdaptationServiceData const &old) : ACLStringData(old) {};
+    // Not implemented
+    ACLAdaptationServiceData &operator= (ACLAdaptationServiceData const &);
+    virtual void parse();
+    virtual ACLData<char const *> *clone() const;
+};
+
+#endif /* SQUID_ADAPTATIONSERVICEDATA_H */
@@ -1,7 +1,7 @@
 #include "squid.h"
 #include "acl/AllOf.h"
-#include "acl/Checklist.h"
 #include "acl/BoolOps.h"
+#include "acl/Checklist.h"
 #include "globals.h"
 #include "MemBuf.h"
 
@@ -89,17 +89,45 @@ struct as_info {
     time_t expires;		/* NOTUSED */
 };
 
-struct ASState {
+class ASState
+{
+public:
+    ASState();
+    ~ASState();
+
     StoreEntry *entry;
     store_client *sc;
-    HttpRequest *request;
+    HttpRequest::Pointer request;
     int as_number;
     int64_t offset;
     int reqofs;
     char reqbuf[AS_REQBUF_SZ];
     bool dataRead;
+private:
+    CBDATA_CLASS2(ASState);
 };
 
+CBDATA_CLASS_INIT(ASState);
+
+ASState::ASState() :
+        entry(NULL),
+        sc(NULL),
+        request(NULL),
+        as_number(0),
+        offset(0),
+        reqofs(0),
+        dataRead(false)
+{
+    memset(reqbuf, 0, AS_REQBUF_SZ);
+}
+
+ASState::~ASState()
+{
+    debugs(53, 3, entry->url());
+    storeUnregister(sc, entry, this);
+    entry->unlock("~ASState");
+}
+
 /** entry into the radix tree */
 struct rtentry_t {
     struct squid_radix_node e_nodes[2];
@@ -127,8 +155,6 @@ extern "C" {
 
 void asnAclInitialize(ACL * acls);
 
-static void asStateFree(void *data);
-
 static void destroyRadixNodeInfo(as_info *);
 
 static OBJH asnStats;
@@ -197,13 +223,11 @@ asnRegisterWithCacheManager(void)
 
 SQUIDCEXTERN int squid_max_keylen;	/* yuck.. this is in lib/radix.c */
 
-CBDATA_TYPE(ASState);
 void
 asnInit(void)
 {
     static bool inited = false;
     squid_max_keylen = 40;
-    CBDATA_INIT_TYPE(ASState);
 
     if (!inited) {
         inited = true;
@@ -237,34 +261,25 @@ asnCacheStart(int as)
 {
     LOCAL_ARRAY(char, asres, 4096);
     StoreEntry *e;
-    ASState *asState;
-    asState = cbdataAlloc(ASState);
-    asState->dataRead = 0;
-    debugs(53, 3, "asnCacheStart: AS " << as);
+    ASState *asState = new ASState;
+    debugs(53, 3, "AS " << as);
     snprintf(asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
     asState->as_number = as;
     asState->request = HttpRequest::CreateFromUrl(asres);
-    assert(NULL != asState->request);
-    HTTPMSGLOCK(asState->request);
+    assert(asState->request != NULL);
 
     if ((e = storeGetPublic(asres, Http::METHOD_GET)) == NULL) {
         e = storeCreateEntry(asres, asres, RequestFlags(), Http::METHOD_GET);
         asState->sc = storeClientListAdd(e, asState);
-        FwdState::fwdStart(Comm::ConnectionPointer(), e, asState->request);
+        FwdState::fwdStart(Comm::ConnectionPointer(), e, asState->request.getRaw());
     } else {
         e->lock("Asn");
         asState->sc = storeClientListAdd(e, asState);
     }
 
     asState->entry = e;
-    asState->offset = 0;
-    asState->reqofs = 0;
     StoreIOBuffer readBuffer (AS_REQBUF_SZ, asState->offset, asState->reqbuf);
-    storeClientCopy(asState->sc,
-                    e,
-                    readBuffer,
-                    asHandleReply,
-                    asState);
+    storeClientCopy(asState->sc, e, readBuffer, asHandleReply, asState);
 }
 
 static void
@@ -283,21 +298,21 @@ asHandleReply(void *data, StoreIOBuffer result)
     /* First figure out whether we should abort the request */
 
     if (EBIT_TEST(e->flags, ENTRY_ABORTED)) {
-        asStateFree(asState);
+        delete asState;
         return;
     }
 
     if (result.length == 0 && asState->dataRead) {
-        debugs(53, 3, "asHandleReply: Done: " << e->url()  );
-        asStateFree(asState);
+        debugs(53, 3, "asHandleReply: Done: " << e->url());
+        delete asState;
         return;
     } else if (result.flags.error) {
         debugs(53, DBG_IMPORTANT, "asHandleReply: Called with Error set and size=" << (unsigned int) result.length);
-        asStateFree(asState);
+        delete asState;
         return;
     } else if (e->getReply()->sline.status() != Http::scOkay) {
         debugs(53, DBG_IMPORTANT, "WARNING: AS " << asState->as_number << " whois request failed");
-        asStateFree(asState);
+        delete asState;
         return;
     }
 
@@ -325,7 +340,7 @@ asHandleReply(void *data, StoreIOBuffer result)
         debugs(53, 3, "asHandleReply: AS# " << s << " (" << asState->as_number << ")");
         asnAddNet(s, asState->as_number);
         s = t + 1;
-        asState->dataRead = 1;
+        asState->dataRead = true;
     }
 
     /*
@@ -376,17 +391,6 @@ asHandleReply(void *data, StoreIOBuffer result)
     }
 }
 
-static void
-asStateFree(void *data)
-{
-    ASState *asState = (ASState *)data;
-    debugs(53, 3, "asnStateFree: " << asState->entry->url()  );
-    storeUnregister(asState->sc, asState->entry, asState);
-    asState->entry->unlock("Asn");
-    HTTPMSGUNLOCK(asState->request);
-    cbdataFree(asState);
-}
-
 /**
  * add a network (addr, mask) to the radix tree, with matching AS number
  */
@@ -32,10 +32,10 @@
 #ifndef SQUID_ACLASN_H
 #define SQUID_ACLASN_H
 
+#include "acl/Checklist.h"
 #include "acl/Data.h"
-#include "CbDataList.h"
 #include "acl/Strategised.h"
-#include "acl/Checklist.h"
+#include "CbDataList.h"
 #include "ip/Address.h"
 
 int asnMatchIp(CbDataList<int> *, Ip::Address &);
@@ -33,8 +33,8 @@
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
 #include "acl/Browser.h"
+#include "acl/Checklist.h"
 #include "acl/RegexData.h"
 
 /* explicit template instantiation required for some systems */
@@ -40,12 +40,12 @@
 #if USE_SSL
 
 #include "acl/Certificate.h"
-#include "acl/Checklist.h"
 #include "acl/CertificateData.h"
-#include "HttpRequest.h"
+#include "acl/Checklist.h"
 #include "client_side.h"
 #include "fde.h"
 #include "globals.h"
+#include "HttpRequest.h"
 
 int
 ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
@@ -34,10 +34,10 @@
 #define SQUID_ACLCERTIFICATE_H
 
 #include "acl/Acl.h"
-#include "acl/Data.h"
 #include "acl/Checklist.h"
-#include "ssl/support.h"
+#include "acl/Data.h"
 #include "acl/Strategised.h"
+#include "ssl/support.h"
 
 /// \ingroup ACLAPI
 class ACLCertificateStrategy : public ACLStrategy<X509 *>
@@ -35,8 +35,8 @@
 #include "squid.h"
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
-#include "Debug.h"
 #include "cache_cf.h"
+#include "Debug.h"
 #include "wordlist.h"
 
 ACLCertificateData::ACLCertificateData(Ssl::GETX509ATTRIBUTE *sslStrategy, const char *attrs, bool optionalAttr) : validAttributesStr(attrs), attributeIsOptional(optionalAttr), attribute (NULL), values (), sslAttributeCall (sslStrategy)
@@ -33,11 +33,11 @@
 #ifndef SQUID_ACLCERTIFICATEDATA_H
 #define SQUID_ACLCERTIFICATEDATA_H
 
-#include "splay.h"
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "ssl/support.h"
 #include "acl/StringData.h"
+#include "splay.h"
+#include "ssl/support.h"
 #include <string>
 #include <list>
 
@@ -33,10 +33,10 @@
  */
 
 #include "squid.h"
-#include "acl/DestinationDomain.h"
 #include "acl/Checklist.h"
-#include "acl/RegexData.h"
+#include "acl/DestinationDomain.h"
 #include "acl/DomainData.h"
+#include "acl/RegexData.h"
 #include "fqdncache.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
@@ -34,8 +34,8 @@
 #define SQUID_ACLDESTINATIONDOMAIN_H
 
 #include "acl/Acl.h"
-#include "acl/Data.h"
 #include "acl/Checklist.h"
+#include "acl/Data.h"
 #include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
@@ -33,12 +33,12 @@
  */
 
 #include "squid.h"
-#include "acl/DomainData.h"
 #include "acl/Checklist.h"
+#include "acl/DomainData.h"
 #include "cache_cf.h"
 #include "Debug.h"
-#include "wordlist.h"
 #include "src/URL.h"
+#include "wordlist.h"
 
 template<class T>
 inline void
@@ -33,9 +33,9 @@
 #ifndef SQUID_ACLDOMAINDATA_H
 #define SQUID_ACLDOMAINDATA_H
 
-#include "splay.h"
 #include "acl/Acl.h"
 #include "acl/Data.h"
+#include "splay.h"
 
 /// \ingroup ACLAPI
 class ACLDomainData : public ACLData<char const *>
@@ -7,8 +7,8 @@
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 #if USE_AUTH
-#include "auth/UserRequest.h"
 #include "auth/AclProxyAuth.h"
+#include "auth/UserRequest.h"
 #endif
 
 CBDATA_CLASS_INIT(ACLFilledChecklist);
@@ -1,6 +1,7 @@
 #ifndef SQUID_ACLFILLED_CHECKLIST_H
 #define SQUID_ACLFILLED_CHECKLIST_H
 
+#include "AccessLogEntry.h"
 #include "acl/Checklist.h"
 #include "acl/forward.h"
 #include "ip/Address.h"
@@ -75,6 +76,8 @@ class ACLFilledChecklist: public ACLChecklist
     Ssl::X509_Pointer serverCert;
 #endif
 
+    AccessLogEntry::Pointer al; ///< info for the future access.log entry
+
     ExternalACLEntry *extacl_entry;
 
 private:
@@ -38,12 +38,12 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
-#include "acl/AclNameList.h"
 #include "acl/AclDenyInfoList.h"
+#include "acl/AclNameList.h"
 #include "acl/Checklist.h"
-#include "acl/Tree.h"
-#include "acl/Strategised.h"
 #include "acl/Gadgets.h"
+#include "acl/Strategised.h"
+#include "acl/Tree.h"
 #include "ConfigParser.h"
 #include "errorpage.h"
 #include "globals.h"
@@ -54,6 +54,11 @@
 err_type
 aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed)
 {
+    if (!name) {
+        debugs(28, 3, "ERR_NONE due to a NULL name");
+        return ERR_NONE;
+    }
+
     AclDenyInfoList *A = NULL;
 
     debugs(28, 8, HERE << "got called for " << name);
@@ -83,10 +88,12 @@ aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allow
 int
 aclIsProxyAuth(const char *name)
 {
-    debugs(28, 5, "aclIsProxyAuth: called for " << name);
-
-    if (NULL == name)
+    if (!name) {
+        debugs(28, 3, "false due to a NULL name");
         return false;
+    }
+
+    debugs(28, 5, "aclIsProxyAuth: called for " << name);
 
     ACL *a;
 
@@ -120,7 +127,7 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
 
     /* first expect a page name */
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseDenyInfoLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseDenyInfoLine: missing 'error page' parameter.");
         return;
@@ -133,7 +140,7 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
 
-    while ((t = strtok(NULL, w_space))) {
+    while ((t = ConfigParser::NextToken())) {
         L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
         xstrncpy(L->name, t, ACL_NAME_SZ-1);
         *Tail = L;
@@ -157,7 +164,7 @@ void
 aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
 {
     /* first expect either 'allow' or 'deny' */
-    const char *t = ConfigParser::strtokFile();
+    const char *t = ConfigParser::NextToken();
 
     if (!t) {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
@@ -1,8 +1,8 @@
 #ifndef SQUID_ACL_GADGETS_H
 #define SQUID_ACL_GADGETS_H
 
-#include "err_type.h"
 #include "acl/forward.h"
+#include "err_type.h"
 
 #if HAVE_SSTREAM
 #include <sstream>
@@ -1,7 +1,7 @@
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/HierCode.h"
 #include "acl/HierCodeData.h"
-#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
@@ -1,8 +1,8 @@
 #ifndef SQUID_ACLHIERCODE_H
 #define SQUID_ACLHIERCODE_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 #include "hier_code.h"
 
 /// \ingroup ACLAPI
@@ -1,6 +1,6 @@
 #include "squid.h"
-#include "acl/HierCodeData.h"
 #include "acl/Checklist.h"
+#include "acl/HierCodeData.h"
 #include "cache_cf.h"
 #include "hier_code.h"
 #include "wordlist.h"
@@ -33,15 +33,16 @@
  */
 
 #include "squid.h"
-#include "acl/HttpHeaderData.h"
-#include "acl/Checklist.h"
 #include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/HttpHeaderData.h"
 #include "acl/RegexData.h"
 #include "cache_cf.h"
-#include "Debug.h"
-#include "wordlist.h"
 #include "ConfigParser.h"
+#include "Debug.h"
 #include "HttpHeaderTools.h"
+#include "SBuf.h"
+#include "wordlist.h"
 
 /* Construct an ACLHTTPHeaderData that uses an ACLRegex rule with the value of the
  * selected header from a given request.
@@ -75,13 +76,8 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
             return false;
     }
 
-    // By now, we know the header is present, but:
-    // HttpHeader::get*() return an undefined String for empty header values;
-    // String::termedBuf() returns NULL for undefined Strings; and
-    // ACLRegexData::match() always fails on NULL strings.
-    // This makes it possible to detect an empty header value using regex:
-    const char *cvalue = value.defined() ? value.termedBuf() : "";
-    return regex_rule->match(cvalue);
+    SBuf cvalue(value);
+    return regex_rule->match(cvalue.c_str());
 }
 
 wordlist *
@@ -108,7 +104,7 @@ ACLHTTPHeaderData::parse()
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == HDR_BAD_HDR && hdrName.undefined()) || regex_rule->empty();
+    return (hdrId == HDR_BAD_HDR && hdrName.size()==0) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "acl/HttpRepHeader.h"
-#include "acl/HttpHeaderData.h"
 #include "acl/Checklist.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/HttpRepHeader.h"
 #include "HttpReply.h"
 
 int
@@ -33,8 +33,8 @@
 #ifndef SQUID_ACLHTTPREPHEADER_H
 #define SQUID_ACLHTTPREPHEADER_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 #include "HttpHeader.h"
 
 /// \ingroup ACLAPI
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "acl/HttpReqHeader.h"
-#include "acl/HttpHeaderData.h"
 #include "acl/Checklist.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/HttpReqHeader.h"
 #include "HttpRequest.h"
 
 int
@@ -33,8 +33,8 @@
 #ifndef SQUID_ACLHTTPREQHEADER_H
 #define SQUID_ACLHTTPREQHEADER_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 #include "HttpHeader.h"
 
 /// \ingroup ACLAPI
@@ -33,8 +33,8 @@
  */
 
 #include "squid.h"
-#include "acl/HttpStatus.h"
 #include "acl/FilledChecklist.h"
+#include "acl/HttpStatus.h"
 #include "cache_cf.h"
 #include "Debug.h"
 #include "HttpReply.h"
@@ -40,6 +40,7 @@ class InnerNode: public ACL
     /* ACL API */
     virtual int match(ACLChecklist *checklist);
 
+    // XXX: use refcounting instead of raw pointers
     std::vector<ACL*> nodes; ///< children nodes of this intermediate node
 };
 
@@ -36,8 +36,8 @@
 #include "acl/IntRange.h"
 #include "cache_cf.h"
 #include "Debug.h"
-#include "wordlist.h"
 #include "Parsing.h"
+#include "wordlist.h"
 
 /* explicit instantiation required for some systems */
 /** \cond AUTODOCS-IGNORE */
@@ -32,8 +32,8 @@
  */
 
 #include "squid.h"
-#include "acl/Ip.h"
 #include "acl/Checklist.h"
+#include "acl/Ip.h"
 #include "cache_cf.h"
 #include "Debug.h"
 #include "ip/tools.h"
@@ -34,8 +34,8 @@
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "splay.h"
 #include "ip/Address.h"
+#include "splay.h"
 
 /// \ingroup ACLAPI
 class acl_ip_data
@@ -32,8 +32,8 @@
  */
 
 #include "squid.h"
-#include "acl/LocalIp.h"
 #include "acl/FilledChecklist.h"
+#include "acl/LocalIp.h"
 
 char const *
 ACLLocalIP::typeString() const
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
-#include "acl/LocalPort.h"
-#include "acl/IntRange.h"
 #include "acl/Checklist.h"
+#include "acl/IntRange.h"
+#include "acl/LocalPort.h"
 
 int
 ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
@@ -33,8 +33,8 @@
 #ifndef SQUID_ACLLOCALPORT_H
 #define SQUID_ACLLOCALPORT_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 
 /// \ingroup ACLAPI
 class ACLLocalPortStrategy : public ACLStrategy<int>
@@ -148,6 +148,14 @@ if ENABLE_SSL
 libacls_la_SOURCES += $(SSL_ACLS)
 endif
 
+if USE_ADAPTATION
+libacls_la_SOURCES += AdaptationService.h \
+	AdaptationService.cc \
+	AdaptationServiceData.h \
+	AdaptationServiceData.cc
+endif
+
+
 EXTRA_libacls_la_SOURCES += $(SSL_ACLS)
 
 
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/Method.h"
 #include "acl/MethodData.h"
-#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
@@ -33,8 +33,8 @@
 #ifndef SQUID_ACLMETHOD_H
 #define SQUID_ACLMETHOD_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 #include "HttpRequestMethod.h"
 
 /// \ingroup ACLAPI
@@ -33,8 +33,8 @@
  */
 
 #include "squid.h"
-#include "acl/MethodData.h"
 #include "acl/Checklist.h"
+#include "acl/MethodData.h"
 #include "cache_cf.h"
 #include "HttpRequestMethod.h"
 #include "wordlist.h"
@@ -33,8 +33,8 @@
 
 #ifndef SQUID_ACLMYPORTNAME_H
 #define SQUID_ACLMYPORTNAME_H
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 
 class ACLMyPortNameStrategy : public ACLStrategy<const char *>
 {
@@ -1,7 +1,7 @@
 #include "squid.h"
-#include "acl/Note.h"
-#include "acl/HttpHeaderData.h"
 #include "acl/Checklist.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Note.h"
 #include "HttpRequest.h"
 #include "Notes.h"
 
@@ -1,8 +1,8 @@
 #ifndef SQUID_ACLNOTE_H
 #define SQUID_ACLNOTE_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 
 class HttpRequest;
 
@@ -74,7 +74,7 @@ ACLNoteData::parse()
 bool
 ACLNoteData::empty() const
 {
-    return name.undefined();
+    return name.size() == 0;
 }
 
 ACLData<HttpRequest *> *
@@ -2,8 +2,8 @@
 #define SQUID_ACLNOTEDATA_H
 
 #include "acl/Data.h"
-#include "SquidString.h"
 #include "MemPool.h"
+#include "SquidString.h"
 
 class HttpRequest;
 class NotePairs;
@@ -1,8 +1,8 @@
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/PeerName.h"
 #include "acl/RegexData.h"
 #include "acl/StringData.h"
-#include "acl/Checklist.h"
 #include "CachePeer.h"
 
 int
@@ -1,8 +1,8 @@
 #ifndef SQUID_ACLPEERNAME_H
 #define SQUID_ACLPEERNAME_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 
 class ACLPeerNameStrategy : public ACLStrategy<const char *>
 {
@@ -32,9 +32,9 @@
  */
 
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/Protocol.h"
 #include "acl/ProtocolData.h"
-#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
@@ -34,8 +34,8 @@
 #ifndef SQUID_ACLPROTOCOL_H
 #define SQUID_ACLPROTOCOL_H
 
-#include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "acl/Strategy.h"
 #include "anyp/ProtocolType.h"
 
 class ACLProtocolStrategy : public ACLStrategy<AnyP::ProtocolType>
@@ -33,8 +33,8 @@
  */
 
 #include "squid.h"
-#include "acl/ProtocolData.h"
 #include "acl/Checklist.h"
+#include "acl/ProtocolData.h"
 #include "cache_cf.h"
 #include "Debug.h"
 #include "URLScheme.h"
@@ -33,8 +33,8 @@
  */
 
 #include "squid.h"
-#include "acl/Referer.h"
 #include "acl/Checklist.h"
+#include "acl/Referer.h"
 #include "acl/RegexData.h"
 
 /* explicit template instantiation required for some systems */
@@ -35,9 +35,9 @@
  */
 
 #include "squid.h"
-#include "acl/RegexData.h"
-#include "acl/Checklist.h"
 #include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "Mem.h"
@@ -322,7 +322,7 @@ aclParseRegexList(RegexList **curlist)
 
     debugs(28, 2, HERE << "aclParseRegexList: new Regex line or file");
 
-    while ((t = ConfigParser::strtokFile()) != NULL) {
+    while ((t = ConfigParser::RegexStrtokFile()) != NULL) {
         const char *clean = removeUnnecessaryWildcards(t);
         if (strlen(clean) > BUFSIZ-1) {
             debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
@@ -36,8 +36,8 @@ class ACLChecklist;
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "acl/Strategy.h"
 #include "acl/FilledChecklist.h"
+#include "acl/Strategy.h"
 #include "HttpReply.h"
 
 template <http_hdr_type header>
@@ -33,9 +33,9 @@
  */
 
 #include "squid.h"
-#include "acl/ReplyMimeType.h"
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
+#include "acl/ReplyMimeType.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -45,9 +45,9 @@ class ACLReplyMIMEType
 
 /* partial specialisation */
 
+#include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/ReplyHeaderStrategy.h"
-#include "acl/Checklist.h"
 
 template <>
 inline int
@@ -35,9 +35,9 @@
 #define SQUID_ACLREQUESTHEADERSTRATEGY_H
 #include "acl/Acl.h"
 #include "acl/Data.h"
+#include "acl/FilledChecklist.h"
 #include "acl/Strategy.h"
 #include "HttpRequest.h"
-#include "acl/FilledChecklist.h"
 
 template <http_hdr_type header>
 
@@ -33,9 +33,9 @@
  */
 
 #include "squid.h"
-#include "acl/RequestMimeType.h"
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
+#include "acl/RequestMimeType.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -45,9 +45,9 @@ class ACLRequestMIMEType
 
 /* partial specialisation */
 
+#include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/RequestHeaderStrategy.h"
-#include "acl/Checklist.h"
 
 template <>
 inline int
@@ -5,9 +5,9 @@
 
 #if USE_SSL
 
-#include "acl/ServerCertificate.h"
-#include "acl/Checklist.h"
 #include "acl/CertificateData.h"
+#include "acl/Checklist.h"
+#include "acl/ServerCertificate.h"
 #include "client_side.h"
 #include "fde.h"
 #include "ssl/ServerBump.h"
@@ -5,10 +5,10 @@
 #define SQUID_ACLSERVERCERTIFICATE_H
 
 #include "acl/Acl.h"
-#include "acl/Data.h"
 #include "acl/Checklist.h"
-#include "ssl/support.h"
+#include "acl/Data.h"
 #include "acl/Strategised.h"
+#include "ssl/support.h"
 
 /// \ingroup ACLAPI
 class ACLServerCertificateStrategy : public ACLStrategy<X509 *>