@@ -1,20 +1,30 @@
 Special thanks go to people who have volunteered their time, effort,
 and ideas to make this software available.
 
+    'noloader' <noloader@gmail.com>
     Adam Ciarcinski
     Adrian Chadd <adrian@squid-cache.org>
+    Alan Mizrahi <alan@mizrahi.com.ve>
     Alex Rousskov <rousskov@measurement-factory.com>
     Alexander B. Demenshin <aldem@barnet.kharkov.ua>
+    Alexander Komyagin <komyagin@altell.ru>
     Alexander Lukyanov <lav@yar.ru>
+    Alexandre Chappaz <alexandrechappaz@gmail.com>
     Alexey Veselovsky <alexey.veselovsky@eykontech.com>
+    Alexis Robert <alexis.robert@gmail.com>
     Alin Nastac <mrness@gentoo.org>
     Alter <alter@alter.org.ua>
     Amos Jeffries <amosjeffries@squid-cache.org>
     Amos Jeffries <squid3@treenet.co.nz>
+    Anatoli <me@anatoli.ws>
+    Andrea Gagliardi <andrea@netlite.it>
+    Andreas Jaeger <aj@suse.com>
     Andreas Lamprecht <Andreas.Lamprecht@siemens.at>
     Andres Kroonmaa <andre@ml.ee>
+    Andrew Beverley <andy@andybev.com>
     Andrew Hoying <andrew_hoying@blm.gov>
     Andrey Shorin <tolsty@tushino.com>
+    Anonymous <redskilldough@gmail.com>
     Ansgar Hockmann <Ansgar.Hockmann@hrz.uni-dortmund.de>
     Anthony Baxter <arb@connect.com.au>
     Arjan de Vet <Arjan.deVet@adv.IAEhv.nl>
@@ -23,7 +33,9 @@ and ideas to make this software available.
     Assar Westerlund <assar@pdc.kth.se>
     Automatic source maintenance <squidadm@squid-cache.org>
     Axel Westerhold <ml.awesterhold@dts.de>
+    Benjamin Kerensa <bkerensa@ubuntu.com>
     Benno Rice <benno@squid-cache.org>
+    Bernard <fli4l.charrier@free.fr>
     Bertrand Jacquin <beber@meleeweb.net>
     Bojan Smojver <bojan@rexursive.com>
     Brad Smith <brad@comstyle.com>
@@ -32,13 +44,17 @@ and ideas to make this software available.
     Brian Denehy <B-Denehy@adfa.oz.au>
     Bruce Murphy <pack-squid@rattus.net>
     Carson Gaspar (carson@lehman.com, carson@cs.columbia.edu)
+    Changming <me@sunchangming.com>
     Chris Hills <chaz@chaz6.com>
     Christos Tsantilas <chtsanti@users.sourceforge.net>
     Cloyce <cloyce.spradling@sun.com>
     Constantin Rack
     Cord Beermann <cord@cc.fh-lippe.de>
+    Daniel Beschorner <daniel.beschorner@evlks.de>
     Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
+    David Isaacs <david.isaacs@sbhs.nsw.edu.au>
     David Luyer <luyer@ucs.uwa.edu.au>
+    Dennis Glatting
     Dhaval Varia
     Diego Woitasen <diegows@xtech.com.ar>
     Dmitry Kurochkin
@@ -50,20 +66,26 @@ and ideas to make this software available.
     Dustin J. Mitchell
     Ed Knowles <ed@fatboy.geog.unsw.edu.au>
     Edward Moy <moy@parc.xerox.com>
+    Eliezer Croitoru <eliezer@ngtech.co.il>
+    Elmar Vonlanthen <Elmar.Vonlanthen@united-security-providers.ch>
     Emilio Casbas <ecasbas@unav.es>
     Endre Balint Nagy <bne@CareNet.hu>
+    Eray Aslan <eray.aslan@caf.com.tr>
     Eric Stern <estern@logisense.com>
     Eugene Gladchenko <eugene@donpac.ru>
     Evan Jones <ejones@uwaterloo.ca>
+    Eygene Ryabinkin <rea@freebsd.org>
     Felix Meschberger <felix.meschberger@day.com>
     Finn Thain <fthain@telegraphics.com.au>
     Flavio Pescuma <flavio@marasystems.com>
+    Francesco <kinkie@squid-cache.org>
     Francesco Chemolli <kinkie@squid-cache.org>
     Francesco Salvestrini
     Francis Daly <francis@daoine.org>
     Francois Cami <fcami@winsoft.fr>
     Frank Balluffi
     Frank Schmirler <squid@schmirler.de>
+    Frederic Bourgeois <fredbmail@free.fr>
     Geoff Keating <Geoff.Keating@anu.edu.au>
     George Michaelson <ggm@connect.com.au>
     Georgy Salnikov <sge@nmr.nioch.nsc.ru>
@@ -85,24 +107,29 @@ and ideas to make this software available.
     Igor Vinokurov <igor@cs.ibank.ru>
     Isnard <isnardjaquet@gmail.com>
     JPP <jpp1@frws.com>
+    Jakob Bohm <jb-debbugs@wisemo.com>
     Jakub Wilk <ubanus@users.sf.net>
     James Brotchie <brotchie@gmail.com>
     James R Grinter <jrg@demon.net>
     Jan Niehusmann <jan@anduin.gondor.mcs.de>
+    Jan Sievers <sievers@zedat.fu-berlin.de>
     Jean-Francois Micouleau <Jean-Francois.Micouleau@utc.fr>
     Jean-Gabriel Dick <jean-gabriel.dick@curie.fr>
+    Jean-Philippe Menil <jean-philippe.menil@univ-nantes.fr>
     Jerry Murdock <jmurdock@itraktech.com>
     Joachim Bauch <jojo@fistofbenztown.de>
     Joao Alves Neto <alves_joao@hotmail.com>
     Jochen Voss <voss@seehuhn.de>
     Joe Ramey <ramey@jello.csc.ti.com>
     John Dilley <jad@hpl.hp.com>
     John Saunders <johns@rd.scitec.com.au>
+    John Xue <xgxjohn@gmail.com>
     Johnathan Conley <johnathan.conley@gmail.com>
     Jon Thackray <jrmt@uk.gdscorp.com>
     Jonathan Larmour <JLarmour@origin-at.co.uk>
     Joshua Root <josh+squid@root.id.au>
     Kieran Whitbread <k.j.whitbread@qmul.ac.uk>
+    Kinkie <kinkie@squid-cache.org>
     Klaubert Herr <klaubert@gmail.com>
     Klaus Singvogel <kssingvo@suse.de>
     Kolics Bertold <bertold@tohotom.vein.hu>
@@ -115,15 +142,19 @@ and ideas to make this software available.
     Lutz Donnerhacke <lutz@iks-jena.de>
     Manu Garg <manugarg@gmail.com>
     Marin Stavrev <mstavrev@gmail.com>
+    Marios Makassikis <mmakassikis@gmail.com>
     Mark Bergsma <mark@nedworks.org>
     Mark Nottingham <mnot@pobox.com>
     Mark Treacy <mark@aone.com.au>
     Marko <mr_4u2@yahoo.com>
+    Marko Cupac <marko.cupac@mimar.rs>
     Markus Gyger <mgyger@itr.ch>
     Markus Moeller <huaraz@moeller.plus.com>
+    Markus Rietzler <markus.rietzler@rzf.fin-nrw.de>
     Markus Stumpf <maex@Space.NET>
     Martin Hamilton <martin@mrrl.lut.ac.uk>
     Martin Huter <m.huter@phion.com>
+    Martin Stolle <martin.stolle@ekom21.de>
     Masashi Fujita <objectx@bandit.co.jp>
     Massimo Zito <zmax.linkedin at gmail dot com>
     Matthew Morgan <atcs.matthew@gmail.com>
@@ -134,16 +165,22 @@ and ideas to make this software available.
     Michael O'Reilly <michael@metal.iinet.net.au>
     Michael Pelletier <mikep@comshare.com>
     Michael van Elst
+    Michal Luscon <mluscon@redhat.com>
     Miguel A.L. Paraz <map@iphil.net>
     Mike Groeneweg <mikeg@scorpion.murdoch.edu.au>
     Mike Mitchell <Mike.Mitchell@sas.com>
     Mikio Kishi <mkishi@104.net>
+    Ming Fu <mfu@watchguard.com>
     Miquel van Smoorenburg <miquels@cistron.nl>
     Moez Mahfoudh <moez.mahfoudh@imag.fr>
     Mukaigawa Shin'ichi <shin@nff.ncl.omron.co.jp>
+    Nathan Hoad <nathan@getoffmalawn.com>
     Neil Murray <neil@aone.com.au>
     Niall Doherty <ndoherty@eei.ericsson.se>
+    Nick Rogers <ncrogers@gmail.com>
+    Nikolai Gorchilov <niki@x3me.net>
     Oskar Pearson <oskar@is.co.za>
+    Paul Z <paulz42@gmail.com>
     Pawel Worach <pawel.worach@gmail.com>
     Pedro Lineu Orso <orso@pop.hsbcbamerindus.com.br>
     Pedro Ribeiro <pribeiro@isel.pt>
@@ -153,47 +190,72 @@ and ideas to make this software available.
     Philip Allison <philip.allison@smoothwall.net>
     Philippe Lantin <plantin@cobaltgroup.com>
     Pierangelo Masarati <ando@sys-net.it>
+    Pierre-Louis BRENAC <brenacp@esiee.fr>
     Pierre-Louis Brenac <brenacp@esiee.fr>
+    Priyanka Gupta <priyanka@icelero.com>
     Przemek Czerkas <pczerkas@mgmnet.pl>
     Rafael Martinez Torres <rmartine@fdi.ucm.es>
     Rafal Ramocki <maniac@sistbg.net>
+    Rajiv Desai <rajiv@maginatics.com>
     Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
     Ralph Loader <loader@maths.ox.ac.uk>
     Regardt van de Vyver <squid@vdvyver.net>
     Reinhard Sojka <reinhard.sojka@parlament.gv.at>
     Rene Geile <rene.geile@t-online.de>
     Reuben Farrelly <reuben@reub.net>
     Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>
+    Richard Wall <richard.wall@appliansys.com>
     Robert Collins <robertc@robertcollins.net>
     Robert Forster
+    Rodrigo Campos (rodrigo@geekbunker.org)
     Rodrigo Campos <rodrigo@geekbunker.org>
     Ron Gomes <rrg@ny.ubs.com>
     Russell Street <r.street@auckland.ac.nz>
     Russell Vincent <vincent@ucthpx.uct.ac.za>
     Ryan Troll <ryan+@andrew.cmu.edu>
     Scott Schram <scott@schram.net>
+    Sebastien Wenske <sebastien@wenske.fr>
     Sergio Rabellino <rabellino@di.unito.it>
     Shigechika Aikawa <shige@luck.imasy.or.jp>
+    Silamael <Silamael@coronamundi.de>
     Stefan Fritsch <sf@sfritsch.de>
+    Stefano Cordibella <stefano.cordibella@edalab.it>
     Stephen R. van den Berg <srb@cuci.nl>
     Steve Bennett <S.Bennett@lancaster.ac.uk>
+    Steve Hill <steve@opendium.com>
     Steve Snyder <swsnyder@snydernet.net>
     Steven Wilton <swilton@q-net.net.au>
     Stewart Forster <slf@connect.com.au>
+    Stuart Henderson <sthen@openbsd.org>
+    Susant Sahani <ssahani@redhat.com>
     Svenx <svensven@gmail.com>
     Taavi Talvik <taavi@uninet.ee>
     Taketo Kabe <kabe@shiratori.riec.tohoku.ac.jp>
+    Thomas De Schampheleire <thomas.de.schampheleire@gmail.com>
+    Thomas Hozza <thozza@redhat.com>
     Thomas Ristic <thr@bootet.net>
+    Thomas Weber <x@4t2.com>
     Thomas-Martin Seck <tmseck@netcologne.de>
+    Tianyin Xu <tixu@cs.ucsd.edu>
     Tim Starling <tstarling@wikimedia.org>
+    Tomas Hozza <thozza@redhat.com>
     Tony Lorimer <tlorimer@au.mdis.com>
     Unknown - NetBSD Project
+    Unknown FreeBSD Contributor
     Vincent Regnard
+    Vitaliy Matytsyn (main) <vm@if.bank.gov.ua>
     Vitaliy Matytsyn <vm@if.bank.gov.ua>
     Wesha <wesha@iname.com>
+    Will Roberts <squid@bigwillystyle42.com>
     Wojtek Sylwestrzak <W.Sylwestrzak@icm.edu.pl>
+    Wolfgang Breyha <wbreyha@gmx.net>
     Wolfgang Nothdurft <wolfgang@linogate.de>
+    Zhanpeng Chen <lowstz@gmail.com>
     benno@jeamland.net
     fancyrabbit <fancyrabbit@gmail.com>
+    folkert <folkert@vanheusden.com>
+    hno
+    kinkie@squid-cache.org
+    libit <sambabug.lb@gmail.com>
+    rousskov
     vollkommen <vollkommen@gmx.net>
-    Benjamin Kerensa <bkerensa@ubuntu.com>
@@ -1,6 +1,13 @@
+Changes to squid-3.4.5 (02 May 2014):
+
+	- Regression Bug 4051: inverted test on CONNECT payload existence
+	- Regression Fix: order dependency between cache_dir and maximum_object_size
+	- Fix logformat %note display
+	- Resolve 'dying from an unhandled exception: c'
+
 Changes to squid-3.4.4.2 (23 Apr 2014):
 
-	- versino bump for packaging re-build with altered toolchain
+	- version bump for packaging re-build with altered toolchain
 
 Changes to squid-3.4.4.1 (23 Apr 2014):
 
@@ -3510,6 +3510,7 @@ AC_CONFIG_FILES([
 	helpers/negotiate_auth/wrapper/Makefile
 	helpers/external_acl/Makefile
 	helpers/external_acl/AD_group/Makefile
+	helpers/external_acl/delayer/Makefile
 	helpers/external_acl/eDirectory_userip/Makefile
 	helpers/external_acl/file_userip/Makefile
 	helpers/external_acl/kerberos_ldap_group/Makefile
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.4.2 release notes</title>
+<title>Squid 3.4.5 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.4.2 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.5 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -40,6 +40,9 @@ The 3.5 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 <itemize>
 	<item>Support libecap v1.0
 	<item>Authentication helper query extensions
+	<item>Support named services
+	<item>Upgraded squidclient tool
+	<item>Helper support for concurrency channels
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -71,6 +74,95 @@ Most user-facing changes are reflected in squid.conf (see below).
   will send any meaningful detail.
 
 
+<sect1>Support named services
+<p>Details at <url url="http://wiki.squid-cache.org/MultipleInstances">.
+<p>Terminology details at <url url="http://wiki.squid-cache.org/Features/SmpScale#Terminology">.
+
+<p>The command line option <em>-n</em> assigns a name to the Squid service
+   instance to be used as a unique identifier for all SMP processes run as
+   part of that instance. This allows multiple instances of Squid service to
+   be run on a single machine without background SMP systems such as shared
+   memory and inter-process communication becoming confused or requiring
+   additional configuration.
+
+<p>A service name is always used. When the <em>-n</em> option is missing
+   from the command line the default service name is <em>squid</em>.
+
+<p>When multiple instances are being run the <em>-n</em> service name is
+   required to target all other options such as <em>-z</em> or <em>-k</em>
+   commands at the correct service.
+
+<p>The squid.conf macro ${service_name} is added to provide the service name
+   of the process parsing the config.
+
+
+<sect1>Upgraded squidclient tool
+<p>The <em>squidclient</em> has begun the process of upgrading to support
+   protocols other than HTTP.
+
+<sect2>Debug levels
+<p>The tool displays the server response message on STDOUT unless the <em>-q</em>
+   command line option is used. Error messages will be output to STDERR.
+   All other possible output is considered debug and output to STDERR using
+   a range of debug verbosity levels (currently 1, 2 and 3).
+
+<p>When the <em>-v</em> command line option is used debugging is enabled.
+   The level of debug display is raised for each repetition of the option.
+
+<sect2>PING
+<p>When <em>--ping</em> is given the tool will send its message repeatedly
+   using whichever protocol that message has been formatted for.
+   Optional parameters to limit the number of pings and their frequency are
+   available.
+
+<p>Older tool versions also provide this feature but require the loop count
+   parameter to be set to enable use of the feature.
+
+<sect2>HTTPS
+<p>When Squid is built with the GnuTLS encryption library the tool is able
+   to open TLS (or SSL/3.0) connections to servers.
+
+<p>The <em>--https</em> option enables TLS using default values.
+
+<p>The <em>--cert</em> option specifies a file containing X.509 client
+   certificate and private key in PEM format to be loaded for use. Multiple
+   certificates are supported and the option may be used multiple times to
+   load certificates.
+   The default is not to use a client certificate.
+
+<p>The <em>--params</em> option specifies a library specific set of parameters
+   to be sent to the library for configuring the security context.
+   See <url url="http://gnutls.org/manual/html_node/Priority-Strings.html"> for
+   available GnuTLS parameters.
+
+<p>The <em>--trusted-ca</em> option specifies a file in PEM format containing
+   one or more Certificate Authority (CA) certificates used to verify the
+   remote server. This option may be used multiple times to load additional
+   CA certificate lists.
+   The default is not to use any CA, nor trust any server.
+
+<p>Anonymous TLS (using non-authenticated Diffi-Hellman or Elliptic Curve
+   encryption) is available with the <em>--anonymous-tls</em> option.
+   The default is to use X.509 certificate encryption instead.
+
+<p>When performing TLS/SSL server certificates are always verified, the
+   results shown at debug level 3. The encrypted type is displayed at debug
+   level 2 and the connection is used to send and receive the messages
+   regardless of verification results.
+
+
+<sect1>Helper support for concurrency channels
+<p>Helper concurrency greatly reduces the communication lag between Squid
+   and its helpers allowing faster transaction speeds even on sequential
+   helpers.
+
+<p>The Digest authentication, Store-ID, and URL-rewrite helpers packaged
+   with Squid have been updated to support concurrency channels. They will
+   auto-detect the <em>channel-ID</em> field and will produce the appropriate
+   response format.
+   With these helpers concurrency may now be set to 0 or any higher number as desired.
+
+
 <sect>Changes to squid.conf since Squid-3.4
 <p>
 There have been changes to Squid's configuration file since Squid-3.4.
@@ -81,6 +173,9 @@ There have been changes to Squid's configuration file since Squid-3.4.
     acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
 </verb>
 
+<p>The squid.conf macro ${service_name} is added to provide the service name
+   of the process parsing the config.
+
 <p>There have also been changes to individual directives in the config file.
 
 This section gives a thorough account of those changes in three categories:
@@ -104,10 +199,35 @@ This section gives a thorough account of those changes in three categories:
 	   based on ACL selection. ACL can be based on client request or cached
 	   response details.
 
+	<tag>sslproxy_session_cache_size</tag>
+	<p>New directive which sets the cache size to use for TLS/SSL sessions cache.
+
+	<tag>sslproxy_session_ttl</tag>
+	<p>New directive to specify the time in seconds the TLS/SSL session is valid.
+
+	<tag>store_id_extras</tag>
+	<p>New directive to send additional lookup parameters to the configured
+	   Store-ID helper program. It takes a string which may contain logformat %macros.
+	<p>The Store-ID helper input format is now:
+	<verb>
+         [channel-ID] url [extras]
+	</verb>
+	<p>The default value for extras is: "%&gt;a/%>A %un %>rm myip=%la myport=%lp"
+
 	<tag>store_miss</tag>
 	<p>New configuration directive to enable/disable caching of MISS responses.
 	   ACL can be based on any request or response details.
 
+	<tag>url_rewrite_extras</tag>
+	<p>New directive to send additional lookup parameters to the configured
+	   URL-rewriter/redirector helper program. It takes a string which may
+	   contain logformat %macros.
+	<p>The url rewrite and redirector helper input format is now:
+	<verb>
+         [channel-ID] url [extras]
+	</verb>
+	<p>The default value for extras is: "%>a/%>A %un %>rm myip=%la myport=%lp"
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -123,15 +243,44 @@ This section gives a thorough account of those changes in three categories:
 	<p>New parameter <em>key_extras</em> to send additional parameters to
 	   the authentication helper.
 
+	<tag>cache_dir</tag>
+	<p>New support for larger than 32KB objects in both <em>rock</em> type
+	   cache and shared memory cache.
+	<p>New <em>slot-size=N</em> option for rock cache to specify the database
+	   slot/page size when small slot sizes are desired. The default and
+	   maximum slot size is 32KB.
+	<p>Removal of old rock cache dir followed by <em>squid -z</em> is required
+	   when upgrading from earlier versions of Squid.
+
+	<tag>cache_peer</tag>
+	<p>New <em>standby=N</em> option to retain a set of N open and unused
+	   connections to the peer at virtually all times to reduce TCP handshake
+	   delays.
+	<p>These connections differ from HTTP persistent connections in that they
+	   have not been used for HTTP messaging (and may never be). They may be
+	   turned into persistent connections after their first use subject to the
+	   same keep-alive critera any HTTP connection is checked for.
+
 	<tag>forward_max_tries</tag>
-	<p>Default value increased to <em>25 destinations/em> to allow better
+	<p>Default value increased to <em>25 destinations</em> to allow better
 	   contact and IPv4 failover with domains using long lists of IPv6
 	   addresses.
 
+	<tag>ftp_epsv</tag>
+	<p>Converted into an Access List with allow/deny value driven by ACLs
+	   using Squid standard first line wins matching basis.
+	<p>The old values of <em>on</em> and <em>off</em> imply <em>allow all</em>
+	    and <em>deny all</em> respectively and are now deprecated.
+	   Do not combine use of on/off values with ACL configuration.
+
 	<tag>http_port</tag>
 	<p><em>protocol=</em> option altered to accept protocol version details.
 	   Currently supported values are: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1
 
+	<tag>https_port</tag>
+	<p><em>protocol=</em> option altered to accept protocol version details.
+	   Currently supported values are: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1
+
 	<tag>logformat</tag>
 	<p>New format code <em>%credentials</em> to log the client credentials
 	   token.
@@ -146,13 +295,19 @@ This section gives a thorough account of those changes in three categories:
 <p>
 <descrip>
 	<tag>cache_dir</tag>
-	<p><em>COSS</em> storage type is formally replaced by Rosk storage type.
+	<p><em>COSS</em> storage type is formally replaced by Rock storage type.
 
 	<tag>cache_dns_program</tag>
 	<p>DNS external helper interface has been removed. It was no longer
 	   able to provide high performance service and the internal DNS
 	   client library with multicast DNS cover all modern use-cases.
 
+	<tag>cache_peer</tag>
+	<p><em>idle=</em> replaced by <em>standby=</em>.
+	<p>NOTE that standby connections are started earlier and available in
+	   more circumstances than squid-2 idle connections were. They are
+	   also spread over all IPs of the peer.
+
 	<tag>dns_children</tag>
 	<p>DNS external helper interface has been removed.
 
@@ -177,6 +332,11 @@ This section gives an account of those changes in three categories:
 <descrip>
 	<p><em>There are no new ./configure options in Squid-3.5.</em>
 
+	<tag>--without-gnutls</tag>
+	<p>New option to explicitly disable use of GnuTLS encryption library.
+	   Use of this library is auto-enabled if v3.1.5 or later is available.
+	<p>It is currently only used by the squidclient tool.
+
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
@@ -198,6 +358,10 @@ This section gives an account of those changes in three categories:
 	<tag>--enable-ssl</tag>
 	<p>Removed. Use <em>--with-openssl</em> to enable OpenSSL library support.
 
+	<tag>--with-coss-membuf-size</tag>
+	<p>The COSS cache type has been removed.
+	   It has been replaced by <em>rock</em> cache type.
+
 </descrip>
 
 
@@ -214,7 +378,6 @@ This section gives an account of those changes in three categories:
 	<p>Not yet ported from 2.6
 
 	<tag>cache_peer</tag>
-	<p><em>idle=</em> not yet ported from 2.7
 	<p><em>monitorinterval=</em> not yet ported from 2.6
 	<p><em>monitorsize=</em> not yet ported from 2.6
 	<p><em>monitortimeout=</em> not yet ported from 2.6
@@ -20,6 +20,7 @@ TRANSLATE_LANGUAGES= \
     id.lang \
     it.lang \
     ja.lang \
+    ka.lang \
     ko.lang \
     lt.lang \
     lv.lang \
@@ -73,7 +73,8 @@ main(int argc, char **argv)
             /* Password incorrect */
             printf("ERR Wrong password\n");
 #else
-        } else {
+        }
+        else {
             /* Password incorrect */
             printf("BH message=\"Missing crypto capability\"\n");
 #endif
@@ -32,6 +32,7 @@
 #include "util.h"
 
 typedef struct _request_data {
+    int channelId;
     char *user;
     char *realm;
     char *password;
@@ -49,6 +49,14 @@ ParseBuffer(char *buf, RequestData * requestData)
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
         *p = '\0';		/* strip \n */
+
+    p = NULL;
+    requestData->channelId = strtoll(buf, &p, 10);
+    if (*p != ' ') // not a channel-ID
+        requestData->channelId = -1;
+    else
+        buf = ++p;
+
     if ((requestData->user = strtok(buf, "\"")) == NULL)
         return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
@@ -63,6 +71,8 @@ OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
+    if (requestData->channelId >= 0)
+        printf("%u ", requestData->channelId);
     if (requestData->error) {
         SEND_ERR("message=\"No such user\"");
         return;
@@ -76,6 +86,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
+        if (requestData.channelId >= 0)
+            printf("%u ", requestData.channelId);
         SEND_BH("message=\"Invalid line received\"");
         return;
     }
@@ -35,6 +35,7 @@
 #include "util.h"
 
 typedef struct _request_data {
+    int channelId;
     char *user;
     char *realm;
     char *password;
@@ -49,6 +49,14 @@ ParseBuffer(char *buf, RequestData * requestData)
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
         *p = '\0';		/* strip \n */
+
+    p = NULL;
+    requestData->channelId = strtoll(buf, &p, 10);
+    if (*p != ' ') // not a channel-ID
+        requestData->channelId = -1;
+    else
+        buf = ++p;
+
     if ((requestData->user = strtok(buf, "\"")) == NULL)
         return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
@@ -63,6 +71,8 @@ OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
+    if (requestData->channelId >= 0)
+        printf("%u ", requestData->channelId);
     if (requestData->error) {
         SEND_ERR("message=\"No such user\"");
         return;
@@ -76,6 +86,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
+        if (requestData.channelId >= 0)
+            printf("%u ", requestData.channelId);
         SEND_BH("message=\"Invalid line received\"");
         return;
     }
@@ -27,6 +27,7 @@
 #endif
 
 typedef struct _request_data {
+    int channelId;
     char *user;
     char *realm;
     char *password;
@@ -5,7 +5,7 @@
 .if !'po4a'hide' \-
 File based digest authentication helper for Squid.
 .PP
-Version 1.0
+Version 1.1
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B digest_file_auth
@@ -17,6 +17,9 @@ file
 is an installed binary authentication program for Squid. It handles digest 
 authentication protocol and authenticates against a text file backend.
 .
+This program will automatically detect the existence of a concurrecy channel-ID and adjust appropriately.
+It may be used with any value 0 or above for the auth_param children concurrency= parameter.
+.
 .SH OPTIONS
 .if !'po4a'hide' .TP 12
 .if !'po4a'hide' .B \-c
@@ -51,6 +51,14 @@ ParseBuffer(char *buf, RequestData * requestData)
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
         *p = '\0';		/* strip \n */
+
+    p = NULL;
+    requestData->channelId = strtoll(buf, &p, 10);
+    if (*p != ' ') // not a channel-ID
+        requestData->channelId = -1;
+    else
+        buf = ++p;
+
     if ((requestData->user = strtok(buf, "\"")) == NULL)
         return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
@@ -65,6 +73,8 @@ OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
+    if (requestData->channelId >= 0)
+        printf("%u ", requestData->channelId);
     if (requestData->error) {
         SEND_ERR("message=\"No such user\"");
         return;
@@ -78,6 +88,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
+        if (requestData.channelId >= 0)
+            printf("%u ", requestData.channelId);
         SEND_BH("message=\"Invalid line received\"");
         return;
     }
@@ -1,5 +1,6 @@
 DIST_SUBDIRS= \
 	AD_group \
+	delayer \
 	eDirectory_userip \
 	file_userip \
 	kerberos_ldap_group \
@@ -0,0 +1,12 @@
+include $(top_srcdir)/src/Common.am
+
+libexec_SCRIPTS = ext_delayer_acl
+CLEANFILES += ext_delayer_acl ext_delayer_acl.8
+man_MANS = ext_delayer_acl.8
+EXTRA_DIST = ext_delayer_acl.pl.in ext_delayer_acl.8 required.m4
+
+ext_delayer_acl.8: ext_delayer_acl
+	pod2man ext_delayer_acl ext_delayer_acl.8
+
+ext_delayer_acl: ext_delayer_acl.pl.in
+	$(subst_perlshell)
@@ -0,0 +1,257 @@
+#!@PERL@
+=pod
+
+=head1 NAME
+
+delayer - Squid external acl helper adding artificial delay to requests
+
+=head1 SYNOPSIS
+
+delayer [--help] [--debug] [--log file] [--wait msec]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<--help> or B<-h>
+
+Print help message to stdout
+
+=item B<--debug> or B<-d>
+
+Emit debugging output to STDERR and ultimately cache.log
+
+=item B<--log /path/to/file> or B<-l /path/to/file>
+
+Emit debugging output to specified file instead of STDERR. Also turns on debugging
+
+=item B<--wait msec> or B<-w msec>
+
+Delay each request by the specified amount of msec.
+Unless this option is specified, by default each submitted request
+will be delayed by half a second (500 msec).
+
+=back
+
+=head1 DESCRIPTION
+
+Squid external acl helper; causes squid to delay responding to HTTP requests.
+
+By carefully crafting the ACLs of a Squid setup it is possible to
+selectively delay requests received by a proxy. After the configured amount
+of time, it will always return "true".
+
+=head1 CONFIGURATION
+
+To engage it, this snippet of configuration template can be used in squid.conf:
+
+ external_acl_type delayer concurrency=100000 children-max=2 children-startup=1 children-idle=1 cache=10 %URI /path/to/delayer -w 200
+ acl delay external delayer
+ http_access allow acl1 acl2 acl3 delay !all
+
+It is important that the acl referencing the delayer be the penultimate clause in the
+http_access line. It will cause delay to all requests that match all the
+preceding acls in the line. The !all clause at the end of the line will make it
+so that no traffic is authorized by this ACL, only the delay to evaluate
+the delay clause will be inserted before evaluating following http_access lines.
+It is also important to place the http_access line carefully in the sequence
+of all http_access_lines; it should be near the beginning, but be careful
+not to insert unwanted slow acls (especially proxy_auth).
+
+It is possible to customize how delay is calculated for each request by
+modifying the "calc_delay" PERL function in the script, documentation on this
+is embedded in the source code comments.
+
+=head1 AUTHOR
+
+This software is written by Francesco Chemolli <kinkie@squid-cache.org>
+
+=head1 COPYRIGHT
+
+(C) 2014 Francesco Chemolli <kinkie@squid-cache.org>
+
+This program is free software. You may redistribute copies of it under the
+terms of the GNU General Public License version 2, or (at your opinion) any
+later version.
+
+=head1 QUESTIONS
+
+Questions on this code are best addressed on the Squid-users mailing list
+<squid-users@squid-cache.org>
+
+=head1 REPORTING BUGS
+
+Bug reports need to be made in English.
+See http://wiki.squid-cache.org/SquidFaq/BugReporting for details of what you
+need to include with your bug report.
+Report bugs or bug fixes using http://bugs.squid-cache.org/
+
+=head1 SEE ALSO
+
+B<squid>(8), B<GPL>(7), B<Squid Wiki> http://wiki.squid-cache.org/ ,
+B<Squid Configuration Manual> http://www.squid-cache.org/Doc/config/
+
+=cut
+
+use strict;
+use warnings;
+use Getopt::Long qw(:config auto_version auto_help);
+use Data::Dumper;
+use Time::HiRes qw(gettimeofday tv_interval);
+
+# options handling
+my %opts = (); #for getopt
+my $debug = 0; #debug
+my $logfile = *STDERR; #filehandle to logfile
+my $logfilename;
+my $delay = 500; #in milliseconds. Configurable with the -w option.
+#for custom delay algorithms, you can customize the dispatch_request function
+
+#calculate the delay for the request.
+# Gets as input the verbatim full line received from squid
+# (channel number and all, as configured in squid.conf) and returns
+# a floating point number >= 0 which is the delay to be applied to the request
+# in seconds.
+# Notice that in order to have efficient data structures, the delay is
+# assumed to be monotonously growing. In other words, a long-delay
+# item will stall the queue until completed. Supporting generic delays
+# requires transforming @queue from a FIFO to a priority queue.
+sub calc_delay {
+  return $delay;
+}
+
+GetOptions("debug|d" => \$debug,
+           "wait|w=i" => \$delay,
+           "log|l=s" => \$logfilename)
+or die("Error in parsing command line arguments");
+if (defined $opts{h}) {
+  HELP_MESSAGE();
+  exit 0;
+}
+$delay /= 1000.0; # transform msec into sec
+if ($logfilename) {
+  open ($logfile,">>", "$opts{l}");
+  $debug=1;
+} 
+
+my @p=split(/[\\\/]/,$0);
+my $prg_basename=pop @p;
+$prg_basename .= "[$$]";
+undef @p;
+my $reqid=0; #sequence number for requests
+
+# variables initialization for select
+my $rvec = '';
+vec($rvec,0,1) = 1; #stdin
+my ($nfound, $rd, $nread, $req);
+
+#requests queue
+my @queue = (); # array of references to hashes, with keys chan, when, req, reqid
+
+# signal handlers
+$SIG{HUP} = \&dump_state;
+
+#disable IO buffering
+$| = 1;
+my $fh=select($logfile); $|=1; select($fh); undef($fh);
+
+# takes a result from a gettimeofday call and turns it into a
+# floating-point number suitable for approximate time calculations and select
+sub fract_time {
+  return $_[0]+$_[1]/1000000;
+}
+
+sub dispatch_request {
+  my $r = $_[0];
+  chomp $r;
+  &debug("got request: '$r'");
+  my %evt = ();
+  my @fields;
+  @fields = split (/\s+/, $r);
+  $evt{when} = &calc_delay($r)+fract_time(gettimeofday());
+  $evt{reqid}=$reqid++;
+  $evt{req} = $r;
+  $evt{chan} = $fields[0];
+  &debug("Dispatching: reqid $evt{reqid}, chan $evt{chan}, when $evt{when}, raw {$evt{req}}");
+  push @queue,\%evt;
+}
+
+sub next_event {
+  my $now = fract_time(gettimeofday());
+  if (@queue) {
+    my $when = $queue[0]->{when} - $now;
+    &debug("Next event is in $when seconds");
+    return $when;
+  }
+  &debug("No events in queue");
+  return undef;
+}
+
+sub handle_events {
+  my $now = fract_time(gettimeofday());
+  while ( @queue ) {
+    &debug("Queue length is $#queue");
+    last if ($queue[0]->{when} > $now);
+    my %evt = %{shift @queue};
+    &debug("Event: reqid $evt{reqid}, chan $evt{chan}, when $evt{when}, raw {$evt{req}}");
+    print $evt{chan} , " OK\n";
+  }
+}
+
+# main loop
+while(1) {
+  &debug("selecting");
+  $nfound = select($rd = $rvec,undef,undef,&next_event());
+  &debug("found $nfound bits set");
+  if ($nfound == -1 ) {
+    next if ($!{ERESTART} || $!{EAGAIN} || $!{EINTR});
+    &debug("error in select: $!");
+    exit 1;
+  }
+  if (vec($rd,0,1)==1) { #got stuff from stdin
+    my $d; #data
+    $nread = sysread(STDIN,$d,40960); # read 40kb
+    # clear the signal-bit, stdin is special
+    vec($rd,0,1) = 0;
+    if ($nread==0) {
+      &debug("nothing read from stdin, exiting");
+      exit 0;
+    }
+    my $i;
+    while ($i = index($d,"\n")) { #BUG: assumption of no spill-over
+      last if ($i == -1);
+      &dispatch_request(substr($d,0,$i));
+      $d=substr($d,$i+1);
+    }
+  }
+  &handle_events();
+}
+
+my $doc = <<_EOF;
+delay-adding external acl helper
+authorizes all requests, adding a delay before doing so.
+supports multiplexed helper protocol.
+Options:
+  -h, --help: this help message
+  -d, --debug: enable debug output
+  -l <file>, --log <file>: log output to named file instead of stderr (implies debug)
+  -w <num>, --wait <num> delay each request by this number milliseconds
+
+AUTHOR: Francesco Chemolli <kinkie\@squid-cache.org>
+Licensed under the terms of the GNU GPL v2 or later (see source for details)
+_EOF
+our $VERSION = "1.0";
+
+sub HELP_MESSAGE {
+  print STDERR $doc;
+}
+
+sub dump_state {
+  $SIG{HUP} = \&dump_state;
+  print STDERR "Queue:\n",Dumper(\@queue),"\n";
+}
+
+sub debug {
+  return unless ($debug);
+  print $logfile $prg_basename , ": ", @_, "\n";
+}
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="delayer"
+fi
@@ -27,6 +27,9 @@ if test "x$enable_external_acl_helpers" != "xno" ; then
       elif test "x$helper" = "xLM_group" ; then
         m4_include([helpers/external_acl/LM_group/required.m4])
 
+      elif test "x$helper" = "xdelayer" ; then
+        m4_include([helpers/external_acl/delayer/required.m4])
+
       elif test "x$helper" = "xSQL_session" ; then
         m4_include([helpers/external_acl/SQL_session/required.m4])
 
@@ -13,7 +13,7 @@ storeid_file_rewrite - File based Store-ID helper for Squid
 
 storeid_file_rewrite filepath
 
-=head1 DESCRIPTOIN
+=head1 DESCRIPTION
 
 This program acts as a store_id helper program, rewriting URLs passed
 by Squid into storage-ids that can be used to achieve better caching
@@ -28,6 +28,9 @@ Eg:
 Rewrite rules are matched in the same order as they appear in the rules file.
 So for best performance, sort it in order of frequency of occurrence.
 
+This program will automatically detect the existence of a concurrecy channel-ID and adjust appropriately.
+It may be used with any value 0 or above for the store_id_children concurrency= parameter.
+
 For more information please see http://wiki.squid-cache.org/Features/StoreID
 
 =cut
@@ -109,9 +109,16 @@ main(int argc, char *argv[])
 
         debug("Got %d bytes '%s' from Squid\n", buflen, buf);
 
-        /* send 'no-change' result back to Squid */
-        fprintf(stdout,"\n");
+        p = NULL;
+        int64_t channelId = strtoll(buf, &p, 10);
+        if (*p != ' ') {
+            /* send 'no-change' result back to Squid in non-concurrent format */
+            fprintf(stdout,"ERR\n");
+        } else {
+            /* send 'no-change' result back to Squid in concurrent format */
+            fprintf(stdout, "%" PRId64 " ERR\n", channelId);
+        }
     }
     debug("%s build " __DATE__ ", " __TIME__ " shutting down...\n", my_program_name);
-    exit(0);
+    return 0;
 }
@@ -30,6 +30,7 @@
  */
 
 #include "acl/forward.h"
+#include "base/CbcPointer.h"
 #include "enums.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
@@ -43,7 +44,9 @@
 
 class CachePeerDomainList;
 class NeighborTypeDomainList;
+class PconnPool;
 class PeerDigest;
+class PeerPoolMgr;
 
 // currently a POD
 class CachePeer
@@ -186,6 +189,12 @@ class CachePeer
     time_t connect_timeout;
     int connect_fail_limit;
     int max_conn;
+    struct {
+        PconnPool *pool; ///< idle connection pool for this peer
+        CbcPointer<PeerPoolMgr> mgr; ///< pool manager
+        int limit; ///< the limit itself
+        bool waitingForClose; ///< a conn must close before we open a standby conn
+    } standby; ///< optional "cache_peer standby=limit" feature
     char *domain;       /* Forced domain */
 #if USE_OPENSSL
 
@@ -106,20 +106,20 @@ int aioQueueSize(void);
 class DiskThreadsIOStrategy;
 
 struct AIOCounts {
-    int open_start;
-    int open_finish;
-    int close_start;
-    int close_finish;
-    int cancel;
-    int write_start;
-    int write_finish;
-    int read_start;
-    int read_finish;
-    int stat_start;
-    int stat_finish;
-    int unlink_start;
-    int unlink_finish;
-    int check_callback;
+    uint64_t open_start;
+    uint64_t open_finish;
+    uint64_t close_start;
+    uint64_t close_finish;
+    uint64_t cancel;
+    uint64_t write_start;
+    uint64_t write_finish;
+    uint64_t read_start;
+    uint64_t read_finish;
+    uint64_t stat_start;
+    uint64_t stat_finish;
+    uint64_t unlink_start;
+    uint64_t unlink_finish;
+    uint64_t check_callback;
 };
 
 extern AIOCounts squidaio_counts;
@@ -196,16 +196,16 @@ void
 DiskThreadsIOStrategy::aioStats(StoreEntry * sentry)
 {
     storeAppendPrintf(sentry, "ASYNC IO Counters:\n");
-    storeAppendPrintf(sentry, "Operation\t# Requests\tNumber serviced\n");
-    storeAppendPrintf(sentry, "open\t%d\t%d\n", squidaio_counts.open_start, squidaio_counts.open_finish);
-    storeAppendPrintf(sentry, "close\t%d\t%d\n", squidaio_counts.close_start, squidaio_counts.close_finish);
-    storeAppendPrintf(sentry, "cancel\t%d\t-\n", squidaio_counts.cancel);
-    storeAppendPrintf(sentry, "write\t%d\t%d\n", squidaio_counts.write_start, squidaio_counts.write_finish);
-    storeAppendPrintf(sentry, "read\t%d\t%d\n", squidaio_counts.read_start, squidaio_counts.read_finish);
-    storeAppendPrintf(sentry, "stat\t%d\t%d\n", squidaio_counts.stat_start, squidaio_counts.stat_finish);
-    storeAppendPrintf(sentry, "unlink\t%d\t%d\n", squidaio_counts.unlink_start, squidaio_counts.unlink_finish);
-    storeAppendPrintf(sentry, "check_callback\t%d\t-\n", squidaio_counts.check_callback);
-    storeAppendPrintf(sentry, "queue\t%d\t-\n", squidaio_get_queue_len());
+    storeAppendPrintf(sentry, "  Operation\t# Requests\tNumber serviced\n");
+    storeAppendPrintf(sentry, "  open\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.open_start, squidaio_counts.open_finish);
+    storeAppendPrintf(sentry, "  close\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.close_start, squidaio_counts.close_finish);
+    storeAppendPrintf(sentry, "  cancel\t%" PRIu64 "\t-\n", squidaio_counts.cancel);
+    storeAppendPrintf(sentry, "  write\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.write_start, squidaio_counts.write_finish);
+    storeAppendPrintf(sentry, "  read\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.read_start, squidaio_counts.read_finish);
+    storeAppendPrintf(sentry, "  stat\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.stat_start, squidaio_counts.stat_finish);
+    storeAppendPrintf(sentry, "  unlink\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.unlink_start, squidaio_counts.unlink_finish);
+    storeAppendPrintf(sentry, "  check_callback\t%" PRIu64 "\t-\n", squidaio_counts.check_callback);
+    storeAppendPrintf(sentry, "  queue\t%d\t-\n", squidaio_get_queue_len());
     squidaio_stats(sentry);
 }
 
@@ -64,6 +64,7 @@
 #include "mgr/Registration.h"
 #include "neighbors.h"
 #include "pconn.h"
+#include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
@@ -93,7 +94,7 @@ static OBJH fwdStats;
 #define MAX_FWD_STATS_IDX 9
 static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][Http::scInvalidHeader + 1];
 
-static PconnPool *fwdPconnPool = new PconnPool("server-side");
+static PconnPool *fwdPconnPool = new PconnPool("server-side", NULL);
 CBDATA_CLASS_INIT(FwdState);
 
 #if USE_OPENSSL
@@ -103,13 +104,14 @@ class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::Cb
     typedef void (FwdState::*Method)(Ssl::PeerConnectorAnswer &);
 
     FwdStatePeerAnswerDialer(Method method, FwdState *fwd):
-        method_(method), fwd_(fwd), answer_() {}
+            method_(method), fwd_(fwd), answer_() {}
 
     /* CallDialer API */
     virtual bool canDial(AsyncCall &call) { return fwd_.valid(); }
     void dial(AsyncCall &call) { ((&(*fwd_))->*method_)(answer_); }
     virtual void print(std::ostream &os) const {
-        os << '(' << fwd_.get() << ", " << answer_ << ')'; }
+        os << '(' << fwd_.get() << ", " << answer_ << ')';
+    }
 
     /* Ssl::PeerConnector::CbDialer API */
     virtual Ssl::PeerConnectorAnswer &answer() { return answer_; }
@@ -121,25 +123,30 @@ class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::Cb
 };
 #endif
 
-
 void
 FwdState::abort(void* d)
 {
     FwdState* fwd = (FwdState*)d;
     Pointer tmp = fwd; // Grab a temporary pointer to keep the object alive during our scope.
 
     if (Comm::IsConnOpen(fwd->serverConnection())) {
-        comm_remove_close_handler(fwd->serverConnection()->fd, fwdServerClosedWrapper, fwd);
-        debugs(17, 3, HERE << "store entry aborted; closing " <<
-               fwd->serverConnection());
-        fwd->serverConnection()->close();
+        fwd->closeServerConnection("store entry aborted");
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
     fwd->serverDestinations.clear();
     fwd->self = NULL;
 }
 
+void
+FwdState::closeServerConnection(const char *reason)
+{
+    debugs(17, 3, "because " << reason << "; " << serverConn);
+    comm_remove_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
+    fwdPconnPool->noteUses(fd_table[serverConn->fd].pconn.uses);
+    serverConn->close();
+}
+
 /**** PUBLIC INTERFACE ********************************************************/
 
 FwdState::FwdState(const Comm::ConnectionPointer &client, StoreEntry * e, HttpRequest * r, const AccessLogEntryPointer &alp):
@@ -295,11 +302,8 @@ FwdState::~FwdState()
         calls.connector = NULL;
     }
 
-    if (Comm::IsConnOpen(serverConn)) {
-        comm_remove_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
-        debugs(17, 3, HERE << "closing FD " << serverConnection()->fd);
-        serverConn->close();
-    }
+    if (Comm::IsConnOpen(serverConn))
+        closeServerConnection("~FwdState");
 
     serverDestinations.clear();
 
@@ -615,7 +619,11 @@ FwdState::checkRetriable()
 void
 FwdState::serverClosed(int fd)
 {
-    debugs(17, 2, HERE << "FD " << fd << " " << entry->url());
+    // XXX: fd is often -1 here
+    debugs(17, 2, "FD " << fd << " " << entry->url() << " after " <<
+           (fd >= 0 ? fd_table[fd].pconn.uses : -1) << " requests");
+    if (fd >= 0 && serverConnection()->fd == fd)
+        fwdPconnPool->noteUses(fd_table[fd].pconn.uses);
     retryOrBail();
 }
 
@@ -700,8 +708,8 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
 
             HttpRequest::Pointer requestPointer = request;
             AsyncCall::Pointer callback = asyncCall(17,4,
-                "FwdState::ConnectedToPeer",
-                FwdStatePeerAnswerDialer(&FwdState::connectedToPeer, this));
+                                                    "FwdState::ConnectedToPeer",
+                                                    FwdStatePeerAnswerDialer(&FwdState::connectedToPeer, this));
             Ssl::PeerConnector *connector =
                 new Ssl::PeerConnector(requestPointer, serverConnection(), clientConn, callback);
             AsyncJob::Start(connector); // will call our callback
@@ -833,7 +841,7 @@ FwdState::connectStart()
     // This does not increase the total number of connections because we just
     // closed the connection that failed the race. And re-pinning assumes this.
     if (pconnRace != raceHappened)
-        temp = fwdPconnPool->pop(serverDestinations[0], host, checkRetriable());
+        temp = pconnPop(serverDestinations[0], host);
 
     const bool openedPconn = Comm::IsConnOpen(temp);
     pconnRace = openedPconn ? racePossible : raceImpossible;
@@ -895,7 +903,7 @@ FwdState::dispatch()
 
     fd_note(serverConnection()->fd, entry->url());
 
-    fd_table[serverConnection()->fd].noteUse(fwdPconnPool);
+    fd_table[serverConnection()->fd].noteUse();
 
     /*assert(!EBIT_TEST(entry->flags, ENTRY_DISPATCHED)); */
     assert(entry->ping_status != PING_WAITING);
@@ -1128,6 +1136,22 @@ FwdState::pconnPush(Comm::ConnectionPointer &conn, const char *domain)
     }
 }
 
+Comm::ConnectionPointer
+FwdState::pconnPop(const Comm::ConnectionPointer &dest, const char *domain)
+{
+    // always call shared pool first because we need to close an idle
+    // connection there if we have to use a standby connection.
+    Comm::ConnectionPointer conn = fwdPconnPool->pop(dest, domain, checkRetriable());
+    if (!Comm::IsConnOpen(conn)) {
+        // either there was no pconn to pop or this is not a retriable xaction
+        if (CachePeer *peer = dest->getPeer()) {
+            if (peer->standby.pool)
+                conn = peer->standby.pool->pop(dest, domain, true);
+        }
+    }
+    return conn; // open, closed, or nil
+}
+
 void
 FwdState::initModule()
 {
@@ -16,6 +16,8 @@
 
 class AccessLogEntry;
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
+class PconnPool;
+typedef RefCount<PconnPool> PconnPoolPointer;
 class ErrorState;
 class HttpRequest;
 
@@ -76,6 +78,9 @@ class FwdState : public RefCountable
     bool checkRetry();
     bool checkRetriable();
     void dispatch();
+    /// Pops a connection from connection pool if available. If not
+    /// checks the peer stand-by connection pool for available connection.
+    Comm::ConnectionPointer pconnPop(const Comm::ConnectionPointer &dest, const char *domain);
     void pconnPush(Comm::ConnectionPointer & conn, const char *domain);
 
     bool dontRetry() { return flags.dont_retry; }
@@ -103,6 +108,9 @@ class FwdState : public RefCountable
 #endif
     static void RegisterWithCacheManager(void);
 
+    /// stops monitoring server connection for closure and updates pconn stats
+    void closeServerConnection(const char *reason);
+
 public:
     StoreEntry *entry;
     HttpRequest *request;
@@ -472,6 +472,8 @@ squid_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	PeerSelectState.h \
 	PingData.h \
 	protos.h \
@@ -1518,6 +1520,8 @@ tests_testCacheManager_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
@@ -1744,6 +1748,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_stat.cc \
@@ -1899,6 +1904,8 @@ tests_testEvent_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2147,6 +2154,8 @@ tests_testEventLoop_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2391,6 +2400,8 @@ tests_test_http_range_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2731,6 +2742,8 @@ tests_testHttpRequest_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	redirect.h \
 	tests/stub_libauth_acls.cc \
 	tests/stub_redirect.cc \
@@ -3081,6 +3094,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_libeui.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
@@ -3373,6 +3387,7 @@ tests_testRock_SOURCES = \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_Port.cc \
 	tests/stub_pconn.cc \
 	tests/stub_store_client.cc \
@@ -3513,6 +3528,8 @@ tests_testURL_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -158,15 +158,15 @@ NotePairs::~NotePairs()
 }
 
 const char *
-NotePairs::find(const char *noteKey) const
+NotePairs::find(const char *noteKey, const char *sep) const
 {
     static String value;
     value.clean();
     for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0) {
             if (value.size())
-                value.append(", ");
-            value.append(ConfigParser::QuoteString((*i)->value));
+                value.append(sep);
+            value.append((*i)->value);
         }
     }
     return value.size() ? value.termedBuf() : NULL;
@@ -180,7 +180,7 @@ NotePairs::toString(const char *sep) const
     for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         value.append((*i)->name);
         value.append(": ");
-        value.append(ConfigParser::QuoteString((*i)->value));
+        value.append((*i)->value);
         value.append(sep);
     }
     return value.size() ? value.termedBuf() : NULL;
@@ -145,7 +145,7 @@ class NotePairs: public RefCountable
      * Returns a comma separated list of notes with key 'noteKey'.
      * Use findFirst instead when a unique kv-pair is needed.
      */
-    const char *find(const char *noteKey) const;
+    const char *find(const char *noteKey, const char *sep = ",") const;
 
     /**
      * Returns the first note value for this key or an empty string.
@@ -0,0 +1,284 @@
+#include "squid.h"
+#include "base/AsyncJobCalls.h"
+#include "base/RunnersRegistry.h"
+#include "CachePeer.h"
+#include "comm/Connection.h"
+#include "comm/ConnOpener.h"
+#include "Debug.h"
+#include "fd.h"
+#include "FwdState.h"
+#include "globals.h"
+#include "HttpRequest.h"
+#include "neighbors.h"
+#include "pconn.h"
+#include "PeerPoolMgr.h"
+#include "SquidConfig.h"
+#if USE_OPENSSL
+#include "ssl/PeerConnector.h"
+#endif
+
+CBDATA_CLASS_INIT(PeerPoolMgr);
+
+#if USE_OPENSSL
+/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+class MyAnswerDialer: public UnaryMemFunT<PeerPoolMgr, Ssl::PeerConnectorAnswer, Ssl::PeerConnectorAnswer&>,
+        public Ssl::PeerConnector::CbDialer
+{
+public:
+    MyAnswerDialer(const JobPointer &aJob, Method aMethod):
+            UnaryMemFunT<PeerPoolMgr, Ssl::PeerConnectorAnswer, Ssl::PeerConnectorAnswer&>(aJob, aMethod, Ssl::PeerConnectorAnswer()) {}
+
+    /* Ssl::PeerConnector::CbDialer API */
+    virtual Ssl::PeerConnectorAnswer &answer() { return arg1; }
+};
+#endif
+
+PeerPoolMgr::PeerPoolMgr(CachePeer *aPeer): AsyncJob("PeerPoolMgr"),
+        peer(cbdataReference(aPeer)),
+        request(),
+        opener(),
+        securer(),
+        closer(),
+        addrUsed(0)
+{
+}
+
+PeerPoolMgr::~PeerPoolMgr()
+{
+    cbdataReferenceDone(peer);
+}
+
+void
+PeerPoolMgr::start()
+{
+    AsyncJob::start();
+
+    // ErrorState, getOutgoingAddress(), and other APIs may require a request.
+    // We fake one. TODO: Optionally send this request to peers?
+    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, "*");
+    request->SetHost(peer->host);
+
+    checkpoint("peer initialized");
+}
+
+void
+PeerPoolMgr::swanSong()
+{
+    AsyncJob::swanSong();
+}
+
+bool
+PeerPoolMgr::validPeer() const
+{
+    return peer && cbdataReferenceValid(peer) && peer->standby.pool;
+}
+
+bool
+PeerPoolMgr::doneAll() const
+{
+    return !(validPeer() && peer->standby.limit) && AsyncJob::doneAll();
+}
+
+void
+PeerPoolMgr::handleOpenedConnection(const CommConnectCbParams &params)
+{
+    opener = NULL;
+
+    if (!validPeer()) {
+        debugs(48, 3, "peer gone");
+        if (params.conn != NULL)
+            params.conn->close();
+        return;
+    }
+
+    if (params.flag != COMM_OK) {
+        /* it might have been a timeout with a partially open link */
+        if (params.conn != NULL)
+            params.conn->close();
+        peerConnectFailed(peer);
+        checkpoint("conn opening failure"); // may retry
+        return;
+    }
+
+    Must(params.conn != NULL);
+
+#if USE_OPENSSL
+    // Handle SSL peers.
+    if (peer->use_ssl) {
+        typedef CommCbMemFunT<PeerPoolMgr, CommCloseCbParams> CloserDialer;
+        closer = JobCallback(48, 3, CloserDialer, this,
+                             PeerPoolMgr::handleSecureClosure);
+        comm_add_close_handler(params.conn->fd, closer);
+
+        securer = asyncCall(48, 4, "PeerPoolMgr::handleSecuredPeer",
+                            MyAnswerDialer(this, &PeerPoolMgr::handleSecuredPeer));
+        Ssl::PeerConnector *connector =
+            new Ssl::PeerConnector(request, params.conn, NULL, securer);
+        AsyncJob::Start(connector); // will call our callback
+        return;
+    }
+#endif
+
+    pushNewConnection(params.conn);
+}
+
+void
+PeerPoolMgr::pushNewConnection(const Comm::ConnectionPointer &conn)
+{
+    Must(validPeer());
+    Must(Comm::IsConnOpen(conn));
+    peer->standby.pool->push(conn, NULL /* domain */);
+    // push() will trigger a checkpoint()
+}
+
+#if USE_OPENSSL
+void
+PeerPoolMgr::handleSecuredPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    Must(securer != NULL);
+    securer = NULL;
+
+    if (closer != NULL) {
+        if (answer.conn != NULL)
+            comm_remove_close_handler(answer.conn->fd, closer);
+        else
+            closer->cancel("securing completed");
+        closer = NULL;
+    }
+
+    if (!validPeer()) {
+        debugs(48, 3, "peer gone");
+        if (answer.conn != NULL)
+            answer.conn->close();
+        return;
+    }
+
+    if (answer.error.get()) {
+        if (answer.conn != NULL)
+            answer.conn->close();
+        // PeerConnector calls peerConnectFailed() for us;
+        checkpoint("conn securing failure"); // may retry
+        return;
+    }
+
+    pushNewConnection(answer.conn);
+}
+
+void
+PeerPoolMgr::handleSecureClosure(const CommCloseCbParams &params)
+{
+    Must(closer != NULL);
+    Must(securer != NULL);
+    securer->cancel("conn closed by a 3rd party");
+    securer = NULL;
+    closer = NULL;
+    // allow the closing connection to fully close before we check again
+    Checkpoint(this, "conn closure while securing");
+}
+#endif
+
+void
+PeerPoolMgr::openNewConnection()
+{
+    // KISS: Do nothing else when we are already doing something.
+    if (opener != NULL || securer != NULL || shutting_down) {
+        debugs(48, 7, "busy: " << opener << '|' << securer << '|' << shutting_down);
+        return; // there will be another checkpoint when we are done opening/securing
+    }
+
+    // Do not talk to a peer until it is ready.
+    if (!neighborUp(peer)) // provides debugging
+        return; // there will be another checkpoint when peer is up
+
+    // Do not violate peer limits.
+    if (!peerCanOpenMore(peer)) { // provides debugging
+        peer->standby.waitingForClose = true; // may already be true
+        return; // there will be another checkpoint when a peer conn closes
+    }
+
+    // Do not violate global restrictions.
+    if (fdUsageHigh()) {
+        debugs(48, 7, "overwhelmed");
+        peer->standby.waitingForClose = true; // may already be true
+        // There will be another checkpoint when a peer conn closes OR when
+        // a future pop() fails due to an empty pool. See PconnPool::pop().
+        return;
+    }
+
+    peer->standby.waitingForClose = false;
+
+    Comm::ConnectionPointer conn = new Comm::Connection;
+    Must(peer->n_addresses); // guaranteed by neighborUp() above
+    // cycle through all available IP addresses
+    conn->remote = peer->addresses[addrUsed++ % peer->n_addresses];
+    conn->remote.port(peer->http_port);
+    conn->peerType = STANDBY_POOL; // should be reset by peerSelect()
+    conn->setPeer(peer);
+    getOutgoingAddress(request.getRaw(), conn);
+    GetMarkingsToServer(request.getRaw(), *conn);
+
+    const int ctimeout = peer->connect_timeout > 0 ?
+                         peer->connect_timeout : Config.Timeout.peer_connect;
+    typedef CommCbMemFunT<PeerPoolMgr, CommConnectCbParams> Dialer;
+    opener = JobCallback(48, 5, Dialer, this, PeerPoolMgr::handleOpenedConnection);
+    Comm::ConnOpener *cs = new Comm::ConnOpener(conn, opener, ctimeout);
+    AsyncJob::Start(cs);
+}
+
+void
+PeerPoolMgr::closeOldConnections(const int howMany)
+{
+    debugs(48, 8, howMany);
+    peer->standby.pool->closeN(howMany);
+}
+
+void
+PeerPoolMgr::checkpoint(const char *reason)
+{
+    if (!validPeer()) {
+        debugs(48, 3, reason << " and peer gone");
+        return; // nothing to do after our owner dies; the job will quit
+    }
+
+    const int count = peer->standby.pool->count();
+    const int limit = peer->standby.limit;
+    debugs(48, 7, reason << " with " << count << " ? " << limit);
+
+    if (count < limit)
+        openNewConnection();
+    else if (count > limit)
+        closeOldConnections(count - limit);
+}
+
+void
+PeerPoolMgr::Checkpoint(const Pointer &mgr, const char *reason)
+{
+    CallJobHere1(48, 5, mgr, PeerPoolMgr, checkpoint, reason);
+}
+
+/// launches PeerPoolMgrs for peers configured with standby.limit
+class PeerPoolMgrsRr: public RegisteredRunner
+{
+public:
+    /* RegisteredRunner API */
+    virtual void useConfig() { syncConfig(); }
+    virtual void syncConfig();
+};
+
+RunnerRegistrationEntry(PeerPoolMgrsRr);
+
+void
+PeerPoolMgrsRr::syncConfig()
+{
+    for (CachePeer *p = Config.peers; p; p = p->next) {
+        // On reconfigure, Squid deletes the old config (and old peers in it),
+        // so should always be dealing with a brand new configuration.
+        assert(!p->standby.mgr);
+        assert(!p->standby.pool);
+        if (p->standby.limit) {
+            p->standby.mgr = new PeerPoolMgr(p);
+            p->standby.pool = new PconnPool(p->name, p->standby.mgr);
+            AsyncJob::Start(p->standby.mgr.get());
+        }
+    }
+}
@@ -0,0 +1,69 @@
+#ifndef SQUID_PEERPOOLMGR_H
+#define SQUID_PEERPOOLMGR_H
+
+#include "base/AsyncJob.h"
+#include "comm/forward.h"
+
+class HttpRequest;
+class CachePeer;
+class CommConnectCbParams;
+
+#if USE_OPENSSL
+namespace Ssl
+{
+class PeerConnectorAnswer;
+}
+#endif
+
+/// Maintains an fixed-size "standby" PconnPool for a single CachePeer.
+class PeerPoolMgr: public AsyncJob
+{
+public:
+    typedef CbcPointer<PeerPoolMgr> Pointer;
+
+    // syncs mgr state whenever connection-related peer or pool state changes
+    static void Checkpoint(const Pointer &mgr, const char *reason);
+
+    explicit PeerPoolMgr(CachePeer *aPeer);
+    virtual ~PeerPoolMgr();
+
+protected:
+    /* AsyncJob API */
+    virtual void start();
+    virtual void swanSong();
+    virtual bool doneAll() const;
+
+    /// whether the peer is still out there and in a valid state we can safely use
+    bool validPeer() const;
+
+    /// Starts new connection, or closes the excess connections
+    /// according pool configuration
+    void checkpoint(const char *reason);
+    /// starts the process of opening a new standby connection (if possible)
+    void openNewConnection();
+    /// closes 'howMany' standby connections
+    void closeOldConnections(const int howMany);
+
+    /// Comm::ConnOpener calls this when done opening a connection for us
+    void handleOpenedConnection(const CommConnectCbParams &params);
+#if USE_OPENSSL
+    /// Ssl::PeerConnector callback
+    void handleSecuredPeer(Ssl::PeerConnectorAnswer &answer);
+    /// called when the connection we are trying to secure is closed by a 3rd party
+    void handleSecureClosure(const CommCloseCbParams &params);
+#endif
+    /// the final step in connection opening (and, optionally, securing) sequence
+    void pushNewConnection(const Comm::ConnectionPointer &conn);
+
+private:
+    CachePeer *peer; ///< the owner of the pool we manage
+    RefCount<HttpRequest> request; ///< fake HTTP request for conn opening code
+    AsyncCall::Pointer opener; ///< whether we are opening a connection
+    AsyncCall::Pointer securer; ///< whether we are securing a connection
+    AsyncCall::Pointer closer; ///< monitors conn while we are securing it
+    unsigned int addrUsed; ///< counter for cycling through peer addresses
+
+    CBDATA_CLASS2(PeerPoolMgr);
+};
+
+#endif /* SQUID_PEERPOOLMGR_H */
@@ -498,6 +498,7 @@ SBuf::consume(size_type n)
         n = length();
     else
         n = min(n, length());
+    debugs(24, 8, "consume " << n);
     SBuf rv(substr(0, n));
     chop(n);
     return rv;
@@ -111,7 +111,6 @@ acl_ip_data::toSBuf() const
     return SBuf(tmpbuf);
 }
 
-
 /*
  * aclIpAddrNetworkCompare - The guts of the comparison for IP ACLs
  * matching checks.  The first argument (p) is a "host" address,
@@ -89,9 +89,9 @@ ACLMethodData::parse()
 
     for (Tail = &values; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-        if (strcmp(t, "PURGE") == 0)
-            ++ThePurgeCount; // configuration code wants to know
         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));
+        if (q->element == Http::METHOD_PURGE)
+            ++ThePurgeCount; // configuration code wants to know
         *(Tail) = q;
         Tail = &q->next;
     }
@@ -51,8 +51,8 @@ Adaptation::AccessRule::group()
 Adaptation::AccessRules &
 Adaptation::AllRules()
 {
-    static AccessRules TheRules;
-    return TheRules;
+    static AccessRules *TheRules = new AccessRules;
+    return *TheRules;
 }
 
 // TODO: make AccessRules::find work
@@ -54,8 +54,8 @@ Adaptation::Service::wants(const ServiceFilter &filter) const
 Adaptation::Services &
 Adaptation::AllServices()
 {
-    static Services TheServices;
-    return TheServices;
+    static Services *TheServices = new Services;
+    return *TheServices;
 }
 
 Adaptation::ServicePointer
@@ -315,8 +315,8 @@ Adaptation::ServicePlan::print(std::ostream &os) const
 Adaptation::Groups &
 Adaptation::AllGroups()
 {
-    static Groups TheGroups;
-    return TheGroups;
+    static Groups *TheGroups = new Groups;
+    return *TheGroups;
 }
 
 Adaptation::ServiceGroupPointer
@@ -135,7 +135,7 @@ libecap::Name
 Adaptation::Ecap::FirstLineRep::protocol() const
 {
     // TODO: optimize?
-    switch (theMessage.protocol) {
+    switch (theMessage.http_ver.protocol) {
     case AnyP::PROTO_HTTP:
         return libecap::protocolHttp;
     case AnyP::PROTO_HTTPS:
@@ -179,7 +179,7 @@ void
 Adaptation::Ecap::FirstLineRep::protocol(const Name &p)
 {
     // TODO: what happens if we fail to translate some protocol?
-    theMessage.protocol = TranslateProtocolId(p);
+    theMessage.http_ver.protocol = TranslateProtocolId(p);
 }
 
 AnyP::ProtocolType
@@ -147,7 +147,7 @@ void Adaptation::Icap::ServiceRep::putConnection(const Comm::ConnectionPointer &
 void Adaptation::Icap::ServiceRep::noteConnectionUse(const Comm::ConnectionPointer &conn)
 {
     Must(Comm::IsConnOpen(conn));
-    fd_table[conn->fd].noteUse(NULL); // pconn re-use but not via PconnPool API
+    fd_table[conn->fd].noteUse(); // pconn re-use, albeit not via PconnPool API
 }
 
 void Adaptation::Icap::ServiceRep::noteConnectionFailed(const char *comment)
@@ -59,7 +59,6 @@ Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
         username_(NULL),
         requestRealm_(aRequestRealm)
 {
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
     ip_list.head = ip_list.tail = NULL;
     debugs(29, 5, HERE << "Initialised auth_user '" << this << "'.");
@@ -91,7 +90,6 @@ Auth::User::absorb(Auth::User::Pointer from)
 {
     /*
      * XXX Incomplete: it should merge in hash references too and ask the module to merge in scheme data
-     *  dlink_list proxy_auth_list;
      *  dlink_list proxy_match_cache;
      */
 
@@ -71,8 +71,6 @@ class User : public RefCountable
     Auth::Type auth_type;
     /** the config for this user */
     Auth::Config *config;
-    /** we may have many proxy-authenticate strings that decode to the same user */
-    dlink_list proxy_auth_list;
     dlink_list proxy_match_cache;
     size_t ipcount;
     long expiretime;
@@ -65,8 +65,8 @@ Auth::UserRequest::start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTH
 {
     assert(handler);
     assert(data);
-    debugs(29, 9, HERE << "auth_user_request '" << this << "'");
-    module_start(request, al, handler, data);
+    debugs(29, 9, this);
+    startHelperLookup(request, al, handler, data);
 }
 
 bool
@@ -158,15 +158,6 @@ class UserRequest : public RefCountable
 
     virtual void releaseAuthServer();
 
-    /**
-     * Called when squid is ready to put the request on hold and wait for a callback from the auth module
-     * when the auth module has performed it's external activities.
-     *
-     * \param handler	Handler to process the callback when its run
-     * \param data	CBDATA for handler
-     */
-    virtual void module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *handler, void *data) = 0;
-
     // User credentials object this UserRequest is managing
     virtual User::Pointer user() {return _auth_user;}
     virtual const User::Pointer user() const {return _auth_user;}
@@ -195,7 +186,18 @@ class UserRequest : public RefCountable
     /// Add the appropriate [Proxy-]Authenticate header to the given reply
     static void addReplyAuthHeader(HttpReply * rep, UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal);
 
+    /** Start an asynchronous helper lookup to verify the user credentials
+     *
+     * Uses startHelperLookup() for scheme-specific actions.
+     *
+     * The given callback will be called when the auth module has performed
+     * it's external activities.
+     *
+     * \param handler	Handler to process the callback when its run
+     * \param data	CBDATA for handler
+     */
     void start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *handler, void *data);
+
     char const * denyMessage(char const * const default_message = NULL);
 
     /** Possibly overrideable in future */
@@ -224,6 +226,15 @@ class UserRequest : public RefCountable
     virtual const char *credentialsStr() = 0;
 
     const char *helperRequestKeyExtras(HttpRequest *, AccessLogEntry::Pointer &al);
+
+protected:
+    /**
+     * The scheme-specific actions to be performed when sending helper lookup.
+     *
+     * \see void start(HttpRequest *, AccessLogEntry::Pointer &, AUTHCB *, void *);
+     */
+    virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *handler, void *data) = 0;
+
 private:
 
     static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
@@ -93,7 +93,7 @@ Auth::Basic::UserRequest::module_direction()
 
 /* send the initial data to a basic authenticator module */
 void
-Auth::Basic::UserRequest::module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Basic::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     assert(user()->auth_type == Auth::AUTH_BASIC);
     Auth::Basic::User *basic_auth = dynamic_cast<Auth::Basic::User *>(user().getRaw());
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void module_start(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
 private:
@@ -272,7 +272,7 @@ Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int acc
 
 /* send the initial data to a digest authenticator module */
 void
-Auth::Digest::UserRequest::module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Digest::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     char buf[8192];
 
@@ -34,7 +34,7 @@ class UserRequest : public Auth::UserRequest
     virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel);
 #endif
 
-    virtual void module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     char *nonceb64;             /* "dcd98b7102dd2f0e8b11d0f600bfb0c093" */
@@ -6,7 +6,6 @@
 Auth::Negotiate::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
         Auth::User(aConfig, aRequestRealm)
 {
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
 }
 
 Auth::Negotiate::User::~User()
@@ -97,7 +97,7 @@ Auth::Negotiate::UserRequest::module_direction()
 }
 
 void
-Auth::Negotiate::UserRequest::module_start(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Negotiate::UserRequest::startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Direction module_direction();
-    virtual void module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
@@ -6,7 +6,6 @@
 Auth::Ntlm::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
         Auth::User(aConfig, aRequestRealm)
 {
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
 }
 
 Auth::Ntlm::User::~User()
@@ -95,7 +95,7 @@ Auth::Ntlm::UserRequest::module_direction()
 }
 
 void
-Auth::Ntlm::UserRequest::module_start(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Ntlm::UserRequest::startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void module_start(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     virtual const char * connLastHeader();
@@ -135,7 +135,7 @@ Cbc &
 CbcPointer<Cbc>::operator *() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return *c;
 }
 
@@ -144,7 +144,7 @@ Cbc *
 CbcPointer<Cbc>::operator ->() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return c;
 }
 
@@ -69,7 +69,9 @@
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
 #include "Parsing.h"
+#include "pconn.h"
 #include "PeerDigest.h"
+#include "PeerPoolMgr.h"
 #include "RefreshPattern.h"
 #include "rfc1738.h"
 #include "SBufList.h"
@@ -724,6 +726,7 @@ configDoConfigure(void)
 #endif
 
     storeConfigure();
+    update_maxobjsize(); // check for late maximum_object_size directive
 
     snprintf(ThisCache, sizeof(ThisCache), "%s (%s)",
              uniqueHostname(),
@@ -2267,6 +2270,8 @@ parse_peer(CachePeer ** head)
             p->options.allow_miss = true;
         } else if (!strncmp(token, "max-conn=", 9)) {
             p->max_conn = xatoi(token + 9);
+        } else if (!strncmp(token, "standby=", 8)) {
+            p->standby.limit = xatoi(token + 8);
         } else if (!strcmp(token, "originserver")) {
             p->options.originserver = true;
         } else if (!strncmp(token, "name=", 5)) {
@@ -2340,6 +2345,9 @@ parse_peer(CachePeer ** head)
     if (peerFindByName(p->name))
         fatalf("ERROR: cache_peer %s specified twice\n", p->name);
 
+    if (p->max_conn > 0 && p->max_conn < p->standby.limit)
+        fatalf("ERROR: cache_peer %s max-conn=%d is lower than its standby=%d\n", p->host, p->max_conn, p->standby.limit);
+
     if (p->weight < 1)
         p->weight = 1;
 
@@ -2384,6 +2392,9 @@ free_peer(CachePeer ** P)
         cbdataReferenceDone(p->digest);
 #endif
 
+        // the mgr job will notice that its owner is gone and stop
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "peer gone");
+        delete p->standby.pool;
         cbdataFree(p);
     }
 
@@ -4836,7 +4847,7 @@ static void parse_ftp_epsv(acl_access **ftp_epsv)
     bool ftpEpsvIsDeprecatedRule = false;
 
     char *t = ConfigParser::PeekAtToken();
-    if (!t){
+    if (!t) {
         self_destruct();
         return;
     }
@@ -4856,7 +4867,7 @@ static void parse_ftp_epsv(acl_access **ftp_epsv)
     //   2) if this line is "ftp_epsv on|off" and already exist rules of "ftp_epsv allow|deny ..."
     // then abort
     if ((!ftpEpsvIsDeprecatedRule && FtpEspvDeprecated) ||
-        (ftpEpsvIsDeprecatedRule && !FtpEspvDeprecated && *ftp_epsv != NULL)) {
+            (ftpEpsvIsDeprecatedRule && !FtpEspvDeprecated && *ftp_epsv != NULL)) {
         debugs(3, DBG_CRITICAL, "FATAL: do not mix \"ftp_epsv on|off\" cfg lines with \"ftp_epsv allow|deny ...\" cfg lines. Update your ftp_epsv rules.");
         self_destruct();
     }
@@ -48,9 +48,9 @@
 
 #include "squid.h"
 #include "cbdata.h"
+#include "Generic.h"
 #include "mgr/Registration.h"
 #include "Store.h"
-#include "Generic.h"
 
 #include <climits>
 #if USE_CBDATA_DEBUG
@@ -360,8 +360,8 @@ DOC_START
 
 	"program" cmdline
 	Specify the command for the external authenticator.  Such a program
-	reads a request_format line ("username password" by default) and
-	replies with one of three results:
+	reads a request line ("username password" by default) and replies
+	with one of three results:
 
 	  OK
 		the user exists.
@@ -3120,7 +3120,8 @@ DOC_START
 	
 	connect-fail-limit=N
 			How many times connecting to a peer must fail before
-			it is marked as down. Default is 10.
+			it is marked as down. Standby connection failures
+			count towards this limit. Default is 10.
 	
 	allow-miss	Disable Squid's use of only-if-cached when forwarding
 			requests to siblings. This is primarily useful when
@@ -3130,8 +3131,50 @@ DOC_START
 			For example to deny peer usage on requests from peer
 			by denying cache_peer_access if the source is a peer.
 	
-	max-conn=N	Limit the amount of connections Squid may open to this
-			peer. see also 
+	max-conn=N 	Limit the number of concurrent connections the Squid
+			may open to this peer, including already opened idle
+			and standby connections. There is no peer-specific
+			connection limit by default.
+	
+			A peer exceeding the limit is not used for new
+			requests unless a standby connection is available.
+	
+			max-conn currently works poorly with idle persistent
+			connections: When a peer reaches its max-conn limit,
+			and there are idle persistent connections to the peer,
+			the peer may not be selected because the limiting code
+			does not know whether Squid can reuse those idle
+			connections.
+	
+	standby=N	Maintain a pool of N "hot standby" connections to an
+			UP peer, available for requests when no idle
+			persistent connection is available (or safe) to use.
+			By default and with zero N, no such pool is maintained.
+			N must not exceed the max-conn limit (if any).
+	
+			At start or after reconfiguration, Squid opens new TCP
+			standby connections until there are N connections
+			available and then replenishes the standby pool as
+			opened connections are used up for requests. A used
+			connection never goes back to the standby pool, but
+			may go to the regular idle persistent connection pool
+			shared by all peers and origin servers.
+	
+			Squid never opens multiple new standby connections
+			concurrently.  This one-at-a-time approach minimizes
+			flooding-like effect on peers. Furthermore, just a few
+			standby connections should be sufficient in most cases
+			to supply most new requests with a ready-to-use
+			connection.
+	
+			Standby connections obey server_idle_pconn_timeout.
+			For the feature to work as intended, the peer must be
+			configured to accept and keep them open longer than
+			the idle timeout at the connecting Squid, to minimize
+			race conditions typical to idle used persistent
+			connections. Default request_timeout and
+			server_idle_pconn_timeout values ensure such a
+			configuration.
 	
 	name=xxx	Unique name for the peer.
 			Required if you have multiple peers on the same host
@@ -3446,9 +3489,7 @@ TYPE: b_int64_t
 DEFAULT: 4 MB
 LOC: Config.Store.maxObjectSize
 DOC_START
-	Set the default value for max-size parameter on any cache_dir
-	which follow.
-	
+	Set the default value for max-size parameter on any cache_dir.
 	The value is specified in bytes, and the default is 4 MB.
 	
 	If you wish to get a high BYTES hit ratio, you should probably
@@ -3612,10 +3653,9 @@ DOC_START
 
 	max-size=n	the maximum object size in bytes this cache_dir
 			supports.
-			The value in maximum_object_size directive above
-			this cache_dir line sets a default unless more
-			specific details are available (ie a small store
-			capacity).
+			The value in maximum_object_size directive sets
+			the default unless more specific details are
+			available (ie a small store capacity).
 
 	Note: To make optimal use of the max-size limits you should order
 	the cache_dir lines with the smallest max-size value first.
@@ -3776,10 +3816,22 @@ DOC_START
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
-		note	The meta header specified by the argument. Also
+		note	The annotation specified by the argument. Also
 			logs the adaptation meta headers set by the
 			adaptation_meta configuration parameter.
-			If no argument given all meta headers logged.
+			If no argument given all annotations logged.
+			The argument may include a separator to use with
+			annotation values:
+                            name[:separator]
+			By default, multiple note values are separated with ","
+			and multiple notes are separated with "\r\n".
+			When logging named notes with %{name}note, the
+			explicitly configured separator is used between note
+			values. When logging all notes with %note, the
+			explicitly configured separator is used between
+			individual notes. There is currently no way to
+			specify both value and notes separators when logging
+			all notes with %note.
 
 	Connection related format codes:
 
@@ -3849,15 +3901,20 @@ DOC_START
 		[http::]ru	Request URL from client (historic, filtered for logging)
 		[http::]>ru	Request URL from client
 		[http::]<ru	Request URL sent to server or peer
+		[http::]>rs	Request URL scheme from client
+		[http::]<rs	Request URL scheme sent to server or peer
 		[http::]>rd	Request URL domain from client
-		[http::]rp	Request URL-Path excluding hostname
-		[http::]>rp	Request URL-Path excluding hostname from client
-		[http::]<rp	Request URL-Path excluding hostname sent to server or peer
+		[http::]>rd	Request URL domain sent to server or peer
+		[http::]>rP	Request URL port from client
+		[http::]<rP	Request URL port sent to server or peer
+		[http::]rp	Request URL path excluding hostname
+		[http::]>rp	Request URL path excluding hostname from client
+		[http::]<rp	Request URL path excluding hostname sent to server or peer
 		[http::]rv	Request protocol version
 		[http::]>rv	Request protocol version from client
 		[http::]<rv	Request protocol version sent to server or peer
 
-		[http::]>h	Original received request header. 
+		[http::]>h	Original received request header.
 				Usually differs from the request header sent by
 				Squid, although most fields are often preserved.
 				Accepts optional header field name/value filter
@@ -874,11 +874,11 @@ gen_quote_escape(const std::string &var)
 
     for (int i = 0; i < var.length(); ++i) {
         switch (var[i]) {
-            case '"':
-            case '\\':
-                esc += '\\';
-            default:
-                esc += var[i];
+        case '"':
+        case '\\':
+            esc += '\\';
+        default:
+            esc += var[i];
         }
     }
 
@@ -3632,9 +3632,8 @@ httpsSslBumpAccessCheckDone(allow_t answer, void *data)
         // fake a CONNECT request to force connState to tunnel
         static char ip[MAX_IPSTRLEN];
         connState->clientConnection->local.toUrl(ip, sizeof(ip));
-        SBuf reqStr;
-        reqStr.append("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n");
-        bool ret = connState->handleReadData(&reqStr);
+        connState->in.buf.append("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n");
+        bool ret = connState->handleReadData(&connState->in.buf);
         if (ret)
             ret = connState->clientParseRequests();
 
@@ -1180,9 +1180,6 @@ _comm_close(int fd, char const *file, int line)
 
     commCallCloseHandlers(fd);
 
-    if (F->pconn.uses && F->pconn.pool)
-        F->pconn.pool->noteUses(F->pconn.uses);
-
     comm_empty_os_read_buffers(fd);
 
     AsyncCall::Pointer completeCall=commCbCall(5,4, "comm_close_complete",
@@ -4,6 +4,7 @@
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
+#include "neighbors.h"
 #include "SquidTime.h"
 
 class CachePeer;
@@ -66,7 +67,7 @@ Comm::Connection::close()
         comm_close(fd);
         fd = -1;
         if (CachePeer *p=getPeer())
-            -- p->stats.conn_open;
+            peerConnClosed(p);
     }
 }
 
@@ -573,7 +573,7 @@ ErrorState::NewForwarding(err_type type, HttpRequest *request)
 {
     assert(request);
     const Http::StatusCode status = request->flags.needValidation ?
-        Http::scGatewayTimeout : Http::scServiceUnavailable;
+                                    Http::scGatewayTimeout : Http::scServiceUnavailable;
     return new ErrorState(type, status, request);
 }
 
@@ -950,8 +950,8 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'M':
         if (request) {
-           const SBuf &m = request->method.image();
-           mb.append(m.rawContent(), m.length());
+            const SBuf &m = request->method.image();
+            mb.append(m.rawContent(), m.length());
         } else if (!building_deny_info_url)
             p = "[unknown method]";
         break;
@@ -19,8 +19,8 @@ bool
 Eui::Eui64::decode(const char *asc)
 {
     if (eui64_aton(asc, (struct eui64 *)eui) != 0) {
-       debugs(28, 4, "id=" << (void*)this << " decode fail on " << asc);
-       return false;
+        debugs(28, 4, "id=" << (void*)this << " decode fail on " << asc);
+        return false;
     }
 
     debugs(28, 4, "id=" << (void*)this << " ATON decoded " << asc);
@@ -48,6 +48,7 @@
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
 #include "fde.h"
+#include "format/ByteCode.h"
 #include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -150,55 +151,7 @@ class external_acl
 };
 
 struct _external_acl_format {
-    enum format_type {
-        EXT_ACL_UNKNOWN,
-#if USE_AUTH
-        EXT_ACL_LOGIN,
-#endif
-#if USE_IDENT
-        EXT_ACL_IDENT,
-#endif
-        EXT_ACL_SRC,
-        EXT_ACL_SRCPORT,
-#if USE_SQUID_EUI
-        EXT_ACL_SRCEUI48,
-        EXT_ACL_SRCEUI64,
-#endif
-        EXT_ACL_MYADDR,
-        EXT_ACL_MYPORT,
-        EXT_ACL_URI,
-        EXT_ACL_DST,
-        EXT_ACL_PROTO,
-        EXT_ACL_PORT,
-        EXT_ACL_PATH,
-        EXT_ACL_METHOD,
-
-        EXT_ACL_HEADER_REQUEST,
-        EXT_ACL_HEADER_REQUEST_MEMBER,
-        EXT_ACL_HEADER_REQUEST_ID,
-        EXT_ACL_HEADER_REQUEST_ID_MEMBER,
-
-        EXT_ACL_HEADER_REPLY,
-        EXT_ACL_HEADER_REPLY_MEMBER,
-        EXT_ACL_HEADER_REPLY_ID,
-        EXT_ACL_HEADER_REPLY_ID_MEMBER,
-
-#if USE_OPENSSL
-        EXT_ACL_USER_CERT,
-        EXT_ACL_USER_CA_CERT,
-        EXT_ACL_USER_CERT_RAW,
-        EXT_ACL_USER_CERTCHAIN_RAW,
-#endif
-#if USE_AUTH
-        EXT_ACL_EXT_USER,
-#endif
-        EXT_ACL_EXT_LOG,
-        EXT_ACL_TAG,
-        EXT_ACL_ACLNAME,
-        EXT_ACL_ACLDATA,
-        EXT_ACL_PERCENT,
-        EXT_ACL_END
-    } type;
+    Format::ByteCode_t type;
     external_acl_format *next;
     char *header;
     char *member;
@@ -254,7 +207,7 @@ free_external_acl(void *data)
  \param format   - structure to contain all the info about this format element.
  */
 void
-parse_header_token(external_acl_format *format, char *header, const _external_acl_format::format_type type)
+parse_header_token(external_acl_format *format, char *header, const Format::ByteCode_t type)
 {
     /* header format */
     char *member, *end;
@@ -282,30 +235,17 @@ parse_header_token(external_acl_format *format, char *header, const _external_ac
 
         format->member = xstrdup(member);
 
-        if (type == _external_acl_format::EXT_ACL_HEADER_REQUEST)
-            format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER;
+        if (type == Format::LFT_ADAPTED_REQUEST_HEADER)
+            format->type = Format::LFT_ADAPTED_REQUEST_HEADER_ELEM;
         else
-            format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER;
+            format->type = Format::LFT_REPLY_HEADER_ELEM;
+
     } else {
         format->type = type;
     }
 
     format->header = xstrdup(header);
     format->header_id = httpHeaderIdByNameDef(header, strlen(header));
-
-    if (format->header_id != -1) {
-        if (member) {
-            if (type == _external_acl_format::EXT_ACL_HEADER_REQUEST)
-                format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_ID_MEMBER;
-            else
-                format->type = _external_acl_format::EXT_ACL_HEADER_REPLY_ID_MEMBER;
-        } else {
-            if (type == _external_acl_format::EXT_ACL_HEADER_REQUEST)
-                format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_ID;
-            else
-                format->type = _external_acl_format::EXT_ACL_HEADER_REPLY_ID;
-        }
-    }
 }
 
 void
@@ -421,84 +361,84 @@ parse_externalAclHelper(external_acl ** list)
         if (strncmp(token, "%{", 2) == 0) {
             // deprecated. but assume the old configs all referred to request headers.
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+2), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+2), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%>{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%>ha{", 5) == 0) {
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%<{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
+            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
         } else if (strncmp(token, "%<h{", 4) == 0) {
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
+            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
 #if USE_AUTH
         } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
-            format->type = _external_acl_format::EXT_ACL_LOGIN;
+            format->type = Format::LFT_USER_LOGIN;
             a->require_auth = true;
 #endif
         }
 #if USE_IDENT
         else if (strcmp(token, "%IDENT") == 0 || strcmp(token, "%ui") == 0)
-            format->type = _external_acl_format::EXT_ACL_IDENT;
+            format->type = Format::LFT_USER_IDENT;
 #endif
         else if (strcmp(token, "%SRC") == 0 || strcmp(token, "%>a") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRC;
+            format->type = Format::LFT_CLIENT_IP_ADDRESS;
         else if (strcmp(token, "%SRCPORT") == 0 || strcmp(token, "%>p") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRCPORT;
+            format->type = Format::LFT_CLIENT_PORT;
 #if USE_SQUID_EUI
         else if (strcmp(token, "%SRCEUI48") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRCEUI48;
+            format->type = Format::LFT_EXT_ACL_CLIENT_EUI48;
         else if (strcmp(token, "%SRCEUI64") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRCEUI64;
+            format->type = Format::LFT_EXT_ACL_CLIENT_EUI64;
 #endif
         else if (strcmp(token, "%MYADDR") == 0 || strcmp(token, "%la") == 0)
-            format->type = _external_acl_format::EXT_ACL_MYADDR;
+            format->type = Format::LFT_LOCAL_LISTENING_IP;
         else if (strcmp(token, "%MYPORT") == 0 || strcmp(token, "%lp") == 0)
-            format->type = _external_acl_format::EXT_ACL_MYPORT;
+            format->type = Format::LFT_LOCAL_LISTENING_PORT;
         else if (strcmp(token, "%URI") == 0 || strcmp(token, "%>ru") == 0)
-            format->type = _external_acl_format::EXT_ACL_URI;
-        else if (strcmp(token, "%DST") == 0)
-            format->type = _external_acl_format::EXT_ACL_DST;
-        else if (strcmp(token, "%PROTO") == 0)
-            format->type = _external_acl_format::EXT_ACL_PROTO;
-        else if (strcmp(token, "%PORT") == 0)
-            format->type = _external_acl_format::EXT_ACL_PORT;
+            format->type = Format::LFT_CLIENT_REQ_URI;
+        else if (strcmp(token, "%DST") == 0 || strcmp(token, "%>rd") == 0)
+            format->type = Format::LFT_CLIENT_REQ_URLDOMAIN;
+        else if (strcmp(token, "%PROTO") == 0 || strcmp(token, "%>rs") == 0)
+            format->type = Format::LFT_CLIENT_REQ_URLSCHEME;
+        else if (strcmp(token, "%PORT") == 0) // XXX: add a logformat token
+            format->type = Format::LFT_CLIENT_REQ_URLPORT;
         else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
-            format->type = _external_acl_format::EXT_ACL_PATH;
+            format->type = Format::LFT_CLIENT_REQ_URLPATH;
         else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
-            format->type = _external_acl_format::EXT_ACL_METHOD;
+            format->type = Format::LFT_CLIENT_REQ_METHOD;
 #if USE_OPENSSL
         else if (strcmp(token, "%USER_CERT") == 0)
-            format->type = _external_acl_format::EXT_ACL_USER_CERT_RAW;
+            format->type = Format::LFT_EXT_ACL_USER_CERT_RAW;
         else if (strcmp(token, "%USER_CERTCHAIN") == 0)
-            format->type = _external_acl_format::EXT_ACL_USER_CERTCHAIN_RAW;
+            format->type = Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW;
         else if (strncmp(token, "%USER_CERT_", 11) == 0) {
-            format->type = _external_acl_format::EXT_ACL_USER_CERT;
+            format->type = Format::LFT_EXT_ACL_USER_CERT;
             format->header = xstrdup(token + 11);
         } else if (strncmp(token, "%USER_CA_CERT_", 11) == 0) {
-            format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
+            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 11);
         } else if (strncmp(token, "%CA_CERT_", 11) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
-            format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
+            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 11);
         }
 #endif
 #if USE_AUTH
-        else if (strcmp(token, "%EXT_USER") == 0)
-            format->type = _external_acl_format::EXT_ACL_EXT_USER;
+        else if (strcmp(token, "%EXT_USER") == 0 || strcmp(token, "%ue") == 0)
+            format->type = Format::LFT_USER_EXTERNAL;
 #endif
-        else if (strcmp(token, "%EXT_LOG") == 0)
-            format->type = _external_acl_format::EXT_ACL_EXT_LOG;
-        else if (strcmp(token, "%TAG") == 0)
-            format->type = _external_acl_format::EXT_ACL_TAG;
+        else if (strcmp(token, "%EXT_LOG") == 0 || strcmp(token, "%ea") == 0)
+            format->type = Format::LFT_EXT_LOG;
+        else if (strcmp(token, "%TAG") == 0  || strcmp(token, "%et") == 0)
+            format->type = Format::LFT_TAG;
         else if (strcmp(token, "%ACL") == 0)
-            format->type = _external_acl_format::EXT_ACL_ACLNAME;
+            format->type = Format::LFT_EXT_ACL_NAME;
         else if (strcmp(token, "%DATA") == 0)
-            format->type = _external_acl_format::EXT_ACL_ACLDATA;
+            format->type = Format::LFT_EXT_ACL_DATA;
         else if (strcmp(token, "%%") == 0)
-            format->type = _external_acl_format::EXT_ACL_PERCENT;
+            format->type = Format::LFT_PERCENT;
         else {
             debugs(0, DBG_CRITICAL, "ERROR: Unknown Format token " << token);
             self_destruct();
@@ -573,67 +513,60 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
         for (format = node->format; format; format = format->next) {
             switch (format->type) {
 
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST:
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID:
-                storeAppendPrintf(sentry, " %%>{%s}", format->header);
+            case Format::LFT_ADAPTED_REQUEST_HEADER:
+                storeAppendPrintf(sentry, " %%>ha{%s}", format->header);
                 break;
 
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER:
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID_MEMBER:
-                storeAppendPrintf(sentry, " %%>{%s:%s}", format->header, format->member);
+            case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
+                storeAppendPrintf(sentry, " %%>ha{%s:%s}", format->header, format->member);
                 break;
 
-            case _external_acl_format::EXT_ACL_HEADER_REPLY:
-            case _external_acl_format::EXT_ACL_HEADER_REPLY_ID:
-                storeAppendPrintf(sentry, " %%<{%s}", format->header);
+            case Format::LFT_REPLY_HEADER:
+                storeAppendPrintf(sentry, " %%<h{%s}", format->header);
                 break;
 
-            case _external_acl_format::EXT_ACL_HEADER_REPLY_MEMBER:
-            case _external_acl_format::EXT_ACL_HEADER_REPLY_ID_MEMBER:
-                storeAppendPrintf(sentry, " %%<{%s:%s}", format->header, format->member);
+            case Format::LFT_REPLY_HEADER_ELEM:
+                storeAppendPrintf(sentry, " %%<h{%s:%s}", format->header, format->member);
                 break;
-#define DUMP_EXT_ACL_TYPE(a) \
-            case _external_acl_format::EXT_ACL_##a: \
-                storeAppendPrintf(sentry, " %%%s", #a); \
-                break
+
 #define DUMP_EXT_ACL_TYPE_FMT(a, fmt, ...) \
-            case _external_acl_format::EXT_ACL_##a: \
+            case Format::LFT_##a: \
                 storeAppendPrintf(sentry, fmt, ##__VA_ARGS__); \
                 break
 #if USE_AUTH
-                DUMP_EXT_ACL_TYPE(LOGIN);
+                DUMP_EXT_ACL_TYPE_FMT(USER_LOGIN," %%ul");
 #endif
 #if USE_IDENT
 
-                DUMP_EXT_ACL_TYPE(IDENT);
+                DUMP_EXT_ACL_TYPE_FMT(USER_IDENT," %%ui");
 #endif
-
-                DUMP_EXT_ACL_TYPE(SRC);
-                DUMP_EXT_ACL_TYPE(SRCPORT);
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_IP_ADDRESS," %%>a");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_PORT," %%>p");
 #if USE_SQUID_EUI
-                DUMP_EXT_ACL_TYPE(SRCEUI48);
-                DUMP_EXT_ACL_TYPE(SRCEUI64);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI48," %%SRCEUI48");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI64," %%SRCEUI64");
 #endif
-
-                DUMP_EXT_ACL_TYPE(MYADDR);
-                DUMP_EXT_ACL_TYPE(MYPORT);
-                DUMP_EXT_ACL_TYPE(URI);
-                DUMP_EXT_ACL_TYPE(DST);
-                DUMP_EXT_ACL_TYPE(PROTO);
-                DUMP_EXT_ACL_TYPE(PORT);
-                DUMP_EXT_ACL_TYPE(PATH);
-                DUMP_EXT_ACL_TYPE(METHOD);
+                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_IP," %%>la");
+                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_PORT," %%>lp");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URI," %%>ru");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLDOMAIN," %%>rd");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLSCHEME," %%>rs");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPORT," %%>rP");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPATH," %%>rp");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_METHOD," %%>rm");
 #if USE_OPENSSL
-                DUMP_EXT_ACL_TYPE_FMT(USER_CERT_RAW, " %%USER_CERT_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(USER_CERT, " %%USER_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT_RAW, " %%USER_CERT_RAW");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT, " %%USER_CERT_%s", format->header);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
 #endif
 #if USE_AUTH
-                DUMP_EXT_ACL_TYPE(EXT_USER);
+                DUMP_EXT_ACL_TYPE_FMT(USER_EXTERNAL," %%ue");
 #endif
-                DUMP_EXT_ACL_TYPE(EXT_LOG);
-                DUMP_EXT_ACL_TYPE(TAG);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_LOG," %%ea");
+                DUMP_EXT_ACL_TYPE_FMT(TAG," %%et");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_NAME," %%ACL");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_DATA," %%DATA");
                 DUMP_EXT_ACL_TYPE_FMT(PERCENT, " %%%%");
             default:
                 fatal("unknown external_acl format error");
@@ -980,7 +913,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
         switch (format->type) {
 #if USE_AUTH
-        case _external_acl_format::EXT_ACL_LOGIN:
+        case Format::LFT_USER_LOGIN:
             // if this ACL line was the cause of credentials fetch
             // they may not already be in the checklist
             if (ch->auth_user_request == NULL && ch->request)
@@ -991,7 +924,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 #endif
 #if USE_IDENT
-        case _external_acl_format::EXT_ACL_IDENT:
+        case Format::LFT_USER_IDENT:
             str = ch->rfc931;
 
             if (!str || !*str) {
@@ -1004,117 +937,105 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 #endif
 
-        case _external_acl_format::EXT_ACL_SRC:
+        case Format::LFT_CLIENT_IP_ADDRESS:
             str = ch->src_addr.toStr(buf,sizeof(buf));
             break;
 
-        case _external_acl_format::EXT_ACL_SRCPORT:
+        case Format::LFT_CLIENT_PORT:
             snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
             str = buf;
             break;
 
 #if USE_SQUID_EUI
-        case _external_acl_format::EXT_ACL_SRCEUI48:
+        case Format::LFT_EXT_ACL_CLIENT_EUI48:
             if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
                     request->clientConnectionManager->clientConnection->remoteEui48.encode(buf, sizeof(buf)))
                 str = buf;
             break;
 
-        case _external_acl_format::EXT_ACL_SRCEUI64:
+        case Format::LFT_EXT_ACL_CLIENT_EUI64:
             if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
                     request->clientConnectionManager->clientConnection->remoteEui64.encode(buf, sizeof(buf)))
                 str = buf;
             break;
 #endif
 
-        case _external_acl_format::EXT_ACL_MYADDR:
+        case Format::LFT_LOCAL_LISTENING_IP:
             str = request->my_addr.toStr(buf, sizeof(buf));
             break;
 
-        case _external_acl_format::EXT_ACL_MYPORT:
+        case Format::LFT_LOCAL_LISTENING_PORT:
             snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
             str = buf;
             break;
 
-        case _external_acl_format::EXT_ACL_URI:
+        case Format::LFT_CLIENT_REQ_URI:
             str = urlCanonical(request);
             break;
 
-        case _external_acl_format::EXT_ACL_DST:
+        case Format::LFT_CLIENT_REQ_URLDOMAIN:
             str = request->GetHost();
             break;
 
-        case _external_acl_format::EXT_ACL_PROTO:
+        case Format::LFT_CLIENT_REQ_URLSCHEME:
             str = request->url.getScheme().c_str();
             break;
 
-        case _external_acl_format::EXT_ACL_PORT:
+        case Format::LFT_CLIENT_REQ_URLPORT:
             snprintf(buf, sizeof(buf), "%d", request->port);
             str = buf;
             break;
 
-        case _external_acl_format::EXT_ACL_PATH:
+        case Format::LFT_CLIENT_REQ_URLPATH:
             str = request->urlpath.termedBuf();
             break;
 
-        case _external_acl_format::EXT_ACL_METHOD:
-            {
-                const SBuf &s = request->method.image();
-                sb.append(s.rawContent(), s.length());
-            }
-            str = sb.termedBuf();
-            break;
-
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST:
-            sb = request->header.getByName(format->header);
-            str = sb.termedBuf();
-            break;
-
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID:
-            sb = request->header.getStrOrList(format->header_id);
-            str = sb.termedBuf();
-            break;
+        case Format::LFT_CLIENT_REQ_METHOD: {
+            const SBuf &s = request->method.image();
+            sb.append(s.rawContent(), s.length());
+        }
+        str = sb.termedBuf();
+        break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER:
-            sb = request->header.getByNameListMember(format->header, format->member, format->separator);
+        case Format::LFT_ADAPTED_REQUEST_HEADER:
+            if (format->header_id == -1)
+                sb = request->header.getByName(format->header);
+            else
+                sb = request->header.getStrOrList(format->header_id);
             str = sb.termedBuf();
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID_MEMBER:
-            sb = request->header.getListMember(format->header_id, format->member, format->separator);
+        case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
+            if (format->header_id == -1)
+                sb = request->header.getByNameListMember(format->header, format->member, format->separator);
+            else
+                sb = request->header.getListMember(format->header_id, format->member, format->separator);
             str = sb.termedBuf();
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REPLY:
-            if (reply) {
-                sb = reply->header.getByName(format->header);
-                str = sb.termedBuf();
-            }
-            break;
-
-        case _external_acl_format::EXT_ACL_HEADER_REPLY_ID:
+        case Format::LFT_REPLY_HEADER:
             if (reply) {
-                sb = reply->header.getStrOrList(format->header_id);
+                if (format->header_id == -1)
+                    sb = reply->header.getByName(format->header);
+                else
+                    sb = reply->header.getStrOrList(format->header_id);
                 str = sb.termedBuf();
             }
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REPLY_MEMBER:
+        case Format::LFT_REPLY_HEADER_ELEM:
             if (reply) {
-                sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
+                if (format->header_id == -1)
+                    sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
+                else
+                    sb = reply->header.getListMember(format->header_id, format->member, format->separator);
                 str = sb.termedBuf();
             }
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REPLY_ID_MEMBER:
-            if (reply) {
-                sb = reply->header.getListMember(format->header_id, format->member, format->separator);
-                str = sb.termedBuf();
-            }
-            break;
 #if USE_OPENSSL
 
-        case _external_acl_format::EXT_ACL_USER_CERT_RAW:
+        case Format::LFT_EXT_ACL_USER_CERT_RAW:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1125,7 +1046,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_USER_CERTCHAIN_RAW:
+        case Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1136,7 +1057,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_USER_CERT:
+        case Format::LFT_EXT_ACL_USER_CERT:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1147,7 +1068,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_USER_CA_CERT:
+        case Format::LFT_EXT_ACL_USER_CA_CERT:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1159,20 +1080,20 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 #endif
 #if USE_AUTH
-        case _external_acl_format::EXT_ACL_EXT_USER:
+        case Format::LFT_USER_EXTERNAL:
             str = request->extacl_user.termedBuf();
             break;
 #endif
-        case _external_acl_format::EXT_ACL_EXT_LOG:
+        case Format::LFT_EXT_LOG:
             str = request->extacl_log.termedBuf();
             break;
-        case _external_acl_format::EXT_ACL_TAG:
+        case Format::LFT_TAG:
             str = request->tag.termedBuf();
             break;
-        case _external_acl_format::EXT_ACL_ACLNAME:
+        case Format::LFT_EXT_ACL_NAME:
             str = acl_data->name;
             break;
-        case _external_acl_format::EXT_ACL_ACLDATA:
+        case Format::LFT_EXT_ACL_DATA:
             data_used = true;
             for (arg = acl_data->arguments; arg; arg = arg->next) {
                 if (!first)
@@ -1192,13 +1113,14 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
                 first = 0;
             }
             break;
-        case _external_acl_format::EXT_ACL_PERCENT:
+        case Format::LFT_PERCENT:
             str = "%";
             break;
-        case _external_acl_format::EXT_ACL_UNKNOWN:
 
-        case _external_acl_format::EXT_ACL_END:
-            fatal("unknown external_acl format error");
+        default:
+            // TODO: replace this function with Format::assemble()
+            // For now die on unsupported logformat codes.
+            fatalf("ERROR: unknown external_acl_type format %u", (uint8_t)format->type);
             break;
         }
 
@@ -1607,14 +1529,16 @@ ExternalACLLookup::LookupDone(void *data, void *result)
     checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
 
     // attach the helper kv-pair to the transaction
-    if (HttpRequest * req = checklist->request) {
-        // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
-        // workaround by using anything already set in HttpRequest
-        // OR use new and rely on a later Sync copying these to AccessLogEntry
-        if (!req->notes)
-            req->notes = new NotePairs;
-
-        req->notes->appendNewOnly(&checklist->extacl_entry->notes);
+    if (checklist->extacl_entry) {
+        if (HttpRequest * req = checklist->request) {
+            // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
+            // workaround by using anything already set in HttpRequest
+            // OR use new and rely on a later Sync copying these to AccessLogEntry
+            if (!req->notes)
+                req->notes = new NotePairs;
+
+            req->notes->appendNewOnly(&checklist->extacl_entry->notes);
+        }
     }
 
     checklist->resumeNonBlockingCheck(ExternalACLLookup::Instance());
@@ -122,8 +122,7 @@ fde::remoteAddr() const
 }
 
 void
-fde::noteUse(PconnPool *pool)
+fde::noteUse()
 {
     ++ pconn.uses;
-    pconn.pool = pool;
 }
@@ -42,7 +42,6 @@
 class ClientInfo;
 #endif
 
-class PconnPool;
 class dwrite_q;
 class _fde_disk
 {
@@ -70,7 +69,7 @@ class fde
     char const *remoteAddr() const;
     void dumpStats (StoreEntry &, int);
     bool readPending(int);
-    void noteUse(PconnPool *);
+    void noteUse();
 
 public:
 
@@ -110,7 +109,6 @@ class fde
 
     struct {
         int uses;                   /* ie # req's over persistent conn */
-        PconnPool *pool;
     } pconn;
 
 #if USE_DELAY_POOLS
@@ -167,7 +165,6 @@ class fde
         bytes_read = 0;
         bytes_written = 0;
         pconn.uses = 0;
-        pconn.pool = NULL;
 #if USE_DELAY_POOLS
         clientInfo = NULL;
 #endif
@@ -58,7 +58,9 @@ typedef enum {
     /* original Request-Line details recieved from client */
     LFT_CLIENT_REQ_METHOD,
     LFT_CLIENT_REQ_URI,
+    LFT_CLIENT_REQ_URLSCHEME,
     LFT_CLIENT_REQ_URLDOMAIN,
+    LFT_CLIENT_REQ_URLPORT,
     LFT_CLIENT_REQ_URLPATH,
     /* LFT_CLIENT_REQ_QUERY, */
     LFT_CLIENT_REQ_VERSION,
@@ -70,6 +72,7 @@ typedef enum {
     /*LFT_REQUEST_QUERY, */
     LFT_REQUEST_VERSION_OLD_2X,
     LFT_REQUEST_VERSION,
+    LFT_REQUEST_URLGROUP_OLD_2X,
 
     /* request header details pre-adaptation */
     LFT_REQUEST_HEADER,
@@ -84,6 +87,9 @@ typedef enum {
     /* Request-Line details sent to the server/peer */
     LFT_SERVER_REQ_METHOD,
     LFT_SERVER_REQ_URI,
+    LFT_SERVER_REQ_URLSCHEME,
+    LFT_SERVER_REQ_URLDOMAIN,
+    LFT_SERVER_REQ_URLPORT,
     LFT_SERVER_REQ_URLPATH,
     /*LFT_SERVER_REQ_QUERY, */
     LFT_SERVER_REQ_VERSION,
@@ -203,7 +209,18 @@ typedef enum {
 #endif
 
     LFT_NOTE,
-    LFT_PERCENT			/* special string cases for escaped chars */
+    LFT_PERCENT,			/* special string cases for escaped chars */
+
+    // TODO assign better bytecode names and Token strings for these
+    LFT_EXT_ACL_USER_CERT_RAW,
+    LFT_EXT_ACL_USER_CERTCHAIN_RAW,
+    LFT_EXT_ACL_USER_CERT,
+    LFT_EXT_ACL_USER_CA_CERT,
+    LFT_EXT_ACL_CLIENT_EUI48,
+    LFT_EXT_ACL_CLIENT_EUI64,
+    LFT_EXT_ACL_NAME,
+    LFT_EXT_ACL_DATA
+
 } ByteCode_t;
 
 /// Quoting style for a format output.
@@ -475,7 +475,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             const char *spec;
 
             struct tm *t;
-            spec = fmt->data.timespec;
+            spec = fmt->data.string;
 
             if (fmt->type == LFT_TIME_LOCALTIME) {
                 if (!spec)
@@ -931,13 +931,27 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             }
             break;
 
+        case LFT_CLIENT_REQ_URLSCHEME:
+            if (al->request) {
+                out = al->request->url.getScheme().c_str();
+                quote = 1;
+            }
+            break;
+
         case LFT_CLIENT_REQ_URLDOMAIN:
             if (al->request) {
                 out = al->request->GetHost();
                 quote = 1;
             }
             break;
 
+        case LFT_CLIENT_REQ_URLPORT:
+            if (al->request) {
+                outint = al->request->port;
+                doint = 1;
+            }
+            break;
+
         case LFT_REQUEST_URLPATH_OLD_31:
         case LFT_CLIENT_REQ_URLPATH:
             if (al->request) {
@@ -991,6 +1005,27 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             }
             break;
 
+        case LFT_SERVER_REQ_URLSCHEME:
+            if (al->adapted_request) {
+                out = al->adapted_request->url.getScheme().c_str();
+                quote = 1;
+            }
+            break;
+
+        case LFT_SERVER_REQ_URLDOMAIN:
+            if (al->adapted_request) {
+                out = al->adapted_request->GetHost();
+                quote = 1;
+            }
+            break;
+
+        case LFT_SERVER_REQ_URLPORT:
+            if (al->adapted_request) {
+                outint = al->adapted_request->port;
+                doint = 1;
+            }
+            break;
+
         case LFT_SERVER_REQ_URLPATH:
             if (al->adapted_request) {
                 out = al->adapted_request->urlpath.termedBuf();
@@ -1101,32 +1136,40 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 #endif
 
+        case LFT_REQUEST_URLGROUP_OLD_2X:
+            assert(LFT_REQUEST_URLGROUP_OLD_2X == 0); // should never happen.
+
         case LFT_NOTE:
-            if (fmt->data.string) {
+            tmp[0] = fmt->data.header.separator;
+            tmp[1] = '\0';
+            if (fmt->data.header.header && *fmt->data.header.header) {
+                const char *separator = tmp;
 #if USE_ADAPTATION
                 Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL) {
-                    if (const char *meta = ah->metaHeaders->find(fmt->data.string))
+                    if (const char *meta = ah->metaHeaders->find(fmt->data.header.header, separator))
                         sb.append(meta);
                 }
 #endif
                 if (al->notes != NULL) {
-                    if (const char *note = al->notes->find(fmt->data.string)) {
+                    if (const char *note = al->notes->find(fmt->data.header.header, separator)) {
                         if (sb.size())
-                            sb.append(", ");
+                            sb.append(separator);
                         sb.append(note);
                     }
                 }
                 out = sb.termedBuf();
                 quote = 1;
             } else {
+                // if no argument given use default "\r\n" as notes separator
+                const char *separator = fmt->data.string ? tmp : "\r\n";
 #if USE_ADAPTATION
                 Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL && !ah->metaHeaders->empty())
-                    sb.append(ah->metaHeaders->toString());
+                    sb.append(ah->metaHeaders->toString(separator));
 #endif
                 if (al->notes != NULL && !al->notes->empty())
-                    sb.append(al->notes->toString());
+                    sb.append(al->notes->toString(separator));
 
                 out = sb.termedBuf();
                 quote = 1;
@@ -1143,7 +1186,20 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_PERCENT:
             out = "%";
+            break;
 
+            // XXX: external_acl_type format tokens which are not output by logformat.
+            // They are listed here because the switch requires
+            // every ByteCode_t to be explicitly enumerated.
+            // But do not output due to lack of access to the values.
+        case LFT_EXT_ACL_USER_CERT_RAW:
+        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
+        case LFT_EXT_ACL_USER_CERT:
+        case LFT_EXT_ACL_USER_CA_CERT:
+        case LFT_EXT_ACL_CLIENT_EUI48:
+        case LFT_EXT_ACL_CLIENT_EUI64:
+        case LFT_EXT_ACL_NAME:
+        case LFT_EXT_ACL_DATA:
             break;
         }
 
@@ -81,7 +81,9 @@ static TokenTableEntry TokenTable2C[] = {
 
     {">rm", LFT_CLIENT_REQ_METHOD},
     {">ru", LFT_CLIENT_REQ_URI},
+    {">rs", LFT_CLIENT_REQ_URLSCHEME},
     {">rd", LFT_CLIENT_REQ_URLDOMAIN},
+    {">rP", LFT_CLIENT_REQ_URLPORT},
     {">rp", LFT_CLIENT_REQ_URLPATH},
     /*{">rq", LFT_CLIENT_REQ_QUERY},*/
     {">rv", LFT_CLIENT_REQ_VERSION},
@@ -91,9 +93,13 @@ static TokenTableEntry TokenTable2C[] = {
     {"rp", LFT_REQUEST_URLPATH_OLD_31},
     /* { "rq", LFT_REQUEST_QUERY }, * /     / * the query-string, INCLUDING the leading ? */
     {"rv", LFT_REQUEST_VERSION},
+    {"rG", LFT_REQUEST_URLGROUP_OLD_2X},
 
     {"<rm", LFT_SERVER_REQ_METHOD},
     {"<ru", LFT_SERVER_REQ_URI},
+    {"<rs", LFT_SERVER_REQ_URLSCHEME},
+    {"<rd", LFT_SERVER_REQ_URLDOMAIN},
+    {"<rP", LFT_SERVER_REQ_URLPORT},
     {"<rp", LFT_SERVER_REQ_URLPATH},
     /*{"<rq", LFT_SERVER_REQ_QUERY},*/
     {"<rv", LFT_SERVER_REQ_VERSION},
@@ -407,6 +413,8 @@ Format::Token::parse(const char *def, Quoting *quoting)
 
     case LFT_REPLY_HEADER:
 
+    case LFT_NOTE:
+
         if (data.string) {
             char *header = data.string;
             char *cp = strchr(header, ':');
@@ -534,13 +542,36 @@ Format::Token::parse(const char *def, Quoting *quoting)
         break;
 #endif
 
+    case LFT_REQUEST_URLGROUP_OLD_2X:
+        debugs(46, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: The \"rG\" formatting code is deprecated. Use \"note{urlgroup}\" instead.");
+        type = LFT_NOTE;
+        data.header.header = xstrdup("urlgroup");
+        break;
+
     default:
         break;
     }
 
     return (cur - def);
 }
 
+Format::Token::Token() : type(LFT_NONE),
+        label(NULL),
+        widthMin(-1),
+        widthMax(-1),
+        quote(LOG_QUOTE_NONE),
+        left(false),
+        space(false),
+        zero(false),
+        divisor(1),
+        next(NULL)
+{
+    data.string = NULL;
+    data.header.header = NULL;
+    data.header.element = NULL;
+    data.header.separator = ',';
+}
+
 Format::Token::~Token()
 {
     label = NULL; // drop reference to global static.
@@ -27,18 +27,7 @@ class TokenTableEntry;
 class Token
 {
 public:
-    Token() : type(LFT_NONE),
-            label(NULL),
-            widthMin(-1),
-            widthMax(-1),
-            quote(LOG_QUOTE_NONE),
-            left(false),
-            space(false),
-            zero(false),
-            divisor(1),
-            next(NULL)
-    { data.string = NULL; }
-
+    Token();
     ~Token();
 
     /// Initialize the format token registrations
@@ -52,15 +41,14 @@ class Token
 
     ByteCode_t type;
     const char *label;
-    union {
+    struct {
         char *string;
 
         struct {
             char *header;
             char *element;
             char separator;
         } header;
-        char *timespec;
     } data;
     int widthMin; ///< minimum field width
     int widthMax; ///< maximum field width
@@ -2590,7 +2590,7 @@ ftpSendPassive(FtpStateData * ftpState)
             }
         }
     }
-        break;
+    break;
     }
 
     ftpState->writeCommand(cbuf);
@@ -26,6 +26,7 @@ typedef enum {
     SOURCEHASH_PARENT,
     PINNED,
     ORIGINAL_DST,
+    STANDBY_POOL,
     HIER_MAX
 } hier_code;
 
@@ -8,12 +8,15 @@ namespace Http
 
 /**
  * Stores HTTP version label information.
- * For example HTTP/1.0
+ *
+ * Squid being conditionally compliant with RFC 2616
+ * on both client and server connections the default
+ * value is HTTP/1.1.
  */
 class ProtocolVersion : public AnyP::ProtocolVersion
 {
 public:
-    ProtocolVersion() : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,0) {}
+    ProtocolVersion() : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1) {}
 
     ProtocolVersion(unsigned int aMajor, unsigned int aMinor) : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,aMajor,aMinor) {}
 };
@@ -7,12 +7,12 @@ Http::StatusCodeString(const Http::StatusCode status)
 {
     switch (status) {
 
-    // 000
+        // 000
     case Http::scNone:
         return "Init";		/* we init .status with code 0 */
         break;
 
-    // 100-199
+        // 100-199
     case Http::scContinue:
         return "Continue";
         break;
@@ -25,7 +25,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Processing";
         break;
 
-    // 200-299
+        // 200-299
     case Http::scOkay:
         return "OK";
         break;
@@ -66,7 +66,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "IM Used";
         break;
 
-    // 300-399
+        // 300-399
     case Http::scMultipleChoices:
         return "Multiple Choices";
         break;
@@ -99,7 +99,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Permanent Redirect";
         break;
 
-    // 400-499
+        // 400-499
     case Http::scBadRequest:
         return "Bad Request";
         break;
@@ -200,7 +200,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Request Header Fields Too Large";
         break;
 
-    // 500-599
+        // 500-599
     case Http::scInternalServerError:
         return "Internal Server Error";
         break;
@@ -245,7 +245,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Network Authentication Required";
         break;
 
-    // 600+
+        // 600+
     case Http::scInvalidHeader:
     case Http::scHeaderTooLarge:
         // fall through to default.
@@ -292,7 +292,11 @@ usage(void)
 #if USE_WIN32_SERVICE
             "       -i        Installs as a Windows Service (see -n option).\n"
 #endif
-            "       -k reconfigure|rotate|shutdown|interrupt|kill|debug|check|parse\n"
+            "       -k reconfigure|rotate|shutdown|"
+#ifdef SIGTTIN
+            "restart|"
+#endif
+            "interrupt|kill|debug|check|parse\n"
             "                 Parse configuration file, then send signal to \n"
             "                 running copy (except -k parse) and exit.\n"
             "       -n name   Specify service name to use for service operations\n"
@@ -497,7 +501,7 @@ mainParseOptions(int argc, char *argv[])
                 fatal("Need to add -DMALLOC_DBG when compiling to use -mX option");
 #endif
 
-            } 
+            }
             break;
 
         case 'n':
@@ -54,7 +54,9 @@
 #include "multicast.h"
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
+#include "pconn.h"
 #include "PeerDigest.h"
+#include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
@@ -246,13 +248,46 @@ peerWouldBePinged(const CachePeer * p, HttpRequest * request)
     return 1;
 }
 
+bool
+peerCanOpenMore(const CachePeer *p)
+{
+    const int effectiveLimit = p->max_conn <= 0 ? Squid_MaxFD : p->max_conn;
+    const int remaining = effectiveLimit - p->stats.conn_open;
+    debugs(15, 7, remaining << '=' << effectiveLimit << '-' << p->stats.conn_open);
+    return remaining > 0;
+}
+
+bool
+peerHasConnAvailable(const CachePeer *p)
+{
+    // Standby connections can be used without opening new connections.
+    const int standbys = p->standby.pool ? p->standby.pool->count() : 0;
+
+    // XXX: Some idle pconns can be used without opening new connections.
+    // Complication: Idle pconns cannot be reused for some requests.
+    const int usableIdles = 0;
+
+    const int available = standbys + usableIdles;
+    debugs(15, 7, available << '=' << standbys << '+' << usableIdles);
+    return available > 0;
+}
+
+void
+peerConnClosed(CachePeer *p)
+{
+    --p->stats.conn_open;
+    if (p->standby.waitingForClose && peerCanOpenMore(p)) {
+        p->standby.waitingForClose = false;
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "conn closed");
+    }
+}
+
 /* Return TRUE if it is okay to send an HTTP request to this CachePeer. */
 int
 peerHTTPOkay(const CachePeer * p, HttpRequest * request)
 {
-    if (p->max_conn)
-        if (p->stats.conn_open >= p->max_conn)
-            return 0;
+    if (!peerCanOpenMore(p) && !peerHasConnAvailable(p))
+        return 0;
 
     if (!peerAllowedToUse(p, request))
         return 0;
@@ -432,7 +467,7 @@ peerClearRR()
 {
     CachePeer *p = NULL;
     for (p = Config.peers; p; p = p->next) {
-        p->rr_count = 0;
+        p->rr_count = 1;
     }
 }
 
@@ -446,6 +481,8 @@ peerAlive(CachePeer *p)
         debugs(15, DBG_IMPORTANT, "Detected REVIVED " << neighborTypeStr(p) << ": " << p->name);
         p->stats.logged_state = PEER_ALIVE;
         peerClearRR();
+        if (p->standby.mgr.valid())
+            PeerPoolMgr::Checkpoint(p->standby.mgr, "revived peer");
     }
 
     p->stats.last_reply = squid_curtime;
@@ -1190,6 +1227,9 @@ peerNoteDigestGone(CachePeer * p)
 static void
 peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 {
+    // TODO: connections to no-longer valid IP addresses should be
+    // closed when we can detect such IP addresses.
+
     CachePeer *p = (CachePeer *)data;
 
     int j;
@@ -1229,11 +1269,13 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
         peerCountMcastPeersSchedule(p, 10);
 
 #if USE_ICMP
-    if (p->type != PEER_MULTICAST)
+    if (p->type != PEER_MULTICAST && IamWorkerProcess())
         if (!p->options.no_netdb_exchange)
             eventAddIsh("netdbExchangeStart", netdbExchangeStart, p, 30.0, 1);
 #endif
 
+    if (p->standby.mgr.valid())
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "resolved peer");
 }
 
 static void
@@ -1565,6 +1607,8 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
 
     if (p->max_conn > 0)
         storeAppendPrintf(sentry, " max-conn=%d", p->max_conn);
+    if (p->standby.limit > 0)
+        storeAppendPrintf(sentry, " standby=%d", p->standby.limit);
 
     if (p->options.originserver)
         storeAppendPrintf(sentry, " originserver");
@@ -81,6 +81,13 @@ void peerConnectSucceded(CachePeer *);
 void dump_peer_options(StoreEntry *, CachePeer *);
 int peerHTTPOkay(const CachePeer *, HttpRequest *);
 
+/// Whether we can open new connections to the peer (e.g., despite max-conn)
+bool peerCanOpenMore(const CachePeer *p);
+/// Whether the peer has idle or standby connections that can be used now
+bool peerHasConnAvailable(const CachePeer *p);
+/// Notifies peer of an associated connection closure.
+void peerConnClosed(CachePeer *p);
+
 CachePeer *whichPeer(const Ip::Address &from);
 
 #endif /* SQUID_NEIGHBORS_H_ */
@@ -31,13 +31,16 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "mgr/Registration.h"
+#include "neighbors.h"
 #include "pconn.h"
+#include "PeerPoolMgr.h"
 #include "SquidConfig.h"
 #include "Store.h"
 
@@ -64,6 +67,11 @@ IdleConnList::~IdleConnList()
     if (parent_)
         parent_->unlinkList(this);
 
+    if (size_) {
+        parent_ = NULL; // prevent reentrant notifications and deletions
+        closeN(size_);
+    }
+
     delete[] theList_;
 
     xfree(hash.key);
@@ -292,6 +300,8 @@ IdleConnList::findAndClose(const Comm::ConnectionPointer &conn)
 {
     const int index = findIndexOf(conn);
     if (index >= 0) {
+        if (parent_)
+            parent_->notifyManager("idle conn closure");
         /* might delete this */
         removeAt(index);
         clearHandlers(conn);
@@ -366,15 +376,17 @@ PconnPool::dumpHash(StoreEntry *e) const
     hash_first(hid);
 
     int i = 0;
-    for (hash_link *walker = hid->next; walker; walker = hash_next(hid)) {
+    for (hash_link *walker = hash_next(hid); walker; walker = hash_next(hid)) {
         storeAppendPrintf(e, "\t item %d:\t%s\n", i, (char *)(walker->key));
         ++i;
     }
 }
 
 /* ========== PconnPool PUBLIC FUNCTIONS ============================================ */
 
-PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
+PconnPool::PconnPool(const char *aDescr, const CbcPointer<PeerPoolMgr> &aMgr):
+        table(NULL), descr(aDescr),
+        mgr(aMgr),
         theCount(0)
 {
     int i;
@@ -386,10 +398,18 @@ PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
     PconnModule::GetInstance()->add(this);
 }
 
+static void
+DeleteIdleConnList(void *hashItem)
+{
+    delete reinterpret_cast<IdleConnList*>(hashItem);
+}
+
 PconnPool::~PconnPool()
 {
-    descr = NULL;
+    PconnModule::GetInstance()->remove(this);
+    hashFreeItems(table, &DeleteIdleConnList);
     hashFreeMemory(table);
+    descr = NULL;
 }
 
 void
@@ -404,6 +424,7 @@ PconnPool::push(const Comm::ConnectionPointer &conn, const char *domain)
         debugs(48, 3, HERE << "Squid is shutting down. Refusing to do anything");
         return;
     }
+    // TODO: also close used pconns if we exceed peer max-conn limit
 
     const char *aKey = key(conn, domain);
     IdleConnList *list = (IdleConnList *) hash_lookup(table, aKey);
@@ -423,35 +444,64 @@ PconnPool::push(const Comm::ConnectionPointer &conn, const char *domain)
     snprintf(desc, FD_DESC_SZ, "Idle server: %s", aKey);
     fd_note(conn->fd, desc);
     debugs(48, 3, HERE << "pushed " << conn << " for " << aKey);
+
+    // successful push notifications resume multi-connection opening sequence
+    notifyManager("push");
 }
 
 Comm::ConnectionPointer
-PconnPool::pop(const Comm::ConnectionPointer &destLink, const char *domain, bool isRetriable)
+PconnPool::pop(const Comm::ConnectionPointer &dest, const char *domain, bool keepOpen)
 {
-    const char * aKey = key(destLink, domain);
+
+    const char * aKey = key(dest, domain);
 
     IdleConnList *list = (IdleConnList *)hash_lookup(table, aKey);
     if (list == NULL) {
         debugs(48, 3, HERE << "lookup for key {" << aKey << "} failed.");
+        // failure notifications resume standby conn creation after fdUsageHigh
+        notifyManager("pop failure");
         return Comm::ConnectionPointer();
     } else {
-        debugs(48, 3, HERE << "found " << hashKeyStr(&list->hash) << (isRetriable?"(to use)":"(to kill)") );
+        debugs(48, 3, HERE << "found " << hashKeyStr(&list->hash) <<
+               (keepOpen ? " to use" : " to kill"));
     }
 
     /* may delete list */
-    Comm::ConnectionPointer temp = list->findUseable(destLink);
-    if (!isRetriable && Comm::IsConnOpen(temp))
-        temp->close();
+    Comm::ConnectionPointer popped = list->findUseable(dest);
+    if (!keepOpen && Comm::IsConnOpen(popped))
+        popped->close();
+
+    // successful pop notifications replenish standby connections pool
+    notifyManager("pop");
+    return popped;
+}
 
-    return temp;
+void
+PconnPool::notifyManager(const char *reason)
+{
+    if (mgr.valid())
+        PeerPoolMgr::Checkpoint(mgr, reason);
 }
 
 void
-PconnPool::closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain)
+PconnPool::closeN(int n)
 {
-    // TODO: optimize: we can probably do hash_lookup just once
-    for (int i = 0; i < n; ++i)
-        pop(destLink, domain, false); // may fail!
+    hash_table *hid = table;
+    hash_first(hid);
+
+    // close N connections, one per list, to treat all lists "fairly"
+    for (int i = 0; i < n && count(); ++i) {
+
+        hash_link *current = hash_next(hid);
+        if (!current) {
+            hash_first(hid);
+            current = hash_next(hid);
+            Must(current); // must have one because the count() was positive
+        }
+
+        // may delete current
+        reinterpret_cast<IdleConnList*>(current)->closeN(1);
+    }
 }
 
 void
@@ -477,11 +527,8 @@ PconnPool::noteUses(int uses)
  * This simple class exists only for the cache manager
  */
 
-PconnModule::PconnModule() : pools(NULL), poolCount(0)
+PconnModule::PconnModule(): pools()
 {
-    pools = (PconnPool **) xcalloc(MAX_NUM_PCONN_POOLS, sizeof(*pools));
-//TODO: re-link to MemPools. WAS:    pconn_fds_pool = memPoolCreate("pconn_fds", PCONN_FDS_SZ * sizeof(int));
-    debugs(48, DBG_CRITICAL, "persistent connection module initialized");
     registerWithCacheManager();
 }
 
@@ -505,21 +552,26 @@ PconnModule::registerWithCacheManager(void)
 void
 PconnModule::add(PconnPool *aPool)
 {
-    assert(poolCount < MAX_NUM_PCONN_POOLS);
-    *(pools+poolCount) = aPool;
-    ++poolCount;
+    pools.insert(aPool);
 }
 
 void
-PconnModule::dump(StoreEntry *e)
+PconnModule::remove(PconnPool *aPool)
 {
-    int i;
+    pools.erase(aPool);
+}
 
-    for (i = 0; i < poolCount; ++i) {
+void
+PconnModule::dump(StoreEntry *e)
+{
+    typedef Pools::const_iterator PCI;
+    int i = 0; // TODO: Why number pools if they all have names?
+    for (PCI p = pools.begin(); p != pools.end(); ++p, ++i) {
+        // TODO: Let each pool dump itself the way it wants to.
         storeAppendPrintf(e, "\n Pool %d Stats\n", i);
-        (*(pools+i))->dumpHist(e);
+        (*p)->dumpHist(e);
         storeAppendPrintf(e, "\n Pool %d Hash Table\n",i);
-        (*(pools+i))->dumpHash(e);
+        (*p)->dumpHash(e);
     }
 }
 
@@ -1,6 +1,9 @@
 #ifndef SQUID_PCONN_H
 #define SQUID_PCONN_H
 
+#include "base/CbcPointer.h"
+#include <set>
+
 /**
  \defgroup PConnAPI Persistent Connection API
  \ingroup Component
@@ -9,6 +12,7 @@
  */
 
 class PconnPool;
+class PeerPoolMgr;
 
 /* for CBDATA_CLASS2() macros */
 #include "cbdata.h"
@@ -17,9 +21,6 @@ class PconnPool;
 /* for IOCB */
 #include "comm.h"
 
-/// \ingroup PConnAPI
-#define MAX_NUM_PCONN_POOLS 10
-
 /// \ingroup PConnAPI
 #define PCONN_HIST_SZ (1<<16)
 
@@ -106,38 +107,46 @@ class PconnPool
 {
 
 public:
-    PconnPool(const char *);
+    PconnPool(const char *aDescription, const CbcPointer<PeerPoolMgr> &aMgr);
     ~PconnPool();
 
     void moduleInit();
     void push(const Comm::ConnectionPointer &serverConn, const char *domain);
 
     /**
-     * Updates destLink to point at an existing open connection if available and retriable.
-     * Otherwise, return false.
+     * Returns either a pointer to a popped connection to dest or nil.
+     * Closes the connection before returning its pointer unless keepOpen.
      *
-     * We close available persistent connection if the caller transaction is not
-     * retriable to avoid having a growing number of open connections when many
-     * transactions create persistent connections but are not retriable.
+     * A caller with a non-retriable transaction should set keepOpen to false
+     * and call pop() anyway, even though the caller does not want a pconn.
+     * This forces us to close an available persistent connection, avoiding
+     * creating a growing number of open connections when many transactions
+     * create (and push) persistent connections but are not retriable and,
+     * hence, do not need to pop a connection.
      */
-    Comm::ConnectionPointer pop(const Comm::ConnectionPointer &destLink, const char *domain, bool retriable);
+    Comm::ConnectionPointer pop(const Comm::ConnectionPointer &dest, const char *domain, bool keepOpen);
     void count(int uses);
     void dumpHist(StoreEntry *e) const;
     void dumpHash(StoreEntry *e) const;
     void unlinkList(IdleConnList *list);
     void noteUses(int uses);
-    void closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain);
+    /// closes any n connections, regardless of their destination
+    void closeN(int n);
     int count() const { return theCount; }
     void noteConnectionAdded() { ++theCount; }
     void noteConnectionRemoved() { assert(theCount > 0); --theCount; }
 
+    // sends an async message to the pool manager, if any
+    void notifyManager(const char *reason);
+
 private:
 
     static const char *key(const Comm::ConnectionPointer &destLink, const char *domain);
 
     int hist[PCONN_HIST_SZ];
     hash_table *table;
     const char *descr;
+    CbcPointer<PeerPoolMgr> mgr; ///< optional pool manager (for notifications)
     int theCount; ///< the number of pooled connections
 };
 
@@ -162,15 +171,15 @@ class PconnModule
     void registerWithCacheManager(void);
 
     void add(PconnPool *);
+    void remove(PconnPool *); ///< unregister and forget about this pool object
 
     OBJH dump;
 
 private:
-    PconnPool **pools;
+    typedef std::set<PconnPool*> Pools; ///< unordered PconnPool collection
+    Pools pools; ///< all live pools
 
     static PconnModule * instance;
-
-    int poolCount;
 };
 
 #endif /* SQUID_PCONN_H */
@@ -131,8 +131,7 @@ redirectHandleReply(void *data, const HelperReply &reply)
                  * At this point altering the helper buffer in that way is not harmful, but annoying.
                  * When Bug 1961 is resolved and urlParse has a const API, this needs to die.
                  */
-                const char * result = reply.other().content();
-                const Http::StatusCode status = static_cast<Http::StatusCode>(atoi(result));
+                char * result = reply.modifiableOther().content();
 
                 HelperReply newReply;
                 // BACKWARD COMPATIBILITY 2012-06-15:
@@ -142,6 +141,20 @@ redirectHandleReply(void *data, const HelperReply &reply)
                 newReply.result = HelperReply::Okay;
                 newReply.notes.append(&reply.notes);
 
+                // check and parse for obsoleted Squid-2 urlgroup feature
+                if (*result == '!') {
+                    static int urlgroupWarning = 0;
+                    if (!urlgroupWarning++)
+                        debugs(85, DBG_IMPORTANT, "UPGRADE WARNING: URL rewriter using obsolete Squid-2 urlgroup feature needs updating.");
+                    if (char *t = strchr(result+1, '!')) {
+                        *t = '\0';
+                        newReply.notes.add("urlgroup", result+1);
+                        result = t + 1;
+                    }
+                }
+
+                const Http::StatusCode status = static_cast<Http::StatusCode>(atoi(result));
+
                 if (status == Http::scMovedPermanently
                         || status == Http::scFound
                         || status == Http::scSeeOther
@@ -162,7 +175,8 @@ redirectHandleReply(void *data, const HelperReply &reply)
                     // status code is not a redirect code (or does not exist)
                     // treat as a re-write URL request
                     // TODO: validate the URL produced here is RFC 2616 compliant URI
-                    newReply.notes.add("rewrite-url", reply.other().content());
+                    if (*result)
+                        newReply.notes.add("rewrite-url", result);
                 }
 
                 void *cbdata;
@@ -23,7 +23,6 @@
 #include "ssl/PeerConnector.h"
 #include "ssl/ServerBump.h"
 #include "ssl/support.h"
-#include "SquidConfig.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Ssl, PeerConnector);
 
@@ -32,11 +31,11 @@ Ssl::PeerConnector::PeerConnector(
     const Comm::ConnectionPointer &aServerConn,
     const Comm::ConnectionPointer &aClientConn,
     AsyncCall::Pointer &aCallback):
-    AsyncJob("Ssl::PeerConnector"),
-    request(aRequest),
-    serverConn(aServerConn),
-    clientConn(aClientConn),
-    callback(aCallback)
+        AsyncJob("Ssl::PeerConnector"),
+        request(aRequest),
+        serverConn(aServerConn),
+        clientConn(aClientConn),
+        callback(aCallback)
 {
     // if this throws, the caller's cb dialer is not our CbDialer
     Must(dynamic_cast<CbDialer*>(callback->getDialer()));
@@ -137,6 +136,9 @@ Ssl::PeerConnector::initializeSsl()
             SSL_set_session(ssl, peer->sslSession);
 
     } else if (request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) {
+        // client connection is required for Peek or Stare mode in the case we need to splice
+        // or terminate client and server connections
+        assert(clientConn != NULL);
         SSL *clientSsl = fd_table[request->clientConnectionManager->clientConnection->fd].ssl;
         BIO *b = SSL_get_rbio(clientSsl);
         Ssl::ClientBio *clnBio = static_cast<Ssl::ClientBio *>(b->ptr);
@@ -464,56 +466,56 @@ Ssl::PeerConnector::handleNegotiateError(const int ret)
     Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
 
 #ifdef EPROTO
-        int sysErrNo = EPROTO;
+    int sysErrNo = EPROTO;
 #else
-        int sysErrNo = EACCES;
+    int sysErrNo = EACCES;
 #endif
 
-        switch (ssl_error) {
+    switch (ssl_error) {
 
-        case SSL_ERROR_WANT_READ:
-            Comm::SetSelect(fd, COMM_SELECT_READ, &NegotiateSsl, this, 0);
-            return;
+    case SSL_ERROR_WANT_READ:
+        Comm::SetSelect(fd, COMM_SELECT_READ, &NegotiateSsl, this, 0);
+        return;
 
-        case SSL_ERROR_WANT_WRITE:
-            if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
-                debugs(81, DBG_IMPORTANT, "hold write on SSL connection on FD " << fd);
-                checkForPeekAndSplice(false, Ssl::bumpNone);
-                return;
-            }
-            Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
+    case SSL_ERROR_WANT_WRITE:
+        if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
+            debugs(81, DBG_IMPORTANT, "hold write on SSL connection on FD " << fd);
+            checkForPeekAndSplice(false, Ssl::bumpNone);
             return;
+        }
+        Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
+        return;
 
-        case SSL_ERROR_SSL:
-        case SSL_ERROR_SYSCALL:
-            ssl_lib_error = ERR_get_error();
+    case SSL_ERROR_SSL:
+    case SSL_ERROR_SYSCALL:
+        ssl_lib_error = ERR_get_error();
 
-            // If we are in peek-and-splice mode and still we did not write to
-            // server yet, try to see if we should splice.
-            // In this case the connection can be saved.
-            // If the checklist decision is do not splice a new error will
-            // occure in the next SSL_connect call, and we will fail again.
+        // If we are in peek-and-splice mode and still we did not write to
+        // server yet, try to see if we should splice.
+        // In this case the connection can be saved.
+        // If the checklist decision is do not splice a new error will
+        // occure in the next SSL_connect call, and we will fail again.
 #if 1
-            if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
-                debugs(81, DBG_IMPORTANT, "fwdNegotiateSSL: Error but, hold write on SSL connection on FD " << fd);
-                checkForPeekAndSplice(false, Ssl::bumpNone);
-                return;
-            }
+        if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
+            debugs(81, DBG_IMPORTANT, "fwdNegotiateSSL: Error but, hold write on SSL connection on FD " << fd);
+            checkForPeekAndSplice(false, Ssl::bumpNone);
+            return;
+        }
 #endif
 
-            // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
-            if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
-                sysErrNo = errno;
+        // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
+        if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
+            sysErrNo = errno;
 
-            debugs(83, DBG_IMPORTANT, "Error negotiating SSL on FD " << fd <<
-                   ": " << ERR_error_string(ssl_lib_error, NULL) << " (" <<
-                   ssl_error << "/" << ret << "/" << errno << ")");
+        debugs(83, DBG_IMPORTANT, "Error negotiating SSL on FD " << fd <<
+               ": " << ERR_error_string(ssl_lib_error, NULL) << " (" <<
+               ssl_error << "/" << ret << "/" << errno << ")");
 
-            break; // proceed to the general error handling code
+        break; // proceed to the general error handling code
 
-        default:
-            break; // no special error handling for all other errors
-        }
+    default:
+        break; // no special error handling for all other errors
+    }
 
     ErrorState *const anErr = ErrorState::NewForwarding(ERR_SECURE_CONNECT_FAIL, request.getRaw());
     anErr->xerrno = sysErrNo;
@@ -605,7 +607,6 @@ Ssl::PeerConnector::callBack()
     ScheduleCallHere(cb);
 }
 
-
 void
 Ssl::PeerConnector::swanSong()
 {
@@ -643,7 +644,7 @@ Ssl::PeerConnectorAnswer::~PeerConnectorAnswer()
 }
 
 std::ostream &
-operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &answer)
+Ssl::operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &answer)
 {
     return os << answer.conn << ", " << answer.error;
 }
@@ -29,22 +29,25 @@
 #ifndef SQUID_SSL_PEER_CONNECTOR_H
 #define SQUID_SSL_PEER_CONNECTOR_H
 
-#include "base/AsyncJob.h"
+#include "acl/Acl.h"
 #include "base/AsyncCbdataCalls.h"
+#include "base/AsyncJob.h"
 #include "ssl/support.h"
 #include <iosfwd>
 
 class HttpRequest;
 class ErrorState;
 
-namespace Ssl {
+namespace Ssl
+{
 
 class ErrorDetail;
 class CertValidationResponse;
 
 /// PeerConnector results (supplied via a callback).
 /// The connection to peer was secured if and only if the error member is nil.
-class PeerConnectorAnswer {
+class PeerConnectorAnswer
+{
 public:
     ~PeerConnectorAnswer(); ///< deletes error if it is still set
     Comm::ConnectionPointer conn; ///< peer connection (secured on success)
@@ -80,12 +83,13 @@ class PeerConnectorAnswer {
  \par
  * This job never closes the connection, even on errors. If a 3rd-party
  * closes the connection, this job simply quits without informing the caller.
-*/ 
+*/
 class PeerConnector: virtual public AsyncJob
 {
 public:
     /// Callback dialier API to allow PeerConnector to set the answer.
-    class CbDialer {
+    class CbDialer
+    {
     public:
         virtual ~CbDialer() {}
         /// gives PeerConnector access to the in-dialer answer
@@ -140,7 +144,7 @@ class PeerConnector: virtual public AsyncJob
     /// mimics FwdState to minimize changes to FwdState::initiate/negotiateSsl
     Comm::ConnectionPointer const &serverConnection() const { return serverConn; }
 
-    void bail(ErrorState *error); ///< Return an error to the PeerConnector caller 
+    void bail(ErrorState *error); ///< Return an error to the PeerConnector caller
 
     /// Callback the caller class, and pass the ready to communicate secure
     /// connection or an error if PeerConnector failed.
@@ -170,8 +174,8 @@ class PeerConnector: virtual public AsyncJob
     CBDATA_CLASS2(PeerConnector);
 };
 
-} // namespace Ssl
-
 std::ostream &operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &a);
 
+} // namespace Ssl
+
 #endif /* SQUID_PEER_CONNECTOR_H */
@@ -54,6 +54,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_mem.cc \
 	tests/stub_mem_node.cc \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_redirect.cc \
 	tests/stub_stat.cc \
@@ -0,0 +1,9 @@
+#include "squid.h"
+
+#define STUB_API "neighbors.cc"
+#include "tests/STUB.h"
+
+#include "neighbors.h"
+
+void
+peerConnClosed(CachePeer *p) STUB
@@ -13,7 +13,7 @@ IdleConnList::~IdleConnList() STUB
 void IdleConnList::push(const Comm::ConnectionPointer &conn) STUB
 Comm::ConnectionPointer IdleConnList::findUseable(const Comm::ConnectionPointer &key) STUB_RETVAL(Comm::ConnectionPointer())
 void IdleConnList::clearHandlers(const Comm::ConnectionPointer &conn) STUB
-PconnPool::PconnPool(const char *) STUB
+PconnPool::PconnPool(const char *, const CbcPointer<PeerPoolMgr>&) STUB
 PconnPool::~PconnPool() STUB
 void PconnPool::moduleInit() STUB
 void PconnPool::push(const Comm::ConnectionPointer &serverConn, const char *domain) STUB
@@ -183,13 +183,14 @@ class TunnelStateData
         typedef void (TunnelStateData::*Method)(Ssl::PeerConnectorAnswer &);
 
         MyAnswerDialer(Method method, TunnelStateData *tunnel):
-                       method_(method), tunnel_(tunnel), answer_() {}
+                method_(method), tunnel_(tunnel), answer_() {}
 
         /* CallDialer API */
         virtual bool canDial(AsyncCall &call) { return tunnel_.valid(); }
         void dial(AsyncCall &call) { ((&(*tunnel_))->*method_)(answer_); }
         virtual void print(std::ostream &os) const {
-            os << '(' << tunnel_.get() << ", " << answer_ << ')'; }
+            os << '(' << tunnel_.get() << ", " << answer_ << ')';
+        }
 
         /* Ssl::PeerConnector::CbDialer API */
         virtual Ssl::PeerConnectorAnswer &answer() { return answer_; }
@@ -955,16 +956,17 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
 }
 
 void
-TunnelStateData::connectToPeer() {
+TunnelStateData::connectToPeer()
+{
     const Comm::ConnectionPointer &srv = server.conn;
     const Comm::ConnectionPointer &cln = client.conn;
 
 #if USE_OPENSSL
     if (CachePeer *p = srv->getPeer()) {
         if (p->use_ssl) {
             AsyncCall::Pointer callback = asyncCall(5,4,
-                "TunnelStateData::ConnectedToPeer",
-                MyAnswerDialer(&TunnelStateData::connectedToPeer, this));
+                                                    "TunnelStateData::ConnectedToPeer",
+                                                    MyAnswerDialer(&TunnelStateData::connectedToPeer, this));
             Ssl::PeerConnector *connector =
                 new Ssl::PeerConnector(request, srv, cln, callback);
             AsyncJob::Start(connector); // will call our callback
@@ -508,21 +508,20 @@ urlCanonical(HttpRequest * request)
             snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
             break;
 
-        default:
-            {
-                portbuf[0] = '\0';
-
-                if (request->port != urlDefaultPort(request->url.getScheme()))
-                    snprintf(portbuf, 32, ":%d", request->port);
-
-                snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
-                         request->url.getScheme().c_str(),
-                         request->login,
-                         *request->login ? "@" : null_string,
-                         request->GetHost(),
-                         portbuf,
-                         SQUIDSTRINGPRINT(request->urlpath));
-            }
+        default: {
+            portbuf[0] = '\0';
+
+            if (request->port != urlDefaultPort(request->url.getScheme()))
+                snprintf(portbuf, 32, ":%d", request->port);
+
+            snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
+                     request->url.getScheme().c_str(),
+                     request->login,
+                     *request->login ? "@" : null_string,
+                     request->GetHost(),
+                     portbuf,
+                     SQUIDSTRINGPRINT(request->urlpath));
+        }
         }
     }
 
@@ -551,36 +550,35 @@ urlCanonicalClean(const HttpRequest * request)
             snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
             break;
 
-        default:
-            {
-                portbuf[0] = '\0';
-
-                if (request->port != urlDefaultPort(request->url.getScheme()))
-                    snprintf(portbuf, 32, ":%d", request->port);
+        default: {
+            portbuf[0] = '\0';
 
-                loginbuf[0] = '\0';
+            if (request->port != urlDefaultPort(request->url.getScheme()))
+                snprintf(portbuf, 32, ":%d", request->port);
 
-                if ((int) strlen(request->login) > 0) {
-                    strcpy(loginbuf, request->login);
+            loginbuf[0] = '\0';
 
-                    if ((t = strchr(loginbuf, ':')))
-                        *t = '\0';
+            if ((int) strlen(request->login) > 0) {
+                strcpy(loginbuf, request->login);
 
-                    strcat(loginbuf, "@");
-                }
+                if ((t = strchr(loginbuf, ':')))
+                    *t = '\0';
 
-                snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
-                         request->url.getScheme().c_str(),
-                         loginbuf,
-                         request->GetHost(),
-                         portbuf,
-                         SQUIDSTRINGPRINT(request->urlpath));
-
-                // strip arguments AFTER a question-mark
-                if (Config.onoff.strip_query_terms)
-                    if ((t = strchr(buf, '?')))
-                        *(++t) = '\0';
+                strcat(loginbuf, "@");
             }
+
+            snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
+                     request->url.getScheme().c_str(),
+                     loginbuf,
+                     request->GetHost(),
+                     portbuf,
+                     SQUIDSTRINGPRINT(request->urlpath));
+
+            // strip arguments AFTER a question-mark
+            if (Config.onoff.strip_query_terms)
+                if ((t = strchr(buf, '?')))
+                    *(++t) = '\0';
+        }
         }
     }
 
@@ -42,7 +42,7 @@ fi
 # but skip if we have no files to remove.
 FILECOUNT=`ls -1 | grep -c .`
 if test "${FILECOUNT}" != "0" ; then
-  make -k distclean || echo "distclean done. errors are unwanted but okay here."
+  ${MAKE:-make} -k distclean || echo "distclean done. errors are unwanted but okay here."
   ls -la .
   rm -fr ./src/fs/aufs/.deps src/fs/diskd/.deps
 fi
@@ -55,7 +55,7 @@ fi
 # eval is need to correctly handle quoted arguments
 	eval "$base/../configure ${DISTCHECK_CONFIGURE_FLAGS} ${configcache}" \
 		2>&1 && \
-	make ${pjobs} ${MAKETEST} 2>&1
+	${MAKE:-make} ${pjobs} ${MAKETEST} 2>&1
 
 # Remember and then explicitly return the result of the last command
 # to the script caller. Probably not needed on most or all platforms.
@@ -17,12 +17,11 @@ class TheConfig
 {
 public:
     TheConfig() :
-        ioTimeout(120),
-        localHost(NULL),
-        port(CACHE_HTTP_PORT),
-        tlsEnabled(false),
-        tlsAnonymous(false)
-    {
+            ioTimeout(120),
+            localHost(NULL),
+            port(CACHE_HTTP_PORT),
+            tlsEnabled(false),
+            tlsAnonymous(false) {
         params = "NORMAL";
         hostname = "localhost";
     }
@@ -122,13 +122,13 @@ usage(const char *progname)
               << "Usage: " << progname << " [Basic Options] [HTTP Options]" << std::endl
               << std::endl;
     std::cerr
-              << "    -s | --quiet    Silent.  Do not print response message to stdout." << std::endl
-              << "    -v | --verbose  Verbose debugging. Repeat (-vv) to increase output level." << std::endl
-              << "                    Levels:" << std::endl
-              << "                      1 - Print outgoing request message to stderr." << std::endl
-              << "                      2 - Print action trace to stderr." << std::endl
-              << "    --help          Display this help text." << std::endl
-              << std::endl;
+        << "    -s | --quiet    Silent.  Do not print response message to stdout." << std::endl
+        << "    -v | --verbose  Verbose debugging. Repeat (-vv) to increase output level." << std::endl
+        << "                    Levels:" << std::endl
+        << "                      1 - Print outgoing request message to stderr." << std::endl
+        << "                      2 - Print action trace to stderr." << std::endl
+        << "    --help          Display this help text." << std::endl
+        << std::endl;
     Transport::Config.usage();
     Ping::Config.usage();
     std::cerr