@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -15,7 +15,7 @@
 @SET_MAKE@
 
 #
-# $Id: Makefile.in,v 1.56 2003/07/23 00:13:24 hno Exp $
+# $Id: Makefile.in,v 1.57 2004/08/30 03:28:45 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -238,11 +238,11 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = README ./include/autoconf.h.in COPYING ChangeLog INSTALL \
-	Makefile.am Makefile.in TODO acinclude.m4 aclocal.m4 \
-	cfgaux/compile cfgaux/config.guess cfgaux/config.sub \
-	cfgaux/depcomp cfgaux/install-sh cfgaux/missing \
-	cfgaux/mkinstalldirs configure configure.in
+DIST_COMMON = README $(srcdir)/Makefile.in $(srcdir)/configure \
+	./include/autoconf.h.in COPYING ChangeLog INSTALL Makefile.am \
+	TODO acinclude.m4 aclocal.m4 cfgaux/compile cfgaux/config.guess \
+	cfgaux/config.sub cfgaux/depcomp cfgaux/install-sh \
+	cfgaux/missing cfgaux/mkinstalldirs configure configure.in
 all: all-recursive
 
 .SUFFIXES:
@@ -555,15 +555,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
 
 maintainer-clean-generic:
@@ -575,6 +575,7 @@ clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
 
 dvi: dvi-recursive
@@ -597,7 +598,8 @@ installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf autom4te.cache
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.7.4 -*- Autoconf -*-
+# generated automatically by aclocal 1.7.9 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002
 # Free Software Foundation, Inc.
@@ -253,7 +253,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],[am__api_version="1.7"])
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.7.4])])
+	 [AM_AUTOMAKE_VERSION([1.7.9])])
 
 # Helper functions for option handling.                    -*- Autoconf -*-
 
@@ -635,18 +635,32 @@ AC_CACHE_CHECK([dependency style of $depcc],
   # using a relative directory.
   cp "$am_depcomp" conftest.dir
   cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
 
   am_cv_$1_dependencies_compiler_type=none
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
   fi
   for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
     # We need to recreate these files for each test, as the compiler may
     # overwrite some of them when testing with obscure command lines.
     # This happens at least with the AIX C compiler.
-    echo '#include "conftest.h"' > conftest.c
-    echo 'int i;' > conftest.h
-    echo "${am__include} ${am__quote}conftest.Po${am__quote}" > confmf
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      : > sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
     case $depmode in
     nosideeffect)
@@ -664,11 +678,12 @@ AC_CACHE_CHECK([dependency style of $depcc],
     # mode.  It turns out that the SunPro C++ compiler does not properly
     # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=conftest.c object=conftest.o \
-       depfile=conftest.Po tmpdepfile=conftest.TPo \
-       $SHELL ./depcomp $depcc -c -o conftest.o conftest.c \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep conftest.h conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # (even with -Werror).  So we grep stderr for any message
@@ -803,7 +818,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 
 # Check to see how 'make' treats includes.	-*- Autoconf -*-
 
-# Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -828,8 +843,9 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 AC_DEFUN([AM_MAKE_INCLUDE],
 [am_make=${MAKE-make}
 cat > confinc << 'END'
-doit:
+am__doit:
 	@echo done
+.PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
 AC_MSG_CHECKING([for style of include used by $am_make])
@@ -857,9 +873,9 @@ if test "$am__include" = "#"; then
       _am_result=BSD
    fi
 fi
-AC_SUBST(am__include)
-AC_SUBST(am__quote)
-AC_MSG_RESULT($_am_result)
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
 rm -f confinc confmf
 ])
 
@@ -76,8 +76,9 @@ do
 	    perl -i.bak -p -e 's/m4_patsubst/m4_bpatsubst/g; s/m4_regexp/m4_bregexp/g;' aclocal.m4
 	fi
 	bootstrap autoheader$acver
+	bootstrap libtoolize --automake
 	bootstrap automake$amver --foreign --add-missing
-	bootstrap autoconf$acver ); then
+	bootstrap autoconf$acver); then
 	    : # OK
 	else
 	    exit 1
@@ -3,7 +3,7 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.356 2004/07/13 01:01:19 hno Exp $
+dnl  $Id: configure.in,v 1.357 2004/08/30 03:28:45 robertc Exp $
 dnl
 dnl
 dnl
@@ -13,7 +13,7 @@ AC_CONFIG_SRCDIR([src/main.cc])
 AC_CONFIG_AUX_DIR(cfgaux)
 AM_INIT_AUTOMAKE(squid, 3.0-PRE3-CVS)
 AM_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.356 $)dnl
+AC_REVISION($Revision: 1.357 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AM_MAINTAINER_MODE
 
@@ -30,6 +30,8 @@ AC_LANG_C
 AC_PROG_CXX
 AM_PROG_CC_C_O
 AC_CANONICAL_HOST
+AM_PROG_LIBTOOL
+AC_LTDL_DLLIB
 
 
 CRYPTLIB=''
@@ -1103,9 +1105,14 @@ if test -n "$AUTH_MODULES"; then
     AUTH_OBJS="auth/lib`echo $AUTH_MODULES|sed -e 's% %.a auth/lib%g'`.a"
     AUTH_LIBS="`echo $AUTH_OBJS|sed -e 's%auth/%%g'`"
 fi
+AUTH_LINKOBJS=
+for module in $AUTH_MODULES; do
+  AUTH_LINKOBJS="$AUTH_LINKOBJS auth/${module}/${module}Scheme.o"
+done
 AC_SUBST(AUTH_MODULES)
-AC_SUBST(AUTH_OBJS)
 AC_SUBST(AUTH_LIBS)
+AC_SUBST(AUTH_LINKOBJS)
+AC_SUBST(AUTH_OBJS)
 
 dnl Select basic auth scheme helpers to build
 BASIC_AUTH_HELPERS=""
@@ -1372,6 +1379,42 @@ AC_ARG_WITH(filedescriptors,
 [  --with-filedescriptors=NUMBER Force squid to support NUMBER filedescriptors],
 [ squid_filedescriptors_num=$withval ])
 
+# FIXME, try linking in a test program first, then if that fails try probing etc.
+SQUID_CPPUNIT_DIR='cppunit-1.10.0'
+SQUID_CPPUNIT_LA='$(top_builddir)/lib/cppunit-1.10.0/src/cppunit/libcppunit.la' 
+SQUID_CPPUNIT_INC='-I$(top_builddir)/lib/cppunit-1.10.0/include -I $(top_srcdir)/lib/cppunit-1.10.0/include'
+if test -f /usr/include/cppunit/TestCase.h; then
+  echo "using system installed cppunit"
+  SQUID_CPPUNIT_DIR=''
+  SQUID_CPPUNIT_LA='/usr/lib/libcppunit.la'
+  SQUID_CPPUNIT_INC=''
+fi
+AC_ARG_WITH(cppunit-basedir,
+[  --with-cppunit-basedir=/path/to/cppunit-base
+                          Path where the cppunit headers are libraries are found
+			  for unit testing. (defaults to use internal copies -
+			  version 1.10.0)
+			  ],
+[ if test -f $withval/include/cppunit/TestCase.h; then
+	echo "Using cppunit includes from $withval"
+	SQUID_CPPUNIT_INC="-I${withval}/include"
+    else
+	echo "ERROR: Cannot find cppunit at $withval"
+	exit 1
+    fi
+  if test -f $withval/lib/libcppunit.la; then
+	echo "Using cppunit lib from $withval"
+	SQUID_CPPUNIT_LA="-I${withval}/lib/libcppunit.la"
+    else
+	echo "ERROR: Cannot find cppunit at $withval"
+	exit 1
+    fi
+  SQUID_CPPUNIT_DIR=''
+])
+AC_SUBST(SQUID_CPPUNIT_LA)
+AC_SUBST(SQUID_CPPUNIT_INC)
+AC_SUBST(SQUID_CPPUNIT_DIR)
+
 # Force some compilers to use ANSI features
 #
 case "$host" in
@@ -2609,5 +2652,6 @@ AC_CONFIG_FILES([\
 ])
 
 AC_CONFIG_SUBDIRS(lib/libTrie)
+AC_CONFIG_SUBDIRS(lib/cppunit-1.10.0)
 
 AC_OUTPUT
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -233,7 +233,7 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/cfgaux/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -297,15 +297,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -315,7 +315,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -337,7 +337,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.36 2003/07/23 00:13:27 hno Exp $
+#  $Id: Makefile.in,v 1.37 2004/08/30 03:28:45 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -227,7 +227,7 @@ DIST_SOURCES =
 
 NROFF = nroff
 MANS = $(man_MANS)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -328,7 +328,6 @@ all-am: Makefile $(MANS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(man8dir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -340,15 +339,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -358,7 +357,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -380,7 +379,7 @@ install-man: install-man8
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -15,7 +15,7 @@
 @SET_MAKE@
 
 #
-# $Id: Makefile.in,v 1.53 2003/07/23 00:13:31 hno Exp $
+# $Id: Makefile.in,v 1.54 2004/08/30 03:28:46 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -247,7 +247,7 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/cfgaux/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -303,7 +303,6 @@ check: check-am
 all-am: Makefile
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -315,15 +314,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -333,7 +332,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -355,7 +354,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -214,7 +214,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 DIST_SUBDIRS = $(SUBDIRS)
 all: all-recursive
 
@@ -411,15 +411,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -429,7 +429,7 @@ clean: clean-recursive
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-recursive
@@ -451,7 +451,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.45 2003/07/23 00:13:37 hno Exp $
+#  $Id: Makefile.in,v 1.46 2004/08/30 03:28:47 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -243,7 +243,7 @@ DIST_SOURCES = $(squid_ldap_auth_SOURCES)
 
 NROFF = nroff
 MANS = $(man_MANS)
-DIST_COMMON = README Makefile.am Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(squid_ldap_auth_SOURCES)
 
 all: all-am
@@ -291,9 +291,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/squid_ldap_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -455,7 +452,6 @@ all-am: Makefile $(PROGRAMS) $(MANS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir) $(DESTDIR)$(man8dir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -467,15 +463,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -485,9 +481,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -508,7 +505,8 @@ install-man: install-man8
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -529,15 +527,15 @@ uninstall-man: uninstall-man8
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-man8 install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS uninstall-man uninstall-man8
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-man8 install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS \
+	uninstall-man uninstall-man8
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.48 2003/07/23 00:13:39 hno Exp $
+#  $Id: Makefile.in,v 1.49 2004/08/30 03:28:47 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -272,7 +272,7 @@ LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(msnt_auth_SOURCES)
 DATA = $(sysconf_DATA)
 
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(msnt_auth_SOURCES)
 
 all: all-am
@@ -333,9 +333,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/usersfile.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/valid.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -468,7 +465,6 @@ all-am: Makefile $(PROGRAMS) $(DATA)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir) $(DESTDIR)$(sysconfdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -480,15 +476,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -498,9 +494,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -521,7 +518,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -541,16 +539,15 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS \
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-data-local install-exec install-exec-am \
-	install-info install-info-am install-libexecPROGRAMS \
-	install-man install-strip install-sysconfDATA installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS \
-	uninstall-sysconfDATA
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-data-local install-exec install-exec-am install-info \
+	install-info-am install-libexecPROGRAMS install-man \
+	install-strip install-sysconfDATA installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
+	ps ps-am tags uninstall uninstall-am uninstall-info-am \
+	uninstall-libexecPROGRAMS uninstall-sysconfDATA
 
 
 confload.o: confload.c
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -16,7 +16,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.43 2003/07/23 00:13:35 hno Exp $
+#  $Id: Makefile.in,v 1.44 2004/08/30 03:28:47 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -221,7 +221,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-recursive
 
 .SUFFIXES:
@@ -417,15 +417,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -435,7 +435,7 @@ clean: clean-recursive
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-recursive
@@ -457,7 +457,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.45 2003/07/23 00:13:42 hno Exp $
+#  $Id: Makefile.in,v 1.46 2004/08/30 03:28:48 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -238,7 +238,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(ncsa_auth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(ncsa_auth_SOURCES)
 
 all: all-am
@@ -287,9 +287,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/crypt_md5.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncsa_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -404,7 +401,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -416,15 +412,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -434,9 +430,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -457,7 +454,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -476,15 +474,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid PAM authentication helper
 #
-#  $Id: Makefile.in,v 1.46 2003/08/03 20:38:02 robertc Exp $
+#  $Id: Makefile.in,v 1.47 2004/08/30 03:28:48 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -242,7 +242,7 @@ DIST_SOURCES = pam_auth.c
 
 NROFF = nroff
 MANS = $(man_MANS)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = pam_auth.c
 
 all: all-am
@@ -290,9 +290,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pam_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -454,7 +451,6 @@ all-am: Makefile $(PROGRAMS) $(MANS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir) $(DESTDIR)$(man8dir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -466,15 +462,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -484,9 +480,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -507,7 +504,8 @@ install-man: install-man8
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -528,15 +526,15 @@ uninstall-man: uninstall-man8
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-man8 install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS uninstall-man uninstall-man8
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-man8 install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS \
+	uninstall-man uninstall-man8
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid SASL authentication helper
 #
-#  $Id: Makefile.in,v 1.41 2003/07/23 00:13:46 hno Exp $
+#  $Id: Makefile.in,v 1.42 2004/08/30 03:28:48 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -238,7 +238,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = sasl_auth.c
-DIST_COMMON = README Makefile.am Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.in Makefile.am
 SOURCES = sasl_auth.c
 
 all: all-am
@@ -286,9 +286,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sasl_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -403,7 +400,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -415,15 +411,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -433,9 +429,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -456,7 +453,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -475,15 +473,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.44 2003/07/23 00:13:48 hno Exp $
+#  $Id: Makefile.in,v 1.45 2004/08/30 03:28:48 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -252,7 +252,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = smb_auth.c
-DIST_COMMON = README ChangeLog Makefile.am Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.in ChangeLog Makefile.am
 SOURCES = smb_auth.c
 
 all: all-am
@@ -320,9 +320,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smb_auth-smb_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -459,7 +456,6 @@ all-am: Makefile $(PROGRAMS) $(SCRIPTS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -471,15 +467,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -489,9 +485,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -512,7 +509,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -532,14 +530,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS \
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-libexecSCRIPTS \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags uninstall uninstall-am uninstall-info-am \
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-libexecSCRIPTS install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
 	uninstall-libexecPROGRAMS uninstall-libexecSCRIPTS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.45 2003/07/23 00:13:51 hno Exp $
+#  $Id: Makefile.in,v 1.46 2004/08/30 03:28:48 robertc Exp $
 #
 #
 
@@ -237,7 +237,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(yp_auth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(yp_auth_SOURCES)
 
 all: all-am
@@ -286,9 +286,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nis_support.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/yp_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -403,7 +400,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -415,15 +411,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -433,9 +429,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -456,7 +453,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -475,15 +473,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.43 2003/07/23 00:13:54 hno Exp $
+#  $Id: Makefile.in,v 1.44 2004/08/30 03:28:48 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -239,7 +239,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(getpwname_auth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(getpwname_auth_SOURCES)
 
 all: all-am
@@ -287,9 +287,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getpwnam_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -404,7 +401,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -416,15 +412,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -434,9 +430,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -457,7 +454,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -476,15 +474,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.41 2003/07/23 00:13:55 hno Exp $
+#  $Id: Makefile.in,v 1.42 2004/08/30 03:28:49 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -226,7 +226,7 @@ CONFIG_CLEAN_FILES =
 SCRIPTS = $(libexec_SCRIPTS)
 
 DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -300,7 +300,6 @@ all-am: Makefile $(SCRIPTS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -312,15 +311,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -330,7 +329,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -352,7 +351,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.35 2003/07/23 00:13:57 hno Exp $
+#  $Id: Makefile.in,v 1.36 2004/08/30 03:28:49 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -236,7 +236,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(wb_auth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(wb_auth_SOURCES)
 
 all: all-am
@@ -285,9 +285,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wb_basic_auth.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wb_common.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -402,7 +399,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -414,15 +410,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -432,9 +428,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -455,7 +452,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -474,15 +472,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -16,7 +16,7 @@
 
 #  Makefile for digest auth helpers in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.40 2003/07/23 00:14:02 hno Exp $
+#  $Id: Makefile.in,v 1.41 2004/08/30 03:28:49 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -221,7 +221,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-recursive
 
 .SUFFIXES:
@@ -417,15 +417,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -435,7 +435,7 @@ clean: clean-recursive
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-recursive
@@ -457,7 +457,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.43 2003/07/23 00:14:03 hno Exp $
+#  $Id: Makefile.in,v 1.44 2004/08/30 03:28:49 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -246,7 +246,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(digest_pw_auth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(digest_pw_auth_SOURCES)
 
 all: all-am
@@ -295,9 +295,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/digest_pw_auth.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/text_backend.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -412,7 +409,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -424,15 +420,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -442,9 +438,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -465,7 +462,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -484,15 +482,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -16,7 +16,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.30 2003/07/23 00:14:05 hno Exp $
+#  $Id: Makefile.in,v 1.31 2004/08/30 03:28:49 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -221,7 +221,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-recursive
 
 .SUFFIXES:
@@ -417,15 +417,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -435,7 +435,7 @@ clean: clean-recursive
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-recursive
@@ -457,7 +457,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the ip_user external_acl helper by Rodrigo Campos
 #
-#  $Id: Makefile.in,v 1.31 2004/08/15 00:10:33 hno Exp $
+#  $Id: Makefile.in,v 1.32 2004/08/30 03:28:49 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -254,7 +254,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(ip_user_check_SOURCES)
-DIST_COMMON = README Makefile.am Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(ip_user_check_SOURCES)
 
 all: all-am
@@ -304,9 +304,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/match.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -421,7 +418,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -433,15 +429,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -451,9 +447,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -474,7 +471,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -493,15 +491,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.33 2004/08/15 00:10:34 hno Exp $
+#  $Id: Makefile.in,v 1.34 2004/08/30 03:28:49 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -243,7 +243,7 @@ DIST_SOURCES = $(squid_ldap_group_SOURCES)
 
 NROFF = nroff
 MANS = $(man_MANS)
-DIST_COMMON = README ChangeLog Makefile.am Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.in ChangeLog Makefile.am
 SOURCES = $(squid_ldap_group_SOURCES)
 
 all: all-am
@@ -291,9 +291,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/squid_ldap_group.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -455,7 +452,6 @@ all-am: Makefile $(PROGRAMS) $(MANS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir) $(DESTDIR)$(man8dir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -467,15 +463,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -485,9 +481,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -508,7 +505,8 @@ install-man: install-man8
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -529,15 +527,15 @@ uninstall-man: uninstall-man8
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-man8 install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS uninstall-man uninstall-man8
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-man8 install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS \
+	uninstall-man uninstall-man8
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.31 2004/08/15 00:10:34 hno Exp $
+#  $Id: Makefile.in,v 1.32 2004/08/30 03:28:50 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -243,7 +243,7 @@ DIST_SOURCES = $(squid_unix_group_SOURCES)
 
 NROFF = nroff
 MANS = $(man_MANS)
-DIST_COMMON = README Makefile.am Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(squid_unix_group_SOURCES)
 
 all: all-am
@@ -291,9 +291,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/check_group.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -455,7 +452,6 @@ all-am: Makefile $(PROGRAMS) $(MANS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir) $(DESTDIR)$(man8dir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -467,15 +463,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -485,9 +481,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -508,7 +505,8 @@ install-man: install-man8
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -529,15 +527,15 @@ uninstall-man: uninstall-man8
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-man8 install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS uninstall-man uninstall-man8
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-man8 install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS \
+	uninstall-man uninstall-man8
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.29 2003/07/23 00:14:13 hno Exp $
+#  $Id: Makefile.in,v 1.30 2004/08/30 03:28:50 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -222,7 +222,7 @@ CONFIG_CLEAN_FILES =
 SCRIPTS = $(libexec_SCRIPTS)
 
 DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -296,7 +296,6 @@ all-am: Makefile $(SCRIPTS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -308,15 +307,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -326,7 +325,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -348,7 +347,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the wb_group external_acl helper
 #
-#  $Id: Makefile.in,v 1.32 2004/08/15 00:10:34 hno Exp $
+#  $Id: Makefile.in,v 1.33 2004/08/30 03:28:50 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -238,7 +238,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(wb_group_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(wb_group_SOURCES)
 
 all: all-am
@@ -287,9 +287,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wb_check_group.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wb_common.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -404,7 +401,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -416,15 +412,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -434,9 +430,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -457,7 +454,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -476,15 +474,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -16,7 +16,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.43 2003/07/23 00:14:17 hno Exp $
+#  $Id: Makefile.in,v 1.44 2004/08/30 03:28:50 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -221,7 +221,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-recursive
 
 .SUFFIXES:
@@ -417,15 +417,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -435,7 +435,7 @@ clean: clean-recursive
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-recursive
@@ -457,7 +457,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.43 2003/07/23 00:14:23 hno Exp $
+#  $Id: Makefile.in,v 1.44 2004/08/30 03:28:50 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -248,7 +248,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 DIST_SUBDIRS = $(SUBDIRS)
 SOURCES = $(ntlm_auth_SOURCES)
 
@@ -298,9 +298,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libntlmssp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ntlm_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -510,15 +507,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -528,9 +525,10 @@ clean: clean-recursive
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-recursive
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-recursive
 
@@ -551,7 +549,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -572,10 +571,10 @@ uninstall-info: uninstall-info-recursive
 
 .PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
 	clean-generic clean-libexecPROGRAMS clean-recursive ctags \
-	ctags-recursive distclean distclean-compile distclean-depend \
-	distclean-generic distclean-recursive distclean-tags distdir \
-	dvi dvi-am dvi-recursive info info-am info-recursive install \
-	install-am install-data install-data-am install-data-recursive \
+	ctags-recursive distclean distclean-compile distclean-generic \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-recursive \
 	install-exec install-exec-am install-exec-recursive \
 	install-info install-info-am install-info-recursive \
 	install-libexecPROGRAMS install-man install-recursive \
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -243,7 +243,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(libsmbvalid_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(libsmbvalid_a_SOURCES)
 
 all: all-am
@@ -279,9 +279,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smblib.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/valid.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -395,7 +392,6 @@ check: check-am
 all-am: Makefile $(LIBRARIES)
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -407,15 +403,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -425,9 +421,10 @@ clean: clean-am
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -448,7 +445,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -467,14 +465,13 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
+	ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.42 2003/07/23 00:14:33 hno Exp $
+#  $Id: Makefile.in,v 1.43 2004/08/30 03:28:50 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -239,7 +239,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(fakeauth_auth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(fakeauth_auth_SOURCES)
 
 all: all-am
@@ -287,9 +287,6 @@ distclean-compile:
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fakeauth_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -404,7 +401,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -416,15 +412,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -434,9 +430,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -457,7 +454,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -476,15 +474,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.44 2003/07/23 00:14:36 hno Exp $
+#  $Id: Makefile.in,v 1.45 2004/08/30 03:28:50 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -224,7 +224,7 @@ CONFIG_CLEAN_FILES =
 SCRIPTS = $(libexec_SCRIPTS)
 
 DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -298,7 +298,6 @@ all-am: Makefile $(SCRIPTS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -310,15 +309,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -328,7 +327,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -350,7 +349,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.35 2003/07/23 00:14:38 hno Exp $
+#  $Id: Makefile.in,v 1.36 2004/08/30 03:28:51 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -242,7 +242,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(wb_ntlmauth_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(wb_ntlmauth_SOURCES)
 
 all: all-am
@@ -291,9 +291,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wb_common.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wb_ntlm_auth.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -409,7 +406,6 @@ all-am: Makefile $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -421,15 +417,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -439,9 +435,10 @@ clean: clean-am
 clean-am: clean-generic clean-libexecPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -462,7 +459,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -481,15 +479,14 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libexecPROGRAMS install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libexecPROGRAMS
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libexecPROGRAMS install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -14,7 +14,7 @@
 
 @SET_MAKE@
 
-# $Id: Makefile.in,v 1.58 2003/07/23 00:14:40 hno Exp $
+# $Id: Makefile.in,v 1.59 2004/08/30 03:28:53 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -246,7 +246,7 @@ CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 DATA = $(icon_DATA)
 
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -318,7 +318,6 @@ all-am: Makefile $(DATA)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(icondir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -330,15 +329,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
 
 maintainer-clean-generic:
@@ -349,7 +348,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -371,7 +370,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -110,9 +110,21 @@
    */
 #undef HAVE_DIRENT_H
 
+/* Define if you have the GNU dld library. */
+#undef HAVE_DLD
+
+/* Define to 1 if you have the `dlerror' function. */
+#undef HAVE_DLERROR
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
 /* Define to 1 if you have the `drand48' function. */
 #undef HAVE_DRAND48
 
+/* Define if you have the _dyld_func_lookup function. */
+#undef HAVE_DYLD
+
 /* Define to 1 if you have the <errno.h> header file. */
 #undef HAVE_ERRNO_H
 
@@ -432,6 +444,9 @@
 /* Define to 1 if you have the `setsid' function. */
 #undef HAVE_SETSID
 
+/* Define if you have the shl_load function. */
+#undef HAVE_SHL_LOAD
+
 /* short is defined in system headers */
 #undef HAVE_SHORT
 
@@ -736,9 +751,9 @@
 /* If using the C implementation of alloca, define if you know the
    direction of stack growth for your system; otherwise it will be
    automatically deduced at run-time.
-        STACK_DIRECTION > 0 => grows toward higher addresses
-        STACK_DIRECTION < 0 => grows toward lower addresses
-        STACK_DIRECTION = 0 => direction of growth unknown */
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
 #undef STACK_DIRECTION
 
 /* Define to 1 if you have the ANSI C header files. */
@@ -1,9 +1,10 @@
 ## Process this file with automake to produce Makefile.in
 #
-#  $Id: Makefile.am,v 1.12 2003/07/15 06:50:38 robertc Exp $
+#  $Id: Makefile.am,v 1.13 2004/08/30 03:28:54 robertc Exp $
 #
 
-SUBDIRS = libTrie
+DIST_SUBDIRS = libTrie cppunit-1.10.0
+SUBDIRS= libTrie @SQUID_CPPUNIT_DIR@
 
 AM_CFLAGS = @SQUID_CFLAGS@
 AM_CXXFLAGS = @SQUID_CXXFLAGS@
@@ -72,4 +73,14 @@ libntlmauth_a_SOURCES = \
 libntlmauth_a_LIBADD = \
 	@LIBOBJS@
 
-INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include
+INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include @SQUID_CPPUNIT_INC@
+##FIXME - set these in configure.in and reuse
+
+TESTS=$(check_PROGRAMS)
+check_PROGRAMS=tests/testAll
+
+tests_testAll_SOURCES= tests/testArray.cc tests/testMain.cc  tests/testArray.h
+
+tests_testAll_LDADD= @SQUID_CPPUNIT_LA@
+
+tests_testAll_LDFLAGS = $(LIBADD_DL)
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -15,7 +15,7 @@
 @SET_MAKE@
 
 #
-#  $Id: Makefile.in,v 1.94 2003/07/23 00:14:42 hno Exp $
+#  $Id: Makefile.in,v 1.95 2004/08/30 03:28:54 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -213,9 +213,9 @@ AM_CXXFLAGS = @SQUID_CXXFLAGS@
 
 @ENABLE_XPROF_STATS_TRUE@XPROF_STATS_SOURCE = Profiler.c
 @ENABLE_XPROF_STATS_FALSE@XPROF_STATS_SOURCE = 
+@NEED_OWN_SNPRINTF_FALSE@SNPRINTFSOURCE = 
 
 @NEED_OWN_SNPRINTF_TRUE@SNPRINTFSOURCE = snprintf.c
-@NEED_OWN_SNPRINTF_FALSE@SNPRINTFSOURCE = 
 @NEED_OWN_MD5_TRUE@MD5SOURCE = md5.c
 @NEED_OWN_MD5_FALSE@MD5SOURCE = 
 
@@ -354,8 +354,8 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in drand48.c inet_ntoa.c strerror.c \
-	tempnam.c
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am drand48.c inet_ntoa.c \
+	strerror.c tempnam.c
 DIST_SUBDIRS = $(SUBDIRS)
 SOURCES = $(libdlmalloc_a_SOURCES) $(libmiscutil_a_SOURCES) $(EXTRA_libmiscutil_a_SOURCES) $(libntlmauth_a_SOURCES) $(libregex_a_SOURCES)
 
@@ -422,9 +422,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uudecode.Po@am__quote@
 
-distclean-depend:
-	-rm -rf $(DEPDIR) ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -655,15 +652,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -673,9 +670,10 @@ clean: clean-recursive
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-recursive
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf $(DEPDIR) ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-recursive
 
@@ -696,7 +694,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -rf $(DEPDIR) ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -717,10 +716,10 @@ uninstall-info: uninstall-info-recursive
 
 .PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
 	clean-generic clean-noinstLIBRARIES clean-recursive ctags \
-	ctags-recursive distclean distclean-compile distclean-depend \
-	distclean-generic distclean-recursive distclean-tags distdir \
-	dvi dvi-am dvi-recursive info info-am info-recursive install \
-	install-am install-data install-data-am install-data-recursive \
+	ctags-recursive distclean distclean-compile distclean-generic \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-recursive \
 	install-exec install-exec-am install-exec-recursive \
 	install-info install-info-am install-info-recursive install-man \
 	install-recursive install-strip installcheck installcheck-am \
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -15,7 +15,7 @@
 @SET_MAKE@
 
 #
-# $Id: Makefile.in,v 1.8 2003/08/19 00:20:27 hno Exp $
+# $Id: Makefile.in,v 1.9 2004/08/30 03:28:55 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -136,10 +136,10 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = README AUTHORS COPYING ChangeLog INSTALL Makefile.am \
-	Makefile.in NEWS acinclude.m4 aclocal.m4 config.guess \
-	config.h.in config.sub configure configure.in depcomp \
-	install-sh ltmain.sh missing mkinstalldirs
+DIST_COMMON = README $(srcdir)/Makefile.in $(srcdir)/configure AUTHORS \
+	COPYING ChangeLog INSTALL Makefile.am NEWS acinclude.m4 \
+	aclocal.m4 config.guess config.h.in config.sub configure \
+	configure.in depcomp install-sh ltmain.sh missing mkinstalldirs
 all: config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
@@ -449,15 +449,15 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -468,6 +468,7 @@ clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
 
 dvi: dvi-recursive
@@ -490,7 +491,8 @@ installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf autom4te.cache
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.7.4 -*- Autoconf -*-
+# generated automatically by aclocal 1.7.9 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002
 # Free Software Foundation, Inc.
@@ -221,7 +221,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],[am__api_version="1.7"])
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.7.4])])
+	 [AM_AUTOMAKE_VERSION([1.7.9])])
 
 # Helper functions for option handling.                    -*- Autoconf -*-
 
@@ -603,18 +603,32 @@ AC_CACHE_CHECK([dependency style of $depcc],
   # using a relative directory.
   cp "$am_depcomp" conftest.dir
   cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
 
   am_cv_$1_dependencies_compiler_type=none
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
   fi
   for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
     # We need to recreate these files for each test, as the compiler may
     # overwrite some of them when testing with obscure command lines.
     # This happens at least with the AIX C compiler.
-    echo '#include "conftest.h"' > conftest.c
-    echo 'int i;' > conftest.h
-    echo "${am__include} ${am__quote}conftest.Po${am__quote}" > confmf
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      : > sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
     case $depmode in
     nosideeffect)
@@ -632,11 +646,12 @@ AC_CACHE_CHECK([dependency style of $depcc],
     # mode.  It turns out that the SunPro C++ compiler does not properly
     # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=conftest.c object=conftest.o \
-       depfile=conftest.Po tmpdepfile=conftest.TPo \
-       $SHELL ./depcomp $depcc -c -o conftest.o conftest.c \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep conftest.h conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # (even with -Werror).  So we grep stderr for any message
@@ -771,7 +786,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 
 # Check to see how 'make' treats includes.	-*- Autoconf -*-
 
-# Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -796,8 +811,9 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 AC_DEFUN([AM_MAKE_INCLUDE],
 [am_make=${MAKE-make}
 cat > confinc << 'END'
-doit:
+am__doit:
 	@echo done
+.PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
 AC_MSG_CHECKING([for style of include used by $am_make])
@@ -825,9 +841,9 @@ if test "$am__include" = "#"; then
       _am_result=BSD
    fi
 fi
-AC_SUBST(am__include)
-AC_SUBST(am__quote)
-AC_MSG_RESULT($_am_result)
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
 rm -f confinc confmf
 ])
 
@@ -1,11 +1,10 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.57 for libTrie 0.1.
+# Generated by GNU Autoconf 2.59 for libTrie 0.1.
 #
 # Report bugs to <rbtcollins@squid-cache.org>.
 #
-# Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
@@ -22,9 +21,10 @@ if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
@@ -43,7 +43,7 @@ for as_var in \
   LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
   LC_TELEPHONE LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
@@ -220,16 +220,17 @@ rm -f conf$$ conf$$.exe conf$$.file
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
 else
+  test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
 # Sed expression to map a string onto a valid variable name.
-as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 # IFS
@@ -669,7 +670,7 @@ done
 
 # Be sure to have absolute paths.
 for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
-              localstatedir libdir includedir oldincludedir infodir mandir
+	      localstatedir libdir includedir oldincludedir infodir mandir
 do
   eval ac_val=$`echo $ac_var`
   case $ac_val in
@@ -709,10 +710,10 @@ if test -z "$srcdir"; then
   # Try the directory containing this script, then its parent.
   ac_confdir=`(dirname "$0") 2>/dev/null ||
 $as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$0" : 'X\(//\)[^/]' \| \
-         X"$0" : 'X\(//\)$' \| \
-         X"$0" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$0" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -812,9 +813,9 @@ _ACEOF
   cat <<_ACEOF
 Installation directories:
   --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
+			  [$ac_default_prefix]
   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [PREFIX]
+			  [PREFIX]
 
 By default, \`make install' will install all the files in
 \`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
@@ -917,12 +918,45 @@ case $srcdir in
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
     cd $ac_dir
     # Check for guested configure; otherwise get Cygnus style configure.
@@ -933,24 +967,23 @@ ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
       echo
       $SHELL $ac_srcdir/configure  --help=recursive
     elif test -f $ac_srcdir/configure.ac ||
-           test -f $ac_srcdir/configure.in; then
+	   test -f $ac_srcdir/configure.in; then
       echo
       $ac_configure --help
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd $ac_popdir
+    cd "$ac_popdir"
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
 libTrie configure 0.1
-generated by GNU Autoconf 2.57
+generated by GNU Autoconf 2.59
 
-Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
-Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -962,7 +995,7 @@ This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by libTrie $as_me 0.1, which was
-generated by GNU Autoconf 2.57.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
@@ -1039,19 +1072,19 @@ do
     2)
       ac_configure_args1="$ac_configure_args1 '$ac_arg'"
       if test $ac_must_keep_next = true; then
-        ac_must_keep_next=false # Got value, back to normal.
+	ac_must_keep_next=false # Got value, back to normal.
       else
-        case $ac_arg in
-          *=* | --config-cache | -C | -disable-* | --disable-* \
-          | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-          | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-          | -with-* | --with-* | -without-* | --without-* | --x)
-            case "$ac_configure_args0 " in
-              "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-            esac
-            ;;
-          -* ) ac_must_keep_next=true ;;
-        esac
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
       fi
       ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
       # Get rid of the leading space.
@@ -1085,12 +1118,12 @@ _ASBOX
     case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
     *ac_space=\ *)
       sed -n \
-        "s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
-    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
       ;;
     *)
       sed -n \
-        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
     esac;
 }
@@ -1119,7 +1152,7 @@ _ASBOX
       for ac_var in $ac_subst_files
       do
 	eval ac_val=$`echo $ac_var`
-        echo "$ac_var='"'"'$ac_val'"'"'"
+	echo "$ac_var='"'"'$ac_val'"'"'"
       done | sort
       echo
     fi
@@ -1138,7 +1171,7 @@ _ASBOX
       echo "$as_me: caught signal $ac_signal"
     echo "$as_me: exit $exit_status"
   } >&5
-  rm -f core core.* *.core &&
+  rm -f core *.core &&
   rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
     exit $exit_status
      ' 0
@@ -1218,7 +1251,7 @@ fi
 # value.
 ac_cache_corrupted=false
 for ac_var in `(set) 2>&1 |
-               sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
   eval ac_old_set=\$ac_cv_env_${ac_var}_set
   eval ac_new_set=\$ac_env_${ac_var}_set
   eval ac_old_val="\$ac_cv_env_${ac_var}_value"
@@ -1235,13 +1268,13 @@ echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
-        { echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
 echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-        { echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
 echo "$as_me:   former value:  $ac_old_val" >&2;}
-        { echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
 echo "$as_me:   current value: $ac_new_val" >&2;}
-        ac_cache_corrupted=:
+	ac_cache_corrupted=:
       fi;;
   esac
   # Pass precious variables to config.status.
@@ -1445,7 +1478,6 @@ ac_compiler=`set X $ac_compile; echo $2`
   (exit $ac_status); }
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -1465,8 +1497,8 @@ ac_clean_files="$ac_clean_files a.out a.exe b.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-echo "$as_me:$LINENO: checking for C++ compiler default output" >&5
-echo $ECHO_N "checking for C++ compiler default output... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking for C++ compiler default output file name" >&5
+echo $ECHO_N "checking for C++ compiler default output file name... $ECHO_C" >&6
 ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
   (eval $ac_link_default) 2>&5
@@ -1486,23 +1518,23 @@ do
   test -f "$ac_file" || continue
   case $ac_file in
     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
-        ;;
+	;;
     conftest.$ac_ext )
-        # This is the source file.
-        ;;
+	# This is the source file.
+	;;
     [ab].out )
-        # We found the default executable, but exeext='' is most
-        # certainly right.
-        break;;
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
     *.* )
-        ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-        # FIXME: I believe we export ac_cv_exeext for Libtool,
-        # but it would be cool to find out if it's true.  Does anybody
-        # maintain Libtool? --akim.
-        export ac_cv_exeext
-        break;;
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
     * )
-        break;;
+	break;;
   esac
 done
 else
@@ -1576,8 +1608,8 @@ for ac_file in conftest.exe conftest conftest.*; do
   case $ac_file in
     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-          export ac_cv_exeext
-          break;;
+	  export ac_cv_exeext
+	  break;;
     * ) break;;
   esac
 done
@@ -1602,7 +1634,6 @@ if test "${ac_cv_objext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -1653,7 +1684,6 @@ if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -1673,11 +1703,20 @@ main ()
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -1690,7 +1729,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_compiler_gnu=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
 
 fi
@@ -1706,7 +1745,6 @@ if test "${ac_cv_prog_cxx_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -1723,11 +1761,20 @@ main ()
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -1740,7 +1787,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_prog_cxx_g=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cxx_g" >&6
@@ -1760,23 +1807,21 @@ else
   fi
 fi
 for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
+   '' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
    'extern "C" void exit (int);' \
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <stdlib.h>
 $ac_declaration
+#include <stdlib.h>
 int
 main ()
 {
@@ -1787,11 +1832,20 @@ exit (42);
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -1804,9 +1858,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 continue
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -1823,11 +1876,20 @@ exit (42);
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -1839,7 +1901,7 @@ else
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 rm -f conftest*
 if test -n "$ac_declaration"; then
@@ -2195,7 +2257,6 @@ if test "${ac_cv_c_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2215,11 +2276,20 @@ main ()
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2232,7 +2302,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_compiler_gnu=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
@@ -2248,7 +2318,6 @@ if test "${ac_cv_prog_cc_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2265,11 +2334,20 @@ main ()
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2282,7 +2360,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_prog_cc_g=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
@@ -2309,7 +2387,6 @@ else
   ac_cv_prog_cc_stdc=no
 ac_save_CC=$CC
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2337,6 +2414,16 @@ static char *f (char * (*g) (char **, int), char **p, ...)
   va_end (v);
   return s;
 }
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
 int test (int i, double x);
 struct s1 {int (*f) (int a);};
 struct s2 {int (*f) (double a);};
@@ -2363,11 +2450,20 @@ do
   CC="$ac_save_CC $ac_arg"
   rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2380,7 +2476,7 @@ else
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext
+rm -f conftest.err conftest.$ac_objext
 done
 rm -f conftest.$ac_ext conftest.$ac_objext
 CC=$ac_save_CC
@@ -2408,34 +2504,41 @@ cat >conftest.$ac_ext <<_ACEOF
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
+   '' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
    'extern "C" void exit (int);' \
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <stdlib.h>
 $ac_declaration
+#include <stdlib.h>
 int
 main ()
 {
@@ -2446,11 +2549,20 @@ exit (42);
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2463,9 +2575,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 continue
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -2482,11 +2593,20 @@ exit (42);
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2498,7 +2618,7 @@ else
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 rm -f conftest*
 if test -n "$ac_declaration"; then
@@ -2512,7 +2632,7 @@ else
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -2521,7 +2641,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
 echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
-set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,./+-,__p_,'`
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,:./+-,___p_,'`
 if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2586,6 +2706,7 @@ ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
 echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
 echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
@@ -2602,27 +2723,28 @@ do
 case $as_dir/ in
   ./ | .// | /cC/* | \
   /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
   /usr/ucb/* ) ;;
   *)
     # OSF1 and SCO ODT 3.0 have their own names for install.
     # Don't use installbsd from OSF since it installs stuff as root
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-        if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
-          if test $ac_prog = install &&
-            grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-            # AIX install.  It has an incompatible calling convention.
-            :
-          elif test $ac_prog = install &&
-            grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-            # program-specific install script used by HP pwplus--don't use.
-            :
-          else
-            ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-            break 3
-          fi
-        fi
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
       done
     done
     ;;
@@ -2780,8 +2902,9 @@ DEPDIR="${am__leading_dot}deps"
 
 am_make=${MAKE-make}
 cat > confinc << 'END'
-doit:
+am__doit:
 	@echo done
+.PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
 echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
@@ -3000,18 +3123,32 @@ else
   # using a relative directory.
   cp "$am_depcomp" conftest.dir
   cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
 
   am_cv_CC_dependencies_compiler_type=none
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
   fi
   for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
     # We need to recreate these files for each test, as the compiler may
     # overwrite some of them when testing with obscure command lines.
     # This happens at least with the AIX C compiler.
-    echo '#include "conftest.h"' > conftest.c
-    echo 'int i;' > conftest.h
-    echo "${am__include} ${am__quote}conftest.Po${am__quote}" > confmf
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      : > sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
     case $depmode in
     nosideeffect)
@@ -3029,11 +3166,12 @@ else
     # mode.  It turns out that the SunPro C++ compiler does not properly
     # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=conftest.c object=conftest.o \
-       depfile=conftest.Po tmpdepfile=conftest.TPo \
-       $SHELL ./depcomp $depcc -c -o conftest.o conftest.c \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep conftest.h conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # (even with -Werror).  So we grep stderr for any message
@@ -3087,18 +3225,32 @@ else
   # using a relative directory.
   cp "$am_depcomp" conftest.dir
   cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
 
   am_cv_CXX_dependencies_compiler_type=none
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
   fi
   for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
     # We need to recreate these files for each test, as the compiler may
     # overwrite some of them when testing with obscure command lines.
     # This happens at least with the AIX C compiler.
-    echo '#include "conftest.h"' > conftest.c
-    echo 'int i;' > conftest.h
-    echo "${am__include} ${am__quote}conftest.Po${am__quote}" > confmf
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      : > sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
     case $depmode in
     nosideeffect)
@@ -3116,11 +3268,12 @@ else
     # mode.  It turns out that the SunPro C++ compiler does not properly
     # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=conftest.c object=conftest.o \
-       depfile=conftest.Po tmpdepfile=conftest.TPo \
-       $SHELL ./depcomp $depcc -c -o conftest.o conftest.c \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep conftest.h conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # (even with -Werror).  So we grep stderr for any message
@@ -3318,7 +3471,6 @@ if test "${ac_cv_c_const+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3381,11 +3533,20 @@ main ()
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3398,7 +3559,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_c_const=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
 echo "${ECHO_T}$ac_cv_c_const" >&6
@@ -3438,7 +3599,6 @@ do
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3449,7 +3609,7 @@ cat >>conftest.$ac_ext <<_ACEOF
 #else
 # include <assert.h>
 #endif
-                     Syntax error
+		     Syntax error
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
@@ -3461,6 +3621,7 @@ if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -3481,7 +3642,6 @@ rm -f conftest.err conftest.$ac_ext
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3499,6 +3659,7 @@ if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -3545,7 +3706,6 @@ do
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3556,7 +3716,7 @@ cat >>conftest.$ac_ext <<_ACEOF
 #else
 # include <assert.h>
 #endif
-                     Syntax error
+		     Syntax error
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
@@ -3568,6 +3728,7 @@ if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -3588,7 +3749,6 @@ rm -f conftest.err conftest.$ac_ext
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3606,6 +3766,7 @@ if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
@@ -3666,7 +3827,6 @@ if test "${ac_cv_header_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3687,11 +3847,20 @@ main ()
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3704,12 +3873,11 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_header_stdc=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3731,7 +3899,6 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3756,7 +3923,6 @@ if test $ac_cv_header_stdc = yes; then
   :
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3768,9 +3934,9 @@ cat >>conftest.$ac_ext <<_ACEOF
 # define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #else
 # define ISLOWER(c) \
-                   (('a' <= (c) && (c) <= 'i') \
-                     || ('j' <= (c) && (c) <= 'r') \
-                     || ('s' <= (c) && (c) <= 'z'))
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
 # define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
 #endif
 
@@ -3781,7 +3947,7 @@ main ()
   int i;
   for (i = 0; i < 256; i++)
     if (XOR (islower (i), ISLOWER (i))
-        || toupper (i) != TOUPPER (i))
+	|| toupper (i) != TOUPPER (i))
       exit(2);
   exit (0);
 }
@@ -3806,7 +3972,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 ( exit $ac_status )
 ac_cv_header_stdc=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 fi
@@ -3831,7 +3997,7 @@ fi
 
 
 for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-                  inttypes.h stdint.h unistd.h
+		  inttypes.h stdint.h unistd.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_header" >&5
@@ -3840,7 +4006,6 @@ if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3852,11 +4017,20 @@ $ac_includes_default
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3869,7 +4043,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_Header=no"
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
@@ -3889,7 +4063,6 @@ if test "${ac_cv_type_size_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3909,11 +4082,20 @@ if (sizeof (size_t))
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3926,7 +4108,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_size_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
 echo "${ECHO_T}$ac_cv_type_size_t" >&6
@@ -3973,13 +4155,13 @@ _ACEOF
       # `set' does not quote correctly, so add quotes (double-quote
       # substitution turns \\\\ into \\, and sed turns \\ into \).
       sed -n \
-        "s/'/'\\\\''/g;
-    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
       ;;
     *)
       # `set' quotes correctly as required by POSIX, so do not add quotes.
       sed -n \
-        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
     esac;
 } |
@@ -4009,13 +4191,13 @@ test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
 s/:*\$(srcdir):*/:/;
 s/:*\${srcdir}:*/:/;
 s/:*@srcdir@:*/:/;
-s/^\([^=]*=[ 	]*\):*/\1/;
+s/^\([^=]*=[	 ]*\):*/\1/;
 s/:*$//;
-s/^[^=]*=[ 	]*$//;
+s/^[^=]*=[	 ]*$//;
 }'
 fi
 
@@ -4026,7 +4208,7 @@ ac_ltlibobjs=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
-         sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
   ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
@@ -4098,9 +4280,10 @@ if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
@@ -4119,7 +4302,7 @@ for as_var in \
   LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
   LC_TELEPHONE LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
@@ -4298,16 +4481,17 @@ rm -f conf$$ conf$$.exe conf$$.file
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
 else
+  test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
 # Sed expression to map a string onto a valid variable name.
-as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 # IFS
@@ -4334,7 +4518,7 @@ _ASBOX
 cat >&5 <<_CSEOF
 
 This file was extended by libTrie $as_me 0.1, which was
-generated by GNU Autoconf 2.57.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -4378,9 +4562,9 @@ Usage: $0 [OPTIONS] [FILE]...
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
   --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
+		   instantiate the configuration file FILE
   --header=FILE[:TEMPLATE]
-                   instantiate the configuration header FILE
+		   instantiate the configuration header FILE
 
 Configuration files:
 $config_files
@@ -4397,11 +4581,10 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
 libTrie config.status 0.1
-configured by $0, generated by GNU Autoconf 2.57,
+configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 srcdir=$srcdir
@@ -4679,9 +4862,9 @@ _ACEOF
       (echo ':t
   /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
       if test -z "$ac_sed_cmds"; then
-  	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
       else
-  	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
       fi
       ac_sed_frag=`expr $ac_sed_frag + 1`
       ac_beg=$ac_end
@@ -4699,21 +4882,21 @@ for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case $ac_file in
   - | *:- | *:-:* ) # input from stdin
-        cat >$tmp/stdin
-        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   * )   ac_file_in=$ac_file.in ;;
   esac
 
   # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
   ac_dir=`(dirname "$ac_file") 2>/dev/null ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$ac_file" : 'X\(//\)[^/]' \| \
-         X"$ac_file" : 'X\(//\)$' \| \
-         X"$ac_file" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -4729,10 +4912,10 @@ echo X"$ac_file" |
       as_dirs="$as_dir $as_dirs"
       as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$as_dir" : 'X\(//\)[^/]' \| \
-         X"$as_dir" : 'X\(//\)$' \| \
-         X"$as_dir" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -4770,24 +4953,52 @@ case $srcdir in
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
 
   case $INSTALL in
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -4797,7 +5008,7 @@ echo "$as_me: creating $ac_file" >&6;}
     configure_input="$ac_file.  "
   fi
   configure_input=$configure_input"Generated from `echo $ac_file_in |
-                                     sed 's,.*/,,'` by configure."
+				     sed 's,.*/,,'` by configure."
 
   # First look for the input files in the build tree, otherwise in the
   # src tree.
@@ -4806,26 +5017,32 @@ echo "$as_me: creating $ac_file" >&6;}
       case $f in
       -) echo $tmp/stdin ;;
       [\\/$]*)
-         # Absolute (can't be DOS-style, as IFS=:)
-         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 echo "$f";;
       *) # Relative
-         if test -f "$f"; then
-           # Build tree
-           echo $f
-         elif test -f "$srcdir/$f"; then
-           # Source tree
-           echo $srcdir/$f
-         else
-           # /dev/null tree
-           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         fi;;
+	 fi;;
       esac
     done` || { (exit 1); exit 1; }
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
@@ -4865,12 +5082,12 @@ cat >>$CONFIG_STATUS <<\_ACEOF
 # NAME is the cpp macro being defined and VALUE is the value it is being given.
 #
 # ac_d sets the value in "#define NAME VALUE" lines.
-ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
-ac_dB='[ 	].*$,\1#\2'
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
 ac_dC=' '
 ac_dD=',;t'
 # ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
-ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
 ac_uB='$,\1#\2define\3'
 ac_uC=' '
 ac_uD=',;t'
@@ -4879,11 +5096,11 @@ for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case $ac_file in
   - | *:- | *:-:* ) # input from stdin
-        cat >$tmp/stdin
-        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   * )   ac_file_in=$ac_file.in ;;
   esac
 
@@ -4897,28 +5114,29 @@ echo "$as_me: creating $ac_file" >&6;}
       case $f in
       -) echo $tmp/stdin ;;
       [\\/$]*)
-         # Absolute (can't be DOS-style, as IFS=:)
-         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
       *) # Relative
-         if test -f "$f"; then
-           # Build tree
-           echo $f
-         elif test -f "$srcdir/$f"; then
-           # Source tree
-           echo $srcdir/$f
-         else
-           # /dev/null tree
-           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         fi;;
+	 fi;;
       esac
     done` || { (exit 1); exit 1; }
   # Remove the trailing spaces.
-  sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
 
 _ACEOF
 
@@ -4941,9 +5159,9 @@ s/[\\&,]/\\&/g
 s,[\\$`],\\&,g
 t clear
 : clear
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	(][^ 	(]*\)\(([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
 t end
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
 : end
 _ACEOF
 # If some macros were called several times there might be several times
@@ -4957,13 +5175,13 @@ rm -f confdef2sed.sed
 # example, in the case of _POSIX_SOURCE, which is predefined and required
 # on some systems where configure will not decide to define it.
 cat >>conftest.undefs <<\_ACEOF
-s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
 _ACEOF
 
 # Break up conftest.defines because some shells have a limit on the size
 # of here documents, and old seds have small limits too (100 cmds).
 echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
-echo '  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
 echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
 echo '  :' >>$CONFIG_STATUS
 rm -f conftest.tail
@@ -4972,7 +5190,7 @@ do
   # Write a limited-size here document to $tmp/defines.sed.
   echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
   # Speed up: don't consider the non `#define' lines.
-  echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
   # Work around the forget-to-reset-the-flag bug.
   echo 't clr' >>$CONFIG_STATUS
   echo ': clr' >>$CONFIG_STATUS
@@ -4999,7 +5217,7 @@ do
   # Write a limited-size here document to $tmp/undefs.sed.
   echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
   # Speed up: don't consider the non `#undef'
-  echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
   # Work around the forget-to-reset-the-flag bug.
   echo 't clr' >>$CONFIG_STATUS
   echo ': clr' >>$CONFIG_STATUS
@@ -5033,10 +5251,10 @@ echo "$as_me: $ac_file is unchanged" >&6;}
     else
       ac_dir=`(dirname "$ac_file") 2>/dev/null ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$ac_file" : 'X\(//\)[^/]' \| \
-         X"$ac_file" : 'X\(//\)$' \| \
-         X"$ac_file" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -5052,10 +5270,10 @@ echo X"$ac_file" |
       as_dirs="$as_dir $as_dirs"
       as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$as_dir" : 'X\(//\)[^/]' \| \
-         X"$as_dir" : 'X\(//\)$' \| \
-         X"$as_dir" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -5087,10 +5305,10 @@ for _am_header in $config_headers :; do
 done
 echo "timestamp for $ac_file" >`(dirname $ac_file) 2>/dev/null ||
 $as_expr X$ac_file : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X$ac_file : 'X\(//\)[^/]' \| \
-         X$ac_file : 'X\(//\)$' \| \
-         X$ac_file : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X$ac_file : 'X\(//\)[^/]' \| \
+	 X$ac_file : 'X\(//\)$' \| \
+	 X$ac_file : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X$ac_file |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -5109,16 +5327,41 @@ for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
   ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
   ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
 $as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$ac_dest" : 'X\(//\)[^/]' \| \
-         X"$ac_dest" : 'X\(//\)$' \| \
-         X"$ac_dest" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_dest" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
   	  /^X\(\/\/\)$/{ s//\1/; q; }
   	  /^X\(\/\).*/{ s//\1/; q; }
   	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
   ac_builddir=.
 
 if test "$ac_dir" != .; then
@@ -5144,12 +5387,45 @@ case $srcdir in
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
 
   { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
@@ -5167,10 +5443,10 @@ echo "$as_me: executing $ac_dest commands" >&6;}
   if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
     dirpart=`(dirname "$mf") 2>/dev/null ||
 $as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$mf" : 'X\(//\)[^/]' \| \
-         X"$mf" : 'X\(//\)$' \| \
-         X"$mf" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$mf" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -5206,10 +5482,10 @@ echo X"$mf" |
     test -f "$dirpart/$file" && continue
     fdir=`(dirname "$file") 2>/dev/null ||
 $as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$file" : 'X\(//\)[^/]' \| \
-         X"$file" : 'X\(//\)$' \| \
-         X"$file" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -5225,10 +5501,10 @@ echo X"$file" |
       as_dirs="$as_dir $as_dirs"
       as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$as_dir" : 'X\(//\)[^/]' \| \
-         X"$as_dir" : 'X\(//\)$' \| \
-         X"$as_dir" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -125,7 +125,7 @@ CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 HEADERS = $(noinst_HEADERS)
 
-DIST_COMMON = $(noinst_HEADERS) Makefile.am Makefile.in
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.in Makefile.am
 all: all-am
 
 .SUFFIXES:
@@ -226,7 +226,6 @@ check: check-am
 all-am: Makefile $(HEADERS)
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -238,15 +237,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -256,7 +255,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-am
@@ -278,7 +277,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -155,7 +155,7 @@ CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
 DIST_SOURCES = $(libTrie_a_SOURCES)
 HEADERS = $(noinst_HEADERS)
 
-DIST_COMMON = $(noinst_HEADERS) Makefile.am Makefile.in
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(libTrie_a_SOURCES)
 
 all: all-am
@@ -186,9 +186,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Trie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TrieNode.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCXX_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -303,7 +300,6 @@ check: check-am
 all-am: Makefile $(LIBRARIES) $(HEADERS)
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -315,15 +311,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -333,9 +329,10 @@ clean: clean-am
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -356,7 +353,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -375,14 +373,13 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
+	ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -159,7 +159,7 @@ CXXLD = $(CXX)
 CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
 	-o $@
 DIST_SOURCES = $(trie_SOURCES) $(trie_c_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(trie_SOURCES) $(trie_c_SOURCES)
 
 all: all-am
@@ -190,9 +190,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/trie-c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/trie.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -403,7 +400,6 @@ check: check-am
 all-am: Makefile
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -415,15 +411,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -433,9 +429,10 @@ clean: clean-am
 clean-am: clean-checkPROGRAMS clean-generic mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -456,7 +453,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -475,14 +473,14 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-TESTS check-am clean \
 	clean-checkPROGRAMS clean-generic ctags distclean \
-	distclean-compile distclean-depend distclean-generic \
-	distclean-tags distdir dvi dvi-am info info-am install \
-	install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -0,0 +1,21 @@
+#include "config.h"
+
+#if HAVE_ASSERT_H
+#include <assert.h>
+#endif
+
+#include "testArray.h"
+#include "Array.h"
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testArray );
+
+void testArray::all()
+{
+  CPPUNIT_ASSERT( 1 == 1 );
+    Vector<int> aArray;
+    CPPUNIT_ASSERT (aArray.size() == 0);
+    aArray.push_back(2);
+    CPPUNIT_ASSERT (aArray.size() == 1);
+    CPPUNIT_ASSERT (aArray.back() == 2);
+    CPPUNIT_ASSERT (aArray.size() == 1);
+}
@@ -0,0 +1,27 @@
+
+#ifndef SQUID_LIB_TEST_ARRAY_H
+#define SQUID_LIB_TEST_ARRAY_H
+
+#include <cppunit/extensions/HelperMacros.h>
+
+/* 
+ * A test case that is designed to produce
+ * example errors and failures
+ *
+ */
+
+class testArray : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( testArray );
+  CPPUNIT_TEST( all );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+  void all();
+};
+
+
+#endif
+
@@ -0,0 +1,35 @@
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/CompilerOutputter.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/TestRunner.h>
+
+
+int
+main( int argc, char* argv[] )
+{
+  // Create the event manager and test controller
+  CPPUNIT_NS::TestResult controller;
+
+  // Add a listener that colllects test result
+  CPPUNIT_NS::TestResultCollector result;
+  controller.addListener( &result );        
+
+  // Add a listener that print dots as test run.
+  CPPUNIT_NS::BriefTestProgressListener progress;
+  controller.addListener( &progress );      
+
+  // Add the top suite to the test runner
+  CPPUNIT_NS::TestRunner runner;
+  runner.addTest( CPPUNIT_NS::TestFactoryRegistry::getRegistry().makeTest() );
+  runner.run( controller );
+
+  // Print test in a compiler compatible format.
+  CPPUNIT_NS::CompilerOutputter outputter( &result, std::cerr );
+  outputter.write(); 
+
+  return result.wasSuccessful() ? 0 : 1;
+}
+
+
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -221,7 +221,7 @@ CONFIG_CLEAN_FILES = RunCache RunAccel
 SCRIPTS = $(bin_SCRIPTS)
 
 DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in RunAccel.in RunCache.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am RunAccel.in RunCache.in
 all: all-am
 
 .SUFFIXES:
@@ -299,7 +299,6 @@ all-am: Makefile $(SCRIPTS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -311,15 +310,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -329,7 +328,7 @@ clean: clean-am
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
@@ -351,7 +350,7 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -242,7 +242,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(libsnmp_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(libsnmp_a_SOURCES)
 
 all: all-am
@@ -280,9 +280,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_vars.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmplib_debug.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -396,7 +393,6 @@ check: check-am
 all-am: Makefile $(LIBRARIES)
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -408,15 +404,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -426,9 +422,10 @@ clean: clean-am
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -449,7 +446,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -468,14 +466,13 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
+	ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLChecklist.cc,v 1.16 2003/09/21 12:06:06 robertc Exp $
+ * $Id: ACLChecklist.cc,v 1.17 2004/08/30 03:28:56 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -39,6 +39,7 @@
 #include "authenticate.h"
 #include "ACLProxyAuth.h"
 #include "client_side.h"
+#include "AuthUserRequest.h"
 
 int
 ACLChecklist::authenticated()
@@ -61,7 +62,7 @@ ACLChecklist::authenticated()
 
     /* get authed here */
     /* Note: this fills in auth_user_request when applicable */
-    switch (authenticateTryToAuthenticateAndSetAuthUser(&auth_user_request, headertype, request, conn(), src_addr)) {
+    switch (AuthUserRequest::tryToAuthenticateAndSetAuthUser (&auth_user_request, headertype, request, conn(), src_addr)) {
 
     case AUTH_ACL_CANNOT_AUTHENTICATE:
         debug(28, 4) ("aclMatchAcl: returning  0 user authenticated but not authorised.\n");
@@ -224,7 +225,7 @@ ACLChecklist::checkCallback(allow_t answer)
 
     if (auth_user_request) {
         /* the checklist lock */
-        authenticateAuthUserRequestUnlock(auth_user_request);
+        auth_user_request->unlock();
         /* it might have been connection based */
         assert(conn().getRaw() != NULL);
         conn()->auth_user_request = NULL;
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLMaxUserIP.cc,v 1.4 2003/08/04 22:14:38 robertc Exp $
+ * $Id: ACLMaxUserIP.cc,v 1.5 2004/08/30 03:28:56 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -36,6 +36,7 @@
 
 #include "squid.h"
 #include "ACLMaxUserIP.h"
+#include "AuthUserRequest.h"
 #include "authenticate.h"
 
 ACL::Prototype ACLMaxUserIP::RegistryProtoype(&ACLMaxUserIP::RegistryEntry_, "max_user_ip");
@@ -42,6 +42,8 @@
 #include "ACLRegexData.h"
 #include "client_side.h"
 #include "HttpRequest.h"
+#include "AuthUser.h"
+#include "AuthUserRequest.h"
 
 MemPool (*ACLProxyAuth::Pool)(NULL);
 void *
@@ -158,7 +160,7 @@ ProxyAuthLookup::checkForAsync(ACLChecklist *checklist)const
     auth_user_request = checklist->auth_user_request;
 
     assert(authenticateValidateUser(auth_user_request));
-    authenticateStart(auth_user_request, LookupDone, checklist);
+    auth_user_request->start(LookupDone, checklist);
 }
 
 void
@@ -174,7 +176,7 @@ ProxyAuthLookup::LookupDone(void *data, char *result)
         /* credentials could not be checked either way
          * restart the whole process */
         /* OR the connection was closed, there's no way to continue */
-        authenticateAuthUserRequestUnlock(checklist->auth_user_request);
+        checklist->auth_user_request->unlock();
 
         if (checklist->conn().getRaw() != NULL) {
             checklist->conn()->auth_user_request = NULL;
@@ -216,7 +218,8 @@ ACLProxyAuth::clone() const
 int
 ACLProxyAuth::matchForCache(ACLChecklist *checklist)
 {
-    return data->match(authenticateUserRequestUsername(checklist->auth_user_request));
+    assert (checklist->auth_user_request);
+    return data->match(checklist->auth_user_request->username());
 }
 
 /* aclMatchProxyAuth can return two exit codes:
@@ -228,7 +231,7 @@ ACLProxyAuth::matchProxyAuth(ACLChecklist *checklist)
 {
     checkAuthForCaching(checklist);
     /* check to see if we have matched the user-acl before */
-    int result = cacheMatchAcl(&checklist->auth_user_request->auth_user->
+    int result = cacheMatchAcl(&checklist->auth_user_request->user()->
                                proxy_match_cache, checklist);
     checklist->auth_user_request = NULL;
     return result;
@@ -238,10 +241,14 @@ void
 ACLProxyAuth::checkAuthForCaching(ACLChecklist *checklist)const
 {
     /* for completeness */
-    authenticateAuthUserRequestLock(checklist->auth_user_request);
+
+    checklist->auth_user_request->lock()
+
+    ;
     /* consistent parameters ? */
     assert(authenticateUserAuthenticated(checklist->auth_user_request));
+
     /* this check completed */
-    authenticateAuthUserRequestUnlock(checklist->auth_user_request);
+    checklist->auth_user_request->unlock();
 }
 
@@ -0,0 +1,78 @@
+
+/*
+ * $Id: AuthConfig.cc,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ * DEBUG: section 29    Authenticator
+ * AUTHOR:  Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "AuthConfig.h"
+#include "AuthUserRequest.h"
+
+/* Get Auth User: Return a filled out auth_user structure for the given
+ * Proxy Auth (or Auth) header. It may be a cached Auth User or a new
+ * Unauthenticated structure. The structure is given an inital lock here.
+ * It may also be NULL reflecting that no user could be created.
+ */
+AuthUserRequest *
+AuthConfig::CreateAuthUser(const char *proxy_auth)
+{
+    assert(proxy_auth != NULL);
+    debug(29, 9) ("AuthConfig::CreateAuthUser: header = '%s'\n", proxy_auth);
+
+    AuthConfig *config = Find(proxy_auth);
+
+    if (config == NULL || !config->active()) {
+        debug(29, 1) ("AuthConfig::CreateAuthUser: Unsupported or unconfigured/inactive proxy-auth scheme, '%s'\n", proxy_auth);
+        return NULL;
+    }
+
+    assert (config != NULL);
+
+    AuthUserRequest *result = config->decode (proxy_auth);
+    /* and lock for the callers instance */
+
+    if (result != NULL)
+        result->lock()
+
+        ;
+    return result;
+}
+
+AuthConfig *
+AuthConfig::Find(const char *proxy_auth)
+{
+    for (authConfig::iterator  i = Config.authConfiguration.begin(); i != Config.authConfiguration.end(); ++i)
+        if (strncasecmp(proxy_auth, (*i)->type(), strlen((*i)->type())) == 0)
+            return *i;
+
+    return NULL;
+}
@@ -0,0 +1,83 @@
+
+/*
+ * $Id: AuthConfig.h,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_AUTHCONFIG_H
+#define SQUID_AUTHCONFIG_H
+
+/*
+ * I am the configuration for an auth scheme.
+ * Currently each scheme has only one instance of me,
+ * but this may change.
+ */
+
+/* This class is treated like a ref counted class.
+ * If the children ever stop being singletons, implement the
+ * ref counting...
+ */
+
+class AuthConfig
+{
+
+public:
+    static AuthUserRequest *CreateAuthUser (const char *proxy_auth);
+
+    static AuthConfig *Find(const char *proxy_auth);
+    AuthConfig() {}
+
+    virtual ~AuthConfig(){}
+
+    /* Is this configuration active? (helpers running etc etc */
+    virtual bool active() const = 0;
+    /* new decode API: virtual factory pattern */
+    virtual AuthUserRequest *decode(char const *proxy_auth) = 0;
+    /* squid is finished with this config, release any unneeded resources.
+     * If a singleton, delete will not occur. if not a singleton (future),
+     * delete will occur when no references are held.
+     * TODO: we need a 'done for reconfigure' and a 'done permanently' concept.
+     */
+    virtual void done() = 0;
+    /* is this config complete enough to run */
+    virtual bool configured() const = 0;
+    /* output the parameters */
+    virtual void dump(StoreEntry *, const char *, AuthConfig *) = 0;
+    /* add headers as needed when challenging for auth */
+    virtual void fixHeader(auth_user_request_t *, HttpReply *, http_hdr_type, HttpRequest *) = 0;
+    /* prepare to handle requests */
+    virtual void init(AuthConfig *) = 0;
+    /* parse config options */
+    virtual void parse(AuthConfig *, int, char *) = 0;
+    /* the http string id */
+    virtual const char * type() const = 0;
+};
+
+#endif /* SQUID_AUTHCONFIG_H */
@@ -0,0 +1,95 @@
+
+/*
+ * $Id: AuthScheme.cc,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ * DEBUG: section 29	Authenticator
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ * Copyright (c) 2004, Robert Collins <robertc@squid-cache.org>
+ */
+
+#include "squid.h"
+#include "AuthScheme.h"
+#include "authenticate.h"
+#include "AuthConfig.h"
+
+Vector<AuthScheme*> *AuthScheme::_Schemes = NULL;
+
+void
+AuthScheme::AddScheme(AuthScheme &instance)
+{
+    iterator i = GetSchemes().begin();
+
+    while (i != GetSchemes().end()) {
+        assert(strcmp((*i)->type(), instance.type()) != 0);
+        ++i;
+    }
+
+    GetSchemes().push_back (&instance);
+}
+
+AuthScheme *
+AuthScheme::Find(const char *typestr)
+{
+    for (iterator i = GetSchemes().begin(); i != GetSchemes().end(); ++i) {
+        if (strcmp ((*i)->type(), typestr) == 0)
+            return *i;
+    }
+
+    return NULL;
+}
+
+Vector<AuthScheme *> const &
+AuthScheme::Schemes()
+{
+    return GetSchemes();
+}
+
+Vector<AuthScheme*> &
+AuthScheme::GetSchemes()
+{
+    if (!_Schemes)
+        _Schemes = new Vector<AuthScheme *>;
+
+    return *_Schemes;
+}
+
+/*
+ * called when a graceful shutdown is to occur
+ * of each scheme module.
+ */
+void
+AuthScheme::FreeAll()
+{
+    while (GetSchemes().size()) {
+        AuthScheme *scheme = GetSchemes().back();
+        GetSchemes().pop_back();
+        scheme->done();
+    }
+}
@@ -0,0 +1,79 @@
+
+/*
+ * $Id: AuthScheme.h,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_AUTHSCHEME_H
+#define SQUID_AUTHSCHEME_H
+
+#include "squid.h"
+#include "Array.h"
+
+/* I represent a authentication scheme. For now my children
+ * store both the scheme metadata, and the scheme configuration/
+ * Should we need multiple configs of a single scheme,
+ * a new class AuthConfiguration should be made, and the
+ * config specific calls on AuthScheme moved to it.
+ */
+
+class AuthScheme
+{
+
+public:
+    static void AddScheme(AuthScheme &);
+    static void FreeAll();
+    static Vector<AuthScheme*> const &Schemes();
+    static AuthScheme *Find(const char *);
+    typedef Vector<AuthScheme*>::iterator iterator;
+    typedef Vector<AuthScheme*>::const_iterator const_iterator;
+    AuthScheme() : initialised (false) {}
+
+    virtual ~AuthScheme(){}
+
+    /* per scheme methods */
+    virtual char const *type () const = 0;
+    virtual void done() = 0;
+    virtual AuthConfig *createConfig() = 0;
+    // Not implemented
+    AuthScheme(AuthScheme const &);
+    AuthScheme &operator=(AuthScheme const&);
+
+protected:
+    bool initialised;
+
+private:
+    static Vector<AuthScheme*> &GetSchemes();
+    static Vector<AuthScheme*> *_Schemes;
+};
+
+
+
+#endif /* SQUID_AUTHSCHEME_H */
@@ -0,0 +1,266 @@
+
+/*
+ * $Id: AuthUser.cc,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ * DEBUG: section 29    Authenticator
+ * AUTHOR:  Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#include "squid.h"
+#include "AuthUser.h"
+#include "AuthUserRequest.h"
+#include "AuthConfig.h"
+#include "authenticate.h"
+#include "ACL.h"
+
+#ifndef _USE_INLINE_
+#include "AuthUser.cci"
+#endif
+
+AuthUser::AuthUser (AuthConfig *aConfig) :
+        auth_type (AUTH_UNKNOWN), config(aConfig),
+        usernamehash (NULL), ipcount (0), expiretime (0), references (0), username_(NULL)
+{
+    proxy_auth_list.head = proxy_auth_list.tail = NULL;
+    proxy_match_cache.head = proxy_match_cache.tail = NULL;
+    ip_list.head = ip_list.tail = NULL;
+    requests.head = requests.tail = NULL;
+    debug(29, 5) ("AuthUser::AuthUser: Initialised auth_user '%p' with refcount '%ld'.\n", this, (long int) references);
+}
+
+/* Combine two user structs. ONLY to be called from within a scheme
+ * module. The scheme module is responsible for ensuring that the
+ * two users _can_ be merged without invalidating all the request
+ * scheme data. The scheme is also responsible for merging any user
+ * related scheme data itself.
+ */
+void
+AuthUser::absorb (AuthUser *from)
+{
+    auth_user_request_t *auth_user_request;
+    /*
+     * XXX combine two authuser structs. Incomplete: it should merge
+     * in hash references too and ask the module to merge in scheme
+     * data
+     */
+    debug(29, 5) ("authenticateAuthUserMerge auth_user '%p' into auth_user '%p'.\n", from, this);
+    dlink_node *link = from->requests.head;
+
+    while (link) {
+        auth_user_request = static_cast<auth_user_request_t *>(link->data);
+        dlink_node *tmplink = link;
+        link = link->next;
+        dlinkDelete(tmplink, &from->requests);
+        dlinkAddTail(auth_user_request, tmplink, &requests);
+        auth_user_request->user(this);
+    }
+
+    references += from->references;
+    from->references = 0;
+    delete from;
+}
+
+AuthUser::~AuthUser()
+{
+    auth_user_request_t *auth_user_request;
+    dlink_node *link, *tmplink;
+    debug(29, 5) ("AuthUser::~AuthUser: Freeing auth_user '%p' with refcount '%ld'.\n", this, (long int) references);
+    assert(references == 0);
+    /* were they linked in by username ? */
+
+    if (usernamehash) {
+        assert(usernamehash->user() == this);
+        debug(29, 5) ("AuthUser::~AuthUser: removing usernamehash entry '%p'\n", usernamehash);
+        hash_remove_link(proxy_auth_username_cache,
+                         (hash_link *) usernamehash);
+        /* don't free the key as we use the same user string as the auth_user
+         * structure */
+        delete usernamehash;
+    }
+
+    /* remove any outstanding requests */
+    link = requests.head;
+
+    while (link) {
+        debug(29, 5) ("AuthUser::~AuthUser: removing request entry '%p'\n", link->data);
+        auth_user_request = static_cast<auth_user_request_t *>(link->data);
+        tmplink = link;
+        link = link->next;
+        dlinkDelete(tmplink, &requests);
+        dlinkNodeDelete(tmplink);
+        delete auth_user_request;
+    }
+
+    /* free cached acl results */
+    aclCacheMatchFlush(&proxy_match_cache);
+
+    /* free seen ip address's */
+    clearIp();
+
+    if (username())
+        xfree((char *)username());
+
+    /* prevent accidental reuse */
+    auth_type = AUTH_UNKNOWN;
+}
+
+void
+AuthUser::cacheInit(void)
+{
+    if (!proxy_auth_username_cache) {
+        /* First time around, 7921 should be big enough */
+        proxy_auth_username_cache =
+            hash_create((HASHCMP *) strcmp, 7921, hash_string);
+        assert(proxy_auth_username_cache);
+        eventAdd("User Cache Maintenance", cacheCleanup, NULL, Config.authenticateGCInterval, 1);
+    }
+}
+
+void
+AuthUser::CachedACLsReset()
+{
+    /*
+     * We walk the hash by username as that is the unique key we use.
+     * This must complete all at once, because we are ensuring correctness.
+     */
+    AuthUserHashPointer *usernamehash;
+    auth_user_t *auth_user;
+    char const *username = NULL;
+    debug(29, 3) ("AuthUser::CachedACLsReset: Flushing the ACL caches for all users.\n");
+    hash_first(proxy_auth_username_cache);
+
+    while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
+        auth_user = usernamehash->user();
+        username = auth_user->username();
+        /* free cached acl results */
+        aclCacheMatchFlush(&auth_user->proxy_match_cache);
+
+    }
+
+    debug(29, 3) ("AuthUser::CachedACLsReset: Finished.\n");
+}
+
+void
+AuthUser::cacheCleanup(void *datanotused)
+{
+    /*
+     * We walk the hash by username as that is the unique key we use.
+     * For big hashs we could consider stepping through the cache, 100/200
+     * entries at a time. Lets see how it flys first.
+     */
+    AuthUserHashPointer *usernamehash;
+    auth_user_t *auth_user;
+    char const *username = NULL;
+    debug(29, 3) ("AuthUser::cacheCleanup: Cleaning the user cache now\n");
+    debug(29, 3) ("AuthUser::cacheCleanup: Current time: %ld\n", (long int) current_time.tv_sec);
+    hash_first(proxy_auth_username_cache);
+
+    while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
+        auth_user = usernamehash->user();
+        username = auth_user->username();
+
+        /* if we need to have inpedendent expiry clauses, insert a module call
+         * here */
+        debug(29, 4) ("AuthUser::cacheCleanup: Cache entry:\n\tType: %d\n\tUsername: %s\n\texpires: %ld\n\treferences: %ld\n", auth_user->auth_type, username, (long int) (auth_user->expiretime + Config.authenticateTTL), (long int) auth_user->references);
+
+        if (auth_user->expiretime + Config.authenticateTTL <= current_time.tv_sec) {
+            debug(29, 5) ("AuthUser::cacheCleanup: Removing user %s from cache due to timeout.\n", username);
+            /* the minus 1 accounts for the cache lock */
+
+            if (!(authenticateAuthUserInuse(auth_user) - 1))
+                /* we don't warn if we leave the user in the cache,
+                 * because other modules (ie delay pools) may keep
+                 * locks on users, and thats legitimate
+                 */
+                auth_user->unlock();
+        }
+    }
+
+    debug(29, 3) ("AuthUser::cacheCleanup: Finished cleaning the user cache.\n");
+    eventAdd("User Cache Maintenance", cacheCleanup, NULL, Config.authenticateGCInterval, 1);
+}
+
+void
+AuthUser::clearIp()
+{
+    auth_user_ip_t *ipdata, *tempnode;
+
+    ipdata = (auth_user_ip_t *) ip_list.head;
+
+    while (ipdata) {
+        tempnode = (auth_user_ip_t *) ipdata->node.next;
+        /* walk the ip list */
+        dlinkDelete(&ipdata->node, &ip_list);
+        cbdataFree(ipdata);
+        /* catch incipient underflow */
+        assert(ipcount);
+        ipcount--;
+        ipdata = tempnode;
+    }
+
+    /* integrity check */
+    assert(ipcount == 0);
+}
+
+void
+
+AuthUser::lock()
+{
+    debug(29, 9) ("authenticateAuthUserLock auth_user '%p'.\n", this);
+    assert(this != NULL);
+    references++;
+    debug(29, 9) ("authenticateAuthUserLock auth_user '%p' now at '%ld'.\n", this, (long int) references);
+}
+
+void
+AuthUser::unlock()
+{
+    debug(29, 9) ("authenticateAuthUserUnlock auth_user '%p'.\n", this);
+    assert(this != NULL);
+
+    if (references > 0) {
+        references--;
+    } else {
+        debug(29, 1) ("Attempt to lower Auth User %p refcount below 0!\n", this);
+    }
+
+    debug(29, 9) ("authenticateAuthUserUnlock auth_user '%p' now at '%ld'.\n", this, (long int) references);
+
+    if (references == 0)
+        delete this;
+}
+
+/* addToNameCache: add a auth_user structure to the username cache */
+void
+AuthUser::addToNameCache()
+{
+    usernamehash = new AuthUserHashPointer (this);
+}
@@ -0,0 +1,61 @@
+
+/*
+ * $Id: AuthUser.cci,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ * DEBUG: section 29    Authenticator
+ * AUTHOR:  Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+char const *
+AuthUser::username () const
+{
+    return username_;
+}
+
+void
+AuthUser::username(char const*aString)
+{
+    assert (!username() || !aString);
+    username_ = aString;
+}
+
+void
+AuthUser::addRequest(AuthUserRequest *request)
+{
+    /* lock for the request link */
+
+    lock()
+
+        ;
+    dlink_node *node = dlinkNodeNew();
+
+    dlinkAdd(request, node, &requests);
+}
@@ -0,0 +1,96 @@
+
+/*
+ * $Id: AuthUser.h,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_AUTHUSER_H
+#define SQUID_AUTHUSER_H
+
+class AuthUser
+{
+
+public:
+    /* extra fields for proxy_auth */
+    /* auth_type and auth_module are deprecated. Do Not add new users of these fields.
+     * Aim to remove shortly
+     */
+    /* this determines what scheme owns the user data. */
+    auth_type_t auth_type;
+    /* the config for this user */
+    AuthConfig *config;
+    /* we only have one username associated with a given auth_user struct */
+    auth_user_hash_pointer *usernamehash;
+    /* we may have many proxy-authenticate strings that decode to the same user */
+    dlink_list proxy_auth_list;
+    dlink_list proxy_match_cache;
+    /* what ip addresses has this user been seen at?, plus a list length cache */
+    dlink_list ip_list;
+    size_t ipcount;
+    long expiretime;
+    /* how many references are outstanding to this instance */
+    size_t references;
+    /* the auth_user_request structures that link to this. Yes it could be a splaytree
+     * but how many requests will a single username have in parallel? */
+    dlink_list requests;
+
+public:
+    static void cacheInit ();
+    static void CachedACLsReset();
+
+    void absorb(auth_user_t *from);
+    virtual ~AuthUser ();
+    _SQUID_INLINE_ char const *username() const;
+    _SQUID_INLINE_ void username(char const *);
+    void clearIp();
+    _SQUID_INLINE_ void addRequest(AuthUserRequest *);
+
+    void lock()
+
+        ;
+    void unlock();
+
+    void addToNameCache();
+
+protected:
+    AuthUser (AuthConfig *);
+
+private:
+    static void cacheCleanup (void *unused);
+
+    char const *username_;
+};
+
+#ifdef _USE_INLINE_
+#include "AuthUser.cci"
+#endif
+
+#endif /* SQUID_AUTHUSER_H */
@@ -0,0 +1,772 @@
+
+/*
+ * $Id: AuthUserRequest.cc,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ * DO NOT MODIFY NEXT 2 LINES:
+ * arch-tag: 6803fde1-d5a2-4c29-9034-1c0c9f650eb4
+ *
+ * DEBUG: section 29    Authenticator
+ * AUTHOR:  Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/* The functions in this file handle authentication.
+ * They DO NOT perform access control or auditing.
+ * See acl.c for access control and client_side.c for auditing */
+
+#include "squid.h"
+#include "AuthUserRequest.h"
+#include "AuthUser.h"
+/*#include "authenticate.h"
+#include "ACL.h"
+#include "client_side.h"
+*/
+#include "AuthConfig.h"
+#include "AuthScheme.h"
+#include "HttpReply.h"
+#include "HttpRequest.h"
+
+CBDATA_TYPE(auth_user_ip_t);
+
+/* Generic Functions */
+
+size_t
+AuthUserRequest::refCount () const
+{
+    return references;
+}
+
+char const *
+AuthUserRequest::username() const
+{
+    if (user())
+        return user()->username();
+    else
+        return NULL;
+}
+
+size_t
+authenticateRequestRefCount (auth_user_request_t *aRequest)
+{
+    return aRequest->refCount();
+}
+
+/**** PUBLIC FUNCTIONS (ALL GENERIC!)  ****/
+
+/* send the initial data to an authenticator module */
+void
+AuthUserRequest::start(RH * handler, void *data)
+{
+    assert(handler);
+    debug(29, 9) ("authenticateStart: auth_user_request '%p'\n", this);
+    module_start(handler, data);
+}
+
+/*
+ * Check a auth_user pointer for validity. Does not check passwords, just data
+ * sensability. Broken or Unknown auth_types are not valid for use...
+ */
+
+int
+authenticateValidateUser(auth_user_request_t * auth_user_request)
+{
+    debug(29, 9) ("authenticateValidateUser: Validating Auth_user request '%p'.\n", auth_user_request);
+
+    if (auth_user_request == NULL) {
+        debug(29, 4) ("authenticateValidateUser: Auth_user_request was NULL!\n");
+        return 0;
+    }
+
+    if (auth_user_request->user() == NULL) {
+        debug(29, 4) ("authenticateValidateUser: No associated auth_user structure\n");
+        return 0;
+    }
+
+    if (auth_user_request->user()->auth_type == AUTH_UNKNOWN) {
+        debug(29, 4) ("authenticateValidateUser: Auth_user '%p' uses unknown scheme.\n", auth_user_request->user());
+        return 0;
+    }
+
+    if (auth_user_request->user()->auth_type == AUTH_BROKEN) {
+        debug(29, 4) ("authenticateValidateUser: Auth_user '%p' is broken for it's scheme.\n", auth_user_request->user());
+        return 0;
+    }
+
+    /* any other sanity checks that we need in the future */
+
+    /* Thus should a module call to something like authValidate */
+
+    /* finally return ok */
+    debug(29, 5) ("authenticateValidateUser: Validated Auth_user request '%p'.\n", auth_user_request);
+
+    return 1;
+
+}
+
+void *
+AuthUserRequest::operator new (size_t byteCount)
+{
+    fatal ("AuthUserRequest not directly allocatable\n");
+    return (void *)1;
+}
+
+void
+AuthUserRequest::operator delete (void *address)
+{
+    fatal ("AuthUserRequest child failed to override operator delete\n");
+}
+
+AuthUserRequest::AuthUserRequest():_auth_user(NULL), message(NULL),
+        references (0), lastReply (AUTH_ACL_CANNOT_AUTHENTICATE)
+{
+    debug(29, 5) ("AuthUserRequest::AuthUserRequest: initialised request %p\n", this);
+}
+
+AuthUserRequest::~AuthUserRequest()
+{
+    dlink_node *link;
+    debug(29, 5) ("AuthUserRequest::~AuthUserRequest: freeing request %p\n", this);
+    assert(references == 0);
+
+    if (user()) {
+        /* unlink from the auth_user struct */
+        link = user()->requests.head;
+
+        while (link && (link->data != this))
+            link = link->next;
+
+        assert(link != NULL);
+
+        dlinkDelete(link, &user()->requests);
+
+        dlinkNodeDelete(link);
+
+        /* unlock the request structure's lock */
+        user()->unlock();
+
+        user(NULL);
+    }
+
+    safe_free (message);
+}
+
+void
+AuthUserRequest::setDenyMessage (char const *aString)
+{
+    safe_free (message);
+    message = xstrdup (aString);
+}
+
+char const *
+AuthUserRequest::getDenyMessage ()
+{
+    return message;
+}
+
+char const *
+AuthUserRequest::denyMessage(char const * const default_message)
+{
+    if (this == NULL || getDenyMessage() == NULL) {
+        return default_message;
+    }
+
+    return getDenyMessage();
+}
+
+static void
+
+authenticateAuthUserRequestSetIp(auth_user_request_t * auth_user_request, struct in_addr ipaddr)
+{
+    auth_user_ip_t *ipdata, *tempnode;
+    auth_user_t *auth_user;
+    char *ip1;
+    int found = 0;
+    CBDATA_INIT_TYPE(auth_user_ip_t);
+
+    if (!auth_user_request->user())
+        return;
+
+    auth_user = auth_user_request->user();
+
+    ipdata = (auth_user_ip_t *) auth_user->ip_list.head;
+
+    /*
+     * we walk the entire list to prevent the first item in the list
+     * preventing old entries being flushed and locking a user out after
+     * a timeout+reconfigure
+     */
+    while (ipdata)
+    {
+        tempnode = (auth_user_ip_t *) ipdata->node.next;
+        /* walk the ip list */
+
+        if (ipdata->ipaddr.s_addr == ipaddr.s_addr) {
+            /* This ip has alreadu been seen. */
+            found = 1;
+            /* update IP ttl */
+            ipdata->ip_expiretime = squid_curtime;
+        } else if (ipdata->ip_expiretime + Config.authenticateIpTTL < squid_curtime) {
+            /* This IP has expired - remove from the seen list */
+            dlinkDelete(&ipdata->node, &auth_user->ip_list);
+            cbdataFree(ipdata);
+            /* catch incipient underflow */
+            assert(auth_user->ipcount);
+            auth_user->ipcount--;
+        }
+
+        ipdata = tempnode;
+    }
+
+    if (found)
+        return;
+
+    /* This ip is not in the seen list */
+    ipdata = cbdataAlloc(auth_user_ip_t);
+
+    ipdata->ip_expiretime = squid_curtime;
+
+    ipdata->ipaddr = ipaddr;
+
+    dlinkAddTail(ipdata, &ipdata->node, &auth_user->ip_list);
+
+    auth_user->ipcount++;
+
+    ip1 = xstrdup(inet_ntoa(ipaddr));
+
+    debug(29, 2) ("authenticateAuthUserRequestSetIp: user '%s' has been seen at a new IP address (%s)\n", auth_user->username(), ip1);
+
+    safe_free(ip1);
+}
+
+void
+
+authenticateAuthUserRequestRemoveIp(auth_user_request_t * auth_user_request, struct in_addr ipaddr)
+{
+    auth_user_ip_t *ipdata;
+    auth_user_t *auth_user;
+
+    if (!auth_user_request->user())
+        return;
+
+    auth_user = auth_user_request->user();
+
+    ipdata = (auth_user_ip_t *) auth_user->ip_list.head;
+
+    while (ipdata)
+    {
+        /* walk the ip list */
+
+        if (ipdata->ipaddr.s_addr == ipaddr.s_addr) {
+            /* remove the node */
+            dlinkDelete(&ipdata->node, &auth_user->ip_list);
+            cbdataFree(ipdata);
+            /* catch incipient underflow */
+            assert(auth_user->ipcount);
+            auth_user->ipcount--;
+            return;
+        }
+
+        ipdata = (auth_user_ip_t *) ipdata->node.next;
+    }
+
+}
+
+void
+authenticateAuthUserRequestClearIp(auth_user_request_t * auth_user_request)
+{
+    if (auth_user_request)
+        auth_user_request->user()->clearIp();
+}
+
+size_t
+authenticateAuthUserRequestIPCount(auth_user_request_t * auth_user_request)
+{
+    assert(auth_user_request);
+    assert(auth_user_request->user());
+    return auth_user_request->user()->ipcount;
+}
+
+
+/*
+ * authenticateUserAuthenticated: is this auth_user structure logged in ?
+ */
+int
+authenticateUserAuthenticated(auth_user_request_t * auth_user_request)
+{
+    if (!authenticateValidateUser(auth_user_request))
+        return 0;
+
+    return auth_user_request->authenticated();
+}
+
+int
+AuthUserRequest::direction()
+{
+    if (authenticateUserAuthenticated(this))
+        return 0;
+
+    return module_direction();
+
+    return -2;
+}
+
+void
+AuthUserRequest::addHeader(HttpReply * rep, int accelerated)
+{}
+
+void
+AuthUserRequest::addTrailer(HttpReply * rep, int accelerated)
+{}
+
+void
+AuthUserRequest::onConnectionClose(ConnStateData *)
+{}
+
+const char *
+AuthUserRequest::connLastHeader()
+{
+    fatal("AuthUserRequest::connLastHeader should always be overridden by conn based auth schemes");
+    return NULL;
+}
+
+/*
+ * authenticateAuthenticateUser: call the module specific code to 
+ * log this user request in.
+ * Cache hits may change the auth_user pointer in the structure if needed.
+ * This is basically a handle approach.
+ */
+static void
+authenticateAuthenticateUser(auth_user_request_t * auth_user_request, HttpRequest * request, ConnStateData::Pointer &conn, http_hdr_type type)
+{
+    assert(auth_user_request != NULL);
+
+    auth_user_request->authenticate(request, conn, type);
+}
+
+static auth_user_request_t *
+authTryGetUser (auth_user_request_t **auth_user_request, ConnStateData::Pointer & conn, HttpRequest * request)
+{
+    if (*auth_user_request)
+        return *auth_user_request;
+    else if (request != NULL && request->auth_user_request)
+        return request->auth_user_request;
+    else if (conn.getRaw() != NULL)
+        return conn->auth_user_request;
+    else
+        return NULL;
+}
+
+/* returns one of
+ * AUTH_ACL_CHALLENGE,
+ * AUTH_ACL_HELPER,
+ * AUTH_ACL_CANNOT_AUTHENTICATE,
+ * AUTH_AUTHENTICATED
+ *
+ * How to use: In your proxy-auth dependent acl code, use the following 
+ * construct:
+ * int rv;
+ * if ((rv = AuthenticateAuthenticate()) != AUTH_AUTHENTICATED)
+ *   return rv;
+ * 
+ * when this code is reached, the request/connection is authenticated.
+ *
+ * if you have non-acl code, but want to force authentication, you need a 
+ * callback mechanism like the acl testing routines that will send a 40[1|7] to
+ * the client when rv==AUTH_ACL_CHALLENGE, and will communicate with 
+ * the authenticateStart routine for rv==AUTH_ACL_HELPER
+ */
+auth_acl_t
+
+AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr)
+{
+    const char *proxy_auth;
+    assert(headertype != 0);
+
+    proxy_auth = httpHeaderGetStr(&request->header, headertype);
+
+    /*
+     * a note on proxy_auth logix here:
+     * proxy_auth==NULL -> unauthenticated request || already
+     * authenticated connection so we test for an authenticated
+     * connection when we recieve no authentication header.
+     */
+
+    if (((proxy_auth == NULL) && (!authenticateUserAuthenticated(authTryGetUser(auth_user_request,conn,request))))
+            || (conn.getRaw() != NULL  && conn->auth_type == AUTH_BROKEN))
+    {
+        /* no header or authentication failed/got corrupted - restart */
+        debug(28, 4) ("authenticateAuthenticate: broken auth or no proxy_auth header. Requesting auth header.\n");
+        /* something wrong with the AUTH credentials. Force a new attempt */
+
+        if (conn.getRaw() != NULL) {
+            conn->auth_type = AUTH_UNKNOWN;
+
+            if (conn->auth_user_request)
+                conn->auth_user_request->unlock();
+
+            conn->auth_user_request = NULL;
+        }
+
+        if (*auth_user_request) {
+            /* unlock the ACL lock */
+            (*auth_user_request)->unlock();
+            auth_user_request = NULL;
+        }
+
+        return AUTH_ACL_CHALLENGE;
+    }
+
+    /*
+     * Is this an already authenticated connection with a new auth header?
+     * No check for function required in the if: its compulsory for conn based 
+     * auth modules
+     */
+    if (proxy_auth && conn.getRaw() != NULL && conn->auth_user_request &&
+            authenticateUserAuthenticated(conn->auth_user_request) &&
+            strcmp(proxy_auth, conn->auth_user_request->connLastHeader()))
+    {
+        debug(28, 2) ("authenticateAuthenticate: DUPLICATE AUTH - authentication header on already authenticated connection!. AU %p, Current user '%s' proxy_auth %s\n", conn->auth_user_request, conn->auth_user_request->username(), proxy_auth);
+        /* remove this request struct - the link is already authed and it can't be to
+         * reauth.
+         */
+
+        /* This should _only_ ever occur on the first pass through
+         * authenticateAuthenticate 
+         */
+        assert(*auth_user_request == NULL);
+        /* unlock the conn lock on the auth_user_request */
+        conn->auth_user_request->unlock();
+        /* mark the conn as non-authed. */
+        conn->auth_user_request = NULL;
+        /* Set the connection auth type */
+        conn->auth_type = AUTH_UNKNOWN;
+    }
+
+    /* we have a proxy auth header and as far as we know this connection has
+     * not had bungled connection oriented authentication happen on it. */
+    debug(28, 9) ("authenticateAuthenticate: header %s.\n", proxy_auth ? proxy_auth : "-");
+
+    if (*auth_user_request == NULL)
+    {
+        debug(28, 9) ("authenticateAuthenticate: This is a new checklist test on FD:%d\n",
+                      conn.getRaw() != NULL ? conn->fd : -1);
+
+        if ((!request->auth_user_request)
+                && (conn.getRaw() == NULL || conn->auth_type == AUTH_UNKNOWN)) {
+            /* beginning of a new request check */
+            debug(28, 4) ("authenticateAuthenticate: no connection authentication type\n");
+
+            if (!authenticateValidateUser(*auth_user_request =
+                                              AuthConfig::CreateAuthUser(proxy_auth))) {
+                if (*auth_user_request == NULL)
+                    return AUTH_ACL_CHALLENGE;
+
+                /* the decode might have left a username for logging, or a message to
+                 * the user */
+
+                if ((*auth_user_request)->username()) {
+                    /* lock the user for the request structure link */
+
+                    (*auth_user_request)->lock()
+
+                    ;
+                    request->auth_user_request = *auth_user_request;
+                }
+
+                /* unlock the ACL reference granted by ...createAuthUser. */
+                (*auth_user_request)->unlock();
+
+                *auth_user_request = NULL;
+
+                return AUTH_ACL_CHALLENGE;
+            }
+
+            /* the user_request comes prelocked for the caller to createAuthUser (us) */
+        } else if (request->auth_user_request) {
+            *auth_user_request = request->auth_user_request;
+            /* lock the user request for this ACL processing */
+
+            (*auth_user_request)->lock()
+
+            ;
+        } else {
+            assert (conn.getRaw() != NULL);
+
+            if (conn->auth_user_request != NULL) {
+                *auth_user_request = conn->auth_user_request;
+                /* lock the user request for this ACL processing */
+
+                (*auth_user_request)->lock()
+
+                ;
+            } else {
+                /* failed connection based authentication */
+                debug(28, 4) ("authenticateAuthenticate: Auth user request %p conn-auth user request %p conn type %d authentication failed.\n",
+                              *auth_user_request, conn->auth_user_request, conn->auth_type);
+                (*auth_user_request)->unlock();
+                *auth_user_request = NULL;
+                return AUTH_ACL_CHALLENGE;
+            }
+        }
+    }
+
+    if (!authenticateUserAuthenticated(*auth_user_request))
+    {
+        /* User not logged in. Log them in */
+        authenticateAuthenticateUser(*auth_user_request, request,
+                                     conn, headertype);
+
+        switch (authenticateDirection(*auth_user_request)) {
+
+        case 1:
+
+            if (!request->auth_user_request) {
+
+                (*auth_user_request)->lock()
+
+                ;
+                request->auth_user_request = *auth_user_request;
+            }
+
+            /* fallthrough to -2 */
+
+        case -2:
+            /* this ACL check is finished. Unlock. */
+            (*auth_user_request)->unlock();
+
+            *auth_user_request = NULL;
+
+            return AUTH_ACL_CHALLENGE;
+
+        case -1:
+            /* we are partway through authentication within squid,
+             * the *auth_user_request variables stores the auth_user_request
+             * for the callback to here - Do not Unlock */
+            return AUTH_ACL_HELPER;
+        }
+
+        /* on 0 the authentication is finished - fallthrough */
+        /* See if user authentication failed for some reason */
+        if (!authenticateUserAuthenticated(*auth_user_request)) {
+            if ((*auth_user_request)->username()) {
+                if (!request->auth_user_request) {
+                    /* lock the user for the request structure link */
+
+                    (*auth_user_request)->lock()
+
+                    ;
+                    request->auth_user_request = *auth_user_request;
+                }
+            }
+
+            /* this ACL check is finished. Unlock. */
+            (*auth_user_request)->unlock();
+
+            *auth_user_request = NULL;
+
+            return AUTH_ACL_CHALLENGE;
+        }
+    }
+
+    /* copy username to request for logging on client-side */
+    /* the credentials are correct at this point */
+    if (!request->auth_user_request)
+    {
+        /* lock the user for the request structure link */
+
+        (*auth_user_request)->lock()
+
+        ;
+        request->auth_user_request = *auth_user_request;
+
+        authenticateAuthUserRequestSetIp(*auth_user_request, src_addr);
+    }
+
+    /* Unlock the request - we've authenticated it */
+    (*auth_user_request)->unlock();
+
+    return AUTH_AUTHENTICATED;
+}
+
+auth_acl_t
+
+AuthUserRequest::tryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr)
+{
+    /* If we have already been called, return the cached value */
+    auth_user_request_t *t = authTryGetUser (auth_user_request, conn, request);
+
+    if (t && t->lastReply != AUTH_ACL_CANNOT_AUTHENTICATE
+            && t->lastReply != AUTH_ACL_HELPER)
+    {
+        if (!*auth_user_request)
+            *auth_user_request = t;
+
+        return t->lastReply;
+    }
+
+    /* ok, call the actual authenticator routine. */
+    auth_acl_t result = authenticate(auth_user_request, headertype, request, conn, src_addr);
+
+    t = authTryGetUser (auth_user_request, conn, request);
+
+    if (t && result != AUTH_ACL_CANNOT_AUTHENTICATE &&
+            result != AUTH_ACL_HELPER)
+        t->lastReply = result;
+
+    return result;
+}
+
+/* returns
+ * 0: no output needed
+ * 1: send to client
+ * -1: send to helper
+ * -2: authenticate broken in some fashion
+ */
+int
+authenticateDirection(auth_user_request_t * auth_user_request)
+{
+    if (!auth_user_request)
+        return -2;
+
+    return auth_user_request->direction();
+}
+
+void
+AuthUserRequest::addReplyAuthHeader(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated, int internal)
+/* send the auth types we are configured to support (and have compiled in!) */
+{
+    http_hdr_type type;
+
+    switch (rep->sline.status)
+    {
+
+    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
+        /* Proxy authorisation needed */
+        type = HDR_PROXY_AUTHENTICATE;
+        break;
+
+    case HTTP_UNAUTHORIZED:
+        /* WWW Authorisation needed */
+        type = HDR_WWW_AUTHENTICATE;
+        break;
+
+    default:
+        /* Keep GCC happy */
+        /* some other HTTP status */
+        type = HDR_ENUM_END;
+        break;
+    }
+
+    debug(29, 9) ("authenticateFixHeader: headertype:%d authuser:%p\n", type, auth_user_request);
+
+    if (((rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
+            || (rep->sline.status == HTTP_UNAUTHORIZED)) && internal)
+        /* this is a authenticate-needed response */
+    {
+
+        if ((auth_user_request != NULL) && !authenticateUserAuthenticated(auth_user_request))
+            /* scheme specific */
+            auth_user_request->user()->config->fixHeader(auth_user_request, rep, type, request);
+        else
+        {
+            /* call each configured & running authscheme */
+
+            for (authConfig::iterator  i = Config.authConfiguration.begin(); i != Config.authConfiguration.end(); ++i) {
+                AuthConfig *scheme = *i;
+
+                if (scheme->active())
+                    scheme->fixHeader(NULL, rep, type, request);
+                else
+                    debug(29, 4) ("authenticateFixHeader: Configured scheme %s not Active\n", scheme->type());
+            }
+        }
+
+    }
+    /*
+     * allow protocol specific headers to be _added_ to the existing
+     * response - ie digest auth
+     */
+
+    if (auth_user_request != NULL)
+    {
+        auth_user_request->addHeader(rep, accelerated);
+        auth_user_request->lastReply = AUTH_ACL_CANNOT_AUTHENTICATE;
+    }
+}
+
+void
+authenticateFixHeader(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated, int internal)
+{
+    AuthUserRequest::addReplyAuthHeader(rep, auth_user_request, request, accelerated, internal);
+}
+
+
+/* call the active auth module and allow it to add a trailer to the request */
+void
+authenticateAddTrailer(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated)
+{
+    if (auth_user_request != NULL)
+        auth_user_request->addTrailer(rep, accelerated);
+}
+
+void
+
+AuthUserRequest::lock()
+{
+    debug(29, 9) ("AuthUserRequest::lock: auth_user request '%p'.\n", this);
+    assert(this != NULL);
+    ++references;
+    debug(29, 9) ("AuthUserRequest::lock: auth_user request '%p' now at '%ld'.\n", this, (long int) references);
+}
+
+void
+AuthUserRequest::unlock()
+{
+    debug(29, 9) ("AuthUserRequest::unlock: auth_user request '%p'.\n", this);
+    assert(this != NULL);
+
+    if (references > 0) {
+        --references;
+    } else {
+        debug(29, 1) ("Attempt to lower Auth User request %p refcount below 0!\n", this);
+    }
+
+    debug(29, 9) ("AuthUserRequest::unlock: auth_user_request '%p' now at '%ld'.\n", this, (long int) references);
+
+    if (references == 0)
+        /* not locked anymore */
+        delete this;
+}
+
+AuthScheme *
+AuthUserRequest::scheme() const
+{
+    /* TODO: this should be overriden by the child and be essentially a no-op */
+    return AuthScheme::Find(user()->config->type());
+}
@@ -0,0 +1,142 @@
+
+/*
+ * $Id: AuthUserRequest.h,v 1.1 2004/08/30 03:28:56 robertc Exp $
+ *
+ * DO NOT MODIFY NEXT 2 LINES:
+ * arch-tag: 674533af-8b21-4641-b71a-74c4639072a0
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_AUTHUSERREQUEST_H
+#define SQUID_AUTHUSERREQUEST_H
+
+#include "client_side.h"
+
+class AuthUser;
+
+class ConnStateData;
+
+class AuthScheme;
+
+struct AuthUserIP
+{
+    dlink_node node;
+    /* IP addr this user authenticated from */
+
+    struct in_addr ipaddr;
+    time_t ip_expiretime;
+};
+
+class AuthUserRequest
+{
+
+public:
+    /* this is the object passed around by client_side and acl functions */
+    /* it has request specific data, and links to user specific data */
+    /* the user */
+    auth_user_t *_auth_user;
+
+    int direction();
+    virtual int authenticated() const = 0;
+    virtual void authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type) = 0;
+    /* template method */
+    virtual int module_direction() = 0;
+    virtual void addHeader(HttpReply * rep, int accel);
+    virtual void addTrailer(HttpReply * rep, int accel);
+    virtual void onConnectionClose(ConnStateData *);
+    virtual const char *connLastHeader();
+    /* template method */
+    virtual void module_start(RH *, void *) = 0;
+    virtual AuthUser *user() {return _auth_user;}
+
+    virtual const AuthUser *user() const {return _auth_user;}
+
+    virtual void user (AuthUser *aUser) {_auth_user=aUser;}
+
+public:
+
+    static auth_acl_t tryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, HttpRequest *, ConnStateData::Pointer, struct in_addr);
+    static void addReplyAuthHeader(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated, int internal);
+
+    AuthUserRequest();
+
+    virtual ~AuthUserRequest();
+    void *operator new (size_t byteCount);
+    void operator delete (void *address);
+
+    void start ( RH * handler, void *data);
+    char const * denyMessage (char const * const default_message = NULL);
+    /* these two are possibly overrideable in future */
+    void setDenyMessage (char const *);
+    char const * getDenyMessage ();
+
+
+    size_t refCount() const;
+
+    void lock ()
+
+        ;
+    void unlock ();
+
+    char const *username() const;
+
+    AuthScheme *scheme() const;
+
+private:
+
+    static auth_acl_t authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr);
+
+    /* return a message on the 407 error pages */
+    char *message;
+
+    /* how many 'processes' are working on this data */
+    size_t references;
+
+    /* We only attempt authentication once per http request. This
+     * is to allow multiple auth acl references from different _access areas
+     * when using connection based authentication
+     */
+    auth_acl_t lastReply;
+};
+
+/* AuthUserRequest */
+extern size_t authenticateRequestRefCount (auth_user_request_t *);
+
+extern void authenticateFixHeader(HttpReply *, auth_user_request_t *, HttpRequest *, int, int);
+extern void authenticateAddTrailer(HttpReply *, auth_user_request_t *, HttpRequest *, int);
+
+extern void authenticateAuthUserRequestRemoveIp(auth_user_request_t *, struct in_addr);
+extern void authenticateAuthUserRequestClearIp(auth_user_request_t *);
+extern size_t authenticateAuthUserRequestIPCount(auth_user_request_t *);
+extern int authenticateDirection(auth_user_request_t *);
+
+extern int authenticateUserAuthenticated(auth_user_request_t *);
+extern int authenticateValidateUser(auth_user_request_t *);
+
+#endif /* SQUID_AUTHUSERREQUEST_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayUser.cc,v 1.6 2003/08/04 22:14:40 robertc Exp $
+ * $Id: DelayUser.cc,v 1.7 2004/08/30 03:28:56 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -40,7 +40,8 @@
 #if DELAY_POOLS
 #include "squid.h"
 #include "DelayUser.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
+#include "AuthUser.h"
 #include "NullDelayId.h"
 #include "Store.h"
 
@@ -150,7 +151,7 @@ DelayUser::id(CompositePoolNode::CompositeSelectionDetails &details)
     if (!details.user)
         return new NullDelayId;
 
-    return new Id(this, details.user->auth_user);
+    return new Id(this, details.user->user());
 }
 
 void *
@@ -184,12 +185,15 @@ DelayUserBucket::operator delete (void *address)
 DelayUserBucket::DelayUserBucket(AuthUser *aUser) : authUser (aUser)
 {
     debug (77,3) ("DelayUserBucket::DelayUserBucket\n");
-    authenticateAuthUserLock (authUser);
+
+    authUser->lock()
+
+    ;
 }
 
 DelayUserBucket::~DelayUserBucket()
 {
-    authenticateAuthUserUnlock(authUser);
+    authUser->unlock();
     debug (77,3) ("DelayUserBucket::~DelayUserBucket\n");
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpRequest.cc,v 1.45 2003/09/01 03:49:37 robertc Exp $
+ * $Id: HttpRequest.cc,v 1.46 2004/08/30 03:28:56 robertc Exp $
  *
  * DEBUG: section 73    HTTP Request
  * AUTHOR: Duane Wessels
@@ -36,7 +36,7 @@
 
 #include "HttpRequest.h"
 #include "squid.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "HttpHeaderRange.h"
 
 static void httpRequestHdrCacheInit(HttpRequest * req);
@@ -131,7 +131,7 @@ requestDestroy(HttpRequest * req)
         fatal ("request being destroyed with body connection intact\n");
 
     if (req->auth_user_request)
-        authenticateAuthUserRequestUnlock(req->auth_user_request);
+        req->auth_user_request->unlock();
 
     safe_free(req->canonical);
 
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.92 2003/10/20 11:23:38 robertc Exp $
+#  $Id: Makefile.am,v 1.93 2004/08/30 03:28:56 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -22,6 +22,9 @@ else
 SNMPSOURCE = 
 endif
 
+TESTS=$(check_PROGRAMS)
+check_PROGRAMS=
+
 DELAY_POOL_ALL_SOURCE = \
 	CommonPool.h \
 	CompositePoolNode.h \
@@ -200,8 +203,14 @@ all_FSMODULES = \
 	fs/null/StoreFSnull.cc \
 	fs/ufs/StoreFSufs.cc
 
+all_AUTHMODULES = \
+	auth/basic/basicScheme.cc \
+	auth/digest/digestScheme.cc \
+	auth/ntlm/ntlmScheme.cc 
+
 EXTRA_squid_SOURCES = \
 	$(all_FSMODULES) \
+	$(all_AUTHMODULES) \
 	$(ARP_ACL_ALL_SOURCE) \
 	$(DELAY_POOL_ALL_SOURCE) \
 	dns.cc \
@@ -302,6 +311,12 @@ squid_SOURCES = \
 	asn.cc \
 	authenticate.cc \
 	authenticate.h \
+	AuthConfig.cc \
+	AuthConfig.h \
+	AuthScheme.cc \
+	AuthScheme.h \
+	AuthUser.cc \
+	AuthUserRequest.cc \
 	cache_cf.cc \
 	CacheDigest.cc \
 	cache_manager.cc \
@@ -471,6 +486,9 @@ squid_SOURCES = \
 	$(WIN32SOURCE)
 
 noinst_HEADERS = ACLChecklist.cci \
+	AuthUser.cci \
+	AuthUser.h \
+	AuthUserRequest.h \
 	client_side_request.cci \
 	MemBuf.cci \
 	MemBuf.h \
@@ -482,7 +500,6 @@ noinst_HEADERS = ACLChecklist.cci \
 
 nodist_squid_SOURCES = \
 	repl_modules.cc \
-	auth_modules.cc \
 	cf_parser.h \
 	globals.cc \
 	string_arrays.c
@@ -493,6 +510,7 @@ squid_LDADD = \
 	@REPL_OBJS@ \
 	@STORE_LINKOBJS@ \
 	@STORE_OBJS@ \
+	@AUTH_LINKOBJS@ \
 	@AUTH_OBJS@ \
 	@CRYPTLIB@ \
 	@REGEXLIB@ \
@@ -502,7 +520,10 @@ squid_LDADD = \
 	-lmiscutil \
 	@XTRA_LIBS@ \
 	@EPOLL_LIBS@
-squid_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a @STORE_OBJS@ @STORE_LINKOBJS@
+squid_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a @STORE_OBJS@ @STORE_LINKOBJS@ \
+	@REPL_OBJS@ \
+	@AUTH_LINKOBJS@ \
+	@AUTH_OBJS@
 
 unlinkd_SOURCES = unlinkd.cc SquidNew.cc
 unlinkd_CXXFLAGS = -DUNLINK_DAEMON
@@ -540,6 +561,7 @@ ufsdump_SOURCES = debug.cc \
 	$(squid_ACLSOURCES) \
 	asn.cc \
 	authenticate.cc \
+	AuthUser.cc \
 	cache_cf.cc \
 	CacheDigest.cc \
 	cache_manager.cc \
@@ -677,7 +699,6 @@ ufsdump_LDADD = \
 ufsdump_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a
 nodist_ufsdump_SOURCES = \
 	repl_modules.cc \
-	auth_modules.cc \
 	cf_parser.h \
 	globals.cc \
 	string_arrays.c
@@ -690,8 +711,7 @@ BUILT_SOURCES = \
 	cf_parser.h \
 	globals.cc \
 	string_arrays.c \
-	repl_modules.cc \
-	auth_modules.cc
+	repl_modules.cc
 
 sysconf_DATA = \
 	squid.conf.default \
@@ -707,7 +727,6 @@ EXTRA_DIST = \
 	cf.data.pre \
 	mk-globals-c.pl \
 	mk-string-arrays.pl \
-	auth_modules.sh \
 	repl_modules.sh \
 	mib.txt \
 	mime.conf.default
@@ -786,9 +805,6 @@ cf.data: cf.data.pre Makefile
 repl_modules.cc: repl_modules.sh Makefile
 	$(SHELL) $(srcdir)/repl_modules.sh $(REPL_POLICIES) > repl_modules.cc
 
-auth_modules.cc: auth_modules.sh Makefile
-	@$(SHELL) $(srcdir)/auth_modules.sh $(AUTH_MODULES) >auth_modules.cc
-
 install-data-local: install-sysconfDATA install-dataDATA
 	@if test -f $(DESTDIR)$(DEFAULT_MIME_TABLE) ; then \
 	        echo "$@ will not overwrite existing $(DESTDIR)$(DEFAULT_MIME_TABLE)" ; \
@@ -817,7 +833,7 @@ uninstall-local:
 #	fi
 
 DISTCLEANFILES = cf_gen_defines.h cf.data cf_parser.h squid.conf.default \
-	globals.cc string_arrays.c repl_modules.cc auth_modules.cc 
+	globals.cc string_arrays.c repl_modules.cc 
 
 ##install-pinger:
 ##	@f=$(PINGER_EXE); \
@@ -832,3 +848,29 @@ DISTCLEANFILES = cf_gen_defines.h cf.data cf_parser.h squid.conf.default \
 ##		$(RM) -f $(libexecdir)/-$$f; \
 ##	fi
 
+TESTSOURCES=../test-suite/test_tools.cc
+
+check_PROGRAMS+=tests/testAuth
+tests_testAuth_SOURCES= tests/testAuth.cc tests/testMain.cc  tests/testAuth.h $(TESTSOURCES) \
+	AuthScheme.cc globals.cc authenticate.cc AuthUser.cc AuthUserRequest.cc AuthConfig.cc \
+	tests/stub_acl.cc tests/stub_cache_cf.cc \
+	tests/stub_helper.cc cbdata.cc String.cc tests/stub_cache_manager.cc \
+	tests/stub_store.cc HttpHeaderTools.cc HttpHeader.cc acl.cc event.cc mem.cc \
+	MemBuf.cc HttpHdrContRange.cc Packer.cc ACLChecklist.cc HttpHdrCc.cc HttpHdrSc.cc \
+	HttpHdrScTarget.cc url.cc ACLProxyAuth.cc ACLRegexData.cc ACLUserData.cc \
+	StatHist.cc HttpHdrRange.cc ETag.cc tests/stub_errorpage.cc \
+	tests/stub_HttpRequest.cc
+##	acl.cc cache_cf.cc tools.cc \
+##	helper.cc String.cc cbdata.cc HttpHeaderTools.cc store.cc cache_manager.cc \
+##	HttpHeader.cc url.cc event.cc mem.cc HttpRequest.cc Packer.cc access_log.cc \
+##	MemBuf.cc StatHist.cc logfile.cc
+
+tests_testAuth_LDADD= \
+	@AUTH_LINKOBJS@ @AUTH_OBJS@ \
+	-L../lib -lmiscutil \
+	@SQUID_CPPUNIT_LA@
+tests_testAuth_LDFLAGS = $(LIBADD_DL)
+tests_testAuth_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
+	@AUTH_LINKOBJS@ \
+	@AUTH_OBJS@ \
+	@SQUID_CPPUNIT_LA@
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.322 2003/10/21 00:13:59 hno Exp $
+#  $Id: Makefile.in,v 1.323 2004/08/30 03:28:57 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -245,8 +245,8 @@ DELAY_POOL_ALL_SOURCE = \
 	NullDelayId.cc \
 	NullDelayId.h
 
-@USE_DELAY_POOLS_FALSE@DELAY_POOL_SOURCE = 
 @USE_DELAY_POOLS_TRUE@DELAY_POOL_SOURCE = $(DELAY_POOL_ALL_SOURCE)
+@USE_DELAY_POOLS_FALSE@DELAY_POOL_SOURCE = 
 
 ESI_ALL_SOURCE = \
 	ElementList.h \
@@ -285,14 +285,14 @@ ESI_ALL_SOURCE = \
 @ENABLE_XPROF_STATS_FALSE@XPROF_STATS_SOURCE = 
 
 @ENABLE_HTCP_TRUE@HTCPSOURCE = htcp.cc htcp.h
+@MAKE_LEAKFINDER_FALSE@LEAKFINDERSOURCE = 
 
 @MAKE_LEAKFINDER_TRUE@LEAKFINDERSOURCE = leakfinder.cc
-@MAKE_LEAKFINDER_FALSE@LEAKFINDERSOURCE = 
+@ENABLE_UNLINKD_FALSE@UNLINKDSOURCE = 
 
 @ENABLE_UNLINKD_TRUE@UNLINKDSOURCE = unlinkd.cc
-@ENABLE_UNLINKD_FALSE@UNLINKDSOURCE = 
-@ENABLE_UNLINKD_TRUE@UNLINKD = unlinkd
 @ENABLE_UNLINKD_FALSE@UNLINKD = 
+@ENABLE_UNLINKD_TRUE@UNLINKD = unlinkd
 
 @ENABLE_PINGER_TRUE@PINGER = pinger
 @ENABLE_PINGER_FALSE@PINGER = 
@@ -305,15 +305,15 @@ SSL_ALL_SOURCE = \
 	ssl_support.cc \
 	ssl_support.h
 
-@ENABLE_SSL_FALSE@SSL_SOURCE = 
 @ENABLE_SSL_TRUE@SSL_SOURCE = $(SSL_ALL_SOURCE)
-@ENABLE_WIN32SPECIFIC_FALSE@WIN32SOURCE = 
+@ENABLE_SSL_FALSE@SSL_SOURCE = 
 
 @ENABLE_WIN32SPECIFIC_TRUE@WIN32SOURCE = win32.cc
+@ENABLE_WIN32SPECIFIC_FALSE@WIN32SOURCE = 
 
 IDENT_ALL_SOURCE = ACLIdent.cc ACLIdent.h ident.cc
-@ENABLE_IDENT_TRUE@IDENT_SOURCE = $(IDENT_ALL_SOURCE)
 @ENABLE_IDENT_FALSE@IDENT_SOURCE = 
+@ENABLE_IDENT_TRUE@IDENT_SOURCE = $(IDENT_ALL_SOURCE)
 
 ARP_ACL_ALL_SOURCE = ACLARP.cc ACLARP.h
 @ENABLE_ARP_ACL_FALSE@ARP_ACL_SOURCE = 
@@ -1451,7 +1451,7 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = $(noinst_HEADERS) Makefile.am Makefile.in
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.in Makefile.am
 DIST_SUBDIRS = $(SUBDIRS)
 SOURCES = $(cachemgr__CGIEXT__SOURCES) $(cf_gen_SOURCES) $(dnsserver_SOURCES) $(pinger_SOURCES) $(nodist_pinger_SOURCES) $(recv_announce_SOURCES) $(squid_SOURCES) $(EXTRA_squid_SOURCES) $(nodist_squid_SOURCES) $(squidclient_SOURCES) $(ufsdump_SOURCES) $(nodist_ufsdump_SOURCES) $(unlinkd_SOURCES)
 
@@ -1814,9 +1814,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@fs/null/$(DEPDIR)/StoreFSnull.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@fs/ufs/$(DEPDIR)/StoreFSufs.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR) fs/aufs/$(DEPDIR) fs/coss/$(DEPDIR) fs/diskd/$(DEPDIR) fs/null/$(DEPDIR) fs/ufs/$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -2240,26 +2237,26 @@ install-am: all-am
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
-	-rm -f fs/coss/$(DEPDIR)/$(am__dirstamp)
+	-rm -f $(CONFIG_CLEAN_FILES)
+	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+	-rm -f fs/diskd/$(DEPDIR)/$(am__dirstamp)
 	-rm -f fs/null/$(DEPDIR)/$(am__dirstamp)
-	-rm -f fs/coss/$(am__dirstamp)
 	-rm -f fs/ufs/$(DEPDIR)/$(am__dirstamp)
 	-rm -f fs/null/$(am__dirstamp)
-	-rm -f fs/diskd/$(DEPDIR)/$(am__dirstamp)
-	-rm -f fs/aufs/$(DEPDIR)/$(am__dirstamp)
-	-rm -f fs/ufs/$(am__dirstamp)
 	-rm -f fs/aufs/$(am__dirstamp)
+	-rm -f fs/ufs/$(am__dirstamp)
 	-rm -f fs/diskd/$(am__dirstamp)
-	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+	-rm -f fs/coss/$(am__dirstamp)
+	-rm -f fs/coss/$(DEPDIR)/$(am__dirstamp)
+	-rm -f fs/aufs/$(DEPDIR)/$(am__dirstamp)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -2271,9 +2268,10 @@ clean-am: clean-binPROGRAMS clean-generic clean-libexecPROGRAMS \
 	clean-noinstPROGRAMS clean-sbinPROGRAMS mostlyclean-am
 
 distclean: distclean-recursive
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR) fs/aufs/$(DEPDIR) fs/coss/$(DEPDIR) fs/diskd/$(DEPDIR) fs/null/$(DEPDIR) fs/ufs/$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-recursive
 
@@ -2295,7 +2293,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -rf ./$(DEPDIR) fs/aufs/$(DEPDIR) fs/coss/$(DEPDIR) fs/diskd/$(DEPDIR) fs/null/$(DEPDIR) fs/ufs/$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -2319,10 +2318,10 @@ uninstall-info: uninstall-info-recursive
 .PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
 	clean-binPROGRAMS clean-generic clean-libexecPROGRAMS \
 	clean-noinstPROGRAMS clean-recursive clean-sbinPROGRAMS ctags \
-	ctags-recursive distclean distclean-compile distclean-depend \
-	distclean-generic distclean-recursive distclean-tags distdir \
-	dvi dvi-am dvi-recursive info info-am info-recursive install \
-	install-am install-binPROGRAMS install-data install-data-am \
+	ctags-recursive distclean distclean-compile distclean-generic \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-binPROGRAMS install-data install-data-am \
 	install-data-local install-data-recursive install-dataDATA \
 	install-exec install-exec-am install-exec-recursive \
 	install-info install-info-am install-info-recursive \
@@ -2337,7 +2336,7 @@ uninstall-info: uninstall-info-recursive
 	uninstall-info-am uninstall-info-recursive \
 	uninstall-libexecPROGRAMS uninstall-local uninstall-recursive \
 	uninstall-sbinPROGRAMS uninstall-sysconfDATA
-	$(MAKE) $(AM_MAKEFLAGS) install-am
+
 cf_gen.$(OBJEXT): cf_gen_defines.h
 
 $(OBJS): $(top_srcdir)/include/version.h ../include/autoconf.h
@@ -1,6 +1,6 @@
 
 /*
- * $Id: String.cc,v 1.17 2003/03/10 04:56:36 robertc Exp $
+ * $Id: String.cc,v 1.18 2004/08/30 03:28:57 robertc Exp $
  *
  * DEBUG: section 67    String
  * AUTHOR: Duane Wessels
@@ -267,6 +267,115 @@ StringRegistry::Stater(String const * const & nodedata, void *state)
 
 #endif
 
+/* TODO: move onto String */
+int
+stringHasWhitespace(const char *s)
+{
+    return strpbrk(s, w_space) != NULL;
+}
+
+/* TODO: move onto String */
+int
+stringHasCntl(const char *s)
+{
+    unsigned char c;
+
+    while ((c = (unsigned char) *s++) != '\0') {
+        if (c <= 0x1f)
+            return 1;
+
+        if (c >= 0x7f && c <= 0x9f)
+            return 1;
+    }
+
+    return 0;
+}
+
+/*
+ * Similar to strtok, but has some rudimentary knowledge
+ * of quoting
+ */
+char *
+strwordtok(char *buf, char **t)
+{
+    unsigned char *word = NULL;
+    unsigned char *p = (unsigned char *) buf;
+    unsigned char *d;
+    unsigned char ch;
+    int quoted = 0;
+
+    if (!p)
+        p = (unsigned char *) *t;
+
+    if (!p)
+        goto error;
+
+    while (*p && isspace(*p))
+        p++;
+
+    if (!*p)
+        goto error;
+
+    word = d = p;
+
+    while ((ch = *p)) {
+        switch (ch) {
+
+        case '\\':
+            p++;
+
+            switch (*p) {
+
+            case 'n':
+                ch = '\n';
+
+                break;
+
+            case 'r':
+                ch = '\r';
+
+                break;
+
+            default:
+                ch = *p;
+
+                break;
+
+            }
+
+            *d++ = ch;
+
+            if (ch)
+                p++;
+
+            break;
+
+        case '"':
+            quoted = !quoted;
+
+            p++;
+
+            break;
+
+        default:
+            if (!quoted && isspace(*p)) {
+                p++;
+                goto done;
+            }
+
+            *d++ = *p++;
+            break;
+        }
+    }
+
+done:
+    *d++ = '\0';
+
+error:
+    *t = (char *) p;
+    return (char *) word;
+}
+
 #ifndef _USE_INLINE_
 #include "String.cci"
 #endif
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -204,7 +204,7 @@ target_alias = @target_alias@
 
 #  Makefile for authentication modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.42 2003/07/23 00:14:50 hno Exp $
+#  $Id: Makefile.in,v 1.43 2004/08/30 03:29:00 robertc Exp $
 #
 AUTOMAKE_OPTIONS = subdir-objects
 AM_CFLAGS = @SQUID_CFLAGS@
@@ -258,7 +258,7 @@ CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(libbasic_a_SOURCES) $(libdigest_a_SOURCES) \
 	$(libntlm_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(libbasic_a_SOURCES) $(libdigest_a_SOURCES) $(libntlm_a_SOURCES)
 
 all: all-am
@@ -323,9 +323,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@digest/$(DEPDIR)/auth_digest.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ntlm/$(DEPDIR)/auth_ntlm.Po@am__quote@
 
-distclean-depend:
-	-rm -rf basic/$(DEPDIR) digest/$(DEPDIR) ntlm/$(DEPDIR)
-
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCXX_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -505,7 +502,6 @@ check: check-am
 all-am: Makefile $(LIBRARIES)
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -517,21 +513,21 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
-	-rm -f digest/$(DEPDIR)/$(am__dirstamp)
-	-rm -f basic/$(DEPDIR)/$(am__dirstamp)
+	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f ntlm/$(am__dirstamp)
 	-rm -f digest/$(am__dirstamp)
-	-rm -f basic/$(am__dirstamp)
+	-rm -f digest/$(DEPDIR)/$(am__dirstamp)
 	-rm -f ntlm/$(DEPDIR)/$(am__dirstamp)
-	-rm -f ntlm/$(am__dirstamp)
+	-rm -f basic/$(am__dirstamp)
+	-rm -f basic/$(DEPDIR)/$(am__dirstamp)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -541,9 +537,10 @@ clean: clean-am
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf basic/$(DEPDIR) digest/$(DEPDIR) ntlm/$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -564,7 +561,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf basic/$(DEPDIR) digest/$(DEPDIR) ntlm/$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -583,14 +581,13 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
+	ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,5 +1,5 @@
 /*
- * $Id: auth_basic.cc,v 1.29 2003/08/10 18:57:08 hno Exp $
+ * $Id: auth_basic.cc,v 1.30 2004/08/30 03:29:00 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -42,6 +42,7 @@
 #include "authenticate.h"
 #include "Store.h"
 #include "HttpReply.h"
+#include "basicScheme.h"
 
 static void
 authenticateStateFree(AuthenticateStateData * r)
@@ -52,29 +53,13 @@ authenticateStateFree(AuthenticateStateData * r)
 /* Basic Scheme */
 
 static HLPCB authenticateBasicHandleReply;
-static AUTHSACTIVE authenticateBasicActive;
-static AUTHSAUTHED authenticateBasicAuthenticated;
-static AUTHSAUTHUSER authenticateBasicAuthenticateUser;
-static AUTHSCONFIGURED authBasicConfigured;
-static AUTHSDIRECTION authenticateBasicDirection;
-static AUTHSDECODE authenticateBasicDecodeAuth;
-static AUTHSDUMP authBasicCfgDump;
-static AUTHSFIXERR authenticateBasicFixErrorHeader;
-static AUTHSFREE authenticateBasicFreeUser;
-static AUTHSFREECONFIG authBasicFreeConfig;
-static AUTHSPARSE authBasicParse;
-static AUTHSINIT authBasicInit;
-static AUTHSSTART authenticateBasicStart;
 static AUTHSSTATS authenticateBasicStats;
-static AUTHSUSERNAME authenticateBasicUsername;
-static AUTHSSHUTDOWN authBasicDone;
 
 static helper *basicauthenticators = NULL;
 
-static auth_basic_config *basicConfig = NULL;
+static AuthBasicConfig basicConfig;
 
 static int authbasic_initialised = 0;
-MemPool *basic_data_pool = NULL;
 
 
 /*
@@ -83,37 +68,14 @@ MemPool *basic_data_pool = NULL;
  *
  */
 
-AUTHSSETUP authSchemeSetup_basic;
-
-void
-authSchemeSetup_basic(authscheme_entry_t * authscheme)
-{
-    assert(!authbasic_initialised);
-    authscheme->Active = authenticateBasicActive;
-    authscheme->parse = authBasicParse;
-    authscheme->dump = authBasicCfgDump;
-    authscheme->init = authBasicInit;
-    authscheme->authAuthenticate = authenticateBasicAuthenticateUser;
-    authscheme->authenticated = authenticateBasicAuthenticated;
-    authscheme->configured = authBasicConfigured;
-    authscheme->authFixHeader = authenticateBasicFixErrorHeader;
-    authscheme->FreeUser = authenticateBasicFreeUser;
-    authscheme->freeconfig = authBasicFreeConfig;
-    authscheme->authStart = authenticateBasicStart;
-    authscheme->authStats = authenticateBasicStats;
-    authscheme->authUserUsername = authenticateBasicUsername;
-    authscheme->getdirection = authenticateBasicDirection;
-    authscheme->oncloseconnection = NULL;
-    authscheme->decodeauth = authenticateBasicDecodeAuth;
-    authscheme->donefunc = authBasicDone;
-    authscheme->authConnLastHeader = NULL;
-}
-
 /* internal functions */
 
-static void
-authBasicDone(void)
+/* TODO: move to basicScheme.cc - after all per request and user functions are moved out */
+void
+basicScheme::done()
 {
+    /* TODO: this should be a Config call. */
+
     if (basicauthenticators)
         helperShutdown(basicauthenticators);
 
@@ -127,101 +89,121 @@ authBasicDone(void)
 
     basicauthenticators = NULL;
 
-#if DEBUGSHUTDOWN
-
-    if (basic_data_pool) {
-        memPoolDestroy(&basic_data_pool);
-        basic_data_pool = NULL;
-    }
-
-#endif
+    /* XXX Reinstate auth shutdown for dynamic schemes? */
     debug(29, 2) ("authBasicDone: Basic authentication Shutdown.\n");
 }
 
-static int
-authenticateBasicActive()
+bool
+AuthBasicConfig::active() const
 {
-    return (authbasic_initialised == 1) ? 1 : 0;
+    return authbasic_initialised == 1;
 }
 
-static int
-authBasicConfigured()
+bool
+AuthBasicConfig::configured() const
 {
-    if ((basicConfig != NULL) && (basicConfig->authenticate != NULL) &&
-            (basicConfig->authenticateChildren != 0) &&
-            (basicConfig->basicAuthRealm != NULL)) {
+    if ((authenticate != NULL) && (authenticateChildren != 0) &&
+            (basicAuthRealm != NULL)) {
         debug(29, 9) ("authBasicConfigured: returning configured\n");
-        return 1;
+        return true;
     }
 
     debug(29, 9) ("authBasicConfigured: returning unconfigured\n");
-    return 0;
+    return false;
 }
 
-static int
-authenticateBasicAuthenticated(auth_user_request_t * auth_user_request)
+const char *
+AuthBasicConfig::type() const
 {
-    basic_data *basic_auth = static_cast<basic_data *>(auth_user_request->auth_user->scheme_data);
+    return basicScheme::GetInstance().type();
+}
 
-    if ((basic_auth->flags.credentials_ok == 1) && (basic_auth->credentials_checkedtime + basicConfig->credentialsTTL > squid_curtime))
-        return 1;
+MemPool (*AuthBasicUserRequest::Pool)(NULL);
+void *
+AuthBasicUserRequest::operator new (size_t byteCount)
+{
+    /* derived classes with different sizes must implement their own new */
+    assert (byteCount == sizeof (AuthBasicUserRequest));
 
-    debug(29, 4) ("User not authenticated or credentials need rechecking.\n");
+    if (!Pool)
+        Pool = memPoolCreate("AuthBasicUserRequest", sizeof (AuthBasicUserRequest));
 
-    return 0;
+    return memPoolAlloc(Pool);
 }
 
-#if UNUSED_CODE
-static int
-authenticateBasiccmpUsername(basic_data * u1, basic_data * u2)
+void
+AuthBasicUserRequest::operator delete (void *address)
+{
+    memPoolFree (Pool, address);
+}
+
+AuthBasicUserRequest::AuthBasicUserRequest() : _theUser(NULL)
+{}
+
+AuthBasicUserRequest::~AuthBasicUserRequest()
+{}
+
+
+bool
+BasicUser::authenticated() const
 {
-    return strcmp(u1->username, u2->username);
+    if ((flags.credentials_ok == 1) && (credentials_checkedtime + basicConfig.credentialsTTL > squid_curtime))
+        return true;
+
+    debug(29, 4) ("User not authenticated or credentials need rechecking.\n");
+
+    return false;
 }
 
-#endif
+int
+AuthBasicUserRequest::authenticated() const
+{
+    BasicUser const *basic_auth = dynamic_cast<BasicUser const *>(user());
+    assert (user());
+
+    if (basic_auth->authenticated())
+        return 1;
+
+    return 0;
+}
 
 /* log a basic user in
  */
-static void
-authenticateBasicAuthenticateUser(auth_user_request_t * auth_user_request, HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
+void
+AuthBasicUserRequest::authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
-    auth_user_t *auth_user;
-    basic_data *basic_auth;
-
-    assert(auth_user_request->auth_user != NULL);
-    auth_user = auth_user_request->auth_user;
+    assert(user() != NULL);
 
-    assert(auth_user->scheme_data != NULL);
-    basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
+    basic_data *basic_auth = dynamic_cast<BasicUser *>(user());
 
     /* if the password is not ok, do an identity */
 
     if (basic_auth->flags.credentials_ok != 1)
         return;
 
     /* are we about to recheck the credentials externally? */
-    if ((basic_auth->credentials_checkedtime + basicConfig->credentialsTTL) <= squid_curtime) {
+    if ((basic_auth->credentials_checkedtime + basicConfig.credentialsTTL) <= squid_curtime) {
         debug(29, 4) ("authBasicAuthenticate: credentials expired - rechecking\n");
         return;
     }
 
     /* we have been through the external helper, and the credentials haven't expired */
     debug(29, 9) ("authenticateBasicAuthenticateuser: user '%s' authenticated\n",
-                  basic_auth->username);
+                  basic_auth->username());
 
-    /* Decode now takes care of finding the auth_user struct in the cache */
+    /* Decode now takes care of finding the AuthUser struct in the cache */
     /* after external auth occurs anyway */
-    auth_user->expiretime = current_time.tv_sec;
+    basic_auth->expiretime = current_time.tv_sec;
 
     return;
 }
 
 int
-authenticateBasicDirection(auth_user_request_t * auth_user_request)
+AuthBasicUserRequest::module_direction()
 {
     /* null auth_user is checked for by authenticateDirection */
-    auth_user_t *auth_user = auth_user_request->auth_user;
-    basic_data *basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
+    basic_data *basic_auth = dynamic_cast<BasicUser *>(user());
+    assert (basic_auth);
 
     switch (basic_auth->flags.credentials_ok) {
 
@@ -230,7 +212,7 @@ authenticateBasicDirection(auth_user_request_t * auth_user_request)
 
     case 1:			/* checked & ok */
 
-        if (basic_auth->credentials_checkedtime + basicConfig->credentialsTTL <= squid_curtime)
+        if (basic_auth->credentials_checkedtime + basicConfig.credentialsTTL <= squid_curtime)
             return -1;
 
         return 0;
@@ -246,57 +228,37 @@ authenticateBasicDirection(auth_user_request_t * auth_user_request)
 }
 
 void
-authenticateBasicFixErrorHeader(auth_user_request_t * auth_user_request, HttpReply * rep, http_hdr_type type, HttpRequest * request)
+AuthBasicConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply *rep, http_hdr_type type, HttpRequest * request)
 {
-    if (basicConfig->authenticate) {
-        debug(29, 9) ("authenticateFixErrorHeader: Sending type:%d header: 'Basic realm=\"%s\"'\n", type, basicConfig->basicAuthRealm);
-        httpHeaderPutStrf(&rep->header, type, "Basic realm=\"%s\"", basicConfig->basicAuthRealm);
+    if (authenticate) {
+        debug(29, 9) ("authenticateFixErrorHeader: Sending type:%d header: 'Basic realm=\"%s\"'\n", type, basicAuthRealm);
+        httpHeaderPutStrf(&rep->header, type, "Basic realm=\"%s\"", basicAuthRealm);
     }
 }
 
 /* free any allocated configuration details */
 void
-authBasicFreeConfig(authScheme * scheme)
+AuthBasicConfig::done()
 {
-    if (basicConfig == NULL)
-        return;
-
-    assert(basicConfig == scheme->scheme_data);
-
-    if (basicConfig->authenticate)
-        wordlistDestroy(&basicConfig->authenticate);
-
-    if (basicConfig->basicAuthRealm)
-        safe_free(basicConfig->basicAuthRealm);
-
-    xfree(basicConfig);
+    if (authenticate)
+        wordlistDestroy(&authenticate);
 
-    basicConfig = NULL;
+    if (basicAuthRealm)
+        safe_free(basicAuthRealm);
 }
 
-void
-authenticateBasicFreeUser(auth_user_t * auth_user)
+BasicUser::~BasicUser()
 {
-    basic_data *basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
-    debug(29, 5) ("authenticateBasicFreeUser: Clearing Basic scheme data\n");
-
-    if (basic_auth->username)
-        xfree(basic_auth->username);
-
-    if (basic_auth->passwd)
-        xfree(basic_auth->passwd);
+    if (passwd)
+        xfree(passwd);
 
-    memPoolFree(basic_data_pool, auth_user->scheme_data);
-
-    auth_user->scheme_data = NULL;
+    safe_free (cleartext);
 }
 
 static void
 authenticateBasicHandleReply(void *data, char *reply)
 {
     AuthenticateStateData *r = static_cast<AuthenticateStateData *>(data);
-    auth_user_t *auth_user;
-    basic_data *basic_auth;
     BasicAuthQueueNode *tmpnode;
     char *t = NULL;
     void *cbdata;
@@ -311,9 +273,8 @@ authenticateBasicHandleReply(void *data, char *reply)
     }
 
     assert(r->auth_user_request != NULL);
-    assert(r->auth_user_request->auth_user->auth_type == AUTH_BASIC);
-    auth_user = r->auth_user_request->auth_user;
-    basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
+    assert(r->auth_user_request->user()->auth_type == AUTH_BASIC);
+    basic_data *basic_auth = dynamic_cast<basic_data *>(r->auth_user_request->user());
 
     if (reply && (strncasecmp(reply, "OK", 2) == 0))
         basic_auth->flags.credentials_ok = 1;
@@ -341,11 +302,10 @@ authenticateBasicHandleReply(void *data, char *reply)
     authenticateStateFree(r);
 }
 
-static void
-authBasicCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
+void
+AuthBasicConfig::dump(StoreEntry * entry, const char *name, AuthConfig * scheme)
 {
-    auth_basic_config *config = static_cast<auth_basic_config *>(scheme->scheme_data);
-    wordlist *list = config->authenticate;
+    wordlist *list = authenticate;
     storeAppendPrintf(entry, "%s %s", name, "basic");
 
     while (list != NULL) {
@@ -355,43 +315,38 @@ authBasicCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
 
     storeAppendPrintf(entry, "\n");
 
-    storeAppendPrintf(entry, "%s basic realm %s\n", name, config->basicAuthRealm);
-    storeAppendPrintf(entry, "%s basic children %d\n", name, config->authenticateChildren);
-    storeAppendPrintf(entry, "%s basic concurrency %d\n", name, config->authenticateConcurrency);
-    storeAppendPrintf(entry, "%s basic credentialsttl %d seconds\n", name, (int) config->credentialsTTL);
+    storeAppendPrintf(entry, "%s basic realm %s\n", name, basicAuthRealm);
+    storeAppendPrintf(entry, "%s basic children %d\n", name, authenticateChildren);
+    storeAppendPrintf(entry, "%s basic concurrency %d\n", name, authenticateConcurrency);
+    storeAppendPrintf(entry, "%s basic credentialsttl %d seconds\n", name, (int) credentialsTTL);
 
 }
 
-static void
-authBasicParse(authScheme * scheme, int n_configured, char *param_str)
-{
-    if (scheme->scheme_data == NULL) {
-        assert(basicConfig == NULL);
-        /* this is the first param to be found */
-        scheme->scheme_data = xmalloc(sizeof(auth_basic_config));
-        memset(scheme->scheme_data, 0, sizeof(auth_basic_config));
-        basicConfig = static_cast<auth_basic_config *>(scheme->scheme_data);
-        basicConfig->authenticateChildren = 5;
-        basicConfig->credentialsTTL = 2 * 60 * 60;	/* two hours */
-    }
-
-    basicConfig =  static_cast<auth_basic_config *>(scheme->scheme_data);
+AuthBasicConfig::AuthBasicConfig()
+{
+    /* TODO: move into initialisation list */
+    authenticateChildren = 5;
+    credentialsTTL = 2 * 60 * 60;	/* two hours */
+}
 
+void
+AuthBasicConfig::parse(AuthConfig * scheme, int n_configured, char *param_str)
+{
     if (strcasecmp(param_str, "program") == 0) {
-        if (basicConfig->authenticate)
-            wordlistDestroy(&basicConfig->authenticate);
+        if (authenticate)
+            wordlistDestroy(&authenticate);
 
-        parse_wordlist(&basicConfig->authenticate);
+        parse_wordlist(&authenticate);
 
-        requirePathnameExists("authparam basic program", basicConfig->authenticate->key);
+        requirePathnameExists("authparam basic program", authenticate->key);
     } else if (strcasecmp(param_str, "children") == 0) {
-        parse_int(&basicConfig->authenticateChildren);
+        parse_int(&authenticateChildren);
     } else if (strcasecmp(param_str, "concurrency") == 0) {
-        parse_int(&basicConfig->authenticateConcurrency);
+        parse_int(&authenticateConcurrency);
     } else if (strcasecmp(param_str, "realm") == 0) {
-        parse_eol(&basicConfig->basicAuthRealm);
+        parse_eol(&basicAuthRealm);
     } else if (strcasecmp(param_str, "credentialsttl") == 0) {
-        parse_time_t(&basicConfig->credentialsTTL);
+        parse_time_t(&credentialsTTL);
     } else {
         debug(28, 0) ("unrecognised basic auth scheme parameter '%s'\n", param_str);
     }
@@ -406,37 +361,6 @@ authenticateBasicStats(StoreEntry * sentry)
 
 CBDATA_TYPE(AuthenticateStateData);
 
-/* authenticateBasicUsername: return a pointer to the username in the */
-char const *
-authenticateBasicUsername(auth_user_t const * auth_user)
-{
-    basic_data *basic_auth =  static_cast<basic_data *>(auth_user->scheme_data);
-
-    if (basic_auth)
-        return basic_auth->username;
-
-    return NULL;
-}
-
-static basic_data *
-authBasicDataNew(void)
-{
-    basic_data *temp;
-    temp =  static_cast<basic_data *>(memPoolAlloc(basic_data_pool));
-    assert(temp != NULL);
-    temp->username = NULL;
-    temp->passwd = NULL;
-    temp->auth_queue = NULL;
-    return temp;
-}
-
-#if UNUSED_CODE
-static void
-authBasicDataFree(basic_data * basic_auth)
-{}
-
-#endif
-
 static auth_user_t *
 authBasicAuthUserFindUsername(const char *username)
 {
@@ -445,9 +369,9 @@ authBasicAuthUserFindUsername(const char *username)
 
     if (username && (usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, username)))) {
         while (usernamehash) {
-            if ((authUserHashPointerUser(usernamehash)->auth_type == AUTH_BASIC) &&
+            if ((usernamehash->user()->auth_type == AUTH_BASIC) &&
                     !strcmp(username, (char const *)usernamehash->key))
-                return authUserHashPointerUser(usernamehash);
+                return usernamehash->user();
 
             usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
         }
@@ -456,46 +380,53 @@ authBasicAuthUserFindUsername(const char *username)
     return NULL;
 }
 
+MemPool *BasicUser::Pool (NULL);
+void
+BasicUser::deleteSelf() const
+{
+    delete this;
+}
 
-
-/*
- * Decode a Basic [Proxy-]Auth string, linking the passed auth_user_request structure 
- * to any existing user structure or creating one if needed. Note that just returning
- * will be treated as "cannot decode credentials". Use the message field to return a 
- * descriptive message to the user.
- */
-
-static void
-authenticateBasicDecodeAuth(auth_user_request_t * auth_user_request, const char *proxy_auth)
+void *
+BasicUser::operator new(size_t byteCount)
 {
-    char *sent_auth;
-    char *cleartext;
-    basic_data *basic_auth, local_basic;
-    auth_user_t *auth_user;
-    dlink_node *node;
+    /* derived classes with different sizes must implement their own new */
+    assert (byteCount == sizeof (BasicUser));
 
-    /* decode the username */
-    /* trim BASIC from string */
+    if (!Pool)
+        Pool = memPoolCreate("Authenticate Basic User Data", sizeof (BasicUser));
 
-    while (!xisspace(*proxy_auth))
-        proxy_auth++;
+    return memPoolAlloc(Pool);
+}
 
-    local_basic.passwd = NULL;
+void
+BasicUser::operator delete (void *address)
+{
+    memPoolFree(Pool, address);
+}
 
-    /* Trim leading whitespace before decoding */
-    while (xisspace(*proxy_auth))
-        proxy_auth++;
+BasicUser::BasicUser(AuthConfig *config) : AuthUser (config) , passwd (NULL), credentials_checkedtime(0), auth_queue(NULL), cleartext (NULL), currentRequest (NULL), httpAuthHeader (NULL)
+{
+    flags.credentials_ok = 0;
+}
 
+void
+BasicUser::decodeCleartext()
+{
+    char *sent_auth;
     /* username and password */
-    sent_auth = xstrdup(proxy_auth);
-
+    sent_auth = xstrdup(httpAuthHeader);
     /* Trim trailing \n before decoding */
     strtok(sent_auth, "\n");
 
     cleartext = uudecode(sent_auth);
 
     xfree(sent_auth);
+}
 
+void
+BasicUser::extractUsername()
+{
     /*
      * Don't allow NL or CR in the credentials.
      * Oezguer Kesim <oec@codeblau.de>
@@ -504,133 +435,187 @@ authenticateBasicDecodeAuth(auth_user_request_t * auth_user_request, const char
 
     debug(29, 9) ("authenticateBasicDecodeAuth: cleartext = '%s'\n", cleartext);
 
-    local_basic.username = xstrndup(cleartext, USER_IDENT_SZ);
-
+    username(xstrndup(cleartext, USER_IDENT_SZ));
     xfree(cleartext);
+    /* terminate the username string */
 
-    if ((cleartext = strchr(local_basic.username, ':')) != NULL)
+    if ((cleartext = strchr(username(), ':')) != NULL)
         *(cleartext)++ = '\0';
+}
 
-    local_basic.passwd = cleartext;
+void
+BasicUser::extractPassword()
+{
+    passwd = cleartext;
 
     if (cleartext == NULL) {
         debug(29, 4) ("authenticateBasicDecodeAuth: no password in proxy authorization header '%s'\n",
-                      proxy_auth);
-        local_basic.passwd = NULL;
-        authenticateSetDenyMessage (auth_user_request, "no password was present in the HTTP [proxy-]authorization header. This is most likely a browser bug");
+                      httpAuthHeader);
+        passwd = NULL;
+        currentRequest->setDenyMessage ("no password was present in the HTTP [proxy-]authorization header. This is most likely a browser bug");
     } else if (*cleartext == '\0') {
         debug(29, 4) ("authenticateBasicDecodeAuth: Disallowing empty password,"
-                      "user is '%s'\n", local_basic.username);
-        local_basic.passwd = NULL;
-        authenticateSetDenyMessage (auth_user_request, "Request denied because you provided an empty password. Users MUST have a password.");
+                      "user is '%s'\n", username());
+        passwd = NULL;
+        currentRequest->setDenyMessage ("Request denied because you provided an empty password. Users MUST have a password.");
     }
 
-    /* special case: we have to free the strings for user and password
-     * if we are not returning a filled out structure 
-     */
-    if (local_basic.passwd == NULL) {
-        if (local_basic.username) {
-            /* log the username */
-            debug(29, 9) ("authBasicDecodeAuth: Creating new user for logging '%s'\n", local_basic.username);
-            /* new auth_user */
-            auth_user = authenticateAuthUserNew("basic");
-            /* new scheme data */
-            basic_auth = authBasicDataNew();
-            /* save the credentials */
-            basic_auth->username = local_basic.username;
-            /* link the scheme data in */
-            auth_user->scheme_data = basic_auth;
-            /* set the auth_user type */
-            auth_user->auth_type = AUTH_BROKEN;
-            /* link the request to the user */
-            auth_user_request->auth_user = auth_user;
-            /* lock for the auth_user_request link */
-            authenticateAuthUserLock(auth_user);
-            node = dlinkNodeNew();
-            dlinkAdd(auth_user_request, node, &auth_user->requests);
-        }
+    if (passwd)
+        passwd = xstrndup(cleartext, USER_IDENT_SZ);
 
-        return;
-    } else {
-        local_basic.passwd = xstrndup(cleartext, USER_IDENT_SZ);
-    }
+    cleartext = NULL;
+}
 
-    /* now lookup and see if we have a matching auth_user structure in memory. */
+void
+BasicUser::decode(char const *proxy_auth, AuthUserRequest *auth_user_request)
+{
+    currentRequest = auth_user_request;
+    httpAuthHeader = proxy_auth;
+    decodeCleartext ();
+    extractUsername();
+    extractPassword();
+    currentRequest = NULL;
+    httpAuthHeader = NULL;
+}
+
+bool
+BasicUser::valid() const
+{
+    return passwd != NULL;
+}
 
-    if ((auth_user = authBasicAuthUserFindUsername(local_basic.username)) == NULL) {
-        /* the user doesn't exist in the username cache yet */
-        debug(29, 9) ("authBasicDecodeAuth: Creating new user '%s'\n", local_basic.username);
-        /* new auth_user */
-        auth_user = authenticateAuthUserNew("basic");
+void
+BasicUser::makeLoggingInstance(AuthBasicUserRequest *auth_user_request)
+{
+    if (username()) {
+        /* log the username */
+        debug(29, 9) ("authBasicDecodeAuth: Creating new user for logging '%s'\n", username());
         /* new scheme data */
-        basic_auth = authBasicDataNew();
+        BasicUser *basic_auth = new BasicUser(& basicConfig);
+        auth_user_request->user(basic_auth);
         /* save the credentials */
-        basic_auth->username = local_basic.username;
-        basic_auth->passwd = local_basic.passwd;
-        /* link the scheme data in */
-        auth_user->scheme_data = basic_auth;
+        basic_auth->username(username());
+        username(NULL);
         /* set the auth_user type */
-        auth_user->auth_type = AUTH_BASIC;
-        /* current time for timeouts */
-        auth_user->expiretime = current_time.tv_sec;
-
-        /* this auth_user struct is the 'lucky one' to get added to the username cache */
-        /* the requests after this link to the auth_user */
-        /* store user in hash */
-        authenticateUserNameCacheAdd(auth_user);
-    } else {
-        debug(29, 9) ("authBasicDecodeAuth: Found user '%s' in the user cache as '%p'\n", local_basic.username, auth_user);
-        xfree(local_basic.username);
-        basic_auth =  static_cast<basic_data *>(auth_user->scheme_data);
-
-        if (strcmp(local_basic.passwd, basic_auth->passwd)) {
-            debug(29, 4) ("authBasicDecodeAuth: new password found. Updating in user master record and resetting auth state to unchecked\n");
-            basic_auth->flags.credentials_ok = 0;
-            xfree(basic_auth->passwd);
-            basic_auth->passwd = local_basic.passwd;
-        } else
-            xfree(local_basic.passwd);
-
-        if (basic_auth->flags.credentials_ok == 3) {
-            debug(29, 4) ("authBasicDecodeAuth: last attempt to authenticate this user failed, resetting auth state to unchecked\n");
-            basic_auth->flags.credentials_ok = 0;
-        }
+        basic_auth->auth_type = AUTH_BROKEN;
+        /* link the request to the user */
+        basic_auth->addRequest(auth_user_request);
+    }
+}
+
+AuthUser *
+BasicUser::makeCachedFrom()
+{
+    /* the user doesn't exist in the username cache yet */
+    debug(29, 9) ("authBasicDecodeAuth: Creating new user '%s'\n", username());
+    BasicUser *basic_user = new BasicUser(&basicConfig);
+    /* save the credentials */
+    basic_user->username(username());
+    username(NULL);
+    basic_user->passwd = passwd;
+    passwd = NULL;
+    /* set the auth_user type */
+    basic_user->auth_type = AUTH_BASIC;
+    /* current time for timeouts */
+    basic_user->expiretime = current_time.tv_sec;
+
+    /* this basic_user struct is the 'lucky one' to get added to the username cache */
+    /* the requests after this link to the basic_user */
+    /* store user in hash */
+    basic_user->addToNameCache();
+    return basic_user;
+}
+
+void
+BasicUser::updateCached(BasicUser *from)
+{
+    debug(29, 9) ("authBasicDecodeAuth: Found user '%s' in the user cache as '%p'\n", from->username(), this);
+
+    if (strcmp(from->passwd, passwd)) {
+        debug(29, 4) ("authBasicDecodeAuth: new password found. Updating in user master record and resetting auth state to unchecked\n");
+        flags.credentials_ok = 0;
+        xfree(passwd);
+        passwd = from->passwd;
+        from->passwd = NULL;
+    }
+
+    if (flags.credentials_ok == 3) {
+        debug(29, 4) ("authBasicDecodeAuth: last attempt to authenticate this user failed, resetting auth state to unchecked\n");
+        flags.credentials_ok = 0;
+    }
+}
+
+/*
+ * Decode a Basic [Proxy-]Auth string, linking the passed
+ * auth_user_request structure to any existing user structure or creating one
+ * if needed. Note that just returning will be treated as 
+ * "cannot decode credentials". Use the message field to return a 
+ * descriptive message to the user.
+ */
+AuthUserRequest *
+AuthBasicConfig::decode(char const *proxy_auth)
+{
+    AuthBasicUserRequest *auth_user_request = new AuthBasicUserRequest();
+    /* decode the username */
+    /* trim BASIC from string */
+
+    while (!xisspace(*proxy_auth))
+        proxy_auth++;
+
+    BasicUser *basic_auth, local_basic(&basicConfig);
+
+    /* Trim leading whitespace before decoding */
+    while (xisspace(*proxy_auth))
+        proxy_auth++;
+
+    local_basic.decode(proxy_auth, auth_user_request);
+
+    if (!local_basic.valid()) {
+        local_basic.makeLoggingInstance(auth_user_request);
+        return auth_user_request;
     }
 
-    /* link the request to the user */
-    auth_user_request->auth_user = auth_user;
+    /* now lookup and see if we have a matching auth_user structure in
+     * memory. */
 
-    /* lock for the auth_user_request link */
-    authenticateAuthUserLock(auth_user);
+    auth_user_t *auth_user;
 
-    node = dlinkNodeNew();
+    if ((auth_user = authBasicAuthUserFindUsername(local_basic.username())) == NULL) {
+        auth_user = local_basic.makeCachedFrom();
+        basic_auth = dynamic_cast<BasicUser *>(auth_user);
+        assert (basic_auth);
+    } else {
+        basic_auth = dynamic_cast<BasicUser *>(auth_user);
+        assert (basic_auth);
+        basic_auth->updateCached (&local_basic);
+    }
 
-    dlinkAdd(auth_user_request, node, &auth_user->requests);
+    /* link the request to the in-cache user */
+    auth_user_request->user(basic_auth);
 
-    return;
+    basic_auth->addRequest(auth_user_request);
+
+    return auth_user_request;
 }
 
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
-static void
-authBasicInit(authScheme * scheme)
+void
+AuthBasicConfig::init(AuthConfig * scheme)
 {
     static int init = 0;
 
-    if (basicConfig->authenticate) {
-        if (!basic_data_pool)
-            basic_data_pool = memPoolCreate("Basic Scheme User Data", sizeof(basic_data));
-
+    if (authenticate) {
         authbasic_initialised = 1;
 
         if (basicauthenticators == NULL)
             basicauthenticators = helperCreate("basicauthenticator");
 
-        basicauthenticators->cmdline = basicConfig->authenticate;
+        basicauthenticators->cmdline = authenticate;
 
-        basicauthenticators->n_to_start = basicConfig->authenticateChildren;
+        basicauthenticators->n_to_start = authenticateChildren;
 
-        basicauthenticators->concurrency = basicConfig->authenticateConcurrency;
+        basicauthenticators->concurrency = authenticateConcurrency;
 
         basicauthenticators->ipc_type = IPC_STREAM;
 
@@ -647,50 +632,66 @@ authBasicInit(authScheme * scheme)
     }
 }
 
+void
+BasicUser::queueRequest(auth_user_request_t * auth_user_request, RH * handler, void *data)
+{
+    BasicAuthQueueNode *node;
+    node = static_cast<BasicAuthQueueNode *>(xmalloc(sizeof(BasicAuthQueueNode)));
+    assert(node);
+    /* save the details */
+    node->next = auth_queue;
+    auth_queue = node;
+    node->auth_user_request = auth_user_request;
+    node->handler = handler;
+    node->data = cbdataReference(data);
+}
+
 /* send the initial data to a basic authenticator module */
-static void
-authenticateBasicStart(auth_user_request_t * auth_user_request, RH * handler, void *data)
+void
+AuthBasicUserRequest::module_start(RH * handler, void *data)
 {
-    AuthenticateStateData *r = NULL;
-    char buf[8192];
-    char user[1024], pass[1024];
     basic_data *basic_auth;
-    assert(auth_user_request);
-    assert(handler);
-    assert(auth_user_request->auth_user->auth_type == AUTH_BASIC);
-    assert(auth_user_request->auth_user->scheme_data != NULL);
-    basic_auth = static_cast<basic_data *>(auth_user_request->auth_user->scheme_data);
-    debug(29, 9) ("authenticateStart: '%s:%s'\n", basic_auth->username,
+    assert(user()->auth_type == AUTH_BASIC);
+    basic_auth = dynamic_cast<basic_data *>(user());
+    debug(29, 9) ("AuthBasicUserRequest::start: '%s:%s'\n", basic_auth->username(),
                   basic_auth->passwd);
 
-    if (basicConfig->authenticate == NULL) {
+    if (basicConfig.authenticate == NULL) {
         handler(data, NULL);
         return;
     }
 
     /* check to see if the auth_user already has a request outstanding */
     if (basic_auth->flags.credentials_ok == 2) {
         /* there is a request with the same credentials already being verified */
-        BasicAuthQueueNode *node;
-        node = static_cast<BasicAuthQueueNode *>(xmalloc(sizeof(BasicAuthQueueNode)));
-        assert(node);
-        /* save the details */
-        node->next = basic_auth->auth_queue;
-        basic_auth->auth_queue = node;
-        node->auth_user_request = auth_user_request;
-        node->handler = handler;
-        node->data = cbdataReference(data);
+        basic_auth->queueRequest(this, handler, data);
         return;
-    } else {
-        r = cbdataAlloc(AuthenticateStateData);
-        r->handler = handler;
-        r->data = cbdataReference(data);
-        r->auth_user_request = auth_user_request;
-        /* mark the user as haveing verification in progress */
-        basic_auth->flags.credentials_ok = 2;
-        xstrncpy(user, rfc1738_escape(basic_auth->username), sizeof(user));
-        xstrncpy(pass, rfc1738_escape(basic_auth->passwd), sizeof(pass));
-        snprintf(buf, sizeof(buf), "%s %s\n", user, pass);
-        helperSubmit(basicauthenticators, buf, authenticateBasicHandleReply, r);
     }
+
+    basic_auth->submitRequest (this, handler, data);
 }
+
+void
+BasicUser::submitRequest (auth_user_request_t * auth_user_request, RH * handler, void *data)
+{
+    /* mark the user as haveing verification in progress */
+    flags.credentials_ok = 2;
+    AuthenticateStateData *r = NULL;
+    char buf[8192];
+    char user[1024], pass[1024];
+    r = cbdataAlloc(AuthenticateStateData);
+    r->handler = handler;
+    r->data = cbdataReference(data);
+    r->auth_user_request = auth_user_request;
+    xstrncpy(user, rfc1738_escape(username()), sizeof(user));
+    xstrncpy(pass, rfc1738_escape(passwd), sizeof(pass));
+    snprintf(buf, sizeof(buf), "%s %s\n", user, pass);
+    helperSubmit(basicauthenticators, buf, authenticateBasicHandleReply, r);
+}
+
+AuthConfig *
+basicScheme::createConfig()
+{
+    return &basicConfig;
+}
+
@@ -6,6 +6,9 @@
 #ifndef __AUTH_BASIC_H__
 #define __AUTH_BASIC_H__
 #include "authenticate.h"
+#include "AuthUser.h"
+#include "AuthUserRequest.h"
+#include "AuthConfig.h"
 
 #define DefaultAuthenticateChildrenMax  32	/* 32 processes */
 
@@ -32,11 +35,27 @@ class BasicAuthQueueNode
     void *data;
 };
 
-class basic_data
+class AuthBasicUserRequest;
+
+class BasicUser : public AuthUser
 {
 
 public:
-    char *username;
+    virtual void deleteSelf() const;
+    void *operator new(size_t);
+    void operator delete (void *);
+    BasicUser(AuthConfig *);
+    ~BasicUser();
+    bool authenticated() const;
+    void queueRequest(auth_user_request_t * auth_user_request, RH * handler, void *data);
+    void submitRequest (auth_user_request_t * auth_user_request, RH * handler, void *data);
+    void decode(char const *credentials, AuthUserRequest *);
+    char *getCleartext() {return cleartext;}
+
+    bool valid() const;
+    void makeLoggingInstance(AuthBasicUserRequest *auth_user_request);
+    AuthUser * makeCachedFrom();
+    void updateCached(BasicUser *from);
     char *passwd;
     time_t credentials_checkedtime;
 
@@ -49,14 +68,61 @@ unsigned int credentials_ok:
 
     flags;
     BasicAuthQueueNode *auth_queue;
+
+private:
+    static MemPool *Pool;
+    void decodeCleartext();
+    void extractUsername();
+    void extractPassword();
+    char *cleartext;
+    AuthUserRequest *currentRequest;
+    char const *httpAuthHeader;
+};
+
+typedef class BasicUser basic_data;
+
+/* follows the http request around */
+
+class AuthBasicUserRequest : public AuthUserRequest
+{
+
+public:
+    void *operator new (size_t);
+    void operator delete (void *);
+    AuthBasicUserRequest();
+    virtual ~AuthBasicUserRequest();
+
+    virtual int authenticated() const;
+    virtual void authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type);
+    virtual int module_direction();
+    virtual void module_start(RH *, void *);
+    virtual AuthUser *user() {return _theUser;}
+
+    virtual const AuthUser *user() const {return _theUser;}
+
+    virtual void user (AuthUser *aUser) {_theUser=dynamic_cast<BasicUser *>(aUser);}
+
+private:
+    static MemPool *Pool;
+    BasicUser *_theUser;
 };
 
 /* configuration runtime data */
 
-class auth_basic_config
+class AuthBasicConfig : public AuthConfig
 {
 
 public:
+    AuthBasicConfig::AuthBasicConfig();
+    virtual bool active() const;
+    virtual bool configured() const;
+    virtual AuthUserRequest *decode(char const *proxy_auth);
+    virtual void done();
+    virtual void dump(StoreEntry *, const char *, AuthConfig *);
+    virtual void fixHeader(auth_user_request_t *, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void init(AuthConfig *);
+    virtual void parse(AuthConfig *, int, char *);
+    virtual const char * type() const;
     int authenticateChildren;
     int authenticateConcurrency;
     char *basicAuthRealm;
@@ -0,0 +1,53 @@
+
+/*
+ * $Id: basicScheme.cc,v 1.1 2004/08/30 03:29:00 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "basicScheme.h"
+
+AuthScheme &
+basicScheme::GetInstance()
+{
+    return _instance;
+}
+
+basicScheme::basicScheme()
+{
+    AddScheme(*this);
+}
+
+char const *
+basicScheme::type () const
+{
+    return "basic";
+}
+
+basicScheme basicScheme::_instance;
@@ -0,0 +1,59 @@
+
+/*
+ * $Id: basicScheme.h,v 1.1 2004/08/30 03:29:00 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_BASICSCHEME_H
+#define SQUID_BASICSCHEME_H
+
+#include "AuthScheme.h"
+
+class basicScheme : public AuthScheme
+{
+
+public:
+    static AuthScheme &GetInstance();
+    basicScheme();
+    virtual ~basicScheme(){}
+
+    /* per scheme */
+    virtual char const *type () const;
+    virtual void done();
+    virtual AuthConfig *createConfig();
+    /* Not implemented */
+    basicScheme (basicScheme const &);
+    basicScheme &operator=(basicScheme const &);
+
+private:
+    static basicScheme _instance;
+};
+
+#endif /* SQUID_BASICSCHEME_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_digest.cc,v 1.32 2003/11/07 17:23:04 hno Exp $
+ * $Id: auth_digest.cc,v 1.33 2004/08/30 03:29:00 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Robert Collins
@@ -45,34 +45,19 @@
 #include "Store.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
-
-extern AUTHSSETUP authSchemeSetup_digest;
+/* TODO don't include this */
+#include "digestScheme.h"
 
 /* Digest Scheme */
 
 static HLPCB authenticateDigestHandleReply;
-static AUTHSACTIVE authenticateDigestActive;
-#if WAITING_FOR_TE
-static AUTHSADDTRAILER authDigestAddTrailer;
-#endif
-static AUTHSCONFIGURED authDigestConfigured;
-static AUTHSDECODE authenticateDigestDecodeAuth;
-static AUTHSDUMP authDigestCfgDump;
-static AUTHSFIXERR authenticateDigestFixHeader;
-static AUTHSFREE authenticateDigestUserFree;
-static AUTHSFREECONFIG authDigestFreeConfig;
-static AUTHSINIT authDigestInit;
-static AUTHSPARSE authDigestParse;
-static AUTHSSTART authenticateDigestStart;
 static AUTHSSTATS authenticateDigestStats;
-static AUTHSUSERNAME authenticateDigestUsername;
-static AUTHSSHUTDOWN authDigestDone;
 
 static helper *digestauthenticators = NULL;
 
 static hash_table *digest_nonce_cache;
 
-static auth_digest_config *digestConfig = NULL;
+static AuthDigestConfig digestConfig;
 
 static int authdigest_initialised = 0;
 static MemPool *digest_nonce_pool = NULL;
@@ -218,7 +203,7 @@ authenticateDigestNonceSetup(void)
     if (!digest_nonce_cache) {
         digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
         assert(digest_nonce_cache);
-        eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig->nonceGCInterval, 1);
+        eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig.nonceGCInterval, 1);
     }
 }
 
@@ -285,8 +270,8 @@ authenticateDigestNonceCacheCleanup(void *data)
 
     debug(29, 3) ("authenticateDigestNonceCacheCleanup: Finished cleaning the nonce cache.\n");
 
-    if (authenticateDigestActive())
-        eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig->nonceGCInterval, 1);
+    if (digestConfig.active())
+        eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig.nonceGCInterval, 1);
 }
 
 static void
@@ -373,12 +358,12 @@ authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
     }
 
     /* is the nonce-count ok ? */
-    if (!digestConfig->CheckNonceCount) {
+    if (!digestConfig.CheckNonceCount) {
         nonce->nc++;
         return -1;              /* forced OK by configuration */
     }
 
-    if ((digestConfig->NonceStrictness && intnc != nonce->nc + 1) ||
+    if ((digestConfig.NonceStrictness && intnc != nonce->nc + 1) ||
             intnc < nonce->nc + 1) {
         debug(29, 4) ("authDigestNonceIsValid: Nonce count doesn't match\n");
         nonce->flags.valid = 0;
@@ -403,8 +388,8 @@ authDigestNonceIsStale(digest_nonce_h * nonce)
         return -1;
 
     /* has it's max duration expired? */
-    if (nonce->noncedata.creationtime + digestConfig->noncemaxduration < current_time.tv_sec) {
-        debug(29, 4) ("authDigestNonceIsStale: Nonce is too old. %ld %d %ld\n", (long int) nonce->noncedata.creationtime, (int) digestConfig->noncemaxduration, (long int) current_time.tv_sec);
+    if (nonce->noncedata.creationtime + digestConfig.noncemaxduration < current_time.tv_sec) {
+        debug(29, 4) ("authDigestNonceIsStale: Nonce is too old. %ld %d %ld\n", (long int) nonce->noncedata.creationtime, (int) digestConfig.noncemaxduration, (long int) current_time.tv_sec);
         nonce->flags.valid = 0;
         return -1;
     }
@@ -415,7 +400,7 @@ authDigestNonceIsStale(digest_nonce_h * nonce)
         return -1;
     }
 
-    if (nonce->nc > digestConfig->noncemaxuses) {
+    if (nonce->nc > digestConfig.noncemaxuses) {
         debug(29, 4) ("authDigestNoncelastRequest: Nonce count over user limit\n");
         nonce->flags.valid = 0;
         return -1;
@@ -437,7 +422,7 @@ authDigestNonceLastRequest(digest_nonce_h * nonce)
         return -1;
     }
 
-    if (nonce->nc >= digestConfig->noncemaxuses - 1) {
+    if (nonce->nc >= digestConfig.noncemaxuses - 1) {
         debug(29, 4) ("authDigestNoncelastRequest: Nonce count about to hit user limit\n");
         return -1;
     }
@@ -464,17 +449,6 @@ authDigestNoncePurge(digest_nonce_h * nonce)
 }
 
 /* USER related functions */
-
-
-#if NOT_USED
-static int
-authDigestUsercmpname(digest_user_h * u1, digest_user_h * u2)
-{
-    return strcmp(u1->username, u2->username);
-}
-
-#endif
-
 static auth_user_t *
 authDigestUserFindUsername(const char *username)
 {
@@ -483,14 +457,14 @@ authDigestUserFindUsername(const char *username)
     debug(29, 9) ("authDigestUserFindUsername: Looking for user '%s'\n", username);
 
     if (username && (usernamehash = static_cast < auth_user_hash_pointer * >(hash_lookup(proxy_auth_username_cache, username)))) {
-        while ((authUserHashPointerUser(usernamehash)->auth_type != AUTH_DIGEST) &&
+        while ((usernamehash->user()->auth_type != AUTH_DIGEST) &&
                 (usernamehash->next))
             usernamehash = static_cast < auth_user_hash_pointer * >(usernamehash->next);
 
         auth_user = NULL;
 
-        if (authUserHashPointerUser(usernamehash)->auth_type == AUTH_DIGEST) {
-            auth_user = authUserHashPointerUser(usernamehash);
+        if (usernamehash->user()->auth_type == AUTH_DIGEST) {
+            auth_user = usernamehash->user();
         }
 
         return auth_user;
@@ -510,41 +484,19 @@ authDigestUserShutdown(void)
     hash_first(proxy_auth_username_cache);
 
     while ((usernamehash = ((auth_user_hash_pointer *) hash_next(proxy_auth_username_cache)))) {
-        auth_user = authUserHashPointerUser(usernamehash);
+        auth_user = usernamehash->user();
 
-        if (authscheme_list[auth_user->auth_module - 1].typestr &&
-                strcmp(authscheme_list[auth_user->auth_module - 1].typestr, "digest") == 0)
-            /* it's digest */
-            authenticateAuthUserUnlock(auth_user);
+        if (strcmp(auth_user->config->type(), "digest") == 0)
+            auth_user->unlock();
     }
 }
 
-
-/* request related functions */
-
 /* delete the digest request structure. Does NOT delete related structures */
-digest_request_h::~digest_request_h()
+void
+digestScheme::done()
 {
-    safe_free (nonceb64);
-    safe_free (cnonce);
-    safe_free (realm);
-    safe_free (pszPass);
-    safe_free (algorithm);
-    safe_free (pszMethod);
-    safe_free (qop);
-    safe_free (uri);
-    safe_free (response);
-
-    if (nonce)
-        authDigestNonceUnlink(nonce);
-
-    if (theUser)
-        authenticateAuthUserUnlock(theUser);
-}
+    /* TODO: this should be a Config call. */
 
-static void
-authDigestDone(void)
-{
     if (digestauthenticators)
         helperShutdown(digestauthenticators);
 
@@ -565,11 +517,10 @@ authDigestDone(void)
     debug(29, 2) ("authenticateDigestDone: Digest authentication shut down.\n");
 }
 
-static void
-authDigestCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
+void
+AuthDigestConfig::dump(StoreEntry * entry, const char *name, AuthConfig * scheme)
 {
-    auth_digest_config *config = static_cast < auth_digest_config * >(scheme->scheme_data);
-    wordlist *list = config->authenticate;
+    wordlist *list = authenticate;
     debug(29, 9) ("authDigestCfgDump: Dumping configuration\n");
     storeAppendPrintf(entry, "%s %s", name, "digest");
 
@@ -579,62 +530,32 @@ authDigestCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
     }
 
     storeAppendPrintf(entry, "\n%s %s realm %s\n%s %s children %d\n%s %s nonce_max_count %d\n%s %s nonce_max_duration %d seconds\n%s %s nonce_garbage_interval %d seconds\n",
-                      name, "digest", config->digestAuthRealm,
-                      name, "digest", config->authenticateChildren,
-                      name, "digest", config->noncemaxuses,
-                      name, "digest", (int) config->noncemaxduration,
-                      name, "digest", (int) config->nonceGCInterval);
-}
-
-void
-authSchemeSetup_digest(authscheme_entry_t * authscheme)
-{
-    assert(!authdigest_initialised);
-    authscheme->Active = authenticateDigestActive;
-    authscheme->configured = authDigestConfigured;
-    authscheme->parse = authDigestParse;
-    authscheme->freeconfig = authDigestFreeConfig;
-    authscheme->dump = authDigestCfgDump;
-    authscheme->init = authDigestInit;
-    authscheme->authAuthenticate = NULL;
-    authscheme->authenticated = NULL;
-    authscheme->authFixHeader = authenticateDigestFixHeader;
-    authscheme->FreeUser = authenticateDigestUserFree;
-#if WAITING_FOR_TE
-
-    authscheme->AddTrailer = authDigestAddTrailer;
-#endif
-
-    authscheme->authStart = authenticateDigestStart;
-    authscheme->authStats = authenticateDigestStats;
-    authscheme->authUserUsername = authenticateDigestUsername;
-    authscheme->getdirection = NULL;
-    authscheme->oncloseconnection = NULL;
-    authscheme->decodeauth = authenticateDigestDecodeAuth;
-    authscheme->donefunc = authDigestDone;
-    authscheme->requestFree = NULL;
-    authscheme->authConnLastHeader = NULL;
+                      name, "digest", digestAuthRealm,
+                      name, "digest", authenticateChildren,
+                      name, "digest", noncemaxuses,
+                      name, "digest", (int) noncemaxduration,
+                      name, "digest", (int) nonceGCInterval);
 }
 
-static int
-authenticateDigestActive(void)
+bool
+AuthDigestConfig::active() const
 {
-    return (authdigest_initialised == 1) ? 1 : 0;
+    return authdigest_initialised == 1;
 }
 
-static int
-authDigestConfigured(void)
+bool
+AuthDigestConfig::configured() const
 {
-    if ((digestConfig != NULL) && (digestConfig->authenticate != NULL) &&
-            (digestConfig->authenticateChildren != 0) &&
-            (digestConfig->digestAuthRealm != NULL) && (digestConfig->noncemaxduration > -1))
-        return 1;
+    if ((authenticate != NULL) &&
+            (authenticateChildren != 0) &&
+            (digestAuthRealm != NULL) && (noncemaxduration > -1))
+        return true;
 
-    return 0;
+    return false;
 }
 
 int
-digest_request_h::authenticated() const
+AuthDigestUserRequest::authenticated() const
 {
     if (credentials() == Ok)
         return 1;
@@ -645,10 +566,10 @@ digest_request_h::authenticated() const
 /* log a digest user in
  */
 void
-digest_request_h::authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
+AuthDigestUserRequest::authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
     auth_user_t *auth_user;
-    digest_request_h *digest_request;
+    AuthDigestUserRequest *digest_request;
     digest_user_h *digest_user;
 
     HASHHEX SESSIONKEY;
@@ -658,8 +579,7 @@ digest_request_h::authenticate(HttpRequest * request, ConnStateData::Pointer con
     assert(authUser() != NULL);
     auth_user = authUser();
 
-    assert(auth_user->scheme_data != NULL);
-    digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
+    digest_user = dynamic_cast < digest_user_h * >(auth_user);
 
     /* if the check has corrupted the user, just return */
 
@@ -701,7 +621,7 @@ digest_request_h::authenticate(HttpRequest * request, ConnStateData::Pointer con
             return;
         }
 
-        if (digestConfig->PostWorkaround && request->method != METHOD_GET) {
+        if (digestConfig.PostWorkaround && request->method != METHOD_GET) {
             /* Ugly workaround for certain very broken browsers using the
              * wrong method to calculate the request-digest on POST request.
              * This should be deleted once Digest authentication becomes more
@@ -739,7 +659,7 @@ digest_request_h::authenticate(HttpRequest * request, ConnStateData::Pointer con
         /* check for stale nonce */
         if (!authDigestNonceIsValid(digest_request->nonce, digest_request->nc)) {
             debug(29, 3) ("authenticateDigestAuthenticateuser: user '%s' validated OK but nonce stale\n",
-                          digest_user->username);
+                          digest_user->username());
             digest_request->flags.nonce_stale = 1;
             credentials(Failed);
             return;
@@ -750,7 +670,7 @@ digest_request_h::authenticate(HttpRequest * request, ConnStateData::Pointer con
 
     /* password was checked and did match */
     debug(29, 4) ("authenticateDigestAuthenticateuser: user '%s' validated OK\n",
-                  digest_user->username);
+                  digest_user->username());
 
     /* auth_user is now linked, we reset these values
      * after external auth occurs anyway */
@@ -759,7 +679,7 @@ digest_request_h::authenticate(HttpRequest * request, ConnStateData::Pointer con
 }
 
 int
-digest_request_h::direction()
+AuthDigestUserRequest::module_direction()
 {
     switch (credentials()) {
 
@@ -787,7 +707,7 @@ digest_request_h::direction()
 
 /* add the [proxy]authorisation header */
 void
-digest_request_h::addHeader(HttpReply * rep, int accel)
+AuthDigestUserRequest::addHeader(HttpReply * rep, int accel)
 {
     http_hdr_type type;
 
@@ -806,7 +726,7 @@ digest_request_h::addHeader(HttpReply * rep, int accel)
 
 #endif
 
-    if ((digestConfig->authenticate) && authDigestNonceLastRequest(nonce)) {
+    if ((digestConfig.authenticate) && authDigestNonceLastRequest(nonce)) {
         flags.authinfo_sent = 1;
         debug(29, 9) ("authDigestAddHead: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(nonce));
         httpHeaderPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(nonce));
@@ -815,19 +735,17 @@ digest_request_h::addHeader(HttpReply * rep, int accel)
 
 #if WAITING_FOR_TE
 /* add the [proxy]authorisation header */
-static void
-authDigestAddTrailer(auth_user_request_t * auth_user_request, HttpReply * rep, int accel)
+void
+AuthDigestUserRequest::addTrailer(HttpReply * rep, int accel)
 {
     int type;
-    digest_request_h *digest_request;
 
     if (!auth_user_request)
         return;
 
-    digest_request = dynamic_cast < digest_request_h * >(auth_user_request->state());
 
     /* has the header already been send? */
-    if (digest_request->flags.authinfo_sent)
+    if (flags.authinfo_sent)
         return;
 
     /* don't add to authentication error pages */
@@ -837,26 +755,26 @@ authDigestAddTrailer(auth_user_request_t * auth_user_request, HttpReply * rep, i
 
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
 
-    if ((digestConfig->authenticate) && authDigestNonceLastRequest(digest_request->nonce)) {
-        debug(29, 9) ("authDigestAddTrailer: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(digest_request->nonce));
-        httpTrailerPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(digest_request->nonce));
+    if ((digestConfig.authenticate) && authDigestNonceLastRequest(nonce)) {
+        debug(29, 9) ("authDigestAddTrailer: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(nonce));
+        httpTrailerPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(nonce));
     }
 }
 
 #endif
 
 /* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */
 void
-authenticateDigestFixHeader(auth_user_request_t * auth_user_request, HttpReply * rep, http_hdr_type type, HttpRequest * request)
+AuthDigestConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply *rep, http_hdr_type type, HttpRequest * request)
 {
-    if (!digestConfig->authenticate)
+    if (!authenticate)
         return;
 
     int stale = 0;
 
-    if (auth_user_request && auth_user_request->state()) {
-        digest_request_h *digest_request;
-        digest_request = dynamic_cast < digest_request_h * >(auth_user_request->state());
+    if (auth_user_request) {
+        AuthDigestUserRequest *digest_request;
+        digest_request = dynamic_cast < AuthDigestUserRequest * >(auth_user_request);
         assert (digest_request);
 
         stale = digest_request->flags.nonce_stale;
@@ -865,29 +783,14 @@ authenticateDigestFixHeader(auth_user_request_t * auth_user_request, HttpReply *
     /* on a 407 or 401 we always use a new nonce */
     digest_nonce_h *nonce = authenticateDigestNonceNew();
 
-    debug(29, 9) ("authenticateFixHeader: Sending type:%d header: 'Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s\n", type, digestConfig->digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
+    debug(29, 9) ("authenticateFixHeader: Sending type:%d header: 'Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s\n", type, digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
 
     /* in the future, for WWW auth we may want to support the domain entry */
-    httpHeaderPutStrf(&rep->header, type, "Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s", digestConfig->digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
+    httpHeaderPutStrf(&rep->header, type, "Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s", digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
 }
 
-static void
-authenticateDigestUserFree(auth_user_t * auth_user)
+DigestUser::~DigestUser()
 {
-    digest_user_h *digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
-    debug(29, 9) ("authenticateDigestFreeUser: Clearing Digest scheme data\n");
-
-    if (!digest_user)
-        return;
-
-    delete digest_user;
-
-    auth_user->scheme_data = NULL;
-}
-
-digest_user_h::~digest_user_h()
-{
-    safe_free(username);
 
     dlink_node *link, *tmplink;
     link = nonces.head;
@@ -907,7 +810,7 @@ authenticateDigestHandleReply(void *data, char *reply)
 {
     DigestAuthenticateStateData *replyData = static_cast < DigestAuthenticateStateData * >(data);
     auth_user_request_t *auth_user_request;
-    digest_request_h *digest_request;
+    AuthDigestUserRequest *digest_request;
     digest_user_h *digest_user;
     char *t = NULL;
     void *cbdata;
@@ -923,12 +826,12 @@ authenticateDigestHandleReply(void *data, char *reply)
 
     assert(replyData->auth_user_request != NULL);
     auth_user_request = replyData->auth_user_request;
-    assert(auth_user_request->state() != NULL);
-    digest_request = dynamic_cast < digest_request_h * >(auth_user_request->state());
-    digest_user = static_cast < digest_user_h * >(auth_user_request->auth_user->scheme_data);
+    digest_request = dynamic_cast < AuthDigestUserRequest * >(auth_user_request);
+    assert(digest_request);
+    digest_user = dynamic_cast < digest_user_h * >(auth_user_request->user());
 
     if (reply && (strncasecmp(reply, "ERR", 3) == 0))
-        digest_request->credentials(digest_request_h::Failed);
+        digest_request->credentials(AuthDigestUserRequest::Failed);
     else {
         CvtBin(reply, digest_user->HA1);
         digest_user->HA1created = 1;
@@ -942,21 +845,21 @@ authenticateDigestHandleReply(void *data, char *reply)
 
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
-static void
-authDigestInit(authScheme * scheme)
+void
+AuthDigestConfig::init(AuthConfig * scheme)
 {
     static int init = 0;
 
-    if (digestConfig->authenticate) {
+    if (authenticate) {
         authenticateDigestNonceSetup();
         authdigest_initialised = 1;
 
         if (digestauthenticators == NULL)
             digestauthenticators = helperCreate("digestauthenticator");
 
-        digestauthenticators->cmdline = digestConfig->authenticate;
+        digestauthenticators->cmdline = authenticate;
 
-        digestauthenticators->n_to_start = digestConfig->authenticateChildren;
+        digestauthenticators->n_to_start = authenticateChildren;
 
         digestauthenticators->ipc_type = IPC_STREAM;
 
@@ -975,75 +878,68 @@ authDigestInit(authScheme * scheme)
 
 /* free any allocated configuration details */
 void
-authDigestFreeConfig(authScheme * scheme)
+AuthDigestConfig::done()
 {
-    if (digestConfig == NULL)
-        return;
-
-    assert(digestConfig == scheme->scheme_data);
+    if (authenticate)
+        wordlistDestroy(&authenticate);
 
-    if (digestConfig->authenticate)
-        wordlistDestroy(&digestConfig->authenticate);
-
-    safe_free(digestConfig->digestAuthRealm);
+    safe_free(digestAuthRealm);
+}
 
-    xfree(digestConfig);
 
-    digestConfig = NULL;
+AuthDigestConfig::AuthDigestConfig()
+{
+    /* TODO: move into initialisation list */
+    authenticateChildren = 5;
+    /* 5 minutes */
+    nonceGCInterval = 5 * 60;
+    /* 30 minutes */
+    noncemaxduration = 30 * 60;
+    /* 50 requests */
+    noncemaxuses = 50;
+    /* Not strict nonce count behaviour */
+    NonceStrictness = 0;
+    /* Verify nonce count */
+    CheckNonceCount = 1;
 }
 
-static void
-authDigestParse(authScheme * scheme, int n_configured, char *param_str)
+void
+AuthDigestConfig::parse(AuthConfig * scheme, int n_configured, char *param_str)
 {
-    if (scheme->scheme_data == NULL) {
-        assert(digestConfig == NULL);
-        /* this is the first param to be found */
-        scheme->scheme_data = xmalloc(sizeof(auth_digest_config));
-        memset(scheme->scheme_data, 0, sizeof(auth_digest_config));
-        digestConfig = static_cast < auth_digest_config * >(scheme->scheme_data);
-        digestConfig->authenticateChildren = 5;
-        /* 5 minutes */
-        digestConfig->nonceGCInterval = 5 * 60;
-        /* 30 minutes */
-        digestConfig->noncemaxduration = 30 * 60;
-        /* 50 requests */
-        digestConfig->noncemaxuses = 50;
-        /* Not strict nonce count behaviour */
-        digestConfig->NonceStrictness = 0;
-        /* Verify nonce count */
-        digestConfig->CheckNonceCount = 1;
-    }
-
-    digestConfig = static_cast < auth_digest_config * >(scheme->scheme_data);
-
     if (strcasecmp(param_str, "program") == 0) {
-        if (digestConfig->authenticate)
-            wordlistDestroy(&digestConfig->authenticate);
+        if (authenticate)
+            wordlistDestroy(&authenticate);
 
-        parse_wordlist(&digestConfig->authenticate);
+        parse_wordlist(&authenticate);
 
-        requirePathnameExists("authparam digest program", digestConfig->authenticate->key);
+        requirePathnameExists("authparam digest program", authenticate->key);
     } else if (strcasecmp(param_str, "children") == 0) {
-        parse_int(&digestConfig->authenticateChildren);
+        parse_int(&authenticateChildren);
     } else if (strcasecmp(param_str, "realm") == 0) {
-        parse_eol(&digestConfig->digestAuthRealm);
+        parse_eol(&digestAuthRealm);
     } else if (strcasecmp(param_str, "nonce_garbage_interval") == 0) {
-        parse_time_t(&digestConfig->nonceGCInterval);
+        parse_time_t(&nonceGCInterval);
     } else if (strcasecmp(param_str, "nonce_max_duration") == 0) {
-        parse_time_t(&digestConfig->noncemaxduration);
+        parse_time_t(&noncemaxduration);
     } else if (strcasecmp(param_str, "nonce_max_count") == 0) {
-        parse_int((int *) &digestConfig->noncemaxuses);
+        parse_int((int *) &noncemaxuses);
     } else if (strcasecmp(param_str, "nonce_strictness") == 0) {
-        parse_onoff(&digestConfig->NonceStrictness);
+        parse_onoff(&NonceStrictness);
     } else if (strcasecmp(param_str, "check_nonce_count") == 0) {
-        parse_onoff(&digestConfig->CheckNonceCount);
+        parse_onoff(&CheckNonceCount);
     } else if (strcasecmp(param_str, "post_workaround") == 0) {
-        parse_onoff(&digestConfig->PostWorkaround);
+        parse_onoff(&PostWorkaround);
     } else {
         debug(28, 0) ("unrecognised digest auth scheme parameter '%s'\n", param_str);
     }
 }
 
+const char *
+AuthDigestConfig::type() const
+{
+    return digestScheme::GetInstance().type();
+}
+
 
 static void
 authenticateDigestStats(StoreEntry * sentry)
@@ -1063,10 +959,10 @@ authDigestNonceUserUnlink(digest_nonce_h * nonce)
     if (!nonce)
         return;
 
-    if (!nonce->auth_user)
+    if (!nonce->user)
         return;
 
-    digest_user = static_cast < digest_user_h * >(nonce->auth_user->scheme_data);
+    digest_user = nonce->user;
 
     /* unlink from the user list. Yes we're crossing structures but this is the only
      * time this code is needed
@@ -1085,27 +981,24 @@ authDigestNonceUserUnlink(digest_nonce_h * nonce)
         }
     }
 
-    /* this reference to auth_user was not locked because freeeing the auth_user frees
+    /* this reference to user was not locked because freeeing the user frees
      * the nonce too. 
      */
-    nonce->auth_user = NULL;
+    nonce->user = NULL;
 }
 
 /* authDigestUserLinkNonce: add a nonce to a given user's struct */
 
 static void
-authDigestUserLinkNonce(auth_user_t * auth_user, digest_nonce_h * nonce)
+authDigestUserLinkNonce(DigestUser * user, digest_nonce_h * nonce)
 {
     dlink_node *node;
     digest_user_h *digest_user;
 
-    if (!auth_user || !nonce)
-        return;
-
-    if (!auth_user->scheme_data)
+    if (!user || !nonce)
         return;
 
-    digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
+    digest_user = user;
 
     node = digest_user->nonces.head;
 
@@ -1122,78 +1015,52 @@ authDigestUserLinkNonce(auth_user_t * auth_user, digest_nonce_h * nonce)
     authDigestNonceLink(nonce);
 
     /* ping this nonce to this auth user */
-    assert((nonce->auth_user == NULL) || (nonce->auth_user = auth_user));
+    assert((nonce->user == NULL) || (nonce->user = user));
 
-    /* we don't lock this reference because removing the auth_user removes the
+    /* we don't lock this reference because removing the user removes the
      * hash too. Of course if that changes we're stuffed so read the code huh?
      */
-    nonce->auth_user = auth_user;
-}
-
-/* authenticateDigestUsername: return a pointer to the username in the */
-static char const *
-authenticateDigestUsername(auth_user_t const *auth_user)
-{
-    digest_user_h *digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
-
-    if (digest_user)
-        return digest_user->username;
-
-    return NULL;
+    nonce->user = user;
 }
 
 /* setup the necessary info to log the username */
-static void
-authDigestLogUsername(auth_user_request_t * auth_user_request, char *username)
+static AuthUserRequest *
+authDigestLogUsername(char *username)
 {
-    auth_user_t *auth_user;
-    digest_user_h *digest_user;
-    dlink_node *node;
+    AuthDigestUserRequest *auth_user_request = new AuthDigestUserRequest();
+    assert(auth_user_request != NULL);
 
     /* log the username */
-    debug(29, 9) ("authBasicDecodeAuth: Creating new user for logging '%s'\n", username);
-    /* new auth_user */
-    auth_user = authenticateAuthUserNew("digest");
-    /* new scheme data */
-    digest_user = new digest_user_h;
+    debug(29, 9) ("authDigestLogUsername: Creating new user for logging '%s'\n", username);
+    digest_user_h *digest_user = new DigestUser(&digestConfig);
     /* save the credentials */
-    digest_user->username = username;
-    /* link the scheme data in */
-    auth_user->scheme_data = digest_user;
+    digest_user->username(username);
     /* set the auth_user type */
-    auth_user->auth_type = AUTH_BROKEN;
+    digest_user->auth_type = AUTH_BROKEN;
     /* link the request to the user */
-    auth_user_request->auth_user = auth_user;
-    /* lock for the auth_user_request link */
-    authenticateAuthUserLock(auth_user);
-    node = dlinkNodeNew();
-    dlinkAdd(auth_user_request, node, &auth_user->requests);
+    auth_user_request->authUser(digest_user);
+    auth_user_request->user(digest_user);
+    digest_user->addRequest (auth_user_request);
+    return auth_user_request;
 }
 
 /*
  * Decode a Digest [Proxy-]Auth string, placing the results in the passed
  * Auth_user structure.
  */
-
-static void
-authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char *proxy_auth)
+AuthUserRequest *
+AuthDigestConfig::decode(char const *proxy_auth)
 {
     const char *item;
     const char *p;
     const char *pos = NULL;
     char *username = NULL;
     digest_nonce_h *nonce;
     int ilen;
-    digest_request_h *digest_request;
-    digest_user_h *digest_user;
-    auth_user_t *auth_user;
-    dlink_node *node;
 
     debug(29, 9) ("authenticateDigestDecodeAuth: beginning\n");
-    assert(auth_user_request != NULL);
-    assert (auth_user_request->state() == NULL);
 
-    digest_request = new digest_request_h;
+    AuthDigestUserRequest *digest_request = new AuthDigestUserRequest();
 
     /* trim DIGEST from string */
 
@@ -1338,11 +1205,8 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
 
     if (digest_request->cnonce && strlen(digest_request->nc) != 8) {
         debug(29, 4) ("authenticateDigestDecode: nonce count length invalid\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* now the nonce */
@@ -1351,11 +1215,8 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
     if (!nonce) {
         /* we couldn't find a matching nonce! */
         debug(29, 4) ("authenticateDigestDecode: Unexpected or invalid nonce recieved\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     digest_request->nonce = nonce;
@@ -1367,11 +1228,8 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
     if (!digest_request->qop || strcmp(digest_request->qop, QOP_AUTH)) {
         /* we recieved a qop option we didn't send */
         debug(29, 4) ("authenticateDigestDecode: Invalid qop option recieved\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* we can't check the URI just yet. We'll check it in the
@@ -1381,42 +1239,30 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
 
     if (!digest_request->response || strlen(digest_request->response) != 32) {
         debug(29, 4) ("authenticateDigestDecode: Response length invalid\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* do we have a username ? */
     if (!username || username[0] == '\0') {
         debug(29, 4) ("authenticateDigestDecode: Empty or not present username\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* check that we're not being hacked / the username hasn't changed */
-    if (nonce->auth_user && strcmp(username, nonce->auth_user->username())) {
+    if (nonce->user && strcmp(username, nonce->user->username())) {
         debug(29, 4) ("authenticateDigestDecode: Username for the nonce does not equal the username for the request\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* if we got a qop, did we get a cnonce or did we get a cnonce wihtout a qop? */
     if ((digest_request->qop && !digest_request->cnonce)
             || (!digest_request->qop && digest_request->cnonce)) {
         debug(29, 4) ("authenticateDigestDecode: qop without cnonce, or vice versa!\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* check the algorithm is present and supported */
@@ -1425,11 +1271,8 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
     else if (strcmp(digest_request->algorithm, "MD5")
              && strcmp(digest_request->algorithm, "MD5-sess")) {
         debug(29, 4) ("authenticateDigestDecode: invalid algorithm specified!\n");
-        authDigestLogUsername(auth_user_request, username);
-
-        /* we don't need the scheme specific data anymore */
         delete digest_request;
-        return;
+        return authDigestLogUsername(username);
     }
 
     /* the method we'll check at the authenticate step as well */
@@ -1438,166 +1281,182 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
     /* we don't send or parse opaques. Ok so we're flexable ... */
 
     /* find the user */
+    digest_user_h *digest_user;
+
+    auth_user_t *auth_user;
 
     if ((auth_user = authDigestUserFindUsername(username)) == NULL) {
         /* the user doesn't exist in the username cache yet */
         debug(29, 9) ("authDigestDecodeAuth: Creating new digest user '%s'\n", username);
-        /* new auth_user */
-        auth_user = authenticateAuthUserNew("digest");
-        /* new scheme user data */
-        digest_user = new digest_user_h;
+        digest_user = new DigestUser (&digestConfig);
+        /* auth_user is a parent */
+        auth_user = digest_user;
         /* save the username */
-        digest_user->username = username;
-        /* link the primary struct in */
-        auth_user->scheme_data = digest_user;
+        digest_user->username(username);
         /* set the user type */
-        auth_user->auth_type = AUTH_DIGEST;
+        digest_user->auth_type = AUTH_DIGEST;
         /* this auth_user struct is the one to get added to the
          * username cache */
         /* store user in hash's */
-        authenticateUserNameCacheAdd(auth_user);
+        digest_user->addToNameCache();
 
         /*
          * Add the digest to the user so we can tell if a hacking
          * or spoofing attack is taking place. We do this by assuming
          * the user agent won't change user name without warning.
          */
-        authDigestUserLinkNonce(auth_user, nonce);
+        authDigestUserLinkNonce(digest_user, nonce);
     } else {
         debug(29, 9) ("authDigestDecodeAuth: Found user '%s' in the user cache as '%p'\n", username, auth_user);
-        digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
+        digest_user = static_cast < digest_user_h * >(auth_user);
         xfree(username);
     }
 
     /*link the request and the user */
-    auth_user_request->auth_user = auth_user;
-
-    auth_user_request->state(digest_request);
+    assert(digest_request != NULL);
 
-    digest_request->authUser (auth_user);
+    digest_request->authUser (digest_user);
 
-    /* lock for the request link */
-    authenticateAuthUserLock(auth_user);
-
-    node = dlinkNodeNew();
+    digest_request->user(digest_user);
 
-    dlinkAdd(auth_user_request, node, &auth_user->requests);
+    digest_user->addRequest (digest_request);
 
     debug(29, 9) ("username = '%s'\nrealm = '%s'\nqop = '%s'\nalgorithm = '%s'\nuri = '%s'\nnonce = '%s'\nnc = '%s'\ncnonce = '%s'\nresponse = '%s'\ndigestnonce = '%p'\n",
-                  digest_user->username, digest_request->realm,
+                  digest_user->username(), digest_request->realm,
                   digest_request->qop, digest_request->algorithm,
                   digest_request->uri, digest_request->nonceb64,
                   digest_request->nc, digest_request->cnonce, digest_request->response, nonce);
 
-    return;
+    return digest_request;
 }
 
 /* send the initial data to a digest authenticator module */
-static void
-authenticateDigestStart(auth_user_request_t * auth_user_request, RH * handler, void *data)
+void
+AuthDigestUserRequest::module_start(RH * handler, void *data)
 {
     DigestAuthenticateStateData *r = NULL;
     char buf[8192];
-    digest_request_h *digest_request;
     digest_user_h *digest_user;
-    assert(auth_user_request);
-    assert(handler);
-    assert(auth_user_request->auth_user->auth_type == AUTH_DIGEST);
-    assert(auth_user_request->auth_user->scheme_data != NULL);
-    digest_request = dynamic_cast < digest_request_h * >(auth_user_request->state());
-    assert(digest_request);
-    digest_user = static_cast < digest_user_h * >(auth_user_request->auth_user->scheme_data);
-    debug(29, 9) ("authenticateStart: '\"%s\":\"%s\"'\n", digest_user->username,
-                  digest_request->realm);
+    assert(user()->auth_type == AUTH_DIGEST);
+    digest_user = dynamic_cast < digest_user_h * >(user());
+    debug(29, 9) ("authenticateStart: '\"%s\":\"%s\"'\n", digest_user->username(),
+                  realm);
 
-    if (digestConfig->authenticate == NULL) {
+    if (digestConfig.authenticate == NULL) {
         handler(data, NULL);
         return;
     }
 
     r = cbdataAlloc(DigestAuthenticateStateData);
     r->handler = handler;
     r->data = cbdataReference(data);
-    r->auth_user_request = auth_user_request;
-    snprintf(buf, 8192, "\"%s\":\"%s\"\n", digest_user->username, digest_request->realm);
+    r->auth_user_request = this;
+    snprintf(buf, 8192, "\"%s\":\"%s\"\n", digest_user->username(), realm);
     helperSubmit(digestauthenticators, buf, authenticateDigestHandleReply, r);
 }
 
 
-MemPool (*digest_user_h::Pool)(NULL);
+MemPool (*DigestUser::Pool)(NULL);
 void *
-digest_user_h::operator new (size_t byteCount)
+DigestUser::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (digest_user_h));
+    assert (byteCount == sizeof (DigestUser));
 
     if (!Pool)
-        Pool = memPoolCreate("digest_user_h", sizeof (digest_user_h));
+        Pool = memPoolCreate("Authentication Digest User data", sizeof (DigestUser));
 
     return memPoolAlloc(Pool);
 }
 
 void
-digest_user_h::operator delete (void *address)
+DigestUser::operator delete (void *address)
 {
     memPoolFree (Pool, address);
 }
 
-digest_user_h::digest_user_h () : username (NULL), HA1created (0)
+DigestUser::DigestUser (AuthConfig *config) : AuthUser (config), HA1created (0)
 {}
 
-MemPool (*digest_request_h::Pool)(NULL);
-void *
-digest_request_h::operator new (size_t byteCount)
+auth_user_t *
+AuthDigestUserRequest::authUser() const
 {
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (digest_request_h));
-
-    if (!Pool)
-        Pool = memPoolCreate("digest_request_h", sizeof (digest_request_h));
-
-    return memPoolAlloc(Pool);
+    return const_cast<AuthUser *>(user());
 }
 
 void
-digest_request_h::operator delete (void *address)
+AuthDigestUserRequest::authUser(auth_user_t *aUser)
 {
-    memPoolFree (Pool, address);
+    assert (!authUser());
+    user(aUser);
+
+    user()->lock()
+
+    ;
 }
 
-digest_request_h::digest_request_h () : theUser (NULL)
-        , credentials_ok (Unchecked)
-{}
+AuthDigestUserRequest::CredentialsState
+AuthDigestUserRequest::credentials() const
+{
+    return credentials_ok;
+
+}
 
-digest_request_h::digest_request_h (auth_user_t *aUser) : theUser (aUser)
-        , credentials_ok (Unchecked)
+void
+AuthDigestUserRequest::credentials(CredentialsState newCreds)
 {
-    authenticateAuthUserLock(theUser);
+    credentials_ok = newCreds;
 }
 
-auth_user_t *
-digest_request_h::authUser() const
+MemPool (*AuthDigestUserRequest::Pool)(NULL);
+void *
+AuthDigestUserRequest::operator new (size_t byteCount)
 {
-    return theUser;
+    /* derived classes with different sizes must implement their own new */
+    assert (byteCount == sizeof (AuthDigestUserRequest));
+
+    if (!Pool)
+        Pool = memPoolCreate("AuthDigestUserRequest", sizeof (AuthDigestUserRequest));
+
+    return memPoolAlloc(Pool);
 }
 
 void
-digest_request_h::authUser(auth_user_t *aUser)
+AuthDigestUserRequest::operator delete (void *address)
 {
-    assert (!authUser());
-    authenticateAuthUserLock(aUser);
-    theUser = aUser;
+    memPoolFree (Pool, address);
 }
 
-digest_request_h::CredentialsState
-digest_request_h::credentials() const
+AuthDigestUserRequest::AuthDigestUserRequest() : nonceb64(NULL) ,cnonce(NULL) ,realm(NULL),
+        pszPass(NULL) ,algorithm(NULL) ,pszMethod(NULL),
+        qop(NULL) ,uri(NULL) ,response(NULL),
+        nonce(NULL), _theUser (NULL) ,
+        credentials_ok (Unchecked)
+{}
+
+/* delete the digest request structure. Does NOT delete related structures */
+AuthDigestUserRequest::~AuthDigestUserRequest()
 {
-    return credentials_ok;
+    safe_free (nonceb64);
+    safe_free (cnonce);
+    safe_free (realm);
+    safe_free (pszPass);
+    safe_free (algorithm);
+    safe_free (pszMethod);
+    safe_free (qop);
+    safe_free (uri);
+    safe_free (response);
+
+    if (nonce)
+        authDigestNonceUnlink(nonce);
 
+    if (user())
+        user()->unlock();
 }
 
-void
-digest_request_h::credentials(CredentialsState newCreds)
+AuthConfig *
+digestScheme::createConfig()
 {
-    credentials_ok = newCreds;
+    return &digestConfig;
 }
+
@@ -7,6 +7,9 @@
 #define __AUTH_DIGEST_H__
 #include "rfc2617.h"
 #include "authenticate.h"
+#include "AuthUser.h"
+#include "AuthUserRequest.h"
+#include "AuthConfig.h"
 /* Generic */
 
 class DigestAuthenticateStateData
@@ -22,17 +25,16 @@ typedef struct _digest_nonce_data digest_nonce_data;
 
 typedef struct _digest_nonce_h digest_nonce_h;
 
-class digest_user_h
+class DigestUser : public AuthUser
 {
 
 public:
     void *operator new(size_t);
     void operator delete (void *);
 
-    digest_user_h();
-    ~digest_user_h();
+    DigestUser(AuthConfig *);
+    ~DigestUser();
     int authenticated() const;
-    char *username;
     HASH HA1;
     int HA1created;
 
@@ -43,24 +45,36 @@ class digest_user_h
     static MemPool *Pool;
 };
 
+typedef class DigestUser digest_user_h;
+
 /* the digest_request structure is what follows the http_request around */
 
-class digest_request_h : public AuthUserRequestState
+class AuthDigestUserRequest : public AuthUserRequest
 {
 
 public:
     enum CredentialsState {Unchecked, Ok, Pending, Failed};
     void *operator new(size_t);
     void operator delete (void *);
 
-    digest_request_h();
-    digest_request_h(auth_user_t *);
-    ~digest_request_h();
+    AuthDigestUserRequest();
+    virtual ~AuthDigestUserRequest();
 
-    int authenticated() const;
+    virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type);
-    virtual int direction();
+    virtual int module_direction();
     virtual void addHeader(HttpReply * rep, int accel);
+#if WAITING_FOR_TE
+
+    virtual void addTrailer(HttpReply * rep, int accel);
+#endif
+
+    virtual void module_start(RH *, void *);
+    virtual AuthUser *user() {return _theUser;}
+
+    virtual const AuthUser *user() const {return _theUser;}
+
+    virtual void user (AuthUser *aUser) {_theUser=dynamic_cast<DigestUser *>(aUser);}
 
     CredentialsState credentials() const;
     void credentials(CredentialsState);
@@ -94,10 +108,10 @@ unsigned int helper_queried:
 
     flags;
     digest_nonce_h *nonce;
-    auth_user_t *theUser;
 
 private:
     static MemPool *Pool;
+    DigestUser *_theUser;
     CredentialsState credentials_ok;
 };
 
@@ -121,7 +135,7 @@ struct _digest_nonce_h : public hash_link
     /* reference count */
     short references;
     /* the auth_user this nonce has been tied to */
-    auth_user_t *auth_user;
+    DigestUser *user;
     /* has this nonce been invalidated ? */
 
     struct
@@ -139,8 +153,20 @@ unsigned int incache:
 
 /* configuration runtime data */
 
-struct _auth_digest_config
+class AuthDigestConfig : public AuthConfig
 {
+
+public:
+    AuthDigestConfig::AuthDigestConfig();
+    virtual bool active() const;
+    virtual bool configured() const;
+    virtual AuthUserRequest *decode(char const *proxy_auth);
+    virtual void done();
+    virtual void dump(StoreEntry *, const char *, AuthConfig *);
+    virtual void fixHeader(auth_user_request_t *, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void init(AuthConfig *);
+    virtual void parse(AuthConfig *, int, char *);
+    virtual const char * type() const;
     int authenticateChildren;
     char *digestAuthRealm;
     wordlist *authenticate;
@@ -152,7 +178,7 @@ struct _auth_digest_config
     int PostWorkaround;
 };
 
-typedef struct _auth_digest_config auth_digest_config;
+typedef class AuthDigestConfig auth_digest_config;
 
 /* strings */
 #define QOP_AUTH "auth"
@@ -0,0 +1,53 @@
+
+/*
+ * $Id: digestScheme.cc,v 1.1 2004/08/30 03:29:00 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "digestScheme.h"
+
+AuthScheme &
+digestScheme::GetInstance()
+{
+    return _instance;
+}
+
+digestScheme::digestScheme()
+{
+    AddScheme(*this);
+}
+
+char const *
+digestScheme::type () const
+{
+    return "digest";
+}
+
+digestScheme digestScheme::_instance;
@@ -0,0 +1,59 @@
+
+/*
+ * $Id: digestScheme.h,v 1.1 2004/08/30 03:29:00 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_DIGESTSCHEME_H
+#define SQUID_DIGESTSCHEME_H
+
+#include "AuthScheme.h"
+
+class digestScheme : public AuthScheme
+{
+
+public:
+    static AuthScheme &GetInstance();
+    digestScheme();
+    virtual ~digestScheme(){}
+
+    /* per scheme */
+    virtual char const *type () const;
+    virtual void done();
+    virtual AuthConfig *createConfig();
+    /* Not implemented */
+    digestScheme (digestScheme const &);
+    digestScheme &operator=(digestScheme const &);
+
+private:
+    static digestScheme _instance;
+};
+
+#endif /* SQUID_DIGESTSCHEME_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_ntlm.cc,v 1.39 2004/04/08 00:48:29 hno Exp $
+ * $Id: auth_ntlm.cc,v 1.40 2004/08/30 03:29:00 robertc Exp $
  *
  * DEBUG: section 29    NTLM Authenticator
  * AUTHOR: Robert Collins
@@ -45,8 +45,8 @@
 #include "client_side.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-
-extern AUTHSSETUP authSchemeSetup_ntlm;
+/* TODO remove this include */
+#include "ntlmScheme.h"
 
 static void
 authenticateStateFree(authenticateStateData * r)
@@ -57,22 +57,7 @@ authenticateStateFree(authenticateStateData * r)
 /* NTLM Scheme */
 static HLPSCB authenticateNTLMHandleReply;
 static HLPSCB authenticateNTLMHandleplaceholder;
-static AUTHSACTIVE authenticateNTLMActive;
-static AUTHSAUTHUSER authenticateNTLMAuthenticateUser;
-static AUTHSCONFIGURED authNTLMConfigured;
-static AUTHSFIXERR authenticateNTLMFixErrorHeader;
-static AUTHSFREE authenticateNTLMFreeUser;
-static AUTHSDECODE authenticateDecodeNTLMAuth;
-static AUTHSDUMP authNTLMCfgDump;
-static AUTHSFREECONFIG authNTLMFreeConfig;
-static AUTHSINIT authNTLMInit;
-static AUTHSONCLOSEC authenticateNTLMOnCloseConnection;
-static AUTHSCONNLASTHEADER NTLMLastHeader;
-static AUTHSUSERNAME authenticateNTLMUsername;
-static AUTHSPARSE authNTLMParse;
-static AUTHSSTART authenticateNTLMStart;
 static AUTHSSTATS authenticateNTLMStats;
-static AUTHSSHUTDOWN authNTLMDone;
 
 /* helper callbacks to handle per server state data */
 static HLPSAVAIL authenticateNTLMHelperServerAvailable;
@@ -85,10 +70,9 @@ CBDATA_TYPE(authenticateStateData);
 static int authntlm_initialised = 0;
 
 static MemPool *ntlm_helper_state_pool = NULL;
-static MemPool *ntlm_user_pool = NULL;
 static MemPool *ntlm_user_hash_pool = NULL;
 
-static auth_ntlm_config *ntlmConfig = NULL;
+static auth_ntlm_config ntlmConfig;
 
 static hash_table *proxy_auth_cache = NULL;
 
@@ -98,9 +82,11 @@ static hash_table *proxy_auth_cache = NULL;
  *
  */
 
-static void
-authNTLMDone(void)
+/* move to ntlmScheme.cc */
+void
+ntlmScheme::done()
 {
+    /* TODO: this should be a Config call. */
     debug(29, 2) ("authNTLMDone: shutting down NTLM authentication.\n");
 
     if (ntlmauthenticators)
@@ -122,36 +108,22 @@ authNTLMDone(void)
         memPoolDestroy(&ntlm_helper_state_pool);
     }
 
-    if (ntlm_user_pool) {
-        memPoolDestroy(&ntlm_user_pool);
-    }
-
 #endif
     debug(29, 2) ("authNTLMDone: NTLM authentication Shutdown.\n");
 }
 
 /* free any allocated configuration details */
-static void
-authNTLMFreeConfig(authScheme * scheme)
+void
+AuthNTLMConfig::done()
 {
-    if (ntlmConfig == NULL)
-        return;
-
-    assert(ntlmConfig == scheme->scheme_data);
-
-    if (ntlmConfig->authenticate)
-        wordlistDestroy(&ntlmConfig->authenticate);
-
-    xfree(ntlmConfig);
-
-    ntlmConfig = NULL;
+    if (authenticate)
+        wordlistDestroy(&authenticate);
 }
 
-static void
-authNTLMCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
+void
+AuthNTLMConfig::dump(StoreEntry * entry, const char *name, AuthConfig * scheme)
 {
-    auth_ntlm_config *config = static_cast<auth_ntlm_config *>(scheme->scheme_data);
-    wordlist *list = config->authenticate;
+    wordlist *list = authenticate;
     storeAppendPrintf(entry, "%s %s", name, "ntlm");
 
     while (list != NULL) {
@@ -160,41 +132,36 @@ authNTLMCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
     }
 
     storeAppendPrintf(entry, "\n%s %s children %d\n%s %s max_challenge_reuses %d\n%s %s max_challenge_lifetime %d seconds\n",
-                      name, "ntlm", config->authenticateChildren,
-                      name, "ntlm", config->challengeuses,
-                      name, "ntlm", (int) config->challengelifetime);
+                      name, "ntlm", authenticateChildren,
+                      name, "ntlm", challengeuses,
+                      name, "ntlm", (int) challengelifetime);
 
 }
 
-static void
-authNTLMParse(authScheme * scheme, int n_configured, char *param_str)
+AuthNTLMConfig::AuthNTLMConfig()
 {
-    if (scheme->scheme_data == NULL) {
-        assert(ntlmConfig == NULL);
-        /* this is the first param to be found */
-        scheme->scheme_data = xmalloc(sizeof(auth_ntlm_config));
-        memset(scheme->scheme_data, 0, sizeof(auth_ntlm_config));
-        ntlmConfig = static_cast<auth_ntlm_config *>(scheme->scheme_data);
-        ntlmConfig->authenticateChildren = 5;
-        ntlmConfig->challengeuses = 0;
-        ntlmConfig->challengelifetime = 60;
-    }
-
-    ntlmConfig = static_cast<auth_ntlm_config *>(scheme->scheme_data);
+    /* TODO Move into initialisation list */
+    authenticateChildren = 5;
+    challengeuses = 0;
+    challengelifetime = 60;
+}
 
+void
+AuthNTLMConfig::parse(AuthConfig * scheme, int n_configured, char *param_str)
+{
     if (strcasecmp(param_str, "program") == 0) {
-        if (ntlmConfig->authenticate)
-            wordlistDestroy(&ntlmConfig->authenticate);
+        if (authenticate)
+            wordlistDestroy(&authenticate);
 
-        parse_wordlist(&ntlmConfig->authenticate);
+        parse_wordlist(&authenticate);
 
-        requirePathnameExists("authparam ntlm program", ntlmConfig->authenticate->key);
+        requirePathnameExists("authparam ntlm program", authenticate->key);
     } else if (strcasecmp(param_str, "children") == 0) {
-        parse_int(&ntlmConfig->authenticateChildren);
+        parse_int(&authenticateChildren);
     } else if (strcasecmp(param_str, "max_challenge_reuses") == 0) {
-        parse_int(&ntlmConfig->challengeuses);
+        parse_int(&challengeuses);
     } else if (strcasecmp(param_str, "max_challenge_lifetime") == 0) {
-        parse_time_t(&ntlmConfig->challengelifetime);
+        parse_time_t(&challengelifetime);
     } else {
         debug(28, 0) ("unrecognised ntlm auth scheme parameter '%s'\n", param_str);
     }
@@ -207,50 +174,27 @@ authNTLMParse(authScheme * scheme, int n_configured, char *param_str)
      * state will be preserved.  Caveats: this should be a post-parse
      * test, but that can wait for the modular parser to be integrated.
      */
-    if (ntlmConfig->authenticate)
+    if (authenticate)
         Config.onoff.pipeline_prefetch = 0;
 }
 
-
-void
-authSchemeSetup_ntlm(authscheme_entry_t * authscheme)
+const char *
+AuthNTLMConfig::type() const
 {
-    assert(!authntlm_initialised);
-    authscheme->Active = authenticateNTLMActive;
-    authscheme->configured = authNTLMConfigured;
-    authscheme->parse = authNTLMParse;
-    authscheme->dump = authNTLMCfgDump;
-    authscheme->requestFree = NULL;
-    authscheme->freeconfig = authNTLMFreeConfig;
-    authscheme->init = authNTLMInit;
-    authscheme->authAuthenticate = authenticateNTLMAuthenticateUser;
-    authscheme->authenticated = NULL;
-    authscheme->authFixHeader = authenticateNTLMFixErrorHeader;
-    authscheme->FreeUser = authenticateNTLMFreeUser;
-    authscheme->authStart = authenticateNTLMStart;
-    authscheme->authStats = authenticateNTLMStats;
-    authscheme->authUserUsername = authenticateNTLMUsername;
-    authscheme->getdirection = NULL;
-    authscheme->decodeauth = authenticateDecodeNTLMAuth;
-    authscheme->donefunc = authNTLMDone;
-    authscheme->oncloseconnection = authenticateNTLMOnCloseConnection;
-    authscheme->authConnLastHeader = NTLMLastHeader;
+    return ntlmScheme::GetInstance().type();
 }
 
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
-static void
-authNTLMInit(authScheme * scheme)
+void
+AuthNTLMConfig::init(AuthConfig * scheme)
 {
     static int ntlminit = 0;
 
-    if (ntlmConfig->authenticate) {
+    if (authenticate) {
         if (!ntlm_helper_state_pool)
             ntlm_helper_state_pool = memPoolCreate("NTLM Helper State data", sizeof(ntlm_helper_state_t));
 
-        if (!ntlm_user_pool)
-            ntlm_user_pool = memPoolCreate("NTLM Scheme User Data", sizeof(ntlm_user_t));
-
         if (!ntlm_user_hash_pool)
 
             ntlm_user_hash_pool = memPoolCreate("NTLM Header Hash Data", sizeof(struct ProxyAuthCachePointer));
@@ -265,9 +209,9 @@ authNTLMInit(authScheme * scheme)
 
         assert(proxy_auth_cache);
 
-        ntlmauthenticators->cmdline = ntlmConfig->authenticate;
+        ntlmauthenticators->cmdline = authenticate;
 
-        ntlmauthenticators->n_to_start = ntlmConfig->authenticateChildren;
+        ntlmauthenticators->n_to_start = authenticateChildren;
 
         ntlmauthenticators->ipc_type = IPC_STREAM;
 
@@ -298,28 +242,27 @@ authNTLMInit(authScheme * scheme)
     }
 }
 
-static int
-authenticateNTLMActive()
+bool
+AuthNTLMConfig::active() const
 {
-    return (authntlm_initialised == 1) ? 1 : 0;
+    return authntlm_initialised == 1;
 }
 
-
-static int
-authNTLMConfigured()
+bool
+AuthNTLMConfig::configured() const
 {
-    if ((ntlmConfig != NULL) && (ntlmConfig->authenticate != NULL) && (ntlmConfig->authenticateChildren != 0) && (ntlmConfig->challengeuses > -1) && (ntlmConfig->challengelifetime > -1)) {
+    if ((authenticate != NULL) && (authenticateChildren != 0) && (challengeuses > -1) && (challengelifetime > -1)) {
         debug(29, 9) ("authNTLMConfigured: returning configured\n");
-        return 1;
+        return true;
     }
 
     debug(29, 9) ("authNTLMConfigured: returning unconfigured\n");
-    return 0;
+    return false;
 }
 
 /* NTLM Scheme */
 int
-ntlm_request_t::direction()
+AuthNTLMUserRequest::module_direction()
 {
     /* null auth_user is checked for by authenticateDirection */
 
@@ -328,7 +271,7 @@ ntlm_request_t::direction()
         /* no progress at all. */
 
     case AUTHENTICATE_STATE_NONE:
-        debug(29, 1) ("ntlm_request_t::direction: called before NTLM Authenticate!. Report a bug to squid-dev.\n");
+        debug(29, 1) ("AuthNTLMUserRequest::direction: called before NTLM Authenticate!. Report a bug to squid-dev.\n");
         /* fall thru */
 
     case AUTHENTICATE_STATE_FAILED:
@@ -362,12 +305,12 @@ ntlm_request_t::direction()
  * must be first. To ensure that, the configure use --enable-auth=ntlm, anything
  * else.
  */
-static void
-authenticateNTLMFixErrorHeader(auth_user_request_t * auth_user_request, HttpReply * rep, http_hdr_type type, HttpRequest * request)
+void
+AuthNTLMConfig::fixHeader(auth_user_request_t *auth_user_request, HttpReply *rep, http_hdr_type type, HttpRequest * request)
 {
-    ntlm_request_t *ntlm_request;
+    AuthNTLMUserRequest *ntlm_request;
 
-    if (ntlmConfig->authenticate) {
+    if (authenticate) {
         /* New request, no user details */
 
         if (auth_user_request == NULL) {
@@ -379,7 +322,7 @@ authenticateNTLMFixErrorHeader(auth_user_request_t * auth_user_request, HttpRepl
              * I haven't checked the RFC compliance of this hack - RBCollins */
             request->flags.proxy_keepalive = 0;
         } else {
-            ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+            ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
             assert (ntlm_request);
 
             switch (ntlm_request->auth_state) {
@@ -411,53 +354,27 @@ authenticateNTLMFixErrorHeader(auth_user_request_t * auth_user_request, HttpRepl
     }
 }
 
-ntlm_request_t::~ntlm_request_t()
-{
-    if (ntlmnegotiate)
-        xfree(ntlmnegotiate);
-
-    if (authchallenge)
-        xfree(authchallenge);
-
-    if (ntlmauthenticate)
-        xfree(ntlmauthenticate);
-
-    if (authserver != NULL && authserver_deferred) {
-        debug(29, 9) ("authenticateNTLMRequestFree: releasing server '%p'\n", authserver);
-        helperStatefulReleaseServer(authserver);
-        authserver = NULL;
-    }
-}
-
-static void
-authenticateNTLMFreeUser(auth_user_t * auth_user)
+NTLMUser::~NTLMUser()
 {
     dlink_node *link, *tmplink;
-    ntlm_user_t *ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
     ProxyAuthCachePointer *proxy_auth_hash;
-
-    debug(29, 5) ("authenticateNTLMFreeUser: Clearing NTLM scheme data\n");
-
-    if (ntlm_user->username)
-        xfree(ntlm_user->username);
+    debug(29, 5) ("NTLMUser::~NTLMUser: Clearing NTLM scheme data\n");
 
     /* were they linked in by one or more proxy-authenticate headers */
-    link = ntlm_user->proxy_auth_list.head;
+    link = proxy_auth_list.head;
 
     while (link) {
         debug(29, 9) ("authenticateFreeProxyAuthUser: removing proxy_auth hash entry '%p'\n", link->data);
         proxy_auth_hash = static_cast<ProxyAuthCachePointer *>(link->data);
         tmplink = link;
         link = link->next;
-        dlinkDelete(tmplink, &ntlm_user->proxy_auth_list);
+        dlinkDelete(tmplink, &proxy_auth_list);
         hash_remove_link(proxy_auth_cache, (hash_link *) proxy_auth_hash);
         /* free the key (usually the proxy_auth header) */
         xfree(proxy_auth_hash->key);
         memPoolFree(ntlm_user_hash_pool, proxy_auth_hash);
     }
 
-    memPoolFree(ntlm_user_pool, ntlm_user);
-    auth_user->scheme_data = NULL;
 }
 
 static stateful_helper_callback_t
@@ -478,7 +395,7 @@ authenticateNTLMHandleplaceholder(void *data, void *lastserver, char *reply)
     /* call authenticateNTLMStart to retry this request */
     debug(29, 9) ("authenticateNTLMHandleplaceholder: calling authenticateNTLMStart\n");
 
-    authenticateNTLMStart(r->auth_user_request, r->handler, r->data);
+    r->auth_user_request->start(r->handler, r->data);
 
     cbdataReferenceDone(r->data);
 
@@ -497,7 +414,7 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
     auth_user_request_t *auth_user_request;
     auth_user_t *auth_user;
     ntlm_user_t *ntlm_user;
-    ntlm_request_t *ntlm_request;
+    AuthNTLMUserRequest *ntlm_request;
     debug(29, 9) ("authenticateNTLMHandleReply: Helper: '%p' {%s}\n", lastserver, reply ? reply : "<NULL>");
 
     if (!cbdataReferenceValid(r->data)) {
@@ -537,11 +454,11 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
         /* note this code is now in two places FIXME */
         assert(r->auth_user_request != NULL);
 
-        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        assert(r->auth_user_request->user()->auth_type == AUTH_NTLM);
 
         auth_user_request = r->auth_user_request;
 
-        ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+        ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
 
         assert(ntlm_request != NULL);
 
@@ -561,17 +478,17 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
         /* we're finished, release the helper */
         reply += 3;
         assert(r->auth_user_request != NULL);
-        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        assert(r->auth_user_request->user()->auth_type == AUTH_NTLM);
         auth_user_request = r->auth_user_request;
-        ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+        ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
         assert(ntlm_request);
-        auth_user = auth_user_request->auth_user;
-        ntlm_user = static_cast<ntlm_user_t *>(auth_user_request->auth_user->scheme_data);
+        auth_user = auth_user_request->user();
+        ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user_request->user());
         assert(ntlm_user != NULL);
         result = S_HELPER_RELEASE;
         /* we only expect OK when finishing the handshake */
         assert(ntlm_request->auth_state == AUTHENTICATE_STATE_RESPONSE);
-        ntlm_user->username = xstrndup(reply, MAX_LOGIN_SZ);
+        ntlm_user->username(xstrndup(reply, MAX_LOGIN_SZ));
         ntlm_request->authserver = NULL;
 #ifdef NTLM_FAIL_OPEN
 
@@ -587,17 +504,17 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
         /* AF code: mark user as authenticated */
         reply += 3;
         assert(r->auth_user_request != NULL);
-        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        assert(r->auth_user_request->user()->auth_type == AUTH_NTLM);
         auth_user_request = r->auth_user_request;
-        ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+        ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
         assert(ntlm_request);
-        auth_user = auth_user_request->auth_user;
-        ntlm_user = static_cast<ntlm_user_t *>(auth_user_request->auth_user->scheme_data);
+        auth_user = auth_user_request->user();
+        ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user_request->user());
         assert(ntlm_user != NULL);
         result = S_HELPER_RELEASE;
         /* we only expect LD when finishing the handshake */
         assert(ntlm_request->auth_state == AUTHENTICATE_STATE_RESPONSE);
-        ntlm_user->username = xstrndup(reply, MAX_LOGIN_SZ);
+        ntlm_user->username_ = xstrndup(reply, MAX_LOGIN_SZ);
         helperstate = static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(ntlm_request->authserver));
         ntlm_request->authserver = NULL;
         /* BH code: mark helper as broken */
@@ -608,12 +525,12 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
     } else if (strncasecmp(reply, "NA ", 3) == 0) {
         /* TODO: only work with auth_user here if it exists */
         assert(r->auth_user_request != NULL);
-        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        assert(r->auth_user_request->user()->auth_type == AUTH_NTLM);
         auth_user_request = r->auth_user_request;
-        auth_user = auth_user_request->auth_user;
+        auth_user = auth_user_request->user();
         assert(auth_user != NULL);
-        ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-        ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+        ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
+        ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
         assert((ntlm_user != NULL) && (ntlm_request != NULL));
         /* todo: action of Negotiate state on error */
         result = S_HELPER_RELEASE;	/*some error has occured. no more requests */
@@ -633,12 +550,12 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
          * If after a KK deny the user's request w/ 407 and mark the helper as 
          * Needing YR. */
         assert(r->auth_user_request != NULL);
-        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        assert(r->auth_user_request->user()->auth_type == AUTH_NTLM);
         auth_user_request = r->auth_user_request;
-        auth_user = auth_user_request->auth_user;
+        auth_user = auth_user_request->user();
         assert(auth_user != NULL);
-        ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-        ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+        ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
+        ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
         assert((ntlm_user != NULL) && (ntlm_request != NULL));
         /*some error has occured. no more requests for
                                                				                					 * this helper */
@@ -655,7 +572,7 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
             helperstate->starve = 1;
             /* resubmit the request. This helper is currently busy, so we will get
              * a different one. Our auth state stays the same */
-            authenticateNTLMStart(auth_user_request, r->handler, r->data);
+            auth_user_request->start(r->handler, r->data);
             /* don't call the callback */
             cbdataReferenceDone(r->data);
             authenticateStateFree(r);
@@ -678,12 +595,12 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
         /* TODO: only work with auth_user here if it exists */
         /* TODO: take the request state into consideration */
         assert(r->auth_user_request != NULL);
-        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        assert(r->auth_user_request->user()->auth_type == AUTH_NTLM);
         auth_user_request = r->auth_user_request;
-        auth_user = auth_user_request->auth_user;
+        auth_user = auth_user_request->user();
         assert(auth_user != NULL);
-        ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-        ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+        ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
+        ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
         assert((ntlm_user != NULL) && (ntlm_request != NULL));
         debug(29, 1) ("authenticateNTLMHandleReply: *** Unsupported helper response ***, '%s'\n", reply);
         /* **** NOTE THIS CODE IS EFFECTIVELY UNTESTED **** */
@@ -734,13 +651,13 @@ authenticateNTLMChangeChallenge_p(ntlm_helper_state_t * helperstate)
         return 0;
     }
 
-    if (helperstate->challengeuses > ntlmConfig->challengeuses) {
-        debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge uses (%d) exceeded max uses (%d)\n", helperstate->challengeuses, ntlmConfig->challengeuses);
+    if (helperstate->challengeuses > ntlmConfig.challengeuses) {
+        debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge uses (%d) exceeded max uses (%d)\n", helperstate->challengeuses, ntlmConfig.challengeuses);
         return 1;
     }
 
-    if (helperstate->renewed + ntlmConfig->challengelifetime < squid_curtime) {
-        debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge exceeded max lifetime by %d seconds\n", (int) (squid_curtime - (helperstate->renewed + ntlmConfig->challengelifetime)));
+    if (helperstate->renewed + ntlmConfig.challengelifetime < squid_curtime) {
+        debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge exceeded max lifetime by %d seconds\n", (int) (squid_curtime - (helperstate->renewed + ntlmConfig.challengelifetime)));
         return 1;
     }
 
@@ -749,39 +666,34 @@ authenticateNTLMChangeChallenge_p(ntlm_helper_state_t * helperstate)
 }
 
 /* send the initial data to a stateful ntlm authenticator module */
-static void
-authenticateNTLMStart(auth_user_request_t * auth_user_request, RH * handler, void *data)
+void
+AuthNTLMUserRequest::module_start(RH * handler, void *data)
 {
     authenticateStateData *r = NULL;
     helper_stateful_server *server;
     ntlm_helper_state_t *helperstate;
     char buf[8192];
     char *sent_string = NULL;
     ntlm_user_t *ntlm_user;
-    ntlm_request_t *ntlm_request;
     auth_user_t *auth_user;
 
-    assert(auth_user_request);
-    auth_user = auth_user_request->auth_user;
-    ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-    ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+    auth_user = this->user();
+    ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
     assert(ntlm_user);
-    assert(ntlm_request);
-    assert(handler);
     assert(data);
     assert(auth_user->auth_type == AUTH_NTLM);
-    debug(29, 9) ("authenticateNTLMStart: auth state '%d'\n", ntlm_request->auth_state);
+    debug(29, 9) ("authenticateNTLMStart: auth state '%d'\n", auth_state);
 
-    switch (ntlm_request->auth_state) {
+    switch (auth_state) {
 
     case AUTHENTICATE_STATE_NEGOTIATE:
-        sent_string = ntlm_request->ntlmnegotiate;
+        sent_string = ntlmnegotiate;
         break;
 
     case AUTHENTICATE_STATE_RESPONSE:
-        sent_string = ntlm_request->ntlmauthenticate;
-        assert(ntlm_request->authserver);
-        debug(29, 9) ("authenticateNTLMStart: Asking NTLMauthenticator '%p'.\n", ntlm_request->authserver);
+        sent_string = ntlmauthenticate;
+        assert(authserver);
+        debug(29, 9) ("authenticateNTLMStart: Asking NTLMauthenticator '%p'.\n", authserver);
         break;
 
     default:
@@ -794,19 +706,19 @@ authenticateNTLMStart(auth_user_request_t * auth_user_request, RH * handler, voi
     while (xisspace(*sent_string))	/*trim leading spaces */
         sent_string++;
 
-    debug(29, 9) ("authenticateNTLMStart: state '%d'\n", ntlm_request->auth_state);
+    debug(29, 9) ("authenticateNTLMStart: state '%d'\n", auth_state);
 
     debug(29, 9) ("authenticateNTLMStart: '%s'\n", sent_string);
 
-    if (ntlmConfig->authenticate == NULL) {
+    if (ntlmConfig.authenticate == NULL) {
         debug(29, 0) ("authenticateNTLMStart: no NTLM program specified:'%s'\n", sent_string);
         handler(data, NULL);
         return;
     }
 
     /* this is ugly TODO: move the challenge generation routines to their own function and
      * tidy the logic up to make use of the efficiency we now have */
-    switch (ntlm_request->auth_state) {
+    switch (auth_state) {
 
     case AUTHENTICATE_STATE_NEGOTIATE:
         /*
@@ -830,7 +742,7 @@ authenticateNTLMStart(auth_user_request_t * auth_user_request, RH * handler, voi
         if (server == NULL)
             debug(29, 9) ("unable to get a deferred ntlm helper... all helpers are refreshing challenges. Queuing as a placeholder request.\n");
 
-        ntlm_request->authserver = server;
+        authserver = server;
 
         /* tell the log what helper we have been given */
         debug(29, 9) ("authenticateNTLMStart: helper '%p' assigned\n", server);
@@ -841,26 +753,26 @@ authenticateNTLMStart(auth_user_request_t * auth_user_request, RH * handler, voi
             r = cbdataAlloc(authenticateStateData);
             r->handler = handler;
             r->data = cbdataReference(data);
-            r->auth_user_request = auth_user_request;
+            r->auth_user_request = this;
 
             if (server == NULL) {
                 helperStatefulSubmit(ntlmauthenticators, NULL, authenticateNTLMHandleplaceholder, r, NULL);
             } else {
                 /* Server with invalid challenge */
                 snprintf(buf, 8192, "YR\n");
-                helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, ntlm_request->authserver);
+                helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, authserver);
             }
         } else {
             /* (server != NULL and we have a valid challenge) */
             /* TODO: turn the below into a function and call from here and handlereply */
             /* increment the challenge uses */
             helperstate->challengeuses++;
             /* assign the challenge */
-            ntlm_request->authchallenge = xstrndup(helperstate->challenge, NTLM_CHALLENGE_SZ + 5);
+            authchallenge = xstrndup(helperstate->challenge, NTLM_CHALLENGE_SZ + 5);
             /* we're not actually submitting a request, so we need to release the helper
              * should the connection close unexpectedly
              */
-            ntlm_request->authserver_deferred = 1;
+            authserver_deferred = 1;
             handler(data, NULL);
         }
 
@@ -870,11 +782,11 @@ authenticateNTLMStart(auth_user_request_t * auth_user_request, RH * handler, voi
         r = cbdataAlloc(authenticateStateData);
         r->handler = handler;
         r->data = cbdataReference(data);
-        r->auth_user_request = auth_user_request;
+        r->auth_user_request = this;
         snprintf(buf, 8192, "KK %s\n", sent_string);
         /* getting rid of deferred request status */
-        ntlm_request->authserver_deferred = 0;
-        helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, ntlm_request->authserver);
+        authserver_deferred = 0;
+        helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, authserver);
         debug(29, 9) ("authenticateNTLMstart: finished\n");
         break;
 
@@ -927,29 +839,27 @@ authenticateNTLMHelperServerOnEmpty(void *data)
 static void
 authenticateNTLMReleaseServer(auth_user_request_t * auth_user_request)
 {
-    ntlm_request_t *ntlm_request;
-    assert(auth_user_request->auth_user->auth_type == AUTH_NTLM);
-    ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+    AuthNTLMUserRequest *ntlm_request;
+    assert(auth_user_request->user()->auth_type == AUTH_NTLM);
+    ntlm_request = dynamic_cast< AuthNTLMUserRequest *>(auth_user_request);
     assert (ntlm_request);
     debug(29, 9) ("authenticateNTLMReleaseServer: releasing server '%p'\n", ntlm_request->authserver);
     helperStatefulReleaseServer(ntlm_request->authserver);
     ntlm_request->authserver = NULL;
 }
 
 /* clear any connection related authentication details */
-static void
-authenticateNTLMOnCloseConnection(ConnStateData * conn)
+void
+AuthNTLMUserRequest::onConnectionClose(ConnStateData *conn)
 {
-    ntlm_request_t *ntlm_request;
     assert(conn != NULL);
 
     if (conn->auth_user_request != NULL) {
-        ntlm_request = dynamic_cast< ntlm_request_t *>(conn->auth_user_request->state());
-        assert (ntlm_request);
-        assert(ntlm_request->conn == conn);
+        assert (conn->auth_user_request == this);
+        assert(this->conn == conn);
 
-        if (ntlm_request->authserver != NULL && ntlm_request->authserver_deferred)
-            authenticateNTLMReleaseServer(conn->auth_user_request);
+        if (authserver != NULL && authserver_deferred)
+            authenticateNTLMReleaseServer(this);
 
         /* unlock the connection based lock */
         debug(29, 9) ("authenticateNTLMOnCloseConnection: Unlocking auth_user from the connection.\n");
@@ -958,65 +868,44 @@ authenticateNTLMOnCloseConnection(ConnStateData * conn)
         * If needed, this could be ignored, as the conn deletion will also unlock
         * the auth user request.
         */
-        authenticateAuthUserRequestUnlock(conn->auth_user_request);
+        this->unlock();
 
         conn->auth_user_request = NULL;
     }
 }
 
-/* authenticateUserUsername: return a pointer to the username in the */
-static const char *
-authenticateNTLMUsername(auth_user_t const * auth_user)
-{
-    ntlm_user_t *ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-
-    if (ntlm_user)
-        return ntlm_user->username;
-
-    return NULL;
-}
-
 /* NTLMLastHeader: return a pointer to the last header used in authenticating
  * the request/conneciton
  */
-static const char *
-NTLMLastHeader(auth_user_request_t * auth_user_request)
+const char *
+AuthNTLMUserRequest::connLastHeader()
 {
-    ntlm_request_t *ntlm_request;
-    assert(auth_user_request != NULL);
-    ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
-    assert (ntlm_request);
-    return ntlm_request->ntlmauthenticate;
+    return ntlmauthenticate;
 }
 
 /*
  * Decode an NTLM [Proxy-]Auth string, placing the results in the passed
  * Auth_user structure.
  */
-
-static void
-authenticateDecodeNTLMAuth(auth_user_request_t * auth_user_request, const char *proxy_auth)
+AuthUserRequest *
+AuthNTLMConfig::decode(char const *proxy_auth)
 {
-    dlink_node *node;
-    assert(auth_user_request->auth_user == NULL);
-    auth_user_request->auth_user = authenticateAuthUserNew("ntlm");
-    auth_user_request->auth_user->auth_type = AUTH_NTLM;
-    auth_user_request->auth_user->scheme_data = memPoolAlloc(ntlm_user_pool);
-    auth_user_request->state (new ntlm_request_t);
-    /* lock for the auth_user_request link */
-    authenticateAuthUserLock(auth_user_request->auth_user);
-    node = dlinkNodeNew();
-    dlinkAdd(auth_user_request, node, &auth_user_request->auth_user->requests);
+    NTLMUser *newUser = new NTLMUser(&ntlmConfig);
+    AuthNTLMUserRequest *auth_user_request = new AuthNTLMUserRequest ();
+    assert(auth_user_request->user() == NULL);
+    auth_user_request->user(newUser);
+    auth_user_request->user()->auth_type = AUTH_NTLM;
+    auth_user_request->user()->addRequest(auth_user_request);
 
     /* all we have to do is identify that it's NTLM - the helper does the rest */
     debug(29, 9) ("authenticateDecodeNTLMAuth: NTLM authentication\n");
-    return;
+    return auth_user_request;
 }
 
 static int
 authenticateNTLMcmpUsername(ntlm_user_t * u1, ntlm_user_t * u2)
 {
-    return strcmp(u1->username, u2->username);
+    return strcmp(u1->username(), u2->username());
 }
 
 
@@ -1031,7 +920,7 @@ authenticateProxyAuthCacheAddLink(const char *key, auth_user_t * auth_user)
     struct ProxyAuthCachePointer *proxy_auth_hash;
     dlink_node *node;
     ntlm_user_t *ntlm_user;
-    ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
+    ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
     node = ntlm_user->proxy_auth_list.head;
     /* prevent duplicates */
 
@@ -1051,7 +940,7 @@ authenticateProxyAuthCacheAddLink(const char *key, auth_user_t * auth_user)
 }
 
 int
-ntlm_request_t::authenticated() const
+AuthNTLMUserRequest::authenticated() const
 {
     if (auth_state == AUTHENTICATE_STATE_DONE)
         return 1;
@@ -1062,31 +951,25 @@ ntlm_request_t::authenticated() const
 }
 
 void
-ntlm_request_t::authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
-{
-    fatal ("unusable");
-}
-
-static void
-authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
+AuthNTLMUserRequest::authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type)
 {
     const char *proxy_auth;
 
     struct ProxyAuthCachePointer *proxy_auth_hash = NULL;
     auth_user_hash_pointer *usernamehash;
+    /* TODO: rename this!! */
     auth_user_t *auth_user;
-    ntlm_request_t *ntlm_request;
+    AuthNTLMUserRequest *ntlm_request;
     ntlm_user_t *ntlm_user;
     LOCAL_ARRAY(char, ntlmhash, NTLM_CHALLENGE_SZ * 2);
     /* get header */
     proxy_auth = httpHeaderGetStr(&request->header, type);
 
-    auth_user = auth_user_request->auth_user;
+    auth_user = user();
     assert(auth_user);
     assert(auth_user->auth_type == AUTH_NTLM);
-    assert(auth_user->scheme_data != NULL);
-    ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-    ntlm_request = dynamic_cast< ntlm_request_t *>(auth_user_request->state());
+    ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
+    ntlm_request = this;
     assert (ntlm_request);
     /* Check that we are in the client side, where we can generate
      * auth challenges */
@@ -1105,25 +988,33 @@ authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, HttpRe
         ntlm_request->auth_state = AUTHENTICATE_STATE_NEGOTIATE;
         ntlm_request->ntlmnegotiate = xstrndup(proxy_auth, NTLM_CHALLENGE_SZ + 5);
         conn->auth_type = AUTH_NTLM;
-        conn->auth_user_request = auth_user_request;
+        conn->auth_user_request = this;
         ntlm_request->conn = conn;
         /* and lock for the connection duration */
         debug(29, 9) ("authenticateNTLMAuthenticateUser: Locking auth_user from the connection.\n");
-        authenticateAuthUserRequestLock(auth_user_request);
+
+        this->lock()
+
+        ;
         return;
+
         break;
 
     case AUTHENTICATE_STATE_NEGOTIATE:
         ntlm_request->auth_state = AUTHENTICATE_STATE_CHALLENGE;
+
         /* We _MUST_ have the auth challenge by now */
         assert(ntlm_request->authchallenge);
+
         return;
+
         break;
 
     case AUTHENTICATE_STATE_CHALLENGE:
         /* we should have recieved a NTLM challenge. pass it to the same
          * helper process */
         debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state challenge with header %s.\n", proxy_auth);
+
         /* do a cache lookup here. If it matches it's a successful ntlm
          * challenge - release the helper and use the existing auth_user 
          * details. */
@@ -1155,17 +1046,17 @@ authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, HttpRe
             debug(29, 4) ("authenticateNTLMAuthenticateUser: ntlm proxy-auth cache hit\n");
             /* throw away the temporary entry */
             ntlm_request->authserver_deferred = 0;
-            authenticateNTLMReleaseServer(auth_user_request);
+            authenticateNTLMReleaseServer(this);
             authenticateAuthUserMerge(auth_user, proxy_auth_hash->auth_user);
             auth_user = proxy_auth_hash->auth_user;
-            auth_user_request->auth_user = auth_user;
+            this->user(auth_user);
             ntlm_request->auth_state = AUTHENTICATE_STATE_DONE;
             /* we found one */
             debug(29, 9) ("found matching cache entry\n");
             assert(auth_user->auth_type == AUTH_NTLM);
             /* get the existing entries details */
-            ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-            debug(29, 9) ("Username to be used is %s\n", ntlm_user->username);
+            ntlm_user = dynamic_cast<ntlm_user_t *>(auth_user);
+            debug(29, 9) ("Username to be used is %s\n", ntlm_user->username());
             /* on ntlm auth we do not unlock the auth_user until the
              * connection is dropped. Thank MS for this quirk */
             auth_user->expiretime = current_time.tv_sec;
@@ -1182,35 +1073,35 @@ authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, HttpRe
         debug(29, 4) ("authenticated\nch    %s\nauth     %s\nauthuser %s\n",
                       ntlm_request->authchallenge,
                       ntlm_request->ntlmauthenticate,
-                      ntlm_user->username);
+                      ntlm_user->username());
         /* cache entries have authenticateauthheaderchallengestring */
         snprintf(ntlmhash, sizeof(ntlmhash) - 1, "%s%s",
                  ntlm_request->ntlmauthenticate,
                  ntlm_request->authchallenge);
         /* see if this is an existing user with a different proxy_auth
          * string */
 
-        if ((usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, ntlm_user->username)))
+        if ((usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, ntlm_user->username())))
            ) {
-            while ((authUserHashPointerUser(usernamehash)->auth_type != auth_user->auth_type) && (usernamehash->next) && !authenticateNTLMcmpUsername(static_cast<ntlm_user_t *>(authUserHashPointerUser(usernamehash)->scheme_data), ntlm_user)
+            while ((usernamehash->user()->auth_type != auth_user->auth_type) && (usernamehash->next) && !authenticateNTLMcmpUsername(dynamic_cast<ntlm_user_t *>(usernamehash->user()), ntlm_user)
                   )
                 usernamehash = static_cast<AuthUserHashPointer*>(usernamehash->next);
-            if (authUserHashPointerUser(usernamehash)->auth_type == auth_user->auth_type) {
+            if (usernamehash->user()->auth_type == auth_user->auth_type) {
                 /*
                  * add another link from the new proxy_auth to the
                  * auth_user structure and update the information */
                 assert(proxy_auth_hash == NULL);
-                authenticateProxyAuthCacheAddLink(ntlmhash, authUserHashPointerUser(usernamehash));
+                authenticateProxyAuthCacheAddLink(ntlmhash, usernamehash->user());
                 /* we can't seamlessly recheck the username due to the
                  * challenge nature of the protocol. Just free the 
                  * temporary auth_user */
-                authenticateAuthUserMerge(auth_user, authUserHashPointerUser(usernamehash));
-                auth_user = authUserHashPointerUser(usernamehash);
-                auth_user_request->auth_user = auth_user;
+                authenticateAuthUserMerge(auth_user, usernamehash->user());
+                auth_user = usernamehash->user();
+                this->user(auth_user);
             }
         } else {
             /* store user in hash's */
-            authenticateUserNameCacheAdd(auth_user);
+            auth_user->addToNameCache();
             authenticateProxyAuthCacheAddLink(ntlmhash, auth_user);
         }
 
@@ -1233,21 +1124,81 @@ authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, HttpRe
     return;
 }
 
-MemPool (*ntlm_request_t::Pool)(NULL);
+MemPool (*AuthNTLMUserRequest::Pool)(NULL);
 void *
-ntlm_request_t::operator new (size_t byteCount)
+AuthNTLMUserRequest::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ntlm_request_t));
+    assert (byteCount == sizeof (AuthNTLMUserRequest));
 
     if (!Pool)
-        Pool = memPoolCreate("ntlm_request_t", sizeof (ntlm_request_t));
+        Pool = memPoolCreate("AuthNTLMUserRequest", sizeof (AuthNTLMUserRequest));
 
     return memPoolAlloc(Pool);
 }
 
 void
-ntlm_request_t::operator delete (void *address)
+AuthNTLMUserRequest::operator delete (void *address)
 {
     memPoolFree (Pool, address);
 }
+
+AuthNTLMUserRequest::AuthNTLMUserRequest() : ntlmnegotiate(NULL), authchallenge(NULL), ntlmauthenticate(NULL),
+        authserver(NULL), auth_state(AUTHENTICATE_STATE_NONE),
+        authserver_deferred(0), conn(NULL), _theUser(NULL)
+{}
+
+AuthNTLMUserRequest::~AuthNTLMUserRequest()
+{
+    if (ntlmnegotiate)
+        xfree(ntlmnegotiate);
+
+    if (authchallenge)
+        xfree(authchallenge);
+
+    if (ntlmauthenticate)
+        xfree(ntlmauthenticate);
+
+    if (authserver != NULL && authserver_deferred) {
+        debug(29, 9) ("authenticateNTLMRequestFree: releasing server '%p'\n", authserver);
+        helperStatefulReleaseServer(authserver);
+        authserver = NULL;
+    }
+}
+
+MemPool *NTLMUser::Pool (NULL);
+void
+NTLMUser::deleteSelf() const
+{
+    delete this;
+}
+
+void *
+NTLMUser::operator new(size_t byteCount)
+{
+    /* derived classes with different sizes must implement their own new */
+    assert (byteCount == sizeof (NTLMUser));
+
+    if (!Pool)
+        Pool = memPoolCreate("Authenticate NTLM User Data", sizeof (NTLMUser));
+
+    return memPoolAlloc(Pool);
+}
+
+void
+NTLMUser::operator delete (void *address)
+{
+    memPoolFree(Pool, address);
+}
+
+NTLMUser::NTLMUser (AuthConfig *config) : AuthUser (config)
+{
+    proxy_auth_list.head = proxy_auth_list.tail = NULL;
+}
+
+AuthConfig *
+ntlmScheme::createConfig()
+{
+    return &ntlmConfig;
+}
+
@@ -6,6 +6,9 @@
 #ifndef __AUTH_NTLM_H__
 #define __AUTH_NTLM_H__
 #include "authenticate.h"
+#include "AuthUser.h"
+#include "AuthUserRequest.h"
+#include "AuthConfig.h"
 
 #define DefaultAuthenticateChildrenMax  32	/* 32 processes */
 
@@ -29,24 +32,44 @@ typedef struct
 
 authenticateStateData;
 
-struct _ntlm_user
+class NTLMUser : public AuthUser
 {
-    /* what username did this connection get? */
-    char *username;
+
+public:
+    virtual void deleteSelf() const;
+    void *operator new(size_t);
+    void operator delete (void *);
+    NTLMUser(AuthConfig *);
+    ~NTLMUser();
     dlink_list proxy_auth_list;
+
+private:
+    static MemPool *Pool;
 };
 
-class ntlm_request_t : public AuthUserRequestState
+typedef class NTLMUser ntlm_user_t;
+
+class AuthNTLMUserRequest : public AuthUserRequest
 {
 
 public:
     void *operator new(size_t);
     void operator delete (void *);
 
-    ~ntlm_request_t();
+    AuthNTLMUserRequest();
+    virtual ~AuthNTLMUserRequest();
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type);
-    virtual int direction();
+    virtual int module_direction();
+    virtual void onConnectionClose(ConnStateData *);
+    virtual const char *connLastHeader();
+    virtual void module_start(RH *, void *);
+    virtual AuthUser *user() {return _theUser;}
+
+    virtual const AuthUser *user() const {return _theUser;}
+
+    virtual void user (AuthUser *aUser) {_theUser=dynamic_cast<NTLMUser *>(aUser);}
+
     /* what negotiate string did the client use? */
     char *ntlmnegotiate;
     /* what challenge did we give the client? */
@@ -64,6 +87,8 @@ class ntlm_request_t : public AuthUserRequestState
 
 private:
     static MemPool *Pool;
+    /* the user */
+    NTLMUser * _theUser;
 };
 
 struct _ntlm_helper_state_t
@@ -76,8 +101,20 @@ struct _ntlm_helper_state_t
 
 /* configuration runtime data */
 
-struct _auth_ntlm_config
+class AuthNTLMConfig : public AuthConfig
 {
+
+public:
+    AuthNTLMConfig::AuthNTLMConfig();
+    virtual bool active() const;
+    virtual bool configured() const;
+    virtual AuthUserRequest *decode(char const *proxy_auth);
+    virtual void done();
+    virtual void dump(StoreEntry *, const char *, AuthConfig *);
+    virtual void fixHeader(auth_user_request_t *, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void init(AuthConfig *);
+    virtual void parse(AuthConfig *, int, char *);
+    virtual const char * type() const;
     int authenticateChildren;
     wordlist *authenticate;
     int challengeuses;
@@ -91,11 +128,8 @@ struct ProxyAuthCachePointer : public hash_link
     auth_user_t *auth_user;
 };
 
-typedef struct _ntlm_user ntlm_user_t;
-
-
 typedef struct _ntlm_helper_state_t ntlm_helper_state_t;
 
-typedef struct _auth_ntlm_config auth_ntlm_config;
+typedef class AuthNTLMConfig auth_ntlm_config;
 
 #endif
@@ -0,0 +1,53 @@
+
+/*
+ * $Id: ntlmScheme.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "ntlmScheme.h"
+
+AuthScheme &
+ntlmScheme::GetInstance()
+{
+    return _instance;
+}
+
+ntlmScheme::ntlmScheme()
+{
+    AddScheme(*this);
+}
+
+char const *
+ntlmScheme::type () const
+{
+    return "ntlm";
+}
+
+ntlmScheme ntlmScheme::_instance;
@@ -0,0 +1,59 @@
+
+/*
+ * $Id: ntlmScheme.h,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_NTLMSCHEME_H
+#define SQUID_NTLMSCHEME_H
+
+#include "AuthScheme.h"
+
+class ntlmScheme : public AuthScheme
+{
+
+public:
+    static AuthScheme &GetInstance();
+    ntlmScheme();
+    virtual ~ntlmScheme(){};
+
+    /* per scheme */
+    virtual char const *type () const;
+    virtual void done();
+    virtual AuthConfig *createConfig();
+    /* Not implemented */
+    ntlmScheme (ntlmScheme const &);
+    ntlmScheme &operator=(ntlmScheme const &);
+
+private:
+    static ntlmScheme _instance;
+};
+
+#endif /* SQUID_ntlmSCHEME_H */
@@ -1,16 +0,0 @@
-#!/bin/sh
-echo "/* automatically generated by $0 $*"
-echo " * do not edit"
-echo " */"
-echo "#include \"squid.h\""
-echo "#include \"authenticate.h\""
-echo ""
-for module in "$@"; do
-   echo "extern AUTHSSETUP authSchemeSetup_${module};"
-done
-echo "void authSchemeSetup(void)"
-echo "{"
-for module in "$@"; do
-   echo "	authSchemeAdd(\"$module\", authSchemeSetup_${module});"
-done
-echo "}"
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.cc,v 1.64 2004/04/03 14:42:00 hno Exp $
+ * $Id: authenticate.cc,v 1.65 2004/08/30 03:28:57 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR:  Robert Collins
@@ -41,837 +41,30 @@
 #include "authenticate.h"
 #include "ACL.h"
 #include "client_side.h"
+#include "AuthConfig.h"
+#include "AuthScheme.h"
+#include "AuthUser.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
-CBDATA_TYPE(auth_user_ip_t);
-
 /*
  *
  * Private Data
  *
  */
 
-MemPool *AuthUserRequest::pool = NULL;
 MemPool *AuthUserHashPointer::pool = NULL;
-MemPool *AuthUser::pool = NULL;
-/*
- *     memDataInit(MEM_AUTH_USER_T, "auth_user_t",
- *             sizeof(auth_user_t), 0);
- */
-
-/* Generic Functions */
-
-
-static int
-authenticateAuthSchemeConfigured(const char *proxy_auth)
-{
-    authScheme *scheme;
-    int i;
-
-    for (i = 0; i < Config.authConfiguration.n_configured; i++) {
-        scheme = Config.authConfiguration.schemes + i;
-
-        if ((strncasecmp(proxy_auth, scheme->typestr, strlen(scheme->typestr)) == 0) &&
-                (authscheme_list[scheme->Id].Active()))
-            return 1;
-    }
-
-    return 0;
-}
-
-int
-authenticateAuthSchemeId(const char *typestr)
-{
-    int i = 0;
-
-    for (i = 0; authscheme_list && authscheme_list[i].typestr; i++) {
-        if (strncasecmp(typestr, authscheme_list[i].typestr, strlen(authscheme_list[i].typestr)) == 0) {
-            return i;
-        }
-    }
-
-    return -1;
-}
-
-void
-AuthUserRequest::decodeAuth(const char *proxy_auth)
-{
-    int i = 0;
-    assert(proxy_auth != NULL);
-    debug(29, 9) ("authenticateDecodeAuth: header = '%s'\n", proxy_auth);
-
-    if (!authenticateAuthSchemeConfigured(proxy_auth) ||
-            (i = authenticateAuthSchemeId(proxy_auth)) == -1) {
-        debug(29, 1) ("AuthUserRequest::decodeAuth: Unsupported or unconfigured proxy-auth scheme, '%s'\n", proxy_auth);
-        return;
-    }
-
-    assert (i >= 0);
-    authscheme_list[i].decodeauth(this, proxy_auth);
-    auth_user->auth_module = i + 1;
-}
-
-size_t
-AuthUserRequest::refCount () const
-{
-    return references;
-}
-
-char const *
-AuthUserRequest::username() const
-{
-    if (auth_user)
-        return auth_user->username();
-    else
-        return NULL;
-}
-
-size_t
-authenticateRequestRefCount (auth_user_request_t *aRequest)
-{
-    return aRequest->refCount();
-}
-
-/* clear any connection related authentication details */
-void
-authenticateOnCloseConnection(ConnStateData * conn)
-{
-    auth_user_request_t *auth_user_request;
-    assert(conn != NULL);
-
-    if (conn->auth_user_request != NULL) {
-        auth_user_request = conn->auth_user_request;
-        /* if the auth type gets reset, the connection shouldn't
-         * remain linked to it - the next type might not be conn based
-         */
-        assert(auth_user_request->auth_user->auth_module);
-
-        if (authscheme_list[auth_user_request->auth_user->auth_module - 1].oncloseconnection) {
-            authscheme_list[auth_user_request->auth_user->auth_module - 1].oncloseconnection(conn);
-        }
-    }
-}
 
 /**** PUBLIC FUNCTIONS (ALL GENERIC!)  ****/
 
-/* send the initial data to an authenticator module */
-void
-AuthUserRequest::start(RH * handler, void *data)
-{
-    assert(handler);
-    debug(29, 9) ("authenticateStart: auth_user_request '%p'\n", this);
-
-    if (auth_user->auth_module > 0)
-        authscheme_list[auth_user->auth_module - 1].authStart(this, handler, data);
-    else
-        handler(data, NULL);
-}
-
-void
-authenticateStart(auth_user_request_t * auth_user_request, RH * handler, void *data)
-{
-    assert(auth_user_request);
-    auth_user_request->start (handler, data);
-}
-
-/*
- * Check a auth_user pointer for validity. Does not check passwords, just data
- * sensability. Broken or Unknown auth_types are not valid for use...
- */
-
-int
-authenticateValidateUser(auth_user_request_t * auth_user_request)
-{
-    debug(29, 9) ("authenticateValidateUser: Validating Auth_user request '%p'.\n", auth_user_request);
-
-    if (auth_user_request == NULL) {
-        debug(29, 4) ("authenticateValidateUser: Auth_user_request was NULL!\n");
-        return 0;
-    }
-
-    if (auth_user_request->auth_user == NULL) {
-        debug(29, 4) ("authenticateValidateUser: No associated auth_user structure\n");
-        return 0;
-    }
-
-    if (auth_user_request->auth_user->auth_type == AUTH_UNKNOWN) {
-        debug(29, 4) ("authenticateValidateUser: Auth_user '%p' uses unknown scheme.\n", auth_user_request->auth_user);
-        return 0;
-    }
-
-    if (auth_user_request->auth_user->auth_type == AUTH_BROKEN) {
-        debug(29, 4) ("authenticateValidateUser: Auth_user '%p' is broken for it's scheme.\n", auth_user_request->auth_user);
-        return 0;
-    }
-
-    if (!auth_user_request->auth_user->scheme_data) {
-        debug(29, 4) ("authenticateValidateUser: auth_user '%p' has no scheme data\n", auth_user_request->auth_user);
-        return 0;
-    }
-
-    /* any other sanity checks that we need in the future */
-
-    /* Thus should a module call to something like authValidate */
-
-    /* finally return ok */
-    debug(29, 5) ("authenticateValidateUser: Validated Auth_user request '%p'.\n", auth_user_request);
-
-    return 1;
-
-}
-
-void *
-AuthUser::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (AuthUser));
-
-    if (!pool)
-        pool = memPoolCreate("Authenticate User Data", sizeof (auth_user_t));
-
-    return memPoolAlloc(pool);
-}
-
-AuthUser::AuthUser (const char *scheme) :
-        auth_type (AUTH_UNKNOWN), auth_module (authenticateAuthSchemeId(scheme) + 1),
-        usernamehash (NULL), ipcount (0), expiretime (0), references (0), scheme_data (NULL)
-{
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
-    proxy_match_cache.head = proxy_match_cache.tail = NULL;
-    ip_list.head = ip_list.tail = NULL;
-    requests.head = requests.tail = NULL;
-}
-
-char const *
-AuthUser::username () const
-{
-    if (auth_module <= 0)
-        return NULL;
-
-    return authscheme_list[auth_module - 1].authUserUsername(this);
-}
-
-auth_user_t *
-authenticateAuthUserNew(const char *scheme)
-{
-    return new AuthUser (scheme);
-}
-
-void *
-AuthUserRequest::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (AuthUserRequest));
-
-    if (!pool)
-        pool = memPoolCreate("Authenticate Request Data", sizeof(auth_user_request_t));
-
-    return static_cast<auth_user_request_t *>(memPoolAlloc(pool));
-}
-
-void
-AuthUserRequest::operator delete (void *address)
-{
-    memPoolFree(pool, address);
-}
-
-AuthUserRequest::AuthUserRequest():auth_user(NULL), message(NULL),
-        references (0), lastReply (AUTH_ACL_CANNOT_AUTHENTICATE), state_ (NULL)
-{}
-
-AuthUserRequest::~AuthUserRequest()
-{
-    dlink_node *link;
-    debug(29, 5) ("AuthUserRequest::~AuthUserRequest: freeing request %p\n", this);
-    assert(references == 0);
-
-    if (auth_user) {
-        if (state() != NULL) {
-            /* we MUST know the module */
-            assert(auth_user->auth_module > 0);
-
-            if (authscheme_list[auth_user->auth_module - 1].requestFree != NULL)
-                authscheme_list[auth_user->auth_module - 1].requestFree(this);
-            else {
-                delete state();
-                state(NULL);
-            }
-        }
-
-        /* unlink from the auth_user struct */
-        link = auth_user->requests.head;
-
-        while (link && (link->data != this))
-            link = link->next;
-
-        assert(link != NULL);
-
-        dlinkDelete(link, &auth_user->requests);
-
-        dlinkNodeDelete(link);
-
-        /* unlock the request structure's lock */
-        authenticateAuthUserUnlock(auth_user);
-
-        auth_user = NULL;
-    } else
-        assert(state() == NULL);
-
-    safe_free (message);
-}
-
-void
-AuthUserRequest::setDenyMessage (char const *aString)
-{
-    safe_free (message);
-    message = xstrdup (aString);
-}
-
-char const *
-AuthUserRequest::getDenyMessage ()
-{
-    return message;
-}
-
-char const *
-authenticateAuthUserRequestMessage(auth_user_request_t * auth_user_request)
-{
-    if (auth_user_request)
-        return auth_user_request->getDenyMessage();
-
-    return NULL;
-}
-
-void
-authenticateSetDenyMessage (auth_user_request_t * auth_user_request, char const *message)
-{
-    auth_user_request->setDenyMessage (message);
-}
-
-static void
-
-authenticateAuthUserRequestSetIp(auth_user_request_t * auth_user_request, struct in_addr ipaddr)
-{
-    auth_user_ip_t *ipdata, *tempnode;
-    auth_user_t *auth_user;
-    char *ip1;
-    int found = 0;
-    CBDATA_INIT_TYPE(auth_user_ip_t);
-
-    if (!auth_user_request->auth_user)
-        return;
-
-    auth_user = auth_user_request->auth_user;
-
-    ipdata = (auth_user_ip_t *) auth_user->ip_list.head;
-
-    /*
-     * we walk the entire list to prevent the first item in the list
-     * preventing old entries being flushed and locking a user out after
-     * a timeout+reconfigure
-     */
-    while (ipdata)
-    {
-        tempnode = (auth_user_ip_t *) ipdata->node.next;
-        /* walk the ip list */
-
-        if (ipdata->ipaddr.s_addr == ipaddr.s_addr) {
-            /* This ip has alreadu been seen. */
-            found = 1;
-            /* update IP ttl */
-            ipdata->ip_expiretime = squid_curtime;
-        } else if (ipdata->ip_expiretime + Config.authenticateIpTTL < squid_curtime) {
-            /* This IP has expired - remove from the seen list */
-            dlinkDelete(&ipdata->node, &auth_user->ip_list);
-            cbdataFree(ipdata);
-            /* catch incipient underflow */
-            assert(auth_user->ipcount);
-            auth_user->ipcount--;
-        }
-
-        ipdata = tempnode;
-    }
-
-    if (found)
-        return;
-
-    /* This ip is not in the seen list */
-    ipdata = cbdataAlloc(auth_user_ip_t);
-
-    ipdata->ip_expiretime = squid_curtime;
-
-    ipdata->ipaddr = ipaddr;
-
-    dlinkAddTail(ipdata, &ipdata->node, &auth_user->ip_list);
-
-    auth_user->ipcount++;
-
-    ip1 = xstrdup(inet_ntoa(ipaddr));
-
-    debug(29, 2) ("authenticateAuthUserRequestSetIp: user '%s' has been seen at a new IP address (%s)\n", auth_user->username(), ip1);
-
-    safe_free(ip1);
-}
-
-void
-
-authenticateAuthUserRequestRemoveIp(auth_user_request_t * auth_user_request, struct in_addr ipaddr)
-{
-    auth_user_ip_t *ipdata;
-    auth_user_t *auth_user;
-
-    if (!auth_user_request->auth_user)
-        return;
-
-    auth_user = auth_user_request->auth_user;
-
-    ipdata = (auth_user_ip_t *) auth_user->ip_list.head;
-
-    while (ipdata)
-    {
-        /* walk the ip list */
-
-        if (ipdata->ipaddr.s_addr == ipaddr.s_addr) {
-            /* remove the node */
-            dlinkDelete(&ipdata->node, &auth_user->ip_list);
-            cbdataFree(ipdata);
-            /* catch incipient underflow */
-            assert(auth_user->ipcount);
-            auth_user->ipcount--;
-            return;
-        }
-
-        ipdata = (auth_user_ip_t *) ipdata->node.next;
-    }
-
-}
-
-static void
-authenticateAuthUserClearIp(auth_user_t * auth_user)
-{
-    auth_user_ip_t *ipdata, *tempnode;
-
-    if (!auth_user)
-        return;
-
-    ipdata = (auth_user_ip_t *) auth_user->ip_list.head;
-
-    while (ipdata) {
-        tempnode = (auth_user_ip_t *) ipdata->node.next;
-        /* walk the ip list */
-        dlinkDelete(&ipdata->node, &auth_user->ip_list);
-        cbdataFree(ipdata);
-        /* catch incipient underflow */
-        assert(auth_user->ipcount);
-        auth_user->ipcount--;
-        ipdata = tempnode;
-    }
-
-    /* integrity check */
-    assert(auth_user->ipcount == 0);
-}
-
-
-void
-authenticateAuthUserRequestClearIp(auth_user_request_t * auth_user_request)
-{
-    if (auth_user_request)
-        authenticateAuthUserClearIp(auth_user_request->auth_user);
-}
-
-size_t
-authenticateAuthUserRequestIPCount(auth_user_request_t * auth_user_request)
-{
-    assert(auth_user_request);
-    assert(auth_user_request->auth_user);
-    return auth_user_request->auth_user->ipcount;
-}
-
-
-/* Get Auth User: Return a filled out auth_user structure for the given
- * Proxy Auth (or Auth) header. It may be a cached Auth User or a new
- * Unauthenticated structure. The structure is given an inital lock here.
- */
-auth_user_request_t *
-AuthUserRequest::createAuthUser(const char *proxy_auth)
-{
-    auth_user_request_t *result = new auth_user_request_t;
-    /* and lock for the callers instance */
-
-    result->lock()
-
-    ;
-    /* The scheme is allowed to provide a cached auth_user or a new one */
-    result->decodeAuth(proxy_auth);
-
-    return result;
-}
-
-/*
- * authenticateUserAuthenticated: is this auth_user structure logged in ?
- */
-int
-authenticateUserAuthenticated(auth_user_request_t * auth_user_request)
-{
-    if (!authenticateValidateUser(auth_user_request))
-        return 0;
-
-    if (auth_user_request->auth_user->auth_module > 0) {
-        /* legacy interface */
-
-        if (authscheme_list[auth_user_request->auth_user->auth_module - 1].authenticated)
-            return authscheme_list[auth_user_request->auth_user->auth_module - 1].authenticated(auth_user_request);
-        else {
-            /* state interface */
-            assert (auth_user_request->state());
-            return auth_user_request->state()->authenticated();
-        }
-    } else
-        return 0;
-}
-
-/*
- * authenticateAuthenticateUser: call the module specific code to 
- * log this user request in.
- * Cache hits may change the auth_user pointer in the structure if needed.
- * This is basically a handle approach.
- */
-static void
-authenticateAuthenticateUser(auth_user_request_t * auth_user_request, HttpRequest * request, ConnStateData::Pointer &conn, http_hdr_type type)
-{
-    assert(auth_user_request != NULL);
-
-    if (auth_user_request->auth_user->auth_module > 0) {
-        if (authscheme_list[auth_user_request->auth_user->auth_module - 1].authAuthenticate)
-            authscheme_list[auth_user_request->auth_user->auth_module - 1].authAuthenticate(auth_user_request, request, conn, type);
-        else {
-            assert (auth_user_request->state());
-            auth_user_request->state()->authenticate(request, conn, type);
-        }
-    }
-}
-
-static auth_user_request_t *
-authTryGetUser (auth_user_request_t **auth_user_request, ConnStateData::Pointer & conn, HttpRequest * request)
-{
-    if (*auth_user_request)
-        return *auth_user_request;
-    else if (request != NULL && request->auth_user_request)
-        return request->auth_user_request;
-    else if (conn.getRaw() != NULL)
-        return conn->auth_user_request;
-    else
-        return NULL;
-}
-
-/* returns one of
- * AUTH_ACL_CHALLENGE,
- * AUTH_ACL_HELPER,
- * AUTH_ACL_CANNOT_AUTHENTICATE,
- * AUTH_AUTHENTICATED
- *
- * How to use: In your proxy-auth dependent acl code, use the following 
- * construct:
- * int rv;
- * if ((rv = AuthenticateAuthenticate()) != AUTH_AUTHENTICATED)
- *   return rv;
- * 
- * when this code is reached, the request/connection is authenticated.
- *
- * if you have non-acl code, but want to force authentication, you need a 
- * callback mechanism like the acl testing routines that will send a 40[1|7] to
- * the client when rv==AUTH_ACL_CHALLENGE, and will communicate with 
- * the authenticateStart routine for rv==AUTH_ACL_HELPER
- */
-auth_acl_t
-
-AuthUserRequest::authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr)
-{
-    const char *proxy_auth;
-    assert(headertype != 0);
-
-    proxy_auth = httpHeaderGetStr(&request->header, headertype);
-
-    /*
-     * a note on proxy_auth logix here:
-     * proxy_auth==NULL -> unauthenticated request || already
-     * authenticated connection so we test for an authenticated
-     * connection when we recieve no authentication header.
-     */
-
-    if (((proxy_auth == NULL) && (!authenticateUserAuthenticated(authTryGetUser(auth_user_request,conn,request))))
-            || (conn.getRaw() != NULL  && conn->auth_type == AUTH_BROKEN))
-    {
-        /* no header or authentication failed/got corrupted - restart */
-        debug(28, 4) ("authenticateAuthenticate: broken auth or no proxy_auth header. Requesting auth header.\n");
-        /* something wrong with the AUTH credentials. Force a new attempt */
-
-        if (conn.getRaw() != NULL) {
-            conn->auth_type = AUTH_UNKNOWN;
-
-            if (conn->auth_user_request)
-                conn->auth_user_request->unlock();
-
-            conn->auth_user_request = NULL;
-        }
-
-        if (*auth_user_request) {
-            /* unlock the ACL lock */
-            (*auth_user_request)->unlock();
-            auth_user_request = NULL;
-        }
-
-        return AUTH_ACL_CHALLENGE;
-    }
-
-    /*
-     * Is this an already authenticated connection with a new auth header?
-     * No check for function required in the if: its compulsory for conn based 
-     * auth modules
-     */
-    if (proxy_auth && conn.getRaw() != NULL && conn->auth_user_request &&
-            authenticateUserAuthenticated(conn->auth_user_request) &&
-            strcmp(proxy_auth, authscheme_list[conn->auth_user_request->auth_user->auth_module - 1].authConnLastHeader(conn->auth_user_request)))
-    {
-        debug(28, 2) ("authenticateAuthenticate: DUPLICATE AUTH - authentication header on already authenticated connection!. AU %p, Current user '%s' proxy_auth %s\n", conn->auth_user_request, conn->auth_user_request->username(), proxy_auth);
-        /* remove this request struct - the link is already authed and it can't be to
-         * reauth.
-         */
-
-        /* This should _only_ ever occur on the first pass through
-         * authenticateAuthenticate 
-         */
-        assert(*auth_user_request == NULL);
-        /* unlock the conn lock on the auth_user_request */
-        conn->auth_user_request->unlock();
-        /* mark the conn as non-authed. */
-        conn->auth_user_request = NULL;
-        /* Set the connection auth type */
-        conn->auth_type = AUTH_UNKNOWN;
-    }
-
-    /* we have a proxy auth header and as far as we know this connection has
-     * not had bungled connection oriented authentication happen on it. */
-    debug(28, 9) ("authenticateAuthenticate: header %s.\n", proxy_auth ? proxy_auth : "-");
-
-    if (*auth_user_request == NULL)
-    {
-        debug(28, 9) ("authenticateAuthenticate: This is a new checklist test on FD:%d\n",
-                      conn.getRaw() != NULL ? conn->fd : -1);
-
-        if ((!request->auth_user_request)
-                && (conn.getRaw() == NULL || conn->auth_type == AUTH_UNKNOWN)) {
-            /* beginning of a new request check */
-            debug(28, 4) ("authenticateAuthenticate: no connection authentication type\n");
-
-            if (!authenticateValidateUser(*auth_user_request =
-                                              createAuthUser(proxy_auth))) {
-                /* the decode might have left a username for logging, or a message to
-                 * the user */
-
-                if ((*auth_user_request)->username()) {
-                    /* lock the user for the request structure link */
-
-                    (*auth_user_request)->lock()
-
-                    ;
-                    request->auth_user_request = *auth_user_request;
-                }
-
-                /* unlock the ACL reference granted by ...createAuthUser. */
-                (*auth_user_request)->unlock();
-
-                *auth_user_request = NULL;
-
-                return AUTH_ACL_CHALLENGE;
-            }
-
-            /* the user_request comes prelocked for the caller to createAuthUser (us) */
-        } else if (request->auth_user_request) {
-            *auth_user_request = request->auth_user_request;
-            /* lock the user request for this ACL processing */
-
-            (*auth_user_request)->lock()
-
-            ;
-        } else {
-            assert (conn.getRaw() != NULL);
-
-            if (conn->auth_user_request != NULL) {
-                *auth_user_request = conn->auth_user_request;
-                /* lock the user request for this ACL processing */
-
-                (*auth_user_request)->lock()
-
-                ;
-            } else {
-                /* failed connection based authentication */
-                debug(28, 4) ("authenticateAuthenticate: Auth user request %p conn-auth user request %p conn type %d authentication failed.\n",
-                              *auth_user_request, conn->auth_user_request, conn->auth_type);
-                (*auth_user_request)->unlock();
-                *auth_user_request = NULL;
-                return AUTH_ACL_CHALLENGE;
-            }
-        }
-    }
-
-    if (!authenticateUserAuthenticated(*auth_user_request))
-    {
-        /* User not logged in. Log them in */
-        authenticateAuthenticateUser(*auth_user_request, request,
-                                     conn, headertype);
-
-        switch (authenticateDirection(*auth_user_request)) {
-
-        case 1:
-
-            if (!request->auth_user_request) {
-
-                (*auth_user_request)->lock()
-
-                ;
-                request->auth_user_request = *auth_user_request;
-            }
-
-            /* fallthrough to -2 */
-
-        case -2:
-            /* this ACL check is finished. Unlock. */
-            (*auth_user_request)->unlock();
-
-            *auth_user_request = NULL;
-
-            return AUTH_ACL_CHALLENGE;
-
-        case -1:
-            /* we are partway through authentication within squid,
-             * the *auth_user_request variables stores the auth_user_request
-             * for the callback to here - Do not Unlock */
-            return AUTH_ACL_HELPER;
-        }
-
-        /* on 0 the authentication is finished - fallthrough */
-        /* See if user authentication failed for some reason */
-        if (!authenticateUserAuthenticated(*auth_user_request)) {
-            if ((*auth_user_request)->username()) {
-                if (!request->auth_user_request) {
-                    /* lock the user for the request structure link */
-
-                    (*auth_user_request)->lock()
-
-                    ;
-                    request->auth_user_request = *auth_user_request;
-                }
-            }
-
-            /* this ACL check is finished. Unlock. */
-            (*auth_user_request)->unlock();
-
-            *auth_user_request = NULL;
-
-            return AUTH_ACL_CHALLENGE;
-        }
-    }
-
-    /* copy username to request for logging on client-side */
-    /* the credentials are correct at this point */
-    if (!request->auth_user_request)
-    {
-        /* lock the user for the request structure link */
-
-        (*auth_user_request)->lock()
-
-        ;
-        request->auth_user_request = *auth_user_request;
-
-        authenticateAuthUserRequestSetIp(*auth_user_request, src_addr);
-    }
-
-    /* Unlock the request - we've authenticated it */
-    (*auth_user_request)->unlock();
-
-    return AUTH_AUTHENTICATED;
-}
-
-auth_acl_t
-
-AuthUserRequest::tryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr)
-{
-    /* If we have already been called, return the cached value */
-    auth_user_request_t *t = authTryGetUser (auth_user_request, conn, request);
-
-    if (t && t->lastReply != AUTH_ACL_CANNOT_AUTHENTICATE
-            && t->lastReply != AUTH_ACL_HELPER)
-    {
-        if (!*auth_user_request)
-            *auth_user_request = t;
-
-        return t->lastReply;
-    }
-
-    /* ok, call the actual authenticator routine. */
-    auth_acl_t result = authenticate(auth_user_request, headertype, request, conn, src_addr);
-
-    t = authTryGetUser (auth_user_request, conn, request);
-
-    if (t && result != AUTH_ACL_CANNOT_AUTHENTICATE &&
-            result != AUTH_ACL_HELPER)
-        t->lastReply = result;
-
-    return result;
-}
-
-auth_acl_t
-
-authenticateTryToAuthenticateAndSetAuthUser(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr)
-{
-    return AuthUserRequest::tryToAuthenticateAndSetAuthUser (auth_user_request, headertype,request, conn, src_addr);
-}
-
-/* authenticateUserRequestUsername: return a pointer to the username in the */
-char const *
-authenticateUserRequestUsername(auth_user_request_t * auth_user_request)
-{
-    assert(auth_user_request != NULL);
-    return auth_user_request->username();
-}
-
-/* returns
- * 0: no output needed
- * 1: send to client
- * -1: send to helper
- * -2: authenticate broken in some fashion
- */
-int
-authenticateDirection(auth_user_request_t * auth_user_request)
-{
-    if (!auth_user_request)
-        return -2;
-
-    if (authenticateUserAuthenticated(auth_user_request))
-        return 0;
-
-    if (auth_user_request->auth_user->auth_module > 0) {
-        if (authscheme_list[auth_user_request->auth_user->auth_module - 1].getdirection)
-            return authscheme_list[auth_user_request->auth_user->auth_module - 1].getdirection(auth_user_request);
-        else {
-            assert (auth_user_request->state());
-            return auth_user_request->state()->direction();
-        }
-    }
-
-    return -2;
-}
-
 int
 authenticateActiveSchemeCount(void)
 {
-    int i = 0, rv = 0;
+    int rv = 0;
 
-    for (i = 0; authscheme_list && authscheme_list[i].typestr; i++)
-        if (authscheme_list[i].configured())
-            rv++;
+    for (authConfig::iterator i = Config.authConfiguration.begin(); i != Config.authConfiguration.end(); ++i)
+        if ((*i)->configured())
+            ++rv;
 
     debug(29, 9) ("authenticateActiveSchemeCount: %d active.\n", rv);
 
@@ -881,34 +74,21 @@ authenticateActiveSchemeCount(void)
 int
 authenticateSchemeCount(void)
 {
-    int i = 0, rv = 0;
-
-    for (i = 0; authscheme_list && authscheme_list[i].typestr; i++)
-        rv++;
+    int rv = AuthScheme::Schemes().size();
 
     debug(29, 9) ("authenticateSchemeCount: %d active.\n", rv);
 
     return rv;
 }
 
-void
-authenticateSchemeInit(void)
-{
-    authSchemeSetup();
-}
-
 void
 authenticateInit(authConfig * config)
 {
-    int i;
-    authScheme *scheme;
-
-    for (i = 0; i < config->n_configured; i++) {
-        scheme = config->schemes + i;
+    for (authConfig::iterator i = config->begin(); i != config->end(); ++i) {
+        AuthConfig *scheme = *i;
 
-        if (authscheme_list[scheme->Id].init && authscheme_list[scheme->Id].configured()) {
-            authscheme_list[scheme->Id].init(scheme);
-        }
+        if (scheme->configured())
+            scheme->init(scheme);
     }
 
     if (!proxy_auth_username_cache)
@@ -920,178 +100,18 @@ authenticateInit(authConfig * config)
 void
 authenticateShutdown(void)
 {
-    int i;
     debug(29, 2) ("authenticateShutdown: shutting down auth schemes\n");
     /* free the cache if we are shutting down */
 
-    if (shutting_down)
+    if (shutting_down) {
         hashFreeItems(proxy_auth_username_cache, AuthUserHashPointer::removeFromCache);
-
-    /* find the currently known authscheme types */
-    for (i = 0; authscheme_list && authscheme_list[i].typestr; i++) {
-        if (authscheme_list[i].donefunc != NULL)
-            authscheme_list[i].donefunc();
-        else
-            debug(29, 2) ("authenticateShutdown: scheme %s has not registered a shutdown function.\n", authscheme_list[i].typestr);
-
-        if (shutting_down)
-            authscheme_list[i].typestr = NULL;
-    }
-}
-
-void
-AuthUserRequest::addReplyAuthHeader(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated, int internal)
-/* send the auth types we are configured to support (and have compiled in!) */
-{
-    http_hdr_type type;
-
-    switch (rep->sline.status)
-    {
-
-    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
-        /* Proxy authorisation needed */
-        type = HDR_PROXY_AUTHENTICATE;
-        break;
-
-    case HTTP_UNAUTHORIZED:
-        /* WWW Authorisation needed */
-        type = HDR_WWW_AUTHENTICATE;
-        break;
-
-    default:
-        /* Keep GCC happy */
-        /* some other HTTP status */
-        type = HDR_ENUM_END;
-        break;
-    }
-
-    debug(29, 9) ("authenticateFixHeader: headertype:%d authuser:%p\n", type, auth_user_request);
-
-    if (((rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (rep->sline.status == HTTP_UNAUTHORIZED)) && internal)
-        /* this is a authenticate-needed response */
-    {
-
-        if ((auth_user_request != NULL) && (auth_user_request->auth_user->auth_module > 0) & !authenticateUserAuthenticated(auth_user_request))
-            authscheme_list[auth_user_request->auth_user->auth_module - 1].authFixHeader(auth_user_request, rep, type, request);
-        else
-        {
-            int i;
-            authScheme *scheme;
-            /* call each configured & running authscheme */
-
-            for (i = 0; i < Config.authConfiguration.n_configured; i++) {
-                scheme = Config.authConfiguration.schemes + i;
-
-                if (authscheme_list[scheme->Id].Active())
-                    authscheme_list[scheme->Id].authFixHeader(NULL, rep, type,
-                            request);
-                else
-                    debug(29, 4) ("authenticateFixHeader: Configured scheme %s not Active\n", scheme->typestr);
-            }
-        }
-
-    }
-    /*
-     * allow protocol specific headers to be _added_ to the existing
-     * response - ie digest auth
-     */
-
-    if (auth_user_request != NULL && auth_user_request->state())
-        auth_user_request->state()->addHeader (rep, accelerated);
-
-    if (auth_user_request != NULL)
-        auth_user_request->lastReply = AUTH_ACL_CANNOT_AUTHENTICATE;
-}
-
-void
-authenticateFixHeader(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated, int internal)
-{
-    AuthUserRequest::addReplyAuthHeader(rep, auth_user_request, request, accelerated, internal);
-}
-
-
-/* call the active auth module and allow it to add a trailer to the request */
-void
-authenticateAddTrailer(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated)
-{
-    if ((auth_user_request != NULL) && (auth_user_request->auth_user->auth_module > 0)
-            && (authscheme_list[auth_user_request->auth_user->auth_module - 1].AddTrailer))
-        authscheme_list[auth_user_request->auth_user->auth_module - 1].AddTrailer(auth_user_request, rep, accelerated);
-}
-
-void
-authenticateAuthUserLock(auth_user_t * auth_user)
-{
-    debug(29, 9) ("authenticateAuthUserLock auth_user '%p'.\n", auth_user);
-    assert(auth_user != NULL);
-    auth_user->references++;
-    debug(29, 9) ("authenticateAuthUserLock auth_user '%p' now at '%ld'.\n", auth_user, (long int) auth_user->references);
-}
-
-void
-authenticateAuthUserUnlock(auth_user_t * auth_user)
-{
-    debug(29, 9) ("authenticateAuthUserUnlock auth_user '%p'.\n", auth_user);
-    assert(auth_user != NULL);
-
-    if (auth_user->references > 0) {
-        auth_user->references--;
-    } else {
-        debug(29, 1) ("Attempt to lower Auth User %p refcount below 0!\n", auth_user);
-    }
-
-    debug(29, 9) ("authenticateAuthUserUnlock auth_user '%p' now at '%ld'.\n", auth_user, (long int) auth_user->references);
-
-    if (auth_user->references == 0)
-        delete auth_user;
-}
-
-void
-
-AuthUserRequest::lock()
-{
-    debug(29, 9) ("AuthUserRequest::lock: auth_user request '%p'.\n", this);
-    assert(this != NULL);
-    ++references;
-    debug(29, 9) ("AuthUserRequest::lock: auth_user request '%p' now at '%ld'.\n", this, (long int) references);
-}
-
-void
-AuthUserRequest::unlock()
-{
-    debug(29, 9) ("AuthUserRequest::unlock: auth_user request '%p'.\n", this);
-    assert(this != NULL);
-
-    if (references > 0) {
-        --references;
+        AuthScheme::FreeAll();
     } else {
-        debug(29, 1) ("Attempt to lower Auth User request %p refcount below 0!\n", this);
+        for (AuthScheme::const_iterator i = AuthScheme::Schemes().begin(); i != AuthScheme::Schemes().end(); ++i)
+            (*i)->done();
     }
-
-    debug(29, 9) ("AuthUserRequest::unlock: auth_user_request '%p' now at '%ld'.\n", this, (long int) references);
-
-    if (references == 0)
-        /* not locked anymore */
-        delete this;
 }
 
-void
-authenticateAuthUserRequestLock(auth_user_request_t * auth_user_request)
-{
-
-    auth_user_request->lock()
-
-    ;
-}
-
-void
-authenticateAuthUserRequestUnlock(auth_user_request_t * auth_user_request)
-{
-    auth_user_request->unlock();
-}
-
-
 int
 authenticateAuthUserInuse(auth_user_t * auth_user)
 /* returns 0 for not in use */
@@ -1100,170 +120,12 @@ authenticateAuthUserInuse(auth_user_t * auth_user)
     return auth_user->references;
 }
 
-/* Combine two user structs. ONLY to be called from within a scheme
- * module. The scheme module is responsible for ensuring that the
- * two users _can_ be merged without invalidating all the request
- * scheme data. The scheme is also responsible for merging any user
- * related scheme data itself.
- */
-void
-AuthUser::absorb (AuthUser *from)
-{
-    auth_user_request_t *auth_user_request;
-    /*
-     * XXX combine two authuser structs. Incomplete: it should merge
-     * in hash references too and ask the module to merge in scheme
-     * data
-     */
-    debug(29, 5) ("authenticateAuthUserMerge auth_user '%p' into auth_user '%p'.\n", from, this);
-    dlink_node *link = from->requests.head;
-
-    while (link) {
-        auth_user_request = static_cast<auth_user_request_t *>(link->data);
-        dlink_node *tmplink = link;
-        link = link->next;
-        dlinkDelete(tmplink, &from->requests);
-        dlinkAddTail(auth_user_request, tmplink, &requests);
-        auth_user_request->auth_user = this;
-    }
-
-    references += from->references;
-    from->references = 0;
-    delete from;
-}
-
 void
 authenticateAuthUserMerge(auth_user_t * from, auth_user_t * to)
 {
     to->absorb (from);
 }
 
-void
-AuthUser::operator delete (void *address)
-{
-    memPoolFree(pool, address);
-}
-
-AuthUser::~AuthUser()
-{
-    auth_user_request_t *auth_user_request;
-    dlink_node *link, *tmplink;
-    debug(29, 5) ("AuthUser::~AuthUser: Freeing auth_user '%p' with refcount '%ld'.\n", this, (long int) references);
-    assert(references == 0);
-    /* were they linked in by username ? */
-
-    if (usernamehash) {
-        assert(usernamehash->user() == this);
-        debug(29, 5) ("AuthUser::~AuthUser: removing usernamehash entry '%p'\n", usernamehash);
-        hash_remove_link(proxy_auth_username_cache,
-                         (hash_link *) usernamehash);
-        /* don't free the key as we use the same user string as the auth_user
-         * structure */
-        delete usernamehash;
-    }
-
-    /* remove any outstanding requests */
-    link = requests.head;
-
-    while (link) {
-        debug(29, 5) ("AuthUser::~AuthUser: removing request entry '%p'\n", link->data);
-        auth_user_request = static_cast<auth_user_request_t *>(link->data);
-        tmplink = link;
-        link = link->next;
-        dlinkDelete(tmplink, &requests);
-        dlinkNodeDelete(tmplink);
-        delete auth_user_request;
-    }
-
-    /* free cached acl results */
-    aclCacheMatchFlush(&proxy_match_cache);
-
-    /* free seen ip address's */
-    authenticateAuthUserClearIp(this);
-
-    if (scheme_data && auth_module > 0)
-        authscheme_list[auth_module - 1].FreeUser(this);
-
-    /* prevent accidental reuse */
-    auth_type = AUTH_UNKNOWN;
-}
-
-void
-AuthUser::cacheInit(void)
-{
-    if (!proxy_auth_username_cache) {
-        /* First time around, 7921 should be big enough */
-        proxy_auth_username_cache =
-            hash_create((HASHCMP *) strcmp, 7921, hash_string);
-        assert(proxy_auth_username_cache);
-        eventAdd("User Cache Maintenance", cacheCleanup, NULL, Config.authenticateGCInterval, 1);
-    }
-}
-
-void
-AuthUser::CachedACLsReset()
-{
-    /*
-     * We walk the hash by username as that is the unique key we use.
-     * This must complete all at once, because we are ensuring correctness.
-     */
-    AuthUserHashPointer *usernamehash;
-    auth_user_t *auth_user;
-    char const *username = NULL;
-    debug(29, 3) ("AuthUser::CachedACLsReset: Flushing the ACL caches for all users.\n");
-    hash_first(proxy_auth_username_cache);
-
-    while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
-        auth_user = usernamehash->user();
-        username = auth_user->username();
-        /* free cached acl results */
-        aclCacheMatchFlush(&auth_user->proxy_match_cache);
-
-    }
-
-    debug(29, 3) ("AuthUser::CachedACLsReset: Finished.\n");
-}
-
-void
-AuthUser::cacheCleanup(void *datanotused)
-{
-    /*
-     * We walk the hash by username as that is the unique key we use.
-     * For big hashs we could consider stepping through the cache, 100/200
-     * entries at a time. Lets see how it flys first.
-     */
-    AuthUserHashPointer *usernamehash;
-    auth_user_t *auth_user;
-    char const *username = NULL;
-    debug(29, 3) ("AuthUser::cacheCleanup: Cleaning the user cache now\n");
-    debug(29, 3) ("AuthUser::cacheCleanup: Current time: %ld\n", (long int) current_time.tv_sec);
-    hash_first(proxy_auth_username_cache);
-
-    while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
-        auth_user = usernamehash->user();
-        username = auth_user->username();
-
-        /* if we need to have inpedendent expiry clauses, insert a module call
-         * here */
-        debug(29, 4) ("AuthUser::cacheCleanup: Cache entry:\n\tType: %d\n\tUsername: %s\n\texpires: %ld\n\treferences: %ld\n", auth_user->auth_type, username, (long int) (auth_user->expiretime + Config.authenticateTTL), (long int) auth_user->references);
-
-        if (auth_user->expiretime + Config.authenticateTTL <= current_time.tv_sec) {
-            debug(29, 5) ("AuthUser::cacheCleanup: Removing user %s from cache due to timeout.\n", username);
-            /* the minus 1 accounts for the cache lock */
-
-            if (!(authenticateAuthUserInuse(auth_user) - 1))
-                /* we don't warn if we leave the user in the cache,
-                 * because other modules (ie delay pools) may keep
-                 * locks on users, and thats legitimate
-                 */
-                authenticateAuthUserUnlock(auth_user);
-        }
-    }
-
-    debug(29, 3) ("AuthUser::cacheCleanup: Finished cleaning the user cache.\n");
-    eventAdd("User Cache Maintenance", cacheCleanup, NULL, Config.authenticateGCInterval, 1);
-}
-
 /*
  * authenticateUserCacheRestart() cleans all config-dependent data from the 
  * auth_user cache. It DOES NOT Flush the user cache.
@@ -1284,33 +146,6 @@ authenticateUserCacheRestart(void)
 
 }
 
-/*
- * called to add another auth scheme module
- */
-void
-authSchemeAdd(const char *type, AUTHSSETUP * setup)
-{
-    int i;
-    debug(29, 4) ("authSchemeAdd: adding %s\n", type);
-    /* find the number of currently known authscheme types */
-
-    for (i = 0; authscheme_list && authscheme_list[i].typestr; i++) {
-        assert(strcmp(authscheme_list[i].typestr, type) != 0);
-    }
-
-    /* add the new type */
-    authscheme_list = static_cast<authscheme_entry_t *>(xrealloc(authscheme_list, (i + 2) * sizeof(authscheme_entry_t)));
-
-    memset(&authscheme_list[i], 0, sizeof(authscheme_entry_t));
-
-    memset(&authscheme_list[i + 1], 0, sizeof(authscheme_entry_t));
-
-    authscheme_list[i].typestr = type;
-
-    /* Call the scheme module to set up capabilities and initialize any global data */
-    setup(&authscheme_list[i]);
-}
-
 /* _auth_user_hash_pointe */
 
 void
@@ -1322,7 +157,7 @@ AuthUserHashPointer::removeFromCache(void *usernamehash_p)
     if ((authenticateAuthUserInuse(auth_user) - 1))
         debug(29, 1) ("AuthUserHashPointer::removeFromCache: entry in use - not freeing\n");
 
-    authenticateAuthUserUnlock(auth_user);
+    auth_user->unlock();
 
     /* TODO: change behaviour - we remove from the auth user list here, and then unlock, and the
      * delete ourselves.
@@ -1353,7 +188,10 @@ AuthUserHashPointer::AuthUserHashPointer (auth_user_t * anAuth_user):
     next = NULL;
     hash_join(proxy_auth_username_cache, (hash_link *) this);
     /* lock for presence in the cache */
-    authenticateAuthUserLock(auth_user);
+
+    auth_user->lock()
+
+    ;
 }
 
 AuthUser *
@@ -1362,29 +200,4 @@ AuthUserHashPointer::user() const
     return auth_user;
 }
 
-/* C bindings */
-/* UserNameCacheAdd: add a auth_user structure to the username cache */
-void
-authenticateUserNameCacheAdd(auth_user_t * auth_user)
-{
-    auth_user->usernamehash = new AuthUserHashPointer (auth_user);
-}
-
-auth_user_t*
-authUserHashPointerUser (auth_user_hash_pointer *aHashEntry)
-{
-    return aHashEntry->user();
-}
-
-void *
-AuthUserRequestState::operator new (size_t)
-{
-    fatal ("unusable\n");
-    return (void *)1;
-}
 
-void
-AuthUserRequestState::operator delete (void *)
-{
-    fatal ("unusable\n");
-}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.h,v 1.13 2003/08/10 11:00:42 robertc Exp $
+ * $Id: authenticate.h,v 1.14 2004/08/30 03:28:58 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -57,248 +57,26 @@ struct AuthUserHashPointer : public hash_link
     AuthUser *auth_user;
 };
 
-struct AuthUserIP
-{
-    dlink_node node;
-    /* IP addr this user authenticated from */
-
-    struct in_addr ipaddr;
-    time_t ip_expiretime;
-};
-
-class AuthUser
-{
-
-public:
-    /* extra fields for proxy_auth */
-    /* this determines what scheme owns the user data. */
-    auth_type_t auth_type;
-    /* the index +1 in the authscheme_list to the authscheme entry */
-    int auth_module;
-    /* we only have one username associated with a given auth_user struct */
-    auth_user_hash_pointer *usernamehash;
-    /* we may have many proxy-authenticate strings that decode to the same user */
-    dlink_list proxy_auth_list;
-    dlink_list proxy_match_cache;
-    /* what ip addresses has this user been seen at?, plus a list length cache */
-    dlink_list ip_list;
-    size_t ipcount;
-    long expiretime;
-    /* how many references are outstanding to this instance */
-    size_t references;
-    /* the auth scheme has it's own private data area */
-    void *scheme_data;
-    /* the auth_user_request structures that link to this. Yes it could be a splaytree
-     * but how many requests will a single username have in parallel? */
-    dlink_list requests;
-
-public:
-    static void cacheInit ();
-    static void CachedACLsReset();
-
-    void absorb(auth_user_t *from);
-    AuthUser (const char *);
-    ~AuthUser ();
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
-    char const *username() const;
-
-private:
-    static void cacheCleanup (void *unused);
-    static MemPool *pool;
-};
-
-/* Per scheme request data ABC */
-
 class ConnStateData;
 
-class AuthUserRequestState
-{
-
-public:
-    void *operator new (size_t);
-    void operator delete (void *);
-    virtual ~AuthUserRequestState(){}
-
-    virtual int authenticated() const = 0;
-    virtual void authenticate(HttpRequest * request, ConnStateData::Pointer conn, http_hdr_type type) = 0;
-    virtual int direction() = 0;
-    virtual void addHeader(HttpReply * rep, int accel) {}}
-
-;
-
-class AuthUserRequest
-{
-
-public:
-    /* this is the object passed around by client_side and acl functions */
-    /* it has request specific data, and links to user specific data */
-    /* the user */
-    auth_user_t *auth_user;
-    AuthUserRequestState *state() const { return state_;}
-
-    void state( AuthUserRequestState *aState) {assert ((!state() && aState) || (state() && !aState)); state_ = aState;}
-
-public:
-
-    static auth_acl_t tryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, HttpRequest *, ConnStateData::Pointer, struct in_addr);
-    static void addReplyAuthHeader(HttpReply * rep, auth_user_request_t * auth_user_request, HttpRequest * request, int accelerated, int internal);
-
-    ~AuthUserRequest();
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
-    void start ( RH * handler, void *data);
-    void setDenyMessage (char const *);
-    char const * getDenyMessage ();
-    size_t refCount() const;
-
-    void lock ()
-
-        ;
-    void unlock ();
-
-    char const *username() const;
-
-private:
-
-    static auth_acl_t authenticate(auth_user_request_t ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData::Pointer conn, struct in_addr src_addr);
-
-    static auth_user_request_t *createAuthUser (const char *proxy_auth);
-
-    static MemPool *pool;
-
-    AuthUserRequest();
-
-    void decodeAuth (const char *proxy_auth);
-
-    /* return a message on the 407 error pages */
-    char *message;
-
-    /* how many 'processes' are working on this data */
-    size_t references;
-
-    /* We only attempt authentication once per http request. This
-     * is to allow multiple auth acl references from different _access areas
-     * when using connection based authentication
-     */
-    auth_acl_t lastReply;
-
-    AuthUserRequestState *state_;
-};
+class AuthScheme;
 
 /* authenticate.c authenticate scheme routines typedefs */
-typedef int AUTHSACTIVE(void);
-typedef int AUTHSAUTHED(auth_user_request_t *);
-typedef void AUTHSAUTHUSER(auth_user_request_t *, HttpRequest *, ConnStateData::Pointer, http_hdr_type);
-typedef int AUTHSCONFIGURED(void);
-typedef void AUTHSDECODE(auth_user_request_t *, const char *);
-typedef int AUTHSDIRECTION(auth_user_request_t *);
-typedef void AUTHSDUMP(StoreEntry *, const char *, authScheme *);
-typedef void AUTHSFIXERR(auth_user_request_t *, HttpReply *, http_hdr_type, HttpRequest *);
-typedef void AUTHSADDTRAILER(auth_user_request_t *, HttpReply *, int);
-typedef void AUTHSFREE(auth_user_t *);
-typedef void AUTHSFREECONFIG(authScheme *);
-typedef char const *AUTHSUSERNAME(auth_user_t const *);
-typedef void AUTHSONCLOSEC(ConnStateData *);
-typedef void AUTHSPARSE(authScheme *, int, char *);
-typedef void AUTHSINIT(authScheme *);
-typedef void AUTHSREQFREE(auth_user_request_t *);
-typedef void AUTHSSETUP(authscheme_entry_t *);
-typedef void AUTHSSHUTDOWN(void);
-typedef void AUTHSSTART(auth_user_request_t *, RH *, void *);
+/* TODO: this should be a generic cachemgr API type ? */
 typedef void AUTHSSTATS(StoreEntry *);
-typedef const char *AUTHSCONNLASTHEADER(auth_user_request_t *);
 
 /* subsumed by the C++ interface */
 extern void authenticateAuthUserMerge(auth_user_t *, auth_user_t *);
-extern auth_user_t *authenticateAuthUserNew(const char *);
-
-/* AuthUserRequest */
-extern void authenticateStart(auth_user_request_t *, RH *, void *);
 
-extern auth_acl_t authenticateTryToAuthenticateAndSetAuthUser(auth_user_request_t **, http_hdr_type, HttpRequest *, ConnStateData::Pointer, struct in_addr);
-extern void authenticateSetDenyMessage (auth_user_request_t *, char const *);
-extern size_t authenticateRequestRefCount (auth_user_request_t *);
-extern char const *authenticateAuthUserRequestMessage(auth_user_request_t *);
-
-extern int authenticateAuthSchemeId(const char *typestr);
-extern void authenticateSchemeInit(void);
 extern void authenticateInit(authConfig *);
 extern void authenticateShutdown(void);
-extern void authenticateFixHeader(HttpReply *, auth_user_request_t *, HttpRequest *, int, int);
-extern void authenticateAddTrailer(HttpReply *, auth_user_request_t *, HttpRequest *, int);
-extern void authenticateAuthUserUnlock(auth_user_t * auth_user);
-extern void authenticateAuthUserLock(auth_user_t * auth_user);
-extern void authenticateAuthUserRequestUnlock(auth_user_request_t *);
-extern void authenticateAuthUserRequestLock(auth_user_request_t *);
 extern int authenticateAuthUserInuse(auth_user_t * auth_user);
 
-extern void authenticateAuthUserRequestRemoveIp(auth_user_request_t *, struct in_addr);
-extern void authenticateAuthUserRequestClearIp(auth_user_request_t *);
-extern size_t authenticateAuthUserRequestIPCount(auth_user_request_t *);
-extern int authenticateDirection(auth_user_request_t *);
 extern void authenticateFreeProxyAuthUserACLResults(void *data);
 extern int authenticateActiveSchemeCount(void);
 extern int authenticateSchemeCount(void);
-extern void authenticateUserNameCacheAdd(auth_user_t * auth_user);
 
-extern int authenticateCheckAuthUserIP(struct in_addr request_src_addr, auth_user_request_t * auth_user);
-extern int authenticateUserAuthenticated(auth_user_request_t *);
 extern void authenticateUserCacheRestart(void);
-extern char const *authenticateUserRequestUsername(auth_user_request_t *);
-extern int authenticateValidateUser(auth_user_request_t *);
 extern void authenticateOnCloseConnection(ConnStateData * conn);
-extern void authSchemeAdd(const char *type, AUTHSSETUP * setup);
-
-/* AuthUserHashPointer */
-extern auth_user_t* authUserHashPointerUser(auth_user_hash_pointer *);
-
-/* auth_modules.c */
-SQUIDCEXTERN void authSchemeSetup(void);
-
-/*
- * This defines an auth scheme module
- */
-
-struct _authscheme_entry
-{
-    const char *typestr;
-    AUTHSACTIVE *Active;
-    AUTHSADDTRAILER *AddTrailer;
-    AUTHSAUTHED *authenticated;
-    AUTHSAUTHUSER *authAuthenticate;
-    AUTHSCONFIGURED *configured;
-    AUTHSDUMP *dump;
-    AUTHSFIXERR *authFixHeader;
-    AUTHSFREE *FreeUser;
-    AUTHSFREECONFIG *freeconfig;
-    AUTHSUSERNAME *authUserUsername;
-    AUTHSONCLOSEC *oncloseconnection;   /*optional */
-    AUTHSCONNLASTHEADER *authConnLastHeader;
-    AUTHSDECODE *decodeauth;
-    AUTHSDIRECTION *getdirection;
-    AUTHSPARSE *parse;
-    AUTHSINIT *init;
-    AUTHSREQFREE *requestFree;
-    AUTHSSHUTDOWN *donefunc;
-    AUTHSSTART *authStart;
-    AUTHSSTATS *authStats;
-};
-
-/*
- * This is a configured auth scheme
- */
-
-/* private data types */
-
-struct _authScheme
-{
-    /* pointer to the authscheme_list's string entry */
-    const char *typestr;
-    /* the scheme id in the authscheme_list */
-    int Id;
-    /* the scheme's configuration details. */
-    void *scheme_data;
-};
 
 #endif /* SQUID_AUTHENTICATE_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.453 2004/04/29 23:54:54 hno Exp $
+ * $Id: cache_cf.cc,v 1.454 2004/08/30 03:28:58 robertc Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -35,6 +35,8 @@
 
 #include "squid.h"
 #include "authenticate.h"
+#include "AuthConfig.h"
+#include "AuthScheme.h"
 #include "Store.h"
 #include "SwapDir.h"
 #include "ConfigParser.h"
@@ -48,6 +50,8 @@
 #include "ESIParser.h"
 #endif
 
+CBDATA_TYPE(peer);
+
 static const char *const T_SECOND_STR = "second";
 static const char *const T_MINUTE_STR = "minute";
 static const char *const T_HOUR_STR = "hour";
@@ -536,6 +540,8 @@ configDoConfigure(void)
         if (Config.Wais._peer)
             cbdataFree(Config.Wais._peer);
 
+        CBDATA_INIT_TYPE_FREECB(peer, peerDestroy);
+
         Config.Wais._peer = cbdataAlloc(peer);
 
         Config.Wais._peer->host = xstrdup(Config.Wais.relayHost);
@@ -1226,91 +1232,58 @@ check_null_string(char *s)
     return s == NULL;
 }
 
-static void
-allocate_new_authScheme(authConfig * cfg)
-{
-    if (cfg->schemes == NULL) {
-        cfg->n_allocated = 4;
-        cfg->schemes = static_cast<authScheme *>(xcalloc(cfg->n_allocated, sizeof(authScheme)));
-    }
-
-    if (cfg->n_allocated == cfg->n_configured) {
-        authScheme *tmp;
-        cfg->n_allocated <<= 1;
-        tmp = static_cast<authScheme *>(xcalloc(cfg->n_allocated, sizeof(authScheme)));
-        xmemcpy(tmp, cfg->schemes, cfg->n_configured * sizeof(authScheme));
-        xfree(cfg->schemes);
-        cfg->schemes = tmp;
-    }
-}
-
 static void
 parse_authparam(authConfig * config)
 {
     char *type_str;
     char *param_str;
-    authScheme *scheme = NULL;
-    int type, i;
 
     if ((type_str = strtok(NULL, w_space)) == NULL)
         self_destruct();
 
     if ((param_str = strtok(NULL, w_space)) == NULL)
         self_destruct();
 
-    if ((type = authenticateAuthSchemeId(type_str)) == -1) {
-        debug(3, 0) ("Parsing Config File: Unknown authentication scheme '%s'.\n", type_str);
-        return;
-    }
+    /* find a configuration for the scheme */
+    AuthConfig *scheme = AuthConfig::Find (type_str);
 
-    for (i = 0; i < config->n_configured; i++) {
-        if (config->schemes[i].Id == type) {
-            scheme = config->schemes + i;
+    if (scheme == NULL) {
+        /* Create a configuration */
+        AuthScheme *theScheme;
+
+        if ((theScheme = AuthScheme::Find(type_str)) == NULL) {
+            debug(3, 0) ("Parsing Config File: Unknown authentication scheme '%s'.\n", type_str);
+            return;
         }
-    }
 
-    if (scheme == NULL) {
-        allocate_new_authScheme(config);
-        scheme = config->schemes + config->n_configured;
-        config->n_configured++;
-        scheme->Id = type;
-        scheme->typestr = authscheme_list[type].typestr;
+        config->push_back(theScheme->createConfig());
+        scheme = config->back();
+        assert (scheme);
     }
 
-    authscheme_list[type].parse(scheme, config->n_configured, param_str);
+    scheme->parse(scheme, config->size(), param_str);
 }
 
 static void
 free_authparam(authConfig * cfg)
 {
-    authScheme *scheme;
-    int i;
+    AuthConfig *scheme;
     /* DON'T FREE THESE FOR RECONFIGURE */
 
     if (reconfiguring)
         return;
 
-    for (i = 0; i < cfg->n_configured; i++) {
-        scheme = cfg->schemes + i;
-        authscheme_list[scheme->Id].freeconfig(scheme);
+    while (cfg->size()) {
+        scheme = cfg->pop_back();
+        scheme->done();
     }
-
-    safe_free(cfg->schemes);
-    cfg->schemes = NULL;
-    cfg->n_allocated = 0;
-    cfg->n_configured = 0;
 }
 
 static void
 dump_authparam(StoreEntry * entry, const char *name, authConfig cfg)
 {
-    authScheme *scheme;
-    int i;
-
-    for (i = 0; i < cfg.n_configured; i++) {
-        scheme = cfg.schemes + i;
-        authscheme_list[scheme->Id].dump(entry, name, scheme);
-    }
+    for (authConfig::iterator  i = cfg.begin(); i != cfg.end(); ++i)
+        (*i)->dump(entry, name, (*i));
 }
 
 void
@@ -1501,6 +1474,7 @@ parse_peer(peer ** head)
     char *token = NULL;
     peer *p;
     int i;
+    CBDATA_INIT_TYPE_FREECB(peer, peerDestroy);
     p = cbdataAlloc(peer);
     p->http_port = CACHE_HTTP_PORT;
     p->icp.port = CACHE_ICP_PORT;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cbdata.cc,v 1.62 2003/10/16 21:40:16 robertc Exp $
+ * $Id: cbdata.cc,v 1.63 2004/08/30 03:28:58 robertc Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * ORIGINAL AUTHOR: Duane Wessels
@@ -245,7 +245,6 @@ cbdataInit(void)
     CREATE_CBDATA(helper_server);
     CREATE_CBDATA(statefulhelper);
     CREATE_CBDATA(helper_stateful_server);
-    CREATE_CBDATA_FREE(peer, peerDestroy);
     CREATE_CBDATA(ps_state);
     CREATE_CBDATA(RemovalPolicy);
     CREATE_CBDATA(RemovalPolicyWalker);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.670 2004/04/04 23:21:53 hno Exp $
+ * $Id: client_side.cc,v 1.671 2004/08/30 03:28:58 robertc Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -59,7 +59,7 @@
 #include "client_side.h"
 #include "clientStream.h"
 #include "IPInterception.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "Store.h"
 #include "comm.h"
 #include "HttpReply.h"
@@ -466,15 +466,15 @@ clientPrepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogE
     aLogEntry->cache.extuser = request->extacl_user.buf();
 
     if (request->auth_user_request) {
-        if (authenticateUserRequestUsername(request->auth_user_request))
+
+        if (request->auth_user_request->username())
             aLogEntry->cache.authuser =
-                xstrdup(authenticateUserRequestUsername(request->auth_user_request));
+                xstrdup(request->auth_user_request->username());
 
-        authenticateAuthUserRequestUnlock(request->auth_user_request);
+        request->auth_user_request->unlock();
 
         request->auth_user_request = NULL;
     }
-
 }
 
 void
@@ -597,7 +597,9 @@ ConnStateData::close()
     clientdbEstablished(peer.sin_addr, -1);	/* decrement */
     assert(areAllContextsForThisConnection());
     freeAllContexts();
-    authenticateOnCloseConnection(this);
+
+    if (auth_user_request != NULL)
+        auth_user_request->onConnectionClose(this);
 }
 
 bool
@@ -615,7 +617,7 @@ ConnStateData::~ConnStateData()
         close();
 
     if (auth_user_request)
-        authenticateAuthUserRequestUnlock(auth_user_request);
+        auth_user_request->unlock();
 
     auth_user_request = NULL;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_reply.cc,v 1.69 2004/04/04 13:52:42 hno Exp $
+ * $Id: client_side_reply.cc,v 1.70 2004/08/30 03:28:58 robertc Exp $
  *
  * DEBUG: section 88    Client-side Reply Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -41,7 +41,7 @@
 #include "HttpRequest.h"
 
 #include "clientStream.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #if ESI
 #include "ESI.h"
 #endif
@@ -108,7 +108,10 @@ clientReplyContext::setReplyToError(
     if (auth_user_request)
     {
         errstate->auth_user_request = auth_user_request;
-        authenticateAuthUserRequestLock(errstate->auth_user_request);
+
+        errstate->auth_user_request->lock()
+
+        ;
     }
 
     assert(errstate->callback_data == NULL);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_request.cc,v 1.36 2004/04/07 08:51:31 hno Exp $
+ * $Id: client_side_request.cc,v 1.37 2004/08/30 03:28:58 robertc Exp $
  * 
  * DEBUG: section 85    Client-side Request Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -44,7 +44,7 @@
 #include "squid.h"
 #include "clientStream.h"
 #include "client_side_request.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "HttpRequest.h"
 #include "ACLChecklist.h"
 #include "ACL.h"
@@ -379,14 +379,16 @@ clientAccessCheckDone(int answer, void *data)
     clientHttpRequest *http = context->http;
     err_type page_id;
     http_status status;
-    char const *proxy_auth_msg = NULL;
     debug(85, 2) ("The request %s %s is %s, because it matched '%s'\n",
                   RequestMethodStr[http->request->method], http->uri,
                   answer == ACCESS_ALLOWED ? "ALLOWED" : "DENIED",
                   AclMatchedName ? AclMatchedName : "NO ACL's");
-    proxy_auth_msg = authenticateAuthUserRequestMessage((http->getConn().getRaw() != NULL
-                     && http->getConn()->auth_user_request) ? http->getConn()->
-                     auth_user_request : http->request->auth_user_request);
+    char const *proxy_auth_msg = "<null>";
+
+    if (http->getConn().getRaw() != NULL && http->getConn()->auth_user_request != NULL)
+        proxy_auth_msg = http->getConn()->auth_user_request->denyMessage("<null>");
+    else if (http->request->auth_user_request != NULL)
+        proxy_auth_msg = http->request->auth_user_request->denyMessage("<null>");
 
     if (answer == ACCESS_ALLOWED) {
         safe_free(http->uri);
@@ -753,7 +755,10 @@ clientRedirectDone(void *data, char *result)
 
         if (old_request->auth_user_request) {
             new_request->auth_user_request = old_request->auth_user_request;
-            authenticateAuthUserRequestLock(new_request->auth_user_request);
+
+            new_request->auth_user_request->lock()
+
+            ;
         }
 
         if (old_request->body_connection.getRaw() != NULL) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.234 2003/07/15 20:45:45 wessels Exp $
+ * $Id: enums.h,v 1.235 2004/08/30 03:28:59 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -661,7 +661,6 @@ typedef enum {
     CBDATA_helper_server,
     CBDATA_statefulhelper,
     CBDATA_helper_stateful_server,
-    CBDATA_peer,
     CBDATA_ps_state,
     CBDATA_RemovalPolicy,
     CBDATA_RemovalPolicyWalker,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.195 2004/08/05 20:09:59 hno Exp $
+ * $Id: errorpage.cc,v 1.196 2004/08/30 03:28:59 robertc Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -41,7 +41,7 @@
  */
 
 #include "squid.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "Store.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -470,7 +470,7 @@ errorStateFree(ErrorState * err)
     safe_free(err->ftp.reply);
 
     if (err->auth_user_request)
-        authenticateAuthUserRequestUnlock(err->auth_user_request);
+        err->auth_user_request->unlock();
 
     err->auth_user_request = NULL;
 
@@ -501,9 +501,8 @@ errorDump(ErrorState * err, MemBuf * mb)
         memBufPrintf(&str, "Err: [none]\r\n");
     }
 
-    if (authenticateAuthUserRequestMessage(err->auth_user_request)) {
-        memBufPrintf(&str, "extAuth ErrMsg: %s\r\n", authenticateAuthUserRequestMessage(err->auth_user_request));
-    }
+    if (err->auth_user_request->denyMessage())
+        memBufPrintf(&str, "Auth ErrMsg: %s\r\n", err->auth_user_request->denyMessage());
 
     if (err->dnsserver_msg) {
         memBufPrintf(&str, "DNS Server ErrMsg: %s\r\n", err->dnsserver_msg);
@@ -679,7 +678,7 @@ errorConvert(char token, ErrorState * err)
         break;
 
     case 'm':
-        p = authenticateAuthUserRequestMessage(err->auth_user_request) ? authenticateAuthUserRequestMessage(err->auth_user_request) : "[not available]";
+        p = err->auth_user_request->denyMessage("[not available]");
 
         break;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: external_acl.cc,v 1.56 2004/08/14 21:15:16 hno Exp $
+ * $Id: external_acl.cc,v 1.57 2004/08/30 03:28:59 robertc Exp $
  *
  * DEBUG: section 82    External ACL
  * AUTHOR: Henrik Nordstrom, MARA Systems AB
@@ -43,7 +43,7 @@
 #include "squid.h"
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "Store.h"
 #include "fde.h"
 #include "ACLChecklist.h"
@@ -710,7 +710,8 @@ makeExternalAclKey(ACLChecklist * ch, external_acl_data * acl_data)
         switch (format->type) {
 
         case _external_acl_format::EXT_ACL_LOGIN:
-            str = authenticateUserRequestUsername(ch->auth_user_request);
+            assert (ch->auth_user_request);
+            str = ch->auth_user_request->username();
             break;
 #if USE_IDENT
 
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -16,7 +16,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.47 2003/08/14 23:31:51 robertc Exp $
+#  $Id: Makefile.in,v 1.48 2004/08/30 03:29:02 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -317,7 +317,7 @@ LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(libaufs_a_SOURCES) $(libcoss_a_SOURCES) \
 	$(libdiskd_a_SOURCES) $(libnull_a_SOURCES) $(libufs_a_SOURCES) \
 	$(diskd_diskd_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(libaufs_a_SOURCES) $(libcoss_a_SOURCES) $(libdiskd_a_SOURCES) $(libnull_a_SOURCES) $(libufs_a_SOURCES) $(diskd_diskd_SOURCES)
 
 all: all-am
@@ -461,9 +461,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@ufs/$(DEPDIR)/store_dir_ufs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ufs/$(DEPDIR)/store_io_ufs.Po@am__quote@
 
-distclean-depend:
-	-rm -rf aufs/$(DEPDIR) coss/$(DEPDIR) diskd/$(DEPDIR) null/$(DEPDIR) ufs/$(DEPDIR)
-
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCXX_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -821,7 +818,6 @@ all-am: Makefile $(LIBRARIES) $(PROGRAMS)
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libexecdir)
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -833,25 +829,25 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
-	-rm -f ufs/$(am__dirstamp)
+	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f aufs/$(DEPDIR)/$(am__dirstamp)
 	-rm -f diskd/$(am__dirstamp)
-	-rm -f aufs/$(am__dirstamp)
 	-rm -f coss/$(DEPDIR)/$(am__dirstamp)
-	-rm -f null/$(DEPDIR)/$(am__dirstamp)
 	-rm -f coss/$(am__dirstamp)
+	-rm -f null/$(DEPDIR)/$(am__dirstamp)
 	-rm -f ufs/$(DEPDIR)/$(am__dirstamp)
+	-rm -f ufs/$(am__dirstamp)
+	-rm -f aufs/$(am__dirstamp)
 	-rm -f null/$(am__dirstamp)
 	-rm -f diskd/$(DEPDIR)/$(am__dirstamp)
-	-rm -f aufs/$(DEPDIR)/$(am__dirstamp)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -862,9 +858,10 @@ clean-am: clean-generic clean-libexecPROGRAMS clean-noinstLIBRARIES \
 	mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf aufs/$(DEPDIR) coss/$(DEPDIR) diskd/$(DEPDIR) null/$(DEPDIR) ufs/$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -885,7 +882,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf aufs/$(DEPDIR) coss/$(DEPDIR) diskd/$(DEPDIR) null/$(DEPDIR) ufs/$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -904,15 +902,15 @@ uninstall-am: uninstall-info-am uninstall-libexecPROGRAMS
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libexecPROGRAMS clean-noinstLIBRARIES ctags distclean \
-	distclean-compile distclean-depend distclean-generic \
-	distclean-tags distdir dvi dvi-am info info-am install \
-	install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am \
-	install-libexecPROGRAMS install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am uninstall-libexecPROGRAMS
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-libexecPROGRAMS install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-libexecPROGRAMS
 
 
 aufs/all: libaufs.a
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.126 2003/07/22 15:23:02 robertc Exp $
+ * $Id: globals.h,v 1.127 2004/08/30 03:28:59 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -147,7 +147,6 @@ extern int refresh_nocache_hack;	/* 0 */
 #endif
 extern int store_open_disk_fd;	/* 0 */
 extern const char *SwapDirType[];
-extern authscheme_entry_t *authscheme_list;	/* NULL */
 extern storerepl_entry_t *storerepl_list;	/* NULL */
 extern int store_swap_low;	/* 0 */
 extern int store_swap_high;	/* 0 */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.430 2004/04/03 14:17:36 hno Exp $
+ * $Id: http.cc,v 1.431 2004/08/30 03:28:59 robertc Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -40,7 +40,7 @@
 
 #include "squid.h"
 #include "http.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "Store.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -1273,7 +1273,7 @@ httpBuildRequestHeader(HttpRequest * request,
             const char *username = "-";
 
             if (orig_request->auth_user_request)
-                username = authenticateUserRequestUsername(orig_request->auth_user_request);
+                username = orig_request->auth_user_request->username();
             else if (orig_request->extacl_user.size())
                 username = orig_request->extacl_user.buf();
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.391 2004/04/04 13:48:32 hno Exp $
+ * $Id: main.cc,v 1.392 2004/08/30 03:28:59 robertc Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -990,8 +990,6 @@ main(int argc, char **argv)
         /* Shouldn't be needed for config parsing, but have not audited for such */
         StoreFileSystem::SetupAllFs();
 
-        authenticateSchemeInit();	/* required for config parsign */
-
         parse_err = parseConfigFile(ConfigFile);
 
         if (opt_parse_cfg_only)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.105 2004/04/07 08:51:31 hno Exp $
+ * $Id: redirect.cc,v 1.106 2004/08/30 03:28:59 robertc Exp $
  *
  * DEBUG: section 61    Redirector
  * AUTHOR: Duane Wessels
@@ -34,7 +34,7 @@
  */
 
 #include "squid.h"
-#include "authenticate.h"
+#include "AuthUserRequest.h"
 #include "Store.h"
 #include "client_side_request.h"
 #include "ACLChecklist.h"
@@ -153,7 +153,7 @@ redirectStart(clientHttpRequest * http, RH * handler, void *data)
     r->client_addr = conn.getRaw() != NULL ? conn->log_addr : no_addr;
 
     if (http->request->auth_user_request)
-        r->client_ident = authenticateUserRequestUsername(http->request->auth_user_request);
+        r->client_ident = http->request->auth_user_request->username();
     else if (conn.getRaw() != NULL && conn->rfc931[0]) {
         r->client_ident = conn->rfc931;
     } else {
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -16,7 +16,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.42 2003/07/23 00:14:54 hno Exp $
+#  $Id: Makefile.in,v 1.43 2004/08/30 03:29:02 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -256,7 +256,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(libheap_a_SOURCES) $(liblru_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(libheap_a_SOURCES) $(liblru_a_SOURCES)
 
 all: all-am
@@ -311,9 +311,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@heap/$(DEPDIR)/store_repl_heap.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@lru/$(DEPDIR)/store_repl_lru.Po@am__quote@
 
-distclean-depend:
-	-rm -rf heap/$(DEPDIR) lru/$(DEPDIR)
-
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCXX_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -493,7 +490,6 @@ check: check-am
 all-am: Makefile $(LIBRARIES)
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -505,19 +501,19 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f heap/$(DEPDIR)/$(am__dirstamp)
 	-rm -f heap/$(am__dirstamp)
 	-rm -f lru/$(DEPDIR)/$(am__dirstamp)
 	-rm -f lru/$(am__dirstamp)
-	-rm -f heap/$(DEPDIR)/$(am__dirstamp)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -527,9 +523,10 @@ clean: clean-am
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf heap/$(DEPDIR) lru/$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -550,7 +547,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf heap/$(DEPDIR) lru/$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -569,14 +567,13 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-depend distclean-generic distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
+	ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.487 2004/04/04 23:17:48 hno Exp $
+ * $Id: structs.h,v 1.488 2004/08/30 03:28:59 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -206,13 +206,6 @@ struct _https_port_list
 #include "DelayConfig.h"
 #endif
 
-struct _authConfig
-{
-    authScheme *schemes;
-    int n_allocated;
-    int n_configured;
-};
-
 struct _RemovalPolicySettings
 {
     char *type;
@@ -0,0 +1,60 @@
+/*
+ * $Id: stub_HttpRequest.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 28    Access Control
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+HttpRequest *
+requestCreate(method_t method, protocol_t protocol, const char *aUrlpath)
+{
+    fatal("Not implemented");
+    return NULL;
+}
+
+HttpRequest *
+requestLink(HttpRequest * request)
+{
+    fatal("Not implemented");
+    return NULL;
+}
+
+void
+requestUnlink(HttpRequest * request)
+{
+    fatal("Not implemented");
+}
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: dd894aa8-63cc-4543-92d9-1079a18bee11
+ */
@@ -0,0 +1,40 @@
+/*
+ * $Id: stub_acl.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 28    Access Control
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: 09fd4b9f-d9f5-4566-9ec2-c72a57e116dd
+ */
@@ -0,0 +1,128 @@
+/*
+ * $Id: stub_cache_cf.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 3     Configuration File Parsing
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+void
+self_destruct(void)
+{
+    /*    fatalf("Bungled %s line %d: %s",
+               cfg_filename, config_lineno, config_input_line);*/
+    fatalf("bungled line");
+}
+
+void
+parse_int(int *var)
+{
+    fatal("not implemented 1");
+}
+
+void
+parse_onoff(int *var)
+{
+    fatal("not implemented 2");
+}
+
+void
+parse_eol(char *volatile *var)
+{
+    unsigned char *token = (unsigned char *) strtok(NULL, null_string);
+    safe_free(*var);
+
+    if (token == NULL)
+        self_destruct();
+
+    while (*token && isspace(*token))
+        token++;
+
+    if (!*token)
+        self_destruct();
+
+    *var = xstrdup((char *) token);
+}
+
+void
+parse_wordlist(wordlist ** list)
+{
+    char *token;
+    char *t = strtok(NULL, "");
+
+    while ((token = strwordtok(NULL, &t)))
+        wordlistAdd(list, token);
+}
+
+void
+requirePathnameExists(const char *name, const char *path)
+{
+    /* tee-hee. ignore this for testing  */
+}
+
+void
+parse_time_t(time_t * var)
+{
+    fatal("not implemented 6");
+}
+
+const char *
+wordlistAdd(wordlist ** list, const char *key)
+{
+    while (*list)
+        list = &(*list)->next;
+
+    *list = static_cast<wordlist *>(memAllocate(MEM_WORDLIST));
+
+    (*list)->key = xstrdup(key);
+
+    (*list)->next = NULL;
+
+    return (*list)->key;
+}
+
+void
+wordlistDestroy(wordlist ** list)
+{
+    fatal("not implemented 8");
+}
+
+char *
+strtokFile(void)
+{
+    fatal("not implemented 9");
+    return NULL;
+}
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: 9bbc3b5f-8d7b-4fdc-af59-0b524a785307
+ */
@@ -0,0 +1,44 @@
+/*
+ * $Id: stub_cache_manager.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 16    Cache Manager Objects
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+void
+cachemgrRegister(const char *action, const char *desc, OBJH * handler, int pw_req_flag, int atomic)
+{}
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: 4b6d624e-0e69-415f-bb92-f5991db65dd3
+ */
@@ -0,0 +1,47 @@
+/*
+ * $Id: stub_errorpage.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 28    Access Control
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+err_type
+errorReservePageId(const char *page_name)
+{
+    fatal("Not implemented");
+    return err_type();
+}
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: e4c72cfd-0b31-4497-90e6-0e3cda3b92b4
+ */
@@ -0,0 +1,138 @@
+/*
+ * $Id: stub_helper.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 84    Helper process maintenance
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+void
+helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
+{
+    fatal("Not implemented");
+}
+
+void
+helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPSCB * callback, void *data, helper_stateful_server * lastserver)
+{
+    fatal("Not implemented");
+}
+
+void
+helperStatefulFree(statefulhelper * hlp)
+{
+    fatal("Not implemented");
+}
+
+void
+helperFree(helper * hlp)
+{
+    fatal("Not implemented");
+}
+
+helper *
+helperCreate(const char *name)
+{
+    helper *hlp;
+    hlp = cbdataAlloc(helper);
+    hlp->id_name = name;
+    return hlp;
+}
+
+void
+helperStats(StoreEntry * sentry, helper * hlp)
+{
+    fatal("Not implemented");
+}
+
+void
+helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp)
+{
+    fatal("Not implemented");
+}
+
+void
+helperShutdown(helper * hlp)
+{
+    fatal("Not implemented");
+}
+
+void
+helperStatefulShutdown(statefulhelper * hlp)
+{
+    fatal("Not implemented");
+}
+
+void
+helperOpenServers(helper * hlp)
+{
+    debugs(84,4,"Not implemented");
+}
+
+void
+helperStatefulOpenServers(statefulhelper * hlp)
+{
+    debugs(84,4,"Not implemented");
+}
+
+void *
+helperStatefulServerGetData(helper_stateful_server * srv)
+{
+    fatal("Not implemented");
+    return NULL;
+}
+
+helper_stateful_server *
+helperStatefulDefer(statefulhelper * hlp)
+{
+    fatal("Not implemented");
+    return NULL;
+}
+
+void
+helperStatefulReleaseServer(helper_stateful_server * srv)
+{
+    fatal("Not implemented");
+}
+
+statefulhelper *
+helperStatefulCreate(const char *name)
+{
+    statefulhelper *hlp;
+    hlp = cbdataAlloc(statefulhelper);
+    hlp->id_name = name;
+    return hlp;
+}
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: 0b5fe2ac-1652-4b77-8788-85ded78ad3bb
+ */
@@ -0,0 +1,40 @@
+/*
+ * $Id: stub_stat.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 18    Cache Manager Statistics
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: 910d285d-c514-4592-adac-1f079ca734ab
+ */
@@ -0,0 +1,75 @@
+/*
+ * $Id: stub_store.cc,v 1.1 2004/08/30 03:29:02 robertc Exp $
+ *
+ * DEBUG: section 20    Storage Manager
+ * AUTHOR: Robert Collins
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+extern "C" void
+#if STDC_HEADERS
+    storeAppendPrintf(StoreEntry * e, const char *fmt,...)
+#else
+    storeAppendPrintf(va_alist)
+    va_dcl
+#endif
+{
+    fatal("Not implemented");
+}
+
+extern "C" void
+    storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
+{
+    fatal("Not implemented");
+}
+
+extern "C" void
+    storeBuffer(StoreEntry * e)
+{
+    fatal("Not implemented");
+}
+
+extern "C" void
+    storeBufferFlush(StoreEntry * e)
+{
+    fatal("Not implemented");
+}
+
+extern "C" void
+    storeAppend(StoreEntry * e, const char *buf, int len)
+{
+    fatal("Not implemented");
+}
+
+/*
+ * DO NOT MODIFY:
+ * arch-tag: f6d5bdd6-882b-4988-80d2-de26b759f4b9
+ */
@@ -0,0 +1,234 @@
+#include "config.h"
+
+#include "testAuth.h"
+#include "squid.h"
+#include "authenticate.h"
+#include "AuthUserRequest.h"
+#include "AuthScheme.h"
+#include "AuthConfig.h"
+#include "Mem.h"
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testAuth );
+CPPUNIT_TEST_SUITE_REGISTRATION( testAuthConfig );
+CPPUNIT_TEST_SUITE_REGISTRATION( testAuthUserRequest );
+CPPUNIT_TEST_SUITE_REGISTRATION( testAuthBasicUserRequest );
+CPPUNIT_TEST_SUITE_REGISTRATION( testAuthDigestUserRequest );
+CPPUNIT_TEST_SUITE_REGISTRATION( testAuthNTLMUserRequest );
+
+/* Instantiate all auth framework types */
+void
+testAuth::instantiate()
+{}
+
+char const * stub_config="auth_param digest program /home/robertc/install/squid/libexec/digest_pw_auth /home/robertc/install/squid/etc/digest.pwd\n"
+                         "auth_param digest children 5\n"
+                         "auth_param digest realm Squid proxy-caching web server\n"
+                         "auth_param digest nonce_garbage_interval 5 minutes\n"
+                         "auth_param digest nonce_max_duration 30 minutes\n"
+                         "auth_param digest nonce_max_count 50\n";
+
+static
+char const *
+find_proxy_auth(char const *type)
+{
+    char const * proxy_auths[][2]= { {"basic","Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="},
+
+                                     {"digest", "Digest username=\"robertdig\", realm=\"Squid proxy-caching web server\", nonce=\"yy8rQXjEWwixXVBj\", uri=\"/images/bg8.gif\", response=\"f75a7d3edd48d93c681c75dc4fb58700\", qop=auth, nc=00000012, cnonce=\"e2216641961e228e\" "},
+                                     {"ntlm", "NTLM "}
+                                   };
+
+    for (unsigned count = 0; count < 3 ; count++) {
+        if (strcasecmp(type, proxy_auths[count][0]) == 0)
+            return proxy_auths[count][1];
+    }
+
+    return NULL;
+}
+
+static
+AuthConfig *
+getConfig(char const *type_str)
+{
+    Vector<AuthConfig *> &config = Config.authConfiguration;
+    /* find a configuration for the scheme */
+    AuthConfig *scheme = AuthConfig::Find (type_str);
+
+    if (scheme == NULL) {
+        /* Create a configuration */
+        AuthScheme *theScheme;
+
+        if ((theScheme = AuthScheme::Find(type_str)) == NULL) {
+            fatalf("Unknown authentication scheme '%s'.\n", type_str);
+        }
+
+        config.push_back(theScheme->createConfig());
+        scheme = config.back();
+        assert (scheme);
+    }
+
+    return scheme;
+}
+
+static
+void
+setup_scheme(AuthConfig *scheme, char const **params, unsigned param_count)
+{
+    Vector<AuthConfig *> &config = Config.authConfiguration;
+
+    for (unsigned position=0; position < param_count; position++) {
+        char *param_str=xstrdup(params[position]);
+        strtok(param_str, w_space);
+        scheme->parse(scheme, config.size(), param_str);
+    }
+}
+
+static
+void
+fake_auth_setup()
+{
+    static bool setup(false);
+
+    if (setup)
+        return;
+
+    Mem::Init();
+
+    cbdataInit();
+
+    eventInit();
+
+    Vector<AuthConfig *> &config = Config.authConfiguration;
+
+    char const *digest_parms[]= {"program /home/robertc/install/squid/libexec/digest_pw_auth /home/robertc/install/squid/etc/digest.pwd",
+                                 "realm foo"
+                                };
+
+    char const *basic_parms[]= {"program /home/robertc/install/squid/libexec/digest_pw_auth /home/robertc/install/squid/etc/digest.pwd",
+                                "realm foo"
+                               };
+
+    char const *ntlm_parms[]= {"program /home/robertc/install/squid/libexec/digest_pw_auth /home/robertc/install/squid/etc/digest.pwd"};
+
+    struct _scheme_params {
+        char const *name;
+        char const **params;
+        unsigned paramlength;
+    }
+
+    params[]={ {"digest", digest_parms, 2},
+               {"basic", basic_parms, 2},
+               {"ntlm", ntlm_parms, 1}};
+
+    for (unsigned scheme=0; scheme < 3; scheme++)
+        setup_scheme(getConfig(params[scheme].name), params[scheme].params, params[scheme].paramlength);
+
+    authenticateInit(&config);
+
+    setup=true;
+}
+
+/* AuthConfig::CreateAuthUser works for all
+ * authentication types
+ */
+void
+testAuthConfig::create()
+{
+    Debug::Levels[29]=9;
+    fake_auth_setup();
+
+    for (AuthScheme::const_iterator i = AuthScheme::Schemes().begin(); i != AuthScheme::Schemes().end(); ++i) {
+        AuthUserRequest *authRequest = AuthConfig::CreateAuthUser(find_proxy_auth((*i)->type()));
+        CPPUNIT_ASSERT(authRequest != NULL);
+    }
+}
+
+#include <iostream>
+
+/* AuthUserRequest::scheme returns the correct scheme for all
+ * authentication types
+ */
+void
+testAuthUserRequest::scheme()
+{
+    Debug::Levels[29]=9;
+    fake_auth_setup();
+
+    for (AuthScheme::const_iterator i = AuthScheme::Schemes().begin(); i != AuthScheme::Schemes().end(); ++i) {
+        // create a user request
+        // check its scheme matches *i
+        AuthUserRequest *authRequest = AuthConfig::CreateAuthUser(find_proxy_auth((*i)->type()));
+        CPPUNIT_ASSERT_EQUAL(authRequest->scheme(), *i);
+    }
+}
+
+#include "auth/basic/auth_basic.h"
+/* AuthBasicUserRequest::AuthBasicUserRequest works
+ */
+void
+testAuthBasicUserRequest::construction()
+{
+    AuthBasicUserRequest();
+    AuthBasicUserRequest *temp=new AuthBasicUserRequest();
+    delete temp;
+}
+
+void
+testAuthBasicUserRequest::username()
+{
+    AuthBasicUserRequest();
+    AuthBasicUserRequest *temp=new AuthBasicUserRequest();
+    BasicUser *basic_auth=new BasicUser(AuthConfig::Find("basic"));
+    basic_auth->username("John");
+    temp->user(basic_auth);
+    basic_auth->addRequest(temp);
+    CPPUNIT_ASSERT_EQUAL(0, strcmp("John", temp->username()));
+    delete temp;
+}
+
+#include "auth/digest/auth_digest.h"
+/* AuthDigestUserRequest::AuthDigestUserRequest works
+ */
+void
+testAuthDigestUserRequest::construction()
+{
+    AuthDigestUserRequest();
+    AuthDigestUserRequest *temp=new AuthDigestUserRequest();
+    delete temp;
+}
+
+void
+testAuthDigestUserRequest::username()
+{
+    AuthDigestUserRequest();
+    AuthDigestUserRequest *temp=new AuthDigestUserRequest();
+    DigestUser *user=new DigestUser(AuthConfig::Find("digest"));
+    user->username("John");
+    temp->user(user);
+    user->addRequest(temp);
+    CPPUNIT_ASSERT_EQUAL(0, strcmp("John", temp->username()));
+    delete temp;
+}
+
+#include "auth/ntlm/auth_ntlm.h"
+/* AuthNTLMUserRequest::AuthNTLMUserRequest works
+ */
+void
+testAuthNTLMUserRequest::construction()
+{
+    AuthNTLMUserRequest();
+    AuthNTLMUserRequest *temp=new AuthNTLMUserRequest();
+    delete temp;
+}
+
+void
+testAuthNTLMUserRequest::username()
+{
+    AuthNTLMUserRequest();
+    AuthNTLMUserRequest *temp=new AuthNTLMUserRequest();
+    NTLMUser *user=new NTLMUser(AuthConfig::Find("ntlm"));
+    user->username("John");
+    temp->user(user);
+    user->addRequest(temp);
+    CPPUNIT_ASSERT_EQUAL(0, strcmp("John", temp->username()));
+    delete temp;
+}
@@ -0,0 +1,91 @@
+
+#ifndef SQUID_SRC_TEST_AUTH_H
+#define SQUID_SRC_TEST_AUTH_H
+
+#include <cppunit/extensions/HelperMacros.h>
+
+/*
+ * test the auth Config framework
+ */
+
+class testAuth : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testAuth );
+    CPPUNIT_TEST( instantiate );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+    void instantiate();
+};
+
+class testAuthConfig : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testAuthConfig );
+    CPPUNIT_TEST( create );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+    void create();
+};
+
+class testAuthUserRequest : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testAuthUserRequest );
+    CPPUNIT_TEST( scheme );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+    void scheme();
+    void construction();
+};
+
+class testAuthBasicUserRequest : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testAuthBasicUserRequest );
+    CPPUNIT_TEST( construction );
+    CPPUNIT_TEST( username );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+    void construction();
+    void username();
+};
+
+class testAuthDigestUserRequest : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testAuthDigestUserRequest );
+    CPPUNIT_TEST( construction );
+    CPPUNIT_TEST( username );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+    void construction();
+    void username();
+};
+
+class testAuthNTLMUserRequest : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testAuthNTLMUserRequest );
+    CPPUNIT_TEST( construction );
+    CPPUNIT_TEST( username );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+
+protected:
+    void construction();
+    void username();
+};
+
+#endif
+
@@ -0,0 +1,38 @@
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/TextTestProgressListener.h>
+#include <cppunit/CompilerOutputter.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/TestRunner.h>
+
+
+int
+main( int argc, char* argv[] )
+{
+    // Create the event manager and test controller
+    CPPUNIT_NS::TestResult controller;
+
+    // Add a listener that colllects test result
+    CPPUNIT_NS::TestResultCollector result;
+    controller.addListener( &result );
+
+    // Add a listener that print dots as test run.
+    // use BriefTestProgressListener to get names of each test
+    // even when they pass.
+    CPPUNIT_NS::TextTestProgressListener progress;
+    controller.addListener( &progress );
+
+    // Add the top suite to the test runner
+    CPPUNIT_NS::TestRunner runner;
+    runner.addTest( CPPUNIT_NS::TestFactoryRegistry::getRegistry().makeTest() );
+    runner.run( controller );
+
+    // Print test in a compiler compatible format.
+    CPPUNIT_NS::CompilerOutputter outputter( &result, std::cerr );
+    outputter.write();
+
+    return result.wasSuccessful() ? 0 : 1;
+}
+
+
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.241 2004/08/14 21:15:16 hno Exp $
+ * $Id: tools.cc,v 1.242 2004/08/30 03:28:59 robertc Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -1070,12 +1070,6 @@ debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm)
     memBufClean(&mb);
 }
 
-int
-stringHasWhitespace(const char *s)
-{
-    return strpbrk(s, w_space) != NULL;
-}
-
 void
 linklistPush(link_list ** L, void *p)
 {
@@ -1134,22 +1128,6 @@ xrename(const char *from, const char *to)
     return -1;
 }
 
-int
-stringHasCntl(const char *s)
-{
-    unsigned char c;
-
-    while ((c = (unsigned char) *s++) != '\0') {
-        if (c <= 0x1f)
-            return 1;
-
-        if (c >= 0x7f && c <= 0x9f)
-            return 1;
-    }
-
-    return 0;
-}
-
 void
 parseEtcHosts(void)
 {
@@ -1260,90 +1238,6 @@ getMyPort(void)
     return 0;			/* NOT REACHED */
 }
 
-/*
- * Similar to strtok, but has some rudimentary knowledge
- * of quoting
- */
-char *
-strwordtok(char *buf, char **t)
-{
-    unsigned char *word = NULL;
-    unsigned char *p = (unsigned char *) buf;
-    unsigned char *d;
-    unsigned char ch;
-    int quoted = 0;
-
-    if (!p)
-        p = (unsigned char *) *t;
-
-    if (!p)
-        goto error;
-
-    while (*p && isspace(*p))
-        p++;
-
-    if (!*p)
-        goto error;
-
-    word = d = p;
-
-    while ((ch = *p)) {
-        switch (ch) {
-
-        case '\\':
-            p++;
-
-            switch (*p) {
-
-            case 'n':
-                ch = '\n';
-
-                break;
-
-            case 'r':
-                ch = '\r';
-
-                break;
-
-            default:
-                ch = *p;
-
-                break;
-
-            }
-
-            *d++ = ch;
-
-            if (ch)
-                p++;
-
-            break;
-
-        case '"':
-            quoted = !quoted;
-
-            p++;
-
-            break;
-
-        default:
-            if (!quoted && isspace(*p)) {
-                p++;
-                goto done;
-            }
-
-            *d++ = *p++;
-            break;
-        }
-    }
-
-done:
-    *d++ = '\0';
-
-error:
-    *t = (char *) p;
-    return (char *) word;
-}
 
 /*
  * Inverse of strwordtok. Quotes a word if needed
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.174 2004/04/10 13:10:17 hno Exp $
+ * $Id: typedefs.h,v 1.175 2004/08/30 03:28:59 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -67,9 +67,11 @@ typedef struct AuthUserIP auth_user_ip_t;
 
 typedef struct _acl_proxy_auth_match_cache acl_proxy_auth_match_cache;
 
-typedef struct _authscheme_entry authscheme_entry_t;
+/* temporary: once Config is fully hidden, this shouldn't be needed */
+#include "Array.h"
 
-typedef struct _authScheme authScheme;
+class AuthConfig;
+typedef Vector<AuthConfig *> authConfig;
 
 typedef struct _acl_snmp_comm acl_snmp_comm;
 
@@ -209,8 +211,6 @@ typedef struct _StatCounters StatCounters;
 
 typedef struct _storeSwapLogData storeSwapLogData;
 
-typedef struct _authConfig authConfig;
-
 typedef struct _cacheSwap cacheSwap;
 
 typedef struct _StatHist StatHist;
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.16 2003/07/16 05:27:17 robertc Exp $
+#  $Id: Makefile.am,v 1.17 2004/08/30 03:29:03 robertc Exp $
 #
 
 AUTOMAKE_OPTIONS = subdir-objects
@@ -50,19 +50,16 @@ check_PROGRAMS= debug \
 		syntheticoperators \
 		VirtualDeleteOperator
 
-LDADD = -L$(top_builddir)/lib -lmiscutil
+LDADD =$(top_builddir)/src/globals.o -L$(top_builddir)/lib -lmiscutil
 DEBUG_SOURCE = test_tools.cc
-DEBUG_OBJECTS = $(top_builddir)/src/globals.o
 debug_SOURCES = debug.cc $(DEBUG_SOURCE)
-debug_LDADD = $(DEBUG_OBJECTS) $(LDADD)
 ESIExpressions_SOURCES = ESIExpressions.cc $(DEBUG_SOURCE)
 ESIExpressions_LDADD = $(top_builddir)/src/ESIExpression.o \
-		$(DEBUG_OBJECTS) $(LDADD)
+		$(LDADD)
 mem_node_test_SOURCES = mem_node_test.cc
 mem_node_test_LDADD = $(top_builddir)/src/mem_node.o $(LDADD)
 mem_hdr_test_SOURCES = mem_hdr_test.cc $(DEBUG_SOURCE)
 mem_hdr_test_LDADD = $(top_builddir)/src/stmem.o \
-		     $(DEBUG_OBJECTS) \
 		     $(top_builddir)/src/mem_node.o $(LDADD)
 MemPoolTest_SOURCES = MemPoolTest.cc
 refcount_SOURCES = refcount.cc
@@ -74,12 +71,11 @@ http_range_test_LDADD = $(top_builddir)/src/HttpHdrRange.o \
 		$(top_builddir)/src/Packer.o \
 		$(top_builddir)/src/String.o \
 		$(top_builddir)/src/mem.o \
-		$(DEBUG_OBJECTS) $(LDADD)
+		$(LDADD)
 
 splay_SOURCES = splay.cc
 
 StackTest_SOURCES = StackTest.cc $(DEBUG_SOURCE)
-
 syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
 VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
 
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.4 from Makefile.am.
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -17,7 +17,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.39 2003/07/23 00:14:55 hno Exp $
+#  $Id: Makefile.in,v 1.40 2004/08/30 03:29:03 robertc Exp $
 #
 
 srcdir = @srcdir@
@@ -412,7 +412,7 @@ DIST_SOURCES = $(ESIExpressions_SOURCES) $(MemPoolTest_SOURCES) \
 	$(mem_hdr_test_SOURCES) $(mem_node_test_SOURCES) membanger.c \
 	$(refcount_SOURCES) $(rfc1738_SOURCES) $(splay_SOURCES) \
 	$(syntheticoperators_SOURCES) tcp-banger2.c
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
 SOURCES = $(ESIExpressions_SOURCES) $(MemPoolTest_SOURCES) $(StackTest_SOURCES) $(VirtualDeleteOperator_SOURCES) $(debug_SOURCES) $(http_range_test_SOURCES) $(mem_hdr_test_SOURCES) $(mem_node_test_SOURCES) membanger.c $(refcount_SOURCES) $(rfc1738_SOURCES) $(splay_SOURCES) $(syntheticoperators_SOURCES) tcp-banger2.c
 
 all: all-am
@@ -492,9 +492,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tcp-banger2.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_tools.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
@@ -705,7 +702,6 @@ check: check-am
 all-am: Makefile
 
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -717,15 +713,15 @@ install-am: all-am
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -735,9 +731,10 @@ clean: clean-am
 clean-am: clean-checkPROGRAMS clean-generic mostlyclean-am
 
 distclean: distclean-am
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-am
 
@@ -758,7 +755,8 @@ install-man:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
@@ -777,14 +775,14 @@ uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-TESTS check-am clean \
 	clean-checkPROGRAMS clean-generic ctags distclean \
-	distclean-compile distclean-depend distclean-generic \
-	distclean-tags distdir dvi dvi-am info info-am install \
-	install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am
+	distclean-compile distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
@@ -1,5 +1,5 @@
 /*
- * $Id: MemPoolTest.cc,v 1.1 2003/06/22 08:04:28 robertc Exp $
+ * $Id: MemPoolTest.cc,v 1.2 2004/08/30 03:29:03 robertc Exp $
  *
  * AUTHOR: Robert Collins
  *
@@ -43,7 +43,6 @@ xassert(const char *msg, const char *file, int line)
     std::cout << "Assertion failed: (" << msg << ") at " << file << ":" << line << std::endl;
     exit (1);
 }
-time_t squid_curtime = 0;
 
 class MemPoolTest {
 public:
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem_node_test.cc,v 1.5 2003/08/04 22:14:57 robertc Exp $
+ * $Id: mem_node_test.cc,v 1.6 2004/08/30 03:29:03 robertc Exp $
  *
  * DEBUG: section 19    Store Memory Primitives
  * AUTHOR: Robert Collins
@@ -45,8 +45,6 @@ xassert(const char *msg, const char *file, int line)
     exit (1);
 }
 
-time_t squid_curtime = 0;
-
 int
 main (int argc, char *argv)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: test_tools.cc,v 1.4 2003/07/08 23:10:59 hno Exp $
+ * $Id: test_tools.cc,v 1.5 2004/08/30 03:29:03 robertc Exp $
  *
  * AUTHOR: Robert Collins
  *
@@ -120,6 +120,41 @@ fatal(const char *message) {
     exit (1);
 }
 
+/* used by fatalf */
+static void
+fatalvf(const char *fmt, va_list args) {
+    static char fatal_str[BUFSIZ];
+    vsnprintf(fatal_str, sizeof(fatal_str), fmt, args);
+    fatal(fatal_str);
+}
+
+/* printf-style interface for fatal */
+#if STDC_HEADERS
+void
+fatalf(const char *fmt,...)
+{
+    va_list args;
+    va_start(args, fmt);
+#else
+void
+fatalf(va_alist)
+va_dcl
+{
+    va_list args;
+    const char *fmt = NULL;
+    va_start(args);
+    fmt = va_arg(args, char *);
+#endif
+
+    fatalvf(fmt, args);
+    va_end(args);
+}
+
+void
+debug_trap(const char *message) {
+    fatal(message);
+}
+
 std::ostream &
 Debug::getDebugOut()
 {
@@ -137,3 +172,93 @@ Debug::finishDebug()
 }
 
 std::ostringstream *Debug::CurrentDebug (NULL);
+
+MemPool *dlink_node_pool = NULL;
+
+dlink_node *
+dlinkNodeNew()
+{
+    if (dlink_node_pool == NULL)
+        dlink_node_pool = memPoolCreate("Dlink list nodes", sizeof(dlink_node));
+
+    /* where should we call memPoolDestroy(dlink_node_pool); */
+    return (dlink_node *)memPoolAlloc(dlink_node_pool);
+}
+
+/* the node needs to be unlinked FIRST */
+void
+dlinkNodeDelete(dlink_node * m)
+{
+    if (m == NULL)
+        return;
+
+    memPoolFree(dlink_node_pool, m);
+}
+
+void
+dlinkAdd(void *data, dlink_node * m, dlink_list * list)
+{
+    m->data = data;
+    m->prev = NULL;
+    m->next = list->head;
+
+    if (list->head)
+        list->head->prev = m;
+
+    list->head = m;
+
+    if (list->tail == NULL)
+        list->tail = m;
+}
+
+void
+dlinkAddAfter(void *data, dlink_node * m, dlink_node * n, dlink_list * list)
+{
+    m->data = data;
+    m->prev = n;
+    m->next = n->next;
+
+    if (n->next)
+        n->next->prev = m;
+    else {
+        assert(list->tail == n);
+        list->tail = m;
+    }
+
+    n->next = m;
+}
+
+void
+dlinkAddTail(void *data, dlink_node * m, dlink_list * list)
+{
+    m->data = data;
+    m->next = NULL;
+    m->prev = list->tail;
+
+    if (list->tail)
+        list->tail->next = m;
+
+    list->tail = m;
+
+    if (list->head == NULL)
+        list->head = m;
+}
+
+void
+dlinkDelete(dlink_node * m, dlink_list * list)
+{
+    if (m->next)
+        m->next->prev = m->prev;
+
+    if (m->prev)
+        m->prev->next = m->next;
+
+    if (m == list->head)
+        list->head = m->next;
+
+    if (m == list->tail)
+        list->tail = m->prev;
+
+    m->next = m->prev = NULL;
+}
+