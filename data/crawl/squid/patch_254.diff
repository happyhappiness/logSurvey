@@ -22,6 +22,8 @@
 
 #include "MemPool.h"
 
+#include <stack>
+
 /// \ingroup MemPoolsAPI
 class MemPoolMalloc : public MemImplementingAllocator
 {
@@ -42,7 +44,7 @@ class MemPoolMalloc : public MemImplementingAllocator
     virtual void *allocate();
     virtual void deallocate(void *, bool aggressive);
 private:
-    Stack<void *> freelist;
+    std::stack<void *> freelist;
 };
 
 #endif /* _MEM_POOL_MALLOC_H_ */
@@ -1,67 +0,0 @@
-/*
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#ifndef SQUID_STACK_H
-#define SQUID_STACK_H
-
-#include "base/Vector.h"
-
-/* RBC: 20030714 Composition might be better long-term, but for now,
- * there's no reason to do so.
- */
-
-template <class S = void *>
-
-class Stack : public Vector<S>
-{
-public:
-    using Vector<S>::count;
-    using Vector<S>::items;
-    typedef typename Vector<S>::value_type value_type;
-    typedef typename Vector<S>::pointer pointer;
-    value_type pop() {
-        if (!count)
-            return value_type();
-
-        value_type result = items[--count];
-
-        this->items[count] = value_type();
-
-        return result;
-    }
-
-    /* todo, fatal on empty Top call */
-    value_type top() const {
-        return count ? items[count - 1] : value_type();
-    }
-};
-
-#endif /* SQUID_STACK_H */
@@ -3,7 +3,9 @@
 
 #if defined(__cplusplus)
 
-#include "Stack.h"
+#include "fatal.h"
+
+#include <stack>
 
 template <class V>
 class SplayNode
@@ -402,7 +404,7 @@ class SplayConstIterator
     void advance();
     void addLeftPath(SplayNode<V> *aNode);
     void init(SplayNode<V> *);
-    Stack<SplayNode<V> *> toVisit;
+    std::stack<SplayNode<V> *> toVisit;
 };
 
 template <class V>
@@ -415,7 +417,12 @@ template <class V>
 bool
 SplayConstIterator<V>::operator == (SplayConstIterator const &right) const
 {
-    return toVisit.top() == right.toVisit.top();
+    if (toVisit.empty() && right.toVisit.empty())
+        return true;
+    if (!toVisit.empty() && !right.toVisit.empty())
+        return toVisit.top() == right.toVisit.top();
+    // only one of the two is empty
+    return false;
 }
 
 template <class V>
@@ -447,19 +454,21 @@ template <class V>
 void
 SplayConstIterator<V>::advance()
 {
-    if (toVisit.size() == 0)
+    if (toVisit.empty())
         return;
 
     toVisit.pop();
 
-    if (toVisit.size() == 0)
+    if (toVisit.empty())
         return;
 
-    SplayNode<V> *currentNode = toVisit.pop();
+    // not empty
+    SplayNode<V> *currentNode = toVisit.top();
+    toVisit.pop();
 
     addLeftPath(currentNode->right);
 
-    toVisit.push_back(currentNode);
+    toVisit.push(currentNode);
 }
 
 template <class V>
@@ -470,7 +479,7 @@ SplayConstIterator<V>::addLeftPath(SplayNode<V> *aNode)
         return;
 
     do {
-        toVisit.push_back(aNode);
+        toVisit.push(aNode);
         aNode = aNode->left;
     } while (aNode != NULL);
 }
@@ -46,7 +46,11 @@ extern time_t squid_curtime;
 void *
 MemPoolMalloc::allocate()
 {
-    void *obj = freelist.pop();
+    void *obj = NULL;
+    if (!freelist.empty()) {
+        obj = freelist.top();
+        freelist.pop();
+    }
     if (obj) {
         memMeterDec(meter.idle);
         ++saved_calls;
@@ -72,7 +76,7 @@ MemPoolMalloc::deallocate(void *obj, bool aggressive)
         if (doZero)
             memset(obj, 0, obj_size);
         memMeterInc(meter.idle);
-        freelist.push_back(obj);
+        freelist.push(obj);
     }
 }
 
@@ -122,13 +126,15 @@ MemPoolMalloc::~MemPoolMalloc()
 bool
 MemPoolMalloc::idleTrigger(int shift) const
 {
-    return freelist.count >> (shift ? 8 : 0);
+    return freelist.size() >> (shift ? 8 : 0);
 }
 
 void
 MemPoolMalloc::clean(time_t maxage)
 {
-    while (void *obj = freelist.pop()) {
+    while (!freelist.empty()) {
+        void *obj = freelist.top();
+        freelist.pop();
         memMeterDec(meter.idle);
         memMeterDec(meter.alloc);
         xfree(obj);
@@ -30,7 +30,7 @@ ClientDelayConfig::finalize()
 
 void ClientDelayConfig::freePoolCount()
 {
-    pools.clean();
+    pools.clear();
 }
 
 void ClientDelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
@@ -2,7 +2,8 @@
 #define SQUID_CLIENTDELAYCONFIG_H
 
 #include "acl/forward.h"
-#include "base/Vector.h"
+
+#include <vector>
 
 class StoreEntry;
 class ConfigParser;
@@ -21,7 +22,7 @@ class ClientDelayPool
     int64_t highwatermark;
 };
 
-typedef Vector<ClientDelayPool> ClientDelayPools;
+typedef std::vector<ClientDelayPool> ClientDelayPools;
 
 /* represents configuration of client write limiting delay pools */
 class ClientDelayConfig
@@ -35,7 +35,7 @@
 
 ConfigOptionVector::~ConfigOptionVector()
 {
-    while (options.size()) {
+    while (!options.empty()) {
         delete options.back();
         options.pop_back();
     }
@@ -44,7 +44,7 @@ ConfigOptionVector::~ConfigOptionVector()
 bool
 ConfigOptionVector::parse(char const *option, const char *value, int isaReconfig)
 {
-    Vector<ConfigOption *>::iterator i = options.begin();
+    std::vector<ConfigOption *>::iterator i = options.begin();
 
     while (i != options.end()) {
         if ((*i)->parse(option,value, isaReconfig))
@@ -59,7 +59,7 @@ ConfigOptionVector::parse(char const *option, const char *value, int isaReconfig
 void
 ConfigOptionVector::dump(StoreEntry * e) const
 {
-    for (Vector<ConfigOption *>::const_iterator i = options.begin();
+    for (std::vector<ConfigOption *>::const_iterator i = options.begin();
             i != options.end(); ++i)
         (*i)->dump(e);
 }
@@ -30,7 +30,7 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-#include "base/Vector.h"
+#include <vector>
 
 class StoreEntry;
 
@@ -53,7 +53,7 @@ class ConfigOptionVector : public ConfigOption
     virtual ~ConfigOptionVector();
     virtual bool parse(char const *option, const char *value, int reconfiguring);
     virtual void dump(StoreEntry * e) const;
-    Vector<ConfigOption *>options;
+    std::vector<ConfigOption *>options;
 };
 
 template <class C>
@@ -10,7 +10,7 @@
 #include "Debug.h"
 
 bool
-CpuAffinityMap::add(const Vector<int> &aProcesses, const Vector<int> &aCores)
+CpuAffinityMap::add(const std::vector<int> &aProcesses, const std::vector<int> &aCores)
 {
     if (aProcesses.size() != aCores.size())
         return false;
@@ -4,7 +4,7 @@
 #ifndef SQUID_CPU_AFFINITY_MAP_H
 #define SQUID_CPU_AFFINITY_MAP_H
 
-#include "base/Vector.h"
+#include <vector>
 
 class CpuAffinitySet;
 
@@ -13,20 +13,20 @@ class CpuAffinityMap
 {
 public:
     /// append cpu_affinity_map option
-    bool add(const Vector<int> &aProcesses, const Vector<int> &aCores);
+    bool add(const std::vector<int> &aProcesses, const std::vector<int> &aCores);
 
     /// calculate CPU set for this process
     CpuAffinitySet *calculateSet(const int targetProcess) const;
 
     /// returns list of process numbers
-    const Vector<int> &processes() const { return theProcesses; }
+    const std::vector<int> &processes() const { return theProcesses; }
 
     /// returns list of cores
-    const Vector<int> &cores() const { return theCores; }
+    const std::vector<int> &cores() const { return theCores; }
 
 private:
-    Vector<int> theProcesses; ///< list of process numbers
-    Vector<int> theCores; ///< list of cores
+    std::vector<int> theProcesses; ///< list of process numbers
+    std::vector<int> theCores; ///< list of cores
 };
 
 #endif // SQUID_CPU_AFFINITY_MAP_H
@@ -32,7 +32,7 @@
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
-#include "base/Vector.h"
+#include <vector>
 
 class DelayPool;
 class Updateable;
@@ -75,7 +75,7 @@ class DelayPools
     static time_t LastUpdate;
     static unsigned short pools_;
     static void FreeDelayData ();
-    static Vector<Updateable *> toUpdate;
+    static std::vector<Updateable *> toUpdate;
     static void RegisterWithCacheManager(void);
 };
 
@@ -37,7 +37,6 @@
 #if USE_DELAY_POOLS
 
 #include "auth/Gadgets.h"
-#include "base/Vector.h"
 #include "CompositePoolNode.h"
 #include "DelayBucket.h"
 #include "DelayIdComposite.h"
@@ -38,7 +38,6 @@
 
 #include "auth/Gadgets.h"
 #include "auth/User.h"
-#include "base/Vector.h"
 #include "CompositePoolNode.h"
 #include "DelayBucket.h"
 #include "DelayIdComposite.h"
@@ -72,16 +72,16 @@ class DelayVector : public CompositePoolNode
 
     private:
         RefCount<DelayVector> theVector;
-        Vector<DelayIdComposite::Pointer> ids;
-        typedef Vector<DelayIdComposite::Pointer>::iterator iterator;
-        typedef Vector<DelayIdComposite::Pointer>::const_iterator const_iterator;
+        std::vector<DelayIdComposite::Pointer> ids;
+        typedef std::vector<DelayIdComposite::Pointer>::iterator iterator;
+        typedef std::vector<DelayIdComposite::Pointer>::const_iterator const_iterator;
     };
 
     friend class Id;
 
-    Vector<CompositePoolNode::Pointer> pools;
-    typedef Vector<CompositePoolNode::Pointer>::iterator iterator;
-    typedef Vector<CompositePoolNode::Pointer>::const_iterator const_iterator;
+    std::vector<CompositePoolNode::Pointer> pools;
+    typedef std::vector<CompositePoolNode::Pointer>::iterator iterator;
+    typedef std::vector<CompositePoolNode::Pointer>::const_iterator const_iterator;
 };
 
 #endif /* USE_DELAY_POOLS */
@@ -35,7 +35,7 @@
 #include "squid.h"
 #include "DiskIOModule.h"
 
-Vector<DiskIOModule*> *DiskIOModule::_Modules = NULL;
+std::vector<DiskIOModule*> *DiskIOModule::_Modules = NULL;
 
 //DiskIOModule() : initialised (false) {}
 
@@ -70,17 +70,17 @@ DiskIOModule::ModuleAdd(DiskIOModule &instance)
     GetModules().push_back (&instance);
 }
 
-Vector<DiskIOModule *> const &
+std::vector<DiskIOModule *> const &
 DiskIOModule::Modules()
 {
     return GetModules();
 }
 
-Vector<DiskIOModule*> &
+std::vector<DiskIOModule*> &
 DiskIOModule::GetModules()
 {
     if (!_Modules)
-        _Modules = new Vector<DiskIOModule *>;
+        _Modules = new std::vector<DiskIOModule *>;
 
     return *_Modules;
 }
@@ -92,7 +92,7 @@ DiskIOModule::GetModules()
 void
 DiskIOModule::FreeAllModules()
 {
-    while (GetModules().size()) {
+    while (!GetModules().empty()) {
         DiskIOModule *fs = GetModules().back();
         GetModules().pop_back();
         fs->gracefulShutdown();
@@ -32,7 +32,7 @@
 #ifndef SQUID_DISKIOMODULE_H
 #define SQUID_DISKIOMODULE_H
 
-#include "base/Vector.h"
+#include <vector>
 
 /* forward decls */
 
@@ -57,9 +57,9 @@ class DiskIOModule
      * available module for this system.
      */
     static DiskIOModule *FindDefault();
-    static Vector<DiskIOModule*> const &Modules();
-    typedef Vector<DiskIOModule*>::iterator iterator;
-    typedef Vector<DiskIOModule*>::const_iterator const_iterator;
+    static std::vector<DiskIOModule*> const &Modules();
+    typedef std::vector<DiskIOModule*>::iterator iterator;
+    typedef std::vector<DiskIOModule*>::const_iterator const_iterator;
     DiskIOModule();
     virtual ~DiskIOModule() {}
 
@@ -78,8 +78,8 @@ class DiskIOModule
     static void RegisterAllModulesWithCacheManager(void);
 
 private:
-    static Vector<DiskIOModule*> &GetModules();
-    static Vector<DiskIOModule*> *_Modules;
+    static std::vector<DiskIOModule*> &GetModules();
+    static std::vector<DiskIOModule*> *_Modules;
 };
 
 #endif /* SQUID_DISKIOMODULE_H */
@@ -31,7 +31,7 @@
 #ifndef SQUID_EVENTLOOP_H
 #define SQUID_EVENTLOOP_H
 
-#include "base/Vector.h"
+#include <vector>
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
@@ -104,7 +104,7 @@ class EventLoop
     bool dispatchCalls();
 
     bool last_loop;
-    typedef Vector<AsyncEngine *> engine_vector;
+    typedef std::vector<AsyncEngine *> engine_vector;
     engine_vector engines;
     TimeEngine * timeService;
     AsyncEngine * primaryEngine;
@@ -70,7 +70,7 @@ ExternalACLEntry::update(ExternalACLEntryData const &someData)
     result = someData.result;
 
     // replace all notes. not combine
-    notes.entries.clean();
+    notes.entries.clear();
     notes.append(&someData.notes);
 
 #if USE_AUTH
@@ -1,7 +1,7 @@
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
-#include "base/Vector.h"
+#include <vector>
 
 /// Counts events, forgetting old ones. Usefull for "3 errors/minute" limits.
 class FadingCounter
@@ -25,7 +25,7 @@ class FadingCounter
     double delta; ///< sub-interval duration = horizon/precision
 
     double lastTime; ///< time of the last update
-    Vector<int> counters; ///< events per delta (possibly stale)
+    std::vector<int> counters; ///< events per delta (possibly stale)
     int total; ///< number of remembered events (possibly stale)
 };
 
@@ -112,7 +112,7 @@ FwdState::abort(void* d)
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
-    fwd->serverDestinations.clean();
+    fwd->serverDestinations.clear();
     fwd->self = NULL;
 }
 
@@ -277,7 +277,7 @@ FwdState::~FwdState()
         serverConn->close();
     }
 
-    serverDestinations.clean();
+    serverDestinations.clear();
 
     debugs(17, 3, HERE << "FwdState destructor done");
 }
@@ -472,7 +472,7 @@ FwdState::complete()
         entry->reset();
 
         // drop the last path off the selection list. try the next one.
-        serverDestinations.shift();
+        serverDestinations.erase(serverDestinations.begin());
         startConnectionOrFail();
 
     } else {
@@ -611,7 +611,7 @@ FwdState::retryOrBail()
         if (pconnRace == raceHappened)
             debugs(17, 4, HERE << "retrying the same destination");
         else
-            serverDestinations.shift(); // last one failed. try another.
+            serverDestinations.erase(serverDestinations.begin()); // last one failed. try another.
         startConnectionOrFail();
         return;
     }
@@ -2,7 +2,6 @@
 #define SQUID_FORWARD_H
 
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "err_type.h"
@@ -58,18 +58,6 @@ T& for_each(dlink_list const &collection, T& visitor)
     return visitor;
 }
 
-template <class S>
-class Stack;
-
-template <class E, class T>
-T& for_each(Stack<E> const &collection, T& visitor)
-{
-    for (size_t index = 0; index < collection.count; ++index)
-        visitor(*(typename T::argument_type const *)collection.items[index]);
-
-    return visitor;
-};
-
 /* RBC 20030718 - use this to provide instance expecting classes a pointer to a
  * singleton
  */
@@ -266,8 +266,10 @@ HttpHdrRange::parseInit(const String * range_spec)
          * at least one syntactically invalid byte-range-specs.
          */
         if (!spec) {
-            while (!specs.empty())
-                delete specs.pop_back();
+            while (!specs.empty()) {
+                delete specs.back();
+                specs.pop_back();
+            }
             debugs(64, 2, "ignoring invalid range field: '" << range_spec << "'");
             break;
         }
@@ -281,8 +283,10 @@ HttpHdrRange::parseInit(const String * range_spec)
 
 HttpHdrRange::~HttpHdrRange()
 {
-    while (specs.size())
-        delete specs.pop_back();
+    while (!specs.empty()) {
+        delete specs.back();
+        specs.pop_back();
+    }
 }
 
 HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) :
@@ -338,10 +342,10 @@ HttpHdrRange::packInto(Packer * packer) const
 }
 
 void
-HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
+HttpHdrRange::merge (std::vector<HttpHdrRangeSpec *> &basis)
 {
     /* reset old array */
-    specs.clean();
+    specs.clear();
     /* merge specs:
      * take one spec from "goods" and merge it with specs from
      * "specs" (if any) until there is no overlap */
@@ -350,7 +354,8 @@ HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
     while (i != basis.end()) {
         if (specs.size() && (*i)->mergeWith(specs.back())) {
             /* merged with current so get rid of the prev one */
-            delete specs.pop_back();
+            delete specs.back();
+            specs.pop_back();
             continue;	/* re-iterate */
         }
 
@@ -363,7 +368,7 @@ HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
 }
 
 void
-HttpHdrRange::getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy)
+HttpHdrRange::getCanonizedSpecs(std::vector<HttpHdrRangeSpec *> &copy)
 {
     /* canonize each entry and destroy bad ones if any */
 
@@ -374,8 +379,7 @@ HttpHdrRange::getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy)
             delete (*pos);
     }
 
-    debugs(64, 3, "HttpHdrRange::getCanonizedSpecs: found " <<
-           specs.size() - copy.size() << " bad specs");
+    debugs(64, 3, "found " << specs.size() - copy.size() << " bad specs");
 }
 
 #include "HttpHdrContRange.h"
@@ -404,14 +408,14 @@ int
 HttpHdrRange::canonize (int64_t newClen)
 {
     clen = newClen;
-    debugs(64, 3, "HttpHdrRange::canonize: started with " << specs.count <<
+    debugs(64, 3, "HttpHdrRange::canonize: started with " << specs.size() <<
            " specs, clen: " << clen);
-    Vector<HttpHdrRangeSpec*> goods;
+    std::vector<HttpHdrRangeSpec*> goods;
     getCanonizedSpecs(goods);
     merge (goods);
-    debugs(64, 3, "HttpHdrRange::canonize: finished with " << specs.count <<
+    debugs(64, 3, "HttpHdrRange::canonize: finished with " << specs.size() <<
            " specs");
-    return specs.count > 0;
+    return specs.size() > 0; // fixme, should return bool
 }
 
 /* hack: returns true if range specs are too "complex" for Squid to handle */
@@ -574,7 +578,7 @@ HttpHdrRange::contains(HttpHdrRangeSpec& r) const
 const HttpHdrRangeSpec *
 HttpHdrRangeIter::currentSpec() const
 {
-    if (pos.incrementable())
+    if (pos != end)
         return *pos;
 
     return NULL;
@@ -586,7 +590,7 @@ HttpHdrRangeIter::updateSpec()
     assert (debt_size == 0);
     assert (valid);
 
-    if (pos.incrementable()) {
+    if (pos != end) {
         debt(currentSpec()->length);
     }
 }
@@ -50,6 +50,12 @@
 #include "StrList.h"
 #include "TimeOrTag.h"
 
+#include <algorithm>
+
+/* XXX: the whole set of API managing the entries vector should be rethought
+ *      after the parse4r-ng effort is complete.
+ */
+
 /*
  * On naming conventions:
  *
@@ -435,8 +441,6 @@ HttpHeader::operator =(const HttpHeader &other)
 void
 HttpHeader::clean()
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
 
     assert(owner > hoNone && owner < hoEnd);
     debugs(55, 7, "cleaning hdr: " << this << " owner: " << owner);
@@ -454,27 +458,28 @@ HttpHeader::clean()
          * has been used.  As a hack, just never count zero-sized header
          * arrays.
          */
-        if (0 != entries.count)
-            HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
+        if (!entries.empty())
+            HttpHeaderStats[owner].hdrUCountDistr.count(entries.size());
 
         ++ HttpHeaderStats[owner].destroyedCount;
 
-        HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
+        HttpHeaderStats[owner].busyDestroyedCount += entries.size() > 0;
     } // if (owner <= hoReply)
 
-    while ((e = getEntry(&pos))) {
-        /* tmp hack to try to avoid coredumps */
-
+    for (std::vector<HttpHeaderEntry *>::iterator i = entries.begin(); i != entries.end(); ++i) {
+        HttpHeaderEntry *e = *i;
+        if (e == NULL)
+            continue;
         if (e->id < 0 || e->id >= HDR_ENUM_END) {
-            debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
+            debugs(55, DBG_CRITICAL, "BUG: invalid entry (" << e->id << "). Ignored.");
         } else {
             if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
-            /* yes, this deletion leaves us in an inconsistent state */
             delete e;
         }
     }
-    entries.clean();
+
+    entries.clear();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
     PROF_stop(HttpHeaderClean);
@@ -748,11 +753,11 @@ HttpHeaderEntry *
 HttpHeader::getEntry(HttpHeaderPos * pos) const
 {
     assert(pos);
-    assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)entries.count);
+    assert(*pos >= HttpHeaderInitPos && *pos < static_cast<ssize_t>(entries.size()));
 
-    for (++(*pos); *pos < (ssize_t)entries.count; ++(*pos)) {
-        if (entries.items[*pos])
-            return (HttpHeaderEntry*)entries.items[*pos];
+    for (++(*pos); *pos < static_cast<ssize_t>(entries.size()); ++(*pos)) {
+        if (entries[*pos])
+            return static_cast<HttpHeaderEntry*>(entries[*pos]);
     }
 
     return NULL;
@@ -871,9 +876,9 @@ void
 HttpHeader::delAt(HttpHeaderPos pos, int &headers_deleted)
 {
     HttpHeaderEntry *e;
-    assert(pos >= HttpHeaderInitPos && pos < (ssize_t)entries.count);
-    e = (HttpHeaderEntry*)entries.items[pos];
-    entries.items[pos] = NULL;
+    assert(pos >= HttpHeaderInitPos && pos < static_cast<ssize_t>(entries.size()));
+    e = static_cast<HttpHeaderEntry*>(entries[pos]);
+    entries[pos] = NULL;
     /* decrement header length, allow for ": " and crlf */
     len -= e->name.size() + 2 + e->value.size() + 2;
     assert(len >= 0);
@@ -887,7 +892,10 @@ HttpHeader::delAt(HttpHeaderPos pos, int &headers_deleted)
 void
 HttpHeader::compact()
 {
-    entries.prune(NULL);
+    // TODO: optimize removal, or possibly make it so that's not needed.
+    std::vector<HttpHeaderEntry *>::iterator newend;
+    newend = std::remove(entries.begin(), entries.end(), static_cast<HttpHeaderEntry *>(NULL));
+    entries.resize(newend-entries.begin());
 }
 
 /*
@@ -914,7 +922,7 @@ HttpHeader::addEntry(HttpHeaderEntry * e)
     assert_eid(e->id);
     assert(e->name.size());
 
-    debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
+    debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
     if (CBIT_TEST(mask, e->id))
         ++ Headers[e->id].stat.repCount;
@@ -936,14 +944,14 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
     assert(e);
     assert_eid(e->id);
 
-    debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
+    debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
     if (CBIT_TEST(mask, e->id))
         ++ Headers[e->id].stat.repCount;
     else
         CBIT_SET(mask, e->id);
 
-    entries.insert(e);
+    entries.insert(entries.begin(),e);
 
     /* increment header length, allow for ": " and crlf */
     len += e->name.size() + 2 + e->value.size() + 2;
@@ -36,6 +36,8 @@
 #include "MemPool.h"
 #include "SquidString.h"
 
+#include <vector>
+
 /* class forward declarations */
 class HttpHdrCc;
 class HttpHdrContRange;
@@ -283,7 +285,7 @@ class HttpHeader
     inline bool chunked() const; ///< whether message uses chunked Transfer-Encoding
 
     /* protected, do not use these, use interface functions instead */
-    Vector<HttpHeaderEntry *> entries;		/**< parsed fields in raw format */
+    std::vector<HttpHeaderEntry *> entries;		/**< parsed fields in raw format */
     HttpHeaderMask mask;	/**< bit set <=> entry present */
     http_hdr_owner_type owner;	/**< request or reply */
     int len;			/**< length when packed, not counting terminating null-byte */
@@ -1,4 +1,3 @@
-
 /*
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -32,12 +31,13 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "base/Vector.h"
 #include "MemPool.h"
 #include "Packer.h"
 #include "Range.h"
 #include "SquidString.h"
 
+#include <vector>
+
 class HttpReply;
 /* http byte-range-spec */
 
@@ -83,8 +83,8 @@ class HttpHdrRange
     ~HttpHdrRange();
     HttpHdrRange &operator= (HttpHdrRange const &);
 
-    typedef Vector<HttpHdrRangeSpec *>::iterator iterator;
-    typedef Vector<HttpHdrRangeSpec *>::const_iterator const_iterator;
+    typedef std::vector<HttpHdrRangeSpec *>::iterator iterator;
+    typedef std::vector<HttpHdrRangeSpec *>::const_iterator const_iterator;
     iterator begin();
     const_iterator begin () const;
     iterator end();
@@ -103,11 +103,11 @@ class HttpHdrRange
     int64_t lowestOffset(int64_t) const;
     bool offsetLimitExceeded(const int64_t limit) const;
     bool contains(HttpHdrRangeSpec& r) const;
-    Vector<HttpHdrRangeSpec *> specs;
+    std::vector<HttpHdrRangeSpec *> specs;
 
 private:
-    void getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy);
-    void merge (Vector<HttpHdrRangeSpec *> &basis);
+    void getCanonizedSpecs (std::vector<HttpHdrRangeSpec *> &copy);
+    void merge (std::vector<HttpHdrRangeSpec *> &basis);
     int64_t clen;
 };
 
@@ -121,6 +121,7 @@ class HttpHdrRangeIter
 
 public:
     HttpHdrRange::iterator pos;
+    HttpHdrRange::iterator end;
     const HttpHdrRangeSpec *currentSpec() const;
     void updateSpec();
     int64_t debt() const;
@@ -479,7 +479,7 @@ HttpRequest::adaptHistoryImport(const HttpRequest &them)
 bool
 HttpRequest::multipartRangeRequest() const
 {
-    return (range && range->specs.count > 1);
+    return (range && range->specs.size() > 1);
 }
 
 bool
@@ -1077,8 +1077,7 @@ check_PROGRAMS+=\
 	tests/testSBuf \
 	tests/testSBufList \
 	tests/testConfigParser \
-	tests/testStatHist \
-	tests/testVector
+	tests/testStatHist
 
 if HAVE_FS_ROCK
 check_PROGRAMS += tests/testRock
@@ -3826,21 +3825,6 @@ tests_testStatHist_LDADD = \
 	$(COMPAT_LIB)
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
-tests_testVector_SOURCES = \
-	tests/testVector.cc \
-	tests/testMain.cc \
-	tests/testVector.h
-nodist_tests_testVector_SOURCES = \
-	$(TESTSOURCES)
-tests_testVector_LDADD= \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-tests_testVector_LDFLAGS = $(LIBADD_DL)
-tests_testVector_DEPENDENCIES = \
-	$(SQUID_CPPUNIT_LA)
-
-
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script
@@ -146,21 +146,23 @@ Notes::dump(StoreEntry *entry, const char *key)
 void
 Notes::clean()
 {
-    notes.clean();
+    notes.clear();
 }
 
 NotePairs::~NotePairs()
 {
-    while (!entries.empty())
-        delete entries.pop_back();
+    while (!entries.empty()) {
+        delete entries.back();
+        entries.pop_back();
+    }
 }
 
 const char *
 NotePairs::find(const char *noteKey) const
 {
     static String value;
     value.clean();
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0) {
             if (value.size())
                 value.append(", ");
@@ -175,7 +177,7 @@ NotePairs::toString(const char *sep) const
 {
     static String value;
     value.clean();
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         value.append((*i)->name);
         value.append(": ");
         value.append(ConfigParser::QuoteString((*i)->value));
@@ -187,7 +189,7 @@ NotePairs::toString(const char *sep) const
 const char *
 NotePairs::findFirst(const char *noteKey) const
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0)
             return (*i)->value.termedBuf();
     }
@@ -217,7 +219,7 @@ NotePairs::addStrList(const char *key, const char *values)
 bool
 NotePairs::hasPair(const char *key, const char *value) const
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(key) == 0 && (*i)->value.cmp(value) == 0)
             return true;
     }
@@ -227,15 +229,15 @@ NotePairs::hasPair(const char *key, const char *value) const
 void
 NotePairs::append(const NotePairs *src)
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
         entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
     }
 }
 
 void
 NotePairs::appendNewOnly(const NotePairs *src)
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
         if (!hasPair((*i)->name.termedBuf(), (*i)->value.termedBuf()))
             entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
     }
@@ -3,14 +3,14 @@
 
 #include "acl/forward.h"
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "CbDataList.h"
 #include "format/Format.h"
 #include "MemPool.h"
 #include "SquidString.h"
 #include "typedefs.h"
 
 #include <string>
+#include <vector>
 
 class HttpRequest;
 class HttpReply;
@@ -38,7 +38,7 @@ class Note: public RefCountable
         explicit Value(const String &aVal) : value(aVal), aclList(NULL), valueFormat(NULL) {}
         ~Value();
     };
-    typedef Vector<Value::Pointer> Values;
+    typedef std::vector<Value::Pointer> Values;
 
     explicit Note(const String &aKey): key(aKey) {}
 
@@ -68,13 +68,13 @@ class ConfigParser;
 class Notes
 {
 public:
-    typedef Vector<Note::Pointer> NotesList;
+    typedef std::vector<Note::Pointer> NotesList;
     typedef NotesList::iterator iterator; ///< iterates over the notes list
     typedef NotesList::const_iterator const_iterator; ///< iterates over the notes list
 
     Notes(const char *aDescr, const char **metasBlacklist, bool allowFormatted = false): descr(aDescr), blacklisted(metasBlacklist), formattedValues(allowFormatted) {}
     Notes(): descr(NULL), blacklisted(NULL) {}
-    ~Notes() { notes.clean(); }
+    ~Notes() { notes.clear(); }
     /**
      * Parse a notes line and returns a pointer to the
      * parsed Note object.
@@ -182,7 +182,7 @@ class NotePairs: public RefCountable
      */
     bool empty() const {return entries.empty();}
 
-    Vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
+    std::vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
 
 private:
     NotePairs &operator = (NotePairs const &); // Not implemented
@@ -35,7 +35,6 @@
 
 #include "AccessLogEntry.h"
 #include "acl/Checklist.h"
-#include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
@@ -35,7 +35,7 @@
 #include "squid.h"
 #include "StoreFileSystem.h"
 
-Vector<StoreFileSystem*> *StoreFileSystem::_FileSystems = NULL;
+std::vector<StoreFileSystem*> *StoreFileSystem::_FileSystems = NULL;
 
 void
 StoreFileSystem::RegisterAllFsWithCacheManager(void)
@@ -65,17 +65,17 @@ StoreFileSystem::FsAdd(StoreFileSystem &instance)
     GetFileSystems().push_back (&instance);
 }
 
-Vector<StoreFileSystem *> const &
+std::vector<StoreFileSystem *> const &
 StoreFileSystem::FileSystems()
 {
     return GetFileSystems();
 }
 
-Vector<StoreFileSystem*> &
+std::vector<StoreFileSystem*> &
 StoreFileSystem::GetFileSystems()
 {
     if (!_FileSystems)
-        _FileSystems = new Vector<StoreFileSystem *>;
+        _FileSystems = new std::vector<StoreFileSystem *>;
 
     return *_FileSystems;
 }
@@ -87,7 +87,7 @@ StoreFileSystem::GetFileSystems()
 void
 StoreFileSystem::FreeAllFs()
 {
-    while (GetFileSystems().size()) {
+    while (!GetFileSystems().empty()) {
         StoreFileSystem *fs = GetFileSystems().back();
         GetFileSystems().pop_back();
         fs->done();
@@ -31,7 +31,7 @@
 #ifndef SQUID_STOREFILESYSTEM_H
 #define SQUID_STOREFILESYSTEM_H
 
-#include "base/Vector.h"
+#include <vector>
 
 /* ****** DOCUMENTATION ***** */
 
@@ -116,9 +116,9 @@ class StoreFileSystem
     static void SetupAllFs();
     static void FsAdd(StoreFileSystem &);
     static void FreeAllFs();
-    static Vector<StoreFileSystem*> const &FileSystems();
-    typedef Vector<StoreFileSystem*>::iterator iterator;
-    typedef Vector<StoreFileSystem*>::const_iterator const_iterator;
+    static std::vector<StoreFileSystem*> const &FileSystems();
+    typedef std::vector<StoreFileSystem*>::iterator iterator;
+    typedef std::vector<StoreFileSystem*>::const_iterator const_iterator;
     StoreFileSystem() : initialised(false) {}
 
     virtual ~StoreFileSystem() {}
@@ -136,8 +136,8 @@ class StoreFileSystem
     virtual void registerWithCacheManager(void);
 
 private:
-    static Vector<StoreFileSystem*> &GetFileSystems();
-    static Vector<StoreFileSystem*> *_FileSystems;
+    static std::vector<StoreFileSystem*> &GetFileSystems();
+    static std::vector<StoreFileSystem*> *_FileSystems;
     static void RegisterAllFsWithCacheManager(void);
 };
 
@@ -117,7 +117,7 @@ class StoreSearchHashIndex : public StoreSearch
     void *cbdata;
     bool _done;
     int bucket;
-    Vector<StoreEntry *> entries;
+    std::vector<StoreEntry *> entries;
 
     // keep this last. it plays with private/public
     CBDATA_CLASS2(StoreSearchHashIndex);
@@ -41,6 +41,8 @@
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
+#include <vector>
+
 const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
 
 const char *AclMatchedName = NULL;
@@ -405,7 +407,7 @@ ACL::Prototype::Prototype (ACL const *aPrototype, char const *aType) : prototype
     registerMe ();
 }
 
-Vector<ACL::Prototype const *> * ACL::Prototype::Registry;
+std::vector<ACL::Prototype const *> * ACL::Prototype::Registry;
 void *ACL::Prototype::Initialized;
 
 bool
@@ -429,7 +431,7 @@ ACL::Prototype::registerMe ()
     if (!Registry || (Initialized != ((char *)Registry - 5))  ) {
         /* TODO: extract this */
         /* Not initialised */
-        Registry = new Vector <ACL::Prototype const *>;
+        Registry = new std::vector<ACL::Prototype const *>;
         Initialized = (char *)Registry - 5;
     }
 
@@ -34,14 +34,14 @@
 #define SQUID_ACL_H
 
 #include "acl/forward.h"
-#include "base/Vector.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
 #include "MemPool.h"
 
 #include <ostream>
 #include <string>
+#include <vector>
 
 class ConfigParser;
 
@@ -153,10 +153,10 @@ class ACL
         char const *typeString;
 
     private:
-        static Vector<Prototype const *> * Registry;
+        static std::vector<Prototype const *> * Registry;
         static void *Initialized;
-        typedef Vector<Prototype const*>::iterator iterator;
-        typedef Vector<Prototype const*>::const_iterator const_iterator;
+        typedef std::vector<Prototype const*>::iterator iterator;
+        typedef std::vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
 
@@ -29,7 +29,7 @@ ACLNoteData::matchNotes(NotePairs *note)
     if (values->empty())
         return (note->findFirst(name.termedBuf()) != NULL);
 
-    for (Vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
         if ((*i)->name.cmp(name.termedBuf()) == 0) {
             if (values->match((*i)->value.termedBuf()))
                 return true;
@@ -102,7 +102,7 @@ Adaptation::AccessCheck::check()
         AccessRule *r = *i;
         if (isCandidate(*r)) {
             debugs(93, 5, HERE << "check: rule '" << r->id << "' is a candidate");
-            candidates += r->id;
+            candidates.push_back(r->id);
         }
     }
 
@@ -131,7 +131,7 @@ Adaptation::AccessCheck::checkCandidates()
             return;
         }
 
-        candidates.shift(); // the rule apparently went away (reconfigure)
+        candidates.erase(candidates.begin()); // the rule apparently went away (reconfigure)
     }
 
     debugs(93, 4, HERE << "NO candidates left");
@@ -176,7 +176,7 @@ Adaptation::AccessCheck::noteAnswer(allow_t answer)
     }
 
     // no match or the group disappeared during reconfiguration
-    candidates.shift();
+    candidates.erase(candidates.begin());
     checkCandidates();
 }
 
@@ -39,7 +39,7 @@ class AccessCheck: public virtual AsyncJob
     ACLFilledChecklist *acl_checklist;
 
     typedef int Candidate;
-    typedef Vector<Candidate> Candidates;
+    typedef std::vector<Candidate> Candidates;
     Candidates candidates;
     Candidate topCandidate() const { return *candidates.begin(); }
     ServiceGroupPointer topGroup() const; // may return nil
@@ -5,6 +5,8 @@
 #include "adaptation/forward.h"
 #include "SquidString.h"
 
+#include <vector>
+
 class ConfigParser;
 
 namespace Adaptation
@@ -34,7 +36,7 @@ class AccessRule
     static Id LastId;
 };
 
-typedef Vector<Adaptation::AccessRule*> AccessRules;
+typedef std::vector<Adaptation::AccessRule*> AccessRules;
 AccessRules &AllRules();
 AccessRule *FindRule(const AccessRule::Id &id);
 AccessRule *FindRuleByGroupId(const String &groupId);
@@ -36,13 +36,14 @@
 #include "adaptation/History.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
-#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Store.h"
 
+#include <algorithm>
+
 bool Adaptation::Config::Enabled = false;
 char *Adaptation::Config::masterx_shared_name = NULL;
 int Adaptation::Config::service_iteration_limit = 16;
@@ -87,15 +88,19 @@ Adaptation::Config::removeService(const String& service)
         for (SGSI it = services.begin(); it != services.end(); ++it) {
             if (*it == service) {
                 group->removedServices.push_back(service);
-                group->services.prune(service);
-                debugs(93, 5, HERE << "adaptation service " << service <<
+                ServiceGroup::Store::iterator newend;
+                newend = std::remove(group->services.begin(), group->services.end(), service);
+                group->services.resize(newend-group->services.begin());
+                debugs(93, 5, "adaptation service " << service <<
                        " removed from group " << group->id);
                 break;
             }
         }
         if (services.empty()) {
             removeRule(group->id);
-            AllGroups().prune(group);
+            Groups::iterator newend;
+            newend = std::remove(AllGroups().begin(), AllGroups().end(), group);
+            AllGroups().resize(newend-AllGroups().begin());
         } else {
             ++i;
         }
@@ -122,8 +127,10 @@ Adaptation::Config::removeRule(const String& id)
     for (ARI it = rules.begin(); it != rules.end(); ++it) {
         AccessRule* rule = *it;
         if (rule->groupId == id) {
-            debugs(93, 5, HERE << "removing access rules for:" << id);
-            AllRules().prune(rule);
+            debugs(93, 5, "removing access rules for:" << id);
+            AccessRules::iterator newend;
+            newend = std::remove(AllRules().begin(), AllRules().end(), rule);
+            AllRules().resize(newend-AllRules().begin());
             delete (rule);
             break;
         }
@@ -139,7 +146,7 @@ Adaptation::Config::clear()
     const ServiceConfigs& configs = serviceConfigs;
     for (SCI cfg = configs.begin(); cfg != configs.end(); ++cfg)
         removeService((*cfg)->key);
-    serviceConfigs.clean();
+    serviceConfigs.clear();
     debugs(93, 3, HERE << "rules: " << AllRules().size() << ", groups: " <<
            AllGroups().size() << ", services: " << serviceConfigs.size());
 }
@@ -163,7 +170,7 @@ Adaptation::Config::freeService()
 
     DetachServices();
 
-    serviceConfigs.clean();
+    serviceConfigs.clear();
 }
 
 void
@@ -210,7 +217,7 @@ Adaptation::Config::finalize()
     debugs(93,3, HERE << "Created " << created << " adaptation services");
 
     // services remember their configs; we do not have to
-    serviceConfigs.clean();
+    serviceConfigs.clear();
     return true;
 }
 
@@ -51,7 +51,7 @@ class Config
 
     static bool needHistory; ///< HttpRequest adaptation history should recorded
 
-    typedef Vector<ServiceConfigPointer> ServiceConfigs;
+    typedef std::vector<ServiceConfigPointer> ServiceConfigs;
     ServiceConfigs serviceConfigs;
 
     Config();
@@ -18,5 +18,5 @@ void
 Adaptation::DynamicGroupCfg::clear()
 {
     id.clean();
-    services.clean();
+    services.clear();
 }
@@ -1,17 +1,18 @@
 #ifndef SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 #define SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 
-#include "base/Vector.h"
 #include "SquidString.h"
 
+#include <vector>
+
 namespace Adaptation
 {
 
 /// DynamicServiceGroup configuration to remember future dynamic chains
 class DynamicGroupCfg
 {
 public:
-    typedef Vector<String> Store;
+    typedef std::vector<String> Store;
     typedef String Id;
 
     Id id; ///< group id
@@ -3,7 +3,6 @@
 
 #include "adaptation/DynamicGroupCfg.h"
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "HttpHeader.h"
 #include "Notes.h"
 #include "SBuf.h"
@@ -57,7 +56,7 @@ class History: public RefCountable
     /// AccessLogEntry::notes when ALE becomes available
     NotePairs::Pointer metaHeaders;
 
-    typedef Vector<SBuf> AdaptationServices;
+    typedef std::vector<SBuf> AdaptationServices;
     AdaptationServices theAdaptationServices; ///< The service groups used
 
     /// sets future services for the Adaptation::AccessCheck to notice
@@ -87,7 +86,7 @@ class History: public RefCountable
         bool retried; ///< whether the xaction was replaced by another
     };
 
-    typedef Vector<Entry> Entries;
+    typedef std::vector<Entry> Entries;
     Entries theEntries; ///< historical record, in the order of xact starts
 
     // theXx* will become a map<string,string>, but we only support one record
@@ -71,6 +71,8 @@ Adaptation::FindService(const Service::Id& key)
 
 void Adaptation::DetachServices()
 {
-    while (!AllServices().empty())
-        AllServices().pop_back()->detach();
+    while (!AllServices().empty()) {
+        AllServices().back()->detach();
+        AllServices().pop_back();
+    }
 }
@@ -61,7 +61,7 @@ class Service: public RefCountable
 
 typedef Service::Pointer ServicePointer;
 
-typedef Vector<Adaptation::ServicePointer> Services;
+typedef std::vector<Adaptation::ServicePointer> Services;
 Services &AllServices();
 ServicePointer FindService(const Service::Id &key);
 
@@ -48,7 +48,7 @@ Adaptation::ServiceGroup::finalize()
         }
         s.cut(s.size() - 1);
         debugs(93, DBG_IMPORTANT, "Adaptation group '" << id << "' contains disabled member(s) after reconfiguration: " << s);
-        removedServices.clean();
+        removedServices.clear();
     }
 
     String baselineKey;
@@ -4,9 +4,10 @@
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "SquidString.h"
 
+#include <vector>
+
 namespace Adaptation
 {
 
@@ -17,9 +18,9 @@ class ServiceGroup: public RefCountable
 public:
     typedef RefCount<ServiceGroup> Pointer;
 
-    typedef Vector<String> Store;
+    typedef std::vector<String> Store;
     typedef String Id;
-    typedef unsigned int Pos; // Vector<>::poistion_type
+    typedef unsigned int Pos; // vector<>::position_type
     friend class ServicePlan;
 
 public:
@@ -113,7 +114,7 @@ class DynamicServiceChain: public ServiceChain
 class ServicePlan
 {
 public:
-    typedef unsigned int Pos; // Vector<>::poistion_type
+    typedef unsigned int Pos; // vector<>::position_type
 
 public:
     ServicePlan();
@@ -141,7 +142,7 @@ std::ostream &operator <<(std::ostream &os, const ServicePlan &p)
     return p.print(os);
 }
 
-typedef Vector<ServiceGroupPointer> Groups;
+typedef std::vector<ServiceGroupPointer> Groups;
 Groups &AllGroups();
 ServiceGroupPointer FindGroup(const ServiceGroup::Id &id);
 
@@ -33,7 +33,6 @@
 #include "squid.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
-#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -125,7 +125,7 @@ void Adaptation::Icap::Options::configure(const HttpReply *reply)
 void Adaptation::Icap::Options::cfgMethod(ICAP::Method m)
 {
     Must(m != ICAP::methodNone);
-    methods += m;
+    methods.push_back(m);
 }
 
 // TODO: HttpHeader should provide a general method for this type of conversion
@@ -71,7 +71,7 @@ class Options
     const char *error; // human-readable information; set iff !valid()
 
     // ICAP server MUST supply this info
-    Vector<ICAP::Method> methods;
+    std::vector<ICAP::Method> methods;
     String istag;
 
     // ICAP server MAY supply this info. If not, Squid supplies defaults.
@@ -375,7 +375,8 @@ void Adaptation::Icap::ServiceRep::noteTimeToNotify()
     Pointer us = NULL;
 
     while (!theClients.empty()) {
-        Client i = theClients.pop_back();
+        Client i = theClients.back();
+        theClients.pop_back();
         ScheduleCallHere(i.callback);
         i.callback = 0;
     }
@@ -469,7 +470,7 @@ void Adaptation::Icap::ServiceRep::checkOptions()
     if (!theOptions->methods.empty()) {
         bool method_found = false;
         String method_list;
-        Vector <ICAP::Method>::iterator iter = theOptions->methods.begin();
+        std::vector <ICAP::Method>::iterator iter = theOptions->methods.begin();
 
         while (iter != theOptions->methods.end()) {
 
@@ -140,7 +140,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
         AsyncCall::Pointer callback;
     };
 
-    typedef Vector<Client> Clients;
+    typedef std::vector<Client> Clients;
     // TODO: rename to theUpWaiters
     Clients theClients; // all clients waiting for a call back
 
@@ -150,7 +150,7 @@ class Config
     Format::Format *keyExtras; ///< The compiled request format
 };
 
-typedef Vector<Config *> ConfigVector;
+typedef std::vector<Config *> ConfigVector;
 
 extern ConfigVector TheConfig;
 
@@ -133,7 +133,7 @@ authenticateReset(void)
     authenticateRotate();
 
     /* free current global config details too. */
-    Auth::TheConfig.clean();
+    Auth::TheConfig.clear();
 }
 
 AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user):
@@ -37,7 +37,7 @@
 #include "auth/Scheme.h"
 #include "globals.h"
 
-Vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
+std::vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
 
 void
 Auth::Scheme::AddScheme(Auth::Scheme::Pointer instance)
@@ -63,11 +63,11 @@ Auth::Scheme::Find(const char *typestr)
     return Auth::Scheme::Pointer(NULL);
 }
 
-Vector<Auth::Scheme::Pointer> &
+std::vector<Auth::Scheme::Pointer> &
 Auth::Scheme::GetSchemes()
 {
     if (!_Schemes)
-        _Schemes = new Vector<Auth::Scheme::Pointer>;
+        _Schemes = new std::vector<Auth::Scheme::Pointer>;
 
     return *_Schemes;
 }
@@ -34,7 +34,8 @@
 #if USE_AUTH
 
 #include "base/RefCount.h"
-#include "base/Vector.h"
+
+#include <vector>
 
 /**
  \defgroup AuthSchemeAPI	Authentication Scheme API
@@ -60,8 +61,8 @@ class Scheme : public RefCountable
 {
 public:
     typedef RefCount<Scheme> Pointer;
-    typedef Vector<Scheme::Pointer>::iterator iterator;
-    typedef Vector<Scheme::Pointer>::const_iterator const_iterator;
+    typedef std::vector<Scheme::Pointer>::iterator iterator;
+    typedef std::vector<Scheme::Pointer>::const_iterator const_iterator;
 
 public:
     Scheme() : initialised (false) {};
@@ -93,13 +94,13 @@ class Scheme : public RefCountable
     Scheme(Scheme const &);
     Scheme &operator=(Scheme const&);
 
-    static Vector<Scheme::Pointer> &GetSchemes();
+    static std::vector<Scheme::Pointer> &GetSchemes();
 
 protected:
     bool initialised;
 
 private:
-    static Vector<Scheme::Pointer> *_Schemes;
+    static std::vector<Scheme::Pointer> *_Schemes;
 };
 
 } // namespace Auth
@@ -23,9 +23,7 @@ libbase_la_SOURCES = \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
-	TextException.h \
-	Vector.cc \
-	Vector.h
+	TextException.h
 
 EXTRA_PROGRAMS = \
 	testCharacterSet
@@ -1,48 +0,0 @@
-/*
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-/*
- * Array is an array of (void*) items with unlimited capacity
- *
- * Array grows when arrayAppend() is called and no space is left
- * Currently, array does not have an interface for deleting an item because
- *     we do not need such an interface yet.
- */
-
-#include "squid.h"
-#include "base/Vector.h"
-
-#if HAVE_ASSERT_H
-#include <assert.h>
-#endif
-#if HAVE_STRING_H
-#include <string.h>
-#endif
@@ -1,455 +0,0 @@
-/*
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-#ifndef SQUID_ARRAY_H
-#define SQUID_ARRAY_H
-
-/**
- \todo CLEANUP: this file should be called Vector.h at least, and probably be replaced by STL Vector<C>
- */
-
-#include "fatal.h"
-#include "util.h"
-
-/* users of this template also need assert() */
-#include "compat/assert.h"
-
-/* iterator support */
-#include <iterator>
-
-template <class C>
-class VectorIteratorBase
-{
-public:
-    typedef typename C::value_type value_type;
-    typedef std::forward_iterator_tag iterator_category;
-    typedef typename C::pointer pointer;
-    typedef typename C::reference reference;
-    typedef typename C::difference_type difference_type;
-
-    VectorIteratorBase();
-    VectorIteratorBase(C &);
-    VectorIteratorBase(size_t, C &);
-    VectorIteratorBase & operator =(VectorIteratorBase const &);
-    bool operator != (VectorIteratorBase const &rhs) const;
-    bool operator == (VectorIteratorBase const &rhs) const;
-    VectorIteratorBase & operator ++();
-    VectorIteratorBase operator ++(int);
-    typename C::value_type & operator *() const {
-        return theVector->items[pos];
-    }
-
-    typename C::value_type * operator -> () const {
-        return &theVector->items[pos];
-    }
-
-    ssize_t operator - (VectorIteratorBase const &rhs) const;
-    bool incrementable() const;
-
-private:
-    size_t pos;
-    C * theVector;
-};
-
-template<class E>
-class Vector
-{
-public:
-    typedef E value_type;
-    typedef E* pointer;
-    typedef E& reference;
-    typedef VectorIteratorBase<Vector<E> > iterator;
-    typedef VectorIteratorBase<Vector<E> const> const_iterator;
-    typedef ptrdiff_t difference_type;
-
-    void *operator new (size_t);
-    void operator delete (void *);
-
-    Vector();
-    ~Vector();
-    Vector(Vector const &);
-    Vector &operator = (Vector const &);
-    void clean();
-    void reserve (size_t capacity);
-    void push_back (E);
-    Vector &operator += (E item) {push_back(item); return *this;};
-
-    void insert (E);
-    const E &front() const;
-    E &front();
-    E &back();
-    E pop_back();
-    E shift();         // aka pop_front
-    void prune(E);
-    void preAppend(int app_count);
-    bool empty() const;
-    size_t size() const;
-    iterator begin();
-    const_iterator begin () const;
-    iterator end();
-    const_iterator end () const;
-    E& operator [] (unsigned i);
-    const E& operator [] (unsigned i) const;
-
-    /* Do not change these, until the entry C struct is removed */
-    size_t capacity;
-    size_t count;
-    E *items;
-};
-
-template<class E>
-void *
-Vector<E>::operator new(size_t size)
-{
-    return xmalloc(size);
-}
-
-template<class E>
-void
-Vector<E>::operator delete (void *address)
-{
-    xfree (address);
-}
-
-template<class E>
-Vector<E>::Vector() : capacity (0), count(0), items (NULL)
-{}
-
-template<class E>
-Vector<E>::~Vector()
-{
-    clean();
-}
-
-template<class E>
-void
-Vector<E>::clean()
-{
-    /* could also warn if some objects are left */
-    delete[] items;
-    items = NULL;
-    capacity = 0;
-    count = 0;
-}
-
-/* grows internal buffer to satisfy required minimal capacity */
-template<class E>
-void
-Vector<E>::reserve(size_t min_capacity)
-{
-    const int min_delta = 16;
-    int delta;
-
-    if (capacity >= min_capacity)
-        return;
-
-    delta = min_capacity;
-
-    /* make delta a multiple of min_delta */
-    delta += min_delta - 1;
-
-    delta /= min_delta;
-
-    delta *= min_delta;
-
-    /* actual grow */
-    if (delta < 0)
-        delta = min_capacity - capacity;
-
-    E*newitems = new E[capacity + delta];
-
-    for (size_t counter = 0; counter < size(); ++counter) {
-        newitems[counter] = items[counter];
-    }
-
-    capacity += delta;
-    delete[]items;
-    items = newitems;
-}
-
-template<class E>
-void
-Vector<E>::push_back(E obj)
-{
-    if (size() >= capacity)
-        reserve (size() + 1);
-
-    items[count++] = obj;
-}
-
-template<class E>
-void
-Vector<E>::insert(E obj)
-{
-    if (size() >= capacity)
-        reserve (size() + 1);
-
-    int i;
-
-    for (i = count; i > 0; i--)
-        items[i] = items[i - 1];
-
-    items[i] = obj;
-
-    count += 1;
-}
-
-template<class E>
-E
-Vector<E>::shift()
-{
-    assert (size());
-    value_type result = items[0];
-
-    for (unsigned int i = 1; i < count; i++)
-        items[i-1] = items[i];
-
-    count--;
-
-    /*reset the last (unused) element...*/
-    items[count] = value_type();
-
-    return result;
-}
-
-template<class E>
-E
-Vector<E>::pop_back()
-{
-    assert (size());
-    value_type result = items[--count];
-    items[count] = value_type();
-    return result;
-}
-
-template<class E>
-E &
-Vector<E>::back()
-{
-    assert (size());
-    return items[size() - 1];
-}
-
-template<class E>
-const E &
-Vector<E>::front() const
-{
-    assert (size());
-    return items[0];
-}
-
-template<class E>
-E &
-Vector<E>::front()
-{
-    assert (size());
-    return items[0];
-}
-
-template<class E>
-void
-Vector<E>::prune(E item)
-{
-    unsigned int n = 0;
-    for (unsigned int i = 0; i < count; i++) {
-        if (items[i] != item) {
-            if (i != n)
-                items[n] = items[i];
-            n++;
-        }
-    }
-
-    count = n;
-}
-
-/* if you are going to append a known and large number of items, call this first */
-template<class E>
-void
-Vector<E>::preAppend(int app_count)
-{
-    if (size() + app_count > capacity)
-        reserve(size() + app_count);
-}
-
-template<class E>
-Vector<E>::Vector (Vector<E> const &rhs)
-{
-    items = NULL;
-    capacity = 0;
-    count = 0;
-    reserve (rhs.size());
-
-    for (size_t counter = 0; counter < rhs.size(); ++counter)
-        push_back (rhs.items[counter]);
-}
-
-template<class E>
-Vector<E> &
-Vector<E>::operator = (Vector<E> const &old)
-{
-    clean();
-    reserve (old.size());
-
-    for (size_t counter = 0; counter < old.size(); ++counter)
-        push_back (old.items[counter]);
-
-    return *this;
-}
-
-template<class E>
-bool
-Vector<E>::empty() const
-{
-    return size() == 0;
-}
-
-template<class E>
-size_t
-Vector<E>::size() const
-{
-    return count;
-}
-
-template<class E>
-typename Vector<E>::iterator
-Vector<E>::begin()
-{
-    return iterator (0, *this);
-}
-
-template<class E>
-typename Vector<E>::iterator
-Vector<E>::end()
-{
-    return iterator(size(), *this);
-}
-
-template<class E>
-typename Vector<E>::const_iterator
-Vector<E>::begin() const
-{
-    return const_iterator (0, *this);
-}
-
-template<class E>
-typename Vector<E>::const_iterator
-Vector<E>::end() const
-{
-    return const_iterator(size(), *this);
-}
-
-template<class E>
-E &
-Vector<E>::operator [] (unsigned i)
-{
-    assert (size() > i);
-    return items[i];
-}
-
-template<class E>
-const E &
-Vector<E>::operator [] (unsigned i) const
-{
-    assert (size() > i);
-    return items[i];
-}
-
-template<class C>
-VectorIteratorBase<C>::VectorIteratorBase() : pos(0), theVector(NULL)
-{}
-
-template<class C>
-VectorIteratorBase<C>::VectorIteratorBase(C &container) : pos(container.begin()), theVector(&container)
-{}
-
-template<class C>
-VectorIteratorBase<C>::VectorIteratorBase(size_t aPos, C &container) : pos(aPos), theVector(&container) {}
-
-template<class C>
-bool VectorIteratorBase<C>:: operator != (VectorIteratorBase<C> const &rhs) const
-{
-    assert (theVector);
-    return pos != rhs.pos;
-}
-
-template<class C>
-bool VectorIteratorBase<C>:: operator == (VectorIteratorBase<C> const &rhs) const
-{
-    assert (theVector);
-    return pos == rhs.pos;
-}
-
-template<class C>
-bool
-VectorIteratorBase<C>::incrementable() const
-{
-    assert (theVector);
-    return pos != theVector->size();
-}
-
-template<class C>
-VectorIteratorBase<C> & VectorIteratorBase<C>:: operator ++()
-{
-    assert (theVector);
-
-    if (!incrementable())
-        fatal ("domain error");
-
-    ++pos;
-
-    return *this;
-}
-
-template<class C>
-VectorIteratorBase<C> VectorIteratorBase<C>:: operator ++(int)
-{
-    VectorIteratorBase result(*this);
-    ++*this;
-    return result;
-}
-
-template<class C>
-VectorIteratorBase<C>&
-VectorIteratorBase<C>::operator =(VectorIteratorBase<C> const &old)
-{
-    pos = old.pos;
-    theVector = old.theVector;
-    return *this;
-}
-
-template<class C>
-ssize_t
-VectorIteratorBase<C>::operator - (VectorIteratorBase<C> const &rhs) const
-{
-    assert(theVector == rhs.theVector);
-    return pos - rhs.pos;
-}
-
-#endif /* SQUID_ARRAY_H */
@@ -245,7 +245,7 @@ static void free_sslproxy_ssl_bump(acl_access **ssl_bump);
 static void parse_b_size_t(size_t * var);
 static void parse_b_int64_t(int64_t * var);
 
-static bool parseNamedIntList(const char *data, const String &name, Vector<int> &list);
+static bool parseNamedIntList(const char *data, const String &name, std::vector<int> &list);
 
 static void parse_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap);
 static void dump_CpuAffinityMap(StoreEntry *const entry, const char *const name, const CpuAffinityMap *const cpuAffinityMap);
@@ -462,7 +462,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
 
     config_lineno = 0;
 
-    Vector<bool> if_states;
+    std::vector<bool> if_states;
     while (fgets(config_input_line, BUFSIZ, fp)) {
         ++config_lineno;
 
@@ -1843,12 +1843,7 @@ static void
 free_authparam(Auth::ConfigVector * cfg)
 {
     /* Wipe the Auth globals and Detach/Destruct component config + state. */
-    cfg->clean();
-
-    /* remove our pointers to the probably-dead sub-configs */
-    while (cfg->size()) {
-        cfg->pop_back();
-    }
+    cfg->clear();
 
     /* on reconfigure initialize new auth schemes for the new config. */
     if (reconfiguring) {
@@ -1869,7 +1864,7 @@ static int
 find_fstype(char *type)
 {
     for (size_t i = 0; i < StoreFileSystem::FileSystems().size(); ++i)
-        if (strcasecmp(type, StoreFileSystem::FileSystems().items[i]->type()) == 0)
+        if (strcasecmp(type, StoreFileSystem::FileSystems().at(i)->type()) == 0)
             return (int)i;
 
     return (-1);
@@ -1912,7 +1907,7 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
             sd = dynamic_cast<SwapDir *>(swap->swapDirs[i].getRaw());
 
-            if (strcmp(sd->type(), StoreFileSystem::FileSystems().items[fs]->type()) != 0) {
+            if (strcmp(sd->type(), StoreFileSystem::FileSystems().at(fs)->type()) != 0) {
                 debugs(3, DBG_CRITICAL, "ERROR: Can't change type of existing cache_dir " <<
                        sd->type() << " " << sd->path << " to " << type_str << ". Restart required");
                 return;
@@ -1934,7 +1929,7 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
     allocate_new_swapdir(swap);
 
-    swap->swapDirs[swap->n_configured] = StoreFileSystem::FileSystems().items[fs]->createSwapDir();
+    swap->swapDirs[swap->n_configured] = StoreFileSystem::FileSystems().at(fs)->createSwapDir();
 
     sd = dynamic_cast<SwapDir *>(swap->swapDirs[swap->n_configured].getRaw());
 
@@ -4247,7 +4242,7 @@ free_access_log(CustomLog ** definitions)
 
 /// parses list of integers form name=N1,N2,N3,...
 static bool
-parseNamedIntList(const char *data, const String &name, Vector<int> &list)
+parseNamedIntList(const char *data, const String &name, std::vector<int> &list)
 {
     if (data && (strncmp(data, name.rawBuf(), name.size()) == 0)) {
         data += name.size();
@@ -4280,7 +4275,7 @@ parse_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap)
 
     const char *const pToken = ConfigParser::NextToken();
     const char *const cToken = ConfigParser::NextToken();
-    Vector<int> processes, cores;
+    std::vector<int> processes, cores;
     if (!parseNamedIntList(pToken, "process_numbers", processes)) {
         debugs(3, DBG_CRITICAL, "FATAL: bad 'process_numbers' parameter " <<
                "in 'cpu_affinity_map'");
@@ -50,12 +50,13 @@
 #include "cbdata.h"
 #include "mgr/Registration.h"
 #include "Store.h"
-#if USE_CBDATA_DEBUG
-#include "Stack.h"
-#endif
 #include "Generic.h"
 
 #include <climits>
+#if USE_CBDATA_DEBUG
+#include <algorithm>
+#include <vector>
+#endif
 
 #if WITH_VALGRIND
 #define HASHED_CBDATA 1
@@ -122,7 +123,7 @@ class cbdata
     dlink_node link;
     const char *file;
     int line;
-    Stack<CBDataCall*> calls;
+    std::vector<CBDataCall*> calls; // used as a stack with random access operator
 #endif
 
     /* cookie used while debugging */
@@ -207,10 +208,11 @@ cbdata_hash(const void *p, unsigned int mod)
 cbdata::~cbdata()
 {
 #if USE_CBDATA_DEBUG
-    CBDataCall *aCall;
 
-    while ((aCall = calls.pop()))
-        delete aCall;
+    while (!calls.empty()) {
+        delete calls.back();
+        calls.pop_back();
+    }
 
 #endif
 
@@ -314,7 +316,7 @@ cbdataInternalAlloc(cbdata_type type)
 
     c->file = file;
     c->line = line;
-    c->calls = Stack<CBDataCall *> ();
+    c->calls = std::vector<CBDataCall *> ();
     c->addHistory("Alloc", file, line);
     dlinkAdd(c, &c->link, &cbdataEntries);
     debugs(45, 3, "cbdataAlloc: " << p << " " << file << ":" << line);
@@ -612,8 +614,8 @@ CBDATA_CLASS_INIT(generic_cbdata);
 struct CBDataCallDumper : public unary_function<CBDataCall, void> {
     CBDataCallDumper (StoreEntry *anEntry):where(anEntry) {}
 
-    void operator()(CBDataCall const &x) {
-        storeAppendPrintf(where, "%s\t%s\t%d\n", x.label, x.file, x.line);
+    void operator()(CBDataCall * const &x) {
+        storeAppendPrintf(where, "%s\t%s\t%d\n", x->label, x->file, x->line);
     }
 
     StoreEntry *where;
@@ -626,7 +628,7 @@ struct CBDataHistoryDumper : public CBDataDumper {
         CBDataDumper::operator()(x);
         storeAppendPrintf(where, "\n");
         storeAppendPrintf(where, "Action\tFile\tLine\n");
-        for_each (x.calls,callDumper);
+        std::for_each (x.calls.begin(), x.calls.end(), callDumper);
         storeAppendPrintf(where, "\n");
     }
 
@@ -1353,7 +1353,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         bool replyMatchRequest = rep->content_range != NULL ?
                                  request->range->contains(rep->content_range->spec) :
                                  true;
-        const int spec_count = http->request->range->specs.count;
+        const int spec_count = http->request->range->specs.size();
         int64_t actual_clen = -1;
 
         debugs(33, 3, "clientBuildRangeHeader: range spec count: " <<
@@ -1705,7 +1705,7 @@ ClientSocketContext::canPackMoreRanges() const
     if (!http->range_iter.debt()) {
         debugs(33, 5, HERE << "At end of current range spec for " << clientConnection);
 
-        if (http->range_iter.pos.incrementable())
+        if (http->range_iter.pos != http->range_iter.end)
             ++http->range_iter.pos;
 
         http->range_iter.updateSpec();
@@ -1140,6 +1140,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
              */
             node->readBuffer.offset = request->range->lowestOffset(0);
             http->range_iter.pos = request->range->begin();
+            http->range_iter.end = request->range->end();
             http->range_iter.valid = true;
         }
     }
@@ -47,7 +47,8 @@ Comm::AcceptLimiter::kick()
     debugs(5, 5, "size=" << deferred_.size());
     while (deferred_.size() > 0 && fdNFree() >= RESERVED_FD) {
         /* NP: shift() is equivalent to pop_front(). Giving us a FIFO queue. */
-        TcpAcceptor::Pointer temp = deferred_.shift();
+        TcpAcceptor::Pointer temp = deferred_.front();
+        deferred_.erase(deferred_.begin());
         if (temp.valid()) {
             debugs(5, 5, "doing one.");
             -- temp->isLimited;
@@ -1,9 +1,10 @@
 #ifndef _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 #define _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 
-#include "base/Vector.h"
 #include "comm/TcpAcceptor.h"
 
+#include <vector>
+
 namespace Comm
 {
 
@@ -24,7 +25,7 @@ namespace Comm
  * or to NULL an entry while scanning the list for empty spaces.
  * Side effect: TcpAcceptor->kick() becomes allowed to pull off multiple accept()'s in bunches
  *
- * 2) re-implement as a list instead of vector?
+ * 2) re-implement as a std::queue instead of std::vector
  * storing head/tail pointers for fast push/pop and avoiding the whole shift() overhead
  */
 class AcceptLimiter
@@ -47,7 +48,7 @@ class AcceptLimiter
     static AcceptLimiter Instance_;
 
     /** FIFO queue */
-    Vector<TcpAcceptor::Pointer> deferred_;
+    std::vector<TcpAcceptor::Pointer> deferred_;
 };
 
 }; // namepace Comm
@@ -2,7 +2,8 @@
 #define _SQUID_COMM_FORWARD_H
 
 #include "base/RefCount.h"
-#include "base/Vector.h"
+
+#include <vector>
 
 namespace Comm
 {
@@ -11,7 +12,7 @@ class Connection;
 
 typedef RefCount<Comm::Connection> ConnectionPointer;
 
-typedef Vector<Comm::ConnectionPointer> ConnectionList;
+typedef std::vector<Comm::ConnectionPointer> ConnectionList;
 
 bool IsConnOpen(const Comm::ConnectionPointer &conn);
 
@@ -42,7 +42,6 @@
 #include "squid.h"
 
 #if USE_DELAY_POOLS
-#include "base/Vector.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
 #include "CommonPool.h"
@@ -592,7 +591,7 @@ DelayPools::Update(void *unused)
 
     LastUpdate = squid_curtime;
 
-    Vector<Updateable *>::iterator pos = toUpdate.begin();
+    std::vector<Updateable *>::iterator pos = toUpdate.begin();
 
     while (pos != toUpdate.end()) {
         (*pos)->update(incr);
@@ -610,15 +609,15 @@ DelayPools::registerForUpdates(Updateable *anObject)
 void
 DelayPools::deregisterForUpdates (Updateable *anObject)
 {
-    Vector<Updateable *>::iterator pos = toUpdate.begin();
+    std::vector<Updateable *>::iterator pos = toUpdate.begin();
 
     while (pos != toUpdate.end() && *pos != anObject) {
         ++pos;
     }
 
     if (pos != toUpdate.end()) {
         /* move all objects down one */
-        Vector<Updateable *>::iterator temp = pos;
+        std::vector<Updateable *>::iterator temp = pos;
         ++pos;
 
         while (pos != toUpdate.end()) {
@@ -631,7 +630,7 @@ DelayPools::deregisterForUpdates (Updateable *anObject)
     }
 }
 
-Vector<Updateable *> DelayPools::toUpdate;
+std::vector<Updateable *> DelayPools::toUpdate;
 
 void
 DelayPools::Stats(StoreEntry * sentry)
@@ -119,7 +119,7 @@ error_hard_text[] = {
 };
 
 /// \ingroup ErrorPageInternal
-static Vector<ErrorDynamicPageInfo *> ErrorDynamicPages;
+static std::vector<ErrorDynamicPageInfo *> ErrorDynamicPages;
 
 /* local prototypes */
 
@@ -204,7 +204,7 @@ errorInitialize(void)
             /** \par
              * Index any unknown file names used by deny_info.
              */
-            ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
+            ErrorDynamicPageInfo *info = ErrorDynamicPages.at(i - ERR_MAX);
             assert(info && info->id == i && info->page_name);
 
             const char *pg = info->page_name;
@@ -245,8 +245,10 @@ errorClean(void)
         safe_free(error_text);
     }
 
-    while (ErrorDynamicPages.size())
-        errorDynamicPageInfoDestroy(ErrorDynamicPages.pop_back());
+    while (!ErrorDynamicPages.empty()) {
+        errorDynamicPageInfoDestroy(ErrorDynamicPages.back());
+        ErrorDynamicPages.pop_back();
+    }
 
     error_page_count = 0;
 
@@ -531,7 +533,7 @@ errorPageId(const char *page_name)
     }
 
     for (size_t j = 0; j < ErrorDynamicPages.size(); ++j) {
-        if (strcmp(ErrorDynamicPages.items[j]->page_name, page_name) == 0)
+        if (strcmp(ErrorDynamicPages[j]->page_name, page_name) == 0)
             return j + ERR_MAX;
     }
 
@@ -561,7 +563,7 @@ errorPageName(int pageId)
         return err_type_str[pageId];
 
     if (pageId >= ERR_MAX && pageId - ERR_MAX < (ssize_t)ErrorDynamicPages.size())
-        return ErrorDynamicPages.items[pageId - ERR_MAX]->page_name;
+        return ErrorDynamicPages[pageId - ERR_MAX]->page_name;
 
     return "ERR_UNKNOWN";	/* should not happen */
 }
@@ -593,8 +595,8 @@ ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
 {
     memset(&ftp, 0, sizeof(ftp));
 
-    if (page_id >= ERR_MAX && ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect != Http::scNone)
-        httpStatus = ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect;
+    if (page_id >= ERR_MAX && ErrorDynamicPages[page_id - ERR_MAX]->page_redirect != Http::scNone)
+        httpStatus = ErrorDynamicPages[page_id - ERR_MAX]->page_redirect;
 
     if (req != NULL) {
         request = req;
@@ -32,12 +32,14 @@
  */
 
 #include "squid.h"
-#include "base/Vector.h"
 #include "Debug.h"
 #include "esi/CustomParser.h"
+#include "fatal.h"
 #include "libTrie/Trie.h"
 #include "libTrie/TrieCharTransform.h"
 
+#include <vector>
+
 Trie *ESICustomParser::SearchTrie=NULL;
 
 EsiParserDefinition(ESICustomParser);
@@ -147,7 +149,7 @@ ESICustomParser::parse(char const *dataToParse, size_t const lengthOfData, bool
 
             *tagEnd = '\0';
 
-            Vector<char *>attributes;
+            std::vector<char *>attributes;
 
             char *attribute = const_cast<char *>(endofName + 1);
 
@@ -205,7 +207,8 @@ ESICustomParser::parse(char const *dataToParse, size_t const lengthOfData, bool
                 attribute = end + 1;
             }
 
-            theClient->start (tag + 1, (const char **)attributes.items, attributes.size() >> 1);
+            // TODO: after c++11, replace &attributes.front() with attributes.data()
+            theClient->start (tag + 1, const_cast<const char **>(&attributes.front()), attributes.size() >> 1);
             /* TODO: attributes */
 
             if (*(tagEnd - 1) == '/')
@@ -167,8 +167,10 @@ ESIVarState::~ESIVarState()
 {
     freeResources();
 
-    while (variablesForCleanup.size())
-        delete variablesForCleanup.pop_back();
+    while (!variablesForCleanup.empty()) {
+        delete variablesForCleanup.back();
+        variablesForCleanup.pop_back();
+    }
 
     delete defaultVariable;
 }
@@ -32,11 +32,12 @@
 #ifndef SQUID_ESIVARSTATE_H
 #define SQUID_ESIVARSTATE_H
 
-#include "base/Vector.h"
 #include "esi/Segment.h"
 #include "HttpHeader.h"
 #include "libTrie/Trie.h"
 
+#include <vector>
+
 class HttpReply;
 
 /* esi variable replacement logic */
@@ -117,7 +118,7 @@ class ESIVarState
     void doIt ();
     void setupUserAgent();
     Trie variables;
-    Vector<Variable*> variablesForCleanup;
+    std::vector<Variable*> variablesForCleanup;
     Variable *defaultVariable;
 };
 
@@ -33,7 +33,6 @@
 #define SQUID_EVENT_H
 
 #include "AsyncEngine.h"
-#include "base/Vector.h"
 #include "MemPool.h"
 
 class StoreEntry;
@@ -145,8 +145,8 @@ class SwapDirRr: public Ipc::Mem::RegisteredRunner
     virtual void create();
 
 private:
-    Vector<SwapDir::DirMap::Owner *> mapOwners;
-    Vector< Ipc::Mem::Owner<Ipc::Mem::PageStack> *> freeSlotsOwners;
+    std::vector<SwapDir::DirMap::Owner *> mapOwners;
+    std::vector< Ipc::Mem::Owner<Ipc::Mem::PageStack> *> freeSlotsOwners;
 };
 
 } // namespace Rock
@@ -226,8 +226,10 @@ Fs::Ufs::UFSSwapDir::changeIO(DiskIOModule *module)
     IO->io = anIO;
     /* Change the IO Options */
 
-    if (currentIOOptions && currentIOOptions->options.size() > 2)
-        delete currentIOOptions->options.pop_back();
+    if (currentIOOptions && currentIOOptions->options.size() > 2) {
+        delete currentIOOptions->options.back();
+        currentIOOptions->options.pop_back();
+    }
 
     /* TODO: factor out these 4 lines */
     ConfigOption *ioOptions = IO->io->getOptionTree();
@@ -6,7 +6,6 @@
 #ifndef SQUID_IPC_COORDINATOR_H
 #define SQUID_IPC_COORDINATOR_H
 
-#include "base/Vector.h"
 #include "ipc/Messages.h"
 #include "ipc/Port.h"
 #include "ipc/SharedListen.h"
@@ -19,8 +19,7 @@ Kids::Kids()
 /// maintain n kids
 void Kids::init()
 {
-    if (storage.size() > 0)
-        storage.clean();
+    storage.clear();
 
     storage.reserve(NumberOfKids());
 
@@ -4,9 +4,10 @@
 #ifndef SQUID_IPC_KIDS_H
 #define SQUID_IPC_KIDS_H
 
-#include "base/Vector.h"
 #include "ipc/Kid.h"
 
+#include <vector>
+
 /// a collection of kids
 class Kids
 {
@@ -46,7 +47,7 @@ class Kids
     size_t count() const;
 
 private:
-    Vector<Kid> storage;
+    std::vector<Kid> storage;
 };
 
 extern Kids TheKids; ///< All kids being maintained
@@ -5,7 +5,6 @@
 #define SQUID_IPC_QUEUE_H
 
 #include "base/InstanceId.h"
-#include "base/Vector.h"
 #include "Debug.h"
 #include "ipc/AtomicWord.h"
 #include "ipc/mem/FlexibleArray.h"
@@ -51,7 +51,6 @@
 #include "RequestFlags.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
-#include "Stack.h"
 #include "StatCounters.h"
 #include "stmem.h"
 #include "Store.h"
@@ -72,6 +71,7 @@
 #endif
 
 #include <climits>
+#include <stack>
 
 #define REBUILD_TIMESTAMP_DELTA_MAX 2
 
@@ -124,7 +124,7 @@ static EVH storeLateRelease;
 /*
  * local variables
  */
-static Stack<StoreEntry*> LateReleaseStack;
+static std::stack<StoreEntry*> LateReleaseStack;
 MemAllocator *StoreEntry::pool = NULL;
 
 StorePointer Store::CurrentRoot = NULL;
@@ -1261,7 +1261,7 @@ StoreEntry::release()
             // lock the entry until rebuilding is done
             lock("storeLateRelease");
             setReleaseFlag();
-            LateReleaseStack.push_back(this);
+            LateReleaseStack.push(this);
         } else {
             destroyStoreEntry(static_cast<hash_link *>(this));
             // "this" is no longer valid
@@ -1289,21 +1289,21 @@ static void
 storeLateRelease(void *unused)
 {
     StoreEntry *e;
-    int i;
     static int n = 0;
 
     if (StoreController::store_dirs_rebuilding) {
         eventAdd("storeLateRelease", storeLateRelease, NULL, 1.0, 1);
         return;
     }
 
-    for (i = 0; i < 10; ++i) {
-        e = LateReleaseStack.count ? LateReleaseStack.pop() : NULL;
-
-        if (e == NULL) {
-            /* done! */
+    // TODO: this works but looks unelegant.
+    for (int i = 0; i < 10; ++i) {
+        if (LateReleaseStack.empty()) {
             debugs(20, DBG_IMPORTANT, "storeLateRelease: released " << n << " objects");
             return;
+        } else {
+            e = LateReleaseStack.top();
+            LateReleaseStack.pop();
         }
 
         e->unlock("storeLateRelease");
@@ -1366,7 +1366,7 @@ StoreSearchHashIndex::next(void (aCallback)(void *), void *aCallbackData)
 bool
 StoreSearchHashIndex::next()
 {
-    if (entries.size())
+    if (!entries.empty())
         entries.pop_back();
 
     while (!isDone() && !entries.size())
@@ -4,10 +4,13 @@
 #include "tests/STUB.h"
 
 #include "DiskIO/DiskIOModule.h"
+
+#include <vector>
+
 void DiskIOModule::SetupAllModules() STUB
 void DiskIOModule::ModuleAdd(DiskIOModule &) STUB
 void DiskIOModule::FreeAllModules() STUB
 void DiskIOModule::PokeAllModules() STUB
 DiskIOModule *DiskIOModule::Find(char const *) STUB_RETVAL(NULL)
 DiskIOModule *DiskIOModule::FindDefault() STUB_RETVAL(NULL)
-Vector<DiskIOModule*> const &DiskIOModule::Modules() STUB_RETSTATREF(Vector<DiskIOModule*>)
+std::vector<DiskIOModule*> const &DiskIOModule::Modules() STUB_RETSTATREF(std::vector<DiskIOModule*>)
@@ -21,10 +21,11 @@ AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user) STUB
 Auth::User::Pointer AuthUserHashPointer::user() const STUB_RETVAL(NULL)
 
 #include "auth/Scheme.h"
-Vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
+#include <vector>
+std::vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
 void Auth::Scheme::AddScheme(Auth::Scheme::Pointer) STUB
 Auth::Scheme::Pointer Auth::Scheme::Find(const char *) STUB_RETVAL(NULL)
-Vector<Auth::Scheme::Pointer> & Auth::Scheme::GetSchemes() STUB_RETVAL(*_Schemes);
+std::vector<Auth::Scheme::Pointer> & Auth::Scheme::GetSchemes() STUB_RETVAL(*_Schemes);
 void Auth::Scheme::FreeAll() STUB
 
 #include "auth/User.h"
@@ -1,19 +0,0 @@
-#define SQUID_UNIT_TEST 1
-#include "squid.h"
-#include "base/Vector.h"
-#include "tests/testVector.h"
-
-#include <cppunit/TestAssert.h>
-
-CPPUNIT_TEST_SUITE_REGISTRATION( testVector );
-
-void testVector::all()
-{
-    CPPUNIT_ASSERT_EQUAL(1 ,  1);
-    Vector<int> aArray;
-    CPPUNIT_ASSERT_EQUAL(static_cast<size_t>(0), aArray.size());
-    aArray.push_back(2);
-    CPPUNIT_ASSERT_EQUAL(static_cast<size_t>(1), aArray.size());
-    CPPUNIT_ASSERT_EQUAL(2, aArray.back());
-    CPPUNIT_ASSERT_EQUAL(static_cast<size_t>(1), aArray.size());
-}
@@ -1,24 +0,0 @@
-#ifndef SQUID_SRC_TESTS_TESTVECTOR_H
-#define SQUID_SRC_TESTS_TESTVECTOR_H
-
-#include <cppunit/extensions/HelperMacros.h>
-
-/*
- * A test case that is designed to produce
- * example errors and failures
- *
- */
-
-class testVector : public CPPUNIT_NS::TestFixture
-{
-    CPPUNIT_TEST_SUITE( testVector );
-    CPPUNIT_TEST( all );
-    CPPUNIT_TEST_SUITE_END();
-
-public:
-
-protected:
-    void all();
-};
-
-#endif
@@ -86,7 +86,7 @@ testRangeParser(char const *rangestring)
 
     HttpHdrRange copy(*range);
 
-    assert (copy.specs.count == range->specs.count);
+    assert (copy.specs.size() == range->specs.size());
 
     HttpHdrRange::iterator pos = range->begin();
 
@@ -111,7 +111,7 @@ void
 testRangeIter ()
 {
     HttpHdrRange *range=rangeFromString("bytes=0-3, 1-, -2");
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
     size_t counter = 0;
     HttpHdrRange::iterator i = range->begin();
 
@@ -132,21 +132,21 @@ void
 testRangeCanonization()
 {
     HttpHdrRange *range=rangeFromString("bytes=0-3, 1-, -2");
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
 
     /* 0-3 needs a content length of 4 */
     /* This passes in the extant code - but should it? */
 
     if (!range->canonize(3))
         exit(1);
 
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
 
     delete range;
 
     range=rangeFromString("bytes=0-3, 1-, -2");
 
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
 
     /* 0-3 needs a content length of 4 */
     if (!range->canonize(4))
@@ -156,7 +156,7 @@ testRangeCanonization()
 
     range=rangeFromString("bytes=3-6");
 
-    assert (range->specs.count == 1);
+    assert (range->specs.size() == 1);
 
     /* 3-6 needs a content length of 4 or more */
     if (range->canonize(3))
@@ -166,7 +166,7 @@ testRangeCanonization()
 
     range=rangeFromString("bytes=3-6");
 
-    assert (range->specs.count == 1);
+    assert (range->specs.size() == 1);
 
     /* 3-6 needs a content length of 4 or more */
     if (!range->canonize(4))
@@ -176,12 +176,12 @@ testRangeCanonization()
 
     range=rangeFromString("bytes=1-1,2-3");
 
-    assert (range->specs.count == 2);
+    assert (range->specs.size()== 2);
 
     if (!range->canonize(4))
         exit(1);
 
-    assert (range->specs.count == 2);
+    assert (range->specs.size() == 2);
 
     delete range;
 }
@@ -33,7 +33,6 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
-#include "base/Vector.h"
 #include "CachePeer.h"
 #include "client_side.h"
 #include "client_side_request.h"
@@ -234,7 +233,7 @@ TunnelStateData::~TunnelStateData()
     debugs(26, 3, "TunnelStateData destructed this=" << this);
     assert(noConnections());
     xfree(url);
-    serverDestinations.clean();
+    serverDestinations.clear();
     delete connectRespBuf;
 }
 
@@ -775,7 +774,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
         /* At this point only the TCP handshake has failed. no data has been passed.
          * we are allowed to re-try the TCP-level connection to alternate IPs for CONNECT.
          */
-        tunnelState->serverDestinations.shift();
+        tunnelState->serverDestinations.erase(tunnelState->serverDestinations.begin());
         if (status != COMM_TIMEOUT && tunnelState->serverDestinations.size() > 0) {
             /* Try another IP of this destination host */
 
@@ -31,7 +31,6 @@ endif
 TESTS += debug \
 	syntheticoperators \
 	VirtualDeleteOperator \
-	StackTest \
 	splay\
 	MemPoolTest\
 	mem_node_test\
@@ -46,7 +45,6 @@ check_PROGRAMS += debug \
 		mem_node_test\
 		mem_hdr_test \
 		splay \
-		StackTest \
 		syntheticoperators \
 		VirtualDeleteOperator
 
@@ -89,8 +87,6 @@ MemPoolTest_SOURCES = MemPoolTest.cc
 
 splay_SOURCES = splay.cc
 
-StackTest_SOURCES = StackTest.cc $(DEBUG_SOURCE)
-
 syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
 
 VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
@@ -1,56 +0,0 @@
-
-/*
- * DEBUG: section 19    Store Memory Primitives
- * AUTHOR: Robert Collins
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003  Robert Collins <robertc@squid-cache.org>
- */
-
-#include "squid.h"
-#include "Stack.h"
-
-int
-main(int argc, char **argv)
-{
-    Stack<int> aStack;
-    assert (aStack.size() == 0);
-    aStack.push_back(2);
-    assert (aStack.size() == 1);
-    assert (aStack.top() == 2);
-    assert (aStack.pop() == 2);
-    assert (aStack.size() == 0);
-    Stack<> oldStack;
-    assert (oldStack.size() == 0);
-    oldStack.push_back(&aStack);
-    assert (oldStack.size() == 1);
-    assert (oldStack.top() == &aStack);
-    assert (oldStack.pop() == &aStack);
-    assert (oldStack.size() == 0);
-    return 0;
-}