@@ -0,0 +1,247 @@
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#define OR(A,B) (A ? A : B)
+
+#define ACL_NAME_SZ 32
+#define BROWSERNAMELEN 128
+
+#define ACL_SUNDAY	0x01
+#define ACL_MONDAY	0x02
+#define ACL_TUESDAY	0x04
+#define ACL_WEDNESDAY	0x08
+#define ACL_THURSDAY	0x10
+#define ACL_FRIDAY	0x20
+#define ACL_SATURDAY	0x40
+#define ACL_ALLWEEK	0x7F
+#define ACL_WEEKDAYS	0x3E
+
+#define DefaultDnsChildrenMax		32	/* 32 processes */
+#define DefaultRedirectChildrenMax	32	/* 32 processes */
+#define MAXHTTPPORTS			12
+
+#define COMM_OK		  (0)
+#define COMM_ERROR	 (-1)
+#define COMM_NO_HANDLER	 (-2)
+#define COMM_NOMESSAGE	 (-3)
+#define COMM_TIMEOUT	 (-4)
+#define COMM_SHUTDOWN	 (-5)
+#define COMM_INPROGRESS  (-6)
+#define COMM_ERR_CONNECT (-7)
+#define COMM_ERR_DNS     (-8)
+
+#define COMM_NONBLOCKING  (0x1)
+#define COMM_NOCLOEXEC	  (0x8)
+
+/* Select types. */
+#define COMM_SELECT_READ   (0x1)
+#define COMM_SELECT_WRITE  (0x2)
+#define MAX_DEBUG_SECTIONS 100
+
+#ifdef HAVE_SYSLOG
+#define debug(SECTION, LEVEL) \
+        ((_db_level = (LEVEL)) > debugLevels[SECTION]) ? (void) 0 : _db_print
+#else
+#define debug(SECTION, LEVEL) \
+        ((LEVEL) > debugLevels[SECTION]) ? (void) 0 : _db_print
+#endif
+#define safe_free(x)	if (x) { xxfree(x); x = NULL; }
+
+#define DISK_OK                   (0)
+#define DISK_ERROR               (-1)
+#define DISK_EOF                 (-2)
+#define DISK_FILE_NOT_FOUND      (-5)
+#define DISK_NO_SPACE_LEFT       (-6)
+
+#define DNS_FLAG_ALIVE          0x01
+#define DNS_FLAG_BUSY           0x02
+#define DNS_FLAG_CLOSING        0x04
+
+#define DNS_INBUF_SZ 4096
+
+#define FD_CLOSE_REQUEST	0x02
+#define FD_WRITE_DAEMON		0x04
+#define FD_WRITE_PENDING	0x08
+
+#define FD_DESC_SZ		64
+
+#define FQDN_BLOCKING_LOOKUP	0x01
+#define FQDN_LOOKUP_IF_MISS	0x02
+#define FQDN_LOCK_ENTRY		0x04
+
+#define FQDN_MAX_NAMES 5
+
+#define FQDNCACHE_AV_FACTOR 1000
+
+/*  
+ *  Here are some good prime number choices.  It's important not to
+ *  choose a prime number that is too close to exact powers of 2.
+ */
+#if 0
+#undef  HASH_SIZE 103		/* prime number < 128 */
+#undef  HASH_SIZE 229		/* prime number < 256 */
+#undef  HASH_SIZE 467		/* prime number < 512 */
+#undef  HASH_SIZE 977		/* prime number < 1024 */
+#undef  HASH_SIZE 1979		/* prime number < 2048 */
+#undef  HASH_SIZE 4019		/* prime number < 4096 */
+#undef  HASH_SIZE 6037		/* prime number < 6144 */
+#undef  HASH_SIZE 7951		/* prime number < 8192 */
+#undef  HASH_SIZE 12149		/* prime number < 12288 */
+#undef  HASH_SIZE 16231		/* prime number < 16384 */
+#undef  HASH_SIZE 33493		/* prime number < 32768 */
+#undef  HASH_SIZE 65357		/* prime number < 65536 */
+#endif
+
+#define  HASH_SIZE 7951		/* prime number < 8192 */
+
+#define HTTP_REPLY_FIELD_SZ 128
+
+#define BUF_TYPE_8K 	1
+#define BUF_TYPE_MALLOC 2
+
+#define ANONYMIZER_NONE		0
+#define ANONYMIZER_STANDARD	1
+#define ANONYMIZER_PARANOID	2
+
+#define ERR_MIN ERR_READ_TIMEOUT
+#define ERR_MAX ERR_PROXY_DENIED
+
+
+#define ICP_IDENT_SZ 64
+#define IDENT_NONE 0
+#define IDENT_PENDING 1
+#define IDENT_DONE 2
+
+#define IP_BLOCKING_LOOKUP	0x01
+#define IP_LOOKUP_IF_MISS	0x02
+#define IP_LOCK_ENTRY		0x04
+
+#define IPCACHE_AV_FACTOR 1000
+
+#define MAX_MIME 4096
+
+/* Mark a neighbor cache as dead if it doesn't answer this many pings */
+#define HIER_MAX_DEFICIT  20
+
+/* bitfields for peer->options */
+#define NEIGHBOR_PROXY_ONLY 0x01
+#define NEIGHBOR_NO_QUERY   0x02
+#define NEIGHBOR_DEFAULT_PARENT   0x04
+#define NEIGHBOR_ROUNDROBIN   0x08
+#define NEIGHBOR_MCAST_RESPONDER 0x10
+
+#define ICP_FLAG_HIT_OBJ     0x80000000ul
+#define ICP_FLAG_SRC_RTT     0x40000000ul
+
+#define ICP_COMMON_SZ (sizeof(icp_common_t))
+#define ICP_HDR_SZ (sizeof(icp_common_t)+sizeof(u_num32))
+
+#define ICP_OP_HIGHEST (ICP_OP_END - 1)		/* highest valid opcode */
+
+#define ICP_ERROR_MSGLEN	256	/* max size for string, incl '\0' */
+
+/* Version */
+#define ICP_VERSION_1		1
+#define ICP_VERSION_2		2
+#define ICP_VERSION_3		3
+#define ICP_VERSION_CURRENT	ICP_VERSION_2
+
+#define DIRECT_NO    0
+#define DIRECT_MAYBE 1
+#define DIRECT_YES   2
+
+#define OUTSIDE_FIREWALL 0
+#define INSIDE_FIREWALL  1
+#define NO_FIREWALL      2
+
+#define REDIRECT_AV_FACTOR 1000
+
+#define REDIRECT_NONE 0
+#define REDIRECT_PENDING 1
+#define REDIRECT_DONE 2
+
+#define REFRESH_ICASE 0x01
+
+#define  CONNECT_PORT        443
+
+#define current_stacksize(stack) ((stack)->top - (stack)->base)
+
+/* logfile status */
+#define LOG_ENABLE  1
+#define LOG_DISABLE 0
+
+#define SM_PAGE_SIZE 4096
+#define DISK_PAGE_SIZE  8192
+
+#define MIN_PENDING 		1
+#define MIN_CLIENT 		1
+
+#define BIT_SET(flag, bit) 	((flag) |= (bit))
+#define BIT_RESET(flag, bit) 	((flag) &= ~(bit))
+#define BIT_TEST(flag, bit) 	((flag) & (bit))
+
+#define EBIT_SET(flag, bit) 	((flag) |= ((1<<bit)))
+#define EBIT_RESET(flag, bit) 	((flag) &= ~((1<<bit)))
+#define EBIT_TEST(flag, bit) 	((flag) & ((1<<bit)))
+
+/* 
+ * KEY_URL              If e->key and e->url point to the same location
+ * KEY_CHANGE           If the key for this URL has been changed
+ */
+
+#define ENTRY_VALIDATED		(1<<16)
+#define READ_DEFERRED		(1<<15)
+#define ENTRY_NEGCACHED		(1<<14)
+#define HIERARCHICAL 		(1<<13)		/* can we query neighbors? */
+#define KEY_PRIVATE 		(1<<12)		/* is the key currently private? */
+#define ENTRY_DISPATCHED 	(1<<11)
+#define ENTRY_HTML 		(1<<10)
+#define KEY_CHANGE 		(1<<9)
+#define KEY_URL    		(1<<8)
+#define ENTRY_CACHABLE   	(1<<7)
+#define REFRESH_REQUEST   	(1<<6)
+#define RELEASE_REQUEST 	(1<<5)
+#define ABORT_MSG_PENDING 	(1<<4)
+#define DELAY_SENDING 		(1<<3)
+#define ENTRY_REVALIDATE 	(1<<2)
+#define DELETE_BEHIND   	(1<<1)
+
+#define MAX_FILES_PER_DIR (1<<20)
+
+#define MAX_URL  4096
+#define MAX_LOGIN_SZ  128
+
+/* bitfields for the flags member */
+#define REQ_UNUSED1		0x01
+#define REQ_NOCACHE		0x02
+#define REQ_IMS			0x04
+#define REQ_AUTH		0x08
+#define REQ_CACHABLE		0x10
+#define REQ_UNUSED2		0x20
+#define REQ_HIERARCHICAL	0x40
+#define REQ_LOOPDETECT		0x80
+#define REQ_PROXY_KEEPALIVE	0x100
+#define REQ_PROXYING		0x200
+#define REQ_REFRESH		0x400
+#define PEER_MAX_ADDRESSES 10
+#define RTT_AV_FACTOR      1000
+
+/* flags for peer->mcast.flags */
+#define PEER_COUNT_EVENT_PENDING 1
+#define PEER_COUNTING		 2
+#define ICP_AUTH_SIZE (2)	/* size of authenticator field */
+#define ICP_QUERY_SZ (sizeof(icp_query_t))
+#define ICP_HIT_SZ (sizeof(icp_hit_t))
+#define ICP_MISS_SZ (sizeof(icp_miss_t))
+#define ICP_ERROR_SZ (sizeof(icp_error_t))
+#define ICP_SEND_SZ (sizeof(icp_send_t))
+#define ICP_SENDA_SZ (sizeof(icp_senda_t))
+#define ICP_DATAB_SZ (sizeof(icp_datab_t))
+#define ICP_DATA_SZ (sizeof(icp_databe_t))
+#define ICP_MESSAGE_SZ (sizeof(icp_message_t))
+#define ICP_MESSAGE_SZ (sizeof(icp_message_t))
@@ -0,0 +1,92 @@
+
+extern FILE *debug_log;
+extern Meta_data meta_data;
+extern SquidConfig Config;
+extern SquidConfig2 Config2;
+extern cacheinfo *HTTPCacheInfo;
+extern cacheinfo *ICPCacheInfo;
+extern char *ConfigFile;	/* NULL */
+extern char *IcpOpcodeStr[];
+extern char *dns_error_message;
+extern char *log_tags[];
+extern char *tmp_error_buf;
+extern char *volatile debug_options;
+extern char ThisCache[SQUIDHOSTNAMELEN << 1];
+extern char config_input_line[BUFSIZ];
+extern const char *AclMatchedName;
+extern const char *DefaultConfigFile;	/* DEFAULT_CONFIG_FILE */
+extern const char *DefaultSwapDir;	/* DEFAULT_SWAP_DIR */
+extern const char *RequestMethodStr[];
+extern const char *cfg_filename;	/* NULL */
+extern const char *const appname; /* "squid" */
+extern const char *const close_bracket;
+extern const char *const dash_str; /* "-" */
+extern const char *const localhost; /* "127.0.0.1" */
+extern const char *const null_string; /* "" */
+extern const char *const open_bracket;
+extern const char *const version_string ; /* SQUID_VERSION */
+extern const char *const w_space; /* " \t\n\r" */
+extern const char *fdstatTypeStr[];
+extern const char *hier_strings[];
+extern const char *memStatusStr[];
+extern const char *pingStatusStr[];
+extern const char *storeStatusStr[];
+extern const char *swapStatusStr[];
+extern dnsStatData DnsStats;
+extern fde *fd_table;
+extern int Biggest_FD; /* -1 */
+extern int HttpSockets[MAXHTTPPORTS];
+extern int NDnsServersAlloc;	/* 0 */
+extern int NHttpSockets; /* 0 */
+extern int RESERVED_FD;
+extern int Squid_MaxFD; /* SQUID_MAXFD */
+extern int config_lineno;	/* 0 */
+extern int configured_once; /* 0 */
+extern int debugLevels[MAX_DEBUG_SECTIONS];
+extern int do_mallinfo;
+extern int do_reuse; /* 1 */
+extern int hash_links_allocated;
+extern int icmp_sock;
+extern int neighbors_do_private_keys;
+extern int opt_accel_uses_host; /* 0 */
+extern int opt_catch_signals; /* 1 */
+extern int opt_debug_stderr; /* 0 */
+extern int opt_dns_tests; /* 1 */
+extern int opt_foreground_rebuild; /* 0 */
+extern int opt_forwarded_for; /* 1 */
+extern int opt_mem_pools; /* 1 */
+extern int opt_no_ipcache; /* 0 */
+extern int opt_reload_hit_only; /* 0 */
+extern int opt_syslog_enable; /* 0 */
+extern int opt_udp_hit_obj; /* 0 */
+extern int opt_zap_disk_store; /* 0 */
+extern int select_loops; /* 0 */
+extern int syslog_enable;
+extern int theInIcpConnection; /* -1 */
+extern int theOutIcpConnection; /* -1 */
+extern int vhost_mode; /* 0 */
+extern int vizSock; /* -1 */
+extern iostats IOStats;
+extern stmem_stats disk_stats;
+extern stmem_stats mem_obj_pool;
+extern stmem_stats request_pool;
+extern stmem_stats sm_stats;
+extern struct _acl_deny_info_list *DenyInfoList;
+extern struct in_addr any_addr;
+extern struct in_addr local_addr;
+extern struct in_addr no_addr;
+extern struct in_addr theOutICPAddr;
+extern struct timeval current_time;
+extern time_t squid_curtime;
+extern time_t squid_starttime; /* 0 */
+extern volatile int reconfigure_pending; /* 0 */
+extern volatile int shutdown_pending; /* 0 */
+extern volatile int unbuffered_logs;	/* 0 */
+extern volatile unsigned long nudpconn; /* 0 */
+extern volatile unsigned long ntcpconn; /* 0 */
+extern int unlinkd_count; /* 0 */
+extern int fileno_stack_count; /* 0 */
+
+#ifdef HAVE_SYSLOG
+extern int _db_level;
+#endif
@@ -0,0 +1,586 @@
+
+
+extern void accessLogLog _PARAMS((AccessLogEntry *));
+extern void accessLogRotate _PARAMS((void));
+extern void accessLogClose _PARAMS((void));
+extern void accessLogOpen _PARAMS((const char *));
+extern void hierarchyNote _PARAMS((HierarchyLogEntry *, hier_code, icp_ping_data *, const char *));
+
+extern aclCheck_t *aclChecklistCreate _PARAMS((const struct _acl_access *,
+	request_t *,
+	struct in_addr src,
+	char *ua,
+	char *id));
+extern void aclNBCheck _PARAMS((aclCheck_t *, PF *, void *));
+extern int aclCheckFast _PARAMS((const struct _acl_access * A, aclCheck_t *));
+extern void aclChecklistFree _PARAMS((aclCheck_t *));
+extern int aclMatchAcl _PARAMS((struct _acl *, aclCheck_t *));
+extern void aclDestroyAccessList _PARAMS((struct _acl_access ** list));
+extern void aclDestroyAcls _PARAMS((acl **));
+extern void aclParseAccessLine _PARAMS((struct _acl_access **));
+extern void aclParseAclLine _PARAMS((acl **));
+extern struct _acl *aclFindByName _PARAMS((const char *name));
+extern char *aclGetDenyInfoUrl _PARAMS((struct _acl_deny_info_list **, const char *name));
+extern void aclParseDenyInfoLine _PARAMS((struct _acl_deny_info_list **));
+extern void aclDestroyDenyInfoList _PARAMS((struct _acl_deny_info_list **));
+extern void aclDestroyRegexList _PARAMS((struct _relist * data));
+extern int aclMatchRegex _PARAMS((relist * data, const char *word));
+extern void aclParseRegexList _PARAMS((void *curlist));
+
+
+extern int aio_cancel _PARAMS((aio_result_t *));
+extern int aio_open _PARAMS((const char *, int, mode_t, aio_result_t *));
+extern int aio_read _PARAMS((int, char *, int, off_t, int, aio_result_t *));
+extern int aio_write _PARAMS((int, char *, int, off_t, int, aio_result_t *));
+extern int aio_close _PARAMS((int, aio_result_t *));
+extern int aio_stat _PARAMS((const char *, struct stat *, aio_result_t *));
+extern int aio_unlink _PARAMS((const char *, aio_result_t *));
+extern int aio_opendir _PARAMS((void));
+extern aio_result_t *aio_poll_done();
+
+
+extern void aioCancel _PARAMS((int));
+extern void aioOpen _PARAMS((const char *, int, mode_t, AIOCB *, void *));
+extern void aioClose _PARAMS((int));
+extern void aioWrite _PARAMS((int, char *, int, AIOCB *, void *));
+extern void aioRead _PARAMS((int, char *, int, AIOCB *, void *));
+extern void aioStat _PARAMS((char *, struct stat *, AIOCB *, void *));
+extern void aioUnlink _PARAMS((const char *, AIOCB *, void *));
+extern void aioCheckCallbacks _PARAMS((void));
+
+extern int parseConfigFile _PARAMS((const char *file_name));
+extern int setCacheSwapMax _PARAMS((int size));
+extern void intlistDestroy _PARAMS((intlist **));
+extern void wordlistDestroy _PARAMS((wordlist **));
+extern void configFreeMemory _PARAMS((void));
+extern char *cachemgr_getpassword _PARAMS((cachemgr_passwd **, char *));
+
+extern void cbdataInit _PARAMS((void));
+extern void cbdataAdd _PARAMS((void *p));
+extern void cbdataFree _PARAMS((void *p));
+extern void cbdataLock _PARAMS((void *p));
+extern void cbdataUnlock _PARAMS((void *p));
+extern int cbdataValid _PARAMS((void *p));
+extern void cbdataDump _PARAMS((StoreEntry *));
+
+void clientdbInit _PARAMS((void));
+void clientdbUpdate _PARAMS((struct in_addr, log_type, protocol_t));
+int clientdbDeniedPercent _PARAMS((struct in_addr));
+void clientdbDump _PARAMS((StoreEntry *));
+extern int client_info_sz;
+
+extern void clientAccessCheck _PARAMS((void *));
+extern void clientAccessCheckDone _PARAMS((int, void *));
+extern void icpProcessExpired _PARAMS((int fd, void *));
+extern int modifiedSince _PARAMS((StoreEntry *, request_t *));
+extern char *clientConstructTraceEcho _PARAMS((clientHttpRequest *));
+extern void clientPurgeRequest _PARAMS((clientHttpRequest *));
+
+#if USE_PROXY_AUTH
+const char *proxyAuthenticate(const char *headers);
+#endif /* USE_PROXY_AUTH */
+
+
+extern int commSetNonBlocking _PARAMS((int fd));
+extern void commSetCloseOnExec _PARAMS((int fd));
+extern int comm_accept _PARAMS((int fd, struct sockaddr_in *, struct sockaddr_in *));
+extern void comm_close _PARAMS((int fd));
+extern void commConnectStart _PARAMS((int fd, const char *, u_short, CNCB *, void *));
+extern int comm_connect_addr _PARAMS((int sock, const struct sockaddr_in *));
+extern int comm_init _PARAMS((void));
+extern int comm_listen _PARAMS((int sock));
+extern int comm_open _PARAMS((int, int, struct in_addr, u_short port, int, const char *note));
+extern u_short comm_local_port _PARAMS((int fd));
+#if HAVE_POLL
+extern int comm_poll _PARAMS((time_t));
+#else
+extern int comm_select _PARAMS((time_t));
+#endif
+extern void commSetSelect _PARAMS((int, unsigned int, PF *, void *, time_t));
+extern void comm_add_close_handler _PARAMS((int fd, PF *, void *));
+extern void comm_remove_close_handler _PARAMS((int fd, PF *, void *));
+extern int comm_udp_send _PARAMS((int fd, const char *host, u_short port, const char *buf, int len));
+extern int comm_udp_sendto _PARAMS((int fd, const struct sockaddr_in *, int size, const char *buf, int len));
+extern int fd_of_first_client _PARAMS((StoreEntry *));
+extern void comm_set_stall _PARAMS((int, int));
+extern void comm_write _PARAMS((int fd,
+	char *buf,
+	int size,
+	CWCB * handler,
+	void *handler_data,
+	FREE *));
+extern void commCallCloseHandlers _PARAMS((int fd));
+extern void commCancelWriteHandler _PARAMS((int fd));
+extern int commSetTimeout _PARAMS((int fd, int, PF *, void *));
+
+extern void _db_init _PARAMS((const char *logfile, const char *options));
+extern void _db_rotate_log _PARAMS((void));
+
+#ifdef __STDC__
+extern void _db_print _PARAMS((const char *,...));
+#else
+extern void _db_print _PARAMS(());
+#endif
+
+
+extern int file_open _PARAMS((const char *path, int mode, FOCB *, void *callback_data));
+extern void file_must_close _PARAMS((int fd));
+extern void file_close _PARAMS((int fd));
+extern int file_write _PARAMS((int fd,
+	char *buf,
+	int len,
+	DWCB * handle,
+	void *handle_data,
+	FREE *));
+extern int file_read _PARAMS((int fd,
+	char *buf,
+	int req_len,
+	int offset,
+	DRCB * handler,
+	void *client_data));
+extern int file_walk _PARAMS((int fd, FILE_WALK_HD *, void *, FILE_WALK_LHD *, void *));
+extern int disk_init _PARAMS((void));
+extern int diskWriteIsComplete _PARAMS((int));
+
+extern void statDns _PARAMS((StoreEntry *));
+extern void dnsShutdownServers _PARAMS((void));
+extern void dnsOpenServers _PARAMS((void));
+extern void dnsEnqueue _PARAMS((void *));
+extern void *dnsDequeue _PARAMS((void));
+extern dnsserver_t *dnsGetFirstAvailable _PARAMS((void));
+extern void dnsStats _PARAMS((StoreEntry *));
+extern void dnsFreeMemory _PARAMS((void));
+
+extern char *squid_error_url _PARAMS((const char *, int, int, const char *, int, const char *));
+extern char *squid_error_request _PARAMS((const char *, int, int));
+extern void errorInitialize _PARAMS((void));
+extern char *access_denied_msg _PARAMS((int, int, const char *, const char *));
+extern char *access_denied_redirect _PARAMS((int, int, const char *, const char *, const char *));
+#if USE_PROXY_AUTH
+extern char *proxy_denied_msg _PARAMS((int, int, const char *, const char *));
+#endif /* USE_PROXY_AUTH */
+extern char *authorization_needed_msg _PARAMS((const request_t *, const char *));
+extern void errorpageFreeMemory _PARAMS((void));
+
+
+extern void eventAdd _PARAMS((const char *name,
+	EVH * func,
+	void *arg,
+	time_t when));
+extern void eventRun _PARAMS((void));
+extern time_t eventNextTime _PARAMS((void));
+extern void eventDelete _PARAMS((EVH * func, void *arg));
+
+extern void fd_close _PARAMS((int fd));
+extern void fd_open _PARAMS((int fd, unsigned int type, const char *));
+extern void fd_note _PARAMS((int fd, const char *));
+extern void fd_bytes _PARAMS((int fd, int len, unsigned int type));
+extern void fdFreeMemory _PARAMS((void));
+extern void fdDumpOpen _PARAMS((void));
+
+extern void fdstat_init _PARAMS((void));
+extern void fdstat_open _PARAMS((int fd, unsigned int type));
+extern int fdstat_are_n_free_fd _PARAMS((int));
+
+extern fileMap *file_map_create _PARAMS((int));
+extern int file_map_allocate _PARAMS((fileMap *, int));
+extern int file_map_bit_set _PARAMS((fileMap *, int));
+extern int file_map_bit_test _PARAMS((fileMap *, int));
+extern void file_map_bit_reset _PARAMS((fileMap *, int));
+extern void filemapFreeMemory _PARAMS((fileMap *));
+
+
+extern void fqdncache_nbgethostbyaddr _PARAMS((struct in_addr, FQDNH *, void *));
+extern int fqdncacheUnregister _PARAMS((struct in_addr, void *));
+extern const char *fqdncache_gethostbyaddr _PARAMS((struct in_addr, int flags));
+extern void fqdncache_init _PARAMS((void));
+extern void fqdnStats _PARAMS((StoreEntry *));
+extern void fqdncacheShutdownServers _PARAMS((void));
+extern void fqdncacheOpenServers _PARAMS((void));
+extern void fqdncacheReleaseInvalid _PARAMS((const char *));
+extern const char *fqdnFromAddr _PARAMS((struct in_addr));
+extern int fqdncacheQueueDrain _PARAMS((void));
+extern void fqdncacheFreeMemory _PARAMS((void));
+extern void fqdncache_restart _PARAMS((void));
+
+extern void ftpStart _PARAMS((request_t * req, StoreEntry * entry));
+
+extern void gopherStart _PARAMS((StoreEntry *));
+extern int gopherCachable _PARAMS((const char *));
+
+
+/* init */
+extern void hash_init _PARAMS((int));
+extern hash_table *hash_create _PARAMS((HASHCMP *, int, HASHHASH *));
+extern int hash_insert _PARAMS((hash_table *, const char *, void *));
+extern int hash_delete _PARAMS((hash_table *, const char *));
+extern int hash_delete_link _PARAMS((hash_table *, hash_link *));
+extern int hash_join _PARAMS((hash_table *, hash_link *));
+extern int hash_remove_link _PARAMS((hash_table *, hash_link *));
+
+/* searching, accessing */
+extern hash_link *hash_lookup _PARAMS((hash_table *, const char *));
+extern hash_link *hash_first _PARAMS((hash_table *));
+extern hash_link *hash_next _PARAMS((hash_table *));
+extern hash_link *hash_get_bucket _PARAMS((hash_table *, unsigned int));
+extern void hashFreeMemory _PARAMS((hash_table *));
+extern HASHHASH hash_string;
+extern HASHHASH hash_url;
+extern HASHHASH hash4;
+
+extern int httpCachable _PARAMS((method_t));
+extern void proxyhttpStart _PARAMS((request_t *, StoreEntry *, peer *));
+extern void httpStart _PARAMS((request_t *, StoreEntry *));
+extern void httpParseReplyHeaders _PARAMS((const char *, struct _http_reply *));
+extern void httpProcessReplyHeader _PARAMS((HttpStateData *, const char *, int));
+extern void httpReplyHeaderStats _PARAMS((StoreEntry *));
+extern size_t httpBuildRequestHeader _PARAMS((request_t * request,
+	request_t * orig_request,
+	StoreEntry * entry,
+	size_t * in_len,
+	char *hdr_out,
+	size_t out_sz,
+	int cfd));
+
+extern void icmpOpen _PARAMS((void));
+extern void icmpClose _PARAMS((void));
+extern void icmpPing _PARAMS((struct in_addr to));
+extern void icmpSourcePing _PARAMS((struct in_addr to, const icp_common_t *, const char *url));
+extern void icmpDomainPing _PARAMS((struct in_addr to, const char *domain));
+
+
+extern void *icpCreateMessage _PARAMS((icp_opcode opcode,
+	int flags,
+	const char *url,
+	int reqnum,
+	int pad));
+extern void icpUdpSend _PARAMS((int fd,
+	const struct sockaddr_in *,
+	icp_common_t * msg,
+	log_type,
+	protocol_t));
+extern PF icpHandleUdp;
+extern PF httpAccept;
+extern void icpSendERROR _PARAMS((int fd,
+	log_type errorCode,
+	const char *text,
+	clientHttpRequest *,
+	int httpCode));
+extern void AppendUdp _PARAMS((icpUdpData *));
+extern void icpParseRequestHeaders _PARAMS((clientHttpRequest *));
+extern void icpProcessRequest _PARAMS((int, clientHttpRequest *));
+extern PF icpUdpReply;
+extern CWCB icpSendERRORComplete;
+extern STCB icpSendMoreData;
+
+
+extern void ipcache_nbgethostbyname _PARAMS((const char *name,
+	IPH * handler,
+	void *handlerData));
+extern EVH ipcache_purgelru;
+extern const ipcache_addrs *ipcache_gethostbyname _PARAMS((const char *, int flags));
+extern void ipcacheInvalidate _PARAMS((const char *));
+extern void ipcacheReleaseInvalid _PARAMS((const char *));
+extern void ipcacheOpenServers _PARAMS((void));
+extern void ipcacheShutdownServers _PARAMS((void));
+extern void ipcache_init _PARAMS((void));
+extern void stat_ipcache_get _PARAMS((StoreEntry *));
+extern int ipcacheQueueDrain _PARAMS((void));
+extern void ipcacheOpenServers _PARAMS((void));
+extern void ipcacheCycleAddr _PARAMS((const char *name));
+extern void ipcacheRemoveBadAddr _PARAMS((const char *name, struct in_addr));
+extern void ipcacheFreeMemory _PARAMS((void));
+extern ipcache_addrs *ipcacheCheckNumeric _PARAMS((const char *name));
+extern void ipcache_restart _PARAMS((void));
+extern int ipcacheUnregister _PARAMS((const char *name, void *data));
+
+extern char *mime_get_header _PARAMS((const char *mime, const char *header));
+extern char *mime_headers_end _PARAMS((const char *mime));
+extern int mk_mime_hdr _PARAMS((char *result, const char *type, int size, time_t ttl, time_t lmt));
+extern void mimeInit _PARAMS((char *filename));
+extern char *mimeGetContentEncoding _PARAMS((const char *fn));
+extern char *mimeGetContentType _PARAMS((const char *fn));
+extern char *mimeGetIcon _PARAMS((const char *fn));
+extern char mimeGetTransferMode _PARAMS((const char *fn));
+
+extern int mcastSetTtl _PARAMS((int, int));
+extern IPH mcastJoinGroups;
+extern void mcastJoinVizSock _PARAMS((void));
+
+/* Labels for hierachical log file */
+/* put them all here for easier reference when writing a logfile analyzer */
+
+
+extern peer *getFirstPeer _PARAMS((void));
+extern peer *getFirstUpParent _PARAMS((request_t *));
+extern peer *getNextPeer _PARAMS((peer *));
+extern peer *getSingleParent _PARAMS((request_t *));
+extern int neighborsCount _PARAMS((request_t *));
+extern int neighborsUdpPing _PARAMS((request_t *,
+	StoreEntry *,
+	IRCB * callback,
+	void *data,
+	int *exprep));
+extern void neighborAddDomainPing _PARAMS((const char *, const char *));
+extern void neighborAddDomainType _PARAMS((const char *, const char *, const char *));
+extern void neighborAddAcl _PARAMS((const char *, const char *));
+extern void neighborsUdpAck _PARAMS((int, const char *, icp_common_t *, const struct sockaddr_in *, StoreEntry *, char *, int));
+extern void neighborAdd _PARAMS((const char *, const char *, int, int, int, int, int));
+extern void neighbors_open _PARAMS((int));
+extern void neighborsDestroy _PARAMS((void));
+extern peer *neighborFindByName _PARAMS((const char *));
+extern void neighbors_init _PARAMS((void));
+extern peer *getDefaultParent _PARAMS((request_t * request));
+extern peer *getRoundRobinParent _PARAMS((request_t * request));
+extern int neighborUp _PARAMS((const peer * e));
+extern void peerDestroy _PARAMS((peer * e));
+extern char *neighborTypeStr _PARAMS((const peer * e));
+extern void peerCheckConnectStart _PARAMS((peer *));
+
+extern void netdbHandlePingReply _PARAMS((const struct sockaddr_in * from, int hops, int rtt));
+extern void netdbPingSite _PARAMS((const char *hostname));
+extern void netdbInit _PARAMS((void));
+extern void netdbDump _PARAMS((StoreEntry *));
+extern int netdbHops _PARAMS((struct in_addr));
+extern void netdbFreeMemory _PARAMS((void));
+extern int netdbHostHops _PARAMS((const char *host));
+extern int netdbHostRtt _PARAMS((const char *host));
+extern void netdbUpdatePeer _PARAMS((request_t *, peer * e, int rtt, int hops));
+
+extern void objcachePasswdAdd _PARAMS((cachemgr_passwd **, char *, wordlist *));
+extern void objcachePasswdDestroy _PARAMS((cachemgr_passwd ** a));
+extern void objcacheStart _PARAMS((int fd, StoreEntry *));
+
+
+
+extern void peerSelect _PARAMS((request_t *, StoreEntry *, PSC *, PSC *, void *data));
+extern int peerSelectDirect _PARAMS((request_t *));
+extern peer *peerGetSomeParent _PARAMS((request_t *, hier_code *));
+extern int matchInsideFirewall _PARAMS((const char *));
+extern void peerSelectInit _PARAMS((void));
+
+extern void protoDispatch _PARAMS((int, StoreEntry *, request_t *));
+
+extern int protoUnregister _PARAMS((StoreEntry *, request_t *, struct in_addr));
+extern void protoStart _PARAMS((int, StoreEntry *, peer *, request_t *));
+extern void protoCancelTimeout _PARAMS((int fd, StoreEntry *));
+extern int protoAbortFetch _PARAMS((StoreEntry * entry));
+
+
+extern void redirectStart _PARAMS((clientHttpRequest *, RH *, void *));
+extern void redirectOpenServers _PARAMS((void));
+extern void redirectShutdownServers _PARAMS((void));
+extern void redirectStats _PARAMS((StoreEntry *));
+extern int redirectUnregister _PARAMS((const char *url, void *));
+extern void redirectFreeMemory _PARAMS((void));
+
+extern void refreshFreeMemory _PARAMS((void));
+extern void refreshAddToList _PARAMS((const char *, int, time_t, int, time_t));
+extern int refreshCheck _PARAMS((const StoreEntry *, const request_t *, time_t delta));
+extern time_t getMaxAge _PARAMS((const char *url));
+
+
+
+extern void serverConnectionsClose _PARAMS((void));
+extern void shut_down _PARAMS((int));
+
+
+extern void start_announce _PARAMS((void *unused));
+extern void sslStart _PARAMS((int fd, const char *, request_t *, int *sz));
+extern void waisStart _PARAMS((request_t *, StoreEntry *));
+extern void storeDirClean _PARAMS((void *unused));
+extern void passStart _PARAMS((int, const char *, request_t *, int *));
+extern void identStart _PARAMS((int, ConnStateData *, IDCB * callback));
+extern int httpAnonAllowed _PARAMS((const char *line));
+extern int httpAnonDenied _PARAMS((const char *line));
+
+extern void *pop _PARAMS((Stack *));
+extern int empty_stack _PARAMS((const Stack *));
+extern int full_stack _PARAMS((const Stack *));
+extern void push _PARAMS((Stack *, void *));
+extern void init_stack _PARAMS((Stack *, int));
+extern void stackFreeMemory _PARAMS((Stack *));
+
+extern void stat_init _PARAMS((cacheinfo **, const char *));
+extern void stat_get _PARAMS((const char *req, StoreEntry *));
+extern void log_clear _PARAMS((StoreEntry *));
+extern void log_disable _PARAMS((StoreEntry *));
+extern void log_enable _PARAMS((StoreEntry *));
+extern void log_get_start _PARAMS((StoreEntry *));
+extern void log_status_get _PARAMS((StoreEntry *));
+extern void info_get _PARAMS((StoreEntry *));
+extern void server_list _PARAMS((StoreEntry *));
+extern void parameter_get _PARAMS((StoreEntry *));
+extern void squid_get_start _PARAMS((StoreEntry *));
+
+/* To reduce memory fragmentation, we now store the memory version of an
+ * object in fixed size blocks of size PAGE_SIZE and instead of calling 
+ * malloc and free, we manage our own fixed block free list.   
+ */
+
+extern char *get_free_4k_page _PARAMS((void));
+extern char *get_free_8k_page _PARAMS((void));
+extern void *get_free_request_t _PARAMS((void));
+extern void *get_free_mem_obj _PARAMS((void));
+extern mem_hdr *memInit _PARAMS((void));
+extern void put_free_4k_page _PARAMS((void *));
+extern void put_free_8k_page _PARAMS((void *));
+extern void put_free_request_t _PARAMS((void *));
+extern void put_free_mem_obj _PARAMS((void *));
+extern void stmemInit _PARAMS((void));
+extern void stmemFreeMemory _PARAMS((void));
+
+extern int memFreeDataUpto _PARAMS((mem_hdr *, int));
+extern void memAppend _PARAMS((mem_hdr *, const char *, int));
+extern ssize_t memCopy _PARAMS((const mem_hdr *, off_t, char *, size_t));
+extern void memFree _PARAMS((mem_hdr *));
+extern void memFreeData _PARAMS((mem_hdr *));
+
+
+
+/* ----------------------------------------------------------------- */
+
+extern StoreEntry *storeGet _PARAMS((const char *));
+extern StoreEntry *storeCreateEntry _PARAMS((const char *, int, method_t));
+extern void storeSetPublicKey _PARAMS((StoreEntry *));
+extern StoreEntry *storeGetFirst _PARAMS((void));
+extern StoreEntry *storeGetNext _PARAMS((void));
+extern StoreEntry *storeLRU _PARAMS((void));
+extern int storeWalkThrough _PARAMS((int (*proc) _PARAMS((void)), void *data));
+extern EVH storePurgeOld;
+extern void storeComplete _PARAMS((StoreEntry *));
+extern void storeInit _PARAMS((void));
+extern int storeReleaseEntry _PARAMS((StoreEntry *));
+extern int storeClientWaiting _PARAMS((const StoreEntry *));
+extern void storeAbort _PARAMS((StoreEntry *, log_type, const char *, int));
+extern void storeAppend _PARAMS((StoreEntry *, const char *, int));
+extern int storeGetMemSize _PARAMS((void));
+extern int storeGetSwapSize _PARAMS((void));
+extern int storeGetSwapSpace _PARAMS((int));
+extern void storeLockObject _PARAMS((StoreEntry *));
+extern void storeSwapInStart _PARAMS((StoreEntry *, SIH *, void *data));
+extern int storeRelease _PARAMS((StoreEntry *));
+extern int storeUnlockObject _PARAMS((StoreEntry *));
+extern int storeUnregister _PARAMS((StoreEntry *, void *));
+extern const char *storeGeneratePublicKey _PARAMS((const char *, method_t));
+extern const char *storeGeneratePrivateKey _PARAMS((const char *, method_t, int));
+extern void storeStartDeleteBehind _PARAMS((StoreEntry *));
+extern void storeClientCopy _PARAMS((StoreEntry * e,
+	off_t seen_offset,
+	off_t copy_offset,
+	size_t size,
+	char *buf,
+	STCB * callback,
+	void *data));
+extern int storePendingNClients _PARAMS((const StoreEntry *));
+extern int storeWriteCleanLogs _PARAMS((void));
+extern HASHCMP urlcmp;
+extern EVH storeMaintainSwapSpace;
+extern void storeExpireNow _PARAMS((StoreEntry *));
+extern void storeReleaseRequest _PARAMS((StoreEntry *));
+extern void storeRotateLog _PARAMS((void));
+extern int storeGetLowestReaderOffset _PARAMS((const StoreEntry *));
+extern void storeCloseLog _PARAMS((void));
+extern void storeConfigure _PARAMS((void));
+extern void storeNegativeCache _PARAMS((StoreEntry *));
+extern void storeFreeMemory _PARAMS((void));
+extern int expiresMoreThan _PARAMS((time_t, time_t));
+extern int storeClientListAdd _PARAMS((StoreEntry *, void *));
+extern void InvokeHandlers _PARAMS((StoreEntry *));
+extern int storeEntryValidToSend _PARAMS((StoreEntry *));
+extern void storeTimestampsSet _PARAMS((StoreEntry *));
+extern unsigned int storeReqnum _PARAMS((StoreEntry * entry, method_t));
+extern time_t storeExpiredReferenceAge _PARAMS((void));
+extern void storeRegisterAbort _PARAMS((StoreEntry * e, STABH * cb, void *));
+extern void storeUnregisterAbort _PARAMS((StoreEntry * e));
+
+#ifdef __STDC__
+extern void storeAppendPrintf _PARAMS((StoreEntry *, const char *,...));
+#else
+extern void storeAppendPrintf _PARAMS(());
+#endif
+
+extern int store_rebuilding;
+extern int store_swap_size;
+extern unsigned long store_mem_size;
+
+extern char *storeSwapFullPath _PARAMS((int, char *));
+extern char *storeSwapSubSubDir _PARAMS((int, char *));
+extern int storeAddSwapDisk _PARAMS((const char *,
+	int size,
+	int l1,
+	int l2,
+	int read_only));
+extern void storeReconfigureSwapDisk _PARAMS((const char *,
+	int size,
+	int l1,
+	int l2,
+	int read_only));
+extern int storeVerifySwapDirs _PARAMS((void));
+extern void storeCreateSwapSubDirs _PARAMS((int));
+extern const char *storeSwapPath _PARAMS((int));
+extern int storeDirMapBitTest _PARAMS((int fn));
+extern void storeDirMapBitSet _PARAMS((int fn));
+extern void storeDirMapBitReset _PARAMS((int fn));
+extern int storeDirMapAllocate _PARAMS((void));
+extern char *storeSwapDir _PARAMS((int));
+extern FILE *storeDirOpenTmpSwapLog _PARAMS((int dirn, int *clean_flag));
+extern void storeDirCloseTmpSwapLog _PARAMS((int dirn));
+extern void storeDirOpenSwapLogs _PARAMS((void));
+extern void storeDirCloseSwapLogs _PARAMS((void));
+extern char *storeDirSwapLogFile _PARAMS((int, const char *));
+extern void storeDirSwapLog _PARAMS((const StoreEntry *));
+extern int storeDirNumber _PARAMS((int fileno));
+extern void storeDirUpdateSwapSize _PARAMS((int fn, size_t size, int sign));
+extern int storeDirProperFileno _PARAMS((int dirn, int fn));
+extern void storeDirStats _PARAMS((StoreEntry * sentry));
+
+
+extern const char *getMyHostname _PARAMS((void));
+extern void safeunlink _PARAMS((const char *path, int quiet));
+extern void death _PARAMS((int sig));
+extern void fatal _PARAMS((const char *message));
+extern void fatal_dump _PARAMS((const char *message));
+extern void sigusr2_handle _PARAMS((int sig));
+extern void sig_child _PARAMS((int sig));
+extern void leave_suid _PARAMS((void));
+extern void enter_suid _PARAMS((void));
+extern void no_suid _PARAMS((void));
+extern void writePidFile _PARAMS((void));
+extern void setSocketShutdownLifetimes _PARAMS((int));
+extern void setMaxFD _PARAMS((void));
+extern time_t getCurrentTime _PARAMS((void));
+extern void normal_shutdown _PARAMS((void));
+extern int percent _PARAMS((int, int));
+extern void squid_signal _PARAMS((int sig, void (*func) _PARAMS((int)), int flags));
+extern pid_t readPidFile _PARAMS((void));
+extern void _debug_trap _PARAMS((const char *message));
+extern struct in_addr inaddrFromHostent _PARAMS((const struct hostent * hp));
+extern int intAverage _PARAMS((int, int, int, int));
+extern double doubleAverage _PARAMS((double, double, int, int));
+extern void debug_trap _PARAMS((const char *));
+
+
+extern void unlinkdInit _PARAMS((void));
+extern void unlinkdClose _PARAMS((void));
+extern void unlinkdUnlink _PARAMS((const char *));
+
+extern char *url_convert_hex _PARAMS((char *org_url, int allocate));
+extern char *url_escape _PARAMS((const char *url));
+extern protocol_t urlParseProtocol _PARAMS((const char *));
+extern method_t urlParseMethod _PARAMS((const char *));
+extern void urlInitialize _PARAMS((void));
+extern request_t *urlParse _PARAMS((method_t, char *));
+extern char *urlCanonical _PARAMS((const request_t *, char *));
+extern request_t *requestLink _PARAMS((request_t *));
+extern void requestUnlink _PARAMS((request_t *));
+extern int matchDomainName _PARAMS((const char *d, const char *h));
+extern int urlCheckRequest _PARAMS((const request_t *));
+extern int urlDefaultPort _PARAMS((protocol_t p));
+
+extern void useragentOpenLog _PARAMS((void));
+extern void useragentRotateLog _PARAMS((void));
+extern void logUserAgent _PARAMS((const char *, const char *));
+extern peer_t parseNeighborType _PARAMS((const char *s));
+extern peer *getSslParent _PARAMS((void));
+extern peer *getPassParent _PARAMS((void));
@@ -0,0 +1,840 @@
+
+struct _acl_ip_data {
+    struct in_addr addr1;	/* if addr2 non-zero then its a range */
+    struct in_addr addr2;
+    struct in_addr mask;
+#ifndef USE_SPLAY_TREE
+    struct _acl_ip_data *next;
+#endif
+};
+
+struct _acl_time_data {
+    int weekbits;
+    int start;
+    int stop;
+    struct _acl_time_data *next;
+};
+
+struct _acl_name_list {
+    char name[ACL_NAME_SZ];
+    struct _acl_name_list *next;
+};
+
+struct _acl_deny_info_list {
+    char url[MAX_URL];
+    struct _acl_name_list *acl_list;
+    struct _acl_deny_info_list *next;
+};
+
+struct _acl {
+    char name[ACL_NAME_SZ];
+    squid_acl type;
+    void *data;
+    char *cfgline;
+    struct _acl *next;
+};
+
+struct _acl_list {
+    int op;
+    struct _acl *acl;
+    struct _acl_list *next;
+};
+
+struct _acl_access {
+    int allow;
+    struct _acl_list *acl_list;
+    char *cfgline;
+    struct _acl_access *next;
+};
+
+struct _aclCheck_t {
+    const struct _acl_access *access_list;
+    struct in_addr src_addr;
+    struct in_addr dst_addr;
+    request_t *request;
+    char ident[ICP_IDENT_SZ];
+    char browser[BROWSERNAMELEN];
+    acl_lookup_state state[ACL_ENUM_MAX];
+    PF *callback;
+    void *callback_data;
+};
+
+struct _aio_result_t {
+    int aio_return;
+    int aio_errno;
+};
+
+struct _wordlist {
+    char *key;
+    struct _wordlist *next;
+};
+
+struct _intlist {
+    int i;
+    struct _intlist *next;
+};
+
+struct _ushortlist {
+    u_short i;
+    struct _ushortlist *next;
+};
+
+struct _relist {
+    char *pattern;
+    regex_t regex;
+    struct _relist *next;
+};
+
+struct _cache_peer {
+    char *host;
+    char *type;
+    u_short http;
+    u_short icp;
+    int options;
+    int weight;
+    int mcast_ttl;
+    domain_ping *pinglist;
+    domain_type *typelist;
+    acl_list *acls;
+    struct _cache_peer *next;
+};
+
+struct _SquidConfig {
+    struct {
+	int maxSize;
+	int highWaterMark;
+	int lowWaterMark;
+    } Mem , Swap;
+    struct {
+	char *relayHost;
+	u_short relayPort;
+    } Wais;
+    struct {
+	int min;
+	int pct;
+	int max;
+    } quickAbort;
+    time_t referenceAge;
+    time_t negativeTtl;
+    time_t negativeDnsTtl;
+    time_t positiveDnsTtl;
+    time_t shutdownLifetime;
+    time_t neighborTimeout;
+    time_t stallDelay;
+    struct {
+	time_t read;
+	time_t defer;
+	time_t lifetime;
+	time_t connect;
+	time_t request;
+    } Timeout;
+    int maxRequestSize;
+    struct {
+	ushortlist *http;
+	u_short icp;
+    } Port;
+    struct {
+	char *log;
+	char *access;
+	char *store;
+	char *swap;
+	char *useragent;
+	int rotateNumber;
+	int log_fqdn;
+    } Log;
+    struct {
+	char *File;
+	relist *IgnoreDomains;
+    } proxyAuth;
+    char *adminEmail;
+    char *effectiveUser;
+    char *effectiveGroup;
+    struct {
+	char *dnsserver;
+	char *redirect;
+	char *pinger;
+	char *unlinkd;
+    } Program;
+    int dnsChildren;
+    int redirectChildren;
+    int sourcePing;
+    int commonLogFormat;
+    int logMimeHdrs;
+    int identLookup;
+    int singleParentBypass;
+    struct {
+	char *host;
+	u_short port;
+	int withProxy;
+    } Accel;
+    char *appendDomain;
+    size_t appendDomainLen;
+    char *debugOptions;
+    char *pidFilename;
+    char *mimeTablePathname;
+    char *visibleHostname;
+    char *errHtmlText;
+    struct {
+	char *host;
+	char *file;
+	time_t period;
+	int on;
+	u_short port;
+    } Announce;
+    struct {
+	struct in_addr tcp_incoming;
+	struct in_addr tcp_outgoing;
+	struct in_addr udp_incoming;
+	struct in_addr udp_outgoing;
+	struct in_addr client_netmask;
+    } Addrs;
+    int tcpRcvBufsz;
+    int udpMaxHitObjsz;
+    wordlist *cache_stoplist;
+    wordlist *hierarchy_stoplist;
+    wordlist *mcast_group_list;
+    wordlist *dns_testname_list;
+    relist *cache_stop_relist;
+    cache_peer *peers;
+    cache_peer *sslProxy;
+    cache_peer *passProxy;
+    struct {
+	int size;
+	int low;
+	int high;
+    } ipcache;
+    int minDirectHops;
+    cachemgr_passwd *passwd_list;
+    struct {
+	int objectsPerBucket;
+	int avgObjectSize;
+	int maxObjectSize;
+    } Store;
+    struct {
+	int high;
+	int low;
+	time_t period;
+    } Netdb;
+    struct {
+	int log_udp;
+	int enable_purge;
+	int res_defnames;
+	int anonymizer;
+	int client_db;
+	int query_icmp;
+    } Options;
+    struct _acl *aclList;
+    struct {
+	struct _acl_access *http;
+	struct _acl_access *icp;
+	struct _acl_access *miss;
+	struct _acl_access *NeverDirect;
+	struct _acl_access *AlwaysDirect;
+    } accessList;
+    struct _acl_deny_info_list *denyInfoList;
+    struct {
+	size_t list_width;
+	int list_wrap;
+	char *icon_prefix;
+	char *icon_suffix;
+	char *anon_user;
+    } Ftp;
+    refresh_t *Refresh;
+    struct _cacheSwap {
+        SwapDir *swapDirs;
+        int n_allocated;
+        int n_configured;
+    } cacheSwap;
+};
+
+struct _SquidConfig2 {
+    struct {
+	char *prefix;
+	int on;
+    } Accel;
+};
+
+struct _close_handler {
+    PF *handler;
+    void *data;
+    close_handler *next;
+};
+
+struct _dread_ctrl {
+    int fd;
+    off_t offset;
+    int req_len;
+    char *buf;
+    int end_of_file;
+    DRCB *handler;
+    void *client_data;
+};
+
+struct _dnsserver_t {
+    int id;
+    int flags;
+    int inpipe;
+    int outpipe;
+    time_t answer;
+    unsigned int offset;
+    unsigned int size;
+    char *ip_inbuf;
+    struct timeval dispatch_time;
+    void *data;
+};
+
+struct _dnsStatData {
+    int requests;
+    int replies;
+    int hist[DefaultDnsChildrenMax];
+};
+
+struct _dwrite_q {
+    char *buf;
+    int len;
+    int cur_offset;
+    struct _dwrite_q *next;
+    void (*free) (void *);
+};
+
+
+struct _fde {
+    unsigned int type;
+    unsigned int open;
+    u_short local_port;
+    u_short remote_port;
+    char ipaddr[16];		/* dotted decimal address of peer */
+    char desc[FD_DESC_SZ];
+    int flags;
+    int bytes_read;
+    int bytes_written;
+    struct _fde_disk {
+	DWCB *wrt_handle;
+	void *wrt_handle_data;
+	dwrite_q *write_q;
+	dwrite_q *write_q_tail;
+    } disk;
+    PF *read_handler;
+    void *read_data;
+    PF *write_handler;
+    void *write_data;
+    PF *timeout_handler;
+    time_t timeout;
+    void *timeout_data;
+    void *lifetime_data;
+    close_handler *close_handler;	/* linked list */
+    time_t stall_until;		/* don't select for read until this time */
+    CommWriteStateData *rwstate;	/* State data for comm_write */
+};
+
+struct _fileMap {
+    int max_n_files;
+    int n_files_in_map;
+    int last_file_number_allocated;
+    int toggle;
+    int nwords;
+    unsigned long *file_map;
+};
+
+struct _fqdncache_entry {
+    /* first two items must be equivalent to hash_link in hash.h */
+    char *name;
+    struct _fqdncache_entry *next;
+    time_t lastref;
+    time_t expires;
+    unsigned char name_count;
+    char *names[FQDN_MAX_NAMES + 1];
+    struct _fqdn_pending *pending_head;
+    char *error_message;
+    unsigned char locks;
+    fqdncache_status_t status:3;
+};
+
+struct _hash_link {
+    char *key;
+    struct _hash_link *next;
+    void *item;
+};
+
+struct _hash_table {
+    int valid;
+    hash_link **buckets;
+    HASHCMP *cmp;
+    HASHHASH *hash;
+    unsigned int size;
+    unsigned int current_slot;
+    hash_link *current_ptr;
+};
+
+struct _http_reply {
+    double version;
+    int code;
+    int content_length;
+    int hdr_sz;
+    int cache_control;
+    int misc_headers;
+    time_t date;
+    time_t expires;
+    time_t last_modified;
+    char content_type[HTTP_REPLY_FIELD_SZ];
+    char user_agent[HTTP_REPLY_FIELD_SZ << 2];
+};
+
+struct _HttpStateData {
+    StoreEntry *entry;
+    request_t *request;
+    char *reply_hdr;
+    int reply_hdr_state;
+    peer *neighbor;		/* neighbor request made to */
+    int eof;			/* reached end-of-object? */
+    request_t *orig_request;
+    int fd;			/* needed as identifier for ipcache */
+};
+
+struct _icpUdpData {
+    struct sockaddr_in address;
+    void *msg;
+    size_t len;
+    icpUdpData *next;
+#ifndef LESS_TIMING
+    struct timeval start;
+#endif
+    log_type logcode;
+    protocol_t proto;
+};
+
+struct _icp_ping_data {
+    struct timeval start;
+    struct timeval stop;
+    int n_sent;
+    int n_recv;
+    int n_replies_expected;
+    int timeout;
+    int w_rtt;
+};
+
+struct _HierarchyLogEntry {
+    hier_code code;
+    char host[SQUIDHOSTNAMELEN];
+    struct _icp_ping_data icp;
+};
+
+struct _AccessLogEntry {
+    const char *url;
+    struct {
+	method_t method;
+	int code;
+	const char *content_type;
+    } http;
+    struct {
+	icp_opcode opcode;
+    } icp;
+    struct {
+	struct in_addr caddr;
+	size_t size;
+	log_type code;
+	int msec;
+	const char *ident;
+    } cache;
+    struct _HierarchyLogEntry hier;
+    struct {
+	char *request;
+	char *reply;
+    } headers;
+    struct {
+	const char *method_str;
+    } private;
+};
+
+struct _clientHttpRequest {
+    ConnStateData *conn;
+    request_t *request;		/* Parsed URL ... */
+    char *url;
+    struct {
+	char *buf;
+	int offset;
+	int size;
+    } out;
+    size_t req_sz;
+    StoreEntry *entry;
+    StoreEntry *old_entry;
+    log_type log_type;
+    int http_code;
+    int accel;
+    struct timeval start;
+    float http_ver;
+    int redirect_state;
+    aclCheck_t *acl_checklist;	/* need ptr back so we can unreg if needed */
+    clientHttpRequest *next;
+    struct _AccessLogEntry al;
+};
+
+struct _ConnStateData {
+    int fd;
+    struct {
+	char *buf;
+	int offset;
+	int size;
+    } in;
+    clientHttpRequest *chr;
+    struct sockaddr_in peer;
+    struct sockaddr_in me;
+    struct in_addr log_addr;
+    struct {
+	int fd;
+	char ident[ICP_IDENT_SZ];
+	IDCB *callback;
+	int state;
+    } ident;
+    CommWriteStateData *commWriteState;
+    int nrequests;
+    int persistent;
+};
+
+struct _ipcache_addrs {
+    unsigned char count;
+    unsigned char cur;
+    struct in_addr *in_addrs;
+};
+
+struct _ipcache_entry {
+    /* first two items must be equivalent to hash_link in hash.h */
+    char *name;
+    struct _ipcache_entry *next;
+    time_t lastref;
+    time_t expires;
+    ipcache_addrs addrs;
+    struct _ip_pending *pending_head;
+    char *error_message;
+    unsigned char locks;
+    ipcache_status_t status:3;
+};
+
+struct _ext_table_entry {
+    char *name;
+    char *mime_type;
+    char *mime_encoding;
+    char *icon;
+};
+
+struct _domain_ping {
+    char *domain;
+    int do_ping;		/* boolean */
+    struct _domain_ping *next;
+};
+
+struct _domain_type {
+    char *domain;
+    peer_t type;
+    struct _domain_type *next;
+};
+
+struct _peer {
+    char *host;
+    peer_t type;
+    struct sockaddr_in in_addr;
+    struct {
+	int pings_sent;
+	int pings_acked;
+	int ack_deficit;
+	int fetches;
+	int rtt;
+	int counts[ICP_OP_END];
+	int ignored_replies;
+    } stats;
+    u_short icp_port;
+    u_short http_port;
+    int icp_version;
+    struct _domain_ping *pinglist;
+    struct _domain_type *typelist;
+    struct _acl_list *acls;
+    int options;
+    int weight;
+    struct {
+	double avg_n_members;
+	int n_times_counted;
+	int n_replies_expected;
+	int ttl;
+	int reqnum;
+	int flags;
+    } mcast;
+    int tcp_up;			/* 0 if a connect() fails */
+    time_t last_fail_time;
+    struct in_addr addresses[10];
+    int n_addresses;
+    int rr_count;
+    struct _peer *next;
+    int ip_lookup_pending;
+    int test_fd;
+};
+
+struct _net_db_name {
+    char *name;
+    struct _net_db_name *next;
+};
+
+struct _net_db_peer {
+    char *peername;
+    double hops;
+    double rtt;
+    time_t expires;
+};
+
+struct _netdbEntry {
+    char *key;
+    struct _net_db *next;
+    char network[16];
+    int pings_sent;
+    int pings_recv;
+    double hops;
+    double rtt;
+    time_t next_ping_time;
+    time_t last_use_time;
+    int link_count;
+    net_db_name *hosts;
+    net_db_peer *peers;
+    int n_peers_alloc;
+    int n_peers;
+};
+
+struct _ps_state {
+    request_t *request;
+    StoreEntry *entry;
+    int always_direct;
+    int never_direct;
+    PSC *callback;
+    PSC *fail_callback;
+    void *callback_data;
+    peer *first_parent_miss;
+    peer *closest_parent_miss;
+    icp_ping_data icp;
+    aclCheck_t *acl_checklist;
+};
+
+struct _pingerEchoData {
+    struct in_addr to;
+    unsigned char opcode;
+    int psize;
+    char payload[8192];
+};
+
+struct _pingerReplyData {
+    struct in_addr from;
+    unsigned char opcode;
+    int rtt;
+    int hops;
+    int psize;
+    char payload[8192];
+};
+
+struct _icp_common_t {
+    unsigned char opcode;	/* opcode */
+    unsigned char version;	/* version number */
+    unsigned short length;	/* total length (bytes) */
+    u_num32 reqnum;		/* req number (req'd for UDP) */
+    u_num32 flags;
+    u_num32 pad;
+    /* u_num32 auth[ICP_AUTH_SIZE];     authenticator (old) */
+    u_num32 shostid;		/* sender host id */
+};
+
+struct _Stack {
+    void **base;
+    void **top;
+    int stack_size;
+};
+
+struct _proto_stat {
+    char protoname[25];
+    int object_count;
+    struct _usage {
+	int max;
+	int avg;
+	int min;
+	int now;
+    } kb;
+    unsigned int hit;
+    unsigned int miss;
+    float hitratio;
+    unsigned int transferrate;
+    unsigned int refcount;
+    unsigned int transferbyte;
+};
+
+struct _Meta_data {
+    int hot_vm;
+    int store_entries;
+    int mem_obj_count;
+    int mem_data_count;
+    int ipcache_count;
+    int fqdncache_count;
+    int netdb_addrs;
+    int netdb_hosts;
+    int netdb_peers;
+    int url_strings;
+    int misc;
+    int client_info;
+};
+
+struct _cacheinfo {
+    protocol_t(*proto_id) (const char *url);
+    void (*proto_newobject) (struct _cacheinfo * c, protocol_t proto_id, int len, int flag);
+    void (*proto_purgeobject) (struct _cacheinfo * c, protocol_t proto_id, int len);
+    void (*proto_touchobject) (struct _cacheinfo * c, protocol_t proto_id, int len);
+    void (*proto_count) (struct _cacheinfo * obj, protocol_t proto_id,
+	log_type);
+    proto_stat proto_stat_data[PROTO_MAX + 1];
+};
+
+struct _iostats {
+    struct {
+	int reads;
+	int reads_deferred;
+	int read_hist[16];
+	int writes;
+	int write_hist[16];
+    } Http, Ftp, Gopher, Wais;
+};
+
+struct _mem_node {
+    char *data;
+    int len;
+    mem_node *next;
+};
+
+struct _mem_hdr {
+    mem_node *head;
+    mem_node *tail;
+    int origin_offset;
+};
+
+/* Memory allocator routines for fixed size blocks */
+struct _stmem_stats {
+    int max_pages;
+    int total_pages_allocated;
+    int page_size;
+    int n_pages_in_use;
+    Stack free_page_stack;
+};
+
+/* keep track each client receiving data from that particular StoreEntry */
+struct _store_client {
+    off_t copy_offset;
+    off_t seen_offset;
+    size_t copy_size;
+    char *copy_buf;
+    STCB *callback;
+    void *callback_data;
+};
+
+
+/* This structure can be freed while object is purged out from memory */
+struct _MemObject {
+    mem_hdr *data;
+    char *e_swap_buf;
+    int w_rtt;			/* weighted RTT in msec */
+    peer *e_pings_closest_parent;	/* parent with best RTT to source */
+    int p_rtt;			/* parent's RTT to source */
+    int e_swap_buf_len;
+    unsigned char pending_list_size;
+    char *e_abort_msg;
+    log_type abort_code;
+    int e_current_len;
+    int e_lowest_offset;
+    struct _store_client *clients;
+    int nclients;
+    u_num32 swap_offset;
+    short swapin_fd;
+    short swapout_fd;
+    struct _http_reply *reply;
+    request_t *request;
+    struct timeval start_ping;
+    IRCB *icp_reply_callback;
+    void *ircb_data;
+    int fd;			/* FD of client creating this entry */
+    struct {
+	STABH *callback;
+	void *data;
+    } abort;
+};
+
+/* A cut down structure for store manager */
+struct _StoreEntry {
+    /* first two items must be same as hash_link in hash.h */
+    char *key;
+    struct sentry *next;
+    char *url;
+    MemObject *mem_obj;
+    u_num32 flag;
+    u_num32 refcount;
+    time_t timestamp;
+    time_t lastref;
+    time_t expires;
+    time_t lastmod;
+    int object_len;
+    int swap_file_number;
+    mem_status_t mem_status:3;
+    ping_status_t ping_status:3;
+    store_status_t store_status:3;
+    swap_status_t swap_status:3;
+    method_t method:4;
+    unsigned char lock_count;	/* Assume < 256! */
+};
+
+struct _SwapDir {
+    char *path;
+    int l1;
+    int l2;
+    int cur_size;
+    int max_size;
+    int read_only;
+    int suggest;
+    fileMap *map;
+    int swaplog_fd;
+};
+
+struct _request_t {
+    method_t method;
+    protocol_t protocol;
+    char login[MAX_LOGIN_SZ];
+    char host[SQUIDHOSTNAMELEN + 1];
+    u_short port;
+    char urlpath[MAX_URL];
+    int link_count;		/* free when zero */
+    int flags;
+    time_t max_age;
+    float http_ver;
+    time_t ims;
+    int imslen;
+    int max_forwards;
+    struct in_addr client_addr;
+    char *headers;
+    size_t headers_sz;
+    char *body;
+    size_t body_sz;
+    struct _HierarchyLogEntry hier;
+};
+
+struct _cachemgr_passwd {
+    char *passwd;
+    long actions;
+    struct _cachemgr_passwd *next;
+};
+
+struct _refresh_t {
+    char *pattern;
+    regex_t compiled_pattern;
+    time_t min;
+    int pct;
+    time_t max;
+    struct _refresh_t *next;
+};
+
+struct _CommWriteStateData {
+    char *buf;
+    size_t size;
+    off_t offset;
+    CWCB *handler;
+    void *handler_data;
+    FREE *free;
+};
@@ -0,0 +1,99 @@
+
+typedef unsigned int store_status_t;
+typedef unsigned int mem_status_t;
+typedef unsigned int ping_status_t;
+typedef unsigned int swap_status_t;
+
+/*
+    grep '^struct' structs.h \
+    | perl -ne '($a,$b)=split;$c=$b;$c=~s/^_//; print "typedef struct $b $c;\n";'
+*/
+
+typedef struct _acl_ip_data acl_ip_data;
+typedef struct _acl_time_data acl_time_data;
+typedef struct _acl_name_list acl_name_list;
+typedef struct _acl_deny_info_list acl_deny_info_list;
+typedef struct _acl acl;
+typedef struct _acl_list acl_list;
+typedef struct _acl_access acl_access;
+typedef struct _aclCheck_t aclCheck_t;
+typedef struct _aio_result_t aio_result_t;
+typedef struct _wordlist wordlist;
+typedef struct _intlist intlist;
+typedef struct _ushortlist ushortlist;
+typedef struct _relist relist;
+typedef struct _cache_peer cache_peer;
+typedef struct _SquidConfig SquidConfig;
+typedef struct _SquidConfig2 SquidConfig2;
+typedef struct _close_handler close_handler;
+typedef struct _dread_ctrl dread_ctrl;
+typedef struct _dnsserver_t dnsserver_t;
+typedef struct _dnsStatData dnsStatData;
+typedef struct _dwrite_q dwrite_q;
+typedef struct _fde fde;
+typedef struct _fileMap fileMap;
+typedef struct _fqdncache_entry fqdncache_entry;
+typedef struct _hash_link hash_link;
+typedef struct _hash_table hash_table;
+typedef struct _http_reply http_reply;
+typedef struct _HttpStateData HttpStateData;
+typedef struct _icpUdpData icpUdpData;
+typedef struct _clientHttpRequest clientHttpRequest;
+typedef struct _ConnStateData ConnStateData;
+typedef struct _ipcache_addrs ipcache_addrs;
+typedef struct _ipcache_entry ipcache_entry;
+typedef struct _ext_table_entry ext_table_entry;
+typedef struct _domain_ping domain_ping;
+typedef struct _domain_type domain_type;
+typedef struct _peer peer;
+typedef struct _net_db_name net_db_name;
+typedef struct _net_db_peer net_db_peer;
+typedef struct _netdbEntry netdbEntry;
+typedef struct _icp_ping_data icp_ping_data;
+typedef struct _ps_state ps_state;
+typedef struct _HierarchyLogEntry HierarchyLogEntry;
+typedef struct _pingerEchoData pingerEchoData;
+typedef struct _pingerReplyData pingerReplyData;
+typedef struct _icp_common_t icp_common_t;
+typedef struct _Stack Stack;
+typedef struct _proto_stat proto_stat;
+typedef struct _Meta_data Meta_data;
+typedef struct _cacheinfo cacheinfo;
+typedef struct _iostats iostats;
+typedef struct _mem_node mem_node;
+typedef struct _mem_hdr mem_hdr;
+typedef struct _stmem_stats stmem_stats;
+typedef struct _store_client store_client;
+typedef struct _MemObject MemObject;
+typedef struct _StoreEntry StoreEntry;
+typedef struct _SwapDir SwapDir;
+typedef struct _request_t request_t;
+typedef struct _AccessLogEntry AccessLogEntry;
+typedef struct _cachemgr_passwd cachemgr_passwd;
+typedef struct _refresh_t refresh_t;
+typedef struct _CommWriteStateData CommWriteStateData;
+
+typedef void AIOCB _PARAMS((void *, int aio_return, int aio_errno));
+typedef void CWCB _PARAMS((int fd, char *, int size, int errflag, void *data));
+typedef void CNCB _PARAMS((int fd, int status, void *data));
+typedef void FREE _PARAMS((void *));
+typedef void FOCB _PARAMS((void *, int fd));
+typedef void EVH _PARAMS((void *));
+typedef void PF _PARAMS((int, void *));
+typedef void DRCB _PARAMS((int fd, const char *buf, int size, int errflag, void *data));
+typedef void DWCB _PARAMS((int, int, size_t, void *));
+typedef void FILE_WALK_HD _PARAMS((int fd, int errflag, void *data));
+typedef void FILE_WALK_LHD _PARAMS((int fd, const char *buf, int size, void *line_data));
+typedef void FQDNH _PARAMS((const char *, void *));
+typedef int HASHCMP _PARAMS((const char *, const char *));
+typedef unsigned int HASHHASH _PARAMS((const char *, unsigned int));
+typedef void IDCB _PARAMS((void *));
+typedef void IPH _PARAMS((const ipcache_addrs *, void *));
+typedef void IRCB _PARAMS((peer *, peer_t, icp_opcode, void *data));
+typedef void PSC _PARAMS((peer *, void *));
+typedef void RH _PARAMS((void *data, char *result));
+
+typedef void SIH _PARAMS((void *, int));	/* swap in */
+typedef int QS _PARAMS((const void *, const void *));	/* qsort */
+typedef void STCB _PARAMS((void *, char *, ssize_t));	/* store callback */
+typedef void STABH _PARAMS((void *));