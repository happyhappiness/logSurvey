@@ -38,6 +38,7 @@ libcompat_la_SOURCES = \
 	os/hpux.h \
 	os/linux.h \
 	os/mswin.h \
+	os/macosx.h \
 	os/netbsd.h \
 	os/next.h \
 	os/openbsd.h \
@@ -54,6 +54,7 @@
 #include "compat/os/freebsd.h"
 #include "compat/os/hpux.h"
 #include "compat/os/linux.h"
+#include "compat/os/macosx.h"
 #include "compat/os/mswin.h"
 #include "compat/os/netbsd.h"
 #include "compat/os/next.h"
@@ -33,6 +33,15 @@
 #define SQUID_NO_ALLOC_PROTECT 1
 #endif
 
+/*
+ *   This OS has at least one version that defines these as private
+ *   kernel macros commented as being 'non-standard'.
+ *   We need to use them, much nicer than the OS-provided __u*_*[]
+ */
+//#define s6_addr8  __u6_addr.__u6_addr8
+//#define s6_addr16 __u6_addr.__u6_addr16
+#define s6_addr32 __u6_addr.__u6_addr32
+
 
 #endif /* _SQUID_FREEBSD_ */
 #endif /* SQUID_OS_FREEBSD_H */
@@ -0,0 +1,26 @@
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef SQUID_OS_MACOSX_H
+#define SQUID_OS_MACOSX_H
+
+#ifdef _SQUID_APPLE_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+/*
+ *   This OS has at least one version that defines these as private
+ *   kernel macros commented as being 'non-standard'.
+ *   We need to use them, much nicer than the OS-provided __u*_*[]
+ */
+//#define s6_addr8  __u6_addr.__u6_addr8
+//#define s6_addr16 __u6_addr.__u6_addr16
+#define s6_addr32 __u6_addr.__u6_addr32
+
+#endif /* _SQUID_APPLE_ */
+#endif /* SQUID_OS_MACOSX_H */
@@ -22,5 +22,14 @@
 /* NetBSD does not provide sys_errlist global for strerror */
 #define NEED_SYS_ERRLIST 1
 
+/*
+ *   This OS has at least one version that defines these as private
+ *   kernel macros commented as being 'non-standard'.
+ *   We need to use them, much nicer than the OS-provided __u*_*[]
+ */
+//#define s6_addr8  __u6_addr.__u6_addr8
+//#define s6_addr16 __u6_addr.__u6_addr16
+#define s6_addr32 __u6_addr.__u6_addr32
+
 #endif /* _SQUID_NETBSD_ */
 #endif /* SQUID_OS_NETBSD_H */
@@ -26,5 +26,19 @@
 #define SQUID_NO_ALLOC_PROTECT 1
 #endif
 
+/*
+ *   This OS has at least one version that defines these as private
+ *   kernel macros commented as being 'non-standard'.
+ *   We need to use them, much nicer than the OS-provided __u*_*[]
+ */
+//#define s6_addr8  __u6_addr.__u6_addr8
+//#define s6_addr16 __u6_addr.__u6_addr16
+#define s6_addr32 __u6_addr.__u6_addr32
+
+/* OpenBSD also hide v6only socket option we need for comm layer. :-( */
+#if !defined(IPV6_V6ONLY)
+#define IPV6_V6ONLY             27 // from OpenBSD 4.3 headers. (NP: does not match non-BSD OS values)
+#endif
+
 #endif /* _SQUID_OPENBSD_ */
 #endif /* SQUID_OS_OPENBSD_H */
@@ -67,6 +67,11 @@ SQUIDCEXTERN int gethostname(char *, int);
 #define SQUID_NO_STRING_BUFFER_PROTECT 1
 #endif
 
+/* Bug 2500: Solaris 10/11 require s6_addr* defines. */
+//#define s6_addr8   _S6_un._S6_u8
+//#define s6_addr16  _S6_un._S6_u16
+#define s6_addr32  _S6_un._S6_u32
+
 
 #endif /* _SQUID_SOLARIS_ */
 #endif /* SQUID_OS_SOALRIS_H */
@@ -2646,9 +2646,9 @@ esac
 
 dnl Enable IPv6 support
 AC_MSG_CHECKING([whether to enable IPv6])
-use_ipng=auto
+use_ipng=yes
 AC_ARG_ENABLE(ipv6,
-  AS_HELP_STRING([--disable-ipv6],[Disable IPv6 support]),
+  AS_HELP_STRING([--disable-ipv6],[Disable IPv6 support. The default is to probe system capabilities on startup.]),
 [ case $enableval in
   yes|no)
     use_ipng=$enableval
@@ -2660,117 +2660,26 @@ AC_ARG_ENABLE(ipv6,
 AC_MSG_RESULT($use_ipng)
 
 if test "$use_ipng" != "no"; then
-  SAVED_LIBS="$LIBS"
-  dnl Solaris 10/11 requires  -lsocket
-  case "$host" in
-    *-solaris*)
-      LIBS="$LIBS -lsocket"
-      ;;
-    *)
-      ;;
-  esac
-  AC_CACHE_CHECK([if PF_INET6 is available], squid_cv_pf_inet6,
-    AC_RUN_IFELSE([AC_LANG_SOURCE([[ /* PF_INET6 available check */
-#       include <sys/types.h>
-#       include <sys/socket.h>
-        int main(int argc, char **argv) {
-          if (socket(PF_INET6, SOCK_STREAM, 0) < 0)
-            return 1;
-          else
-            return 0;
-        }
-      ]])],[squid_cv_pf_inet6="yes" ; SAVED_LIBS="$LIBS"],[squid_cv_pf_inet6="no"],[])
-   )
-   LIBS="$SAVED_LIBS"
-fi
-
-# NP: semi-silent failure as IPv4-only mode is perfectly usable on this system.
-# unless --enable-ipv6 is explicitly used. in which case it's a hard fail.
-if test "x$use_ipng" = "xyes" && test "x$squid_cv_pf_inet6" = "xno"; then
-	AC_MSG_ERROR([IPv6 cannot be built on this system. Basic kernel definitions are missing.])
-elif test "x$use_ipng" = "xauto" && test "x$squid_cv_pf_inet6" = "xno"; then
-	AC_MSG_WARN([IPv6 cannot be built on this system. Basic kernel definitions are missing.])
-fi
-
-if test "$use_ipng" != "no" && test "$squid_cv_pf_inet6" = "yes" ; then
   AC_DEFINE(USE_IPV6,1,[Enable support for IPv6 ])
-  SET_IPV6_SETTINGS=""
-  use_v4mapped=yes
-
-dnl Check for forced split-stack mode
-  AC_MSG_CHECKING([for IPv6 split-stack requirement])
-  AC_ARG_WITH(ipv6-split-stack,
-    AS_HELP_STRING([--with-ipv6-split-stack],[Force-Enable experimental split-stack support for Windows XP and *BSD. Requires IPv6.]),
-    [ use_v4mapped="no"
-      AC_MSG_RESULT(yes)],
-    [ AC_MSG_RESULT(no) ])
-
-dnl Check for IPv6 v4-mapping availability
-dnl Useful for other OS with hybrid-stack defaults turned OFF
-dnl But only usable if it actually works...
-  if test "$use_v4mapped" = "yes" ; then
-    AC_MSG_CHECKING([for IPv6 v4-mapping ability])
-    AC_RUN_IFELSE([AC_LANG_SOURCE([[ /* IPPROTO_V4MAPPED is usable check */
-#       include <sys/types.h>
-#       include <sys/socket.h>
-#	include <netinet/in.h>
-#if HAVE_NETINET_IN6_H
-#	include <netinet/in6.h>
-#endif
-        int main(int argc, char **argv) {
-          int s = socket(PF_INET6, SOCK_STREAM, 0);
-          int tos = 0;
-          if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &tos, sizeof(int)) < 0)
-            return 1;
-          else
-            return 0;
-        }
-      ]])],[ AC_MSG_RESULT(yes)
-        use_v4mapped=yes
-        AC_DEFINE(IPV6_SPECIAL_V4MAPPED, 1, [Enable v4-mapping through v6 sockets])
-      ],[ AC_MSG_RESULT(no)
-        AC_DEFINE(IPV6_SPECIAL_V4MAPPED, 0, [Enable v4-mapping through v6 sockets])
-        use_v4mapped=no
-      ],[])
-  fi
-
-dnl if we can't defer v4-mapping to the OS we are forced to split-stack 
-dnl the FD table.
-  AC_MSG_CHECKING([for IPv6 stack type/mode])
-  if test "$use_v4mapped" = "yes"; then
-    AC_DEFINE(IPV6_SPECIAL_V4MAPPED, 1, [Enable v4-mapping through v6 sockets. Requires IPv6 hybrid-stack.])
-    AC_DEFINE(IPV6_SPECIAL_SPLITSTACK, 0, [Enable support for IPv6 on split-stack implementations])
-    AC_MSG_RESULT(mapping hybrid)
-  else
-    AC_DEFINE(IPV6_SPECIAL_V4MAPPED, 0, [Enable v4-mapping through v6 sockets. Requires IPv6 hybrid-stack.])
-    AC_DEFINE(IPV6_SPECIAL_SPLITSTACK, 1, [Enable support for IPv6 on split-stack implementations])
-    AC_MSG_RESULT(split-stack or BSD non-mapping dual-stack)
-  fi
+else
+  AC_DEFINE(USE_IPV6,0,[Enable support for IPv6 ])
+fi
 
 dnl Check whether this OS defines sin6_len as a member of sockaddr_in6 as a backup to ss_len
 AC_CACHE_CHECK([for sin6_len field in struct sockaddr_in6],
                 ac_cv_have_sin6_len_in_struct_sai, [
-        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
-                ]], [[ struct sockaddr_in6 s; s.sin6_len = 1; ]])],[ ac_cv_have_sin6_len_in_struct_sai="yes" ],[ ac_cv_have_sin6_len_in_struct_sai="no" 
-        ])
-  ])
-  if test "x$ac_cv_have_sin6_len_in_struct_sai" = "xyes" ; then
-    AC_DEFINE(HAVE_SIN6_LEN_IN_SAI, 1, [Does struct sockaddr_in6 have sin6_len? 1: Yes, 0: No])
-  else
-    AC_DEFINE(HAVE_SIN6_LEN_IN_SAI, 0, [Does struct sockaddr_in6 have sin6_len? 1: Yes, 0: No])
-  fi
-
+              ]], [[ struct sockaddr_in6 s; s.sin6_len = 1; ]])],[ ac_cv_have_sin6_len_in_struct_sai="yes" ],[ ac_cv_have_sin6_len_in_struct_sai="no" 
+      ])
+])
+if test "x$ac_cv_have_sin6_len_in_struct_sai" = "xyes" ; then
+  AC_DEFINE(HAVE_SIN6_LEN_IN_SAI, 1, [Does struct sockaddr_in6 have sin6_len? 1: Yes, 0: No])
 else
-  # IPv6 is not available, but is not explicitly required. Auto-Disable.
-  AC_DEFINE(USE_IPV6,0,[Enable support for IPv6])
-  AC_DEFINE(IPV6_SPECIAL_SPLITSTACK,0,[Enable support for IPv6 on split-stack implementations])
-  AC_DEFINE(IPV6_SPECIAL_V4MAPPED,0,[Enable v4-mapping through v6 sockets])
-  SET_IPV6_SETTINGS="\#IPv6 Not Available: "
+  AC_DEFINE(HAVE_SIN6_LEN_IN_SAI, 0, [Does struct sockaddr_in6 have sin6_len? 1: Yes, 0: No])
 fi
-AC_SUBST(SET_IPV6_SETTINGS)
 
 dnl Check whether this OS defines ss_len as a member of sockaddr_storage
 AC_CACHE_CHECK([for ss_len field in struct sockaddr_storage],
@@ -220,12 +220,10 @@ xgetaddrinfo (const char *nodename, const char *servname,
         if (!(hints->ai_family == PF_UNSPEC || hints->ai_family == PF_INET))
             return EAI_FAMILY;
         break;
-#if USE_IPV6
     case AF_INET6:
         if (!(hints->ai_family == PF_UNSPEC || hints->ai_family == PF_INET6))
             return EAI_FAMILY;
         break;
-#endif
     default:
         return EAI_FAMILY;
     }
@@ -247,7 +245,6 @@ xgetaddrinfo (const char *nodename, const char *servname,
                     *addrs, hp->h_length);
             addrlen = sizeof (struct sockaddr_in);
             break;
-#if USE_IPV6
         case AF_INET6:
 #if SIN6_LEN
             ((struct sockaddr_in6 *) &sa)->sin6_len = hp->h_length;
@@ -257,7 +254,6 @@ xgetaddrinfo (const char *nodename, const char *servname,
                     *addrs, hp->h_length);
             addrlen = sizeof (struct sockaddr_in6);
             break;
-#endif
         default:
             continue;
         }
@@ -819,7 +819,6 @@ cf.data: cf.data.pre Makefile
 	-e "s%[@]DEFAULT_CONFIG_DIR[@]%$(DEFAULT_CONFIG_DIR)%g" \
 	-e "s%[@]DEFAULT_PREFIX[@]%$(DEFAULT_PREFIX)%g" \
 	-e "s%[@]DEFAULT_HOSTS[@]%$(DEFAULT_HOSTS)%g" \
-	-e "s%[@]IPV6_ONLY_SETTING[@]%$(SET_IPV6_SETTINGS)%g" \
 	-e "s%[@]SQUID[@]%SQUID\ $(VERSION)%g" \
 	< $(srcdir)/cf.data.pre >$@
 
@@ -173,7 +173,6 @@ GetHostWithPort(char *token, Ip::Address *ipa)
     host = NULL;
     port = 0;
 
-#if USE_IPV6
     if (*token == '[') {
         /* [host]:port */
         host = token + 1;
@@ -184,22 +183,20 @@ GetHostWithPort(char *token, Ip::Address *ipa)
         if (*t != ':')
             return false;
         port = xatos(t + 1);
-    } else
-#endif
-        if ((t = strchr(token, ':'))) {
-            /* host:port */
-            host = token;
-            *t = '\0';
-            port = xatos(t + 1);
-
-            if (0 == port)
-                return false;
-        } else if ((port = strtol(token, &tmp, 10)), !*tmp) {
-            /* port */
-        } else {
-            host = token;
-            port = 0;
-        }
+    } else if ((t = strchr(token, ':'))) {
+        /* host:port */
+        host = token;
+        *t = '\0';
+        port = xatos(t + 1);
+
+        if (0 == port)
+            return false;
+    } else if ((port = strtol(token, &tmp, 10)), !*tmp) {
+        /* port */
+    } else {
+        host = token;
+        port = 0;
+    }
 
     if (NULL == host)
         ipa->SetAnyAddr();
@@ -34,9 +34,10 @@
  */
 
 #include "squid.h"
-#include "compat/getaddrinfo.h"
+//#include "compat/getaddrinfo.h"
 #include "acl/Ip.h"
 #include "acl/Checklist.h"
+#include "ip/tools.h"
 #include "MemBuf.h"
 #include "wordlist.h"
 
@@ -109,12 +110,8 @@ acl_ip_data::toStr(char *buf, int len) const
     if (!mask.IsNoAddr()) {
         b3[0] = '/';
         rlen++;
-#if USE_IPV6
         int cidr =  mask.GetCIDR() - (addr1.IsIPv4()?96:0);
         snprintf(&(b3[1]), (len-rlen), "%u", (unsigned int)(cidr<0?0:cidr) );
-#else
-        snprintf(&(b3[1]), (len-rlen), "%u", mask.GetCIDR() );
-#endif
     } else
         b3[0] = '\0';
 }
@@ -225,9 +222,7 @@ acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
             /* this will completely crap out with a security fail-open if the admin is playing mask tricks */
             /* however, thats their fault, and we do warn. see bug 2601 for the effects if we don't do this. */
             unsigned int m = mask.GetCIDR();
-#if USE_IPV6
             debugs(28, DBG_CRITICAL, "WARNING: IPv4 netmasks are particularly nasty when used to compare IPv6 to IPv4 ranges.");
-#endif
             debugs(28, DBG_CRITICAL, "WARNING: For now we will assume you meant to write /" << m);
             /* reset the mask completely, and crop to the CIDR boundary back properly. */
             mask.SetNoAddr();
@@ -288,7 +283,6 @@ acl_ip_data::FactoryParse(const char *t)
         return q;
     }
 
-#if USE_IPV6
     /* Special ACL RHS "ipv4" matches IPv4 Internet
      * A nod to IANA; we include the entire class space in case
      * they manage to find a way to recover and use it */
@@ -363,7 +357,6 @@ acl_ip_data::FactoryParse(const char *t)
 
         return r;
     }
-#endif
 
 // IPv4
     if (sscanf(t, SCAN_ACL1_4, addr1, addr2, mask) == 3) {
@@ -422,8 +415,9 @@ acl_ip_data::FactoryParse(const char *t)
             hints.ai_flags |= AI_NUMERICHOST;
         }
 
-#if 0 && USE_IPV6 && !IPV6_SPECIAL_SPLITSTACK
-        hints.ai_flags |= AI_V4MAPPED | AI_ALL;
+#if 0
+        if (Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING)
+            hints.ai_flags |= AI_V4MAPPED | AI_ALL;
 #endif
 
         int errcode = getaddrinfo(addr1,NULL,&hints,&hp);
@@ -474,13 +468,11 @@ acl_ip_data::FactoryParse(const char *t)
         return q;
     }
 
-#if !USE_IPV6
     /* ignore IPv6 addresses when built with IPv4-only */
-    if ( iptype == AF_INET6 ) {
-        debugs(28, 0, "aclIpParseIpData: IPv6 has not been enabled. build with '--enable-ipv6'");
+    if ( iptype == AF_INET6 && !Ip::EnableIpv6) {
+        debugs(28, DBG_IMPORTANT, "aclIpParseIpData: IPv6 has not been enabled.");
         return NULL;
     }
-#endif
 
     /* Decode addr1 */
     if (!*addr1 || !(q->addr1 = addr1)) {
@@ -58,6 +58,7 @@
 #include "ident/Config.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
+#include "ip/tools.h"
 #include "log/Config.h"
 #include "MemBuf.h"
 #include "Parsing.h"
@@ -3084,7 +3085,6 @@ parse_http_port_specification(http_port_list * s, char *token)
     s->name = xstrdup(token);
     s->connection_auth_disabled = false;
 
-#if USE_IPV6
     if (*token == '[') {
         /* [ipv6]:port */
         host = token + 1;
@@ -3098,23 +3098,25 @@ parse_http_port_specification(http_port_list * s, char *token)
             debugs(3, 0, "http(s)_port: missing Port in: " << token);
             self_destruct();
         }
-        port = xatos(t + 1);
-    } else
-#endif
-        if ((t = strchr(token, ':'))) {
-            /* host:port */
-            /* ipv4:port */
-            host = token;
-            *t = '\0';
-            port = xatos(t + 1);
-
-        } else if ((port = strtol(token, &junk, 10)), !*junk) {
-            /* port */
-            debugs(3, 3, "http(s)_port: found Listen on Port: " << port);
-        } else {
-            debugs(3, 0, "http(s)_port: missing Port: " << token);
+        if (!Ip::EnableIpv6) {
+            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 is not available.");
             self_destruct();
         }
+        port = xatos(t + 1);
+    } else if ((t = strchr(token, ':'))) {
+        /* host:port */
+        /* ipv4:port */
+        host = token;
+        *t = '\0';
+        port = xatos(t + 1);
+
+    } else if ((port = strtol(token, &junk, 10)), !*junk) {
+        /* port */
+        debugs(3, 3, "http(s)_port: found Listen on Port: " << port);
+    } else {
+        debugs(3, 0, "http(s)_port: missing Port: " << token);
+        self_destruct();
+    }
 
     if (port == 0) {
         debugs(3, 0, "http(s)_port: Port cannot be 0: " << token);
@@ -3161,14 +3163,13 @@ parse_http_port_option(http_port_list * s, char *token)
         debugs(3, DBG_IMPORTANT, "Starting Authentication on port " << s->s);
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (interception enabled)");
 
-#if USE_IPV6
         /* INET6: until transparent REDIRECT works on IPv6 SOCKET, force wildcard to IPv4 */
-        debugs(3, DBG_IMPORTANT, "Disabling IPv6 on port " << s->s << " (interception enabled)");
+        if (Ip::EnableIpv6)
+            debugs(3, DBG_IMPORTANT, "Disabling IPv6 on port " << s->s << " (interception enabled)");
         if ( !s->s.SetIPv4() ) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot be transparent (protocol does not provide NAT)" << s->s );
             self_destruct();
         }
-#endif
     } else if (strcmp(token, "tproxy") == 0) {
         if (s->intercepted || s->accel) {
             debugs(3,DBG_CRITICAL, "FATAL: http(s)_port: TPROXY option requires its own interception port. It cannot be shared with other modes.");
@@ -3251,12 +3252,10 @@ parse_http_port_option(http_port_list * s, char *token)
         else
             self_destruct();
     } else if (strcmp(token, "ipv4") == 0) {
-#if USE_IPV6
         if ( !s->s.SetIPv4() ) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot be used a IPv4-Only." << s->s );
+            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot be used as IPv4-Only. " << s->s );
             self_destruct();
         }
-#endif
     } else if (strcmp(token, "tcpkeepalive") == 0) {
         s->tcp_keepalive.enabled = 1;
     } else if (strncmp(token, "tcpkeepalive=", 13) == 0) {
@@ -3338,7 +3337,6 @@ add_http_port(char *portspec)
     Config.Sockaddr.http = s;
 }
 
-#if IPV6_SPECIAL_SPLITSTACK
 http_port_list *
 clone_http_port_list(http_port_list *a)
 {
@@ -3388,7 +3386,6 @@ clone_http_port_list(http_port_list *a)
 
     return b;
 }
-#endif
 
 static void
 parse_http_port_list(http_port_list ** head)
@@ -3407,14 +3404,12 @@ parse_http_port_list(http_port_list ** head)
         parse_http_port_option(s, token);
     }
 
-#if IPV6_SPECIAL_SPLITSTACK
-    if (s->s.IsAnyAddr()) {
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.IsAnyAddr()) {
         // clone the port options from *s to *(s->next)
         s->next = clone_http_port_list(s);
         s->next->s.SetIPv4();
         debugs(3, 3, "http(s)_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
-#endif
 
     while (*head)
         head = &(*head)->next;
@@ -481,7 +481,7 @@ DOC_START
 	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers
 	  ipv4 / ipv6	IP-mode used to communicate to this helper.
 			For compatability with older configurations and helpers
-			the default is 'ipv4'.
+			the default is currently 'ipv4'.
 
 	FORMAT specifications
 
@@ -786,19 +786,17 @@ NOCOMMENT_START
 # Recommended minimum configuration:
 #
 acl manager proto cache_object
-acl localhost src 127.0.0.1/32
-@IPV6_ONLY_SETTING@acl localhost src ::1/128
-acl to_localhost dst 127.0.0.0/8 0.0.0.0/32
-@IPV6_ONLY_SETTING@acl to_localhost dst ::1/128
+acl localhost src 127.0.0.1/32 ::1
+acl to_localhost dst 127.0.0.0/8 0.0.0.0/32 ::1
 
 # Example rule allowing access from your local networks.
 # Adapt to list your (internal) IP networks from where browsing
 # should be allowed
 acl localnet src 10.0.0.0/8	# RFC1918 possible internal network
 acl localnet src 172.16.0.0/12	# RFC1918 possible internal network
 acl localnet src 192.168.0.0/16	# RFC1918 possible internal network
-@IPV6_ONLY_SETTING@acl localnet src fc00::/7   # RFC 4193 local private network range
-@IPV6_ONLY_SETTING@acl localnet src fe80::/10  # RFC 4291 link-local (directly plugged) machines
+acl localnet src fc00::/7       # RFC 4193 local private network range
+acl localnet src fe80::/10      # RFC 4291 link-local (directly plugged) machines
 
 acl SSL_ports port 443
 acl Safe_ports port 80		# http
@@ -420,12 +420,10 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
     *ErrP = SNMP_ERR_NOERROR;
     MemBuf tmp;
     debugs(49, 6, HERE << "Current : length=" << Var->name_length << ": " << snmpDebugOid(Var->name, Var->name_length, tmp));
-    if (Var->name_length == 16 ) {
+    if (Var->name_length == 16) {
         oid2addr(&(Var->name[12]), keyIp, 4);
-#if USE_IPV6
-    } else if (Var->name_length == 28 ) {
+    } else if (Var->name_length == 28) {
         oid2addr(&(Var->name[12]), keyIp, 16);
-#endif
     } else {
         *ErrP = SNMP_ERR_NOSUCHNAME;
         return NULL;
@@ -3043,7 +3043,7 @@ connStateCreate(const Ip::Address &peer, const Ip::Address &me, int fd, http_por
 
     result->peer = peer;
     result->log_addr = peer;
-    result->log_addr.ApplyMask(Config.Addrs.client_netmask.GetCIDR());
+    result->log_addr.ApplyMask(Config.Addrs.client_netmask);
     result->me = me;
     result->fd = fd;
     result->in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &result->in.allocatedSize);
@@ -51,6 +51,7 @@
 #include "icmp/net_db.h"
 #include "ip/Address.h"
 #include "ip/Intercept.h"
+#include "ip/tools.h"
 
 #if defined(_SQUID_CYGWIN_)
 #include <sys/ioctl.h>
@@ -537,10 +538,8 @@ comm_local_port(int fd)
     if (F->local_addr.GetPort())
         return F->local_addr.GetPort();
 
-#if USE_IPV6
     if (F->sock_family == AF_INET)
         temp.SetIPv4();
-#endif
 
     temp.InitAddrInfo(addr);
 
@@ -694,10 +693,10 @@ comm_openex(int sock_type,
     debugs(50, 3, "comm_openex: Attempt open socket for: " << addr );
 
     new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
-#if USE_IPV6
+
     /* under IPv6 there is the possibility IPv6 is present but disabled. */
     /* try again as IPv4-native if possible */
-    if ( new_socket < 0 && addr.IsIPv6() && addr.SetIPv4() ) {
+    if ( new_socket < 0 && Ip::EnableIpv6 && addr.IsIPv6() && addr.SetIPv4() ) {
         /* attempt to open this IPv4-only. */
         addr.FreeAddrInfo(AI);
         /* Setup the socket addrinfo details for use */
@@ -708,7 +707,6 @@ comm_openex(int sock_type,
         new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
         debugs(50, 2, HERE << "attempt open " << note << " socket on: " << addr);
     }
-#endif
 
     if (new_socket < 0) {
         /* Increase the number of reserved fd's if calls to socket()
@@ -735,22 +733,14 @@ comm_openex(int sock_type,
         tos = TOS;
     }
 
-#if IPV6_SPECIAL_SPLITSTACK
-
-    if ( addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && addr.IsIPv6() )
         comm_set_v6only(new_socket, 1);
 
-#endif
-
-#if IPV6_SPECIAL_V4MAPPED
-
     /* Windows Vista supports Dual-Sockets. BUT defaults them to V6ONLY. Turn it OFF. */
     /* Other OS may have this administratively disabled for general use. Same deal. */
-    if ( addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING && addr.IsIPv6() )
         comm_set_v6only(new_socket, 0);
 
-#endif
-
     comm_init_opened(new_socket, addr, TOS, note, AI);
     new_socket = comm_apply_flags(new_socket, addr, flags, AI);
 
@@ -1101,10 +1091,8 @@ ConnectStateData::commResetFD()
     if (F->tos)
         comm_set_tos(fd, F->tos);
 
-#if IPV6_SPECIAL_SPLITSTACK
-    if ( F->local_addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && F->local_addr.IsIPv6() )
         comm_set_v6only(fd, 1);
-#endif
 
     copyFDFlags(fd, F);
 
@@ -1295,7 +1283,6 @@ comm_connect_addr(int sock, const Ip::Address &address)
 
     debugs(5, 9, HERE << "connecting socket FD " << sock << " to " << address << " (want family: " << F->sock_family << ")");
 
-#if USE_IPV6
     /* Handle IPv6 over IPv4-only socket case.
      * this case must presently be handled here since the GetAddrInfo asserts on bad mappings.
      * NP: because commResetFD is private to ConnStateData we have to return an error and
@@ -1317,7 +1304,6 @@ comm_connect_addr(int sock, const Ip::Address &address)
         errno = ENETUNREACH;
         return COMM_ERR_PROTOCOL;
     }
-#endif /* USE_IPV6 */
 
     address.GetAddrInfo(AI, F->sock_family);
 
@@ -267,11 +267,7 @@ Comm::ListenStateData::oldAccept(ConnectionDetail &details)
     details.peer.NtoA(F->ipaddr,MAX_IPSTRLEN);
     F->remote_port = details.peer.GetPort();
     F->local_addr.SetPort(details.me.GetPort());
-#if USE_IPV6
-    F->sock_family = AF_INET;
-#else
-    F->sock_family = details.me.IsIPv4()?AF_INET:AF_INET6;
-#endif
+    F->sock_family = details.me.IsIPv6()?AF_INET6:AF_INET;
     details.me.FreeAddrInfo(gai);
 
     commSetNonBlocking(sock);
@@ -593,15 +593,14 @@ comm_poll_dns_incoming(void)
     int nevents;
     dns_io_events = 0;
 
-    if (DnsSocketA < 0)
+    if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
 
-    fds[nfds++] = DnsSocketA;
+    if (DnsSocketA >= 0)
+        fds[nfds++] = DnsSocketA;
 
-#if IPV6_SPECIAL_SPLITSTACK
-    if (DnsSocketB > 0)
+    if (DnsSocketB >= 0)
         fds[nfds++] = DnsSocketB;
-#endif
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
 
@@ -632,15 +632,14 @@ comm_select_dns_incoming(void)
     int nevents;
     dns_io_events = 0;
 
-    if (DnsSocketA < 0)
+    if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
 
-    fds[nfds++] = DnsSocketA;
+    if (DnsSocketA >= 0)
+        fds[nfds++] = DnsSocketA;
 
-#if IPV6_SPECIAL_SPLITSTACK
-    if (DnsSocketB > 0)
+    if (DnsSocketB >= 0)
         fds[nfds++] = DnsSocketB;
-#endif
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
@@ -654,15 +654,14 @@ comm_select_dns_incoming(void)
     int nevents;
     dns_io_events = 0;
 
-    if (DnsSocketA < 0)
+    if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
 
-    fds[nfds++] = DnsSocketA;
+    if (DnsSocketA >= 0)
+        fds[nfds++] = DnsSocketA;
 
-#if IPV6_SPECIAL_SPLITSTACK
-    if (DnsSocketB > 0)
+    if (DnsSocketB >= 0)
         fds[nfds++] = DnsSocketB;
-#endif
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
@@ -41,6 +41,7 @@
 #include "Store.h"
 #include "comm.h"
 #include "fde.h"
+#include "ip/tools.h"
 #include "MemBuf.h"
 
 #include "wordlist.h"
@@ -813,35 +814,27 @@ idnsSendQuery(idns_query * q)
             idnsSendQueryVC(q, ns);
             x = y = 0;
         } else {
-#if IPV6_SPECIAL_SPLITSTACK
-            if (nameservers[ns].S.IsIPv6() && DnsSocketB > 0)
+            if (DnsSocketB >= 0 && nameservers[ns].S.IsIPv6())
                 y = comm_udp_sendto(DnsSocketB, nameservers[ns].S, q->buf, q->sz);
             else
-#endif
                 x = comm_udp_sendto(DnsSocketA, nameservers[ns].S, q->buf, q->sz);
         }
 
         q->nsends++;
 
         q->queue_t = q->sent_t = current_time;
 
-#if IPV6_SPECIAL_SPLITSTACK
         if (y < 0 && nameservers[ns].S.IsIPv6())
             debugs(50, 1, "idnsSendQuery: FD " << DnsSocketB << ": sendto: " << xstrerror());
         if (x < 0 && nameservers[ns].S.IsIPv4())
-#else
-        if (x < 0)
-#endif
             debugs(50, 1, "idnsSendQuery: FD " << DnsSocketA << ": sendto: " << xstrerror());
 
     } while ( (x<0 && y<0) && q->nsends % nns != 0);
 
-#if IPV6_SPECIAL_SPLITSTACK
     if (y >= 0) {
         fd_bytes(DnsSocketB, y, FD_WRITE);
         commSetSelect(DnsSocketB, COMM_SELECT_READ, idnsRead, NULL, 0);
     }
-#endif
 
     if (x >= 0) {
         fd_bytes(DnsSocketA, x, FD_WRITE);
@@ -1032,13 +1025,10 @@ idnsGrokReply(const char *buf, size_t sz)
             q->start_t = current_time;
             q->id = idnsQueryID();
             rfc1035SetQueryID(q->buf, q->id);
-#if USE_IPV6
-            if (q->query.qtype == RFC1035_TYPE_AAAA) {
+            if (Ip::EnableIpv6 && q->query.qtype == RFC1035_TYPE_AAAA) {
                 debugs(78, 3, "idnsGrokReply: Trying AAAA Query for " << q->name);
                 q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
-            } else
-#endif
-            {
+            } else {
                 debugs(78, 3, "idnsGrokReply: Trying A Query for " << q->name);
                 q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
             }
@@ -1048,7 +1038,6 @@ idnsGrokReply(const char *buf, size_t sz)
         }
     }
 
-#if USE_IPV6
     if (q->need_A && (Config.onoff.dns_require_A == 1 || n <= 0 ) ) {
         /* ERROR or NO AAAA exist. Failover to A records. */
         /*      Apparently its also a good idea to lookup and store the A records
@@ -1085,7 +1074,6 @@ idnsGrokReply(const char *buf, size_t sz)
         idnsSendQuery(q);
         return;
     }
-#endif
 
     /** If there are two result sets from preceeding AAAA and A lookups merge them with a preference for AAAA */
     if (q->initial_AAAA.count > 0 && n > 0) {
@@ -1168,12 +1156,7 @@ idnsRead(int fd, void *data)
             break;
         }
 
-#if IPV6_SPECIAL_SPLITSTACK
-        if ( from.IsIPv6() )
-            fd_bytes(DnsSocketB, len, FD_READ);
-        else
-#endif
-            fd_bytes(DnsSocketA, len, FD_READ);
+        fd_bytes(fd, len, FD_READ);
 
         assert(N);
         (*N)++;
@@ -1201,12 +1184,7 @@ idnsRead(int fd, void *data)
     }
 
     if (lru_list.head) {
-#if IPV6_SPECIAL_SPLITSTACK
-        if ( from.IsIPv6() )
-            commSetSelect(DnsSocketB, COMM_SELECT_READ, idnsRead, NULL, 0);
-        else
-#endif
-            commSetSelect(DnsSocketA, COMM_SELECT_READ, idnsRead, NULL, 0);
+        commSetSelect(fd, COMM_SELECT_READ, idnsRead, NULL, 0);
     }
 }
 
@@ -1357,62 +1335,47 @@ idnsInit(void)
     if (DnsSocketA < 0 && DnsSocketB < 0) {
         int port;
 
-        Ip::Address addr; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
+        Ip::Address addrA; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
         if (!Config.Addrs.udp_outgoing.IsNoAddr())
-            addr = Config.Addrs.udp_outgoing;
+            addrA = Config.Addrs.udp_outgoing;
         else
-            addr = Config.Addrs.udp_incoming;
+            addrA = Config.Addrs.udp_incoming;
 
-#if IPV6_SPECIAL_SPLITSTACK
-        Ip::Address addr4 = addr;
+        Ip::Address addrB = addrA;
+        addrA.SetIPv4();
 
-        if ( addr.IsAnyAddr() || addr.IsIPv6() ) {
-            debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addr);
+        if (Ip::EnableIpv6 && (addrB.IsAnyAddr() || addrB.IsIPv6())) {
+            debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addrB);
             DnsSocketB = comm_open_listener(SOCK_DGRAM,
                                             IPPROTO_UDP,
-                                            addr,
+                                            addrB,
                                             COMM_NONBLOCKING,
-                                            "DNS Socket v6");
+                                            "DNS Socket IPv6");
         }
 
-        if ( addr.IsAnyAddr() || addr.IsIPv4() ) {
-            addr4.SetIPv4();
-            debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addr4);
+        if (addrA.IsAnyAddr() || addrA.IsIPv4()) {
+            debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addrA);
             DnsSocketA = comm_open_listener(SOCK_DGRAM,
                                             IPPROTO_UDP,
-                                            addr4,
+                                            addrA,
                                             COMM_NONBLOCKING,
-                                            "DNS Socket v4");
+                                            "DNS Socket IPv4");
         }
-#else
-        debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addr);
-        DnsSocketA = comm_open_listener(SOCK_DGRAM,
-                                        IPPROTO_UDP,
-                                        addr,
-                                        COMM_NONBLOCKING,
-                                        "DNS Socket");
-#endif
 
         if (DnsSocketA < 0 && DnsSocketB < 0)
             fatal("Could not create a DNS socket");
 
         /* Ouch... we can't call functions using debug from a debug
          * statement. Doing so messes up the internal Debug::level
          */
-#if IPV6_SPECIAL_SPLITSTACK
         if (DnsSocketB >= 0) {
             port = comm_local_port(DnsSocketB);
-            debugs(78, 1, "DNS Socket created at " << addr << ", FD " << DnsSocketB);
+            debugs(78, 1, "DNS Socket created at " << addrB << ", FD " << DnsSocketB);
         }
-#endif
         if (DnsSocketA >= 0) {
             port = comm_local_port(DnsSocketA);
-#if IPV6_SPECIAL_SPLITSTACK
-            debugs(78, 1, "DNS Socket created at " << addr4 << ", FD " << DnsSocketA);
-#else
-            debugs(78, 1, "DNS Socket created at " << addr << ", FD " << DnsSocketA);
-#endif
+            debugs(78, 1, "DNS Socket created at " << addrA << ", FD " << DnsSocketA);
         }
     }
 
@@ -1466,12 +1429,10 @@ idnsShutdown(void)
         DnsSocketA = -1;
     }
 
-#if IPV6_SPECIAL_SPLITSTACK
-    if (DnsSocketA >= 0 ) {
+    if (DnsSocketB >= 0 ) {
         comm_close(DnsSocketB);
         DnsSocketB = -1;
     }
-#endif
 
     for (int i = 0; i < nns; i++) {
         if (nsvc *vc = nameservers[i].vc) {
@@ -1548,13 +1509,13 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
         debugs(78, 3, "idnsALookup: searchpath used for " << q->name);
     }
 
-#if USE_IPV6
-    q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
-    q->need_A = true;
-#else
-    q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
-    q->need_A = false;
-#endif
+    if (Ip::EnableIpv6) {
+        q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->need_A = true;
+    } else {
+        q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->need_A = false;
+    }
 
     if (q->sz < 0) {
         /* problem with query data -- query not sent */
@@ -1590,14 +1551,11 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 
     q->id = idnsQueryID();
 
-#if USE_IPV6
-    if ( addr.IsIPv6() ) {
+    if (Ip::EnableIpv6 && addr.IsIPv6()) {
         struct in6_addr addr6;
         addr.GetInAddr(addr6);
         q->sz = rfc3596BuildPTRQuery6(addr6, q->buf, sizeof(q->buf), q->id, &q->query);
-    } else
-#endif
-    {
+    } else {
         struct in_addr addr4;
         addr.GetInAddr(addr4);
         q->sz = rfc3596BuildPTRQuery4(addr4, q->buf, sizeof(q->buf), q->id, &q->query);
@@ -254,11 +254,9 @@ lookup(const char *buf)
                 case AF_INET:
                     inet_ntop(aiptr->ai_family, &((struct sockaddr_in*)aiptr->ai_addr)->sin_addr, ntoabuf, MAX_IPSTRLEN);
                     break;
-#if USE_IPV6
                 case AF_INET6:
                     inet_ntop(aiptr->ai_family, &((struct sockaddr_in6*)aiptr->ai_addr)->sin6_addr, ntoabuf, MAX_IPSTRLEN);
                     break;
-#endif
                 default:
                     aiptr = aiptr->ai_next;
                     continue;
@@ -48,7 +48,6 @@ Eui::Eui64::lookup(Ip::Address &c)
 bool
 Eui::Eui64::lookupSlaac(Ip::Address &c)
 {
-#if USE_IPV6
     /* RFC 4291 Link-Local unicast addresses which contain SLAAC - usually trustable. */
     if (c.IsSiteLocal6() && c.IsSlaac() ) {
 
@@ -59,7 +58,6 @@ Eui::Eui64::lookupSlaac(Ip::Address &c)
 
         return true;
     }
-#endif
     return false;
 }
 
@@ -68,7 +66,6 @@ bool
 Eui::Eui64::lookupNdp(Ip::Address &c)
 {
 #if 0 /* no actual lookup coded yet */
-#if USE_IPV6
 
     /* no OS yet supported for NDP protocol lookup */
     debugs(28, 0, "ERROR: ARP / MAC / EUI-* operations not supported on this operating system.");
@@ -77,9 +74,6 @@ Eui::Eui64::lookupNdp(Ip::Address &c)
      * Address was not found on any interface
      */
     debugs(28, 3, HERE << c << " NOT found");
-#else
-    debugs(28, 0, "ERROR: IPv6 EUI-64 operations not supported on this operating system.");
-#endif
 #endif /* 0 */
 
     clear();
@@ -53,6 +53,7 @@
 #if USE_IDENT
 #include "ident/AclIdent.h"
 #endif
+#include "ip/tools.h"
 #include "client_side.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
@@ -352,11 +353,9 @@ parse_externalAclHelper(external_acl ** list)
                 debugs(3, 0, "WARNING: Error converting " << a->local_addr << " to IPv4 in " << a->name );
             }
         } else if (strcmp(token, "ipv6") == 0) {
-#if !USE_IPV6
-            debugs(3, 0, "WARNING: --enable-ipv6 required for external ACL helpers to use IPv6: " << a->name );
-#else
-            (void)0;
-#endif
+            if (!Ip::EnableIpv6)
+                debugs(3, 0, "WARNING: --enable-ipv6 required for external ACL helpers to use IPv6: " << a->name );
+            // else nothing to do.
         } else {
             break;
         }
@@ -45,6 +45,7 @@
 #include "HttpHeader.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
+#include "ip/tools.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
 #include "Server.h"
@@ -2326,6 +2327,7 @@ ftpReadEPSV(FtpStateData* ftpState)
         /* server response with list of supported methods   */
         /*   522 Network protocol not supported, use (1)    */
         /*   522 Network protocol not supported, use (1,2)  */
+        /*   522 Network protocol not supported, use (2)  */
         /* TODO: handle the (1,2) case. We might get it back after EPSV ALL
          * which means close data + control without self-destructing and re-open from scratch. */
         debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
@@ -2341,20 +2343,19 @@ ftpReadEPSV(FtpStateData* ftpState)
             ftpState->state = SENT_EPSV_2; /* simulate having sent and failed EPSV 2 */
             ftpSendPassive(ftpState);
         } else if (strcmp(buf, "(2)") == 0) {
-#if USE_IPV6
-            /* If server only supports EPSV 2 and we have already tried that. Go straight to EPRT */
-            if (ftpState->state == SENT_EPSV_2) {
-                ftpSendEPRT(ftpState);
+            if (Ip::EnableIpv6) {
+                /* If server only supports EPSV 2 and we have already tried that. Go straight to EPRT */
+                if (ftpState->state == SENT_EPSV_2) {
+                    ftpSendEPRT(ftpState);
+                } else {
+                    /* or try the next Passive mode down the chain. */
+                    ftpSendPassive(ftpState);
+                }
             } else {
-                /* or try the next Passive mode down the chain. */
+                /* Server only accept EPSV in IPv6 traffic. */
+                ftpState->state = SENT_EPSV_1; /* simulate having sent and failed EPSV 1 */
                 ftpSendPassive(ftpState);
             }
-#else
-            /* We do not support IPv6. Remote server requires it.
-               So we must simulate having failed all EPSV methods. */
-            ftpState->state = SENT_EPSV_1;
-            ftpSendPassive(ftpState);
-#endif
         } else {
             /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
             debugs(9, DBG_IMPORTANT, "WARNING: Server at " << fd_table[ftpState->ctrl.fd].ipaddr << " sent unknown protocol negotiation hint: " << buf);
@@ -2527,13 +2528,11 @@ ftpSendPassive(FtpStateData * ftpState)
             /* block other non-EPSV connections being attempted */
             ftpState->flags.epsv_all_sent = true;
         } else {
-#if USE_IPV6
             if (addr.IsIPv6()) {
                 debugs(9, 5, HERE << "FTP Channel (" << addr << "). Sending default EPSV 2");
                 snprintf(cbuf, 1024, "EPSV 2\r\n");
                 ftpState->state = SENT_EPSV_2;
             }
-#endif
             if (addr.IsIPv4()) {
                 debugs(9, 5, HERE << "Channel (" << addr <<"). Sending default EPSV 1");
                 snprintf(cbuf, 1024, "EPSV 1\r\n");
@@ -2813,7 +2812,6 @@ ftpSendPORT(FtpStateData * ftpState)
         return;
     }
 
-#if USE_IPV6
     if ( AI->ai_addrlen != sizeof(struct sockaddr_in) ) {
         ipa.FreeAddrInfo(AI);
         /* IPv6 CANNOT send PORT command.                           */
@@ -2822,7 +2820,6 @@ ftpSendPORT(FtpStateData * ftpState)
         ftpReadPORT(ftpState);
         return;
     }
-#endif
 
     addrptr = (unsigned char *) &((struct sockaddr_in*)AI->ai_addr)->sin_addr;
     portptr = (unsigned char *) &((struct sockaddr_in*)AI->ai_addr)->sin_port;
@@ -39,9 +39,7 @@
 
 #define MAX_PAYLOAD 256 // WAS: SQUIDHOSTNAMELEN
 #define MAX_PKT4_SZ (MAX_PAYLOAD + sizeof(struct timeval) + sizeof (char) + sizeof(struct icmphdr) + 1)
-#if USE_IPV6
 #define MAX_PKT6_SZ (MAX_PAYLOAD + sizeof(struct timeval) + sizeof (char) + sizeof(struct icmp6_hdr) + 1)
-#endif
 
 #if USE_ICMP
 
@@ -35,7 +35,7 @@
 
 #include "squid.h"
 
-#if USE_ICMP && USE_IPV6
+#if USE_ICMP
 
 #include "SquidTime.h"
 #include "Debug.h"
@@ -338,4 +338,4 @@ Icmp6::Recv(void)
     control.SendResult(preply, (sizeof(pingerReplyData) - PINGER_PAYLOAD_SZ + preply.psize) );
 }
 
-#endif /* USE_ICMP && USE_IPV6 */
+#endif /* USE_ICMP */
@@ -34,8 +34,6 @@
 
 #include "config.h"
 
-#if USE_IPV6
-
 #include "Icmp.h"
 
 #if HAVE_NETINET_IN_H
@@ -87,5 +85,4 @@ class Icmp6 : public Icmp
 SQUIDCEXTERN Icmp6 icmp6;
 
 #endif /* USE_ICMP && SQUID_HELPER */
-#endif /* USE_IPV6 */
 #endif /* _INCLUDE_ICMPV6_H */
@@ -171,9 +171,7 @@ IcmpPinger::Close(void)
 
     /* also shutdown the helper engines */
     icmp4.Close();
-#if USE_IPV6
     icmp6.Close();
-#endif
 }
 
 void
@@ -208,7 +206,6 @@ IcmpPinger::Recv(void)
         return;
     }
 
-#if USE_IPV6
     /* pass request for ICMPv6 handing */
     if (pecho.to.IsIPv6()) {
         debugs(42, 2, HERE << " Pass " << pecho.to << " off to ICMPv6 module.");
@@ -217,7 +214,6 @@ IcmpPinger::Recv(void)
                        pecho.payload,
                        pecho.psize);
     }
-#endif
 
     /* pass the packet for ICMP handling */
     else if (pecho.to.IsIPv4()) {
@@ -35,6 +35,7 @@
 #include "squid.h"
 #include "icmp/IcmpSquid.h"
 #include "icmp/net_db.h"
+#include "ip/tools.h"
 #include "comm.h"
 #include "SquidTime.h"
 
@@ -253,9 +254,8 @@ IcmpSquid::Open(void)
     debugs(37, 1, HERE << "Pinger socket opened on FD " << icmp_sock);
 
     /* Tests the pinger immediately using localhost */
-#if USE_IPV6
-    SendEcho(localhost, S_ICMP_ECHO, "ip6-localhost");
-#endif
+    if (Ip::EnableIpv6)
+        SendEcho(localhost, S_ICMP_ECHO, "ip6-localhost");
     if (localhost.SetIPv4())
         SendEcho(localhost, S_ICMP_ECHO, "localhost");
 
@@ -345,16 +345,13 @@ networkFromInaddr(const Ip::Address &in)
     Ip::Address out;
 
     out = in;
-#if USE_IPV6
 
     /* in IPv6 the 'network' should be the routing section. */
-
     if ( in.IsIPv6() ) {
         out.ApplyMask(64, AF_INET6);
         debugs(14, 5, "networkFromInaddr : Masked IPv6 Address to " << in << "/64 routing part.");
         return out;
     }
-#endif
 
 #if USE_CLASSFUL
     struct in_addr b;
@@ -109,9 +109,7 @@ Win32__WSAFDIsSet(int fd, fd_set FAR * set)
 // ICMP Engines are declared global here so they can call each other easily.
 IcmpPinger control;
 Icmp4 icmp4;
-#if USE_IPV6
 Icmp6 icmp6;
-#endif
 
 int icmp_pkts_sent = 0;
 
@@ -139,9 +137,7 @@ main(int argc, char *argv[])
      * drop privs
      */
     int icmp4_worker = -1;
-#if USE_IPV6
     int icmp6_worker = -1;
-#endif
     int squid_link = -1;
 
     /** start by initializing the pinger debug cache.log-pinger. */
@@ -169,22 +165,15 @@ main(int argc, char *argv[])
 #endif
 
     /** abort if neither worker could open a socket. */
-    if (icmp4_worker == -1) {
-#if USE_IPV6
-        if (icmp6_worker == -1)
-#endif
-        {
-            debugs(42, 0, "FATAL: pinger: Unable to open any ICMP sockets.");
-            exit(1);
-        }
+    if (icmp4_worker < 0 && icmp6_worker < 0) {
+        debugs(42, 0, "FATAL: pinger: Unable to open any ICMP sockets.");
+        exit(1);
     }
 
     if ( (squid_link = control.Open()) < 0) {
         debugs(42, 0, "FATAL: pinger: Unable to setup Pinger control sockets.");
         icmp4.Close();
-#if USE_IPV6
         icmp6.Close();
-#endif
         exit(1); // fatal error if the control channel fails.
     }
     max_fd = max(max_fd, squid_link);
@@ -201,12 +190,10 @@ main(int argc, char *argv[])
         if (icmp4_worker >= 0) {
             FD_SET(icmp4_worker, &R);
         }
-#if USE_IPV6
-
         if (icmp6_worker >= 0) {
             FD_SET(icmp6_worker, &R);
         }
-#endif
+
         FD_SET(squid_link, &R);
         x = select(10, &R, NULL, NULL, &tv);
         getCurrentTime();
@@ -221,12 +208,9 @@ main(int argc, char *argv[])
             control.Recv();
         }
 
-#if USE_IPV6
         if (icmp6_worker >= 0 && FD_ISSET(icmp6_worker, &R)) {
             icmp6.Recv();
         }
-#endif
-
         if (icmp4_worker >= 0 && FD_ISSET(icmp4_worker, &R)) {
             icmp4.Recv();
         }
@@ -101,25 +101,19 @@ internalRemoteUri(const char *host, u_short port, const char *dir, const char *n
     xstrncpy(lc_host, host, SQUIDHOSTNAMELEN);
     Tolower(lc_host);
 
-#if USE_IPV6
     /* check for an IP address and format appropriately if found */
     Ip::Address test = lc_host;
     if ( !test.IsAnyAddr() ) {
         test.ToHostname(lc_host,SQUIDHOSTNAMELEN);
     }
-#endif
 
     /*
      * append the domain in order to mirror the requests with appended
      * domains
      */
 
-#if USE_IPV6
-    /* For IPV6 addresses also check for a colon */
+    /* For IPv6 addresses also check for a colon */
     if (Config.appendDomain && !strchr(lc_host, '.') && !strchr(lc_host, ':'))
-#else
-    if (Config.appendDomain && !strchr(lc_host, '.'))
-#endif
         strncat(lc_host, Config.appendDomain, SQUIDHOSTNAMELEN -
                 strlen(lc_host) - 1);
 
@@ -159,12 +153,8 @@ internalHostname(void)
     LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
     xstrncpy(host, getMyHostname(), SQUIDHOSTNAMELEN);
 
-#if USE_IPV6
-    /* For IPV6 addresses also check for a colon */
+    /* For IPv6 addresses also check for a colon */
     if (Config.appendDomain && !strchr(host, '.') && !strchr(host, ':'))
-#else
-    if (Config.appendDomain && !strchr(host, '.'))
-#endif
         strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN -
                 strlen(host) - 1);
 
@@ -39,6 +39,7 @@
 #include "compat/getaddrinfo.h"
 #include "Debug.h"
 #include "ip/Address.h"
+#include "ip/tools.h"
 #include "util.h"
 
 #if HAVE_ASSERT_H
@@ -52,22 +53,7 @@
 #include <arpa/inet.h>
 #endif
 
-#ifdef INET6
-#error "INET6 defined but has been deprecated! Try running bootstrap and configure again."
-#endif
-
-#if !USE_IPV6
-//  So there are some places where I will drop to using Macros too.
-//  At least I can restrict them to this file so they don't corrupt the app with C code.
-#  define sin6_addr	sin_addr
-#  define sin6_port	sin_port
-#  define sin6_family	sin_family
-#undef s6_addr
-#  define s6_addr	s_addr
-#endif
-
 /* Debugging only. Dump the address content when a fatal assert is encountered. */
-#if USE_IPV6
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
 		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
@@ -76,14 +62,6 @@
 			printf(" %x", m_SocketAddr.sin6_addr.s6_addr[i]); \
 		} printf("\n"); assert(b); \
 	}
-#else
-#define IASSERT(a,b)  \
-	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
-		printf("ADDRESS: %x\n", (unsigned int)m_SocketAddr.sin_addr.s_addr); \
-		assert(b); \
-	}
-#endif
 
 Ip::Address::Address()
 {
@@ -101,26 +79,19 @@ Ip::Address::GetCIDR() const
     uint8_t shift,byte;
     uint8_t bit,caught;
     int len = 0;
-#if USE_IPV6
     const uint8_t *ptr= m_SocketAddr.sin6_addr.s6_addr;
-#else
-    const uint8_t *ptr= (uint8_t *)&m_SocketAddr.sin_addr.s_addr;
-#endif
 
     /* Let's scan all the bits from Most Significant to Least */
     /* Until we find an "0" bit. Then, we return */
     shift=0;
 
-#if USE_IPV6
     /* return IPv4 CIDR for any Mapped address */
     /* Thus only check the mapped bit */
 
     if ( !IsIPv6() ) {
         shift = 12;
     }
 
-#endif
-
     for (; shift<sizeof(m_SocketAddr.sin6_addr) ; shift++) {
         byte= *(ptr+shift);
 
@@ -169,18 +140,6 @@ Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
     uint8_t clearbits = 0;
     uint8_t* p = NULL;
 
-#if !USE_IPV6
-    IASSERT("mtype != AF_INET6", mtype != AF_INET6); /* using IPv6 in IPv4 is invalid. */
-
-    if (mtype == AF_UNSPEC)
-        mtype = AF_INET;
-
-#else
-    if (mtype == AF_UNSPEC)
-        mtype = AF_INET6;
-
-#endif
-
     // validation and short-cuts.
     if (cidr > 128)
         return false;
@@ -200,16 +159,8 @@ Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
     if (clearbits == 0)
         return true;
 
-#if USE_IPV6
-
     p = (uint8_t*)(&m_SocketAddr.sin6_addr) + 15;
 
-#else
-
-    p = (uint8_t*)(&m_SocketAddr.sin_addr) + 3;
-
-#endif
-
     for (; clearbits>0 && p >= (uint8_t*)&m_SocketAddr.sin6_addr ; p-- ) {
         if (clearbits < 8) {
             *p &= ((0xFF << clearbits) & 0xFF);
@@ -232,42 +183,26 @@ Ip::Address::IsSockAddr() const
 bool
 Ip::Address::IsIPv4() const
 {
-#if USE_IPV6
     return IsAnyAddr() || IsNoAddr() || IN6_IS_ADDR_V4MAPPED( &m_SocketAddr.sin6_addr );
-#else
-    return true; // enforce IPv4 in IPv4-only mode.
-#endif
 }
 
 bool
 Ip::Address::IsIPv6() const
 {
-#if USE_IPV6
     return IsAnyAddr() || IsNoAddr() || !IN6_IS_ADDR_V4MAPPED( &m_SocketAddr.sin6_addr );
-#else
-    return false; // enforce IPv4 in IPv4-only mode.
-#endif
 }
 
 bool
 Ip::Address::IsAnyAddr() const
 {
-#if USE_IPV6
     return IN6_IS_ADDR_UNSPECIFIED( &m_SocketAddr.sin6_addr );
-#else
-    return (INADDR_ANY == m_SocketAddr.sin_addr.s_addr);
-#endif
 }
 
 /// NOTE: Does NOT clear the Port stored. Ony the Address and Type.
 void
 Ip::Address::SetAnyAddr()
 {
-#if USE_IPV6
     memset(&m_SocketAddr.sin6_addr, 0, sizeof(struct in6_addr) );
-#else
-    memset(&m_SocketAddr.sin_addr, 0, sizeof(struct in_addr) );
-#endif
 }
 
 /// NOTE: completely empties the Ip::Address structure. Address, Port, Type, everything.
@@ -277,7 +212,6 @@ Ip::Address::SetEmpty()
     memset(&m_SocketAddr, 0, sizeof(m_SocketAddr) );
 }
 
-#if USE_IPV6
 const struct in6_addr Ip::Address::v4_localhost = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x01 }}
 };
@@ -290,13 +224,11 @@ const struct in6_addr Ip::Address::v4_noaddr = {{{ 0x00, 0x00, 0x00, 0x00, 0x00,
 const struct in6_addr Ip::Address::v6_noaddr = {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}
 };
-#endif
 
 
 bool
 Ip::Address::SetIPv4()
 {
-#if USE_IPV6
     if ( IsLocalhost() ) {
         m_SocketAddr.sin6_addr = v4_localhost;
         return true;
@@ -312,78 +244,53 @@ Ip::Address::SetIPv4()
 
     // anything non-IPv4 and non-convertable is BAD.
     return false;
-#else
-    return true; // Always IPv4 in IPv4-only builds.
-#endif
 }
 
 bool
 Ip::Address::IsLocalhost() const
 {
-#if USE_IPV6
     return IN6_IS_ADDR_LOOPBACK( &m_SocketAddr.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_localhost );
-#else
-    return (htonl(0x7F000001) == m_SocketAddr.sin_addr.s_addr);
-#endif
 }
 
 void
 Ip::Address::SetLocalhost()
 {
-#if USE_IPV6
-    m_SocketAddr.sin6_addr = in6addr_loopback;
-    m_SocketAddr.sin6_family = AF_INET6;
-#else
-    m_SocketAddr.sin_addr.s_addr = htonl(0x7F000001);
-    m_SocketAddr.sin_family = AF_INET;
-#endif
+    if (Ip::EnableIpv6) {
+        m_SocketAddr.sin6_addr = in6addr_loopback;
+        m_SocketAddr.sin6_family = AF_INET6;
+    } else {
+        m_SocketAddr.sin6_addr = v4_localhost;
+        m_SocketAddr.sin6_family = AF_INET;
+    }
 }
 
 bool
 Ip::Address::IsSiteLocal6() const
 {
-#if USE_IPV6
     return IN6_IS_ADDR_SITELOCAL( &m_SocketAddr.sin6_addr );
-#else
-    return false;
-#endif
 }
 
 bool
 Ip::Address::IsSlaac() const
 {
-#if USE_IPV6
     return m_SocketAddr.sin6_addr.s6_addr[10] == htons(0xff) &&
            m_SocketAddr.sin6_addr.s6_addr[11] == htons(0xfe);
-#else
-    return false;
-#endif
 }
 
 bool
 Ip::Address::IsNoAddr() const
 {
     // IFF the address == 0xff..ff (all ones)
-#if USE_IPV6
     return IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v6_noaddr );
-#else
-    return 0xFFFFFFFF == m_SocketAddr.sin_addr.s_addr;
-#endif
 }
 
 void
 Ip::Address::SetNoAddr()
 {
-#if USE_IPV6
     memset(&m_SocketAddr.sin6_addr, 0xFF, sizeof(struct in6_addr) );
     m_SocketAddr.sin6_family = AF_INET6;
-#else
-    memset(&m_SocketAddr.sin_addr, 0xFF, sizeof(struct in_addr) );
-    m_SocketAddr.sin_family = AF_INET;
-#endif
 }
 
-#if USE_IPV6
 bool
 Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
 {
@@ -410,7 +317,6 @@ Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &da
 
     return true;
 }
-#endif
 
 bool
 Ip::Address::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
@@ -429,22 +335,14 @@ Ip::Address::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
 {
 
     if (show_type == AF_UNSPEC) {
-#if USE_IPV6
         show_type = IsIPv6() ? AF_INET6 : AF_INET ;
-#else
-        show_type = AF_INET;
-#endif
     }
 
     if (show_type == AF_INET && IsIPv4()) {
-#if USE_IPV6
         struct in_addr* tmp = (struct in_addr*)&m_SocketAddr.sin6_addr.s6_addr[12];
         return GetReverseString4(buf, *tmp);
     } else if ( show_type == AF_INET6 && IsIPv6() ) {
         return GetReverseString6(buf, m_SocketAddr.sin6_addr);
-#else
-        return GetReverseString4(buf, m_SocketAddr.sin_addr);
-#endif
     }
 
     debugs(14,0, "Unable to convert '" << NtoA(buf,MAX_IPSTRLEN) << "' to the rDNS type requested.");
@@ -464,7 +362,7 @@ Ip::Address::operator =(const Ip::Address &s)
 Ip::Address::Address(const char*s)
 {
     SetEmpty();
-    operator=(s);
+    LookupHostIP(s, true);
 }
 
 bool
@@ -494,8 +392,9 @@ Ip::Address::LookupHostIP(const char *s, bool nodns)
     if (nodns) {
         want.ai_flags = AI_NUMERICHOST; // prevent actual DNS lookups!
     }
-#if !USE_IPV6
-    want.ai_family = AF_INET;
+#if 0
+    else if (!Ip::EnableIpv6)
+        want.ai_family = AF_INET;  // maybe prevent IPv6 DNS lookups.
 #endif
 
     if ( (err = getaddrinfo(s, NULL, &want, &res)) != 0) {
@@ -533,22 +432,15 @@ Ip::Address::Address(struct sockaddr_in const &s)
 Ip::Address &
 Ip::Address::operator =(struct sockaddr_in const &s)
 {
-#if USE_IPV6
     Map4to6((const in_addr)s.sin_addr, m_SocketAddr.sin6_addr);
     m_SocketAddr.sin6_port = s.sin_port;
     m_SocketAddr.sin6_family = AF_INET6;
-#else
-
-    memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in));
-#endif
-
     return *this;
 };
 
 Ip::Address &
 Ip::Address::operator =(const struct sockaddr_storage &s)
 {
-#if USE_IPV6
     /* some AF_* magic to tell socket types apart and what we need to do */
     if (s.ss_family == AF_INET6) {
         memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in));
@@ -557,13 +449,9 @@ Ip::Address::operator =(const struct sockaddr_storage &s)
         m_SocketAddr.sin6_port = sin->sin_port;
         Map4to6( sin->sin_addr, m_SocketAddr.sin6_addr);
     }
-#else
-    memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in));
-#endif
     return *this;
 };
 
-#if USE_IPV6
 Ip::Address::Address(struct sockaddr_in6 const &s)
 {
     SetEmpty();
@@ -577,7 +465,6 @@ Ip::Address::operator =(struct sockaddr_in6 const &s)
 
     return *this;
 };
-#endif
 
 Ip::Address::Address(struct in_addr const &s)
 {
@@ -588,19 +475,11 @@ Ip::Address::Address(struct in_addr const &s)
 Ip::Address &
 Ip::Address::operator =(struct in_addr const &s)
 {
-#if USE_IPV6
     Map4to6((const in_addr)s, m_SocketAddr.sin6_addr);
     m_SocketAddr.sin6_family = AF_INET6;
-
-#else
-
-    memcpy(&m_SocketAddr.sin_addr, &s, sizeof(struct in_addr));
-
-#endif
     return *this;
 };
 
-#if USE_IPV6
 Ip::Address::Address(struct in6_addr const &s)
 {
     SetEmpty();
@@ -616,7 +495,6 @@ Ip::Address::operator =(struct in6_addr const &s)
 
     return *this;
 };
-#endif
 
 Ip::Address::Address(const Ip::Address &s)
 {
@@ -663,17 +541,8 @@ Ip::Address::operator =(const struct hostent &s)
 
     case AF_INET6:
         ipv6 = (in6_addr*)(s.h_addr_list[0]);
-#if USE_IPV6
         /* this */
         operator=(*ipv6);
-#else
-
-        debugs(14,1, HERE << "Discarded IPv6 Address. Protocol disabled.");
-
-        // FIXME see if there is another address in the list that might be usable ??
-        return false;
-#endif
-
         break;
 
     default:
@@ -720,39 +589,23 @@ Ip::Address::operator =(const struct addrinfo &s)
 
     case AF_INET6:
         ipv6 = (sockaddr_in6*)(s.ai_addr);
-#if USE_IPV6
         /* this */
         assert(ipv6);
         operator=(*ipv6);
-#else
-
-        debugs(14,1, HERE << "Discarded IPv6 Address. Protocol disabled.");
-
-        // see if there is another address in the list that might be usable ??
-
-        if (s.ai_next)
-            return operator=(*s.ai_next);
-        else
-            return false;
-
-#endif
         break;
 
     case AF_UNSPEC:
     default:
         // attempt to handle partially initialised addrinfo.
         // such as those where data only comes from getsockopt()
         if (s.ai_addr != NULL) {
-#if USE_IPV6
             if (s.ai_addrlen == sizeof(struct sockaddr_in6)) {
                 operator=(*((struct sockaddr_in6*)s.ai_addr));
                 return true;
-            } else
-#endif
-                if (s.ai_addrlen == sizeof(struct sockaddr_in)) {
-                    operator=(*((struct sockaddr_in*)s.ai_addr));
-                    return true;
-                }
+            } else if (s.ai_addrlen == sizeof(struct sockaddr_in)) {
+                operator=(*((struct sockaddr_in*)s.ai_addr));
+                return true;
+            }
         }
         return false;
     }
@@ -783,8 +636,7 @@ Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
             && dst->ai_protocol == 0)
         dst->ai_protocol = IPPROTO_UDP;
 
-#if USE_IPV6
-    if ( force == AF_INET6 || (force == AF_UNSPEC && IsIPv6()) ) {
+    if (force == AF_INET6 || (force == AF_UNSPEC && IsIPv6()) ) {
         dst->ai_addr = (struct sockaddr*)new sockaddr_in6;
 
         memset(dst->ai_addr,0,sizeof(struct sockaddr_in6));
@@ -809,22 +661,20 @@ Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
         dst->ai_protocol = IPPROTO_IPV6;
 #endif
 
-    } else
-#endif
-        if ( force == AF_INET || (force == AF_UNSPEC && IsIPv4()) ) {
+    } else if ( force == AF_INET || (force == AF_UNSPEC && IsIPv4()) ) {
 
-            dst->ai_addr = (struct sockaddr*)new sockaddr_in;
+        dst->ai_addr = (struct sockaddr*)new sockaddr_in;
 
-            memset(dst->ai_addr,0,sizeof(struct sockaddr_in));
+        memset(dst->ai_addr,0,sizeof(struct sockaddr_in));
 
-            GetSockAddr(*((struct sockaddr_in*)dst->ai_addr));
+        GetSockAddr(*((struct sockaddr_in*)dst->ai_addr));
 
-            dst->ai_addrlen = sizeof(struct sockaddr_in);
+        dst->ai_addrlen = sizeof(struct sockaddr_in);
 
-            dst->ai_family = ((struct sockaddr_in*)dst->ai_addr)->sin_family;
-        } else {
-            IASSERT("false",false);
-        }
+        dst->ai_family = ((struct sockaddr_in*)dst->ai_addr)->sin_family;
+    } else {
+        IASSERT("false",false);
+    }
 }
 
 void
@@ -865,13 +715,8 @@ Ip::Address::FreeAddrInfo(struct addrinfo *&ai)
 int
 Ip::Address::matchIPAddr(const Ip::Address &rhs) const
 {
-#if USE_IPV6
     uint8_t *l = (uint8_t*)m_SocketAddr.sin6_addr.s6_addr;
     uint8_t *r = (uint8_t*)rhs.m_SocketAddr.sin6_addr.s6_addr;
-#else
-    uint8_t *l = (uint8_t*)&m_SocketAddr.sin_addr.s_addr;
-    uint8_t *r = (uint8_t*)&rhs.m_SocketAddr.sin_addr.s_addr;
-#endif
 
     // loop a byte-wise compare
     // NP: match MUST be R-to-L : L-to-R produces inconsistent gt/lt results at varying CIDR
@@ -977,11 +822,7 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
     /* some external code may have blindly memset a parent. */
     /* thats okay, our default is known */
     if ( IsAnyAddr() ) {
-#if USE_IPV6
         memcpy(buf,"::\0", min((const unsigned int)3,blen));
-#else
-        memcpy(buf,"0.0.0.0\0", min((const unsigned int)8,blen));
-#endif
         return buf;
     }
 
@@ -996,7 +837,6 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
         return buf;
     }
 
-#if USE_IPV6
     if ( force == AF_INET6 || (force == AF_UNSPEC && IsIPv6()) ) {
 
         inet_ntop(AF_INET6, &m_SocketAddr.sin6_addr, buf, blen);
@@ -1006,10 +846,6 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
         struct in_addr tmp;
         GetInAddr(tmp);
         inet_ntop(AF_INET, &tmp, buf, blen);
-#else
-    if ( force == AF_UNSPEC || (force == AF_INET && IsIPv4()) ) {
-        inet_ntop(AF_INET, &m_SocketAddr.sin_addr, buf, blen);
-#endif
     } else {
         debugs(14,0,"WARNING: Corrupt IP Address details OR required to display in unknown format (" <<
                force << "). accepted={" << AF_UNSPEC << "," << AF_INET << "," << AF_INET6 << "}");
@@ -1089,7 +925,6 @@ Ip::Address::GetSockAddr(struct sockaddr_storage &addr, const int family) const
         assert(false);
     }
 
-#if USE_IPV6
     if ( family == AF_INET6 || (family == AF_UNSPEC && IsIPv6()) ) {
         struct sockaddr_in6 *ss6 = (struct sockaddr_in6*)&addr;
         GetSockAddr(*ss6);
@@ -1099,17 +934,11 @@ Ip::Address::GetSockAddr(struct sockaddr_storage &addr, const int family) const
     } else {
         IASSERT("false",false);
     }
-#else /* not USE_IPV6 */
-    sin = (struct sockaddr_in*)&addr;
-    GetSockAddr(*sin);
-#endif /* USE_IPV6 */
 }
 
 void
 Ip::Address::GetSockAddr(struct sockaddr_in &buf) const
 {
-#if USE_IPV6
-
     if ( IsIPv4() ) {
         buf.sin_family = AF_INET;
         buf.sin_port = m_SocketAddr.sin6_port;
@@ -1121,24 +950,12 @@ Ip::Address::GetSockAddr(struct sockaddr_in &buf) const
         assert(false);
     }
 
-#else
-
-    memcpy(&buf, &m_SocketAddr, sizeof(struct sockaddr_in));
-
-    if (buf.sin_family == 0) {
-        buf.sin_family = AF_INET;
-    }
-
-#endif
-
 #if HAVE_SIN_LEN_IN_SAI
     /* not all OS have this field, BUT when they do it can be a problem if set wrong */
     buf.sin_len = sizeof(struct sockaddr_in);
 #endif
-
 }
 
-#if USE_IPV6
 void
 Ip::Address::GetSockAddr(struct sockaddr_in6 &buf) const
 {
@@ -1151,9 +968,7 @@ Ip::Address::GetSockAddr(struct sockaddr_in6 &buf) const
     buf.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 }
-#endif
 
-#if USE_IPV6
 void
 Ip::Address::Map4to6(const struct in_addr &in, struct in6_addr &out) const
 {
@@ -1194,24 +1009,14 @@ Ip::Address::GetInAddr(in6_addr &buf) const
 {
     memcpy(&buf, &m_SocketAddr.sin6_addr, sizeof(struct in6_addr));
 }
-#endif
 
 bool
 Ip::Address::GetInAddr(struct in_addr &buf) const
 {
-
-#if USE_IPV6
     if ( IsIPv4() ) {
         Map6to4((const in6_addr)m_SocketAddr.sin6_addr, buf);
         return true;
     }
-#else
-
-    if ( IsIPv4() ) {
-        memcpy(&buf, &m_SocketAddr.sin_addr, sizeof(struct in_addr));
-        return true;
-    }
-#endif
 
     // default:
     // non-compatible IPv6 Pure Address
@@ -61,31 +61,6 @@
 namespace Ip
 {
 
-/* FreeBSD hack:
- *   This OS has at least one version that defines these as private
- *   kernel macros commented as being 'non-standard'.
- *   We need to use them, much nicer than the OS-provided __u*_*[]
- * UPDATE: OpenBSD 4.3 has the same.
- * UPDATE: MacOSX has the same.
- */
-#if USE_IPV6 && ( defined(_SQUID_FREEBSD_) || defined(_SQUID_OPENBSD_) || defined(_SQUID_APPLE_) || defined(_SQUID_NETBSD_))
-//#define s6_addr8  __u6_addr.__u6_addr8
-//#define s6_addr16 __u6_addr.__u6_addr16
-#define s6_addr32 __u6_addr.__u6_addr32
-#endif
-
-/* OpenBSD also hide v6only socket option we need for comm layer. :-( */
-#if !defined(IPV6_V6ONLY) && defined(_SQUID_OPENBSD_)
-#define IPV6_V6ONLY		27 // from OpenBSD 4.3 headers. (NP: does not match non-BSD OS values)
-#endif
-
-/* Bug 2500: Solaris 10/11 require s6_addr* defines. */
-#if USE_IPV6 && defined(_SQUID_SOLARIS_)
-//#define s6_addr8   _S6_un._S6_u8
-//#define s6_addr16  _S6_un._S6_u16
-#define s6_addr32  _S6_un._S6_u32
-#endif
-
 /// Length of buffer that needs to be allocated to old a null-terminated IP-string
 // Yuck. But there are still structures that need it to be an 'integer constant'.
 #define MAX_IPSTRLEN  75
@@ -112,15 +87,9 @@ class Address
     Address(Address *);
 
     Address(const struct in_addr &);
-
     Address(const struct sockaddr_in &);
-#if USE_IPV6
-
     Address(const struct in6_addr &);
-
     Address(const struct sockaddr_in6 &);
-#endif
-
     Address(const struct hostent &);
     Address(const struct addrinfo &);
     Address(const char*);
@@ -134,10 +103,8 @@ class Address
     Address& operator =(struct sockaddr_in const &s);
     Address& operator =(struct sockaddr_storage const &s);
     Address& operator =(struct in_addr const &s);
-#if USE_IPV6
     Address& operator =(struct in6_addr const &s);
     Address& operator =(struct sockaddr_in6 const &s);
-#endif
     bool operator =(const struct hostent &s);
     bool operator =(const struct addrinfo &s);
     bool operator =(const char *s);
@@ -267,7 +234,7 @@ class Address
      \param cidr   CIDR Mask being applied. As an integer in host format.
      \param mtype  Type of CIDR mask being applied (AF_INET or AF_INET6)
      */
-    bool ApplyMask(const unsigned int cidr, int mtype = AF_UNSPEC);
+    bool ApplyMask(const unsigned int cidr, int mtype);
 
 
     /** Return the ASCII equivalent of the address
@@ -340,18 +307,11 @@ class Address
      \par
      *  Ip::Address allocated objects MUST be destructed by Ip::Address::FreeAddrInfo
      *  System getaddrinfo() allocated objects MUST be freed with system freeaddrinfo()
-     \par
-     *  Some OS require that IPv4 addresses are pre-mapped by the client.
-     *  The configure option --with-ipv4-mapping=yes will enable this.
      *
      \param ai structure to be filled out.
      \param force a specific sockaddr type is needed. default: don't care.
      */
-#if IPV6_SPECIAL_V4MAPPING
-    void GetAddrInfo(struct addrinfo *&ai, int force = AF_INET6) const;
-#else
     void GetAddrInfo(struct addrinfo *&ai, int force = AF_UNSPEC) const;
-#endif
 
     /**
      *  Equivalent to the sysem call freeaddrinfo() but for Ip::Address allocated data
@@ -388,42 +348,32 @@ class Address
     void GetSockAddr(struct sockaddr_storage &addr, const int family) const;
     void GetSockAddr(struct sockaddr_in &) const;
     bool GetInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
-#if USE_IPV6
     void GetSockAddr(struct sockaddr_in6 &) const;
     void GetInAddr(struct in6_addr &) const;
-#endif
 
 private:
     /* Conversion for dual-type internals */
 
     bool GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const;
 
-#if USE_IPV6
-
     bool GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const;
 
     void Map4to6(const struct in_addr &src, struct in6_addr &dest) const;
 
     void Map6to4(const struct in6_addr &src, struct in_addr &dest) const;
-#endif
 
     // Worker behind GetHostName and char* converters
     bool LookupHostIP(const char *s, bool nodns);
 
     /* variables */
-#if USE_IPV6
     struct sockaddr_in6 m_SocketAddr;
-#else
-    struct sockaddr_in m_SocketAddr;
-#endif
 
 private:
     /* Internally used constants */
     static const unsigned int STRLEN_IP4A = 16;              // aaa.bbb.ccc.ddd\0
     static const unsigned int STRLEN_IP4R = 28;              // ddd.ccc.bbb.aaa.in-addr.arpa.\0
     static const unsigned int STRLEN_IP4S = 21;              // ddd.ccc.bbb.aaa:ppppp\0
     static const unsigned int MAX_IP4_STRLEN = STRLEN_IP4R;
-#if USE_IPV6
     static const unsigned int STRLEN_IP6A = 42;           // [ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff]/0
     static const unsigned int STRLEN_IP6R = 75;           // f.f.f.f f.f.f.f f.f.f.f f.f.f.f f.f.f.f f.f.f.f f.f.f.f f.f.f.f ipv6.arpa./0
     static const unsigned int STRLEN_IP6S = 48;           // [ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff]:00000/0
@@ -432,7 +382,6 @@ class Address
     static const struct in6_addr v4_anyaddr;
     static const struct in6_addr v4_noaddr;
     static const struct in6_addr v6_noaddr;
-#endif
 };
 
 
@@ -405,7 +405,6 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
     int tos = 1;
     int tmp_sock = -1;
 
-#if USE_IPV6
     /* Probe to see if the Kernel TPROXY support is IPv6-enabled */
     if (test.IsIPv6()) {
         debugs(3, 3, "...Probing for IPv6 TPROXY support.");
@@ -433,7 +432,6 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
         debugs(3, DBG_CRITICAL, "TPROXY lacks IPv6 support for " << test );
         return false;
     }
-#endif
 
     /* Probe to see if the Kernel TPROXY support is IPv4-enabled (aka present) */
     if (test.IsIPv4()) {
@@ -10,7 +10,9 @@ libip_la_SOURCES = \
 	Intercept.h \
 	Intercept.cc \
 	QosConfig.h \
-	QosConfig.cc
+	QosConfig.cc \
+	tools.cc \
+	tools.h
 
 
 check_PROGRAMS += testIpAddress
@@ -1,8 +1,9 @@
 #define SQUID_UNIT_TEST 1
 #include "config.h"
-#include "compat/getaddrinfo.h"
+//#include "compat/getaddrinfo.h"
 #include "testAddress.h"
 #include "ip/Address.h"
+#include "ip/tools.h"
 
 #if HAVE_CSTRING
 #include <cstring>
@@ -43,11 +44,7 @@ testIpAddress::testDefaults()
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
-#if USE_IPV6
     CPPUNIT_ASSERT( anIPA.IsIPv6() );
-#else
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-#endif
 }
 
 void
@@ -72,7 +69,6 @@ testIpAddress::testInAddrConstructor()
     CPPUNIT_ASSERT( memcmp(&inval, &outval, sizeof(struct in_addr)) == 0 );
 }
 
-#if USE_IPV6
 void
 testIpAddress::testInAddr6Constructor()
 {
@@ -96,7 +92,6 @@ testIpAddress::testInAddr6Constructor()
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &inval, &outval, sizeof(struct in6_addr)) == 0 );
 }
-#endif
 
 void
 testIpAddress::testSockAddrConstructor()
@@ -127,7 +122,6 @@ testIpAddress::testSockAddrConstructor()
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
 
-#if USE_IPV6
 void
 testIpAddress::testSockAddr6Constructor()
 {
@@ -159,7 +153,6 @@ testIpAddress::testSockAddr6Constructor()
     anIPA.GetSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in6)) == 0 );
 }
-#endif
 
 
 void
@@ -238,7 +231,6 @@ testIpAddress::testStringConstructor()
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-#if USE_IPV6
     struct in6_addr expectv6;
     struct in6_addr outval6;
 
@@ -249,6 +241,10 @@ testIpAddress::testStringConstructor()
 
     Ip::Address bnIPA = "2000:800::45";
 
+//char test[256];
+//bnIPA.NtoA(test, 256);
+//printf("bnIPA: %s\n", test);
+
     /* test stored values */
     CPPUNIT_ASSERT( !bnIPA.IsAnyAddr() );
     CPPUNIT_ASSERT( !bnIPA.IsNoAddr() );
@@ -276,7 +272,6 @@ testIpAddress::testStringConstructor()
     CPPUNIT_ASSERT_EQUAL( (u_short) 0 , cnIPA.GetPort() );
     cnIPA.GetInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
-#endif
 }
 
 void
@@ -303,11 +298,7 @@ testIpAddress::testSetEmpty()
     CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
-#if USE_IPV6
     CPPUNIT_ASSERT( anIPA.IsIPv6() );
-#else
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-#endif
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
 }
@@ -434,11 +425,7 @@ testIpAddress::testNtoA()
     anIPA.SetAnyAddr();
 
     /* test AnyAddr display values */
-#if USE_IPV6
     CPPUNIT_ASSERT( memcmp("::", anIPA.NtoA(buf,MAX_IPSTRLEN), 2) == 0 );
-#else
-    CPPUNIT_ASSERT( memcmp("0.0.0.0",anIPA.NtoA(buf,MAX_IPSTRLEN), 7) == 0 );
-#endif
 
     inval.s_addr = htonl(0xC0A8640C);
     anIPA = inval;
@@ -449,11 +436,7 @@ testIpAddress::testNtoA()
     anIPA.SetNoAddr();
 
     /* test NoAddr display values */
-#if USE_IPV6
     CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",anIPA.NtoA(buf,MAX_IPSTRLEN), 39) == 0 );
-#else
-    CPPUNIT_ASSERT( memcmp("255.255.255.255",anIPA.NtoA(buf,MAX_IPSTRLEN), 15) == 0 );
-#endif
 }
 
 void
@@ -471,8 +454,6 @@ testIpAddress::testToURL_fromInAddr()
     anIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("192.168.100.12", buf, 14) == 0 );
 
-#if USE_IPV6
-
     /* test output when constructed from in6_addr with IPv6 */
     struct in6_addr ip6val;
 
@@ -485,8 +466,6 @@ testIpAddress::testToURL_fromInAddr()
 
     bnIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]", buf, 41) == 0 );
-
-#endif
 }
 
 void
@@ -507,8 +486,6 @@ testIpAddress::testToURL_fromSockAddr()
     anIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("192.168.100.12:80", buf, 17) == 0 );
 
-#if USE_IPV6
-
     /* test output when constructed from in6_addr with IPv6 */
     struct sockaddr_in6 ip6val;
 
@@ -526,9 +503,6 @@ testIpAddress::testToURL_fromSockAddr()
 
     bnIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]:80", buf, 44) == 0 );
-
-#endif
-
 }
 
 void
@@ -551,8 +525,6 @@ testIpAddress::testGetReverseString()
     v4IPA.GetReverseString(buf,AF_INET6);
     CPPUNIT_ASSERT( memcmp("",buf, 1) == 0 );
 
-
-#if USE_IPV6
     struct in6_addr ip6val;
 
     ip6val.s6_addr32[0] = htonl(0xC0A8640C);
@@ -565,9 +537,6 @@ testIpAddress::testGetReverseString()
     /* test IPv6 output */
     v6IPA.GetReverseString(buf);
     CPPUNIT_ASSERT( memcmp("f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.c.0.4.6.8.a.0.c.ip6.arpa.",buf,73) == 0 );
-
-#endif
-
 }
 
 void
@@ -582,37 +551,28 @@ testIpAddress::testMasking()
     CPPUNIT_ASSERT_EQUAL( 0 ,anIPA.GetCIDR() );
 
     anIPA.SetNoAddr();
-#if USE_IPV6
     CPPUNIT_ASSERT_EQUAL( 128 , anIPA.GetCIDR() );
-#else
-    CPPUNIT_ASSERT_EQUAL( 32 , anIPA.GetCIDR() );
-#endif
 
     /* Test Numeric ApplyCIDR */
     anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( !anIPA.ApplyMask(129) );
-#if !USE_IPV6
-    CPPUNIT_ASSERT( !anIPA.ApplyMask(33) );
-#endif
-    CPPUNIT_ASSERT( anIPA.ApplyMask(31) );
-    CPPUNIT_ASSERT_EQUAL( 31 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT( !anIPA.ApplyMask(129,AF_INET6) );
+    CPPUNIT_ASSERT( !anIPA.ApplyMask(33,AF_INET) );
 
     anIPA.SetNoAddr();
-    anIPA.ApplyMask(31, AF_INET);
-#if USE_IPV6
+    CPPUNIT_ASSERT( anIPA.ApplyMask(31,AF_INET) );
+    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.GetCIDR() );
+
+    anIPA.SetNoAddr();
+    CPPUNIT_ASSERT( anIPA.ApplyMask(127,AF_INET6) );
     CPPUNIT_ASSERT_EQUAL( 127 , anIPA.GetCIDR() );
-#else
-    CPPUNIT_ASSERT_EQUAL( 31 , anIPA.GetCIDR() );
-#endif
 
-#if USE_IPV6
     anIPA.SetNoAddr();
     anIPA.ApplyMask(80,AF_INET6);
     CPPUNIT_ASSERT_EQUAL( 80 , anIPA.GetCIDR() );
+
     /* BUG Check: test values by display. */
     CPPUNIT_ASSERT( anIPA.NtoA(buf,MAX_IPSTRLEN) != NULL );
     CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff::", buf, 26) == 0 );
-#endif
 
     /* Test Network Bitmask from Ip::Address */
     anIPA.SetNoAddr();
@@ -631,8 +591,6 @@ testIpAddress::testMasking()
     /* BUG Check failing test. Masked values for display. */
     CPPUNIT_ASSERT( memcmp("255.255.240.0",anIPA.NtoA(buf,MAX_IPSTRLEN), 13) == 0 );
 
-
-#if USE_IPV6
     anIPA.SetNoAddr();
     maskIPA.SetNoAddr();
 
@@ -660,8 +618,6 @@ testIpAddress::testMasking()
     CPPUNIT_ASSERT(  maskIPA.IsIPv4() );
     CPPUNIT_ASSERT( !maskIPA.IsIPv6() );
     CPPUNIT_ASSERT_EQUAL( 20 , anIPA.GetCIDR() );
-#endif
-
 }
 
 void
@@ -719,7 +675,6 @@ testIpAddress::testAddrInfo()
 #endif
 #endif /*0*/
 
-#if USE_IPV6
 #if HAVE_SS_LEN_IN_SS
     CPPUNIT_ASSERT_EQUAL( ((struct sockaddr_storage*)expect->ai_addr)->ss_len,
                           ((struct sockaddr_storage*)ipval->ai_addr)->ss_len );
@@ -739,22 +694,6 @@ testIpAddress::testAddrInfo()
                           ((struct sockaddr_in6*)ipval->ai_addr)->sin6_family );
     CPPUNIT_ASSERT_EQUAL( ((struct sockaddr_in6*)expect->ai_addr)->sin6_port,
                           ((struct sockaddr_in6*)ipval->ai_addr)->sin6_port );
-#else
-#if HAVE_SS_LEN_IN_SS
-    CPPUNIT_ASSERT_EQUAL( ((struct sockaddr_storage*)expect->ai_addr)->ss_len,
-                          ((struct sockaddr_storage*)ipval->ai_addr)->ss_len );
-    CPPUNIT_ASSERT_EQUAL( (socklen_t)((struct sockaddr_storage*)ipval->ai_addr)->ss_len, ipval->ai_addrlen );
-#endif
-#if HAVE_SIN_LEN_IN_SAI
-    CPPUNIT_ASSERT_EQUAL( ((struct sockaddr_in*)expect->ai_addr)->sin_len,
-                          ((struct sockaddr_in*)ipval->ai_addr)->sin_len );
-    CPPUNIT_ASSERT_EQUAL( (socklen_t)((struct sockaddr_in*)ipval->ai_addr)->sin_len, ipval->ai_addrlen );
-#endif
-    CPPUNIT_ASSERT_EQUAL( ((struct sockaddr_in*)expect->ai_addr)->sin_family,
-                          ((struct sockaddr_in*)ipval->ai_addr)->sin_family );
-    CPPUNIT_ASSERT_EQUAL( ((struct sockaddr_in*)expect->ai_addr)->sin_port,
-                          ((struct sockaddr_in*)ipval->ai_addr)->sin_port );
-#endif /* USE_IPV6 */
 
     CPPUNIT_ASSERT( memcmp( expect->ai_addr, ipval->ai_addr, expect->ai_addrlen ) == 0 );
 
@@ -12,13 +12,9 @@ class testIpAddress : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST_SUITE( testIpAddress );
     CPPUNIT_TEST( testDefaults );
     CPPUNIT_TEST( testInAddrConstructor );
-#if USE_IPV6
     CPPUNIT_TEST( testInAddr6Constructor );
-#endif
     CPPUNIT_TEST( testSockAddrConstructor );
-#if USE_IPV6
     CPPUNIT_TEST( testSockAddr6Constructor );
-#endif
     CPPUNIT_TEST( testHostentConstructor );
     CPPUNIT_TEST( testStringConstructor );
     CPPUNIT_TEST( testCopyConstructor );
@@ -40,13 +36,9 @@ class testIpAddress : public CPPUNIT_NS::TestFixture
     void testDefaults();
 
     void testInAddrConstructor();
-#if USE_IPV6
     void testInAddr6Constructor();
-#endif
     void testSockAddrConstructor();
-#if USE_IPV6
     void testSockAddr6Constructor();
-#endif
     void testHostentConstructor();
     void testStringConstructor();
     void testCopyConstructor();
@@ -0,0 +1,81 @@
+/*
+ * DEBUG: section 21    Misc Functions
+ * AUTHOR: Amos Jeffries
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "config.h"
+//#include "compat/getaddrinfo.h"
+//#include "compat/getnameinfo.h"
+#include "Debug.h"
+#include "ip/tools.h"
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IN6_H
+#include <netinet/in6.h>
+#endif
+
+int Ip::EnableIpv6 = IPV6_OFF;
+
+void
+Ip::ProbeTransport()
+{
+#if USE_IPV6
+    // check for usable IPv6 sockets
+    int s = socket(PF_INET6, SOCK_STREAM, 0);
+    if (s < 0) {
+        debugs(3, 2, "IPv6 not supported on this machine. Auto-Disabled.");
+        EnableIpv6 = IPV6_OFF;
+        return;
+    }
+
+    // Test for v4-mapping capability
+    int tos = 0;
+    if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &tos, sizeof(int)) < 0) {
+        debugs(3, 2, "Detected IPv6 hybrid or v4-mapping stack...");
+        EnableIpv6 |= IPV6_SPECIAL_V4MAPPING;
+    } else {
+        debugs(3, 2, "Detected split IPv4 and IPv6 stacks ...");
+        // EnableIpv6 |= IPV6_SPECIAL_SPLITSTACK;
+        // TODO: remove death when split-stack is supported.
+        EnableIpv6 = IPV6_OFF;
+    }
+    close(s);
+
+    debugs(3, 2, "IPv6 transport " << (EnableIpv6?"Enabled":"Disabled"));
+#else
+    debugs(3, 2, "IPv6 transport forced OFF by build parameters.");
+    EnableIpv6 = IPV6_OFF;
+#endif
+}
@@ -0,0 +1,21 @@
+#ifndef _SQUID_SRC_IP_TOOLS_H
+#define _SQUID_SRC_IP_TOOLS_H
+
+namespace Ip
+{
+
+/// Probe to discover IPv6 capabilities
+extern void ProbeTransport(void);
+
+/* Squids notion of IPv6 stack types and state */
+#define IPV6_OFF  0
+#define IPV6_ON   1
+#define IPV6_SPECIAL_V4MAPPING  2
+#define IPV6_SPECIAL_SPLITSTACK 4
+
+/// Whether IPv6 is supported and type of support.
+extern int EnableIpv6;
+
+}; // namespace Ip
+
+#endif /* _SQUID_SRC_IP_TOOLS_H */
@@ -8,11 +8,15 @@
 #ifndef SQUID_IPC_START_LISTENING_H
 #define SQUID_IPC_START_LISTENING_H
 
-#include <iosfwd>
+#include "config.h"
 #include "ip/forward.h"
 #include "ipc/FdNotes.h"
 #include "base/AsyncCall.h"
 
+#if HAVE_IOSFWD
+#include <iosfwd>
+#endif
+
 namespace Ipc
 {
 
@@ -31,13 +31,14 @@
  */
 
 #include "squid.h"
+#include "CacheManager.h"
 #include "cbdata.h"
 #include "event.h"
-#include "CacheManager.h"
+#include "ip/Address.h"
+#include "ip/tools.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
-#include "ip/Address.h"
 
 /**
  \defgroup IPCacheAPI IP Cache API
@@ -480,8 +481,7 @@ ipcacheParse(ipcache_entry *i, rfc1035_rr * answers, int nr, const char *error_m
 
     for (k = 0; k < nr; k++) {
 
-#if USE_IPV6
-        if (answers[k].type == RFC1035_TYPE_AAAA) {
+        if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr)) {
                 debugs(14, 1, "ipcacheParse: Invalid IPv6 address in response to '" << name << "'");
                 continue;
@@ -490,7 +490,6 @@ ipcacheParse(ipcache_entry *i, rfc1035_rr * answers, int nr, const char *error_m
             IpcacheStats.rr_aaaa++;
             continue;
         }
-#endif
 
         if (answers[k].type == RFC1035_TYPE_A) {
             if (answers[k].rdlength != sizeof(struct in_addr)) {
@@ -538,8 +537,7 @@ ipcacheParse(ipcache_entry *i, rfc1035_rr * answers, int nr, const char *error_m
             debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j]);
             j++;
 
-#if USE_IPV6
-        } else if (answers[k].type == RFC1035_TYPE_AAAA) {
+        } else if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr))
                 continue;
 
@@ -549,7 +547,6 @@ ipcacheParse(ipcache_entry *i, rfc1035_rr * answers, int nr, const char *error_m
 
             debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j] );
             j++;
-#endif
         }
         if (ttl == 0 || (int) answers[k].ttl < ttl)
             ttl = answers[k].ttl;
@@ -1178,15 +1175,11 @@ ipcacheAddEntryFromHosts(const char *name, const char *ipaddr)
     Ip::Address ip;
 
     if (!(ip = ipaddr)) {
-#if USE_IPV6
         if (strchr(ipaddr, ':') && strspn(ipaddr, "0123456789abcdefABCDEF:") == strlen(ipaddr)) {
             debugs(14, 3, "ipcacheAddEntryFromHosts: Skipping IPv6 address '" << ipaddr << "'");
         } else {
             debugs(14, 1, "ipcacheAddEntryFromHosts: Bad IP address '" << ipaddr << "'");
         }
-#else
-        debugs(14, 1, "ipcacheAddEntryFromHosts: Bad IP address '" << ipaddr << "'");
-#endif
 
         return 1;
     }
@@ -185,11 +185,9 @@ logfile_mod_tcp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
     Ip::Address any_addr;
     any_addr.SetAnyAddr();
 
-#if USE_IPV6
     // require the sending TCP port to be of the right family for the destination address.
     if (addr.IsIPv4())
         any_addr.SetIPv4();
-#endif
 
     ll->fd = comm_open(SOCK_STREAM, IPPROTO_TCP, any_addr, COMM_NONBLOCKING, "TCP log socket");
     if (ll->fd < 0) {
@@ -179,11 +179,9 @@ logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
     Ip::Address any_addr;
     any_addr.SetAnyAddr();
 
-#if USE_IPV6
     // require the sending UDP port to be of the right family for the destination address.
     if (addr.IsIPv4())
         any_addr.SetIPv4();
-#endif
 
     ll->fd = comm_open(SOCK_DGRAM, IPPROTO_UDP, any_addr, COMM_NONBLOCKING, "UDP log socket");
     if (ll->fd < 0) {
@@ -59,6 +59,7 @@
 #include "ipc/Kids.h"
 #include "ipc/Coordinator.h"
 #include "ipc/Strand.h"
+#include "ip/tools.h"
 #if USE_EPOLL
 #include "comm_epoll.h"
 #endif
@@ -1343,6 +1344,8 @@ SquidMain(int argc, char **argv)
 
         InitAuthSchemes();      /* required for config parsing */
 
+        Ip::ProbeTransport(); // determine IPv4 or IPv6 capabilities before parsing.
+
         parse_err = parseConfigFile(ConfigFile);
 
         Mem::Report();
@@ -66,14 +66,12 @@ mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *datanot
     }
 
     for (i = 0; i < (int) ia->count; i++) {
-        debugs(7, 10, "Listening for ICP requests on " << ia->in_addrs[i] );
+        debugs(7, 9, "Listening for ICP requests on " << ia->in_addrs[i] );
 
-#if USE_IPV6
         if ( ! ia->in_addrs[i].IsIPv4() ) {
-            debugs(7, 10, "ERROR: IPv6 Multicast Listen has not been implemented!");
+            debugs(7, 9, "ERROR: IPv6 Multicast Listen has not been implemented!");
             continue;
         }
-#endif
 
         ia->in_addrs[i].GetInAddr(mr.imr_multiaddr);
 
@@ -572,7 +572,6 @@ SQUIDCEXTERN void setSystemLimits(void);
 SQUIDCEXTERN void squid_signal(int sig, SIGHDLR *, int flags);
 SQUIDCEXTERN pid_t readPidFile(void);
 SQUIDCEXTERN void keepCapabilities(void);
-
 SQUIDCEXTERN void BroadcastSignalIfAny(int& sig);
 /// whether the current process is the parent of all other Squid processes
 SQUIDCEXTERN bool IamMasterProcess();
@@ -34,8 +34,9 @@
 #include "cache_snmp.h"
 #include "comm.h"
 #include "ipc/StartListening.h"
-#include "compat/strsep.h"
+//#include "compat/strsep.h"
 #include "ip/Address.h"
+#include "ip/tools.h"
 
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
@@ -841,10 +842,8 @@ client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn
 
         if (laddr.IsIPv4())
             size = sizeof(in_addr);
-#if USE_IPV6
         else
             size = sizeof(in6_addr);
-#endif
 
         debugs(49, 6, HERE << "len" << *len << ", current-len" << current->len << ", addr=" << laddr << ", size=" << size);
 
@@ -867,10 +866,8 @@ client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn
         if (!laddr.IsAnyAddr()) {
             if (laddr.IsIPv4())
                 newshift = sizeof(in_addr);
-#if USE_IPV6
             else
                 newshift = sizeof(in6_addr);
-#endif
 
             debugs(49, 6, HERE << "len" << *len << ", current-len" << current->len << ", addr=" << laddr << ", newshift=" << newshift);
 
@@ -1145,25 +1142,17 @@ addr2oid(Ip::Address &addr, oid * Dest)
     u_int i ;
     u_char *cp = NULL;
     struct in_addr iaddr;
-#if USE_IPV6
     struct in6_addr i6addr;
     oid code = addr.IsIPv6()? INETADDRESSTYPE_IPV6  : INETADDRESSTYPE_IPV4 ;
     u_int size = (code == INETADDRESSTYPE_IPV4) ? sizeof(struct in_addr):sizeof(struct in6_addr);
-#else
-    oid code = INETADDRESSTYPE_IPV4 ;
-    u_int size = sizeof(struct in_addr) ;
-#endif /* USE_IPV6 */
     //  Dest[0] = code ;
     if ( code == INETADDRESSTYPE_IPV4 ) {
         addr.GetInAddr(iaddr);
         cp = (u_char *) &(iaddr.s_addr);
-    }
-#if USE_IPV6
-    else {
+    } else if (Ip::EnableIpv6) {
         addr.GetInAddr(i6addr);
         cp = (u_char *) &i6addr;
     }
-#endif
     for ( i=0 ; i < size ; i++) {
         // OID's are in network order
         Dest[i] = *cp++;
@@ -1184,29 +1173,20 @@ oid2addr(oid * id, Ip::Address &addr, u_int size)
     struct in_addr iaddr;
     u_int i;
     u_char *cp;
-#if USE_IPV6
     struct in6_addr i6addr;
     if ( size == sizeof(struct in_addr) )
-#endif /* USE_IPV6 */
         cp = (u_char *) &(iaddr.s_addr);
-#if USE_IPV6
-    else
+    else if (Ip::EnableIpv6)
         cp = (u_char *) &(i6addr);
-#endif /* USE_IPV6 */
     MemBuf tmp;
     debugs(49, 7, "oid2addr: id : " << snmpDebugOid(id, size, tmp) );
     for (i=0 ; i<size; i++) {
         cp[i] = id[i];
     }
-#if USE_IPV6
     if ( size == sizeof(struct in_addr) )
-#endif
         addr = iaddr;
-#if USE_IPV6
-    else
+    else if (Ip::EnableIpv6)
         addr = i6addr;
-#endif
-
 }
 
 /* SNMP checklists */
@@ -147,13 +147,7 @@ testHttpRequest::testIPv6HostColonBug()
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
     CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
-#if USE_IPV6
-    /* We hasve fixed this in IPv6 build. */
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
-#else
-    /* NO fix is possible in IPv4-pure build. */
-    CPPUNIT_ASSERT_EQUAL(String("2000:800::45"), String(aRequest->GetHost()));
-#endif
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://2000:800::45/foo"), String(url));
@@ -1174,12 +1174,8 @@ parseEtcHosts(void)
             *nt = '\0';
             debugs(1, 5, "etc_hosts: got hostname '" << lt << "'");
 
-#if USE_IPV6
             /* For IPV6 addresses also check for a colon */
             if (Config.appendDomain && !strchr(lt, '.') && !strchr(lt, ':')) {
-#else
-            if (Config.appendDomain && !strchr(lt, '.')) {
-#endif
                 /* I know it's ugly, but it's only at reconfig */
                 strncpy(buf2, lt, 512);
                 strncat(buf2, Config.appendDomain, 512 - strlen(lt) - 1);
@@ -43,17 +43,13 @@ static const char valid_hostname_chars_u[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
     "abcdefghijklmnopqrstuvwxyz"
     "0123456789-._"
-#if USE_IPV6
     "[:]"
-#endif
     ;
 static const char valid_hostname_chars[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
     "abcdefghijklmnopqrstuvwxyz"
     "0123456789-."
-#if USE_IPV6
     "[:]"
-#endif
     ;
 
 void
@@ -291,7 +287,6 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         if (*host == '[') {
             /* strip any IPA brackets. valid under IPv6. */
             dst = host;
-#if USE_IPV6
             /* only for IPv6 sadly, pre-IPv6/URL code can't handle the clean result properly anyway. */
             src = host;
             src++;
@@ -303,10 +298,6 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
 
             /* we moved in-place, so truncate the actual hostname found */
             *(dst++) = '\0';
-#else
-            /* IPv4-pure needs to skip the whole hostname to ']' inclusive for now */
-            while (*dst != '\0' && *dst != ']') dst++;
-#endif
 
             /* skip ahead to either start of port, or original EOS */
             while (*dst != '\0' && *dst != ':') dst++;
@@ -351,12 +342,8 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         return NULL;
     }
 
-#if USE_IPV6
     /* For IPV6 addresses also check for a colon */
     if (Config.appendDomain && !strchr(host, '.') && !strchr(host, ':'))
-#else
-    if (Config.appendDomain && !strchr(host, '.'))
-#endif
         strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN - strlen(host) - 1);
 
     /* remove trailing dots from hostnames */
@@ -889,11 +876,8 @@ URLHostName::findHostStart()
     while (*hostStart != '\0' && *hostStart == '/')
         ++hostStart;
 
-#if USE_IPV6
     if (*hostStart == ']')
         ++hostStart;
-#endif
-
 }
 
 void
@@ -907,11 +891,8 @@ URLHostName::trimTrailingChars()
     if ((t = strrchr(Host, ':')))
         *t = '\0';
 
-#if USE_IPV6
     if ((t = strchr(Host, ']')))
         *t = '\0';
-#endif
-
 }
 
 void
@@ -32,7 +32,10 @@
 
 #include "config.h"
 #include "compat/tempnam.h"
+#include "getfullhostname.h"
+#include "ip/Address.h"
 #include "rfc1738.h"
+#include "util.h"
 
 #if HAVE_UNISTD_H
 #include <unistd.h>
@@ -114,9 +117,6 @@ extern "C" {
 }
 #endif
 
-#include "util.h"
-#include "ip/Address.h"
-#include "getfullhostname.h"
 
 #ifndef DEFAULT_CACHEMGR_CONFIG
 #define DEFAULT_CACHEMGR_CONFIG "/etc/squid/cachemgr.conf"
@@ -33,6 +33,8 @@
  */
 
 #include "config.h"
+#include "ip/Address.h"
+#include "util.h"
 
 #ifdef _SQUID_MSWIN_
 /** \cond AUTODOCS-IGNORE */
@@ -77,8 +79,6 @@ using namespace Squid;
 #include <getopt.h>
 #endif
 
-#include "util.h"
-#include "ip/Address.h"
 
 #ifndef BUFSIZ
 #define BUFSIZ		8192