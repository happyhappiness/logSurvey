@@ -298,6 +298,8 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE CXX CXXFLAGS ac_ct_CXX CXXDEPMODE build build_cpu build_vendor build_os host host_cpu host_vendor host_os CGIEXT ENABLE_WIN32SPECIFIC_TRUE ENABLE_WIN32SPECIFIC_FALSE LIBDLMALLOC LIB_MALLOC STORE_OBJS STORE_LIBS STORE_MODULES STORE_PROGRAMS STORE_MODULE_SUBDIRS REPL_POLICIES REPL_OBJS REPL_LIBS ENABLE_PINGER_TRUE ENABLE_PINGER_FALSE USE_DELAY_POOLS_TRUE USE_DELAY_POOLS_FALSE USE_SNMP_TRUE USE_SNMP_FALSE SNMPLIB makesnmplib ENABLE_ARP_ACL_TRUE ENABLE_ARP_ACL_FALSE ENABLE_HTCP_TRUE ENABLE_HTCP_FALSE ENABLE_SSL_TRUE ENABLE_SSL_FALSE NEED_OWN_MD5_TRUE NEED_OWN_MD5_FALSE SSLLIB ERR_DEFAULT_LANGUAGE ERR_LANGUAGES MAKE_LEAKFINDER_TRUE MAKE_LEAKFINDER_FALSE ENABLE_IDENT_TRUE ENABLE_IDENT_FALSE USE_DNSSERVER_TRUE USE_DNSSERVER_FALSE OPT_DEFAULT_HOSTS AUTH_MODULES AUTH_OBJS AUTH_LIBS BASIC_AUTH_HELPERS NTLM_AUTH_HELPERS DIGEST_AUTH_HELPERS EXTERNAL_ACL_HELPERS SAMBASOURCES ENABLE_UNLINKD_TRUE ENABLE_UNLINKD_FALSE ENABLE_XPROF_STATS_TRUE ENABLE_XPROF_STATS_FALSE CPP RANLIB ac_ct_RANLIB LN_S SH FALSE TRUE RM MV MKDIR LN PERL AR AR_R EGREP ALLOCA CRYPTLIB NEED_OWN_SNPRINTF_TRUE NEED_OWN_SNPRINTF_FALSE REGEXLIB LIBREGEX LIBOBJS XTRA_OBJS XTRA_LIBS LTLIBOBJS'
+ac_subst_files=''
 
 # Initialize some variables set by options.
 ac_init_help=
@@ -4516,6 +4518,16 @@ _ACEOF
 
 fi;
 
+
+
+if false; then
+  ENABLE_ARP_ACL_TRUE=
+  ENABLE_ARP_ACL_FALSE='#'
+else
+  ENABLE_ARP_ACL_TRUE='#'
+  ENABLE_ARP_ACL_FALSE=
+fi
+
 # Check whether --enable-arp-acl or --disable-arp-acl was given.
 if test "${enable_arp_acl+set}" = set; then
   enableval="$enable_arp_acl"
@@ -4536,6 +4548,16 @@ cat >>confdefs.h <<\_ACEOF
 #define USE_ARP_ACL 1
 _ACEOF
 
+
+
+if true; then
+  ENABLE_ARP_ACL_TRUE=
+  ENABLE_ARP_ACL_FALSE='#'
+else
+  ENABLE_ARP_ACL_TRUE='#'
+  ENABLE_ARP_ACL_FALSE=
+fi
+
    fi
 
 fi;
@@ -15990,6 +16012,231 @@ fi
 
 DEFS=-DHAVE_CONFIG_H
 
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+         sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_WIN32SPECIFIC_TRUE}" && test -z "${ENABLE_WIN32SPECIFIC_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_WIN32SPECIFIC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_WIN32SPECIFIC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_WIN32SPECIFIC_TRUE}" && test -z "${ENABLE_WIN32SPECIFIC_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_WIN32SPECIFIC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_WIN32SPECIFIC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_PINGER_TRUE}" && test -z "${ENABLE_PINGER_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_PINGER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_PINGER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_PINGER_TRUE}" && test -z "${ENABLE_PINGER_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_PINGER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_PINGER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_DELAY_POOLS_TRUE}" && test -z "${USE_DELAY_POOLS_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_DELAY_POOLS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_DELAY_POOLS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_DELAY_POOLS_TRUE}" && test -z "${USE_DELAY_POOLS_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_DELAY_POOLS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_DELAY_POOLS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_SNMP_TRUE}" && test -z "${USE_SNMP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_SNMP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_SNMP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_SNMP_TRUE}" && test -z "${USE_SNMP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_SNMP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_SNMP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_ARP_ACL_TRUE}" && test -z "${ENABLE_ARP_ACL_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_ARP_ACL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_ARP_ACL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_ARP_ACL_TRUE}" && test -z "${ENABLE_ARP_ACL_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_ARP_ACL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_ARP_ACL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_HTCP_TRUE}" && test -z "${ENABLE_HTCP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_HTCP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_HTCP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_HTCP_TRUE}" && test -z "${ENABLE_HTCP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_HTCP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_HTCP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_SSL_TRUE}" && test -z "${ENABLE_SSL_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_SSL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_SSL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_SSL_TRUE}" && test -z "${ENABLE_SSL_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_SSL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_SSL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${NEED_OWN_MD5_TRUE}" && test -z "${NEED_OWN_MD5_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"NEED_OWN_MD5\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"NEED_OWN_MD5\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${NEED_OWN_MD5_TRUE}" && test -z "${NEED_OWN_MD5_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"NEED_OWN_MD5\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"NEED_OWN_MD5\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${MAKE_LEAKFINDER_TRUE}" && test -z "${MAKE_LEAKFINDER_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"MAKE_LEAKFINDER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"MAKE_LEAKFINDER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${MAKE_LEAKFINDER_TRUE}" && test -z "${MAKE_LEAKFINDER_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"MAKE_LEAKFINDER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"MAKE_LEAKFINDER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_IDENT_TRUE}" && test -z "${ENABLE_IDENT_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_IDENT\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_IDENT\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_IDENT_TRUE}" && test -z "${ENABLE_IDENT_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_IDENT\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_IDENT\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_DNSSERVER_TRUE}" && test -z "${USE_DNSSERVER_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_DNSSERVER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_DNSSERVER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_DNSSERVER_TRUE}" && test -z "${USE_DNSSERVER_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_DNSSERVER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_DNSSERVER\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_UNLINKD_TRUE}" && test -z "${ENABLE_UNLINKD_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_UNLINKD\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_UNLINKD\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_UNLINKD_TRUE}" && test -z "${ENABLE_UNLINKD_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_UNLINKD\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_UNLINKD\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_XPROF_STATS_TRUE}" && test -z "${ENABLE_XPROF_STATS_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_XPROF_STATS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_XPROF_STATS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ENABLE_XPROF_STATS_TRUE}" && test -z "${ENABLE_XPROF_STATS_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ENABLE_XPROF_STATS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ENABLE_XPROF_STATS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${NEED_OWN_SNPRINTF_TRUE}" && test -z "${NEED_OWN_SNPRINTF_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"NEED_OWN_SNPRINTF\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"NEED_OWN_SNPRINTF\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${NEED_OWN_SNPRINTF_TRUE}" && test -z "${NEED_OWN_SNPRINTF_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"NEED_OWN_SNPRINTF\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"NEED_OWN_SNPRINTF\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_clean_files_save=$ac_clean_files
@@ -16586,6 +16833,8 @@ s,@USE_SNMP_TRUE@,$USE_SNMP_TRUE,;t t
 s,@USE_SNMP_FALSE@,$USE_SNMP_FALSE,;t t
 s,@SNMPLIB@,$SNMPLIB,;t t
 s,@makesnmplib@,$makesnmplib,;t t
+s,@ENABLE_ARP_ACL_TRUE@,$ENABLE_ARP_ACL_TRUE,;t t
+s,@ENABLE_ARP_ACL_FALSE@,$ENABLE_ARP_ACL_FALSE,;t t
 s,@ENABLE_HTCP_TRUE@,$ENABLE_HTCP_TRUE,;t t
 s,@ENABLE_HTCP_FALSE@,$ENABLE_HTCP_FALSE,;t t
 s,@ENABLE_SSL_TRUE@,$ENABLE_SSL_TRUE,;t t
@@ -3,7 +3,7 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.325 2003/02/22 14:59:32 hno Exp $
+dnl  $Id: configure.in,v 1.326 2003/02/25 12:24:32 robertc Exp $
 dnl
 dnl
 dnl
@@ -13,7 +13,7 @@ AC_CONFIG_SRCDIR([src/main.cc])
 AC_CONFIG_AUX_DIR(cfgaux)
 AM_INIT_AUTOMAKE(squid, 3.0-DEVEL)
 AM_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.325 $)dnl
+AC_REVISION($Revision: 1.326 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AM_MAINTAINER_MODE
 
@@ -604,6 +604,7 @@ AC_ARG_ENABLE(cachemgr-hostname,
    esac
 ])
 
+AM_CONDITIONAL(ENABLE_ARP_ACL, false)
 AC_ARG_ENABLE(arp-acl,
 [  --enable-arp-acl        Enable use of ARP ACL lists (ether address)],
 [  if test "$enableval" = "yes" ; then
@@ -619,6 +620,7 @@ AC_ARG_ENABLE(arp-acl,
 	    ;;
      esac
      AC_DEFINE(USE_ARP_ACL,1,[Define this to include code which lets you specify access control elements based on ethernet hardware addresses.  This code uses functions found in 4.4 BSD derviations (e.g. FreeBSD, ?).])
+     AM_CONDITIONAL(ENABLE_ARP_ACL, true)
    fi
 ])
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACL.h,v 1.7 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACL.h,v 1.8 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -50,67 +50,48 @@ SQUIDCEXTERN err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char
 SQUIDCEXTERN void aclParseDenyInfoLine(struct _acl_deny_info_list **);
 
 SQUIDCEXTERN void aclDestroyDenyInfoList(struct _acl_deny_info_list **);
-
-SQUIDCEXTERN void aclDestroyRegexList(struct _relist *data);
-SQUIDCEXTERN int aclMatchRegex(relist * data, const char *word);
-wordlist *aclDumpRegexList(relist * data);
-SQUIDCEXTERN void aclParseRegexList(void *curlist);
 SQUIDCEXTERN wordlist *aclDumpGeneric(const acl *);
-SQUIDCEXTERN int aclPurgeMethodInUse(acl_access *);
 SQUIDCEXTERN void aclCacheMatchFlush(dlink_list * cache);
 extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
+int aclPurgeMethodInUse(acl_access * a);
+extern const char *AclMatchedName;	/* NULL */
 
 class ACL
 {
 
 public:
     void *operator new(size_t);
     void operator delete(void *);
-    virtual void deleteSelf() const;
+    virtual void deleteSelf() const = 0;
 
     static ACL *Factory (char const *);
     static void ParseAclLine(acl ** head);
+    static void Initialize();
     static ACL* FindByName(const char *name);
 
-    /* temporary until we subclass external acl's */
-    static void ExternalAclLookup(ACLChecklist * ch, ACL *, EAH * callback, void *callback_data);
-
     ACL();
-    ACL (squid_acl const);
     virtual ~ACL();
-    virtual ACL *clone()const;
-    virtual void parse();
-    virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return type;}
-
+    virtual ACL *clone()const = 0;
+    virtual void parse() = 0;
+    virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
     virtual bool requiresRequest() const;
-    virtual int match(ACLChecklist * checklist);
+    virtual bool requiresReply() const;
+    virtual int match(ACLChecklist * checklist) = 0;
     virtual wordlist *dumpGeneric() const;
-    virtual wordlist *dump() const;
-    virtual bool valid () const;
+    virtual wordlist *dump() const = 0;
+    virtual bool valid () const =0;
     int checklistMatches(ACLChecklist *);
 
-    /* only relevant to METHOD acl's */
-    virtual bool containsPURGE() const;
-
-    /* only relecant to ASN acl's */
-    void startCache();
-
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
 
+    virtual void prepareForUse() {}
+
     char name[ACL_NAME_SZ];
     char *cfgline;
     ACL *next;
 
-private:
-    static MemPool *Pool;
-    squid_acl type;
-
-protected:
-    void *data;
-
 public:
 
     class Prototype
@@ -0,0 +1,76 @@
+
+/*
+ * $Id: ACLARP.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLARP_H
+#define SQUID_ACLARP_H
+#include "ACL.h"
+#include "ACLChecklist.h"
+#include "splay.h"
+
+struct acl_arp_data
+{
+    char eth[6];
+    void deleteSelf() const {delete this;}
+};
+
+class ACLARP : public ACL
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    ACLARP(char const *);
+    ACLARP(ACLARP const &);
+    ~ACLARP();
+    ACLARP&operator=(ACLARP const &);
+
+    virtual ACL *clone()const;
+    virtual char const *typeString() const;
+    virtual void parse();
+    virtual int match(ACLChecklist *checklist);
+    virtual wordlist *dump() const;
+    virtual bool valid () const;
+
+protected:
+    static MemPool *Pool;
+    static Prototype RegistryProtoype;
+    static ACLARP RegistryEntry_;
+    SplayNode<acl_arp_data *> *data;
+    char const *class_;
+};
+
+#endif /* SQUID_ACLARP_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLASN.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLASN.h,v 1.3 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,19 +35,38 @@
 
 #ifndef SQUID_ACLASN_H
 #define SQUID_ACLASN_H
+#include "ACLData.h"
+#include "List.h"
+#include "ACLStrategised.h"
 #include "ACLChecklist.h"
-#include "ACLIP.h"
 
-class ASNLookup : public ACLChecklist::AsyncState
+SQUIDCEXTERN int asnMatchIp(List<int> *, struct in_addr);
+SQUIDCEXTERN void asnInit(void);
+SQUIDCEXTERN void asnFreeMemory(void);
+
+class ACLASN : public ACLData<struct in_addr>
 {
 
 public:
-    static ASNLookup *Instance();
-    virtual void checkForAsync(ACLChecklist *)const;
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    virtual ~ACLASN();
+
+    virtual bool match(struct in_addr);
+    virtual wordlist *dump();
+    virtual void parse();
+    virtual ACLData<struct in_addr> *clone() const;
+    virtual void prepareForUse();
 
 private:
-    static ASNLookup instance_;
-    static IPH LookupDone;
+    static MemPool *Pool;
+    static ACL::Prototype SourceRegistryProtoype;
+    static ACLStrategised<struct in_addr> SourceRegistryEntry_;
+    static ACL::Prototype DestinationRegistryProtoype;
+    static ACLStrategised<struct in_addr> DestinationRegistryEntry_;
+    List<int> *data;
 };
 
 #endif /* SQUID_ACLASN_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLCertificate.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLCertificate.h,v 1.3 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -41,7 +41,7 @@
 #include "ssl_support.h"
 #include "ACLStrategised.h"
 
-class ACLCertificateStrategy : public ACLMatchStrategy<SSL *>
+class ACLCertificateStrategy : public ACLStrategy<SSL *>
 {
 
 public:
@@ -62,8 +62,6 @@ class ACLCertificateStrategy : public ACLMatchStrategy<SSL *>
 class ACLCertificate
 {
 
-public:
-
 private:
     static ACL::Prototype UserRegistryProtoype;
     static ACLStrategised<SSL*> UserRegistryEntry_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLCertificateData.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLCertificateData.h,v 1.4 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,6 +39,7 @@
 #include "ACL.h"
 #include "ACLData.h"
 #include "ssl_support.h"
+#include "ACLStringData.h"
 
 class ACLCertificateData : public ACLData<SSL *>
 {
@@ -58,7 +59,7 @@ class ACLCertificateData : public ACLData<SSL *>
     virtual ACLData<SSL *> *clone() const;
 
     char *attribute;
-    SplayNode<char *> *values;
+    ACLStringData values;
 
 private:
     static MemPool *Pool;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLChecklist.h,v 1.7 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLChecklist.h,v 1.8 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -88,7 +88,7 @@ class NullState : public AsyncState
 
     void nonBlockingCheck(PF * callback, void *callback_data);
     void checkCallback(allow_t answer);
-    bool matchAclList(const acl_list * list, bool const fast = false);
+    void matchAclList(const acl_list * list, bool const fast = false);
     ConnStateData *conn();
     void conn(ConnStateData *);
     int authenticated();
@@ -118,7 +118,6 @@ class NullState : public AsyncState
     HttpReply *reply;
     char rfc931[USER_IDENT_SZ];
     auth_user_request_t *auth_user_request;
-    acl_lookup_state state[ACL_ENUM_MAX];
 #if SQUID_SNMP
 
     char *snmp_community;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLData.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLData.h,v 1.4 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -50,6 +50,8 @@ class ACLData
     virtual wordlist *dump() =0;
     virtual void parse() =0;
     virtual ACLData *clone() const =0;
-};
+    virtual void prepareForUse() {}}
+
+;
 
 #endif /* SQUID_ACLDATA_H */
@@ -0,0 +1,61 @@
+
+/*
+ * $Id: ACLDestinationASN.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLDESTINATIONASN_H
+#define SQUID_ACLDESTINATIONASN_H
+#include "ACLASN.h"
+#include "ACLStrategy.h"
+
+class ACLDestinationASNStrategy : public ACLStrategy<struct in_addr>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual bool requiresRequest() const {return true;}
+
+    static ACLDestinationASNStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLDestinationASNStrategy(ACLDestinationASNStrategy const &);
+
+private:
+    static ACLDestinationASNStrategy Instance_;
+    ACLDestinationASNStrategy(){}
+
+    ACLDestinationASNStrategy&operator=(ACLDestinationASNStrategy const &);
+};
+
+#endif /* SQUID_ACLDESTINATIONASN_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLDestinationDomain.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLDestinationDomain.h,v 1.4 2003/02/25 12:22:33 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -65,8 +65,6 @@ class ACLDestinationDomain : public ACL
     ACLDestinationDomain &operator= (ACLDestinationDomain const &);
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
@@ -59,8 +59,6 @@ class ACLDestinationIP : public ACLIP
     virtual void deleteSelf() const;
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual int match(ACLChecklist *checklist);
     virtual bool requiresRequest() const {return true;}
 
@@ -81,7 +81,6 @@ class ACLIP : public ACL
     typedef SplayNode<acl_ip_data *> IPSplay;
 
     virtual char const *typeString() const = 0;
-    virtual squid_acl aclType() const = 0;
     virtual void parse();
     //    virtual bool isProxyAuth() const {return true;}
     virtual int match(ACLChecklist *checklist) = 0;
@@ -65,8 +65,6 @@ class ACLIdent : public ACL
     ~ACLIdent();
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
 
@@ -0,0 +1,61 @@
+
+/*
+ * $Id: ACLIntRange.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLINTRANGE_H
+#define SQUID_ACLINTRANGE_H
+#include "ACLData.h"
+#include "List.h"
+#include "Range.h"
+
+class ACLIntRange : public ACLData<int>
+{
+
+public:
+    virtual void deleteSelf() const;
+
+    ACLIntRange() : ranges(NULL) {}
+
+    virtual ~ACLIntRange();
+    virtual bool match(int);
+    virtual wordlist *dump();
+    virtual void parse();
+    virtual ACLData<int> *clone() const;
+
+private:
+    typedef List<Range<int> > RangeType;
+    RangeType *ranges;
+};
+
+#endif /* SQUID_ACLINTRANGE_H */
@@ -0,0 +1,70 @@
+
+/*
+ * $Id: ACLMaxConnection.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLMAXCONNECTION_H
+#define SQUID_ACLMAXCONNECTION_H
+#include "ACL.h"
+#include "ACLChecklist.h"
+
+class ACLMaxConnection : public ACL
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    ACLMaxConnection(char const *);
+    ACLMaxConnection(ACLMaxConnection const &);
+    ~ACLMaxConnection();
+    ACLMaxConnection&operator=(ACLMaxConnection const &);
+
+    virtual ACL *clone()const;
+    virtual char const *typeString() const;
+    virtual void parse();
+    virtual int match(ACLChecklist *checklist);
+    virtual wordlist *dump() const;
+    virtual bool valid () const;
+    virtual void prepareForUse();
+
+protected:
+    static MemPool *Pool;
+    static Prototype RegistryProtoype;
+    static ACLMaxConnection RegistryEntry_;
+    char const *class_;
+    int limit;
+};
+
+#endif /* SQUID_ACLMAXCONNECTION_H */
@@ -0,0 +1,82 @@
+
+/*
+ * $Id: ACLMaxUserIP.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLMAXUSERIP_H
+#define SQUID_ACLMAXUSERIP_H
+#include "ACL.h"
+#include "ACLChecklist.h"
+
+class ACLMaxUserIP : public ACL
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    ACLMaxUserIP(char const *);
+    ACLMaxUserIP(ACLMaxUserIP const &);
+    ~ACLMaxUserIP();
+    ACLMaxUserIP&operator=(ACLMaxUserIP const &);
+
+    virtual ACL *clone()const;
+    virtual char const *typeString() const;
+    virtual void parse();
+    virtual int match(ACLChecklist *checklist);
+    virtual wordlist *dump() const;
+    virtual bool valid () const;
+    virtual bool requiresRequest() const {return true;}
+
+private:
+    static MemPool *Pool;
+    static Prototype RegistryProtoype;
+    static ACLMaxUserIP RegistryEntry_;
+
+    int match(auth_user_request_t *, struct in_addr const &);
+    char const *class_;
+    size_t max;
+
+    struct Flags
+    {
+        Flags() : strict(0){}
+
+unsigned int strict:
+        1;
+    }
+
+    flags;
+};
+
+#endif /* SQUID_ACLMAXUSERIP_H */
@@ -0,0 +1,69 @@
+
+/*
+ * $Id: ACLMethod.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLMETHOD_H
+#define SQUID_ACLMETHOD_H
+#include "ACLStrategy.h"
+#include "ACLStrategised.h"
+
+class ACLMethodStrategy : public ACLStrategy<method_t>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual bool requiresRequest() const {return true;}
+
+    static ACLMethodStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLMethodStrategy(ACLMethodStrategy const &);
+
+private:
+    static ACLMethodStrategy Instance_;
+    ACLMethodStrategy(){}
+
+    ACLMethodStrategy&operator=(ACLMethodStrategy const &);
+};
+
+class ACLMethod
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<method_t> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLMETHOD_H */
@@ -0,0 +1,65 @@
+
+/*
+ * $Id: ACLMethodData.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLMETHODDATA_H
+#define SQUID_ACLMETHODDATA_H
+#include "ACL.h"
+#include "ACLData.h"
+#include "List.h"
+
+class ACLMethodData : public ACLData<method_t>
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    ACLMethodData();
+    ACLMethodData(ACLMethodData const &);
+    ACLMethodData &operator= (ACLMethodData const &);
+    virtual ~ACLMethodData();
+    bool match(method_t);
+    wordlist *dump();
+    void parse();
+    virtual ACLData<method_t> *clone() const;
+
+    List<method_t> *values;
+
+private:
+    static MemPool *Pool;
+};
+
+#endif /* SQUID_ACLMETHODDATA_H */
@@ -47,8 +47,6 @@ class ACLMyIP : public ACLIP
     static ACLMyIP const &RegistryEntry();
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
 
@@ -0,0 +1,67 @@
+
+/*
+ * $Id: ACLMyPort.h,v 1.1 2003/02/25 12:22:33 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLMYPORT_H
+#define SQUID_ACLMYPORT_H
+#include "ACLStrategy.h"
+#include "ACLStrategised.h"
+
+class ACLMyPortStrategy : public ACLStrategy<int>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    static ACLMyPortStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLMyPortStrategy(ACLMyPortStrategy const &);
+
+private:
+    static ACLMyPortStrategy Instance_;
+    ACLMyPortStrategy(){}
+
+    ACLMyPortStrategy&operator=(ACLMyPortStrategy const &);
+};
+
+class ACLMyPort
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<int> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLMYPORT_H */
@@ -0,0 +1,69 @@
+
+/*
+ * $Id: ACLProtocol.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLPROTOCOL_H
+#define SQUID_ACLPROTOCOL_H
+#include "ACLStrategy.h"
+#include "ACLStrategised.h"
+
+class ACLProtocolStrategy : public ACLStrategy<protocol_t>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual bool requiresRequest() const {return true;}
+
+    static ACLProtocolStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLProtocolStrategy(ACLProtocolStrategy const &);
+
+private:
+    static ACLProtocolStrategy Instance_;
+    ACLProtocolStrategy(){}
+
+    ACLProtocolStrategy&operator=(ACLProtocolStrategy const &);
+};
+
+class ACLProtocol
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<protocol_t> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLPROTOCOL_H */
@@ -0,0 +1,65 @@
+
+/*
+ * $Id: ACLProtocolData.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLPROTOCOLDATA_H
+#define SQUID_ACLPROTOCOLDATA_H
+#include "ACL.h"
+#include "ACLData.h"
+#include "List.h"
+
+class ACLProtocolData : public ACLData<protocol_t>
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    ACLProtocolData();
+    ACLProtocolData(ACLProtocolData const &);
+    ACLProtocolData &operator= (ACLProtocolData const &);
+    virtual ~ACLProtocolData();
+    bool match(protocol_t);
+    wordlist *dump();
+    void parse();
+    virtual ACLData<protocol_t> *clone() const;
+
+    List<protocol_t> *values;
+
+private:
+    static MemPool *Pool;
+};
+
+#endif /* SQUID_ACLPROTOCOLDATA_H */
@@ -76,8 +76,6 @@ class ACLProxyAuth : public ACL
     ACLProxyAuth &operator= (ACLProxyAuth const &);
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
 
@@ -0,0 +1,86 @@
+
+/*
+ * $Id: ACLReplyHeaderStrategy.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLREPLYHEADERSTRATEGY_H
+#define SQUID_ACLREPLYHEADERSTRATEGY_H
+#include "ACL.h"
+#include "ACLData.h"
+#include "ACLStrategy.h"
+
+template <http_hdr_type header>
+
+class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
+{
+
+public:
+    virtual int match (ACLData<char const *> * &, ACLChecklist *);
+    virtual bool requiresReply() const {return true;}
+
+    static ACLReplyHeaderStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLReplyHeaderStrategy(ACLReplyHeaderStrategy const &);
+
+private:
+    static ACLReplyHeaderStrategy Instance_;
+    ACLReplyHeaderStrategy(){}
+
+    ACLReplyHeaderStrategy&operator=(ACLReplyHeaderStrategy const &);
+};
+
+template <http_hdr_type header>
+int
+ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+{
+    char const *theHeader = httpHeaderGetStr(&checklist->request->header, header);
+
+    if (NULL == theHeader)
+        return 0;
+
+    return data->match(theHeader);
+}
+
+template <http_hdr_type header>
+ACLReplyHeaderStrategy<header> *
+ACLReplyHeaderStrategy<header>::Instance()
+{
+    return &Instance_;
+}
+
+template <http_hdr_type header>
+ACLReplyHeaderStrategy<header> ACLReplyHeaderStrategy<header>::Instance_;
+
+#endif /* SQUID_REPLYHEADERSTRATEGY_H */
@@ -0,0 +1,64 @@
+
+/*
+ * $Id: ACLReplyMIMEType.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLREPLYMIMETYPE_H
+#define SQUID_ACLREPLYMIMETYPE_H
+#include "ACL.h"
+#include "ACLData.h"
+#include "ACLReplyHeaderStrategy.h"
+#include "ACLStrategised.h"
+#include "ACLChecklist.h"
+
+class ACLReplyMIMEType
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<char const *> RegistryEntry_;
+};
+
+/* partial specialisation */
+int
+ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+{
+    char const *theHeader = httpHeaderGetStr(&checklist->request->header, HDR_CONTENT_TYPE);
+
+    if (NULL == theHeader)
+        theHeader = "";
+
+    return data->match(theHeader);
+}
+
+#endif /* SQUID_ACLREPLYMIMETYPE_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRequestHeaderStrategy.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLRequestHeaderStrategy.h,v 1.3 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,11 +37,11 @@
 #define SQUID_ACLREQUESTHEADERSTRATEGY_H
 #include "ACL.h"
 #include "ACLData.h"
-#include "ACLMatchStrategy.h"
+#include "ACLStrategy.h"
 
 template <http_hdr_type header>
 
-class ACLRequestHeaderStrategy : public ACLMatchStrategy<char const *>
+class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
@@ -0,0 +1,59 @@
+
+/*
+ * $Id: ACLSourceASN.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLSOURCEASN_H
+#define SQUID_ACLSOURCEASN_H
+#include "ACLASN.h"
+#include "ACLStrategy.h"
+
+class ACLSourceASNStrategy : public ACLStrategy<struct in_addr>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    static ACLSourceASNStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLSourceASNStrategy(ACLSourceASNStrategy const &);
+
+private:
+    static ACLSourceASNStrategy Instance_;
+    ACLSourceASNStrategy(){}
+
+    ACLSourceASNStrategy&operator=(ACLSourceASNStrategy const &);
+};
+
+#endif /* SQUID_ACLSOURCEASN_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLSourceDomain.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLSourceDomain.h,v 1.4 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,7 +40,7 @@
 #include "ACLChecklist.h"
 #include "ACLStrategised.h"
 
-class ACLSourceDomainStrategy : public ACLMatchStrategy<char const *>
+class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
@@ -46,8 +46,6 @@ class ACLSourceIP : public ACLIP
     virtual void deleteSelf() const;
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLStrategised.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLStrategised.h,v 1.3 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,7 +37,7 @@
 #define SQUID_ACLSTRATEGISED_H
 #include "ACL.h"
 #include "ACLData.h"
-#include "ACLMatchStrategy.h"
+#include "ACLStrategy.h"
 
 template <class M>
 
@@ -51,17 +51,18 @@ class ACLStrategised : public ACL
     virtual void deleteSelf() const;
 
     ~ACLStrategised();
-    ACLStrategised(ACLData<MatchType> *, ACLMatchStrategy<MatchType> *, char const *);
+    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *);
     ACLStrategised (ACLStrategised const &);
     ACLStrategised &operator= (ACLStrategised const &);
 
     virtual char const *typeString() const;
-    virtual squid_acl aclType() const { return ACL_DERIVED;}
-
     virtual bool requiresRequest() const {return matcher->requiresRequest();}
 
+    virtual void prepareForUse() { data->prepareForUse();}
+
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
+    virtual int match (M const &);
     virtual wordlist *dump() const;
     virtual bool valid () const;
     virtual ACL *clone()const;
@@ -70,7 +71,7 @@ class ACLStrategised : public ACL
     static MemPool *Pool;
     ACLData<MatchType> *data;
     char const *type_;
-    ACLMatchStrategy<MatchType> *matcher;
+    ACLStrategy<MatchType> *matcher;
 };
 
 /* implementation follows */
@@ -112,7 +113,7 @@ ACLStrategised<MatchType>::~ACLStrategised()
 }
 
 template <class MatchType>
-ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLMatchStrategy<MatchType> *theStrategy, char const *theType) : data (newData), type_(theType), matcher(theStrategy) {}
+ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType) : data (newData), type_(theType), matcher(theStrategy) {}
 
 template <class MatchType>
 ACLStrategised<MatchType>::ACLStrategised (ACLStrategised const &old) : data (old.data->clone()), type_(old.type_), matcher (old.matcher)
@@ -149,6 +150,13 @@ ACLStrategised<MatchType>::match(ACLChecklist *checklist)
     return matcher->match(data, checklist);
 }
 
+template <class MatchType>
+int
+ACLStrategised<MatchType>::match(MatchType const &toFind)
+{
+    return data->match(toFind);
+}
+
 template <class MatchType>
 wordlist *
 ACLStrategised<MatchType>::dump() const
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLMatchStrategy.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLStrategy.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -33,25 +33,25 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
-#ifndef SQUID_ACLMATCHSTRATEGY_H
-#define SQUID_ACLMATCHSTRATEGY_H
+#ifndef SQUID_ACLSTRATEGY_H
+#define SQUID_ACLSTRATEGY_H
 #include "ACL.h"
 #include "ACLData.h"
 
 /* Perhaps this should live in ACL? */
 
 template<class M>
 
-class ACLMatchStrategy
+class ACLStrategy
 {
 
 public:
     typedef M MatchType;
     virtual int match (ACLData<M> * &, ACLChecklist *) = 0;
     virtual bool requiresRequest() const {return false;}
 
-    virtual ~ACLMatchStrategy(){}}
+    virtual ~ACLStrategy(){}}
 
 ;
 
-#endif /* SQUID_ACLMATCHSTRATEGY_H */
+#endif /* SQUID_ACLSTRATEGY_H */
@@ -0,0 +1,65 @@
+
+/*
+ * $Id: ACLStringData.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLSTRINGDATA_H
+#define SQUID_ACLSTRINGDATA_H
+#include "splay.h"
+#include "ACL.h"
+#include "ACLData.h"
+
+class ACLStringData : public ACLData<char const *>
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    ACLStringData();
+    ACLStringData(ACLStringData const &);
+    ACLStringData &operator= (ACLStringData const &);
+    virtual ~ACLStringData();
+    bool match(char const *);
+    wordlist *dump();
+    void parse();
+    virtual ACLData<char const *> *clone() const;
+
+    SplayNode<char *> *values;
+
+private:
+    static MemPool *Pool;
+};
+
+#endif /* SQUID_ACLSTRINGDATA_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLTime.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLTime.h,v 1.3 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,7 +40,7 @@
 #include "ACLChecklist.h"
 #include "ACLStrategised.h"
 
-class ACLTimeStrategy : public ACLMatchStrategy<time_t>
+class ACLTimeStrategy : public ACLStrategy<time_t>
 {
 
 public:
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLUrl.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLUrl.h,v 1.3 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,7 +39,7 @@
 #include "ACLData.h"
 #include "ACLStrategised.h"
 
-class ACLUrlStrategy : public ACLMatchStrategy<char const *>
+class ACLUrlStrategy : public ACLStrategy<char const *>
 {
 
 public:
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLUrlPath.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
+ * $Id: ACLUrlPath.h,v 1.3 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,10 +37,10 @@
 #define SQUID_ACLURLPATH_H
 #include "ACL.h"
 #include "ACLData.h"
-#include "ACLMatchStrategy.h"
+#include "ACLStrategy.h"
 #include "ACLStrategised.h"
 
-class ACLUrlPathStrategy : public ACLMatchStrategy<char const *>
+class ACLUrlPathStrategy : public ACLStrategy<char const *>
 {
 
 public:
@@ -0,0 +1,69 @@
+
+/*
+ * $Id: ACLUrlPort.h,v 1.1 2003/02/25 12:22:34 robertc Exp $
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLURLPORT_H
+#define SQUID_ACLURLPORT_H
+#include "ACLStrategy.h"
+#include "ACLStrategised.h"
+
+class ACLUrlPortStrategy : public ACLStrategy<int>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual bool requiresRequest() const {return true;}
+
+    static ACLUrlPortStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLUrlPortStrategy(ACLUrlPortStrategy const &);
+
+private:
+    static ACLUrlPortStrategy Instance_;
+    ACLUrlPortStrategy(){}
+
+    ACLUrlPortStrategy&operator=(ACLUrlPortStrategy const &);
+};
+
+class ACLUrlPort
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<int> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLURLPORT_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ExternalACL.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
+ * $Id: ExternalACL.h,v 1.3 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,6 +35,7 @@
 
 #ifndef SQUID_EXTERNALACL_H
 #define SQUID_EXTERNALACL_H
+#include "ACL.h"
 #include "ACLChecklist.h"
 
 class ExternalACLLookup : public ACLChecklist::AsyncState
@@ -49,4 +50,44 @@ class ExternalACLLookup : public ACLChecklist::AsyncState
     static void LookupDone(void *data, void *result);
 };
 
+typedef struct _external_acl_data external_acl_data;
+
+class ACLExternal : public ACL
+{
+
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+    virtual void deleteSelf() const;
+
+    static void ExternalAclLookup(ACLChecklist * ch, ACLExternal *, EAH * callback, void *callback_data);
+
+
+    ACLExternal(char const *);
+    ACLExternal(ACLExternal const &);
+    ~ACLExternal();
+    ACLExternal&operator=(ACLExternal const &);
+
+    virtual ACL *clone()const;
+    virtual char const *typeString() const;
+    virtual void parse();
+    virtual int match(ACLChecklist *checklist);
+    /* This really should be dynamic based on the external class defn */
+    virtual bool requiresRequest() const {return true;}
+
+    /* when requiresRequest is made dynamic, review this too */
+    //    virtual bool requiresReply() const {return true;}
+    /* This may need to be extant, to cause 407's if %LOGIN% is used. */
+    //    virtual bool isProxyAuth() const {return true;}
+    virtual wordlist *dump() const;
+    virtual bool valid () const;
+
+protected:
+    static MemPool *Pool;
+    static Prototype RegistryProtoype;
+    static ACLExternal RegistryEntry_;
+    external_acl_data *data;
+    char const *class_;
+};
+
 #endif /* SQUID_EXTERNALACL_H */
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.61 2003/02/17 07:01:35 robertc Exp $
+#  $Id: Makefile.am,v 1.62 2003/02/25 12:24:32 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -100,6 +100,12 @@ else
 IDENTSOURCE =
 endif
 
+if ENABLE_ARP_ACL
+ARP_ACL_SOURCE = ACLARP.cc ACLARP.h
+else
+ARP_ACL_SOURCE =
+endif
+
 AM_CFLAGS = -Werror -Wall
 AM_CXXFLAGS = -Werror -Wall
 
@@ -137,6 +143,7 @@ squidclient_SOURCES = client.cc
 cachemgr__CGIEXT__SOURCES = cachemgr.cc
 
 EXTRA_squid_SOURCES = \
+	$(ARP_ACL_SOURCE) \
 	$(DELAY_POOL_SOURCE) \
 	dns.cc \
 	dnsserver.cc \
@@ -152,6 +159,11 @@ EXTRA_squid_SOURCES = \
 	win32.cc
 
 squid_ACLSOURCES = \
+	$(ARP_ACL_SOURCE) \
+	ACLASN.cc \
+	ACLASN.h \
+	ACLDestinationASN.h \
+	ACLSourceASN.h \
 	ACLBrowser.cc \
 	ACLBrowser.h \
 	ACLData.h \
@@ -161,17 +173,35 @@ squid_ACLSOURCES = \
 	ACLDestinationIP.h \
 	ACLDomainData.h \
 	ACLDomainData.cc \
+	ACLIntRange.cc \
+	ACLIntRange.h \
 	ACLIP.cc \
 	ACLIP.h \
-	ACLMatchStrategy.h \
+	ACLMaxConnection.cc \
+	ACLMaxConnection.h \
+	ACLMaxUserIP.cc \
+	ACLMaxUserIP.h \
+	ACLMethod.cc \
+	ACLMethod.h \
+	ACLMethodData.cc \
+	ACLMethodData.h \
 	ACLMyIP.cc \
 	ACLMyIP.h \
+	ACLMyPort.cc \
+	ACLMyPort.h \
+	ACLProtocol.cc \
+	ACLProtocol.h \
+	ACLProtocolData.cc \
+	ACLProtocolData.h \
 	ACLProxyAuth.cc \
 	ACLProxyAuth.h \
 	ACLReferer.cc \
 	ACLReferer.h \
 	ACLRegexData.cc \
 	ACLRegexData.h \
+	ACLReplyHeaderStrategy.h \
+	ACLReplyMIMEType.cc \
+	ACLReplyMIMEType.h \
 	ACLRequestHeaderStrategy.h \
 	ACLRequestMIMEType.cc \
 	ACLRequestMIMEType.h \
@@ -181,6 +211,9 @@ squid_ACLSOURCES = \
 	ACLSourceIP.h \
 	ACLStrategised.cc \
 	ACLStrategised.h \
+	ACLStrategy.h \
+	ACLStringData.cc \
+	ACLStringData.h \
 	ACLTime.cc \
 	ACLTime.h \
 	ACLTimeData.cc \
@@ -189,6 +222,8 @@ squid_ACLSOURCES = \
 	ACLUrl.h \
 	ACLUrlPath.cc \
 	ACLUrlPath.h \
+	ACLUrlPort.cc \
+	ACLUrlPort.h \
 	ACLUserData.cc \
 	ACLUserData.h 
 
@@ -409,6 +444,7 @@ ufsdump_SOURCES = debug.cc \
 	access_log.cc \
 	acl.cc \
 	$(squid_ACLSOURCES) \
+	ACLChecklist.cc \
 	asn.cc \
 	authenticate.cc \
 	cache_cf.cc \
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.293 2003/02/17 07:07:04 robertc Exp $
+#  $Id: Makefile.in,v 1.294 2003/02/25 12:24:33 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -187,6 +187,9 @@ makesnmplib = @makesnmplib@
 @ENABLE_IDENT_TRUE@IDENTSOURCE = ACLIdent.cc ACLIdent.h ident.cc
 @ENABLE_IDENT_FALSE@IDENTSOURCE = 
 
+@ENABLE_ARP_ACL_TRUE@ARP_ACL_SOURCE = ACLARP.cc ACLARP.h
+@ENABLE_ARP_ACL_FALSE@ARP_ACL_SOURCE = 
+
 AM_CFLAGS = -Werror -Wall
 AM_CXXFLAGS = -Werror -Wall
 
@@ -227,6 +230,7 @@ squidclient_SOURCES = client.cc
 cachemgr__CGIEXT__SOURCES = cachemgr.cc
 
 EXTRA_squid_SOURCES = \
+	$(ARP_ACL_SOURCE) \
 	$(DELAY_POOL_SOURCE) \
 	dns.cc \
 	dnsserver.cc \
@@ -243,6 +247,11 @@ EXTRA_squid_SOURCES = \
 
 
 squid_ACLSOURCES = \
+	$(ARP_ACL_SOURCE) \
+	ACLASN.cc \
+	ACLASN.h \
+	ACLDestinationASN.h \
+	ACLSourceASN.h \
 	ACLBrowser.cc \
 	ACLBrowser.h \
 	ACLData.h \
@@ -252,17 +261,35 @@ squid_ACLSOURCES = \
 	ACLDestinationIP.h \
 	ACLDomainData.h \
 	ACLDomainData.cc \
+	ACLIntRange.cc \
+	ACLIntRange.h \
 	ACLIP.cc \
 	ACLIP.h \
-	ACLMatchStrategy.h \
+	ACLMaxConnection.cc \
+	ACLMaxConnection.h \
+	ACLMaxUserIP.cc \
+	ACLMaxUserIP.h \
+	ACLMethod.cc \
+	ACLMethod.h \
+	ACLMethodData.cc \
+	ACLMethodData.h \
 	ACLMyIP.cc \
 	ACLMyIP.h \
+	ACLMyPort.cc \
+	ACLMyPort.h \
+	ACLProtocol.cc \
+	ACLProtocol.h \
+	ACLProtocolData.cc \
+	ACLProtocolData.h \
 	ACLProxyAuth.cc \
 	ACLProxyAuth.h \
 	ACLReferer.cc \
 	ACLReferer.h \
 	ACLRegexData.cc \
 	ACLRegexData.h \
+	ACLReplyHeaderStrategy.h \
+	ACLReplyMIMEType.cc \
+	ACLReplyMIMEType.h \
 	ACLRequestHeaderStrategy.h \
 	ACLRequestMIMEType.cc \
 	ACLRequestMIMEType.h \
@@ -272,6 +299,9 @@ squid_ACLSOURCES = \
 	ACLSourceIP.h \
 	ACLStrategised.cc \
 	ACLStrategised.h \
+	ACLStrategy.h \
+	ACLStringData.cc \
+	ACLStringData.h \
 	ACLTime.cc \
 	ACLTime.h \
 	ACLTimeData.cc \
@@ -280,6 +310,8 @@ squid_ACLSOURCES = \
 	ACLUrl.h \
 	ACLUrlPath.cc \
 	ACLUrlPath.h \
+	ACLUrlPort.cc \
+	ACLUrlPort.h \
 	ACLUserData.cc \
 	ACLUserData.h 
 
@@ -506,6 +538,7 @@ ufsdump_SOURCES = debug.cc \
 	access_log.cc \
 	acl.cc \
 	$(squid_ACLSOURCES) \
+	ACLChecklist.cc \
 	asn.cc \
 	authenticate.cc \
 	cache_cf.cc \
@@ -780,68 +813,75 @@ recv_announce_OBJECTS = $(am_recv_announce_OBJECTS)
 recv_announce_LDADD = $(LDADD)
 recv_announce_DEPENDENCIES =
 recv_announce_LDFLAGS =
-am__objects_4 = ACLBrowser.$(OBJEXT) ACLDestinationDomain.$(OBJEXT) \
-	ACLDestinationIP.$(OBJEXT) ACLDomainData.$(OBJEXT) \
-	ACLIP.$(OBJEXT) ACLMyIP.$(OBJEXT) ACLProxyAuth.$(OBJEXT) \
+@ENABLE_ARP_ACL_TRUE@am__objects_1 = ACLARP.$(OBJEXT)
+@ENABLE_ARP_ACL_FALSE@am__objects_1 =
+am__objects_2 = $(am__objects_1) ACLASN.$(OBJEXT) ACLBrowser.$(OBJEXT) \
+	ACLDestinationDomain.$(OBJEXT) ACLDestinationIP.$(OBJEXT) \
+	ACLDomainData.$(OBJEXT) ACLIntRange.$(OBJEXT) ACLIP.$(OBJEXT) \
+	ACLMaxConnection.$(OBJEXT) ACLMaxUserIP.$(OBJEXT) \
+	ACLMethod.$(OBJEXT) ACLMethodData.$(OBJEXT) ACLMyIP.$(OBJEXT) \
+	ACLMyPort.$(OBJEXT) ACLProtocol.$(OBJEXT) \
+	ACLProtocolData.$(OBJEXT) ACLProxyAuth.$(OBJEXT) \
 	ACLReferer.$(OBJEXT) ACLRegexData.$(OBJEXT) \
-	ACLRequestMIMEType.$(OBJEXT) ACLSourceDomain.$(OBJEXT) \
-	ACLSourceIP.$(OBJEXT) ACLStrategised.$(OBJEXT) \
+	ACLReplyMIMEType.$(OBJEXT) ACLRequestMIMEType.$(OBJEXT) \
+	ACLSourceDomain.$(OBJEXT) ACLSourceIP.$(OBJEXT) \
+	ACLStrategised.$(OBJEXT) ACLStringData.$(OBJEXT) \
 	ACLTime.$(OBJEXT) ACLTimeData.$(OBJEXT) ACLUrl.$(OBJEXT) \
-	ACLUrlPath.$(OBJEXT) ACLUserData.$(OBJEXT)
-@USE_DELAY_POOLS_FALSE@am__objects_5 =
-@USE_DELAY_POOLS_TRUE@am__objects_5 = delay_pools.$(OBJEXT) \
+	ACLUrlPath.$(OBJEXT) ACLUrlPort.$(OBJEXT) ACLUserData.$(OBJEXT)
+@USE_DELAY_POOLS_TRUE@am__objects_3 = delay_pools.$(OBJEXT) \
 @USE_DELAY_POOLS_TRUE@	DelayId.$(OBJEXT) DelayBucket.$(OBJEXT) \
 @USE_DELAY_POOLS_TRUE@	DelayConfig.$(OBJEXT) DelayPool.$(OBJEXT) \
 @USE_DELAY_POOLS_TRUE@	DelaySpec.$(OBJEXT) DelayUser.$(OBJEXT) \
 @USE_DELAY_POOLS_TRUE@	DelayVector.$(OBJEXT) \
 @USE_DELAY_POOLS_TRUE@	NullDelayId.$(OBJEXT)
-@USE_DNSSERVER_FALSE@am__objects_6 = dns_internal.$(OBJEXT)
-@USE_DNSSERVER_TRUE@am__objects_6 = dns.$(OBJEXT)
-@ENABLE_HTCP_TRUE@am__objects_7 = htcp.$(OBJEXT)
-@ENABLE_IDENT_TRUE@am__objects_8 = ACLIdent.$(OBJEXT) ident.$(OBJEXT)
-@ENABLE_IDENT_FALSE@am__objects_8 =
-@MAKE_LEAKFINDER_TRUE@am__objects_9 = leakfinder.$(OBJEXT)
-@MAKE_LEAKFINDER_FALSE@am__objects_9 =
-@ENABLE_XPROF_STATS_TRUE@am__objects_3 = ProfStats.$(OBJEXT)
-@ENABLE_XPROF_STATS_FALSE@am__objects_3 =
-@USE_SNMP_TRUE@am__objects_10 = snmp_core.$(OBJEXT) snmp_agent.$(OBJEXT)
-@USE_SNMP_FALSE@am__objects_10 =
-@ENABLE_SSL_FALSE@am__objects_11 =
-@ENABLE_SSL_TRUE@am__objects_11 = ACLCertificateData.$(OBJEXT) \
+@USE_DELAY_POOLS_FALSE@am__objects_3 =
+@USE_DNSSERVER_TRUE@am__objects_4 = dns.$(OBJEXT)
+@USE_DNSSERVER_FALSE@am__objects_4 = dns_internal.$(OBJEXT)
+@ENABLE_HTCP_TRUE@am__objects_5 = htcp.$(OBJEXT)
+@ENABLE_IDENT_TRUE@am__objects_6 = ACLIdent.$(OBJEXT) ident.$(OBJEXT)
+@ENABLE_IDENT_FALSE@am__objects_6 =
+@MAKE_LEAKFINDER_TRUE@am__objects_7 = leakfinder.$(OBJEXT)
+@MAKE_LEAKFINDER_FALSE@am__objects_7 =
+@ENABLE_XPROF_STATS_TRUE@am__objects_8 = ProfStats.$(OBJEXT)
+@ENABLE_XPROF_STATS_FALSE@am__objects_8 =
+@USE_SNMP_TRUE@am__objects_9 = snmp_core.$(OBJEXT) snmp_agent.$(OBJEXT)
+@USE_SNMP_FALSE@am__objects_9 =
+@ENABLE_SSL_TRUE@am__objects_10 = ACLCertificateData.$(OBJEXT) \
 @ENABLE_SSL_TRUE@	ACLCertificate.$(OBJEXT) ssl_support.$(OBJEXT)
-@ENABLE_UNLINKD_TRUE@am__objects_12 = unlinkd.$(OBJEXT)
-@ENABLE_UNLINKD_FALSE@am__objects_12 =
-@ENABLE_WIN32SPECIFIC_FALSE@am__objects_13 =
-@ENABLE_WIN32SPECIFIC_TRUE@am__objects_13 = win32.$(OBJEXT)
+@ENABLE_SSL_FALSE@am__objects_10 =
+@ENABLE_UNLINKD_TRUE@am__objects_11 = unlinkd.$(OBJEXT)
+@ENABLE_UNLINKD_FALSE@am__objects_11 =
+@ENABLE_WIN32SPECIFIC_TRUE@am__objects_12 = win32.$(OBJEXT)
+@ENABLE_WIN32SPECIFIC_FALSE@am__objects_12 =
 am_squid_OBJECTS = access_log.$(OBJEXT) acl.$(OBJEXT) \
-	ACLChecklist.$(OBJEXT) $(am__objects_4) asn.$(OBJEXT) \
+	ACLChecklist.$(OBJEXT) $(am__objects_2) asn.$(OBJEXT) \
 	authenticate.$(OBJEXT) cache_cf.$(OBJEXT) CacheDigest.$(OBJEXT) \
 	cache_manager.$(OBJEXT) carp.$(OBJEXT) cbdata.$(OBJEXT) \
 	client_db.$(OBJEXT) client_side.$(OBJEXT) \
 	client_side_reply.$(OBJEXT) client_side_request.$(OBJEXT) \
 	clientStream.$(OBJEXT) comm.$(OBJEXT) comm_select.$(OBJEXT) \
 	comm_poll.$(OBJEXT) comm_kqueue.$(OBJEXT) debug.$(OBJEXT) \
-	$(am__objects_5) disk.$(OBJEXT) $(am__objects_6) \
+	$(am__objects_3) disk.$(OBJEXT) $(am__objects_4) \
 	errorpage.$(OBJEXT) ETag.$(OBJEXT) event.$(OBJEXT) \
 	external_acl.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) \
 	filemap.$(OBJEXT) forward.$(OBJEXT) fqdncache.$(OBJEXT) \
 	ftp.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
-	$(am__objects_7) http.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
+	$(am__objects_5) http.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
 	HttpHdrCc.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
 	HttpHdrContRange.$(OBJEXT) HttpHeader.$(OBJEXT) \
 	HttpHeaderTools.$(OBJEXT) HttpBody.$(OBJEXT) HttpMsg.$(OBJEXT) \
 	HttpReply.$(OBJEXT) HttpRequest.$(OBJEXT) icmp.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_8) \
+	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_6) \
 	int.$(OBJEXT) internal.$(OBJEXT) ipc.$(OBJEXT) \
-	ipcache.$(OBJEXT) IPInterception.$(OBJEXT) $(am__objects_9) \
+	ipcache.$(OBJEXT) IPInterception.$(OBJEXT) $(am__objects_7) \
 	logfile.$(OBJEXT) main.$(OBJEXT) mem.$(OBJEXT) \
 	mem_node.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
 	mime.$(OBJEXT) multicast.$(OBJEXT) neighbors.$(OBJEXT) \
-	net_db.$(OBJEXT) Packer.$(OBJEXT) $(am__objects_3) \
+	net_db.$(OBJEXT) Packer.$(OBJEXT) $(am__objects_8) \
 	pconn.$(OBJEXT) peer_digest.$(OBJEXT) peer_select.$(OBJEXT) \
 	redirect.$(OBJEXT) referer.$(OBJEXT) refresh.$(OBJEXT) \
-	send-announce.$(OBJEXT) $(am__objects_10) tunnel.$(OBJEXT) \
-	$(am__objects_11) stat.$(OBJEXT) StatHist.$(OBJEXT) \
+	send-announce.$(OBJEXT) $(am__objects_9) tunnel.$(OBJEXT) \
+	$(am__objects_10) stat.$(OBJEXT) StatHist.$(OBJEXT) \
 	String.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
 	store_io.$(OBJEXT) StoreIOState.$(OBJEXT) \
 	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
@@ -852,9 +892,9 @@ am_squid_OBJECTS = access_log.$(OBJEXT) acl.$(OBJEXT) \
 	StoreMetaSTD.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
 	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
 	SwapDir.$(OBJEXT) tools.$(OBJEXT) ufscommon.$(OBJEXT) \
-	$(am__objects_12) url.$(OBJEXT) urn.$(OBJEXT) \
+	$(am__objects_11) url.$(OBJEXT) urn.$(OBJEXT) \
 	useragent.$(OBJEXT) wais.$(OBJEXT) wccp.$(OBJEXT) \
-	whois.$(OBJEXT) $(am__objects_13)
+	whois.$(OBJEXT) $(am__objects_12)
 nodist_squid_OBJECTS = repl_modules.$(OBJEXT) auth_modules.$(OBJEXT) \
 	store_modules.$(OBJEXT) globals.$(OBJEXT) \
 	string_arrays.$(OBJEXT)
@@ -869,43 +909,44 @@ am_ufsdump_OBJECTS = debug.$(OBJEXT) int.$(OBJEXT) ufsdump.$(OBJEXT) \
 	store.$(OBJEXT) StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
 	StoreMetaSTD.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
 	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	access_log.$(OBJEXT) acl.$(OBJEXT) $(am__objects_4) \
-	asn.$(OBJEXT) authenticate.$(OBJEXT) cache_cf.$(OBJEXT) \
-	CacheDigest.$(OBJEXT) cache_manager.$(OBJEXT) carp.$(OBJEXT) \
-	cbdata.$(OBJEXT) client_db.$(OBJEXT) client_side.$(OBJEXT) \
+	access_log.$(OBJEXT) acl.$(OBJEXT) $(am__objects_2) \
+	ACLChecklist.$(OBJEXT) asn.$(OBJEXT) authenticate.$(OBJEXT) \
+	cache_cf.$(OBJEXT) CacheDigest.$(OBJEXT) \
+	cache_manager.$(OBJEXT) carp.$(OBJEXT) cbdata.$(OBJEXT) \
+	client_db.$(OBJEXT) client_side.$(OBJEXT) \
 	client_side_reply.$(OBJEXT) client_side_request.$(OBJEXT) \
 	clientStream.$(OBJEXT) comm.$(OBJEXT) comm_select.$(OBJEXT) \
-	comm_poll.$(OBJEXT) comm_kqueue.$(OBJEXT) $(am__objects_5) \
-	disk.$(OBJEXT) $(am__objects_6) errorpage.$(OBJEXT) \
+	comm_poll.$(OBJEXT) comm_kqueue.$(OBJEXT) $(am__objects_3) \
+	disk.$(OBJEXT) $(am__objects_4) errorpage.$(OBJEXT) \
 	ETag.$(OBJEXT) event.$(OBJEXT) external_acl.$(OBJEXT) \
 	fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) forward.$(OBJEXT) \
 	fqdncache.$(OBJEXT) ftp.$(OBJEXT) gopher.$(OBJEXT) \
-	helper.$(OBJEXT) $(am__objects_7) http.$(OBJEXT) \
+	helper.$(OBJEXT) $(am__objects_5) http.$(OBJEXT) \
 	HttpStatusLine.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrRange.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
 	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
 	HttpBody.$(OBJEXT) HttpMsg.$(OBJEXT) HttpReply.$(OBJEXT) \
 	HttpRequest.$(OBJEXT) icmp.$(OBJEXT) icp_v2.$(OBJEXT) \
-	icp_v3.$(OBJEXT) $(am__objects_8) internal.$(OBJEXT) \
+	icp_v3.$(OBJEXT) $(am__objects_6) internal.$(OBJEXT) \
 	ipc.$(OBJEXT) ipcache.$(OBJEXT) IPInterception.$(OBJEXT) \
-	$(am__objects_9) logfile.$(OBJEXT) mem.$(OBJEXT) \
+	$(am__objects_7) logfile.$(OBJEXT) mem.$(OBJEXT) \
 	mem_node.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
 	mime.$(OBJEXT) multicast.$(OBJEXT) neighbors.$(OBJEXT) \
-	net_db.$(OBJEXT) Packer.$(OBJEXT) $(am__objects_3) \
+	net_db.$(OBJEXT) Packer.$(OBJEXT) $(am__objects_8) \
 	pconn.$(OBJEXT) peer_digest.$(OBJEXT) peer_select.$(OBJEXT) \
 	redirect.$(OBJEXT) referer.$(OBJEXT) refresh.$(OBJEXT) \
-	send-announce.$(OBJEXT) $(am__objects_10) tunnel.$(OBJEXT) \
-	$(am__objects_11) stat.$(OBJEXT) StatHist.$(OBJEXT) \
+	send-announce.$(OBJEXT) $(am__objects_9) tunnel.$(OBJEXT) \
+	$(am__objects_10) stat.$(OBJEXT) StatHist.$(OBJEXT) \
 	String.$(OBJEXT) stmem.$(OBJEXT) store_io.$(OBJEXT) \
 	StoreIOState.$(OBJEXT) store_client.$(OBJEXT) \
 	store_digest.$(OBJEXT) store_dir.$(OBJEXT) \
 	store_key_md5.$(OBJEXT) store_log.$(OBJEXT) \
 	store_rebuild.$(OBJEXT) store_swapin.$(OBJEXT) \
 	store_swapmeta.$(OBJEXT) store_swapout.$(OBJEXT) \
 	SwapDir.$(OBJEXT) tools.$(OBJEXT) ufscommon.$(OBJEXT) \
-	$(am__objects_12) url.$(OBJEXT) urn.$(OBJEXT) \
+	$(am__objects_11) url.$(OBJEXT) urn.$(OBJEXT) \
 	useragent.$(OBJEXT) wais.$(OBJEXT) wccp.$(OBJEXT) \
-	whois.$(OBJEXT) $(am__objects_13)
+	whois.$(OBJEXT) $(am__objects_12)
 nodist_ufsdump_OBJECTS = repl_modules.$(OBJEXT) auth_modules.$(OBJEXT) \
 	store_modules.$(OBJEXT) globals.$(OBJEXT) \
 	string_arrays.$(OBJEXT)
@@ -921,94 +962,117 @@ CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 depcomp = $(SHELL) $(top_srcdir)/cfgaux/depcomp
-@AMDEP_TRUE@DEP_FILES = $(DEPDIR)/ACLBrowser.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLCertificate.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLCertificateData.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLChecklist.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLDestinationDomain.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLDestinationIP.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLDomainData.Po $(DEPDIR)/ACLIP.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLIdent.Po $(DEPDIR)/ACLMyIP.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLProxyAuth.Po $(DEPDIR)/ACLReferer.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLRegexData.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLRequestMIMEType.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLSourceDomain.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLSourceIP.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLStrategised.Po $(DEPDIR)/ACLTime.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLTimeData.Po $(DEPDIR)/ACLUrl.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ACLUrlPath.Po $(DEPDIR)/ACLUserData.Po \
-@AMDEP_TRUE@	$(DEPDIR)/CacheDigest.Po $(DEPDIR)/DelayBucket.Po \
-@AMDEP_TRUE@	$(DEPDIR)/DelayConfig.Po $(DEPDIR)/DelayId.Po \
-@AMDEP_TRUE@	$(DEPDIR)/DelayPool.Po $(DEPDIR)/DelaySpec.Po \
-@AMDEP_TRUE@	$(DEPDIR)/DelayUser.Po $(DEPDIR)/DelayVector.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ETag.Po $(DEPDIR)/HttpBody.Po \
-@AMDEP_TRUE@	$(DEPDIR)/HttpHdrCc.Po \
-@AMDEP_TRUE@	$(DEPDIR)/HttpHdrContRange.Po \
-@AMDEP_TRUE@	$(DEPDIR)/HttpHdrRange.Po $(DEPDIR)/HttpHeader.Po \
-@AMDEP_TRUE@	$(DEPDIR)/HttpHeaderTools.Po $(DEPDIR)/HttpMsg.Po \
-@AMDEP_TRUE@	$(DEPDIR)/HttpReply.Po $(DEPDIR)/HttpRequest.Po \
-@AMDEP_TRUE@	$(DEPDIR)/HttpStatusLine.Po \
-@AMDEP_TRUE@	$(DEPDIR)/IPInterception.Po $(DEPDIR)/MemBuf.Po \
-@AMDEP_TRUE@	$(DEPDIR)/MemObject.Po $(DEPDIR)/NullDelayId.Po \
-@AMDEP_TRUE@	$(DEPDIR)/Packer.Po $(DEPDIR)/ProfStats.Po \
-@AMDEP_TRUE@	$(DEPDIR)/StatHist.Po $(DEPDIR)/StoreIOState.Po \
-@AMDEP_TRUE@	$(DEPDIR)/StoreMeta.Po $(DEPDIR)/StoreMetaMD5.Po \
-@AMDEP_TRUE@	$(DEPDIR)/StoreMetaSTD.Po $(DEPDIR)/StoreMetaURL.Po \
-@AMDEP_TRUE@	$(DEPDIR)/StoreMetaUnpacker.Po \
-@AMDEP_TRUE@	$(DEPDIR)/StoreMetaVary.Po $(DEPDIR)/String.Po \
-@AMDEP_TRUE@	$(DEPDIR)/SwapDir.Po $(DEPDIR)/access_log.Po \
-@AMDEP_TRUE@	$(DEPDIR)/acl.Po $(DEPDIR)/asn.Po \
-@AMDEP_TRUE@	$(DEPDIR)/auth_modules.Po $(DEPDIR)/authenticate.Po \
-@AMDEP_TRUE@	$(DEPDIR)/cache_cf.Po $(DEPDIR)/cache_manager.Po \
-@AMDEP_TRUE@	$(DEPDIR)/cachemgr.Po $(DEPDIR)/carp.Po \
-@AMDEP_TRUE@	$(DEPDIR)/cbdata.Po $(DEPDIR)/cf_gen.Po \
-@AMDEP_TRUE@	$(DEPDIR)/client.Po $(DEPDIR)/clientStream.Po \
-@AMDEP_TRUE@	$(DEPDIR)/client_db.Po $(DEPDIR)/client_side.Po \
-@AMDEP_TRUE@	$(DEPDIR)/client_side_reply.Po \
-@AMDEP_TRUE@	$(DEPDIR)/client_side_request.Po $(DEPDIR)/comm.Po \
-@AMDEP_TRUE@	$(DEPDIR)/comm_kqueue.Po $(DEPDIR)/comm_poll.Po \
-@AMDEP_TRUE@	$(DEPDIR)/comm_select.Po $(DEPDIR)/debug.Po \
-@AMDEP_TRUE@	$(DEPDIR)/delay_pools.Po $(DEPDIR)/disk.Po \
-@AMDEP_TRUE@	$(DEPDIR)/dns.Po $(DEPDIR)/dns_internal.Po \
-@AMDEP_TRUE@	$(DEPDIR)/dnsserver.Po $(DEPDIR)/errorpage.Po \
-@AMDEP_TRUE@	$(DEPDIR)/event.Po $(DEPDIR)/external_acl.Po \
-@AMDEP_TRUE@	$(DEPDIR)/fd.Po $(DEPDIR)/fde.Po \
-@AMDEP_TRUE@	$(DEPDIR)/filemap.Po $(DEPDIR)/forward.Po \
-@AMDEP_TRUE@	$(DEPDIR)/fqdncache.Po $(DEPDIR)/ftp.Po \
-@AMDEP_TRUE@	$(DEPDIR)/globals.Po $(DEPDIR)/gopher.Po \
-@AMDEP_TRUE@	$(DEPDIR)/helper.Po $(DEPDIR)/htcp.Po \
-@AMDEP_TRUE@	$(DEPDIR)/http.Po $(DEPDIR)/icmp.Po \
-@AMDEP_TRUE@	$(DEPDIR)/icp_v2.Po $(DEPDIR)/icp_v3.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ident.Po $(DEPDIR)/int.Po \
-@AMDEP_TRUE@	$(DEPDIR)/internal.Po $(DEPDIR)/ipc.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ipcache.Po $(DEPDIR)/leakfinder.Po \
-@AMDEP_TRUE@	$(DEPDIR)/logfile.Po $(DEPDIR)/main.Po \
-@AMDEP_TRUE@	$(DEPDIR)/mem.Po $(DEPDIR)/mem_node.Po \
-@AMDEP_TRUE@	$(DEPDIR)/mime.Po $(DEPDIR)/multicast.Po \
-@AMDEP_TRUE@	$(DEPDIR)/neighbors.Po $(DEPDIR)/net_db.Po \
-@AMDEP_TRUE@	$(DEPDIR)/pconn.Po $(DEPDIR)/peer_digest.Po \
-@AMDEP_TRUE@	$(DEPDIR)/peer_select.Po $(DEPDIR)/pinger.Po \
-@AMDEP_TRUE@	$(DEPDIR)/recv-announce.Po $(DEPDIR)/redirect.Po \
-@AMDEP_TRUE@	$(DEPDIR)/referer.Po $(DEPDIR)/refresh.Po \
-@AMDEP_TRUE@	$(DEPDIR)/repl_modules.Po \
-@AMDEP_TRUE@	$(DEPDIR)/send-announce.Po $(DEPDIR)/snmp_agent.Po \
-@AMDEP_TRUE@	$(DEPDIR)/snmp_core.Po $(DEPDIR)/ssl_support.Po \
-@AMDEP_TRUE@	$(DEPDIR)/stat.Po $(DEPDIR)/stmem.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store.Po $(DEPDIR)/store_client.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_digest.Po $(DEPDIR)/store_dir.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_io.Po $(DEPDIR)/store_key_md5.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_log.Po $(DEPDIR)/store_modules.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_rebuild.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_swapin.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_swapmeta.Po \
-@AMDEP_TRUE@	$(DEPDIR)/store_swapout.Po \
-@AMDEP_TRUE@	$(DEPDIR)/string_arrays.Po $(DEPDIR)/tools.Po \
-@AMDEP_TRUE@	$(DEPDIR)/tunnel.Po $(DEPDIR)/ufscommon.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ufsdump.Po $(DEPDIR)/unlinkd-unlinkd.Po \
-@AMDEP_TRUE@	$(DEPDIR)/unlinkd.Po $(DEPDIR)/url.Po \
-@AMDEP_TRUE@	$(DEPDIR)/urn.Po $(DEPDIR)/useragent.Po \
-@AMDEP_TRUE@	$(DEPDIR)/wais.Po $(DEPDIR)/wccp.Po \
-@AMDEP_TRUE@	$(DEPDIR)/whois.Po $(DEPDIR)/win32.Po
+am__depfiles_maybe = depfiles
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/ACLARP.Po ./$(DEPDIR)/ACLASN.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLBrowser.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLCertificate.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLCertificateData.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLChecklist.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLDestinationDomain.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLDestinationIP.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLDomainData.Po ./$(DEPDIR)/ACLIP.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLIdent.Po ./$(DEPDIR)/ACLIntRange.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLMaxConnection.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLMaxUserIP.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLMethod.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLMethodData.Po ./$(DEPDIR)/ACLMyIP.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLMyPort.Po ./$(DEPDIR)/ACLProtocol.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLProtocolData.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLProxyAuth.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLReferer.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLRegexData.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLReplyMIMEType.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLRequestMIMEType.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLSourceDomain.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLSourceIP.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLStrategised.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLStringData.Po ./$(DEPDIR)/ACLTime.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLTimeData.Po ./$(DEPDIR)/ACLUrl.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLUrlPath.Po ./$(DEPDIR)/ACLUrlPort.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ACLUserData.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/CacheDigest.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/DelayBucket.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/DelayConfig.Po ./$(DEPDIR)/DelayId.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/DelayPool.Po ./$(DEPDIR)/DelaySpec.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/DelayUser.Po ./$(DEPDIR)/DelayVector.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ETag.Po ./$(DEPDIR)/HttpBody.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpHdrCc.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpHdrContRange.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpHdrRange.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpHeader.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpHeaderTools.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpMsg.Po ./$(DEPDIR)/HttpReply.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpRequest.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/HttpStatusLine.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/IPInterception.Po ./$(DEPDIR)/MemBuf.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/MemObject.Po ./$(DEPDIR)/NullDelayId.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/Packer.Po ./$(DEPDIR)/ProfStats.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StatHist.Po ./$(DEPDIR)/StoreIOState.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StoreMeta.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StoreMetaMD5.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StoreMetaSTD.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StoreMetaURL.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StoreMetaUnpacker.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/StoreMetaVary.Po ./$(DEPDIR)/String.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/SwapDir.Po ./$(DEPDIR)/access_log.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/acl.Po ./$(DEPDIR)/asn.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/auth_modules.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/authenticate.Po ./$(DEPDIR)/cache_cf.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/cache_manager.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/cachemgr.Po ./$(DEPDIR)/carp.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/cbdata.Po ./$(DEPDIR)/cf_gen.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/client.Po ./$(DEPDIR)/clientStream.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/client_db.Po ./$(DEPDIR)/client_side.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/client_side_reply.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/client_side_request.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/comm.Po ./$(DEPDIR)/comm_kqueue.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/comm_poll.Po ./$(DEPDIR)/comm_select.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/debug.Po ./$(DEPDIR)/delay_pools.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/disk.Po ./$(DEPDIR)/dns.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/dns_internal.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/dnsserver.Po ./$(DEPDIR)/errorpage.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/event.Po ./$(DEPDIR)/external_acl.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/fd.Po ./$(DEPDIR)/fde.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/filemap.Po ./$(DEPDIR)/forward.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/fqdncache.Po ./$(DEPDIR)/ftp.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/globals.Po ./$(DEPDIR)/gopher.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/helper.Po ./$(DEPDIR)/htcp.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/http.Po ./$(DEPDIR)/icmp.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/icp_v2.Po ./$(DEPDIR)/icp_v3.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ident.Po ./$(DEPDIR)/int.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/internal.Po ./$(DEPDIR)/ipc.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ipcache.Po ./$(DEPDIR)/leakfinder.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/logfile.Po ./$(DEPDIR)/main.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/mem.Po ./$(DEPDIR)/mem_node.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/mime.Po ./$(DEPDIR)/multicast.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/neighbors.Po ./$(DEPDIR)/net_db.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/pconn.Po ./$(DEPDIR)/peer_digest.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/peer_select.Po ./$(DEPDIR)/pinger.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/recv-announce.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/redirect.Po ./$(DEPDIR)/referer.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/refresh.Po ./$(DEPDIR)/repl_modules.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/send-announce.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/snmp_agent.Po ./$(DEPDIR)/snmp_core.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ssl_support.Po ./$(DEPDIR)/stat.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/stmem.Po ./$(DEPDIR)/store.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_client.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_digest.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_dir.Po ./$(DEPDIR)/store_io.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_key_md5.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_log.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_modules.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_rebuild.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_swapin.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_swapmeta.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/store_swapout.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/string_arrays.Po ./$(DEPDIR)/tools.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/tunnel.Po ./$(DEPDIR)/ufscommon.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/ufsdump.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/unlinkd-unlinkd.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/unlinkd.Po ./$(DEPDIR)/url.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/urn.Po ./$(DEPDIR)/useragent.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/wais.Po ./$(DEPDIR)/wccp.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/whois.Po ./$(DEPDIR)/win32.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
@@ -1156,171 +1220,184 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLBrowser.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLCertificate.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLCertificateData.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLChecklist.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLDestinationDomain.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLDestinationIP.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLDomainData.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLIP.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLIdent.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLMyIP.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLProxyAuth.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLReferer.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLRegexData.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLRequestMIMEType.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLSourceDomain.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLSourceIP.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLStrategised.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLTime.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLTimeData.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLUrl.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLUrlPath.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ACLUserData.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/CacheDigest.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelayBucket.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelayConfig.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelayId.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelayPool.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelaySpec.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelayUser.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/DelayVector.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ETag.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpBody.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpHdrCc.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpHdrContRange.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpHdrRange.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpHeader.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpHeaderTools.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpMsg.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpReply.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpRequest.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/HttpStatusLine.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/IPInterception.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/MemBuf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/MemObject.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/NullDelayId.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/Packer.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ProfStats.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StatHist.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreIOState.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreMeta.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreMetaMD5.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreMetaSTD.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreMetaURL.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreMetaUnpacker.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StoreMetaVary.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/String.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/SwapDir.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/access_log.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/acl.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/asn.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/auth_modules.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/authenticate.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/cache_cf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/cache_manager.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/cachemgr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/carp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/cbdata.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/cf_gen.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/client.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/clientStream.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/client_db.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/client_side.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/client_side_reply.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/client_side_request.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/comm.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/comm_kqueue.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/comm_poll.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/comm_select.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/debug.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/delay_pools.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/disk.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/dns.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/dns_internal.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/dnsserver.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/errorpage.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/event.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/external_acl.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/fd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/fde.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/filemap.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/forward.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/fqdncache.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ftp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/globals.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/gopher.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/helper.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/htcp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/http.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/icmp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/icp_v2.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/icp_v3.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ident.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/int.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/internal.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ipc.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ipcache.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/leakfinder.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/logfile.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/main.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/mem.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/mem_node.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/mime.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/multicast.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/neighbors.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/net_db.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/pconn.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/peer_digest.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/peer_select.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/pinger.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/recv-announce.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/redirect.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/referer.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/refresh.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/repl_modules.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/send-announce.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/snmp_agent.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/snmp_core.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ssl_support.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/stat.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/stmem.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_client.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_digest.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_dir.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_io.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_key_md5.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_log.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_modules.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_rebuild.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_swapin.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_swapmeta.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/store_swapout.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/string_arrays.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/tools.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/tunnel.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ufscommon.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ufsdump.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/unlinkd-unlinkd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/unlinkd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/url.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/urn.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/useragent.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/wais.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/wccp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/whois.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/win32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLARP.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLASN.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLBrowser.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLCertificate.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLCertificateData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLChecklist.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLDestinationDomain.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLDestinationIP.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLDomainData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLIP.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLIdent.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLIntRange.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLMaxConnection.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLMaxUserIP.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLMethod.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLMethodData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLMyIP.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLMyPort.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLProtocol.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLProtocolData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLProxyAuth.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLReferer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLRegexData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLReplyMIMEType.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLRequestMIMEType.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLSourceDomain.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLSourceIP.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLStrategised.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLStringData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLTime.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLTimeData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLUrl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLUrlPath.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLUrlPort.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ACLUserData.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/CacheDigest.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelayBucket.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelayConfig.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelayId.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelayPool.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelaySpec.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelayUser.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DelayVector.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ETag.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpBody.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrCc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrContRange.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrRange.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHeader.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHeaderTools.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpMsg.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpReply.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpRequest.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpStatusLine.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/IPInterception.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MemBuf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MemObject.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/NullDelayId.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Packer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ProfStats.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StatHist.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreIOState.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreMeta.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreMetaMD5.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreMetaSTD.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreMetaURL.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreMetaUnpacker.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StoreMetaVary.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/String.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SwapDir.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/access_log.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/acl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/auth_modules.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/authenticate.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cache_cf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cache_manager.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cachemgr.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/carp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cbdata.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cf_gen.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/clientStream.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client_db.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client_side.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client_side_reply.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client_side_request.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/comm.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/comm_kqueue.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/comm_poll.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/comm_select.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/debug.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/delay_pools.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/disk.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dns.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dns_internal.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dnsserver.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/errorpage.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/event.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/external_acl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fde.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filemap.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/forward.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fqdncache.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ftp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/globals.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gopher.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/helper.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/htcp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/http.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icmp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icp_v2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icp_v3.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ident.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/int.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/internal.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipcache.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/leakfinder.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/logfile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mem.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mem_node.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mime.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/multicast.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/neighbors.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/net_db.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pconn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/peer_digest.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/peer_select.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pinger.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/recv-announce.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/redirect.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/referer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/refresh.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/repl_modules.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/send-announce.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_agent.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_core.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ssl_support.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stat.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stmem.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_digest.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_dir.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_io.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_key_md5.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_log.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_modules.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_rebuild.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_swapin.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_swapmeta.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/store_swapout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/string_arrays.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tools.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tunnel.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ufscommon.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ufsdump.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlinkd-unlinkd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlinkd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/url.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/urn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/useragent.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wais.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wccp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/whois.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32.Po@am__quote@
 
 distclean-depend:
-	-rm -rf $(DEPDIR)
+	-rm -rf ./$(DEPDIR)
 
 .c.o:
 @AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
 @AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-	$(COMPILE) -c `test -f $< || echo '$(srcdir)/'`$<
+	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
 
 .c.obj:
 @AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -1,5 +1,5 @@
 /*
- * $Id: acl.cc,v 1.305 2003/02/21 22:50:06 robertc Exp $
+ * $Id: acl.cc,v 1.306 2003/02/25 12:24:33 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -35,196 +35,21 @@
 #include "squid.h"
 #include "ACL.h"
 #include "ACLChecklist.h"
-#include "splay.h"
 #include "HttpRequest.h"
-#include "authenticate.h"
-#include "fde.h"
-#include "ExternalACL.h"
-#include "ACLDestinationIP.h"
-
-static void aclParseIntlist(void *curlist);
-#if SQUID_SNMP
-static void aclParseWordList(void *curlist);
-#endif
-static void aclParseProtoList(void *curlist);
-static void aclParseMethodList(void *curlist);
-static void aclParseIntRange(void *curlist);
-static void aclDestroyIntRange(intrange *);
-static int aclMatchIntegerRange(intrange * data, int i);
-#if SQUID_SNMP
-static int aclMatchWordList(wordlist *, const char *);
-#endif
-static void aclParseUserMaxIP(void *data);
-static void aclDestroyUserMaxIP(void *data);
-static wordlist *aclDumpUserMaxIP(void *data);
-
-static int aclMatchUserMaxIP(void *, auth_user_request_t *, struct in_addr);
-static squid_acl aclStrToType(const char *s);
-static wordlist *aclDumpIntlistList(intlist * data);
-static wordlist *aclDumpIntRangeList(intrange * data);
-static wordlist *aclDumpProtoList(intlist * data);
-static wordlist *aclDumpMethodList(intlist * data);
-
-
-#if USE_ARP_ACL
-static void aclParseArpList(void *curlist);
-static int decode_eth(const char *asc, char *eth);
-
-static int aclMatchArp(void *dataptr, struct in_addr c);
-static wordlist *aclDumpArpList(void *);
-static splayNode::SPLAYCMP aclArpCompare;
-static splayNode::SPLAYWALKEE aclDumpArpListWalkee;
-#endif
 
-MemPool *ACL::Pool(NULL);
+const char *AclMatchedName = NULL;
+
 void *
 ACL::operator new (size_t byteCount)
 {
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ACL));
-
-    if (!Pool)
-        Pool = memPoolCreate("ACL", sizeof (ACL));
-
-    return memPoolAlloc(Pool);
+    fatal ("unusable ACL::new");
+    return (void *)1;
 }
 
 void
 ACL::operator delete (void *address)
 {
-    memPoolFree (Pool, address);
-}
-
-void
-ACL::deleteSelf() const
-{
-    delete this;
-}
-
-template<class T>
-inline void
-xRefFree(T &thing)
-{
-    xfree (thing);
-}
-
-template<class T>
-inline int
-splaystrcmp (T&l, T&r)
-{
-    return strcmp ((char *)l,(char *)r);
-}
-
-
-static squid_acl
-aclStrToType(const char *s)
-{
-    if (!strcmp(s, "port"))
-        return ACL_URL_PORT;
-
-    if (!strcmp(s, "myport"))
-        return ACL_MY_PORT;
-
-    if (!strcmp(s, "maxconn"))
-        return ACL_MAXCONN;
-
-    if (!strncmp(s, "proto", 5))
-        return ACL_PROTO;
-
-    if (!strcmp(s, "method"))
-        return ACL_METHOD;
-
-    if (!strcmp(s, "src_as"))
-        return ACL_SRC_ASN;
-
-    if (!strcmp(s, "dst_as"))
-        return ACL_DST_ASN;
-
-#if SQUID_SNMP
-
-    if (!strcmp(s, "snmp_community"))
-        return ACL_SNMP_COMMUNITY;
-
-#endif
-#if SRC_RTT_NOT_YET_FINISHED
-
-    if (!strcmp(s, "src_rtt"))
-        return ACL_NETDB_SRC_RTT;
-
-#endif
-#if USE_ARP_ACL
-
-    if (!strcmp(s, "arp"))
-        return ACL_SRC_ARP;
-
-#endif
-
-    if (!strcmp(s, "rep_mime_type"))
-        return ACL_REP_MIME_TYPE;
-
-    if (!strcmp(s, "max_user_ip"))
-        return ACL_MAX_USER_IP;
-
-    if (!strcmp(s, "external"))
-        return ACL_EXTERNAL;
-
-    return ACL_NONE;
-}
-
-static const char *aclTypeToStr(squid_acl);
-const char *
-aclTypeToStr(squid_acl type)
-{
-    if (type == ACL_URL_PORT)
-        return "port";
-
-    if (type == ACL_MY_PORT)
-        return "myport";
-
-    if (type == ACL_MAXCONN)
-        return "maxconn";
-
-    if (type == ACL_PROTO)
-        return "proto";
-
-    if (type == ACL_METHOD)
-        return "method";
-
-    if (type == ACL_SRC_ASN)
-        return "src_as";
-
-    if (type == ACL_DST_ASN)
-        return "dst_as";
-
-#if SQUID_SNMP
-
-    if (type == ACL_SNMP_COMMUNITY)
-        return "snmp_community";
-
-#endif
-#if SRC_RTT_NOT_YET_FINISHED
-
-    if (type == ACL_NETDB_SRC_RTT)
-        return "src_rtt";
-
-#endif
-#if USE_ARP_ACL
-
-    if (type == ACL_SRC_ARP)
-        return "arp";
-
-#endif
-
-    if (type == ACL_REP_MIME_TYPE)
-        return "rep_mime_type";
-
-    if (type == ACL_MAX_USER_IP)
-        return "max_user_ip";
-
-    if (type == ACL_EXTERNAL)
-        return "external";
-
-    return "ERROR";
+    fatal ("unusable ACL::delete");
 }
 
 acl *
@@ -239,210 +64,18 @@ ACL::FindByName(const char *name)
     return NULL;
 }
 
-static void
-aclParseIntlist(void *curlist)
-{
-    intlist **Tail;
-    intlist *q = NULL;
-    char *t = NULL;
-
-    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next))
-
-        ;
-    while ((t = strtokFile())) {
-        q = (intlist *)memAllocate(MEM_INTLIST);
-        q->i = atoi(t);
-        *(Tail) = q;
-        Tail = &q->next;
-    }
-}
-
-static void
-aclParseIntRange(void *curlist)
-{
-    intrange **Tail;
-    intrange *q = NULL;
-    char *t = NULL;
-
-    for (Tail = (intrange **)curlist; *Tail; Tail = &((*Tail)->next))
-
-        ;
-    while ((t = strtokFile())) {
-        q = (intrange *)xcalloc(1, sizeof(intrange));
-        q->i = atoi(t);
-        t = strchr(t, '-');
-
-        if (t && *(++t))
-            q->j = atoi(t);
-        else
-            q->j = q->i;
-
-        *(Tail) = q;
-
-        Tail = &q->next;
-    }
-}
-
-static void
-aclParseProtoList(void *curlist)
-{
-    intlist **Tail;
-    intlist *q = NULL;
-    char *t = NULL;
-    protocol_t protocol;
-
-    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next))
-
-        ;
-    while ((t = strtokFile())) {
-        protocol = urlParseProtocol(t);
-        q = (intlist *)memAllocate(MEM_INTLIST);
-        q->i = (int) protocol;
-        *(Tail) = q;
-        Tail = &q->next;
-    }
-}
-
-static void
-aclParseMethodList(void *curlist)
-{
-    intlist **Tail;
-    intlist *q = NULL;
-    char *t = NULL;
-
-    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next))
-
-        ;
-    while ((t = strtokFile())) {
-        q = (intlist *)memAllocate(MEM_INTLIST);
-        q->i = (int) urlParseMethod(t);
-        *(Tail) = q;
-        Tail = &q->next;
-    }
-}
-
-void
-aclParseRegexList(void *curlist)
-{
-    relist **Tail;
-    relist *q = NULL;
-    char *t = NULL;
-    regex_t comp;
-    int errcode;
-    int flags = REG_EXTENDED | REG_NOSUB;
-
-    for (Tail = (relist **)curlist; *Tail; Tail = &((*Tail)->next))
-
-        ;
-    while ((t = strtokFile())) {
-        if (strcmp(t, "-i") == 0) {
-            flags |= REG_ICASE;
-            continue;
-        }
-
-        if (strcmp(t, "+i") == 0) {
-            flags &= ~REG_ICASE;
-            continue;
-        }
-
-        if ((errcode = regcomp(&comp, t, flags)) != 0) {
-            char errbuf[256];
-            regerror(errcode, &comp, errbuf, sizeof errbuf);
-            debug(28, 0) ("%s line %d: %s\n",
-                          cfg_filename, config_lineno, config_input_line);
-            debug(28, 0) ("aclParseRegexList: Invalid regular expression '%s': %s\n",
-                          t, errbuf);
-            continue;
-        }
-
-        q = (relist *)memAllocate(MEM_RELIST);
-        q->pattern = xstrdup(t);
-        q->regex = comp;
-        *(Tail) = q;
-        Tail = &q->next;
-    }
-}
-
-#if SQUID_SNMP
-static void
-aclParseWordList(void *curlist)
-{
-    char *t = NULL;
-
-    while ((t = strtokFile()))
-        wordlistAdd((wordlist **)curlist, t);
-}
-
-#endif
-
 ACL *
 ACL::Factory (char const *type)
 {
     ACL *result = Prototype::Factory (type);
 
-    if (result)
-        return result;
-
-    squid_acl const acltype = aclStrToType(type);
-
-    switch (acltype) {
-
-    case ACL_URL_PORT:
-
-    case ACL_MY_PORT:
-
-    case ACL_MAXCONN:
-
-    case ACL_PROTO:
-
-    case ACL_METHOD:
-
-    case ACL_SRC_ASN:
-
-    case ACL_DST_ASN:
-#if SQUID_SNMP
-
-    case ACL_SNMP_COMMUNITY:
-#endif
-#if SRC_RTT_NOT_YET_FINISHED
-
-    case ACL_NETDB_SRC_RTT:
-#endif
-#if USE_ARP_ACL
-
-    case ACL_SRC_ARP:
-#endif
-
-    case ACL_REP_MIME_TYPE:
-
-    case ACL_MAX_USER_IP:
-
-    case ACL_EXTERNAL:
-        result = new ACL(acltype);
-        break;
-
-    case ACL_DERIVED:
-
-    default:
+    if (!result)
         fatal ("Unknown acl type in ACL::Factory");
-    };
-
-    assert (result);
 
     return result;
 }
 
-ACL::ACL (squid_acl const acltype) : type (acltype)
-{}
-
-ACL::ACL () : type(ACL_NONE)
-{}
-
-char const *
-ACL::typeString() const
-{
-    return aclTypeToStr(aclType());
-}
+ACL::ACL () {}
 
 void
 ACL::ParseAclLine(acl ** head)
@@ -451,7 +84,6 @@ ACL::ParseAclLine(acl ** head)
     char *t = NULL;
     acl *A = NULL;
     LOCAL_ARRAY(char, aclname, ACL_NAME_SZ);
-    squid_acl acltype;
     int new_acl = 0;
 
     /* snarf the ACL name */
@@ -465,31 +97,30 @@ ACL::ParseAclLine(acl ** head)
 
     xstrncpy(aclname, t, ACL_NAME_SZ);
     /* snarf the ACL type */
+    char *theType;
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((theType = strtok(NULL, w_space)) == NULL) {
         debug(28, 0) ("%s line %d: %s\n",
                       cfg_filename, config_lineno, config_input_line);
         debug(28, 0) ("aclParseAclLine: missing ACL type.\n");
         return;
     }
 
-    if ((acltype = aclStrToType(t)) == ACL_NONE && !Prototype::Registered (t)) {
+    if (!Prototype::Registered (theType)) {
         debug(28, 0) ("%s line %d: %s\n",
                       cfg_filename, config_lineno, config_input_line);
-        debug(28, 0) ("aclParseAclLine: Invalid ACL type '%s'\n", t);
+        debug(28, 0) ("aclParseAclLine: Invalid ACL type '%s'\n", theType);
         return;
     }
 
     if ((A = FindByName(aclname)) == NULL) {
         debug(28, 3) ("aclParseAclLine: Creating ACL '%s'\n", aclname);
-        A = ACL::Factory(t);
+        A = ACL::Factory(theType);
         xstrncpy(A->name, aclname, ACL_NAME_SZ);
         A->cfgline = xstrdup(config_input_line);
         new_acl = 1;
     } else {
-        /* FIXME: strcmp the registry typeString */
-
-        if (acltype != ACL_NONE && acltype != A->aclType()) {
+        if (strcmp (A->typeString(),theType) ) {
             debug(28, 0) ("aclParseAclLine: ACL '%s' already exists with different type, skipping.\n", A->name);
             return;
         }
@@ -531,81 +162,6 @@ ACL::ParseAclLine(acl ** head)
     *head = A;
 }
 
-bool
-ACL::valid () const
-{
-    return data != NULL;
-}
-
-void
-ACL::parse()
-{
-    switch (aclType()) {
-
-    case ACL_REP_MIME_TYPE:
-        aclParseRegexList(&data);
-        break;
-
-    case ACL_SRC_ASN:
-
-    case ACL_MAXCONN:
-
-    case ACL_DST_ASN:
-        aclParseIntlist(&data);
-        break;
-
-    case ACL_MAX_USER_IP:
-        aclParseUserMaxIP(&data);
-        break;
-#if SRC_RTT_NOT_YET_FINISHED
-
-    case ACL_NETDB_SRC_RTT:
-        aclParseIntlist(&data);
-        break;
-#endif
-
-    case ACL_URL_PORT:
-
-    case ACL_MY_PORT:
-        aclParseIntRange(&data);
-        break;
-
-    case ACL_PROTO:
-        aclParseProtoList(&data);
-        break;
-
-    case ACL_METHOD:
-        aclParseMethodList(&data);
-        break;
-
-    case ACL_DERIVED:
-        fatal ("overriden");
-        break;
-#if SQUID_SNMP
-
-    case ACL_SNMP_COMMUNITY:
-        aclParseWordList(&data);
-        break;
-#endif
-#if USE_ARP_ACL
-
-    case ACL_SRC_ARP:
-        aclParseArpList(&data);
-        break;
-#endif
-
-    case ACL_EXTERNAL:
-        aclParseExternal(&data);
-        break;
-
-    case ACL_NONE:
-
-    case ACL_ENUM_MAX:
-        fatal("Bad ACL type");
-        break;
-    }
-}
-
 /* does name lookup, returns page_id */
 err_type
 aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name)
@@ -813,42 +369,6 @@ aclParseAclList(acl_list ** head)
     }
 }
 
-int
-aclMatchRegex(relist * data, const char *word)
-{
-    relist *first, *prev;
-
-    if (word == NULL)
-        return 0;
-
-    debug(28, 3) ("aclMatchRegex: checking '%s'\n", word);
-
-    first = data;
-
-    prev = NULL;
-
-    while (data) {
-        debug(28, 3) ("aclMatchRegex: looking for '%s'\n", data->pattern);
-
-        if (regexec(&data->regex, word, 0, 0, 0) == 0) {
-            if (prev != NULL) {
-                /* shift the element just found to the second position
-                 * in the list */
-                prev->next = data->next;
-                data->next = first->next;
-                first->next = data;
-            }
-
-            return 1;
-        }
-
-        prev = data;
-        data = data->next;
-    }
-
-    return 0;
-}
-
 /* ACL result caching routines */
 
 int
@@ -910,384 +430,70 @@ aclCacheMatchFlush(dlink_list * cache)
     }
 }
 
+bool
+ACL::requiresReply() const
+{
+    return false;
+}
 
-CBDATA_TYPE(acl_user_ip_data);
-
-void
-aclParseUserMaxIP(void *data)
+bool
+ACL::requiresRequest() const
 {
-    acl_user_ip_data **acldata = (acl_user_ip_data **)data;
-    char *t = NULL;
-    CBDATA_INIT_TYPE(acl_user_ip_data);
+    return false;
+}
 
-    if (*acldata) {
-        debug(28, 1) ("Attempting to alter already set User max IP acl\n");
-        return;
+int
+ACL::checklistMatches(ACLChecklist *checklist)
+{
+    if (NULL == checklist->request && requiresRequest()) {
+        debug(28, 1) ("WARNING: '%s' ACL is used but there is no"
+                      " HTTP request -- not matching.\n", name);
+        return 0;
     }
 
-    *acldata = cbdataAlloc(acl_user_ip_data);
-    t = strtokFile();
-
-    if (!t)
-        goto error;
-
-    debug(28, 5) ("aclParseUserMaxIP: First token is %s\n", t);
-
-    if (strcmp("-s", t) == 0) {
-        debug(28, 5) ("aclParseUserMaxIP: Going strict\n");
-        (*acldata)->flags.strict = 1;
-        t = strtokFile();
-
-        if (!t)
-            goto error;
+    if (NULL == checklist->reply && requiresReply()) {
+        debug(28, 1) ("WARNING: '%s' ACL is used but there is no"
+                      " HTTP reply -- not matching.\n", name);
+        return 0;
     }
 
-    (*acldata)->max = atoi(t);
-    debug(28, 5) ("aclParseUserMaxIP: Max IP address's %d\n", (int) (*acldata)->max);
-    return;
-
-error:
-    fatal("aclParseUserMaxIP: Malformed ACL %d\n");
+    debug(28, 3) ("aclMatchAcl: checking '%s'\n", cfgline);
+    return match(checklist);
 }
 
-void
-aclDestroyUserMaxIP(void *data)
+bool
+ACLList::matches (ACLChecklist *checklist) const
 {
-    acl_user_ip_data **acldata = (acl_user_ip_data **)data;
+    assert (_acl);
+    AclMatchedName = _acl->name;
+    debug(28, 3) ("ACLList::matches: checking %s%s\n",
+                  op ? null_string : "!", _acl->name);
 
-    if (*acldata)
-        cbdataFree(*acldata);
+    if (_acl->checklistMatches(checklist) != op) {
+        return false;
+    }
 
-    *acldata = NULL;
+    return true;
 }
 
-wordlist *
-aclDumpUserMaxIP(void *data)
+/* Warning: do not cbdata lock checklist here - it
+ * may be static or on the stack
+ */
+int
+aclCheckFast(const acl_access * A, ACLChecklist * checklist)
 {
-    acl_user_ip_data *acldata = (acl_user_ip_data *)data;
-    wordlist *W = NULL;
-    char buf[128];
-
-    if (acldata->flags.strict)
-        wordlistAdd(&W, "-s");
+    allow_t allow = ACCESS_DENIED;
+    PROF_start(aclCheckFast);
+    debug(28, 5) ("aclCheckFast: list: %p\n", A);
 
-    snprintf(buf, sizeof(buf), "%lu", (unsigned long int) acldata->max);
+    while (A) {
+        allow = A->allow;
+        checklist->matchAclList(A->aclList, true);
 
-    wordlistAdd(&W, buf);
-
-    return W;
-}
-
-/*
- * aclMatchUserMaxIP - check for users logging in from multiple IP's 
- * 0 : No match
- * 1 : Match 
- */
-int
-aclMatchUserMaxIP(void *data, auth_user_request_t * auth_user_request,
-
-                  struct in_addr src_addr)
-{
-    /*
-     * the logic for flush the ip list when the limit is hit vs keep
-     * it sorted in most recent access order and just drop the oldest
-     * one off is currently undecided
-     */
-    acl_user_ip_data *acldata = (acl_user_ip_data *)data;
-
-    if (authenticateAuthUserRequestIPCount(auth_user_request) <= acldata->max)
-        return 0;
-
-    /* this is a match */
-    if (acldata->flags.strict)
-    {
-        /*
-         * simply deny access - the user name is already associated with
-         * the request 
-         */
-        /* remove _this_ ip, as it is the culprit for going over the limit */
-        authenticateAuthUserRequestRemoveIp(auth_user_request, src_addr);
-        debug(28, 4) ("aclMatchUserMaxIP: Denying access in strict mode\n");
-    } else
-    {
-        /*
-         * non-strict - remove some/all of the cached entries 
-         * ie to allow the user to move machines easily
-         */
-        authenticateAuthUserRequestClearIp(auth_user_request);
-        debug(28, 4) ("aclMatchUserMaxIP: Denying access in non-strict mode - flushing the user ip cache\n");
-    }
-
-    return 1;
-}
-
-static int
-aclMatchInteger(intlist * data, int i)
-{
-    intlist *first, *prev;
-    first = data;
-    prev = NULL;
-
-    while (data) {
-        if (data->i == i) {
-            if (prev != NULL) {
-                /* shift the element just found to the second position
-                 * in the list */
-                prev->next = data->next;
-                data->next = first->next;
-                first->next = data;
-            }
-
-            return 1;
-        }
-
-        prev = data;
-        data = data->next;
-    }
-
-    return 0;
-}
-
-static int
-aclMatchIntegerRange(intrange * data, int i)
-{
-    intrange *first, *prev;
-    first = data;
-    prev = NULL;
-
-    while (data) {
-        if (i < data->i) {
-            (void) 0;
-        } else if (i > data->j) {
-            (void) 0;
-        } else {
-            /* matched */
-
-            if (prev != NULL) {
-                /* shift the element just found to the second position
-                 * in the list */
-                prev->next = data->next;
-                data->next = first->next;
-                first->next = data;
-            }
-
-            return 1;
-        }
-
-        prev = data;
-        data = data->next;
-    }
-
-    return 0;
-}
-
-#if SQUID_SNMP
-static int
-aclMatchWordList(wordlist * w, const char *word)
-{
-    debug(28, 3) ("aclMatchWordList: looking for '%s'\n", word);
-
-    while (w != NULL) {
-        debug(28, 3) ("aclMatchWordList: checking '%s'\n", w->key);
-
-        if (!strcmp(w->key, word))
-            return 1;
-
-        w = w->next;
-    }
-
-    return 0;
-}
-
-#endif
-
-
-bool
-ACL::requiresRequest() const
-{
-    switch (aclType()) {
-
-    case ACL_DST_ASN:
-
-    case ACL_MAX_USER_IP:
-
-    case ACL_METHOD:
-
-    case ACL_PROTO:
-
-    case ACL_REP_MIME_TYPE:
-
-    case ACL_URL_PORT:
-        /* These ACL types require checklist->request */
-        return true;
-
-    default:
-        return false;
-    }
-}
-
-int
-ACL::checklistMatches(ACLChecklist *checklist)
-{
-    if (NULL == checklist->request && requiresRequest()) {
-        debug(28, 1) ("WARNING: '%s' ACL is used but there is no"
-                      " HTTP request -- access denied.\n", name);
-        return 0;
-    }
-
-    debug(28, 3) ("aclMatchAcl: checking '%s'\n", cfgline);
-    return match(checklist);
-}
-
-int
-ACL::match(ACLChecklist * checklist)
-{
-    request_t *r = checklist->request;
-    const ipcache_addrs *ia = NULL;
-    const char *header;
-    int k, ti;
-
-    switch (aclType()) {
-
-    case ACL_MAXCONN:
-        k = clientdbEstablished(checklist->src_addr, 0);
-        return ((k > ((intlist *) data)->i) ? 1 : 0);
-        /* NOTREACHED */
-
-    case ACL_URL_PORT:
-        return aclMatchIntegerRange((intrange *)data, (int) r->port);
-        /* NOTREACHED */
-
-    case ACL_MY_PORT:
-        return aclMatchIntegerRange((intrange *)data, (int) checklist->my_port);
-        /* NOTREACHED */
-
-    case ACL_PROTO:
-        return aclMatchInteger((intlist *)data, r->protocol);
-        /* NOTREACHED */
-
-    case ACL_METHOD:
-        return aclMatchInteger((intlist *)data, r->method);
-        /* NOTREACHED */
-
-    case ACL_MAX_USER_IP:
-
-        if ((ti = checklist->authenticated()) != 1)
-            return ti;
-
-        ti = aclMatchUserMaxIP(data, checklist->auth_user_request,
-                               checklist->src_addr);
-
-        checklist->auth_user_request = NULL;
-
-        return ti;
-
-        /* NOTREACHED */
-#if SQUID_SNMP
-
-    case ACL_SNMP_COMMUNITY:
-        return aclMatchWordList((wordlist *)data, checklist->snmp_community);
-
-        /* NOTREACHED */
-#endif
-
-    case ACL_SRC_ASN:
-        return asnMatchIp(data, checklist->src_addr);
-
-        /* NOTREACHED */
-
-    case ACL_DST_ASN:
-        ia = ipcache_gethostbyname(r->host, IP_LOOKUP_IF_MISS);
-
-        if (ia) {
-            for (k = 0; k < (int) ia->count; k++) {
-                if (asnMatchIp(data, ia->in_addrs[k]))
-                    return 1;
-            }
-
-            return 0;
-        } else if (checklist->state[ACL_DST_ASN] == ACL_LOOKUP_NONE) {
-            debug(28, 3) ("asnMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
-                          name, r->host);
-            checklist->changeState (DestinationIPLookup::Instance());
-        } else {
-            return asnMatchIp(data, no_addr);
-        }
-
-        return 0;
-        /* NOTREACHED */
-#if USE_ARP_ACL
-
-    case ACL_SRC_ARP:
-        return aclMatchArp(&data, checklist->src_addr);
-        /* NOTREACHED */
-#endif
-
-    case ACL_REP_MIME_TYPE:
-
-        if (!checklist->reply)
-            return 0;
-
-        header = httpHeaderGetStr(&checklist->reply->header, HDR_CONTENT_TYPE);
-
-        if (NULL == header)
-            header = "";
-
-        return aclMatchRegex((relist *)data, header);
-
-        /* NOTREACHED */
-
-    case ACL_EXTERNAL:
-        return aclMatchExternal(data, checklist);
-
-        /* NOTREACHED */
-
-    case ACL_NONE:
-
-    case ACL_ENUM_MAX:
-        break;
-
-    case ACL_DERIVED:
-        fatal ("overridden");
-    }
-
-    debug(28, 0) ("aclMatchAcl: '%s' has bad type %d\n",
-                  name, aclType());
-    return 0;
-}
-
-bool
-ACLList::matches (ACLChecklist *checklist) const
-{
-    assert (_acl);
-    AclMatchedName = _acl->name;
-    debug(28, 3) ("ACLList::matches: checking %s%s\n",
-                  op ? null_string : "!", _acl->name);
-
-    if (_acl->checklistMatches(checklist) != op) {
-        return false;
-    }
-
-    return true;
-}
-
-/* Warning: do not cbdata lock checklist here - it
- * may be static or on the stack
- */
-int
-aclCheckFast(const acl_access * A, ACLChecklist * checklist)
-{
-    allow_t allow = ACCESS_DENIED;
-    PROF_start(aclCheckFast);
-    debug(28, 5) ("aclCheckFast: list: %p\n", A);
-
-    while (A) {
-        allow = A->allow;
-
-        if (checklist->matchAclList(A->aclList, true)) {
-            PROF_stop(aclCheckFast);
-            return allow == ACCESS_ALLOWED;
-        }
+        if (checklist->finished()) {
+            PROF_stop(aclCheckFast);
+            return allow == ACCESS_ALLOWED;
+        }
 
         A = A->next;
     }
@@ -1319,7 +525,6 @@ aclCheckFast(const acl_access * A, ACLChecklist * checklist)
 ACLChecklist *
 aclChecklistCreate(const acl_access * A, request_t * request, const char *ident)
 {
-    int i;
     ACLChecklist *checklist = new ACLChecklist;
     checklist->accessList = cbdataReference(A);
 
@@ -1330,11 +535,7 @@ aclChecklistCreate(const acl_access * A, request_t * request, const char *ident)
         checklist->my_port = request->my_port;
     }
 
-    for (i = 0; i < ACL_ENUM_MAX; i++)
-        checklist->state[i] = ACL_LOOKUP_NONE;
-
 #if USE_IDENT
-
     if (ident)
         xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
 
@@ -1349,19 +550,6 @@ aclChecklistCreate(const acl_access * A, request_t * request, const char *ident)
 /* Destroy functions */
 /*********************/
 
-void
-aclDestroyRegexList(relist * data)
-{
-    relist *next = NULL;
-
-    for (; data; data = next) {
-        next = data->next;
-        regfree(&data->regex);
-        safe_free(data->pattern);
-        memFree(data, MEM_RELIST);
-    }
-}
-
 void
 aclDestroyAcls(acl ** head)
 {
@@ -1378,64 +566,6 @@ aclDestroyAcls(acl ** head)
 ACL::~ACL()
 {
     debug(28, 3) ("aclDestroyAcls: '%s'\n", cfgline);
-
-    switch (aclType()) {
-#if USE_ARP_ACL
-
-    case ACL_SRC_ARP:
-#endif
-#if SQUID_SNMP
-
-    case ACL_SNMP_COMMUNITY:
-        wordlistDestroy((wordlist **) & data);
-        break;
-#endif
-        /* Destroyed in the children */
-
-    case ACL_DERIVED:
-        break;
-
-    case ACL_REP_MIME_TYPE:
-        aclDestroyRegexList((relist *)data);
-        break;
-
-    case ACL_PROTO:
-
-    case ACL_METHOD:
-
-    case ACL_SRC_ASN:
-
-    case ACL_DST_ASN:
-#if SRC_RTT_NOT_YET_FINISHED
-
-    case ACL_NETDB_SRC_RTT:
-#endif
-
-    case ACL_MAXCONN:
-        intlistDestroy((intlist **) & data);
-        break;
-
-    case ACL_MAX_USER_IP:
-        aclDestroyUserMaxIP(&data);
-        break;
-
-    case ACL_URL_PORT:
-
-    case ACL_MY_PORT:
-        aclDestroyIntRange((intrange *)data);
-        break;
-
-    case ACL_EXTERNAL:
-        aclDestroyExternal(&data);
-        break;
-
-    case ACL_NONE:
-
-    case ACL_ENUM_MAX:
-        debug(28, 1) ("aclDestroyAcls: no case for ACL type %d\n", aclType());
-        break;
-    }
-
     safe_free(cfgline);
 }
 
@@ -1492,166 +622,27 @@ aclDestroyDenyInfoList(acl_deny_info_list ** list)
     *list = NULL;
 }
 
-static void
-aclDestroyIntRange(intrange * list)
-{
-    intrange *w = NULL;
-    intrange *n = NULL;
-
-    for (w = list; w; w = n) {
-        n = w->next;
-        safe_free(w);
-    }
-}
-
-wordlist *
-aclDumpRegexList(relist * data)
-{
-    wordlist *W = NULL;
-
-    while (data != NULL) {
-        wordlistAdd(&W, data->pattern);
-        data = data->next;
-    }
-
-    return W;
-}
-
-static wordlist *
-aclDumpIntlistList(intlist * data)
-{
-    wordlist *W = NULL;
-    char buf[32];
-
-    while (data != NULL) {
-        snprintf(buf, sizeof(buf), "%d", data->i);
-        wordlistAdd(&W, buf);
-        data = data->next;
-    }
-
-    return W;
-}
-
-static wordlist *
-aclDumpIntRangeList(intrange * data)
-{
-    wordlist *W = NULL;
-    char buf[32];
-
-    while (data != NULL) {
-        if (data->i == data->j)
-            snprintf(buf, sizeof(buf), "%d", data->i);
-        else
-            snprintf(buf, sizeof(buf), "%d-%d", data->i, data->j);
-
-        wordlistAdd(&W, buf);
-
-        data = data->next;
-    }
-
-    return W;
-}
-
-static wordlist *
-aclDumpProtoList(intlist * data)
-{
-    wordlist *W = NULL;
-
-    while (data != NULL) {
-        wordlistAdd(&W, ProtocolStr[data->i]);
-        data = data->next;
-    }
-
-    return W;
-}
-
-static wordlist *
-aclDumpMethodList(intlist * data)
-{
-    wordlist *W = NULL;
-
-    while (data != NULL) {
-        wordlistAdd(&W, RequestMethodStr[data->i]);
-        data = data->next;
-    }
-
-    return W;
-}
-
 wordlist *
 ACL::dumpGeneric () const
 {
-    debug(28, 3) ("ACL::dumpGeneric: %s type %d\n", name, aclType());
+    debug(28, 3) ("ACL::dumpGeneric: %s type %s\n", name, typeString());
     return dump();
 }
 
-wordlist *
-ACL::dump() const
-{
-    switch (aclType()) {
-#if SQUID_SNMP
-
-    case ACL_SNMP_COMMUNITY:
-        return wordlistDup((wordlist *)data);
-#endif
-
-    case ACL_DERIVED:
-        fatal ("unused");
-
-    case ACL_REP_MIME_TYPE:
-        return aclDumpRegexList((relist *)data);
-
-    case ACL_SRC_ASN:
-
-    case ACL_MAXCONN:
-
-    case ACL_DST_ASN:
-        return aclDumpIntlistList((intlist *)data);
-
-    case ACL_MAX_USER_IP:
-        return aclDumpUserMaxIP(data);
-
-    case ACL_URL_PORT:
-
-    case ACL_MY_PORT:
-        return aclDumpIntRangeList((intrange *)data);
-
-    case ACL_PROTO:
-        return aclDumpProtoList((intlist *)data);
-
-    case ACL_METHOD:
-        return aclDumpMethodList((intlist *)data);
-#if USE_ARP_ACL
-
-    case ACL_SRC_ARP:
-        return aclDumpArpList(data);
-#endif
-
-    case ACL_EXTERNAL:
-        return aclDumpExternal(data);
-
-    case ACL_NONE:
-
-    case ACL_ENUM_MAX:
-        break;
-    }
-
-    debug(28, 1) ("ACL::dumpGeneric: no case for ACL type %d\n", aclType());
-    return NULL;
-}
-
 /*
  * This function traverses all ACL elements referenced
  * by an access list (presumably 'http_access').   If 
  * it finds a PURGE method ACL, then it returns TRUE,
  * otherwise FALSE.
  */
+/* XXX: refactor this more sensibly. perhaps have the parser detect it ? */
 int
 aclPurgeMethodInUse(acl_access * a)
 {
     return a->containsPURGE();
 }
 
+#include "ACLStrategised.h"
 bool
 acl_access::containsPURGE() const
 {
@@ -1660,446 +651,19 @@ acl_access::containsPURGE() const
 
     for (; a; a = a->next) {
         for (b = a->aclList; b; b = b->next) {
-            if (ACL_METHOD != b->_acl->aclType())
+            ACLStrategised<method_t> *tempAcl = dynamic_cast<ACLStrategised<method_t> *>(b->_acl);
+
+            if (!tempAcl)
                 continue;
 
-            if (b->_acl->containsPURGE())
+            if (tempAcl->match(METHOD_PURGE))
                 return true;
         }
     }
 
     return false;
 }
 
-bool
-ACL::containsPURGE() const
-{
-    if (aclMatchInteger((intlist *)data, METHOD_PURGE))
-        return true;
-
-    return false;
-}
-
-
-#if USE_ARP_ACL
-/* ==== BEGIN ARP ACL SUPPORT ============================================= */
-
-/*
- * From:    dale@server.ctam.bitmcnit.bryansk.su (Dale)
- * To:      wessels@nlanr.net
- * Subject: Another Squid patch... :)
- * Date:    Thu, 04 Dec 1997 19:55:01 +0300
- * ============================================================================
- * 
- * Working on setting up a proper firewall for a network containing some
- * Win'95 computers at our Univ, I've discovered that some smart students
- * avoid the restrictions easily just changing their IP addresses in Win'95
- * Contol Panel... It has been getting boring, so I took Squid-1.1.18
- * sources and added a new acl type for hard-wired access control:
- * 
- * acl <name> arp <Ethernet address> ...
- * 
- * For example,
- * 
- * acl students arp 00:00:21:55:ed:22 00:00:21:ff:55:38
- *
- * NOTE: Linux code by David Luyer <luyer@ucs.uwa.edu.au>.
- *       Original (BSD-specific) code no longer works.
- *       Solaris code by R. Gancarz <radekg@solaris.elektrownia-lagisza.com.pl>
- */
-
-#ifdef _SQUID_SOLARIS_
-#include <sys/sockio.h>
-#else
-#include <sys/sysctl.h>
-#endif
-#ifdef _SQUID_LINUX_
-#include <net/if_arp.h>
-#include <sys/ioctl.h>
-#else
-#include <net/if_dl.h>
-#endif
-#include <net/route.h>
-#include <net/if.h>
-#if HAVE_NETINET_IF_ETHER_H
-#include <netinet/if_ether.h>
-#endif
-
-/*
- * Decode an ascii representation (asc) of an ethernet adress, and place
- * it in eth[6].
- */
-static int
-decode_eth(const char *asc, char *eth)
-{
-    int a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, a6 = 0;
-
-    if (sscanf(asc, "%x:%x:%x:%x:%x:%x", &a1, &a2, &a3, &a4, &a5, &a6) != 6) {
-        debug(28, 0) ("decode_eth: Invalid ethernet address '%s'\n", asc);
-        return 0;		/* This is not valid address */
-    }
-
-    eth[0] = (u_char) a1;
-    eth[1] = (u_char) a2;
-    eth[2] = (u_char) a3;
-    eth[3] = (u_char) a4;
-    eth[4] = (u_char) a5;
-    eth[5] = (u_char) a6;
-    return 1;
-}
-
-static acl_arp_data *
-aclParseArpData(const char *t)
-{
-    LOCAL_ARRAY(char, eth, 256);
-    acl_arp_data *q = (acl_arp_data *)xcalloc(1, sizeof(acl_arp_data));
-    debug(28, 5) ("aclParseArpData: %s\n", t);
-
-    if (sscanf(t, "%[0-9a-fA-F:]", eth) != 1) {
-        debug(28, 0) ("aclParseArpData: Bad ethernet address: '%s'\n", t);
-        safe_free(q);
-        return NULL;
-    }
-
-    if (!decode_eth(eth, q->eth)) {
-        debug(28, 0) ("%s line %d: %s\n",
-                      cfg_filename, config_lineno, config_input_line);
-        debug(28, 0) ("aclParseArpData: Ignoring invalid ARP acl entry: can't parse '%s'\n", eth);
-        safe_free(q);
-        return NULL;
-    }
-
-    return q;
-}
-
-
-/*******************/
-/* aclParseArpList */
-/*******************/
-static void
-aclParseArpList(void *curlist)
-{
-    char *t = NULL;
-    splayNode **Top = (splayNode **)curlist;
-    acl_arp_data *q = NULL;
-
-    while ((t = strtokFile())) {
-        if ((q = aclParseArpData(t)) == NULL)
-            continue;
-
-        *Top = splay_insert(q, *Top, aclArpCompare);
-    }
-}
-
-/***************/
-/* aclMatchArp */
-/***************/
-static int
-
-aclMatchArp(void *dataptr, struct in_addr c)
-{
-#if defined(_SQUID_LINUX_)
-
-    struct arpreq arpReq;
-
-    struct sockaddr_in ipAddr;
-
-    unsigned char ifbuffer[sizeof(struct ifreq) * 64];
-
-    struct ifconf ifc;
-
-    struct ifreq *ifr;
-    int offset;
-    splayNode **Top = (splayNode **)dataptr;
-    /*
-     * The linux kernel 2.2 maintains per interface ARP caches and
-     * thus requires an interface name when doing ARP queries.
-     * 
-     * The older 2.0 kernels appear to use a unified ARP cache,
-     * and require an empty interface name
-     * 
-     * To support both, we attempt the lookup with a blank interface
-     * name first. If that does not succeed, the try each interface
-     * in turn
-     */
-    /*
-     * Set up structures for ARP lookup with blank interface name
-     */
-    ipAddr.sin_family = AF_INET;
-    ipAddr.sin_port = 0;
-    ipAddr.sin_addr = c;
-    memset(&arpReq, '\0', sizeof(arpReq));
-
-    xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
-    /* Query ARP table */
-
-    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1)
-    {
-        /* Skip non-ethernet interfaces */
-
-        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
-            return 0;
-        }
-
-        debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
-                      arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
-                      arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
-                      arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
-        /* Do lookup */
-        const void *X = arpReq.arp_ha.sa_data;
-        *Top = splay_splay(&X, *Top, aclArpCompare);
-        debug(28, 3) ("aclMatchArp: '%s' %s\n",
-                      inet_ntoa(c), splayLastResult ? "NOT found" : "found");
-        return (0 == splayLastResult);
-    }
-
-    /* lookup list of interface names */
-    ifc.ifc_len = sizeof(ifbuffer);
-
-    ifc.ifc_buf = (char *)ifbuffer;
-
-    if (ioctl(HttpSockets[0], SIOCGIFCONF, &ifc) < 0)
-    {
-        debug(28, 1) ("Attempt to retrieve interface list failed: %s\n",
-                      xstrerror());
-        return 0;
-    }
-
-    if (ifc.ifc_len > (int)sizeof(ifbuffer))
-    {
-        debug(28, 1) ("Interface list too long - %d\n", ifc.ifc_len);
-        return 0;
-    }
-
-    /* Attempt ARP lookup on each interface */
-    offset = 0;
-
-    while (offset < ifc.ifc_len)
-    {
-
-        ifr = (struct ifreq *) (ifbuffer + offset);
-        offset += sizeof(*ifr);
-        /* Skip loopback and aliased interfaces */
-
-        if (0 == strncmp(ifr->ifr_name, "lo", 2))
-            continue;
-
-        if (NULL != strchr(ifr->ifr_name, ':'))
-            continue;
-
-        debug(28, 4) ("Looking up ARP address for %s on %s\n", inet_ntoa(c),
-                      ifr->ifr_name);
-
-        /* Set up structures for ARP lookup */
-        ipAddr.sin_family = AF_INET;
-
-        ipAddr.sin_port = 0;
-
-        ipAddr.sin_addr = c;
-
-        memset(&arpReq, '\0', sizeof(arpReq));
-
-        xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
-
-        strncpy(arpReq.arp_dev, ifr->ifr_name, sizeof(arpReq.arp_dev) - 1);
-
-        arpReq.arp_dev[sizeof(arpReq.arp_dev) - 1] = '\0';
-
-        /* Query ARP table */
-        if (-1 == ioctl(HttpSockets[0], SIOCGARP, &arpReq)) {
-            /*
-             * Query failed.  Do not log failed lookups or "device
-             * not supported"
-             */
-
-            if (ENXIO == errno)
-                (void) 0;
-            else if (ENODEV == errno)
-                (void) 0;
-            else
-                debug(28, 1) ("ARP query failed: %s: %s\n",
-                              ifr->ifr_name, xstrerror());
-
-            continue;
-        }
-
-        /* Skip non-ethernet interfaces */
-        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER)
-            continue;
-
-        debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x on %s\n",
-                      arpReq.arp_ha.sa_data[0] & 0xff,
-                      arpReq.arp_ha.sa_data[1] & 0xff,
-                      arpReq.arp_ha.sa_data[2] & 0xff,
-                      arpReq.arp_ha.sa_data[3] & 0xff,
-                      arpReq.arp_ha.sa_data[4] & 0xff,
-                      arpReq.arp_ha.sa_data[5] & 0xff, ifr->ifr_name);
-
-        /* Do lookup */
-        const void *X = arpReq.arp_ha.sa_data;
-
-        *Top = splay_splay(&X, *Top, aclArpCompare);
-
-        /* Return if match, otherwise continue to other interfaces */
-        if (0 == splayLastResult) {
-            debug(28, 3) ("aclMatchArp: %s found on %s\n",
-                          inet_ntoa(c), ifr->ifr_name);
-            return 1;
-        }
-
-        /*
-         * Should we stop looking here? Can the same IP address
-         * exist on multiple interfaces?
-         */
-    }
-
-#elif defined(_SQUID_SOLARIS_)
-
-    struct arpreq arpReq;
-
-    struct sockaddr_in ipAddr;
-
-    unsigned char ifbuffer[sizeof(struct ifreq) * 64];
-
-    struct ifconf ifc;
-
-    struct ifreq *ifr;
-
-    int offset;
-
-    splayNode **Top = dataptr;
-
-    /*
-    * Set up structures for ARP lookup with blank interface name
-    */
-    ipAddr.sin_family = AF_INET;
-
-    ipAddr.sin_port = 0;
-
-    ipAddr.sin_addr = c;
-
-    memset(&arpReq, '\0', sizeof(arpReq));
-
-    xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
-
-    /* Query ARP table */
-    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1)
-    {
-        /*
-        *  Solaris (at least 2.6/x86) does not use arp_ha.sa_family -
-        * it returns 00:00:00:00:00:00 for non-ethernet media
-        */
-
-        if (arpReq.arp_ha.sa_data[0] == 0 &&
-                arpReq.arp_ha.sa_data[1] == 0 &&
-                arpReq.arp_ha.sa_data[2] == 0 &&
-                arpReq.arp_ha.sa_data[3] == 0 &&
-                arpReq.arp_ha.sa_data[4] == 0 && arpReq.arp_ha.sa_data[5] == 0)
-            return 0;
-
-        debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
-                      arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
-                      arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
-                      arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
-
-        /* Do lookup */
-        *Top = splay_splay(&arpReq.arp_ha.sa_data, *Top, aclArpCompare);
-
-        debug(28, 3) ("aclMatchArp: '%s' %s\n",
-                      inet_ntoa(c), splayLastResult ? "NOT found" : "found");
-
-        return (0 == splayLastResult);
-    }
-
-#else
-    WRITE ME;
-
-#endif
-    /*
-     * Address was not found on any interface
-     */
-    debug(28, 3) ("aclMatchArp: %s NOT found\n", inet_ntoa(c));
-
-    return 0;
-}
-
-static int
-aclArpCompare(void * const &a, void * const &b)
-{
-    return memcmp(a, b, 6);
-}
-
-#if UNUSED_CODE
-/**********************************************************************
-* This is from the pre-splay-tree code for BSD
-* I suspect the Linux approach will work on most O/S and be much
-* better - <luyer@ucs.uwa.edu.au>
-***********************************************************************
-static int
-checkARP(u_long ip, char *eth)
-{
-    int mib[6] =
-    {CTL_NET, PF_ROUTE, 0, AF_INET, NET_RT_FLAGS, RTF_LLINFO};
-    size_t needed;
-    char *buf, *next, *lim;
-    struct rt_msghdr *rtm;
-    struct sockaddr_inarp *sin;
-    struct sockaddr_dl *sdl;
-    if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
-	debug(28, 0) ("Can't estimate ARP table size!\n");
-	return 0;
-    }
-    if ((buf = xmalloc(needed)) == NULL) {
-	debug(28, 0) ("Can't allocate temporary ARP table!\n");
-	return 0;
-    }
-    if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
-	debug(28, 0) ("Can't retrieve ARP table!\n");
-	xfree(buf);
-	return 0;
-    }
-    lim = buf + needed;
-    for (next = buf; next < lim; next += rtm->rtm_msglen) {
-	rtm = (struct rt_msghdr *) next;
-	sin = (struct sockaddr_inarp *) (rtm + 1);
-	sdl = (struct sockaddr_dl *) (sin + 1);
-	if (sin->sin_addr.s_addr == ip) {
-	    if (sdl->sdl_alen)
-		if (!memcmp(LLADDR(sdl), eth, 6)) {
-		    xfree(buf);
-		    return 1;
-		}
-	    break;
-	}
-    }
-    xfree(buf);
-    return 0;
-}
-**********************************************************************/
-#endif
-
-static void
-aclDumpArpListWalkee(void * const &node, void *state)
-{
-    acl_arp_data *arp = (acl_arp_data *)node;
-    static char buf[24];
-    snprintf(buf, sizeof(buf), "%02x:%02x:%02x:%02x:%02x:%02x",
-             arp->eth[0], arp->eth[1], arp->eth[2], arp->eth[3],
-             arp->eth[4], arp->eth[5]);
-    wordlistAdd((wordlist **)state, buf);
-}
-
-static wordlist *
-aclDumpArpList(void *data)
-{
-    wordlist *w = NULL;
-    splay_walk((splayNode *)data, aclDumpArpListWalkee, &w);
-    return w;
-}
-
-/* ==== END ARP ACL SUPPORT =============================================== */
-#endif /* USE_ARP_ACL */
-
 /* to be split into separate files in the future */
 
 MemPool *ACLList::Pool(NULL);
@@ -2127,7 +691,6 @@ ACLList::deleteSelf() const
     delete this;
 }
 
-
 CBDATA_CLASS_INIT(acl_access);
 
 void *
@@ -2202,9 +765,14 @@ ACL::Prototype::Factory (char const *typeToClone)
     return NULL;
 }
 
-ACL *
-ACL::clone()const
+void
+ACL::Initialize()
 {
-    fatal ("Cannot clone base class");
-    return NULL;
+    acl *a = Config.aclList;
+    debug(53, 3) ("ACL::Initialize\n");
+
+    while (a) {
+        a->prepareForUse();
+        a = a->next;
+    }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: asn.cc,v 1.90 2003/02/21 22:50:06 robertc Exp $
+ * $Id: asn.cc,v 1.91 2003/02/25 12:24:34 robertc Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -39,6 +39,10 @@
 #include "StoreClient.h"
 #include "Store.h"
 #include "ACL.h"
+#include "ACLASN.h"
+#include "ACLSourceASN.h"
+#include "ACLDestinationASN.h"
+#include "ACLDestinationIP.h"
 
 #define WHOIS_PORT 43
 #define	AS_REQBUF_SZ	4096
@@ -60,13 +64,13 @@ struct squid_radix_node_head *AS_tree_head;
 
 /*
  * Structure for as number information. it could be simply 
- * an intlist but it's coded as a structure for future
+ * a list but it's coded as a structure for future
  * enhancements (e.g. expires)
  */
 
 struct _as_info
 {
-    intlist *as_number;
+    List<int> *as_number;
     time_t expires;		/* NOTUSED */
 };
 
@@ -106,24 +110,23 @@ static STCB asHandleReply;
 static int destroyRadixNode(struct squid_radix_node *rn, void *w);
 
 static int printRadixNode(struct squid_radix_node *rn, void *sentry);
-static void asnAclInitialize(acl * acls);
+void asnAclInitialize(acl * acls);
 static void asStateFree(void *data);
 static void destroyRadixNodeInfo(as_info *);
 static OBJH asnStats;
 
 /* PUBLIC */
 
 int
-
-asnMatchIp(void *data, struct in_addr addr)
+asnMatchIp(List<int> *data, struct in_addr addr)
 {
     unsigned long lh;
 
     struct squid_radix_node *rn;
     as_info *e;
     m_int m_addr;
-    intlist *a = NULL;
-    intlist *b = NULL;
+    List<int> *a = NULL;
+    List<int> *b = NULL;
     lh = ntohl(addr.s_addr);
     debug(53, 3) ("asnMatchIp: Called for %s.\n", inet_ntoa(addr));
 
@@ -140,8 +143,7 @@ asnMatchIp(void *data, struct in_addr addr)
 
     rn = squid_rn_match(m_addr, AS_tree_head);
 
-    if (rn == NULL)
-    {
+    if (rn == NULL) {
         debug(53, 3) ("asnMatchIp: Address not in as db.\n");
         return 0;
     }
@@ -150,10 +152,9 @@ asnMatchIp(void *data, struct in_addr addr)
     e = ((rtentry_t *) rn)->e_info;
     assert(e);
 
-    for (a = (intlist *) data; a; a = a->next)
+    for (a = data; a; a = a->next)
         for (b = e->as_number; b; b = b->next)
-            if (a->i == b->i)
-            {
+            if (a->element == b->element) {
                 debug(53, 5) ("asnMatchIp: Found a match!\n");
                 return 1;
             }
@@ -162,27 +163,12 @@ asnMatchIp(void *data, struct in_addr addr)
     return 0;
 }
 
-static void
-asnAclInitialize(acl * acls)
-{
-    acl *a;
-    debug(53, 3) ("asnAclInitialize\n");
-
-    for (a = acls; a; a = a->next) {
-        if (a->aclType() != ACL_DST_ASN && a->aclType() != ACL_SRC_ASN)
-            continue;
-
-        a->startCache();
-    }
-}
-
 void
-ACL::startCache()
+ACLASN::prepareForUse()
 {
-    assert (aclType() == ACL_DST_ASN || aclType() == ACL_SRC_ASN);
-
-    for (intlist *i = (intlist *)data; i; i = i->next)
-        asnCacheStart(i->i);
+    for (List<int> *i = data; i; i = i->
+                                     next)
+        asnCacheStart(i->element);
 }
 
 /* initialize the radix tree structure */
@@ -202,8 +188,6 @@ asnInit(void)
 
     squid_rn_inithead((void **) &AS_tree_head, 8);
 
-    asnAclInitialize(Config.aclList);
-
     cachemgrRegister("asndb", "AS Number Database", asnStats, 0, 1);
 }
 
@@ -393,8 +377,8 @@ asnAddNet(char *as_string, int as_number)
 
     struct squid_radix_node *rn;
     char dbg1[32], dbg2[32];
-    intlist **Tail = NULL;
-    intlist *q = NULL;
+    List<int> **Tail = NULL;
+    List<int> *q = NULL;
     as_info *asinfo = NULL;
 
     struct in_addr in_a, in_m;
@@ -445,7 +429,7 @@ asnAddNet(char *as_string, int as_number)
     if (rn != NULL) {
         asinfo = ((rtentry_t *) rn)->e_info;
 
-        if (intlistFind(asinfo->as_number, as_number)) {
+        if (asinfo->as_number->find(as_number)) {
             debug(53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
                           dbg1, bitl, as_number);
         } else {
@@ -454,17 +438,14 @@ asnAddNet(char *as_string, int as_number)
             for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next)
 
                 ;
-            q = (intlist *)xcalloc(1, sizeof(intlist));
-
-            q->i = as_number;
+            q = new List<int> (as_number);
 
             *(Tail) = q;
 
             e->e_info = asinfo;
         }
     } else {
-        q = (intlist *)xcalloc(1, sizeof(intlist));
-        q->i = as_number;
+        q = new List<int> (as_number);
         asinfo = (as_info *)xmalloc(sizeof(asinfo));
         asinfo->as_number = q;
         rn = squid_rn_addroute(e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
@@ -509,8 +490,8 @@ destroyRadixNode(struct squid_radix_node *rn, void *w)
 static void
 destroyRadixNodeInfo(as_info * e_info)
 {
-    intlist *prev = NULL;
-    intlist *data = e_info->as_number;
+    List<int> *prev = NULL;
+    List<int> *data = e_info->as_number;
 
     while (data) {
         prev = data;
@@ -543,7 +524,7 @@ printRadixNode(struct squid_radix_node *rn, void *_sentry)
 {
     StoreEntry *sentry = (StoreEntry *)_sentry;
     rtentry_t *e = (rtentry_t *) rn;
-    intlist *q;
+    List<int> *q;
     as_info *asinfo;
 
     struct in_addr addr;
@@ -559,9 +540,143 @@ printRadixNode(struct squid_radix_node *rn, void *_sentry)
     assert(asinfo->as_number);
 
     for (q = asinfo->as_number; q; q = q->next)
-        storeAppendPrintf(sentry, " %d", q->i);
+        storeAppendPrintf(sentry, " %d", q->element);
 
     storeAppendPrintf(sentry, "\n");
 
     return 0;
 }
+
+MemPool *ACLASN::Pool(NULL);
+void *
+ACLASN::operator new (size_t byteCount)
+{
+    /* derived classes with different sizes must implement their own new */
+    assert (byteCount == sizeof (ACLASN));
+
+    if (!Pool)
+        Pool = memPoolCreate("ACLASN", sizeof (ACLASN));
+
+    return memPoolAlloc(Pool);
+}
+
+void
+ACLASN::operator delete (void *address)
+{
+    memPoolFree (Pool, address);
+}
+
+void
+ACLASN::deleteSelf() const
+{
+    delete this;
+}
+
+ACLASN::~ACLASN()
+{
+    if (data)
+        data->deleteSelf();
+}
+
+bool
+
+ACLASN::match(struct in_addr toMatch)
+{
+    return asnMatchIp(data, toMatch);
+}
+
+wordlist *
+ACLASN::dump()
+{
+    wordlist *W = NULL;
+    char buf[32];
+    List<int> *ldata = data;
+
+    while (ldata != NULL) {
+        snprintf(buf, sizeof(buf), "%d", ldata->element);
+        wordlistAdd(&W, buf);
+        ldata = ldata->next;
+    }
+
+    return W;
+}
+
+void
+ACLASN::parse()
+{
+    List<int> **curlist = &data;
+    List<int> **Tail;
+    List<int> *q = NULL;
+    char *t = NULL;
+
+    for (Tail = curlist; *Tail; Tail = &((*Tail)->next))
+
+        ;
+    while ((t = strtokFile())) {
+        q = new List<int> (atoi(t));
+        *(Tail) = q;
+        Tail = &q->next;
+    }
+}
+
+ACLData<struct in_addr> *
+ACLASN::clone() const
+{
+    if (data)
+        fatal ("cloning of ACLASN not implemented");
+
+    return new ACLASN(*this);
+}
+
+ACL::Prototype ACLASN::SourceRegistryProtoype(&ACLASN::SourceRegistryEntry_, "src_as");
+ACLStrategised<struct in_addr> ACLASN::SourceRegistryEntry_(new ACLASN, ACLSourceASNStrategy::Instance(), "src_as");
+ACL::Prototype ACLASN::DestinationRegistryProtoype(&ACLASN::DestinationRegistryEntry_, "dst_as");
+ACLStrategised<struct in_addr> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
+
+int
+ACLSourceASNStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+{
+    return data->match(checklist->src_addr);
+}
+
+ACLSourceASNStrategy *
+ACLSourceASNStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLSourceASNStrategy ACLSourceASNStrategy::Instance_;
+
+
+int
+ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+{
+    const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->host, IP_LOOKUP_IF_MISS);
+
+    if (ia) {
+        for (int k = 0; k < (int) ia->count; k++) {
+            if (data->match(ia->in_addrs[k]))
+                return 1;
+        }
+
+        return 0;
+    } else if (!checklist->request->flags.destinationIPLookedUp()) {
+        /* No entry in cache, lookup not attempted */
+        /* XXX FIXME: allow accessing the acl name here */
+        debug(28, 3) ("asnMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+                      "unknown" /*name*/, checklist->request->host);
+        checklist->changeState (DestinationIPLookup::Instance());
+    } else {
+        return data->match(no_addr);
+    }
+
+    return 0;
+}
+
+ACLDestinationASNStrategy *
+ACLDestinationASNStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLDestinationASNStrategy ACLDestinationASNStrategy::Instance_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.434 2003/02/21 22:50:06 robertc Exp $
+ * $Id: cache_cf.cc,v 1.435 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -204,32 +204,6 @@ wordlistDup(const wordlist * w)
     return D;
 }
 
-void
-intlistDestroy(intlist ** list)
-{
-    intlist *w = NULL;
-    intlist *n = NULL;
-
-    for (w = *list; w; w = n) {
-        n = w->next;
-        memFree(w, MEM_INTLIST);
-    }
-
-    *list = NULL;
-}
-
-int
-intlistFind(intlist * list, int i)
-{
-    intlist *w = NULL;
-
-    for (w = list; w; w = w->next)
-        if (w->i == i)
-            return 1;
-
-    return 0;
-}
-
 /*
  * These functions is the same as atoi/l/f, except that they check for errors
  */
@@ -418,6 +392,7 @@ parseConfigFile(const char *file_name)
 static void
 configDoConfigure(void)
 {
+    LOCAL_ARRAY(char, buf, BUFSIZ);
     memset(&Config2, '\0', sizeof(SquidConfig2));
     /* init memory as early as possible */
     memConfigure();
@@ -455,6 +430,12 @@ configDoConfigure(void)
         }
     }
 
+    if (Config.Accel.host) {
+        snprintf(buf, BUFSIZ, "http://%s:%d", Config.Accel.host, Config.Accel.port);
+        Config2.Accel.prefix = xstrdup(buf);
+        Config2.Accel.on = 1;
+    }
+
     if (Config.appendDomain)
         if (*Config.appendDomain != '.')
             fatal("append_domain must begin with a '.'");
@@ -464,10 +445,16 @@ configDoConfigure(void)
 
     storeConfigure();
 
+    if (Config2.Accel.on && !strcmp(Config.Accel.host, "virtual")) {
+        vhost_mode = 1;
+
+        if (Config.Accel.port == 0)
+            vport_mode = 1;
+    }
+
     snprintf(ThisCache, sizeof(ThisCache), "%s (%s)",
              uniqueHostname(),
              full_appname_string);
-
     /*
      * the extra space is for loop detection in client_side.c -- we search
      * for substrings in the Via header.
@@ -604,21 +591,9 @@ configDoConfigure(void)
     }
 
     urlExtMethodConfigure();
-
-    if (0 == Config.onoff.client_db) {
-        acl *a;
-
-        for (a = Config.aclList; a; a = a->next) {
-            if (ACL_MAXCONN != a->aclType())
-                continue;
-
-            debug(22, 0) ("WARNING: 'maxconn' ACL (%s) won't work with client_db disabled\n", a->name);
-        }
-    }
-
 #if USE_SSL
-    Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath);
 
+    Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath);
 #endif
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_reply.cc,v 1.41 2003/02/21 22:50:07 robertc Exp $
+ * $Id: client_side_reply.cc,v 1.42 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 88    Client-side Reply Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -44,6 +44,7 @@
 #include "MemObject.h"
 #include "client_side_request.h"
 #include "ACLChecklist.h"
+#include "ACL.h"
 #if DELAY_POOLS
 #include "DelayPools.h"
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.227 2003/02/21 22:50:08 robertc Exp $
+ * $Id: enums.h,v 1.228 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -96,39 +96,6 @@ typedef enum {
     ERR_MAX
 } err_type;
 
-typedef enum {
-    ACL_NONE,
-    ACL_URL_PORT,
-    ACL_MY_PORT,
-    ACL_PROTO,
-    ACL_METHOD,
-    ACL_SRC_ASN,
-    ACL_DST_ASN,
-#if USE_ARP_ACL
-    ACL_SRC_ARP,
-#endif
-#if SQUID_SNMP
-    ACL_SNMP_COMMUNITY,
-#endif
-#if SRC_RTT_NOT_YET_FINISHED
-    ACL_NETDB_SRC_RTT,
-#endif
-    ACL_MAXCONN,
-    ACL_REP_MIME_TYPE,
-    ACL_MAX_USER_IP,
-    ACL_EXTERNAL,
-    ACL_DERIVED,
-    ACL_ENUM_MAX
-} squid_acl;
-
-typedef enum {
-    ACL_LOOKUP_NONE,
-    ACL_LOOKUP_NEEDED,
-    ACL_LOOKUP_PENDING,
-    ACL_LOOKUP_DONE,
-    ACL_PROXY_AUTH_NEEDED
-} acl_lookup_state;
-
 enum fd_type {
     FD_NONE,
     FD_LOG,
@@ -498,14 +465,16 @@ enum {
 typedef enum {
     STREAM_NONE,		/* No particular status */
     STREAM_COMPLETE,		/* All data has been flushed, no more reads allowed */
-    STREAM_UNPLANNED_COMPLETE,	/* an unpredicted end has occured, no more
-                    				 * reads occured, but no need to tell 
-                    				 * downstream that an error occured
-                    				 */
-    STREAM_FAILED		/* An error has occured in this node or an above one,
-                    				 * and the node is not generating an error body / it's 
-                    				 * midstream
-                    				 */
+    /* an unpredicted end has occured, no more
+     * reads occured, but no need to tell 
+     * downstream that an error occured
+     */
+    STREAM_UNPLANNED_COMPLETE,
+    /* An error has occured in this node or an above one,
+     * and the node is not generating an error body / it's
+     * midstream
+     */
+    STREAM_FAILED
 } clientStream_status_t;
 
 typedef enum {
@@ -582,7 +551,6 @@ typedef enum {
     MEM_HTTP_HDR_CONTENT_RANGE,
     MEM_HTTP_HDR_ENTRY,
     MEM_HTTP_REPLY,
-    MEM_INTLIST,
     MEM_IPCACHE_ENTRY,
     MEM_MD5_DIGEST,
     MEM_NETDBENTRY,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: external_acl.cc,v 1.29 2003/02/21 22:50:08 robertc Exp $
+ * $Id: external_acl.cc,v 1.30 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 82    External ACL
  * AUTHOR: Henrik Nordstrom, MARA Systems AB
@@ -60,8 +60,6 @@
 
 typedef struct _external_acl_format external_acl_format;
 
-typedef struct _external_acl_data external_acl_data;
-
 static char *makeExternalAclKey(ACLChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, external_acl_entry * entry);
 static int external_acl_entry_expired(external_acl * def, external_acl_entry * entry);
@@ -455,13 +453,11 @@ free_external_acl_data(void *data)
 }
 
 void
-aclParseExternal(void *dataptr)
+ACLExternal::parse()
 {
-    external_acl_data **datap = static_cast<external_acl_data **>(dataptr);
-    external_acl_data *data;
     char *token;
 
-    if (*datap)
+    if (data)
         self_destruct();
 
     CBDATA_INIT_TYPE_FREECB(external_acl_data, free_external_acl_data);
@@ -481,22 +477,21 @@ aclParseExternal(void *dataptr)
     while ((token = strtokFile())) {
         wordlistAdd(&data->arguments, token);
     }
-
-    *datap = data;
 }
 
-void
-aclDestroyExternal(void **dataptr)
+ACLExternal::~ACLExternal()
 {
-    cbdataFree(*dataptr);
+    cbdataFree(data);
+    safe_free (class_);
 }
 
-int
-aclMatchExternal(void *data, ACLChecklist * ch)
+static int
+aclMatchExternal(external_acl_data *acl, ACLChecklist * ch);
+static int
+aclMatchExternal(external_acl_data *acl, ACLChecklist * ch)
 {
     int result;
     external_acl_entry *entry;
-    external_acl_data *acl = static_cast<external_acl_data *>(data);
     const char *key = "";
     debug(82, 9) ("aclMatchExternal: acl=\"%s\"\n", acl->def->name);
     entry = ch->extacl_entry;
@@ -537,7 +532,6 @@ aclMatchExternal(void *data, ACLChecklist * ch)
 
     if (!entry) {
         debug(82, 2) ("aclMatchExternal: %s(\"%s\") = lookup needed\n", acl->def->name, key);
-        ch->state[ACL_EXTERNAL] = ACL_LOOKUP_NEEDED;
         ch->changeState (ExternalACLLookup::Instance());
         return 0;
     }
@@ -556,10 +550,16 @@ aclMatchExternal(void *data, ACLChecklist * ch)
     return result;
 }
 
+int
+ACLExternal::match(ACLChecklist *checklist)
+{
+    return aclMatchExternal (data, checklist);
+}
+
 wordlist *
-aclDumpExternal(void *data)
+ACLExternal::dump() const
 {
-    external_acl_data *acl = static_cast<external_acl_data *>(data);
+    external_acl_data const *acl = data;
     wordlist *result = NULL;
     wordlist *arg;
     MemBuf mb;
@@ -913,7 +913,7 @@ externalAclHandleReply(void *data, char *reply)
 }
 
 void
-ACL::ExternalAclLookup(ACLChecklist * ch, ACL * me, EAH * callback, void *callback_data)
+ACLExternal::ExternalAclLookup(ACLChecklist * ch, ACLExternal * me, EAH * callback, void *callback_data)
 {
     MemBuf buf;
     external_acl_data *acl = static_cast<external_acl_data *>(me->data);
@@ -1052,19 +1052,83 @@ ExternalACLLookup::Instance()
 void
 ExternalACLLookup::checkForAsync(ACLChecklist *checklist)const
 {
-    assert (checklist->state[ACL_EXTERNAL] == ACL_LOOKUP_NEEDED);
+    /* TODO: optimise this - we probably have a pointer to this
+     * around somewhere */
     acl *acl = ACL::FindByName(AclMatchedName);
-    assert (acl->aclType() == ACL_EXTERNAL);
+    ACLExternal *me = dynamic_cast<ACLExternal *> (acl);
+    assert (me);
     checklist->asyncInProgress(true);
-    ACL::ExternalAclLookup(checklist, acl, LookupDone, checklist);
+    ACLExternal::ExternalAclLookup(checklist, me, LookupDone, checklist);
 }
 
 void
 ExternalACLLookup::LookupDone(void *data, void *result)
 {
     ACLChecklist *checklist = (ACLChecklist *)data;
-    checklist->state[ACL_EXTERNAL] = ACL_LOOKUP_DONE;
     checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
     checklist->asyncInProgress(false);
     checklist->check();
 }
+
+/* This registers "external" in the registry. To do dynamic definitions
+ * of external ACL's, rather than a static prototype, have a Prototype instance
+ * prototype in the class that defines each external acl 'class'.
+ * Then, then the external acl instance is created, it self registers under
+ * it's name.
+ * Be sure that clone is fully functional for that acl class though!
+ */
+ACL::Prototype ACLExternal::RegistryProtoype(&ACLExternal::RegistryEntry_, "external");
+
+ACLExternal ACLExternal::RegistryEntry_("external");
+
+ACL *
+ACLExternal::clone() const
+{
+    return new ACLExternal(*this);
+}
+
+ACLExternal::ACLExternal (char const *theClass) : data (NULL), class_ (xstrdup (theClass))
+{}
+
+ACLExternal::ACLExternal (ACLExternal const & old) : data (NULL), class_ (old.class_ ? xstrdup (old.class_) : NULL)
+{
+    /* we don't have copy constructors for the data yet */
+    assert (!old.data);
+}
+
+MemPool *ACLExternal::Pool(NULL);
+void *
+ACLExternal::operator new (size_t byteCount)
+{
+    /* derived classes with different sizes must implement their own new */
+    assert (byteCount == sizeof (ACLExternal));
+
+    if (!Pool)
+        Pool = memPoolCreate("ACLExternal", sizeof (ACLExternal));
+
+    return memPoolAlloc(Pool);
+}
+
+void
+ACLExternal::operator delete (void *address)
+{
+    memPoolFree (Pool, address);
+}
+
+void
+ACLExternal::deleteSelf() const
+{
+    delete this;
+}
+
+char const *
+ACLExternal::typeString() const
+{
+    return class_;
+}
+
+bool
+ACLExternal::valid () const
+{
+    return data != NULL;
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.98 2003/02/23 00:08:04 robertc Exp $
+ * $Id: forward.cc,v 1.99 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -452,7 +452,9 @@ static struct in_addr
 
     for (l = head; l; l = l->next)
     {
-        if (ch->matchAclList(l->aclList))
+        ch->matchAclList(l->aclList);
+
+        if (ch->finished())
             return l->addr;
     }
 
@@ -466,7 +468,9 @@ aclMapTOS(acl_tos * head, ACLChecklist * ch)
     acl_tos *l;
 
     for (l = head; l; l = l->next) {
-        if (ch->matchAclList(l->aclList))
+        ch->matchAclList(l->aclList);
+
+        if (ch->finished())
             return l->tos;
     }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.120 2003/02/21 22:50:08 robertc Exp $
+ * $Id: globals.h,v 1.121 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -46,7 +46,6 @@ extern char *volatile debug_options;	/* NULL */
 extern char ThisCache[SQUIDHOSTNAMELEN << 1];
 extern char ThisCache2[SQUIDHOSTNAMELEN << 1];
 extern char config_input_line[BUFSIZ];
-extern const char *AclMatchedName;	/* NULL */
 extern const char *DefaultConfigFile;	/* DEFAULT_CONFIG_FILE */
 extern const char *RequestMethodStr[];
 extern const char *ProtocolStr[];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icp_v2.cc,v 1.79 2003/02/23 00:08:04 robertc Exp $
+ * $Id: icp_v2.cc,v 1.80 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 12    Internet Cache Protocol
  * AUTHOR: Duane Wessels
@@ -39,6 +39,7 @@
 #include "ICP.h"
 #include "HttpRequest.h"
 #include "ACLChecklist.h"
+#include "ACL.h"
 
 static void icpLogIcp(struct in_addr, log_type, int, const char *, int);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.368 2003/02/21 22:50:09 robertc Exp $
+ * $Id: main.cc,v 1.369 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -39,6 +39,8 @@
 #include "ICP.h"
 #include "HttpReply.h"
 #include "Mem.h"
+#include "ACLASN.h"
+#include "ACL.h"
 
 /* for error reporting from xmalloc and friends */
 extern void (*failure_notify) (const char *);
@@ -365,6 +367,7 @@ serverConnectionsOpen(void)
     icmpOpen();
     netdbInit();
     asnInit();
+    ACL::Initialize();
     peerSelectInit();
 #if USE_CARP
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.74 2003/02/21 22:50:09 robertc Exp $
+ * $Id: mem.cc,v 1.75 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -392,7 +392,6 @@ Mem::Init(void)
     memDataInit(MEM_HTTP_HDR_ENTRY, "HttpHeaderEntry", sizeof(HttpHeaderEntry), 0);
     memDataInit(MEM_HTTP_HDR_CC, "HttpHdrCc", sizeof(HttpHdrCc), 0);
     memDataInit(MEM_HTTP_HDR_CONTENT_RANGE, "HttpHdrContRange", sizeof(HttpHdrContRange), 0);
-    memDataInit(MEM_INTLIST, "intlist", sizeof(intlist), 0);
     memDataInit(MEM_NETDBENTRY, "netdbEntry", sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, "net_db_name", sizeof(net_db_name), 0);
     memDataInit(MEM_RELIST, "relist", sizeof(relist), 0);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.468 2003/02/21 22:50:10 robertc Exp $
+ * $Id: protos.h,v 1.469 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -55,8 +55,6 @@ SQUIDCEXTERN int logTypeIsATcpHit(log_type);
  * cache_cf.c
  */
 SQUIDCEXTERN int parseConfigFile(const char *file_name);
-SQUIDCEXTERN void intlistDestroy(intlist **);
-SQUIDCEXTERN int intlistFind(intlist * list, int i);
 SQUIDCEXTERN const char *wordlistAdd(wordlist **, const char *);
 SQUIDCEXTERN void wordlistAddWl(wordlist **, wordlist *);
 SQUIDCEXTERN void wordlistJoin(wordlist **, wordlist **);
@@ -919,10 +917,6 @@ SQUIDCEXTERN void pconnPush(int, const char *host, u_short port);
 SQUIDCEXTERN int pconnPop(const char *host, u_short port);
 SQUIDCEXTERN void pconnInit(void);
 
-SQUIDCEXTERN int asnMatchIp(void *, struct in_addr);
-SQUIDCEXTERN void asnInit(void);
-SQUIDCEXTERN void asnFreeMemory(void);
-
 /* tools.c */
 SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
 SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
@@ -1065,10 +1059,6 @@ SQUIDCEXTERN void WIN32_Exit(void);
 SQUIDCEXTERN void parse_externalAclHelper(external_acl **);
 SQUIDCEXTERN void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 SQUIDCEXTERN void free_externalAclHelper(external_acl **);
-SQUIDCEXTERN void aclParseExternal(void *curlist);
-SQUIDCEXTERN void aclDestroyExternal(void **curlust);
-SQUIDCEXTERN int aclMatchExternal(void *dataptr, ACLChecklist * ch);
-SQUIDCEXTERN wordlist *aclDumpExternal(void *dataptr);
 typedef void EAH(void *data, void *result);
 SQUIDCEXTERN void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
 SQUIDCEXTERN void externalAclInit(void);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: snmp_core.cc,v 1.63 2003/02/23 00:08:04 robertc Exp $
+ * $Id: snmp_core.cc,v 1.64 2003/02/25 12:24:35 robertc Exp $
  *
  * DEBUG: section 49    SNMP support
  * AUTHOR: Glenn Chisholm
@@ -1162,3 +1162,52 @@ struct in_addr
     cp[3] = id[3];
     return &laddr;
 }
+
+/* SNMP checklists */
+#include "ACLStrategy.h"
+#include "ACLStrategised.h"
+#include "ACLStringData.h"
+
+class ACLSNMPCommunityStrategy : public ACLStrategy<char const *>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    static ACLSNMPCommunityStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLSNMPCommunityStrategy(ACLSNMPCommunityStrategy const &);
+
+private:
+    static ACLSNMPCommunityStrategy Instance_;
+    ACLSNMPCommunityStrategy(){}
+
+    ACLSNMPCommunityStrategy&operator=(ACLSNMPCommunityStrategy const &);
+};
+
+class ACLSNMPCommunity
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<char const *> RegistryEntry_;
+};
+
+ACL::Prototype ACLSNMPCommunity::RegistryProtoype(&ACLSNMPCommunity::RegistryEntry_, "snmp_community");
+ACLStrategised<char const *> ACLSNMPCommunity::RegistryEntry_(new ACLStringData, ACLSNMPCommunityStrategy::Instance(), "snmp_community");
+
+int
+ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+{
+    return data->match (checklist->snmp_community);
+    ;
+}
+
+ACLSNMPCommunityStrategy *
+ACLSNMPCommunityStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLSNMPCommunityStrategy ACLSNMPCommunityStrategy::Instance_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.453 2003/02/22 14:59:35 hno Exp $
+ * $Id: structs.h,v 1.454 2003/02/25 12:22:34 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -49,20 +49,6 @@ struct _dlink_list
     dlink_node *tail;
 };
 
-struct _acl_user_ip_data
-{
-    size_t max;
-
-    struct
-    {
-
-unsigned int strict:
-        1;
-    }
-
-    flags;
-};
-
 struct _acl_name_list
 {
     char name[ACL_NAME_SZ];
@@ -84,15 +70,6 @@ struct _acl_deny_info_list
     acl_deny_info_list *next;
 };
 
-#if USE_ARP_ACL
-
-struct _acl_arp_data
-{
-    char eth[6];
-};
-
-#endif
-
 
 class acl_access;
 
@@ -159,19 +136,6 @@ struct _wordlist
     wordlist *next;
 };
 
-struct _intlist
-{
-    int i;
-    intlist *next;
-};
-
-struct _intrange
-{
-    int i;
-    int j;
-    intrange *next;
-};
-
 struct _ushortlist
 {
     u_short i;
@@ -192,31 +156,13 @@ struct _sockaddr_in_list
     sockaddr_in_list *next;
 };
 
-struct _http_port_list
-{
-    http_port_list *next;
-
-    struct sockaddr_in s;
-    char *protocol;		/* protocol name */
-    char *name;			/* visible name */
-    char *defaultsite;		/* default web site */
-
-unsigned int transparent:
-    1;	/* transparent proxy */
-
-unsigned int accel:
-    1;	/* HTTP accelerator */
-
-unsigned int vhost:
-    1;	/* uses host header */
-    int vport;			/* virtual port support, -1 for dynamic, >0 static*/
-};
-
 #if USE_SSL
 
 struct _https_port_list
 {
-    http_port_list http;	/* must be first */
+    https_port_list *next;
+
+    struct sockaddr_in s;
     char *cert;
     char *key;
     int version;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.153 2003/02/21 22:50:12 robertc Exp $
+ * $Id: typedefs.h,v 1.154 2003/02/25 12:22:35 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -71,10 +71,6 @@ typedef struct _authscheme_entry authscheme_entry_t;
 
 typedef struct _authScheme authScheme;
 
-typedef struct _acl_user_ip_data acl_user_ip_data;
-
-typedef struct _acl_arp_data acl_arp_data;
-
 typedef struct _acl_snmp_comm acl_snmp_comm;
 
 typedef class ACLList acl_list;
@@ -87,18 +83,12 @@ class ACLChecklist;
 
 typedef struct _wordlist wordlist;
 
-typedef struct _intlist intlist;
-
-typedef struct _intrange intrange;
-
 typedef struct _ushortlist ushortlist;
 
 typedef struct _relist relist;
 
 typedef struct _sockaddr_in_list sockaddr_in_list;
 
-typedef struct _http_port_list http_port_list;
-
 typedef struct _https_port_list https_port_list;
 
 typedef struct _SquidConfig SquidConfig;