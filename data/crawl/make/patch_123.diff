diff --git a/.cvsignore b/.cvsignore
index fd278e9..d8801b8 100644
--- a/.cvsignore
+++ b/.cvsignore
@@ -21,7 +21,7 @@ config.ami configh.dos config.h.W32 config.h-vms
 
 loadavg loadavg.c make
 
-.deps .dep_segment
+.deps .dep_segment ID TAGS
 
 _*
 sun4 i386 i386-netbsd hp300-netbsd hp300 rs6000 sun3 news800 amiga
diff --git a/ChangeLog b/ChangeLog
index 1eb3ca3..a3b5237 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,4 +1,45 @@
-2006-09-30  Paul Smith  <psmith@paulandlesley.org>
+2006-11-18  Paul Smith  <psmith@gnu.org>
+
+	* strcache.c (strcache_add_len): Don't allocate a new buffer
+	unless the string is not already nil-terminated.  Technically this
+	is a violation of the standard, since we may be passed an array
+	that is not long enough to test one past.  However, in make this
+	is never true since we only use nil-terminated strings.
+
+	* read.c (eval, do_define): Use cmd_prefix instead of '\t'.
+
+	* main.c: New global cmd_prefix, defaults to '\t'.
+	* job.c (construct_command_argv_internal): Use cmd_prefix instead
+	of '\t'.
+
+	* dir.c: Constified.
+	(dir_contents_file_exists_p): Check for an error return	from
+	readdir(), just in case.
+
+	* commands.c: Constified.
+	* default.c: Constified.
+	* expand.c: Constified.
+	* function.c: Partial constification.
+	* variable.c: Partial constification.
+	* vmsify.c: Constification.  Hard to test this but I hope I didn't
+	screw it up!
+	* vpath.c: Partial constification.
+
+2006-11-16  Eli Zaretskii  <eliz@gnu.org>
+
+	* main.c (main) [HAVE_DOS_PATHS]: Treat DOS style argv[0] with
+	backslashes and drive letters as absolute.
+
+2006-10-22  Paul Smith  <psmith@gnu.org>
+
+	* main.c (struct command_switch): Use const and void*.
+
+2006-10-21  Paul Smith  <psmith@gnu.org>
+
+	* ar.c: Constified.
+	* arscan.c: Constified.
+
+2006-09-30  Paul Smith  <psmith@gnu.org>
 
 	* doc/make.texi (MAKEFILE_LIST Variable): Modify reference to
 	point to lastword since the example was updated.
diff --git a/ar.c b/ar.c
index 9487146..9bf0cb7 100644
--- a/ar.c
+++ b/ar.c
@@ -24,23 +24,16 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.  */
 #include "dep.h"
 #include <fnmatch.h>
 
-/* Defined in arscan.c.  */
-extern long int ar_scan (char *archive, long int (*function) (), long int arg);
-extern int ar_name_equal (char *name, char *mem, int truncated);
-#ifndef VMS
-extern int ar_member_touch (char *arname, char *memname);
-#endif
-
 /* Return nonzero if NAME is an archive-member reference, zero if not.
    An archive-member reference is a name like `lib(member)'.
    If a name like `lib((entry))' is used, a fatal error is signaled at
    the attempt to use this unsupported feature.  */
 
 int
-ar_name (char *name)
+ar_name (const char *name)
 {
-  char *p = strchr (name, '(');
-  char *end;
+  const char *p = strchr (name, '(');
+  const char *end;
 
   if (p == 0 || p == name)
     return 0;
@@ -61,9 +54,9 @@ ar_name (char *name)
    put the malloc'd member name in *MEMNAME_P if MEMNAME_P is non-nil.  */
 
 void
-ar_parse_name (char *name, char **arname_p, char **memname_p)
+ar_parse_name (const char *name, char **arname_p, char **memname_p)
 {
-  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
+  const char *p = strchr (name, '('), *end = name + strlen (name) - 1;
 
   if (arname_p != 0)
     *arname_p = savestring (name, p - name);
@@ -72,17 +65,28 @@ ar_parse_name (char *name, char **arname_p, char **memname_p)
     *memname_p = savestring (p + 1, end - (p + 1));
 }
 
-static long int ar_member_date_1 (int desc, char *mem, int truncated, long int hdrpos,
-	long int datapos, long int size, long int date, int uid, int gid, int mode, char *name);
+
+/* This function is called by `ar_scan' to find which member to look at.  */
+
+/* ARGSUSED */
+static long int
+ar_member_date_1 (int desc UNUSED, const char *mem, int truncated,
+		  long int hdrpos UNUSED, long int datapos UNUSED,
+                  long int size UNUSED, long int date,
+                  int uid UNUSED, int gid UNUSED, int mode UNUSED,
+		  const void *name)
+{
+  return ar_name_equal (name, mem, truncated) ? date : 0;
+}
 
 /* Return the modtime of NAME.  */
 
 time_t
-ar_member_date (char *name)
+ar_member_date (const char *name)
 {
   char *arname;
-  int arname_used = 0;
   char *memname;
+  int arname_used = 0;
   long int val;
 
   ar_parse_name (name, &arname, &memname);
@@ -107,7 +111,7 @@ ar_member_date (char *name)
       (void) f_mtime (arfile, 0);
   }
 
-  val = ar_scan (arname, ar_member_date_1, (long int) memname);
+  val = ar_scan (arname, ar_member_date_1, memname);
 
   if (!arname_used)
     free (arname);
@@ -115,31 +119,19 @@ ar_member_date (char *name)
 
   return (val <= 0 ? (time_t) -1 : (time_t) val);
 }
-
-/* This function is called by `ar_scan' to find which member to look at.  */
-
-/* ARGSUSED */
-static long int
-ar_member_date_1 (int desc UNUSED, char *mem, int truncated,
-		  long int hdrpos UNUSED, long int datapos UNUSED,
-                  long int size UNUSED, long int date,
-                  int uid UNUSED, int gid UNUSED, int mode UNUSED, char *name)
-{
-  return ar_name_equal (name, mem, truncated) ? date : 0;
-}
 
 /* Set the archive-member NAME's modtime to now.  */
 
 #ifdef VMS
 int
-ar_touch (char *name)
+ar_touch (const char *name)
 {
   error (NILF, _("touch archive member is not available on VMS"));
   return -1;
 }
 #else
 int
-ar_touch (char *name)
+ar_touch (const char *name)
 {
   char *arname, *memname;
   int arname_used = 0;
@@ -198,7 +190,7 @@ ar_touch (char *name)
 struct ar_glob_state
   {
     char *arname;
-    char *pattern;
+    const char *pattern;
     unsigned int size;
     struct nameseq *chain;
     unsigned int n;
@@ -208,11 +200,13 @@ struct ar_glob_state
    element against the pattern in STATE.  */
 
 static long int
-ar_glob_match (int desc UNUSED, char *mem, int truncated UNUSED,
+ar_glob_match (int desc UNUSED, const char *mem, int truncated UNUSED,
 	       long int hdrpos UNUSED, long int datapos UNUSED,
                long int size UNUSED, long int date UNUSED, int uid UNUSED,
-               int gid UNUSED, int mode UNUSED, struct ar_glob_state *state)
+               int gid UNUSED, int mode UNUSED, const void *arg)
 {
+  struct ar_glob_state *state = (struct ar_glob_state *)arg;
+
   if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
     {
       /* We have a match.  Add it to the chain.  */
@@ -263,7 +257,7 @@ glob_pattern_p (const char *pattern, int quote)
    Return a malloc'd chain of matching elements (or nil if none).  */
 
 struct nameseq *
-ar_glob (char *arname, char *member_pattern, unsigned int size)
+ar_glob (const char *arname, const char *member_pattern, unsigned int size)
 {
   struct ar_glob_state state;
   char **names;
@@ -284,7 +278,7 @@ ar_glob (char *arname, char *member_pattern, unsigned int size)
   state.size = size;
   state.chain = 0;
   state.n = 0;
-  (void) ar_scan (arname, ar_glob_match, (long int) &state);
+  ar_scan (arname, ar_glob_match, &state);
 
   if (state.chain == 0)
     return 0;
diff --git a/arscan.c b/arscan.c
index 97649a8..5e767a1 100644
--- a/arscan.c
+++ b/arscan.c
@@ -25,7 +25,7 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.  */
 #endif
 
 #ifndef	NO_ARCHIVES
-
+
 #ifdef VMS
 #include <lbrdef.h>
 #include <mhddef.h>
@@ -134,7 +134,7 @@ VMS_get_member_info (struct dsc$descriptor_s *module, unsigned long *rfa)
    Returns 0 if have scanned successfully.  */
 
 long int
-ar_scan (char *archive, long int (*function) (void), long int arg)
+ar_scan (const char *archive, ar_member_func_t function, const void *arg)
 {
   char *p;
 
@@ -301,7 +301,7 @@ struct ar_hdr
    Returns 0 if have scanned successfully.  */
 
 long int
-ar_scan (char *archive, long int (*function)(), long int arg)
+ar_scan (const char *archive, ar_member_func_t function, const void *arg)
 {
 #ifdef AIAMAG
   FL_HDR fl_header;
@@ -313,7 +313,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
   int long_name = 0;
 #endif
   char *namemap = 0;
-  register int desc = open (archive, O_RDONLY, 0);
+  int desc = open (archive, O_RDONLY, 0);
   if (desc < 0)
     return -1;
 #ifdef SARMAG
@@ -706,9 +706,9 @@ ar_scan (char *archive, long int (*function)(), long int arg)
    sizeof (struct ar_hdr.ar_name) - 1.  */
 
 int
-ar_name_equal (char *name, char *mem, int truncated)
+ar_name_equal (const char *name, const char *mem, int truncated)
 {
-  char *p;
+  const char *p;
 
   p = strrchr (name, '/');
   if (p != 0)
@@ -737,10 +737,10 @@ ar_name_equal (char *name, char *mem, int truncated)
 #ifndef VMS
 /* ARGSUSED */
 static long int
-ar_member_pos (int desc UNUSED, char *mem, int truncated,
+ar_member_pos (int desc UNUSED, const char *mem, int truncated,
 	       long int hdrpos, long int datapos UNUSED, long int size UNUSED,
                long int date UNUSED, int uid UNUSED, int gid UNUSED,
-               int mode UNUSED, char *name)
+               int mode UNUSED, const void *name)
 {
   if (!ar_name_equal (name, mem, truncated))
     return 0;
@@ -755,9 +755,9 @@ ar_member_pos (int desc UNUSED, char *mem, int truncated,
    1 if valid but member MEMNAME does not exist.  */
 
 int
-ar_member_touch (char *arname, char *memname)
+ar_member_touch (const char *arname, const char *memname)
 {
-  long int pos = ar_scan (arname, ar_member_pos, (long int) memname);
+  long int pos = ar_scan (arname, ar_member_pos, memname);
   int fd;
   struct ar_hdr ar_hdr;
   int i;
@@ -816,9 +816,9 @@ ar_member_touch (char *arname, char *memname)
 #ifdef TEST
 
 long int
-describe_member (int desc, char *name, int truncated,
+describe_member (int desc, const char *name, int truncated,
 		 long int hdrpos, long int datapos, long int size,
-                 long int date, int uid, int gid, int mode)
+                 long int date, int uid, int gid, int mode, const void *arg)
 {
   extern char *ctime ();
 
@@ -834,7 +834,7 @@ describe_member (int desc, char *name, int truncated,
 int
 main (int argc, char **argv)
 {
-  ar_scan (argv[1], describe_member);
+  ar_scan (argv[1], describe_member, NULL);
   return 0;
 }
 
diff --git a/commands.c b/commands.c
index 923dc7c..d1db6fe 100644
--- a/commands.c
+++ b/commands.c
@@ -44,8 +44,8 @@ int getpid ();
 void
 set_file_variables (struct file *file)
 {
-  struct dep *d;
-  char *at, *percent, *star, *less;
+  const struct dep *d;
+  const char *at, *percent, *star, *less;
 
 #ifndef	NO_ARCHIVES
   /* If the target is an archive member `lib(member)',
@@ -54,16 +54,19 @@ set_file_variables (struct file *file)
   if (ar_name (file->name))
     {
       unsigned int len;
+      const char *cp;
       char *p;
 
-      p = strchr (file->name, '(');
-      at = alloca (p - file->name + 1);
-      memcpy (at, file->name, p - file->name);
-      at[p - file->name] = '\0';
-      len = strlen (p + 1);
-      percent = alloca (len);
-      memcpy (percent, p + 1, len - 1);
-      percent[len - 1] = '\0';
+      cp = strchr (file->name, '(');
+      p = alloca (cp - file->name + 1);
+      memcpy (p, file->name, cp - file->name);
+      p[cp - file->name] = '\0';
+      at = p;
+      len = strlen (cp + 1);
+      p = alloca (len);
+      memcpy (p, cp + 1, len - 1);
+      p[len - 1] = '\0';
+      percent = p;
     }
   else
 #endif	/* NO_ARCHIVES.  */
@@ -78,7 +81,7 @@ set_file_variables (struct file *file)
       /* In Unix make, $* is set to the target name with
 	 any suffix in the .SUFFIXES list stripped off for
 	 explicit rules.  We store this in the `stem' member.  */
-      char *name;
+      const char *name;
       unsigned int len;
 
 #ifndef	NO_ARCHIVES
@@ -136,7 +139,7 @@ set_file_variables (struct file *file)
 
   {
     static char *plus_value=0, *bar_value=0, *qmark_value=0;
-    static unsigned int qmark_max=0, plus_max=0, bar_max=0;
+    static unsigned int plus_max=0, bar_max=0, qmark_max=0;
 
     unsigned int qmark_len, plus_len, bar_len;
     char *cp;
@@ -163,7 +166,7 @@ set_file_variables (struct file *file)
     for (d = file->deps; d != 0; d = d->next)
       if (! d->ignore_mtime)
         {
-          char *c = dep_name (d);
+          const char *c = dep_name (d);
 
 #ifndef	NO_ARCHIVES
           if (ar_name (c))
@@ -214,7 +217,7 @@ set_file_variables (struct file *file)
 
     for (d = file->deps; d != 0; d = d->next)
       {
-	char *c = dep_name (d);
+	const char *c = dep_name (d);
 
 #ifndef	NO_ARCHIVES
 	if (ar_name (c))
@@ -267,7 +270,7 @@ set_file_variables (struct file *file)
 void
 chop_commands (struct commands *cmds)
 {
-  register char *p;
+  const char *p;
   unsigned int nlines, idx;
   char **lines;
 
@@ -287,7 +290,7 @@ chop_commands (struct commands *cmds)
   p = cmds->commands;
   while (*p != '\0')
     {
-      char *end = p;
+      const char *end = p;
     find_end:;
       end = strchr (end, '\n');
       if (end == 0)
@@ -295,7 +298,7 @@ chop_commands (struct commands *cmds)
       else if (end > p && end[-1] == '\\')
         {
           int backslash = 1;
-          register char *b;
+          const char *b;
           for (b = end - 2; b >= p && *b == '\\'; --b)
             backslash = !backslash;
           if (backslash)
@@ -364,7 +367,7 @@ chop_commands (struct commands *cmds)
 void
 execute_file_commands (struct file *file)
 {
-  register char *p;
+  const char *p;
 
   /* Don't go through all the preparations if
      the commands are nothing but whitespace.  */
@@ -452,7 +455,7 @@ fatal_error_signal (int sig)
 
   if (sig == SIGTERM)
     {
-      register struct child *c;
+      struct child *c;
       for (c = children; c != 0; c = c->next)
 	if (!c->remote)
 	  (void) kill (c->pid, SIGTERM);
@@ -470,7 +473,7 @@ fatal_error_signal (int sig)
 #endif
     )
     {
-      register struct child *c;
+      struct child *c;
 
       /* Remote children won't automatically get signals sent
 	 to the process group, so we must send them.  */
@@ -522,7 +525,7 @@ fatal_error_signal (int sig)
    and it has changed on disk since we last stat'd it.  */
 
 static void
-delete_target (struct file *file, char *on_behalf_of)
+delete_target (struct file *file, const char *on_behalf_of)
 {
   struct stat st;
   int e;
@@ -577,7 +580,7 @@ delete_child_targets (struct child *child)
     return;
 
   /* Delete the target file if it changed.  */
-  delete_target (child->file, 0);
+  delete_target (child->file, NULL);
 
   /* Also remove any non-precious targets listed in the `also_make' member.  */
   for (d = child->file->also_make; d != 0; d = d->next)
@@ -589,9 +592,9 @@ delete_child_targets (struct child *child)
 /* Print out the commands in CMDS.  */
 
 void
-print_commands (struct commands *cmds)
+print_commands (const struct commands *cmds)
 {
-  register char *s;
+  const char *s;
 
   fputs (_("#  commands to execute"), stdout);
 
@@ -604,7 +607,7 @@ print_commands (struct commands *cmds)
   s = cmds->commands;
   while (*s != '\0')
     {
-      char *end;
+      const char *end;
 
       while (isspace ((unsigned char)*s))
 	++s;
diff --git a/commands.h b/commands.h
index 3e790ea..d717d9c 100644
--- a/commands.h
+++ b/commands.h
@@ -36,7 +36,7 @@ struct commands
 #define	COMMANDS_NOERROR	4 /* No errors: -.  */
 
 void execute_file_commands (struct file *file);
-void print_commands (struct commands *cmds);
+void print_commands (const struct commands *cmds);
 void delete_child_targets (struct child *child);
 void chop_commands (struct commands *cmds);
 void set_file_variables (struct file *file);
diff --git a/default.c b/default.c
index ada0a8a..95f5635 100644
--- a/default.c
+++ b/default.c
@@ -302,7 +302,7 @@ static char *default_suffix_rules[] =
     0, 0,
   };
 
-static char *default_variables[] =
+static const char *default_variables[] =
   {
 #ifdef VMS
 #ifdef __ALPHA
@@ -544,14 +544,14 @@ set_default_suffixes (void)
 void
 install_default_suffix_rules (void)
 {
-  register char **s;
+  char **s;
 
   if (no_builtin_rules_flag)
     return;
 
- for (s = default_suffix_rules; *s != 0; s += 2)
+  for (s = default_suffix_rules; *s != 0; s += 2)
     {
-      register struct file *f = enter_file (s[0]);
+      struct file *f = enter_file (s[0]);
       /* Don't clobber cmds given in a makefile if there were any.  */
       if (f->cmds == 0)
 	{
@@ -569,7 +569,7 @@ install_default_suffix_rules (void)
 void
 install_default_implicit_rules (void)
 {
-  register struct pspec *p;
+  struct pspec *p;
 
   if (no_builtin_rules_flag)
     return;
@@ -584,11 +584,11 @@ install_default_implicit_rules (void)
 void
 define_default_variables (void)
 {
-  register char **s;
+  const char **s;
 
   if (no_builtin_variables_flag)
     return;
 
   for (s = default_variables; *s != 0; s += 2)
-    (void) define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
+    define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
 }
diff --git a/dep.h b/dep.h
index 345f5ad..f84a83e 100644
--- a/dep.h
+++ b/dep.h
@@ -64,7 +64,7 @@ struct nameseq *parse_file_seq (char **stringp, int stopchar, unsigned int size,
 char *tilde_expand (char *name);
 
 #ifndef NO_ARCHIVES
-struct nameseq *ar_glob (char *arname, char *member_pattern, unsigned int size);
+struct nameseq *ar_glob (const char *arname, const char *member_pattern, unsigned int size);
 #endif
 
 #ifndef	iAPX286
diff --git a/dir.c b/dir.c
index b6c18a6..12e0382 100644
--- a/dir.c
+++ b/dir.c
@@ -67,8 +67,8 @@ char *vmsify (char *name, int type);
 #define _USE_LFN 0
 #endif
 
-static char *
-dosify (char *filename)
+static const char *
+dosify (const char *filename)
 {
   static char dos_filename[14];
   char *df;
@@ -117,8 +117,8 @@ dosify (char *filename)
 #endif
 
 #ifdef HAVE_CASE_INSENSITIVE_FS
-static char *
-downcase (char *filename)
+static const char *
+downcase (const char *filename)
 {
   static PATH_VAR (new_filename);
   char *df;
@@ -130,11 +130,11 @@ downcase (char *filename)
   df = new_filename;
 
   /* First, transform the name part.  */
-  for (i = 0; *filename != '\0'; ++i)
-  {
-    *df++ = tolower ((unsigned char)*filename);
-    ++filename;
-  }
+  while (*filename != '\0')
+    {
+      *df++ = tolower ((unsigned char)*filename);
+      ++filename;
+    }
 
   *df = 0;
 
@@ -214,27 +214,24 @@ struct directory_contents
   {
     dev_t dev;			/* Device and inode numbers of this dir.  */
 #ifdef WINDOWS32
-    /*
-     * Inode means nothing on WINDOWS32. Even file key information is
-     * unreliable because it is random per file open and undefined
-     * for remote filesystems. The most unique attribute I can
-     * come up with is the fully qualified name of the directory. Beware
-     * though, this is also unreliable. I'm open to suggestion on a better
-     * way to emulate inode.
-     */
+    /* Inode means nothing on WINDOWS32. Even file key information is
+     * unreliable because it is random per file open and undefined for remote
+     * filesystems. The most unique attribute I can come up with is the fully
+     * qualified name of the directory. Beware though, this is also
+     * unreliable. I'm open to suggestion on a better way to emulate inode.  */
     char *path_key;
     int   ctime;
     int   mtime;        /* controls check for stale directory cache */
     int   fs_flags;     /* FS_FAT, FS_NTFS, ... */
-#define FS_FAT      0x1
-#define FS_NTFS     0x2
-#define FS_UNKNOWN  0x4
+# define FS_FAT      0x1
+# define FS_NTFS     0x2
+# define FS_UNKNOWN  0x4
 #else
-#ifdef VMS
+# ifdef VMS
     ino_t ino[3];
-#else
+# else
     ino_t ino;
-#endif
+# endif
 #endif /* WINDOWS32 */
     struct hash_table dirfiles;	/* Files in this directory.  */
     DIR *dirstream;		/* Stream reading this directory.  */
@@ -243,7 +240,7 @@ struct directory_contents
 static unsigned long
 directory_contents_hash_1 (const void *key_0)
 {
-  struct directory_contents const *key = (struct directory_contents const *) key_0;
+  const struct directory_contents *key = key_0;
   unsigned long hash;
 
 #ifdef WINDOWS32
@@ -266,7 +263,7 @@ directory_contents_hash_1 (const void *key_0)
 static unsigned long
 directory_contents_hash_2 (const void *key_0)
 {
-  struct directory_contents const *key = (struct directory_contents const *) key_0;
+  const struct directory_contents *key = key_0;
   unsigned long hash;
 
 #ifdef WINDOWS32
@@ -301,8 +298,8 @@ directory_contents_hash_2 (const void *key_0)
 static int
 directory_contents_hash_cmp (const void *xv, const void *yv)
 {
-  struct directory_contents const *x = (struct directory_contents const *) xv;
-  struct directory_contents const *y = (struct directory_contents const *) yv;
+  const struct directory_contents *x = xv;
+  const struct directory_contents *y = yv;
   int result;
 
 #ifdef WINDOWS32
@@ -338,7 +335,7 @@ static struct hash_table directory_contents;
 
 struct directory
   {
-    char *name;			/* Name of the directory.  */
+    const char *name;			/* Name of the directory.  */
 
     /* The directory's contents.  This data may be shared by several
        entries in the hash table, which refer to the same directory
@@ -349,20 +346,20 @@ struct directory
 static unsigned long
 directory_hash_1 (const void *key)
 {
-  return_ISTRING_HASH_1 (((struct directory const *) key)->name);
+  return_ISTRING_HASH_1 (((const struct directory *) key)->name);
 }
 
 static unsigned long
 directory_hash_2 (const void *key)
 {
-  return_ISTRING_HASH_2 (((struct directory const *) key)->name);
+  return_ISTRING_HASH_2 (((const struct directory *) key)->name);
 }
 
 static int
 directory_hash_cmp (const void *x, const void *y)
 {
-  return_ISTRING_COMPARE (((struct directory const *) x)->name,
-			  ((struct directory const *) y)->name);
+  return_ISTRING_COMPARE (((const struct directory *) x)->name,
+			  ((const struct directory *) y)->name);
 }
 
 /* Table of directories hashed by name.  */
@@ -379,7 +376,7 @@ static unsigned int open_directories = 0;
 
 struct dirfile
   {
-    char *name;			/* Name of the file.  */
+    const char *name;		/* Name of the file.  */
     short length;
     short impossible;		/* This file is impossible.  */
   };
@@ -399,8 +396,8 @@ dirfile_hash_2 (const void *key)
 static int
 dirfile_hash_cmp (const void *xv, const void *yv)
 {
-  struct dirfile const *x = ((struct dirfile const *) xv);
-  struct dirfile const *y = ((struct dirfile const *) yv);
+  const struct dirfile *x = xv;
+  const struct dirfile *y = yv;
   int result = x->length - y->length;
   if (result)
     return result;
@@ -411,17 +408,18 @@ dirfile_hash_cmp (const void *xv, const void *yv)
 #define DIRFILE_BUCKETS 107
 #endif
 
-static int dir_contents_file_exists_p (struct directory_contents *dir, char *filename);
-static struct directory *find_directory (char *name);
+static int dir_contents_file_exists_p (struct directory_contents *dir,
+                                       const char *filename);
+static struct directory *find_directory (const char *name);
 
 /* Find the directory named NAME and return its `struct directory'.  */
 
 static struct directory *
-find_directory (char *name)
+find_directory (const char *name)
 {
-  register char *p;
-  register struct directory *dir;
-  register struct directory **dir_slot;
+  const char *p;
+  struct directory *dir;
+  struct directory **dir_slot;
   struct directory dir_key;
   int r;
 #ifdef WINDOWS32
@@ -451,7 +449,7 @@ find_directory (char *name)
 
       p = name + strlen (name);
       dir = xmalloc (sizeof (struct directory));
-      dir->name = savestring (name, p - name);
+      dir->name = strcache_add_len (name, p - name);
       hash_insert_at (&directories, dir, dir_slot);
       /* The directory is not in the name hash table.
 	 Find its device and inode numbers, and look it up by them.  */
@@ -549,8 +547,8 @@ find_directory (char *name)
 	      hash_insert_at (&directory_contents, dc, dc_slot);
 	      ENULLLOOP (dc->dirstream, opendir (name));
 	      if (dc->dirstream == 0)
-                /* Couldn't open the directory.  Mark this by
-                   setting the `files' member to a nil pointer.  */
+                /* Couldn't open the directory.  Mark this by setting the
+                   `files' member to a nil pointer.  */
                 dc->dirfiles.ht_vec = 0;
 	      else
 		{
@@ -561,7 +559,7 @@ find_directory (char *name)
 		  if (open_directories == MAX_OPEN_DIRECTORIES)
 		    /* We have too many directories open already.
 		       Read the entire directory and then close it.  */
-		    (void) dir_contents_file_exists_p (dc, 0);
+		    dir_contents_file_exists_p (dc, 0);
 		}
 	    }
 
@@ -577,7 +575,8 @@ find_directory (char *name)
    FILENAME must contain no slashes.  */
 
 static int
-dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
+dir_contents_file_exists_p (struct directory_contents *dir,
+                            const char *filename)
 {
   unsigned int hash;
   struct dirfile *df;
@@ -588,10 +587,9 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 #endif
 
   if (dir == 0 || dir->dirfiles.ht_vec == 0)
-    {
     /* The directory could not be stat'd or opened.  */
-      return 0;
-    }
+    return 0;
+
 #ifdef __MSDOS__
   filename = dosify (filename);
 #endif
@@ -621,11 +619,9 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 	}
       dirfile_key.name = filename;
       dirfile_key.length = strlen (filename);
-      df = (struct dirfile *) hash_find_item (&dir->dirfiles, &dirfile_key);
+      df = hash_find_item (&dir->dirfiles, &dirfile_key);
       if (df)
-	{
-	  return !df->impossible;
-	}
+        return !df->impossible;
     }
 
   /* The file was not found in the hashed list.
@@ -646,7 +642,7 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 	      dir->mtime = time ((time_t *) 0);
 	      rehash = 1;
 	    }
-	  else if (stat(dir->path_key, &st) == 0 && st.st_mtime > dir->mtime)
+	  else if (stat (dir->path_key, &st) == 0 && st.st_mtime > dir->mtime)
 	    {
 	      /* reset date stamp to show most recent re-process.  */
 	      dir->mtime = st.st_mtime;
@@ -658,7 +654,7 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 	    return 0;
 
           /* make sure directory can still be opened; if not return.  */
-          dir->dirstream = opendir(dir->path_key);
+          dir->dirstream = opendir (dir->path_key);
           if (!dir->dirstream)
             return 0;
 	}
@@ -677,7 +673,11 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 
       ENULLLOOP (d, readdir (dir->dirstream));
       if (d == 0)
-        break;
+        {
+          if (errno)
+            fatal (NILF, "INTERNAL: readdir: %s\n", strerror (errno));
+          break;
+        }
 
 #if defined(VMS) && defined(HAVE_DIRENT_H)
       /* In VMS we get file versions too, which have to be stripped off */
@@ -703,16 +703,14 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
 #endif
 	{
 	  df = xmalloc (sizeof (struct dirfile));
-	  df->name = savestring (d->d_name, len);
+	  df->name = strcache_add_len (d->d_name, len);
 	  df->length = len;
 	  df->impossible = 0;
 	  hash_insert_at (&dir->dirfiles, df, dirfile_slot);
 	}
       /* Check if the name matches the one we're searching for.  */
       if (filename != 0 && strieq (d->d_name, filename))
-	{
-	  return 1;
-	}
+        return 1;
     }
 
   /* If the directory has been completely read in,
@@ -731,7 +729,7 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
    FILENAME must contain no slashes.  */
 
 int
-dir_file_exists_p (char *dirname, char *filename)
+dir_file_exists_p (const char *dirname, const char *filename)
 {
   return dir_contents_file_exists_p (find_directory (dirname)->contents,
 				     filename);
@@ -740,11 +738,11 @@ dir_file_exists_p (char *dirname, char *filename)
 /* Return 1 if the file named NAME exists.  */
 
 int
-file_exists_p (char *name)
+file_exists_p (const char *name)
 {
-  char *dirend;
-  char *dirname;
-  char *slash;
+  const char *dirend;
+  const char *dirname;
+  const char *slash;
 
 #ifndef	NO_ARCHIVES
   if (ar_name (name))
@@ -762,7 +760,7 @@ file_exists_p (char *name)
 #ifdef HAVE_DOS_PATHS
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    char *bslash = strrchr(name, '\\');
+    const char *bslash = strrchr(name, '\\');
     if (!dirend || bslash > dirend)
       dirend = bslash;
     /* The case of "d:file".  */
@@ -783,15 +781,17 @@ file_exists_p (char *name)
     dirname = "/";
   else
     {
+      char *p;
 #ifdef HAVE_DOS_PATHS
   /* d:/ and d: are *very* different...  */
       if (dirend < name + 3 && name[1] == ':' &&
 	  (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
 	dirend++;
 #endif
-      dirname = alloca (dirend - name + 1);
-      memcpy (dirname, name, dirend - name);
-      dirname[dirend - name] = '\0';
+      p = alloca (dirend - name + 1);
+      memcpy (p, name, dirend - name);
+      p[dirend - name] = '\0';
+      dirname = p;
     }
   return dir_file_exists_p (dirname, slash + 1);
 }
@@ -801,12 +801,12 @@ file_exists_p (char *name)
    as an intermediate file, and it has failed.  */
 
 void
-file_impossible (char *filename)
+file_impossible (const char *filename)
 {
-  char *dirend;
-  register char *p = filename;
-  register struct directory *dir;
-  register struct dirfile *new;
+  const char *dirend;
+  const char *p = filename;
+  struct directory *dir;
+  struct dirfile *new;
 
 #ifdef VMS
   dirend = strrchr (p, ']');
@@ -820,7 +820,7 @@ file_impossible (char *filename)
 # ifdef HAVE_DOS_PATHS
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    char *bslash = strrchr(p, '\\');
+    const char *bslash = strrchr(p, '\\');
     if (!dirend || bslash > dirend)
       dirend = bslash;
     /* The case of "d:file".  */
@@ -837,21 +837,23 @@ file_impossible (char *filename)
 #endif /* VMS */
   else
     {
-      char *dirname;
-      char *slash = dirend;
+      const char *dirname;
+      const char *slash = dirend;
       if (dirend == p)
 	dirname = "/";
       else
 	{
+          char *cp;
 #ifdef HAVE_DOS_PATHS
 	  /* d:/ and d: are *very* different...  */
 	  if (dirend < p + 3 && p[1] == ':' &&
 	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
 	    dirend++;
 #endif
-	  dirname = alloca (dirend - p + 1);
-	  memcpy (dirname, p, dirend - p);
-	  dirname[dirend - p] = '\0';
+	  cp = alloca (dirend - p + 1);
+	  memcpy (cp, p, dirend - p);
+	  cp[dirend - p] = '\0';
+          dirname = cp;
 	}
       dir = find_directory (dirname);
       filename = p = slash + 1;
@@ -861,8 +863,7 @@ file_impossible (char *filename)
     {
       /* The directory could not be stat'd.  We allocate a contents
 	 structure for it, but leave it out of the contents hash table.  */
-      dir->contents = (struct directory_contents *)
-	xmalloc (sizeof (struct directory_contents));
+      dir->contents = xmalloc (sizeof (struct directory_contents));
       memset (dir->contents, '\0', sizeof (struct directory_contents));
     }
 
@@ -875,8 +876,8 @@ file_impossible (char *filename)
   /* Make a new entry and put it in the table.  */
 
   new = xmalloc (sizeof (struct dirfile));
-  new->name = xstrdup (filename);
   new->length = strlen (filename);
+  new->name = strcache_add_len (filename, new->length);
   new->impossible = 1;
   hash_insert (&dir->contents->dirfiles, new);
 }
@@ -884,12 +885,12 @@ file_impossible (char *filename)
 /* Return nonzero if FILENAME has been marked impossible.  */
 
 int
-file_impossible_p (char *filename)
+file_impossible_p (const char *filename)
 {
-  char *dirend;
-  register char *p = filename;
-  register struct directory_contents *dir;
-  register struct dirfile *dirfile;
+  const char *dirend;
+  const char *p = filename;
+  struct directory_contents *dir;
+  struct dirfile *dirfile;
   struct dirfile dirfile_key;
 
 #ifdef VMS
@@ -901,7 +902,7 @@ file_impossible_p (char *filename)
 #ifdef HAVE_DOS_PATHS
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    char *bslash = strrchr(filename, '\\');
+    const char *bslash = strrchr(filename, '\\');
     if (!dirend || bslash > dirend)
       dirend = bslash;
     /* The case of "d:file".  */
@@ -918,21 +919,23 @@ file_impossible_p (char *filename)
 #endif /* VMS */
   else
     {
-      char *dirname;
-      char *slash = dirend;
+      const char *dirname;
+      const char *slash = dirend;
       if (dirend == filename)
 	dirname = "/";
       else
 	{
+          char *cp;
 #ifdef HAVE_DOS_PATHS
 	  /* d:/ and d: are *very* different...  */
 	  if (dirend < filename + 3 && filename[1] == ':' &&
 	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
 	    dirend++;
 #endif
-	  dirname = alloca (dirend - filename + 1);
-	  memcpy (dirname, p, dirend - p);
-	  dirname[dirend - p] = '\0';
+	  cp = alloca (dirend - filename + 1);
+	  memcpy (cp, p, dirend - p);
+	  cp[dirend - p] = '\0';
+          dirname = cp;
 	}
       dir = find_directory (dirname)->contents;
       p = filename = slash + 1;
@@ -954,7 +957,7 @@ file_impossible_p (char *filename)
 
   dirfile_key.name = filename;
   dirfile_key.length = strlen (filename);
-  dirfile = (struct dirfile *) hash_find_item (&dir->dirfiles, &dirfile_key);
+  dirfile = hash_find_item (&dir->dirfiles, &dirfile_key);
   if (dirfile)
     return dirfile->impossible;
 
@@ -964,8 +967,8 @@ file_impossible_p (char *filename)
 /* Return the already allocated name in the
    directory hash table that matches DIR.  */
 
-char *
-dir_name (char *dir)
+const char *
+dir_name (const char *dir)
 {
   return find_directory (dir)->name;
 }
@@ -975,10 +978,10 @@ dir_name (char *dir)
 void
 print_dir_data_base (void)
 {
-  register unsigned int files;
-  register unsigned int impossible;
-  register struct directory **dir_slot;
-  register struct directory **dir_end;
+  unsigned int files;
+  unsigned int impossible;
+  struct directory **dir_slot;
+  struct directory **dir_end;
 
   puts (_("\n# Directories\n"));
 
@@ -988,7 +991,7 @@ print_dir_data_base (void)
   dir_end = dir_slot + directories.ht_size;
   for ( ; dir_slot < dir_end; dir_slot++)
     {
-      register struct directory *dir = *dir_slot;
+      struct directory *dir = *dir_slot;
       if (! HASH_VACANT (dir))
 	{
 	  if (dir->contents == 0)
@@ -1013,16 +1016,16 @@ print_dir_data_base (void)
 	    }
 	  else
 	    {
-	      register unsigned int f = 0;
-	      register unsigned int im = 0;
-	      register struct dirfile **files_slot;
-	      register struct dirfile **files_end;
+	      unsigned int f = 0;
+	      unsigned int im = 0;
+	      struct dirfile **files_slot;
+	      struct dirfile **files_end;
 
 	      files_slot = (struct dirfile **) dir->contents->dirfiles.ht_vec;
 	      files_end = files_slot + dir->contents->dirfiles.ht_size;
 	      for ( ; files_slot < files_end; files_slot++)
 		{
-		  register struct dirfile *df = *files_slot;
+		  struct dirfile *df = *files_slot;
 		  if (! HASH_VACANT (df))
 		    {
 		      if (df->impossible)
@@ -1212,5 +1215,6 @@ hash_init_directories (void)
   hash_init (&directories, DIRECTORY_BUCKETS,
 	     directory_hash_1, directory_hash_2, directory_hash_cmp);
   hash_init (&directory_contents, DIRECTORY_BUCKETS,
-	     directory_contents_hash_1, directory_contents_hash_2, directory_contents_hash_cmp);
+	     directory_contents_hash_1, directory_contents_hash_2,
+             directory_contents_hash_cmp);
 }
diff --git a/expand.c b/expand.c
index 7ca0b92..4aadb26 100644
--- a/expand.c
+++ b/expand.c
@@ -55,7 +55,7 @@ char *variable_buffer;
    the following call.  */
 
 char *
-variable_buffer_output (char *ptr, char *string, unsigned int length)
+variable_buffer_output (char *ptr, const char *string, unsigned int length)
 {
   register unsigned int newlen = length + (ptr - variable_buffer);
 
@@ -159,9 +159,9 @@ recursively_expand_for_file (struct variable *v, struct file *file)
 __inline
 #endif
 static char *
-reference_variable (char *o, char *name, unsigned int length)
+reference_variable (char *o, const char *name, unsigned int length)
 {
-  register struct variable *v;
+  struct variable *v;
   char *value;
 
   v = lookup_variable (name, length);
@@ -190,29 +190,39 @@ reference_variable (char *o, char *name, unsigned int length)
    Write the results to LINE, which must point into `variable_buffer'.  If
    LINE is NULL, start at the beginning of the buffer.
    Return a pointer to LINE, or to the beginning of the buffer if LINE is
-   NULL.  */
-
+   NULL.
+ */
 char *
-variable_expand_string (char *line, char *string, long length)
+variable_expand_string (char *line, const char *string, long length)
 {
   struct variable *v;
-  char *p, *o, *p1;
-  char save_char = '\0';
+  const char *p, *p1;
+  char *abuf = NULL;
+  char *o;
   unsigned int line_offset;
 
   if (!line)
     line = initialize_variable_output();
-
-  p = string;
   o = line;
   line_offset = line - variable_buffer;
 
-  if (length >= 0)
+  if (length == 0)
     {
-      save_char = string[length];
-      string[length] = '\0';
+      variable_buffer_output (o, "", 1);
+      return (variable_buffer);
     }
 
+  /* If we want a subset of the string, allocate a temporary buffer for it.
+     Most of the functions we use here don't work with length limits.  */
+  if (length > 0 && string[length] != '\0')
+    {
+      abuf = xmalloc(length+1);
+      memcpy(abuf, string, length);
+      abuf[length] = '\0';
+      string = abuf;
+    }
+  p = string;
+
   while (1)
     {
       /* Copy all following uninteresting chars all at once to the
@@ -242,10 +252,11 @@ variable_expand_string (char *line, char *string, long length)
 	  {
 	    char openparen = *p;
 	    char closeparen = (openparen == '(') ? ')' : '}';
-	    register char *beg = p + 1;
-	    int free_beg = 0;
-	    char *op, *begp;
-	    char *end, *colon;
+            const char *begp;
+	    const char *beg = p + 1;
+	    char *op;
+            char *abeg = NULL;
+	    const char *end, *colon;
 
 	    op = o;
 	    begp = p;
@@ -281,8 +292,8 @@ variable_expand_string (char *line, char *string, long length)
 		   such as `$($(a)'.  */
 		if (count < 0)
 		  {
-		    beg = expand_argument (beg, p); /* Expand the name.  */
-		    free_beg = 1; /* Remember to free BEG when finished.  */
+		    abeg = expand_argument (beg, p); /* Expand the name.  */
+		    beg = abeg;
 		    end = strchr (beg, '\0');
 		  }
 	      }
@@ -300,7 +311,7 @@ variable_expand_string (char *line, char *string, long length)
 	    if (colon)
 	      {
 		/* This looks like a substitution reference: $(FOO:A=B).  */
-		char *subst_beg, *subst_end, *replace_beg, *replace_end;
+		const char *subst_beg, *subst_end, *replace_beg, *replace_end;
 
 		subst_beg = colon + 1;
 		subst_end = lindex (subst_beg, end, '=');
@@ -373,8 +384,8 @@ variable_expand_string (char *line, char *string, long length)
 		 Look up the value of the variable.  */
 		o = reference_variable (o, beg, end - beg);
 
-	  if (free_beg)
-	    free (beg);
+	  if (abeg)
+	    free (abeg);
 	  }
 	  break;
 
@@ -398,10 +409,10 @@ variable_expand_string (char *line, char *string, long length)
 	++p;
     }
 
-  if (save_char)
-    string[length] = save_char;
+  if (abuf)
+    free (abuf);
 
-  (void)variable_buffer_output (o, "", 1);
+  variable_buffer_output (o, "", 1);
   return (variable_buffer + line_offset);
 }
 
@@ -411,7 +422,7 @@ variable_expand_string (char *line, char *string, long length)
    and is valid only until the next time this function is called.  */
 
 char *
-variable_expand (char *line)
+variable_expand (const char *line)
 {
   return variable_expand_string(NULL, line, (long)-1);
 }
@@ -444,7 +455,7 @@ expand_argument (const char *str, const char *end)
    FILE's commands were found.  Expansion uses FILE's variable set list.  */
 
 char *
-variable_expand_for_file (char *line, struct file *file)
+variable_expand_for_file (const char *line, struct file *file)
 {
   char *result;
   struct variable_set_list *save;
@@ -534,7 +545,7 @@ allocated_variable_append (const struct variable *v)
    This function is called a lot.  It wants to be efficient.  */
 
 char *
-allocated_variable_expand_for_file (char *line, struct file *file)
+allocated_variable_expand_for_file (const char *line, struct file *file)
 {
   char *value;
 
diff --git a/file.c b/file.c
index b2f95e8..638736b 100644
--- a/file.c
+++ b/file.c
@@ -123,7 +123,7 @@ lookup_file (char *name)
 #endif /* VMS */
 
   file_key.hname = name;
-  f = (struct file *) hash_find_item (&files, &file_key);
+  f = hash_find_item (&files, &file_key);
 #if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
   if (*name != '.')
     free (lname);
diff --git a/function.c b/function.c
index 39ad2fe..1dda6d8 100644
--- a/function.c
+++ b/function.c
@@ -42,22 +42,22 @@ struct function_table_entry
 static unsigned long
 function_table_entry_hash_1 (const void *keyv)
 {
-  struct function_table_entry const *key = (struct function_table_entry const *) keyv;
+  const struct function_table_entry *key = keyv;
   return_STRING_N_HASH_1 (key->name, key->len);
 }
 
 static unsigned long
 function_table_entry_hash_2 (const void *keyv)
 {
-  struct function_table_entry const *key = (struct function_table_entry const *) keyv;
+  const struct function_table_entry *key = keyv;
   return_STRING_N_HASH_2 (key->name, key->len);
 }
 
 static int
 function_table_entry_hash_cmp (const void *xv, const void *yv)
 {
-  struct function_table_entry const *x = (struct function_table_entry const *) xv;
-  struct function_table_entry const *y = (struct function_table_entry const *) yv;
+  const struct function_table_entry *x = xv;
+  const struct function_table_entry *y = yv;
   int result = x->len - y->len;
   if (result)
     return result;
@@ -277,7 +277,7 @@ lookup_function (const char *s)
 /* Return 1 if PATTERN matches STR, 0 if not.  */
 
 int
-pattern_matches (char *pattern, char *percent, char *str)
+pattern_matches (const char *pattern, const char *percent, const char *str)
 {
   unsigned int sfxlen, strlength;
 
@@ -286,10 +286,10 @@ pattern_matches (char *pattern, char *percent, char *str)
       unsigned int len = strlen (pattern) + 1;
       char *new_chars = alloca (len);
       memcpy (new_chars, pattern, len);
-      pattern = new_chars;
-      percent = find_percent (pattern);
+      percent = find_percent (new_chars);
       if (percent == 0)
-	return streq (pattern, str);
+	return streq (new_chars, str);
+      pattern = new_chars;
     }
 
   sfxlen = strlen (percent + 1);
@@ -2120,15 +2120,15 @@ expand_builtin_function (char *o, int argc, char **argv,
    *STRINGP past the reference and returning nonzero.  If not, return zero.  */
 
 int
-handle_function (char **op, char **stringp)
+handle_function (char **op, const char **stringp)
 {
   const struct function_table_entry *entry_p;
   char openparen = (*stringp)[0];
   char closeparen = openparen == '(' ? ')' : '}';
-  char *beg;
-  char *end;
+  const char *beg;
+  const char *end;
   int count = 0;
-  register char *p;
+  char *abeg = NULL;
   char **argv, **argvp;
   int nargs;
 
@@ -2175,36 +2175,47 @@ handle_function (char **op, char **stringp)
      not, make a duplicate of the string and point into that, nul-terminating
      each argument.  */
 
-  if (!entry_p->expand_args)
+  if (entry_p->expand_args)
     {
-      int len = end - beg;
+      const char *p;
+      for (p=beg, nargs=0; p <= end; ++argvp)
+        {
+          const char *next;
 
-      p = xmalloc (len+1);
-      memcpy (p, beg, len);
-      p[len] = '\0';
-      beg = p;
-      end = beg + len;
-    }
+          ++nargs;
 
-  for (p=beg, nargs=0; p <= end; ++argvp)
-    {
-      char *next;
+          if (nargs == entry_p->maximum_args
+              || (! (next = find_next_argument (openparen, closeparen, p, end))))
+            next = end;
 
-      ++nargs;
+          *argvp = expand_argument (p, next);
+          p = next + 1;
+        }
+    }
+  else
+    {
+      int len = end - beg;
+      char *p, *aend;
 
-      if (nargs == entry_p->maximum_args
-          || (! (next = find_next_argument (openparen, closeparen, p, end))))
-        next = end;
+      abeg = xmalloc (len+1);
+      memcpy (abeg, beg, len);
+      abeg[len] = '\0';
+      aend = abeg + len;
 
-      if (entry_p->expand_args)
-        *argvp = expand_argument (p, next);
-      else
+      for (p=abeg, nargs=0; p <= aend; ++argvp)
         {
+          char *next;
+
+          ++nargs;
+
+          if (nargs == entry_p->maximum_args
+              || (! (next = find_next_argument (openparen, closeparen, p, aend))))
+            next = aend;
+
           *argvp = p;
           *next = '\0';
+          p = next + 1;
         }
-
-      p = next + 1;
     }
   *argvp = NULL;
 
@@ -2215,8 +2226,8 @@ handle_function (char **op, char **stringp)
   if (entry_p->expand_args)
     for (argvp=argv; *argvp != 0; ++argvp)
       free (*argvp);
-  else
-    free (beg);
+  if (abeg)
+    free (abeg);
 
   return 1;
 }
diff --git a/job.c b/job.c
index 79bdb0d..347c8c6 100644
--- a/job.c
+++ b/job.c
@@ -186,8 +186,6 @@ int getgid ();
 # endif
 #endif
 
-char *allocated_variable_expand_for_file (char *line, struct file *file);
-
 int getloadavg (double loadavg[], int nelem);
 int start_remote_job (char **argv, char **envp, int stdin_fd, int *is_remote,
                       int *id_ptr, int *used_stdin);
@@ -2446,8 +2444,8 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
                   *(ap++) = *(p++);
                   *(ap++) = *p;
                 }
-              /* If there's a TAB here, skip it.  */
-              if (p[1] == '\t')
+              /* If there's a command prefix char here, skip it.  */
+              if (p[1] == cmd_prefix)
                 ++p;
             }
 	  else if (*p == '\n' && restp != NULL)
@@ -2496,8 +2494,9 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 		/* Throw out the backslash and newline.  */
                 ++p;
 
-		/* If there is a tab after a backslash-newline, remove it.  */
-		if (p[1] == '\t')
+		/* If there is a command prefix after a backslash-newline,
+		   remove it.  */
+		if (p[1] == cmd_prefix)
                   ++p;
 
                 /* If there's nothing in this argument yet, skip any
@@ -2744,7 +2743,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 	      }
 
 	    ++p;
-	    if (p[1] == '\t')
+	    if (p[1] == cmd_prefix)
 	      ++p;
 
 	    continue;
@@ -2835,8 +2834,9 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
             if (q[0] == '\\' && q[1] == '\n')
               {
                 q += 2; /* remove '\\' and '\n' */
-                if (q[0] == '\t')
-                  q++; /* remove 1st tab in the next line */
+		/* Remove any command prefix in the next line */
+                if (q[0] == cmd_prefix)
+                  q++;
               }
             else
               *p++ = *q++;
diff --git a/main.c b/main.c
index 126c914..ba7f87d 100644
--- a/main.c
+++ b/main.c
@@ -107,14 +107,14 @@ struct command_switch
 	ignore			/* Ignored.  */
       } type;
 
-    char *value_ptr;	/* Pointer to the value-holding variable.  */
+    void *value_ptr;	/* Pointer to the value-holding variable.  */
 
     unsigned int env:1;		/* Can come from MAKEFLAGS.  */
     unsigned int toenv:1;	/* Should be put in MAKEFLAGS.  */
     unsigned int no_makefile:1;	/* Don't propagate when remaking makefiles.  */
 
-    char *noarg_value;	/* Pointer to value used if no argument is given.  */
-    char *default_value;/* Pointer to default value.  */
+    const void *noarg_value;	/* Pointer to value used if no arg given.  */
+    const void *default_value;	/* Pointer to default value.  */
 
     char *long_name;		/* Long option name.  */
   };
@@ -157,6 +157,10 @@ static int debug_flag = 0;
 
 int db_level = 0;
 
+/* Output level (--verbosity).  */
+
+static struct stringlist *verbosity_flags;
+
 #ifdef WINDOWS32
 /* Suspend make in main for a short time to allow debugger to attach */
 
@@ -281,6 +285,10 @@ int rebuilding_makefiles = 0;
 
 struct variable shell_var;
 
+/* This character introduces a command: it's the first char on the line.  */
+
+char cmd_prefix = '\t';
+
 
 /* The usage output.  We write it this way to make life easier for the
    translators, especially those trying to translate to right-to-left
@@ -362,59 +370,52 @@ static const char *const usage[] =
 static const struct command_switch switches[] =
   {
     { 'b', ignore, 0, 0, 0, 0, 0, 0, 0 },
-    { 'B', flag, (char *) &always_make_set, 1, 1, 0, 0, 0, "always-make" },
-    { 'C', string, (char *) &directories, 0, 0, 0, 0, 0, "directory" },
-    { 'd', flag, (char *) &debug_flag, 1, 1, 0, 0, 0, 0 },
-    { CHAR_MAX+1, string, (char *) &db_flags, 1, 1, 0, "basic", 0, "debug" },
+    { 'B', flag, &always_make_set, 1, 1, 0, 0, 0, "always-make" },
+    { 'C', string, &directories, 0, 0, 0, 0, 0, "directory" },
+    { 'd', flag, &debug_flag, 1, 1, 0, 0, 0, 0 },
+    { CHAR_MAX+1, string, &db_flags, 1, 1, 0, "basic", 0, "debug" },
 #ifdef WINDOWS32
-    { 'D', flag, (char *) &suspend_flag, 1, 1, 0, 0, 0, "suspend-for-debug" },
-#endif
-    { 'e', flag, (char *) &env_overrides, 1, 1, 0, 0, 0,
-      "environment-overrides", },
-    { 'f', string, (char *) &makefiles, 0, 0, 0, 0, 0, "file" },
-    { 'h', flag, (char *) &print_usage_flag, 0, 0, 0, 0, 0, "help" },
-    { 'i', flag, (char *) &ignore_errors_flag, 1, 1, 0, 0, 0,
-      "ignore-errors" },
-    { 'I', string, (char *) &include_directories, 1, 1, 0, 0, 0,
+    { 'D', flag, &suspend_flag, 1, 1, 0, 0, 0, "suspend-for-debug" },
+#endif
+    { 'e', flag, &env_overrides, 1, 1, 0, 0, 0, "environment-overrides", },
+    { 'f', string, &makefiles, 0, 0, 0, 0, 0, "file" },
+    { 'h', flag, &print_usage_flag, 0, 0, 0, 0, 0, "help" },
+    { 'i', flag, &ignore_errors_flag, 1, 1, 0, 0, 0, "ignore-errors" },
+    { 'I', string, &include_directories, 1, 1, 0, 0, 0,
       "include-dir" },
-    { 'j', positive_int, (char *) &job_slots, 1, 1, 0, (char *) &inf_jobs,
-      (char *) &default_job_slots, "jobs" },
-    { CHAR_MAX+2, string, (char *) &jobserver_fds, 1, 1, 0, 0, 0,
-      "jobserver-fds" },
-    { 'k', flag, (char *) &keep_going_flag, 1, 1, 0, 0,
-      (char *) &default_keep_going_flag, "keep-going" },
+    { 'j', positive_int, &job_slots, 1, 1, 0, &inf_jobs, &default_job_slots,
+      "jobs" },
+    { CHAR_MAX+2, string, &jobserver_fds, 1, 1, 0, 0, 0, "jobserver-fds" },
+    { 'k', flag, &keep_going_flag, 1, 1, 0, 0, &default_keep_going_flag,
+      "keep-going" },
 #ifndef NO_FLOAT
-    { 'l', floating, (char *) &max_load_average, 1, 1, 0,
-      (char *) &default_load_average, (char *) &default_load_average,
-      "load-average" },
+    { 'l', floating, &max_load_average, 1, 1, 0, &default_load_average,
+      &default_load_average, "load-average" },
 #else
-    { 'l', positive_int, (char *) &max_load_average, 1, 1, 0,
-      (char *) &default_load_average, (char *) &default_load_average,
-      "load-average" },
+    { 'l', positive_int, &max_load_average, 1, 1, 0, &default_load_average,
+      &default_load_average, "load-average" },
 #endif
-    { 'L', flag, (char *) &check_symlink_flag, 1, 1, 0, 0, 0,
-      "check-symlink-times" },
+    { 'L', flag, &check_symlink_flag, 1, 1, 0, 0, 0, "check-symlink-times" },
     { 'm', ignore, 0, 0, 0, 0, 0, 0, 0 },
-    { 'n', flag, (char *) &just_print_flag, 1, 1, 1, 0, 0, "just-print" },
-    { 'o', string, (char *) &old_files, 0, 0, 0, 0, 0, "old-file" },
-    { 'p', flag, (char *) &print_data_base_flag, 1, 1, 0, 0, 0,
-      "print-data-base" },
-    { 'q', flag, (char *) &question_flag, 1, 1, 1, 0, 0, "question" },
-    { 'r', flag, (char *) &no_builtin_rules_flag, 1, 1, 0, 0, 0,
-      "no-builtin-rules" },
-    { 'R', flag, (char *) &no_builtin_variables_flag, 1, 1, 0, 0, 0,
+    { 'n', flag, &just_print_flag, 1, 1, 1, 0, 0, "just-print" },
+    { 'o', string, &old_files, 0, 0, 0, 0, 0, "old-file" },
+    { 'p', flag, &print_data_base_flag, 1, 1, 0, 0, 0, "print-data-base" },
+    { 'q', flag, &question_flag, 1, 1, 1, 0, 0, "question" },
+    { 'r', flag, &no_builtin_rules_flag, 1, 1, 0, 0, 0, "no-builtin-rules" },
+    { 'R', flag, &no_builtin_variables_flag, 1, 1, 0, 0, 0,
       "no-builtin-variables" },
-    { 's', flag, (char *) &silent_flag, 1, 1, 0, 0, 0, "silent" },
-    { 'S', flag_off, (char *) &keep_going_flag, 1, 1, 0, 0,
-      (char *) &default_keep_going_flag, "no-keep-going" },
-    { 't', flag, (char *) &touch_flag, 1, 1, 1, 0, 0, "touch" },
-    { 'v', flag, (char *) &print_version_flag, 1, 1, 0, 0, 0, "version" },
-    { 'w', flag, (char *) &print_directory_flag, 1, 1, 0, 0, 0,
-      "print-directory" },
-    { CHAR_MAX+3, flag, (char *) &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
+    { 's', flag, &silent_flag, 1, 1, 0, 0, 0, "silent" },
+    { 'S', flag_off, &keep_going_flag, 1, 1, 0, 0, &default_keep_going_flag,
+      "no-keep-going" },
+    { 't', flag, &touch_flag, 1, 1, 1, 0, 0, "touch" },
+    { 'v', flag, &print_version_flag, 1, 1, 0, 0, 0, "version" },
+    { CHAR_MAX+3, string, &verbosity_flags, 1, 1, 0, 0, 0,
+      "verbosity" },
+    { 'w', flag, &print_directory_flag, 1, 1, 0, 0, 0, "print-directory" },
+    { CHAR_MAX+4, flag, &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
       "no-print-directory" },
-    { 'W', string, (char *) &new_files, 0, 0, 0, 0, 0, "what-if" },
-    { CHAR_MAX+4, flag, (char *) &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
+    { 'W', string, &new_files, 0, 0, 0, 0, 0, "what-if" },
+    { CHAR_MAX+5, flag, &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
       "warn-undefined-variables" },
     { 0, 0, 0, 0, 0, 0, 0, 0, 0 }
   };
@@ -831,15 +832,14 @@ find_and_set_default_shell (char *token)
 }
 #endif  /* WINDOWS32 */
 
-#ifdef  __MSDOS__
-
+#ifdef __MSDOS__
 static void
 msdos_return_to_initial_directory (void)
 {
   if (directory_before_chdir)
     chdir (directory_before_chdir);
 }
-#endif
+#endif  /* __MSDOS__ */
 
 char *mktemp (char *template);
 int mkstemp (char *template);
@@ -1291,7 +1291,7 @@ main (int argc, char **argv, char **envp)
   if (current_directory[0] != '\0'
       && argv[0] != 0
       && (argv[0][0] != '/' && (argv[0][0] == '\0' || argv[0][1] != ':'))
-#ifdef __EMX__
+# ifdef __EMX__
       /* do not prepend cwd if argv[0] contains no '/', e.g. "make" */
       && (strchr (argv[0], '/') != 0 || strchr (argv[0], '\\') != 0)
 # endif
@@ -1299,7 +1299,12 @@ main (int argc, char **argv, char **envp)
     argv[0] = concat (current_directory, "/", argv[0]);
 #else  /* !__MSDOS__ */
   if (current_directory[0] != '\0'
-      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0)
+      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0
+#ifdef HAVE_DOS_PATHS
+      && (argv[0][0] != '\\' && (!argv[0][0] || argv[0][1] != ':'))
+      && strchr (argv[0], '\\') != 0
+#endif
+      )
     argv[0] = concat (current_directory, "/", argv[0]);
 #endif /* !__MSDOS__ */
 #endif /* WINDOWS32 */
@@ -1670,6 +1675,9 @@ main (int argc, char **argv, char **envp)
       fatal (NILF,
              _("internal error: invalid --jobserver-fds string `%s'"), cp);
 
+    DB (DB_JOBS,
+	(_("Jobserver client (fds %d,%d)\n"), job_fds[0], job_fds[1]));
+
     /* The combination of a pipe + !job_slots means we're using the
        jobserver.  If !job_slots and we don't have a pipe, we can start
        infinite jobs.  If we see both a pipe and job_slots >0 that means the
@@ -2468,7 +2476,7 @@ decode_switches (int argc, char **argv, int env)
 		    break;
 
 		  if (optarg == 0)
-		    optarg = cs->noarg_value;
+		    optarg = xstrdup (cs->noarg_value);
                   else if (*optarg == '\0')
                     {
                       error (NILF, _("the `-%c' option requires a non-empty string argument"),
diff --git a/make.h b/make.h
index 316d9c7..08f5543 100644
--- a/make.h
+++ b/make.h
@@ -396,17 +396,28 @@ char *find_percent (char *);
 FILE *open_tmpfile (char **, const char *);
 
 #ifndef NO_ARCHIVES
-int ar_name (char *);
-void ar_parse_name (char *, char **, char **);
-int ar_touch (char *);
-time_t ar_member_date (char *);
+int ar_name (const char *);
+void ar_parse_name (const char *, char **, char **);
+int ar_touch (const char *);
+time_t ar_member_date (const char *);
+
+typedef long int (*ar_member_func_t) (int desc, const char *mem, int truncated,
+				      long int hdrpos, long int datapos,
+				      long int size, long int date, int uid,
+				      int gid, int mode, const void *arg);
+
+long int ar_scan (const char *archive, ar_member_func_t function, const void *arg);
+int ar_name_equal (const char *name, const char *mem, int truncated);
+#ifndef VMS
+int ar_member_touch (const char *arname, const char *memname);
+#endif
 #endif
 
-int dir_file_exists_p (char *, char *);
-int file_exists_p (char *);
-int file_impossible_p (char *);
-void file_impossible (char *);
-char *dir_name (char *);
+int dir_file_exists_p (const char *, const char *);
+int file_exists_p (const char *);
+int file_impossible_p (const char *);
+void file_impossible (const char *);
+const char *dir_name (const char *);
 void hash_init_directories (void);
 
 void define_default_variables (void);
@@ -417,7 +428,7 @@ void install_default_implicit_rules (void);
 void build_vpath_lists (void);
 void construct_vpath_list (char *pattern, char *dirpath);
 int vpath_search (char **file, FILE_TIMESTAMP *mtime_ptr);
-int gpath_search (char *file, unsigned int len);
+int gpath_search (const char *file, unsigned int len);
 
 void construct_include_path (char **arg_dirs);
 
@@ -477,6 +488,8 @@ extern int second_expansion, clock_skew_detected, rebuilding_makefiles;
 /* can we run commands via 'sh -c xxx' or must we use batch files? */
 extern int batch_mode_shell;
 
+extern char cmd_prefix;
+
 extern unsigned int job_slots;
 extern int job_fds[2];
 extern int job_rfd;
@@ -574,4 +587,3 @@ extern int handling_fatal_signal;
 
 #define ENULLLOOP(_v,_c)   do{ errno = 0; \
                                while (((_v)=_c)==0 && errno==EINTR); }while(0)
-
diff --git a/read.c b/read.c
index b7b5bc7..6b0c0aa 100644
--- a/read.c
+++ b/read.c
@@ -527,7 +527,7 @@ eval (struct ebuffer *ebuf, int set_default)
 
       /* Check for a shell command line first.
 	 If it is not one, we can stop treating tab specially.  */
-      if (line[0] == '\t')
+      if (line[0] == cmd_prefix)
 	{
 	  if (no_targets)
 	    /* Ignore the commands in a rule with no targets.  */
@@ -848,7 +848,7 @@ eval (struct ebuffer *ebuf, int set_default)
       /* This line starts with a tab but was not caught above because there
          was no preceding target, and the line might have been usable as a
          variable definition.  But now we know it is definitely lossage.  */
-      if (line[0] == '\t')
+      if (line[0] == cmd_prefix)
         fatal(fstart, _("commands commence before first target"));
 
       /* This line describes some target files.  This is complicated by
@@ -1351,7 +1351,7 @@ do_define (char *name, unsigned int namelen,
          another define, or ends one.  */
 
       /* Stop if we find an 'endef' */
-      if (line[0] != '\t')
+      if (line[0] != cmd_prefix)
         {
           p = next_token (line);
           len = strlen (p);
@@ -2223,7 +2223,7 @@ find_char_unquote (char *string, int stop1, int stop2, int blank,
   return 0;
 }
 
-/* Search PATTERN for an unquoted %.  */
+/* Search PATTERN for an unquoted % and handle quoting.  */
 
 char *
 find_percent (char *pattern)
diff --git a/remake.c b/remake.c
index 8d17ce7..ea6e555 100644
--- a/remake.c
+++ b/remake.c
@@ -921,12 +921,11 @@ notice_finished_file (struct file *file)
     file->update_status = 0;
 }
 
-/* Check whether another file (whose mtime is THIS_MTIME)
-   needs updating on account of a dependency which is file FILE.
-   If it does, store 1 in *MUST_MAKE_PTR.
-   In the process, update any non-intermediate files
-   that FILE depends on (including FILE itself).
-   Return nonzero if any updating failed.  */
+/* Check whether another file (whose mtime is THIS_MTIME) needs updating on
+   account of a dependency which is file FILE.  If it does, store 1 in
+   *MUST_MAKE_PTR.  In the process, update any non-intermediate files that
+   FILE depends on (including FILE itself).  Return nonzero if any updating
+   failed.  */
 
 static int
 check_dep (struct file *file, unsigned int depth,
@@ -940,8 +939,8 @@ check_dep (struct file *file, unsigned int depth,
 
   if (file->phony || !file->intermediate)
     {
-      /* If this is a non-intermediate file, update it and record
-         whether it is newer than THIS_MTIME.  */
+      /* If this is a non-intermediate file, update it and record whether it
+         is newer than THIS_MTIME.  */
       FILE_TIMESTAMP mtime;
       dep_status = update_file (file, depth);
       check_renamed (file);
@@ -970,18 +969,18 @@ check_dep (struct file *file, unsigned int depth,
 	  file->cmds = default_file->cmds;
 	}
 
-      /* If the intermediate file actually exists
-	 and is newer, then we should remake from it.  */
       check_renamed (file);
       mtime = file_mtime (file);
       check_renamed (file);
       if (mtime != NONEXISTENT_MTIME && mtime > this_mtime)
+        /* If the intermediate file actually exists and is newer, then we
+           should remake from it.  */
 	*must_make_ptr = 1;
-	  /* Otherwise, update all non-intermediate files we depend on,
-	     if necessary, and see whether any of them is more
-	     recent than the file on whose behalf we are checking.  */
       else
 	{
+          /* Otherwise, update all non-intermediate files we depend on, if
+             necessary, and see whether any of them is more recent than the
+             file on whose behalf we are checking.  */
 	  struct dep *lastd;
 
 	  lastd = 0;
diff --git a/strcache.c b/strcache.c
index 33dcaf1..5b72399 100644
--- a/strcache.c
+++ b/strcache.c
@@ -155,11 +155,17 @@ strcache_add (const char *str)
 const char *
 strcache_add_len (const char *str, int len)
 {
-  char *key = alloca (len + 1);
-  memcpy (key, str, len);
-  key[len] = '\0';
+  /* If we're not given a nul-terminated string we have to create one, because
+     the hashing functions expect it.  */
+  if (str[len] != '\0')
+    {
+      char *key = alloca (len + 1);
+      memcpy (key, str, len);
+      key[len] = '\0';
+      str = key;
+    }
 
-  return add_hash (key, len);
+  return add_hash (str, len);
 }
 
 int
diff --git a/variable.c b/variable.c
index 098a941..8a82a3f 100644
--- a/variable.c
+++ b/variable.c
@@ -159,7 +159,7 @@ init_hash_global_variable_set (void)
 
 struct variable *
 define_variable_in_set (const char *name, unsigned int length,
-                        char *value, enum variable_origin origin,
+                        const char *value, enum variable_origin origin,
                         int recursive, struct variable_set *set,
                         const struct floc *flocp)
 {
diff --git a/variable.h b/variable.h
index 783fb62..937a88e 100644
--- a/variable.h
+++ b/variable.h
@@ -109,20 +109,20 @@ extern char *variable_buffer;
 extern struct variable_set_list *current_variable_set_list;
 
 /* expand.c */
-char *variable_buffer_output (char *ptr, char *string, unsigned int length);
-char *variable_expand (char *line);
-char *variable_expand_for_file (char *line, struct file *file);
-char *allocated_variable_expand_for_file (char *line, struct file *file);
+char *variable_buffer_output (char *ptr, const char *string, unsigned int length);
+char *variable_expand (const char *line);
+char *variable_expand_for_file (const char *line, struct file *file);
+char *allocated_variable_expand_for_file (const char *line, struct file *file);
 #define	allocated_variable_expand(line) \
   allocated_variable_expand_for_file (line, (struct file *) 0)
 char *expand_argument (const char *str, const char *end);
-char *variable_expand_string (char *line, char *string, long length);
+char *variable_expand_string (char *line, const char *string, long length);
 void install_variable_buffer (char **bufp, unsigned int *lenp);
 void restore_variable_buffer (char *buf, unsigned int len);
 
 /* function.c */
-int handle_function (char **op, char **stringp);
-int pattern_matches (char *pattern, char *percent, char *str);
+int handle_function (char **op, const char **stringp);
+int pattern_matches (const char *pattern, const char *percent, const char *str);
 char *subst_expand (char *o, char *text, char *subst, char *replace,
                     unsigned int slen, unsigned int rlen, int by_word);
 char *patsubst_expand (char *o, char *text, char *pattern, char *replace,
@@ -159,7 +159,7 @@ struct variable *lookup_variable_in_set (const char *name, unsigned int length,
                                          const struct variable_set *set);
 
 struct variable *define_variable_in_set (const char *name, unsigned int length,
-                                         char *value,
+                                         const char *value,
                                          enum variable_origin origin,
                                          int recursive,
                                          struct variable_set *set,
diff --git a/vmsdir.h b/vmsdir.h
index a4bd6f1..51fe9ef 100644
--- a/vmsdir.h
+++ b/vmsdir.h
@@ -72,6 +72,6 @@ typedef struct DIR
 DIR *opendir ();
 struct direct *readdir (DIR *dfd);
 int closedir (DIR *dfd);
-char *vmsify (char *name, int type);
+const char *vmsify (const char *name, int type);
 
 #endif /* VMSDIR_H */
diff --git a/vmsify.c b/vmsify.c
index d9f7df4..7ab4481 100644
--- a/vmsify.c
+++ b/vmsify.c
@@ -63,9 +63,9 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.  */
 */
 
 static int
-copyto (char **to, char **from, char upto, int as_dir)
+copyto (char **to, const char **from, char upto, int as_dir)
 {
-  char *s;
+  const char *s;
 
   s = strrchr (*from, '.');
 
@@ -111,7 +111,7 @@ copyto (char **to, char **from, char upto, int as_dir)
 */
 
 static char *
-trnlog (char *name)
+trnlog (const char *name)
 {
   int stat;
   static char reslt[1024];
@@ -205,11 +205,12 @@ enum namestate { N_START, N_DEVICE, N_OPEN, N_DOT, N_CLOSED, N_DONE };
 25  filenames with ':' are left unchanged
 26  filenames with a single pair of '[' ']' are left unchanged
 
-  the input string is not written to
+  The input string is not written to.  The result is also const because
+  it's a static buffer; we don't want to change it.
 */
 
-char *
-vmsify (char *name, int type)
+const char *
+vmsify (const char *name, int type)
 {
 /* max 255 device
    max 39 directory
@@ -221,9 +222,9 @@ vmsify (char *name, int type)
 
   enum namestate nstate;
   static char vmsname[MAXPATHLEN+1];
-  char *fptr;
+  const char *fptr;
+  const char *t;
   char *vptr;
-  char *s,*s1;
   int as_dir;
   int count;
 
@@ -234,69 +235,57 @@ vmsify (char *name, int type)
   nstate = N_START;
 
   /* case 25a */
+  t = strpbrk (name, "$:");
 
-  s = strpbrk (name, "$:");
-  if (s != 0)
+  if (t != 0)
     {
-      char *s1;
-      char *s2;
+      const char *s1;
+      const char *s2;
 
       if (type == 1)
-	{
-	  s1 = strchr (s+1, '[');
-	  s2 = strchr (s+1, ']');
-	}
+        {
+          s1 = strchr (t+1, '[');
+          s2 = strchr (t+1, ']');
+        }
 
-      if (*s == '$')
-	{
-	  if (strchr (name, '/') == 0)
-	    {
-	      if ((type == 1) && (s1 != 0) && (s2 == 0))
-		{
-		  strcpy (vmsname, name);
-		  strcat (vmsname, "]");
-		  return vmsname;
-		}
-	      else
-		return name;
-	    }
-	}
+      if (*t == '$')
+        {
+          if (strchr (name, '/') == 0)
+            {
+              strcpy (vmsname, name);
+              if ((type == 1) && (s1 != 0) && (s2 == 0))
+                strcat (vmsname, "]");
+              return vmsname;
+            }
+        }
       else
-	{
-	  if ((type == 1) && (s1 != 0) && (s2 == 0))
-	    {
-	      strcpy (vmsname, name);
-	      strcat (vmsname, "]");
-	      return vmsname;
-	    }
-	  else
-	    return name;
-	}
+        {
+          strcpy (vmsname, name);
+          if ((type == 1) && (s1 != 0) && (s2 == 0))
+            strcat (vmsname, "]");
+          return vmsname;
+        }
     }
 
   /* case 26 */
+  t = strchr (name, '[');
 
-  s = strchr (name, '[');
-
-  if (s != 0)
+  if (t != 0)
     {
-      s1 = strchr (s+1, '[');
+      const char *s;
+      const char *s1 = strchr (t+1, '[');
       if (s1 == 0)
 	{
-	  if ((type == 1)
-	       && (strchr (s+1, ']') == 0))
-	    {
-	      strcpy (vmsname, name);
-	      strcat (vmsname, "]");
-	      return vmsname;
-	    }
-	  else
-	    return name;			/* single [, keep unchanged */
+          strcpy (vmsname, name);
+	  if ((type == 1) && (strchr (t+1, ']') == 0))
+            strcat (vmsname, "]");
+          return vmsname;
 	}
       s1--;
       if (*s1 != ']')
 	{
-	  return name;			/* not ][, keep unchanged */
+          strcpy (vmsname, name);
+	  return vmsname;		/* not ][, keep unchanged */
 	}
 
       /* we have ][ */
@@ -305,7 +294,6 @@ vmsify (char *name, int type)
 
       /* s  -> starting char
 	 s1 -> ending ']'  */
-
       do
 	{
 	  strncpy (vptr, s, s1-s);	/* copy up to but not including ']' */
@@ -329,19 +317,13 @@ vmsify (char *name, int type)
       fptr = s;
 
     }
-
   else		/* no [ in name */
-
     {
-
-      int state;
+      int state = 0;
       int rooted = 1;	/* flag if logical is rooted, else insert [000000] */
 
-      state = 0;
-
       do
 	{
-
       switch (state)
 	{
 	  case 0:				/* start of loop */
@@ -370,7 +352,8 @@ vmsify (char *name, int type)
 	    break;
 
 	  case 2:				/* no '/' at start */
-	    s = strchr (fptr, '/');
+            {
+            const char *s = strchr (fptr, '/');
 	    if (s == 0)			/* no '/' (16) */
 	      {
 		if (type == 1)
@@ -401,8 +384,13 @@ vmsify (char *name, int type)
 		  }
 	      }
 	    break;
+            }
 
 	  case 3:				/* '//' at start */
+            {
+            const char *s;
+            const char *s1;
+            char *vp;
 	    while (*fptr == '/')	/* collapse all '/' */
 	      fptr++;
 	    if (*fptr == 0)		/* just // */
@@ -412,12 +400,14 @@ vmsify (char *name, int type)
 		s1 = getcwd(cwdbuf, MAXPATHLEN);
 		if (s1 == 0)
 		  {
-		    return "";		/* FIXME, err getcwd */
+                    vmsname[0] = '\0';
+		    return vmsname;	/* FIXME, err getcwd */
 		  }
 		s = strchr (s1, ':');
 		if (s == 0)
 		  {
-		    return "";		/* FIXME, err no device */
+                    vmsname[0] = '\0';
+		    return vmsname;	/* FIXME, err no device */
 		  }
 		strncpy (vptr, s1, s-s1+1);
 		vptr += s-s1+1;
@@ -444,28 +434,27 @@ vmsify (char *name, int type)
 	      }
 	    *vptr = 0;
 				/* check logical for [000000] insertion */
-	    s1 = trnlog (s);
-	    if (*s1 != 0)
+	    vp = trnlog (s);
+	    if (*vp != '\0')
 	      {			/* found translation */
-		char *s2;
 		for (;;)	/* loop over all nested logicals */
 		  {
-		    s2 = s1 + strlen (s1) - 1;
-		    if (*s2 == ':')	/* translation ends in ':' */
+		    char *vp2 = vp + strlen (vp) - 1;
+		    if (*vp2 == ':')	/* translation ends in ':' */
 		      {
-			s2 = trnlog (s1);
-			free (s1);
-			if (*s2 == 0)
+			vp2 = trnlog (vp);
+			free (vp);
+			if (*vp2 == 0)
 			  {
 			    rooted = 0;
 			    break;
 			  }
-			s1 = s2;
+			vp = vp2;
 			continue;	/* next iteration */
 		      }
-		    if (*s2 == ']')	/* translation ends in ']' */
+		    if (*vp2 == ']')	/* translation ends in ']' */
 		      {
-			if (*(s2-1) == '.')	/* ends in '.]' */
+			if (*(vp2-1) == '.')	/* ends in '.]' */
 			  {
 			    if (strncmp (fptr, "000000", 6) != 0)
 			      rooted = 0;
@@ -473,15 +462,15 @@ vmsify (char *name, int type)
 			else
 			  {
 			    strcpy (vmsname, s1);
-			    s = strchr (vmsname, ']');
-			    *s = '.';
+			    vp = strchr (vmsname, ']');
+			    *vp = '.';
 			    nstate = N_DOT;
-			    vptr = s;
+			    vptr = vp;
 			  }
 		      }
 		    break;
 		  }
-		free (s1);
+		free (vp);
 	      }
 	    else
 	      rooted = 0;
@@ -496,15 +485,15 @@ vmsify (char *name, int type)
 
 	    if (rooted == 0)
 	      {
+		nstate = N_DOT;
 	        strcpy (vptr, "[000000.");
 		vptr += 8;
-		s1 = vptr-1;
-		nstate = N_DOT;
+		vp = vptr-1;
 	      }
 	    else
-	      s1 = 0;
+	      vp = 0;
 
-	/* s1-> '.' after 000000 or NULL */
+            /* vp-> '.' after 000000 or NULL */
 
 	    s = strchr (fptr, '/');
 	    if (s == 0)
@@ -531,18 +520,18 @@ vmsify (char *name, int type)
 	      }
 	    else
 	      if ((nstate == N_DOT)
-		 && (s1 != 0)
+		 && (vp != 0)
 		 && (*(s+1) == 0))
 		{
 		  if (type == 2)
 		    {
-		      *s1 = ']';
+		      *vp = ']';
 		      nstate = N_CLOSED;
 		    }
 		}
 	    state = 9;
 	    break;
-
+            }
 	  case 4:				/* single '/' at start (9..15) */
 	    if (*fptr == 0)
 	      state = 5;
@@ -564,7 +553,9 @@ vmsify (char *name, int type)
 	      state = 8;
 	    break;
 
-	  case 6:				/* chars following '/' at start 10..15 */
+	  case 6:		/* chars following '/' at start 10..15 */
+            {
+            const char *s;
 	    *vptr++ = '[';
 	    nstate = N_OPEN;
 	    s = strchr (fptr, '/');
@@ -595,24 +586,25 @@ vmsify (char *name, int type)
 		state = 9;
 	      }
 	    break;
+            }
 
 	  case 7:				/* add '.dir' and exit */
 	    if ((nstate == N_OPEN)
 		|| (nstate == N_DOT))
 	      {
-		s = vptr-1;
-		while (s > vmsname)
+		char *vp = vptr-1;
+		while (vp > vmsname)
 		  {
-		    if (*s == ']')
+		    if (*vp == ']')
 		      {
 			break;
 		      }
-		    if (*s == '.')
+		    if (*vp == '.')
 		      {
-			*s = ']';
+			*vp = ']';
 			break;
 		      }
-		    s--;
+		    vp--;
 		  }
 	      }
 	    strcpy (vptr, ".dir");
@@ -625,7 +617,9 @@ vmsify (char *name, int type)
 	    state = -1;
 	    break;
 
-	  case 9:				/* 17..21, fptr -> 1st '/' + 1 */
+	  case 9:			/* 17..21, fptr -> 1st '/' + 1 */
+            {
+            const char *s;
 	    if (*fptr == 0)
 	      {
 		if (type == 2)
@@ -687,6 +681,7 @@ vmsify (char *name, int type)
 		&& ((*(fptr+2) == '/')
 		    || (*(fptr+2) == 0)) )
 	      {
+                char *vp;
 		fptr += 2;
 		if (*fptr == '/')
 		  {
@@ -699,29 +694,29 @@ vmsify (char *name, int type)
 		else if (*fptr == 0)
 		  type = 1;
 		vptr--;				/* vptr -> '.' or ']' */
-		s1 = vptr;
+		vp = vptr;
 		for (;;)
 		  {
-		    s1--;
-		    if (*s1 == '.')		/* one back */
+		    vp--;
+		    if (*vp == '.')		/* one back */
 		      {
-			vptr = s1;
+			vptr = vp;
 			nstate = N_OPEN;
 			break;
 		      }
-		    if (*s1 == '[')		/* top level reached */
+		    if (*vp == '[')		/* top level reached */
 		      {
 			if (*fptr == 0)
 			  {
-			    strcpy (s1, "[000000]");
-			    vptr = s1 + 8;
+			    strcpy (vp, "[000000]");
+			    vptr = vp + 8;
 			    nstate = N_CLOSED;
 			    s = 0;
 			    break;
 			  }
 			else
 			  {
-			    vptr = s1+1;
+			    vptr = vp+1;
 			    nstate = N_OPEN;
 			    break;
 			  }
@@ -756,6 +751,7 @@ vmsify (char *name, int type)
 		  }
 	      }
 	    break;
+            }
 
 	  case 10:				/* 1,2 first is '.' */
 	    if (*fptr == '.')
@@ -773,7 +769,8 @@ vmsify (char *name, int type)
 	      {
 		if (*fptr != '/')		/* got ..xxx */
 		  {
-		    return name;
+                    strcpy (vmsname, name);
+		    return vmsname;
 		  }
 		do				/* got ../ */
 		  {
@@ -791,42 +788,44 @@ vmsify (char *name, int type)
 		while (*fptr == '/');
 	      }
 	    {					/* got '..' or '../' */
+              char *vp;
 	      char cwdbuf[MAXPATHLEN+1];
 
-	      s1 = getcwd(cwdbuf, MAXPATHLEN);
-	      if (s1 == 0)
+	      vp = getcwd(cwdbuf, MAXPATHLEN);
+	      if (vp == 0)
 		{
-		  return "";	    /* FIXME, err getcwd */
+                  vmsname[0] = '\0';
+		  return vmsname;    /* FIXME, err getcwd */
 		}
-	      strcpy (vptr, s1);
-	      s = strchr (vptr, ']');
-	      if (s != 0)
+	      strcpy (vptr, vp);
+	      vp = strchr (vptr, ']');
+	      if (vp != 0)
 		{
 		  nstate = N_OPEN;
-		  while (s > vptr)
+		  while (vp > vptr)
 		    {
-		      s--;
-		      if (*s == '[')
+		      vp--;
+		      if (*vp == '[')
 			{
-			  s++;
-			  strcpy (s, "000000]");
+			  vp++;
+			  strcpy (vp, "000000]");
 			  state = -1;
 			  break;
 			}
-		      else if (*s == '.')
+		      else if (*vp == '.')
 			{
 			  if (--count == 0)
 			    {
 			      if (*fptr == 0)	/* had '..' or '../' */
 				{
-				  *s++ = ']';
+				  *vp++ = ']';
 				  state = -1;
 				}
 			      else			/* had '../xxx' */
 				{
 				  state = 9;
 				}
-			      *s = 0;
+			      *vp = '\0';
 			      break;
 			    }
 			}
@@ -841,40 +840,43 @@ vmsify (char *name, int type)
 	      {
 		if (*fptr != '/')
 		  {
-		    return name;
+                    strcpy (vmsname, name);
+		    return vmsname;
 		  }
 		while (*fptr == '/')
 		  fptr++;
 	      }
 
 	    {
+              char *vp;
 	      char cwdbuf[MAXPATHLEN+1];
 
-	      s1 = getcwd(cwdbuf, MAXPATHLEN);
-	      if (s1 == 0)
-		{
-		  return "";	    /*FIXME, err getcwd */
-		}
-	      strcpy (vptr, s1);
-	      if (*fptr == 0)
+	      vp = getcwd(cwdbuf, MAXPATHLEN);
+	      if (vp == 0)
 		{
-		  state = -1;
-		  break;
-		}
-	      else
-		{
-		  s = strchr (vptr, ']');
-		  if (s == 0)
-		    {
-		      state = -1;
-		      break;
-		    }
-		  *s = 0;
-		  nstate = N_OPEN;
-		  vptr += strlen (vptr);
-		  state = 9;
+                  vmsname[0] = '\0';
+		  return vmsname;    /*FIXME, err getcwd */
 		}
-	    }
+	      strcpy (vptr, vp);
+            }
+            if (*fptr == 0)
+              {
+                state = -1;
+                break;
+              }
+            else
+              {
+                char *vp = strchr (vptr, ']');
+                if (vp == 0)
+                  {
+                    state = -1;
+                    break;
+                  }
+                *vp = '\0';
+                nstate = N_OPEN;
+                vptr += strlen (vptr);
+                state = 9;
+              }
 	    break;
 	}
 
@@ -903,14 +905,18 @@ vmsify (char *name, int type)
   dev:[dir1.dir2]	//dev/dir1/dir2/
 */
 
-char *
-unixify (char *name)
+const char *
+unixify (const char *name)
 {
   static char piece[512];
-  char *s, *p;
+  const char *s;
+  char *p;
 
   if (strchr (name, '/') != 0)		/* already in unix style */
-    return name;
+    {
+      strcpy (piece, name);
+      return piece;
+    }
 
   p = piece;
   *p = 0;
@@ -921,12 +927,11 @@ unixify (char *name)
 
   if (s != 0)
     {
-      *s = 0;
+      int l = s - name;
       *p++ = '/';
       *p++ = '/';
-      strcpy (p, name);
-      p += strlen (p);
-      *s = ':';
+      strncpy (p, name, l);
+      p += l;
     }
 
   /* directory part */
diff --git a/vpath.c b/vpath.c
index 7f6f316..992065b 100644
--- a/vpath.c
+++ b/vpath.c
@@ -29,10 +29,10 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.  */
 struct vpath
   {
     struct vpath *next;	/* Pointer to next struct in the linked list.  */
-    char *pattern;	/* The pattern to match.  */
-    char *percent;	/* Pointer into `pattern' where the `%' is.  */
+    const char *pattern;/* The pattern to match.  */
+    const char *percent;/* Pointer into `pattern' where the `%' is.  */
     unsigned int patlen;/* Length of the pattern.  */
-    char **searchpath;	/* Null-terminated list of directories.  */
+    const char **searchpath; /* Null-terminated list of directories.  */
     unsigned int maxlen;/* Maximum length of any entry in the list.  */
   };
 
@@ -90,13 +90,14 @@ build_vpath_lists ()
     {
       /* Save the list of vpaths.  */
       struct vpath *save_vpaths = vpaths;
+      char gp[] = "%";
 
       /* Empty `vpaths' so the new one will have no next, and `vpaths'
 	 will still be nil if P contains no existing directories.  */
       vpaths = 0;
 
       /* Parse P.  */
-      construct_vpath_list ("%", p);
+      construct_vpath_list (gp, p);
 
       /* Store the created path as the general path,
 	 and restore the old list of vpaths.  */
@@ -122,13 +123,14 @@ build_vpath_lists ()
     {
       /* Save the list of vpaths.  */
       struct vpath *save_vpaths = vpaths;
+      char gp[] = "%";
 
       /* Empty `vpaths' so the new one will have no next, and `vpaths'
 	 will still be nil if P contains no existing directories.  */
       vpaths = 0;
 
       /* Parse P.  */
-      construct_vpath_list ("%", p);
+      construct_vpath_list (gp, p);
 
       /* Store the created path as the GPATH,
 	 and restore the old list of vpaths.  */
@@ -159,23 +161,20 @@ build_vpath_lists ()
 void
 construct_vpath_list (char *pattern, char *dirpath)
 {
-  register unsigned int elem;
-  register char *p;
-  register char **vpath;
-  register unsigned int maxvpath;
+  unsigned int elem;
+  char *p;
+  const char **vpath;
+  unsigned int maxvpath;
   unsigned int maxelem;
-  char *percent = NULL;
+  const char *percent = NULL;
 
   if (pattern != 0)
-    {
-      pattern = xstrdup (pattern);
-      percent = find_percent (pattern);
-    }
+    percent = find_percent (pattern);
 
   if (dirpath == 0)
     {
       /* Remove matching listings.  */
-      register struct vpath *path, *lastpath;
+      struct vpath *path, *lastpath;
 
       lastpath = 0;
       path = vpaths;
@@ -195,7 +194,6 @@ construct_vpath_list (char *pattern, char *dirpath)
 		lastpath->next = next;
 
 	      /* Free its unused storage.  */
-	      free (path->pattern);
 	      free (path->searchpath);
 	      free (path);
 	    }
@@ -205,8 +203,6 @@ construct_vpath_list (char *pattern, char *dirpath)
 	  path = next;
 	}
 
-      if (pattern != 0)
-	free (pattern);
       return;
     }
 
@@ -214,6 +210,10 @@ construct_vpath_list (char *pattern, char *dirpath)
     convert_vpath_to_windows32(dirpath, ';');
 #endif
 
+  /* Skip over any initial separators and blanks.  */
+  while (*dirpath == PATH_SEPARATOR_CHAR || isblank ((unsigned char)*dirpath))
+    ++dirpath;
+
   /* Figure out the maximum number of VPATH entries and put it in
      MAXELEM.  We start with 2, one before the first separator and one
      nil (the list terminator) and increment our estimated number for
@@ -224,15 +224,11 @@ construct_vpath_list (char *pattern, char *dirpath)
     if (*p++ == PATH_SEPARATOR_CHAR || isblank ((unsigned char)*p))
       ++maxelem;
 
-  vpath = xmalloc (maxelem * sizeof (char *));
+  vpath = xmalloc (maxelem * sizeof (const char *));
   maxvpath = 0;
 
-  /* Skip over any initial separators and blanks.  */
-  p = dirpath;
-  while (*p == PATH_SEPARATOR_CHAR || isblank ((unsigned char)*p))
-    ++p;
-
   elem = 0;
+  p = dirpath;
   while (*p != '\0')
     {
       char *v;
@@ -254,23 +250,12 @@ construct_vpath_list (char *pattern, char *dirpath)
       if (len > 1 && p[-1] == '/')
 	--len;
 
+      /* Put the directory on the vpath list.  */
       if (len > 1 || *v != '.')
 	{
-	  v = savestring (v, len);
-
-	  /* Verify that the directory actually exists.  */
-
-	  if (dir_file_exists_p (v, ""))
-	    {
-	      /* It does.  Put it in the list.  */
-	      vpath[elem++] = dir_name (v);
-	      free (v);
-	      if (len > maxvpath)
-		maxvpath = len;
-	    }
-	  else
-	    /* The directory does not exist.  Omit from the list.  */
-	    free (v);
+          vpath[elem++] = dir_name (strcache_add_len (v, len));
+          if (len > maxvpath)
+            maxvpath = len;
 	}
 
       /* Skip over separators and blanks between entries.  */
@@ -285,10 +270,10 @@ construct_vpath_list (char *pattern, char *dirpath)
 	 entry, to where the nil-pointer terminator goes.
 	 Usually this is maxelem - 1.  If not, shrink down.  */
       if (elem < (maxelem - 1))
-	vpath = xrealloc (vpath, (elem+1) * sizeof (char *));
+	vpath = xrealloc (vpath, (elem+1) * sizeof (const char *));
 
       /* Put the nil-pointer terminator on the end of the VPATH list.  */
-      vpath[elem] = 0;
+      vpath[elem] = NULL;
 
       /* Construct the vpath structure and put it into the linked list.  */
       path = xmalloc (sizeof (struct vpath));
@@ -298,26 +283,22 @@ construct_vpath_list (char *pattern, char *dirpath)
       vpaths = path;
 
       /* Set up the members.  */
-      path->pattern = pattern;
-      path->percent = percent;
+      path->pattern = strcache_add (pattern);
+      path->percent = path->pattern + (percent - pattern);
       path->patlen = strlen (pattern);
     }
   else
-    {
-      /* There were no entries, so free whatever space we allocated.  */
-      free (vpath);
-      if (pattern != 0)
-	free (pattern);
-    }
+    /* There were no entries, so free whatever space we allocated.  */
+    free (vpath);
 }
 
 /* Search the GPATH list for a pathname string that matches the one passed
    in.  If it is found, return 1.  Otherwise we return 0.  */
 
 int
-gpath_search (char *file, unsigned int len)
+gpath_search (const char *file, unsigned int len)
 {
-  char **gp;
+  const char **gp;
 
   if (gpaths && (len <= gpaths->maxlen))
     for (gp = gpaths->searchpath; *gp != NULL; ++gp)
@@ -336,7 +317,7 @@ gpath_search (char *file, unsigned int len)
 int
 vpath_search (char **file, FILE_TIMESTAMP *mtime_ptr)
 {
-  register struct vpath *v;
+  struct vpath *v;
 
   /* If there are no VPATH entries or FILENAME starts at the root,
      there is nothing we can do.  */
@@ -375,7 +356,7 @@ selective_vpath_search (struct vpath *path, char **file,
   int not_target;
   char *name, *n;
   char *filename;
-  register char **vpath = path->searchpath;
+  const char **vpath = path->searchpath;
   unsigned int maxvpath = path->maxlen;
   register unsigned int i;
   unsigned int flen, vlen, name_dplen;
@@ -565,8 +546,8 @@ selective_vpath_search (struct vpath *path, char **file,
 void
 print_vpath_data_base (void)
 {
-  register unsigned int nvpaths;
-  register struct vpath *v;
+  unsigned int nvpaths;
+  struct vpath *v;
 
   puts (_("\n# VPATH Search Paths\n"));
 
@@ -593,8 +574,8 @@ print_vpath_data_base (void)
     puts (_("\n# No general (`VPATH' variable) search path."));
   else
     {
-      register char **path = general_vpath->searchpath;
-      register unsigned int i;
+      const char **path = general_vpath->searchpath;
+      unsigned int i;
 
       fputs (_("\n# General (`VPATH' variable) search path:\n# "), stdout);
 
diff --git a/w32/include/pathstuff.h b/w32/include/pathstuff.h
index 55af520..0288496 100644
--- a/w32/include/pathstuff.h
+++ b/w32/include/pathstuff.h
@@ -18,9 +18,9 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.  */
 #ifndef _PATHSTUFF_H
 #define _PATHSTUFF_H
 
-extern char * convert_Path_to_windows32(char *Path, char to_delim);
-extern char * convert_vpath_to_windows32(char *Path, char to_delim);
-extern char * w32ify(char *file, int resolve);
-extern char * getcwd_fs(char *buf, int len);
+char *convert_Path_to_windows32(char *Path, char to_delim);
+char *convert_vpath_to_windows32(char *Path, char to_delim);
+char *w32ify(const char *file, int resolve);
+char *getcwd_fs(char *buf, int len);
 
 #endif
diff --git a/w32/pathstuff.c b/w32/pathstuff.c
index d425657..7f88010 100644
--- a/w32/pathstuff.c
+++ b/w32/pathstuff.c
@@ -83,7 +83,7 @@ convert_Path_to_windows32(char *Path, char to_delim)
  * Convert to forward slashes. Resolve to full pathname optionally
  */
 char *
-w32ify(char *filename, int resolve)
+w32ify(const char *filename, int resolve)
 {
     static char w32_path[FILENAME_MAX];
     char *p;
-- 
cgit v1.0-41-gc330

