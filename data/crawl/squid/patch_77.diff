@@ -13,15 +13,9 @@
 #include <errno.h>
 #endif
 
-/** strerror() wrapper replacement.
- *
- * Provides the guarantee that a string is always returned.
- * Where strerror() would have provided NULL this will report the error as unknown.
- */
-#define xstrerror() xstrerr(errno)
-
 /** Provide the textual display of a system error number.
  * A string is always returned.
+ * Where strerror() would have provided NULL this will report the error as unknown.
  * On MS Windows the native Win32 errors are also translated.
  */
 extern const char * xstrerr(int error);
@@ -1089,8 +1089,9 @@ read_mib(char *filename) {
     char *p;
 
     fp = fopen(filename, "r");
-    if (fp == NULL) {
-        snmplib_debug(1, "init_mib: %s: %s\n", filename, xstrerror());
+    if (!fp) {
+        int xerrno = errno;
+        snmplib_debug(1, "init_mib: %s: %s\n", filename, xstrerr(xerrno));
         return (NULL);
     }
     mbuf[0] = '\0';
@@ -31,9 +31,10 @@ CpuAffinitySet::apply()
 
     bool success = false;
     if (sched_getaffinity(0, sizeof(theOrigCpuSet), &theOrigCpuSet)) {
+        int xerrno = errno;
         debugs(54, DBG_IMPORTANT, "ERROR: failed to get CPU affinity for "
                "process PID " << getpid() << ", ignoring CPU affinity for "
-               "this process: " << xstrerror());
+               "this process: " << xstrerr(xerrno));
     } else {
         cpu_set_t cpuSet;
         memcpy(&cpuSet, &theCpuSet, sizeof(cpuSet));
@@ -43,8 +44,9 @@ CpuAffinitySet::apply()
                    "PID " << getpid() << ", may be caused by an invalid core in "
                    "'cpu_affinity_map' or by external affinity restrictions");
         } else if (sched_setaffinity(0, sizeof(cpuSet), &cpuSet)) {
+            int xerrno = errno;
             debugs(54, DBG_IMPORTANT, "ERROR: failed to set CPU affinity for "
-                   "process PID " << getpid() << ": " << xstrerror());
+                   "process PID " << getpid() << ": " << xstrerr(xerrno));
         } else
             success = true;
     }
@@ -57,9 +59,10 @@ CpuAffinitySet::undo()
 {
     if (applied()) {
         if (sched_setaffinity(0, sizeof(theOrigCpuSet), &theOrigCpuSet)) {
+            int xerrno = errno;
             debugs(54, DBG_IMPORTANT, "ERROR: failed to restore original CPU "
                    "affinity for process PID " << getpid() << ": " <<
-                   xstrerror());
+                   xstrerr(xerrno));
         }
         CPU_ZERO(&theOrigCpuSet);
     }
@@ -132,8 +132,9 @@ AIODiskFile::read(ReadRequest *request)
 
     /* Initiate aio */
     if (aio_read(&qe->aq_e_aiocb) < 0) {
-        fatalf("Aiee! aio_read() returned error (%d)  FIXME and wrap file_read !\n", errno);
-        debugs(79, DBG_IMPORTANT, "WARNING: aio_read() returned error: " << xstrerror());
+        int xerrno = errno;
+        fatalf("Aiee! aio_read() returned error (%d)  FIXME and wrap file_read !\n", xerrno);
+        debugs(79, DBG_IMPORTANT, "WARNING: aio_read() returned error: " << xstrerr(xerrno));
         /* fall back to blocking method */
         //        file_read(fd, request->buf, request->len, request->offset, callback, data);
     }
@@ -190,8 +191,9 @@ AIODiskFile::write(WriteRequest *request)
 
     /* Initiate aio */
     if (aio_write(&qe->aq_e_aiocb) < 0) {
-        fatalf("Aiee! aio_write() returned error (%d) FIXME and wrap file_write !\n", errno);
-        debugs(79, DBG_IMPORTANT, "WARNING: aio_write() returned error: " << xstrerror());
+        int xerrno = errno;
+        fatalf("Aiee! aio_write() returned error (%d) FIXME and wrap file_write !\n", xerrno);
+        debugs(79, DBG_IMPORTANT, "WARNING: aio_write() returned error: " << xstrerr(xerrno));
         /* fall back to blocking method */
         //       file_write(fd, offset, buf, len, callback, data, freefunc);
     }
@@ -101,10 +101,11 @@ DiskdFile::create(int flags, mode_t, RefCount<IORequestor> callback)
                      NULL);
 
     if (x < 0) {
+        int xerrno = errno;
         ioCompleted();
         errorOccured = true;
         //        IO->shm.put (shm_offset);
-        debugs(79, DBG_IMPORTANT, "storeDiskdSend CREATE: " << xstrerror());
+        debugs(79, DBG_IMPORTANT, "storeDiskdSend CREATE: " << xstrerr(xerrno));
         notifyClient();
         ioRequestor = NULL;
         return;
@@ -130,10 +131,11 @@ DiskdFile::read(ReadRequest *aRead)
                      aRead);
 
     if (x < 0) {
+        int xerrno = errno;
         ioCompleted();
         errorOccured = true;
         //        IO->shm.put (shm_offset);
-        debugs(79, DBG_IMPORTANT, "storeDiskdSend READ: " << xstrerror());
+        debugs(79, DBG_IMPORTANT, "storeDiskdSend READ: " << xstrerr(xerrno));
         notifyClient();
         ioRequestor = NULL;
         return;
@@ -157,9 +159,10 @@ DiskdFile::close()
                      NULL);
 
     if (x < 0) {
+        int xerrno = errno;
         ioCompleted();
         errorOccured = true;
-        debugs(79, DBG_IMPORTANT, "storeDiskdSend CLOSE: " << xstrerror());
+        debugs(79, DBG_IMPORTANT, "storeDiskdSend CLOSE: " << xstrerr(xerrno));
         notifyClient();
         ioRequestor = NULL;
         return;
@@ -294,9 +297,10 @@ DiskdFile::write(WriteRequest *aRequest)
                      aRequest);
 
     if (x < 0) {
+        int xerrno = errno;
         ioCompleted();
         errorOccured = true;
-        debugs(79, DBG_IMPORTANT, "storeDiskdSend WRITE: " << xstrerror());
+        debugs(79, DBG_IMPORTANT, "storeDiskdSend WRITE: " << xstrerr(xerrno));
         //        IO->shm.put (shm_offset);
         notifyClient();
         ioRequestor = NULL;
@@ -124,7 +124,8 @@ DiskdIOStrategy::unlinkFile(char const *path)
              shm_offset);
 
     if (x < 0) {
-        debugs(79, DBG_IMPORTANT, "storeDiskdSend UNLINK: " << xstrerror());
+        int xerrno = errno;
+        debugs(79, DBG_IMPORTANT, "storeDiskdSend UNLINK: " << xstrerr(xerrno));
         ::unlink(buf);      /* XXX EWW! */
         //        shm.put (shm_offset);
     }
@@ -150,14 +151,16 @@ DiskdIOStrategy::init()
     smsgid = msgget((key_t) ikey, 0700 | IPC_CREAT);
 
     if (smsgid < 0) {
-        debugs(50, DBG_CRITICAL, "storeDiskdInit: msgget: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "msgget: " << xstrerr(xerrno));
         fatal("msgget failed");
     }
 
     rmsgid = msgget((key_t) (ikey + 1), 0700 | IPC_CREAT);
 
     if (rmsgid < 0) {
-        debugs(50, DBG_CRITICAL, "storeDiskdInit: msgget: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "msgget: " << xstrerr(xerrno));
         fatal("msgget failed");
     }
 
@@ -248,14 +251,16 @@ SharedMemory::init(int ikey, int magic2)
                 nbufs * SHMBUF_BLKSZ, 0600 | IPC_CREAT);
 
     if (id < 0) {
-        debugs(50, DBG_CRITICAL, "storeDiskdInit: shmget: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "shmget: " << xstrerr(xerrno));
         fatal("shmget failed");
     }
 
     buf = (char *)shmat(id, NULL, 0);
 
     if (buf == (void *) -1) {
-        debugs(50, DBG_CRITICAL, "storeDiskdInit: shmat: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "shmat: " << xstrerr(xerrno));
         fatal("shmat failed");
     }
 
@@ -380,7 +385,8 @@ DiskdIOStrategy::SEND(diomsg *M, int mtype, int id, size_t size, off_t offset, s
         ++diskd_stats.sent_count;
         ++away;
     } else {
-        debugs(79, DBG_IMPORTANT, "storeDiskdSend: msgsnd: " << xstrerror());
+        int xerrno = errno;
+        debugs(79, DBG_IMPORTANT, MYNAME << "msgsnd: " << xstrerr(xerrno));
         cbdataReferenceDone(M->callback_data);
         ++send_errors;
         assert(send_errors < 100);
@@ -350,7 +350,7 @@ main(int argc, char *argv[])
     hash = hash_create(fsCmp, 1 << 4, fsHash);
     assert(hash);
     if (fcntl(0, F_SETFL, SQUID_NONBLOCK) < 0) {
-        perror(xstrerror());
+        perror(xstrerr(errno));
         return 1;
     }
     memset(&sa, '\0', sizeof(sa));
@@ -143,8 +143,7 @@ DiskThreadsDiskFile::openDone(int, const char *, int anFD, int errflag)
     fd = anFD;
 
     if (errflag || fd < 0) {
-        errno = errflag;
-        debugs(79, DBG_CRITICAL, "DiskThreadsDiskFile::openDone: " << xstrerror());
+        debugs(79, DBG_CRITICAL, MYNAME << xstrerr(errflag));
         debugs(79, DBG_IMPORTANT, "\t" << path_);
         errorOccured = true;
     } else {
@@ -78,11 +78,12 @@ MmappedFile::open(int flags, mode_t, RefCount<IORequestor> callback)
     ioRequestor = callback;
 
     if (fd < 0) {
-        debugs(79,3, HERE << "open error: " << xstrerror());
+        int xerrno = errno;
+        debugs(79,3, "open error: " << xstrerr(xerrno));
         error_ = true;
     } else {
         ++store_open_disk_fd;
-        debugs(79,3, HERE << "FD " << fd);
+        debugs(79,3, "FD " << fd);
 
         // setup mapping boundaries
         struct stat sb;
@@ -251,7 +251,8 @@ main (int argc, char *argv[])
     }
     FILE *FH = fopen(filename, "r");
     if (!FH) {
-        fprintf(stderr, "%s: FATAL: Unable to open file '%s': %s", program_name, filename, xstrerror());
+        int xerrno = errno;
+        fprintf(stderr, "%s: FATAL: Unable to open file '%s': %s", program_name, filename, xstrerr(xerrno));
         exit(1);
     }
     current_entry = load_dict(FH);
@@ -52,8 +52,9 @@ read_passwd_file(const char *passwdfile)
     usermap.clear();
     //TODO: change to c++ streams
     f = fopen(passwdfile, "r");
-    if (NULL == f) {
-        fprintf(stderr, "FATAL: %s: %s\n", passwdfile, xstrerror());
+    if (!f) {
+        int xerrno = errno;
+        fprintf(stderr, "FATAL: %s: %s\n", passwdfile, xstrerr(xerrno));
         exit(1);
     }
     unsigned int lineCount = 0;
@@ -418,10 +418,11 @@ authenticate(int socket_fd, const char *username, const char *passwd)
          */
         gettimeofday(&sent, NULL);
         if (send(socket_fd, (char *) auth, total_length, 0) < 0) {
+            int xerrno = errno;
             // EAGAIN is expected at high traffic, just retry
             // TODO: block/sleep a few ms to let the apparently full buffer drain ?
-            if (errno != EAGAIN && errno != EWOULDBLOCK)
-                fprintf(stderr,"ERROR: RADIUS send() failure: %s\n", xstrerror());
+            if (xerrno != EAGAIN && xerrno != EWOULDBLOCK)
+                fprintf(stderr,"ERROR: RADIUS send() failure: %s\n", xstrerr(xerrno));
             continue;
         }
         while ((time_spent = time_since(&sent)) < 1000000) {
@@ -569,7 +570,8 @@ main(int argc, char **argv)
     }
 #ifdef O_NONBLOCK
     if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK) < 0) {
-        fprintf(stderr,"%s| ERROR: fcntl() failure: %s\n", argv[0], xstrerror());
+        int xerrno = errno;
+        fprintf(stderr,"%s| ERROR: fcntl() failure: %s\n", argv[0], xstrerr(xerrno));
         exit(1);
     }
 #endif
@@ -80,7 +80,8 @@ read_passwd_file(const char *passwordFile, int isHa1Mode)
     }
     FILE *f = fopen(passwordFile, "r");
     if (!f) {
-        fprintf(stderr, "digest_file_auth: cannot open password file: %s\n", xstrerror());
+        int xerrno = errno;
+        fprintf(stderr, "digest_file_auth: cannot open password file: %s\n", xstrerr(xerrno));
         exit(1);
     }
     unsigned int lineCount = 0;
@@ -293,8 +293,8 @@ parseManyConfigFiles(char* files, int depth)
     memset(&globbuf, 0, sizeof(globbuf));
     for (path = strwordtok(files, &saveptr); path; path = strwordtok(NULL, &saveptr)) {
         if (glob(path, globbuf.gl_pathc ? GLOB_APPEND : 0, NULL, &globbuf) != 0) {
-            fatalf("Unable to find configuration file: %s: %s",
-                   path, xstrerror());
+            int xerrno = errno;
+            fatalf("Unable to find configuration file: %s: %s", path, xstrerr(xerrno));
         }
     }
     for (i = 0; i < (int)globbuf.gl_pathc; ++i) {
@@ -441,8 +441,10 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
         fp = fopen(file_name, "r");
     }
 
-    if (fp == NULL)
-        fatalf("Unable to open configuration file: %s: %s", file_name, xstrerror());
+    if (!fp) {
+        int xerrno = errno;
+        fatalf("Unable to open configuration file: %s: %s", file_name, xstrerr(xerrno));
+    }
 
 #if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
@@ -3863,13 +3865,14 @@ requirePathnameExists(const char *name, const char *path)
     }
 
     if (stat(path, &sb) < 0) {
-        debugs(0, DBG_CRITICAL, (opt_parse_cfg_only?"FATAL: ":"ERROR: ") << name << " " << path << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(0, DBG_CRITICAL, (opt_parse_cfg_only?"FATAL: ":"ERROR: ") << name << " " << path << ": " << xstrerr(xerrno));
         // keep going to find more issues if we are only checking the config file with "-k parse"
         if (opt_parse_cfg_only)
             return;
         // this is fatal if it is found during startup or reconfigure
         if (opt_send_signal == -1 || opt_send_signal == SIGHUP)
-            fatalf("%s %s: %s", name, path, xstrerror());
+            fatalf("%s %s: %s", name, path, xstrerr(xerrno));
     }
 }
 
@@ -2453,8 +2453,10 @@ ConnStateData::start()
             (transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
         int i = IP_PMTUDISC_DONT;
-        if (setsockopt(clientConnection->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0)
-            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << clientConnection << " : " << xstrerror());
+        if (setsockopt(clientConnection->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0) {
+            int xerrno = errno;
+            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << clientConnection << " : " << xstrerr(xerrno));
+        }
 #else
         static bool reported = false;
 
@@ -1775,8 +1775,9 @@ ftpOpenListenSocket(Ftp::Gateway * ftpState, int fallback)
         errno = 0;
         if (setsockopt(ftpState->ctrl.conn->fd, SOL_SOCKET, SO_REUSEADDR,
                        (char *) &on, sizeof(on)) == -1) {
+            int xerrno = errno;
             // SO_REUSEADDR is only an optimization, no need to be verbose about error
-            debugs(9, 4, "setsockopt failed: " << xstrerror());
+            debugs(9, 4, "setsockopt failed: " << xstrerr(xerrno));
         }
         ftpState->ctrl.conn->flags |= COMM_REUSEADDR;
         temp->flags |= COMM_REUSEADDR;
@@ -181,7 +181,8 @@ comm_local_port(int fd)
     Ip::Address::InitAddr(addr);
 
     if (getsockname(fd, addr->ai_addr, &(addr->ai_addrlen)) ) {
-        debugs(50, DBG_IMPORTANT, "comm_local_port: Failed to retrieve TCP/UDP port number for socket: FD " << fd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "Failed to retrieve TCP/UDP port number for socket: FD " << fd << ": " << xstrerr(xerrno));
         Ip::Address::FreeAddr(addr);
         return 0;
     }
@@ -206,11 +207,11 @@ commBind(int s, struct addrinfo &inaddr)
     ++ statCounter.syscalls.sock.binds;
 
     if (bind(s, inaddr.ai_addr, inaddr.ai_addrlen) == 0) {
-        debugs(50, 6, "commBind: bind socket FD " << s << " to " << fd_table[s].local_addr);
+        debugs(50, 6, "bind socket FD " << s << " to " << fd_table[s].local_addr);
         return Comm::OK;
     }
-
-    debugs(50, 0, "commBind: Cannot bind socket FD " << s << " to " << fd_table[s].local_addr << ": " << xstrerror());
+    int xerrno = errno;
+    debugs(50, DBG_CRITICAL, MYNAME << "Cannot bind socket FD " << s << " to " << fd_table[s].local_addr << ": " << xstrerr(xerrno));
 
     return Comm::COMM_ERROR;
 }
@@ -271,10 +272,11 @@ comm_set_v6only(int fd, int tos)
 {
 #ifdef IPV6_V6ONLY
     if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &tos, sizeof(int)) < 0) {
-        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(IPV6_V6ONLY) " << (tos?"ON":"OFF") << " for FD " << fd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "setsockopt(IPV6_V6ONLY) " << (tos?"ON":"OFF") << " for FD " << fd << ": " << xstrerr(xerrno));
     }
 #else
-    debugs(50, 0, "WARNING: comm_open: setsockopt(IPV6_V6ONLY) not supported on this platform");
+    debugs(50, DBG_CRITICAL, MYNAME << "WARNING: setsockopt(IPV6_V6ONLY) not supported on this platform");
 #endif /* sockopt */
 }
 
@@ -311,7 +313,8 @@ comm_set_transparent(int fd)
 #if defined(soLevel) && defined(soFlag)
     int tos = 1;
     if (setsockopt(fd, soLevel, soFlag, (char *) &tos, sizeof(int)) < 0) {
-        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(TPROXY) on FD " << fd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "setsockopt(TPROXY) on FD " << fd << ": " << xstrerr(xerrno));
     } else {
         /* mark the socket as having transparent options */
         fd_table[fd].flags.transparent = true;
@@ -347,6 +350,7 @@ comm_openex(int sock_type,
     debugs(50, 3, "comm_openex: Attempt open socket for: " << addr );
 
     new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
+    int xerrno = errno;
 
     /* under IPv6 there is the possibility IPv6 is present but disabled. */
     /* try again as IPv4-native if possible */
@@ -357,9 +361,9 @@ comm_openex(int sock_type,
         addr.getAddrInfo(AI);
         AI->ai_socktype = sock_type;
         AI->ai_protocol = proto;
-        debugs(50, 3, "comm_openex: Attempt fallback open socket for: " << addr );
+        debugs(50, 3, "Attempt fallback open socket for: " << addr );
         new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
-        debugs(50, 2, HERE << "attempt open " << note << " socket on: " << addr);
+        debugs(50, 2, "attempt open " << note << " socket on: " << addr);
     }
 
     if (new_socket < 0) {
@@ -368,15 +372,16 @@ comm_openex(int sock_type,
          * limits the number of simultaneous clients */
 
         if (limitError(errno)) {
-            debugs(50, DBG_IMPORTANT, "comm_open: socket failure: " << xstrerror());
+            debugs(50, DBG_IMPORTANT, MYNAME << "socket failure: " << xstrerr(xerrno));
             fdAdjustReserved();
         } else {
-            debugs(50, DBG_CRITICAL, "comm_open: socket failure: " << xstrerror());
+            debugs(50, DBG_CRITICAL, MYNAME << "socket failure: " << xstrerr(xerrno));
         }
 
         Ip::Address::FreeAddr(AI);
 
         PROF_stop(comm_open);
+        errno = xerrno; // restore for caller
         return -1;
     }
 
@@ -404,6 +409,7 @@ comm_openex(int sock_type,
 
     // XXX transition only. prevent conn from closing the new FD on function exit.
     conn->fd = -1;
+    errno = xerrno; // restore for caller
     return new_socket;
 }
 
@@ -737,12 +743,11 @@ static void
 commLingerClose(int fd, void *unused)
 {
     LOCAL_ARRAY(char, buf, 1024);
-    int n;
-    n = FD_READ_METHOD(fd, buf, 1024);
-
-    if (n < 0)
-        debugs(5, 3, "commLingerClose: FD " << fd << " read: " << xstrerror());
-
+    int n = FD_READ_METHOD(fd, buf, 1024);
+    if (n < 0) {
+        int xerrno = errno;
+        debugs(5, 3, "FD " << fd << " read: " << xstrerr(xerrno));
+    }
     comm_close(fd);
 }
 
@@ -798,9 +803,10 @@ comm_reset_close(const Comm::ConnectionPointer &conn)
     L.l_onoff = 1;
     L.l_linger = 0;
 
-    if (setsockopt(conn->fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0)
-        debugs(50, DBG_CRITICAL, "ERROR: Closing " << conn << " with TCP RST: " << xstrerror());
-
+    if (setsockopt(conn->fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "ERROR: Closing " << conn << " with TCP RST: " << xstrerr(xerrno));
+    }
     conn->close();
 }
 
@@ -812,9 +818,10 @@ old_comm_reset_close(int fd)
     L.l_onoff = 1;
     L.l_linger = 0;
 
-    if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0)
-        debugs(50, DBG_CRITICAL, "ERROR: Closing FD " << fd << " with TCP RST: " << xstrerror());
-
+    if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "ERROR: Closing FD " << fd << " with TCP RST: " << xstrerr(xerrno));
+    }
     comm_close(fd);
 }
 
@@ -955,20 +962,22 @@ comm_udp_sendto(int fd,
     struct addrinfo *AI = NULL;
     to_addr.getAddrInfo(AI, fd_table[fd].sock_family);
     int x = sendto(fd, buf, len, 0, AI->ai_addr, AI->ai_addrlen);
+    int xerrno = errno;
     Ip::Address::FreeAddr(AI);
 
     PROF_stop(comm_udp_sendto);
 
-    if (x >= 0)
+    if (x >= 0) {
+        errno = xerrno; // restore for caller to use
         return x;
+    }
 
 #if _SQUID_LINUX_
-
-    if (ECONNREFUSED != errno)
+    if (ECONNREFUSED != xerrno)
 #endif
+        debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << ", (family=" << fd_table[fd].sock_family << ") " << to_addr << ": " << xstrerr(xerrno));
 
-        debugs(50, DBG_IMPORTANT, "comm_udp_sendto: FD " << fd << ", (family=" << fd_table[fd].sock_family << ") " << to_addr << ": " << xstrerror());
-
+    errno = xerrno; // restore for caller to use
     return Comm::COMM_ERROR;
 }
 
@@ -1051,31 +1060,39 @@ commSetNoLinger(int fd)
     L.l_onoff = 0;      /* off */
     L.l_linger = 0;
 
-    if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0)
-        debugs(50, 0, "commSetNoLinger: FD " << fd << ": " << xstrerror());
-
+    if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+    }
     fd_table[fd].flags.nolinger = true;
 }
 
 static void
 commSetReuseAddr(int fd)
 {
     int on = 1;
-
-    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on)) < 0)
-        debugs(50, DBG_IMPORTANT, "commSetReuseAddr: FD " << fd << ": " << xstrerror());
+    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+    }
 }
 
 static void
 commSetTcpRcvbuf(int fd, int size)
 {
-    if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char *) &size, sizeof(size)) < 0)
-        debugs(50, DBG_IMPORTANT, "commSetTcpRcvbuf: FD " << fd << ", SIZE " << size << ": " << xstrerror());
-    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (char *) &size, sizeof(size)) < 0)
-        debugs(50, DBG_IMPORTANT, "commSetTcpRcvbuf: FD " << fd << ", SIZE " << size << ": " << xstrerror());
+    if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char *) &size, sizeof(size)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << ", SIZE " << size << ": " << xstrerr(xerrno));
+    }
+    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (char *) &size, sizeof(size)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << ", SIZE " << size << ": " << xstrerr(xerrno));
+    }
 #ifdef TCP_WINDOW_CLAMP
-    if (setsockopt(fd, SOL_TCP, TCP_WINDOW_CLAMP, (char *) &size, sizeof(size)) < 0)
-        debugs(50, DBG_IMPORTANT, "commSetTcpRcvbuf: FD " << fd << ", SIZE " << size << ": " << xstrerror());
+    if (setsockopt(fd, SOL_TCP, TCP_WINDOW_CLAMP, (char *) &size, sizeof(size)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << ", SIZE " << size << ": " << xstrerr(xerrno));
+    }
 #endif
 }
 
@@ -1086,7 +1103,8 @@ commSetNonBlocking(int fd)
     int nonblocking = TRUE;
 
     if (ioctl(fd, FIONBIO, &nonblocking) < 0) {
-        debugs(50, 0, "commSetNonBlocking: FD " << fd << ": " << xstrerror() << " " << fd_table[fd].type);
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": " << xstrerr(xerrno) << " " << fd_table[fd].type);
         return Comm::COMM_ERROR;
     }
 
@@ -1095,12 +1113,14 @@ commSetNonBlocking(int fd)
     int dummy = 0;
 
     if ((flags = fcntl(fd, F_GETFL, dummy)) < 0) {
-        debugs(50, 0, "FD " << fd << ": fcntl F_GETFL: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": fcntl F_GETFL: " << xstrerr(xerrno));
         return Comm::COMM_ERROR;
     }
 
     if (fcntl(fd, F_SETFL, flags | SQUID_NONBLOCK) < 0) {
-        debugs(50, 0, "commSetNonBlocking: FD " << fd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
         return Comm::COMM_ERROR;
     }
 #endif
@@ -1121,13 +1141,15 @@ commUnsetNonBlocking(int fd)
     int dummy = 0;
 
     if ((flags = fcntl(fd, F_GETFL, dummy)) < 0) {
-        debugs(50, 0, "FD " << fd << ": fcntl F_GETFL: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": fcntl F_GETFL: " << xstrerr(xerrno));
         return Comm::COMM_ERROR;
     }
 
     if (fcntl(fd, F_SETFL, flags & (~SQUID_NONBLOCK)) < 0) {
 #endif
-        debugs(50, 0, "commUnsetNonBlocking: FD " << fd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
         return Comm::COMM_ERROR;
     }
 
@@ -1143,12 +1165,15 @@ commSetCloseOnExec(int fd)
     int dummy = 0;
 
     if ((flags = fcntl(fd, F_GETFD, dummy)) < 0) {
-        debugs(50, 0, "FD " << fd << ": fcntl F_GETFD: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": fcntl F_GETFD: " << xstrerr(xerrno));
         return;
     }
 
-    if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)
-        debugs(50, 0, "FD " << fd << ": set close-on-exec failed: " << xstrerror());
+    if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "FD " << fd << ": set close-on-exec failed: " << xstrerr(xerrno));
+    }
 
     fd_table[fd].flags.close_on_exec = true;
 
@@ -1161,8 +1186,10 @@ commSetTcpNoDelay(int fd)
 {
     int on = 1;
 
-    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0)
-        debugs(50, DBG_IMPORTANT, "commSetTcpNoDelay: FD " << fd << ": " << xstrerror());
+    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+    }
 
     fd_table[fd].flags.nodelay = true;
 }
@@ -1176,24 +1203,32 @@ commSetTcpKeepalive(int fd, int idle, int interval, int timeout)
 #ifdef TCP_KEEPCNT
     if (timeout && interval) {
         int count = (timeout + interval - 1) / interval;
-        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(on)) < 0)
-            debugs(5, DBG_IMPORTANT, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(on)) < 0) {
+            int xerrno = errno;
+            debugs(5, DBG_IMPORTANT, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+        }
     }
 #endif
 #ifdef TCP_KEEPIDLE
     if (idle) {
-        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(on)) < 0)
-            debugs(5, DBG_IMPORTANT, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(on)) < 0) {
+            int xerrno = errno;
+            debugs(5, DBG_IMPORTANT, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+        }
     }
 #endif
 #ifdef TCP_KEEPINTVL
     if (interval) {
-        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(on)) < 0)
-            debugs(5, DBG_IMPORTANT, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(on)) < 0) {
+            int xerrno = errno;
+            debugs(5, DBG_IMPORTANT, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+        }
     }
 #endif
-    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) < 0)
-        debugs(5, DBG_IMPORTANT, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) < 0) {
+        int xerrno = errno;
+        debugs(5, DBG_IMPORTANT, MYNAME << "FD " << fd << ": " << xstrerr(xerrno));
+    }
 }
 
 void
@@ -1873,15 +1908,16 @@ comm_open_uds(int sock_type,
     debugs(50, 3, HERE << "Attempt open socket for: " << addr->sun_path);
 
     if ((new_socket = socket(AI.ai_family, AI.ai_socktype, AI.ai_protocol)) < 0) {
+        int xerrno = errno;
         /* Increase the number of reserved fd's if calls to socket()
          * are failing because the open file table is full.  This
          * limits the number of simultaneous clients */
 
-        if (limitError(errno)) {
-            debugs(50, DBG_IMPORTANT, HERE << "socket failure: " << xstrerror());
+        if (limitError(xerrno)) {
+            debugs(50, DBG_IMPORTANT, MYNAME << "socket failure: " << xstrerr(xerrno));
             fdAdjustReserved();
         } else {
-            debugs(50, DBG_CRITICAL, HERE << "socket failure: " << xstrerror());
+            debugs(50, DBG_CRITICAL, MYNAME << "socket failure: " << xstrerr(xerrno));
         }
 
         PROF_stop(comm_open);
@@ -410,7 +410,8 @@ Comm::ConnOpener::lookupLocalAddress()
     Ip::Address::InitAddr(addr);
 
     if (getsockname(conn_->fd, addr->ai_addr, &(addr->ai_addrlen)) != 0) {
-        debugs(50, DBG_IMPORTANT, "ERROR: Failed to retrieve TCP/UDP details for socket: " << conn_ << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "ERROR: Failed to retrieve TCP/UDP details for socket: " << conn_ << ": " << xstrerr(xerrno));
         Ip::Address::FreeAddr(addr);
         return;
     }
@@ -197,8 +197,10 @@ Comm::SelectLoopInit(void)
 
     /* attempt to open /dev/poll device */
     devpoll_fd = open("/dev/poll", O_RDWR);
-    if (devpoll_fd < 0)
-        fatalf("comm_select_init: can't open /dev/poll: %s\n", xstrerror());
+    if (devpoll_fd < 0) {
+        int xerrno = errno;
+        fatalf("comm_select_init: can't open /dev/poll: %s\n", xstrerr(xerrno));
+    }
 
     fd_open(devpoll_fd, FD_UNKNOWN, "devpoll ctl");
 
@@ -69,13 +69,15 @@ Comm::SelectLoopInit(void)
     pevents = (struct epoll_event *) xmalloc(SQUID_MAXFD * sizeof(struct epoll_event));
 
     if (!pevents) {
-        fatalf("comm_select_init: xmalloc() failed: %s\n",xstrerror());
+        int xerrno = errno;
+        fatalf("comm_select_init: xmalloc() failed: %s\n", xstrerr(xerrno));
     }
 
     kdpfd = epoll_create(SQUID_MAXFD);
 
     if (kdpfd < 0) {
-        fatalf("comm_select_init: epoll_create(): %s\n",xstrerror());
+        int xerrno = errno;
+        fatalf("comm_select_init: epoll_create(): %s\n", xstrerr(xerrno));
     }
 
     commEPollRegisterWithCacheManager();
@@ -168,8 +170,9 @@ Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time
         F->epoll_state = ev.events;
 
         if (epoll_ctl(kdpfd, epoll_ctl_type, fd, &ev) < 0) {
-            debugs(5, DEBUG_EPOLL ? 0 : 8, HERE << "epoll_ctl(," << epolltype_atoi(epoll_ctl_type) <<
-                   ",,): failed on FD " << fd << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(5, DEBUG_EPOLL ? 0 : 8, "epoll_ctl(," << epolltype_atoi(epoll_ctl_type) <<
+                   ",,): failed on FD " << fd << ": " << xstrerr(xerrno));
         }
     }
 
@@ -412,18 +412,19 @@ Comm::DoSelect(int msec)
             PROF_start(comm_poll_normal);
             ++ statCounter.syscalls.selects;
             num = poll(pfds, nfds, msec);
+            int xerrno = errno;
             ++ statCounter.select_loops;
             PROF_stop(comm_poll_normal);
 
             if (num >= 0 || npending > 0)
                 break;
 
-            if (ignoreErrno(errno))
+            if (ignoreErrno(xerrno))
                 continue;
 
-            debugs(5, DBG_CRITICAL, "comm_poll: poll failure: " << xstrerror());
+            debugs(5, DBG_CRITICAL, MYNAME << "poll failure: " << xstrerr(xerrno));
 
-            assert(errno != EINVAL);
+            assert(xerrno != EINVAL);
 
             return Comm::COMM_ERROR;
 
@@ -434,15 +434,16 @@ Comm::DoSelect(int msec)
             poll_time.tv_usec = (msec % 1000) * 1000;
             ++ statCounter.syscalls.selects;
             num = select(maxfd, &readfds, &writefds, NULL, &poll_time);
+            int xerrno = errno;
             ++ statCounter.select_loops;
 
             if (num >= 0 || pending > 0)
                 break;
 
-            if (ignoreErrno(errno))
+            if (ignoreErrno(xerrno))
                 break;
 
-            debugs(5, DBG_CRITICAL, "comm_select: select failure: " << xstrerror());
+            debugs(5, DBG_CRITICAL, MYNAME << "select failure: " << xstrerr(xerrno));
 
             examine_select(&readfds, &writefds);
 
@@ -712,9 +713,10 @@ examine_select(fd_set * readfds, fd_set * writefds)
             debugs(5, 5, "FD " << fd << " is valid.");
             continue;
         }
+        int xerrno = errno;
 
         F = &fd_table[fd];
-        debugs(5, DBG_CRITICAL, "FD " << fd << ": " << xstrerror());
+        debugs(5, DBG_CRITICAL, "fstat(FD " << fd << "): " << xstrerr(xerrno));
         debugs(5, DBG_CRITICAL, "WARNING: FD " << fd << " has handlers, but it's invalid.");
         debugs(5, DBG_CRITICAL, "FD " << fd << " is a " << fdTypeStr[F->type] << " called '" << F->desc << "'");
         debugs(5, DBG_CRITICAL, "tmout:" << F->timeoutHandler << " read:" << F->read_handler << " write:" << F->write_handler);
@@ -425,15 +425,16 @@ Comm::DoSelect(int msec)
             poll_time.tv_usec = (msec % 1000) * 1000;
             ++ statCounter.syscalls.selects;
             num = select(maxfd, &readfds, &writefds, &errfds, &poll_time);
+            int xerrno = errno;
             ++ statCounter.select_loops;
 
             if (num >= 0 || pending > 0)
                 break;
 
-            if (ignoreErrno(errno))
+            if (ignoreErrno(xerrno))
                 break;
 
-            debugs(5, DBG_CRITICAL, "comm_select: select failure: " << xstrerror());
+            debugs(5, DBG_CRITICAL, MYNAME << "WARNING: select failure: " << xstrerr(xerrno));
 
             examine_select(&readfds, &writefds);
 
@@ -723,9 +724,10 @@ examine_select(fd_set * readfds, fd_set * writefds)
             debugs(5, 5, "FD " << fd << " is valid.");
             continue;
         }
+        int xerrno = errno;
 
         F = &fd_table[fd];
-        debugs(5, DBG_CRITICAL, "FD " << fd << ": " << xstrerror());
+        debugs(5, DBG_CRITICAL, "fstat(FD " << fd << "): " << xstrerr(xerrno));
         debugs(5, DBG_CRITICAL, "WARNING: FD " << fd << " has handlers, but it's invalid.");
         debugs(5, DBG_CRITICAL, "FD " << fd << " is a " << fdTypeStr[F->type] << " called '" << F->desc << "'");
         debugs(5, DBG_CRITICAL, "tmout:" << F->timeoutHandler << " read:" << F->read_handler << " write:" << F->write_handler);
@@ -163,14 +163,18 @@ Comm::TcpAcceptor::setListen()
         bzero(&afa, sizeof(afa));
         debugs(5, DBG_IMPORTANT, "Installing accept filter '" << Config.accept_filter << "' on " << conn);
         xstrncpy(afa.af_name, Config.accept_filter, sizeof(afa.af_name));
-        if (setsockopt(conn->fd, SOL_SOCKET, SO_ACCEPTFILTER, &afa, sizeof(afa)) < 0)
-            debugs(5, DBG_CRITICAL, "WARNING: SO_ACCEPTFILTER '" << Config.accept_filter << "': '" << xstrerror());
+        if (setsockopt(conn->fd, SOL_SOCKET, SO_ACCEPTFILTER, &afa, sizeof(afa)) < 0) {
+            int xerrno = errno;
+            debugs(5, DBG_CRITICAL, "WARNING: SO_ACCEPTFILTER '" << Config.accept_filter << "': '" << xstrerr(xerrno));
+        }
 #elif defined(TCP_DEFER_ACCEPT)
         int seconds = 30;
         if (strncmp(Config.accept_filter, "data=", 5) == 0)
             seconds = atoi(Config.accept_filter + 5);
-        if (setsockopt(conn->fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &seconds, sizeof(seconds)) < 0)
-            debugs(5, DBG_CRITICAL, "WARNING: TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerror());
+        if (setsockopt(conn->fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &seconds, sizeof(seconds)) < 0) {
+            int xerrno = errno;
+            debugs(5, DBG_CRITICAL, "WARNING: TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerr(xerrno));
+        }
 #else
         debugs(5, DBG_CRITICAL, "WARNING: accept_filter not supported on your OS");
 #endif
@@ -344,14 +348,14 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
 
         PROF_stop(comm_accept);
 
-        if (ignoreErrno(errno)) {
-            debugs(50, 5, HERE << status() << ": " << xstrerror());
+        if (ignoreErrno(errcode)) {
+            debugs(50, 5, status() << ": " << xstrerr(errcode));
             return Comm::NOMESSAGE;
         } else if (ENFILE == errno || EMFILE == errno) {
-            debugs(50, 3, HERE << status() << ": " << xstrerror());
+            debugs(50, 3, status() << ": " << xstrerr(errcode));
             return Comm::COMM_ERROR;
         } else {
-            debugs(50, DBG_IMPORTANT, HERE << status() << ": " << xstrerror());
+            debugs(50, DBG_IMPORTANT, MYNAME << status() << ": " << xstrerr(errcode));
             return Comm::COMM_ERROR;
         }
     }
@@ -373,7 +377,8 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     Ip::Address::InitAddr(gai);
     details->local.setEmpty();
     if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
-        debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerr(xerrno));
         Ip::Address::FreeAddr(gai);
         PROF_stop(comm_accept);
         return Comm::COMM_ERROR;
@@ -433,8 +433,9 @@ idnsParseResolvConf(void)
 #if !_SQUID_WINDOWS_
     FILE *fp = fopen(_PATH_RESCONF, "r");
 
-    if (fp == NULL) {
-        debugs(78, DBG_IMPORTANT, "" << _PATH_RESCONF << ": " << xstrerror());
+    if (!fp) {
+        int xerrno = errno;
+        debugs(78, DBG_IMPORTANT, "" << _PATH_RESCONF << ": " << xstrerr(xerrno));
         return false;
     }
 
@@ -994,15 +995,16 @@ idnsSendQuery(idns_query * q)
             else if (DnsSocketA >= 0)
                 x = comm_udp_sendto(DnsSocketA, nameservers[nsn].S, q->buf, q->sz);
         }
+        int xerrno = errno;
 
         ++ q->nsends;
 
         q->sent_t = current_time;
 
         if (y < 0 && nameservers[nsn].S.isIPv6())
-            debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketB << ": sendto: " << xstrerror());
+            debugs(50, DBG_IMPORTANT, MYNAME << "FD " << DnsSocketB << ": sendto: " << xstrerr(xerrno));
         if (x < 0 && nameservers[nsn].S.isIPv4())
-            debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketA << ": sendto: " << xstrerror());
+            debugs(50, DBG_IMPORTANT, MYNAME << "FD " << DnsSocketA << ": sendto: " << xstrerr(xerrno));
 
     } while ( (x<0 && y<0) && q->nsends % nns != 0);
 
@@ -1350,18 +1352,18 @@ idnsRead(int fd, void *)
             break;
 
         if (len < 0) {
-            if (ignoreErrno(errno))
+            int xerrno = errno;
+            if (ignoreErrno(xerrno))
                 break;
 
 #if _SQUID_LINUX_
             /* Some Linux systems seem to set the FD for reading and then
              * return ECONNREFUSED when sendto() fails and generates an ICMP
              * port unreachable message. */
             /* or maybe an EHOSTUNREACH "No route to host" message */
-            if (errno != ECONNREFUSED && errno != EHOSTUNREACH)
+            if (xerrno != ECONNREFUSED && xerrno != EHOSTUNREACH)
 #endif
-
-                debugs(50, DBG_IMPORTANT, "idnsRead: FD " << fd << " recvfrom: " << xstrerror());
+                debugs(50, DBG_IMPORTANT, MYNAME << "FD " << fd << " recvfrom: " << xstrerr(xerrno));
 
             break;
         }
@@ -330,23 +330,26 @@ TemplateFile::loadFromFile(const char *path)
 
     if (fd < 0) {
         /* with dynamic locale negotiation we may see some failures before a success. */
-        if (!silent && templateCode < TCP_RESET)
-            debugs(4, DBG_CRITICAL, HERE << "'" << path << "': " << xstrerror());
+        if (!silent && templateCode < TCP_RESET) {
+            int xerrno = errno;
+            debugs(4, DBG_CRITICAL, MYNAME << "'" << path << "': " << xstrerr(xerrno));
+        }
         wasLoaded = false;
         return wasLoaded;
     }
 
     while ((len = FD_READ_METHOD(fd, buf, sizeof(buf))) > 0) {
         if (!parse(buf, len, false)) {
-            debugs(4, DBG_CRITICAL, HERE << " parse error while reading template file: " << path);
+            debugs(4, DBG_CRITICAL, MYNAME << "parse error while reading template file: " << path);
             wasLoaded = false;
             return wasLoaded;
         }
     }
     parse(buf, 0, true);
 
     if (len < 0) {
-        debugs(4, DBG_CRITICAL, HERE << "failed to fully read: '" << path << "': " << xstrerror());
+        int xerrno = errno;
+        debugs(4, DBG_CRITICAL, MYNAME << "ERROR: failed to fully read: '" << path << "': " << xstrerr(xerrno));
     }
 
     file_close(fd);
@@ -148,7 +148,8 @@ Eui::Eui48::lookup(const Ip::Address &c)
     /* IPv6 builds do not provide the first http_port as an IPv4 socket for ARP */
     int tmpSocket = socket(AF_INET,SOCK_STREAM,0);
     if (tmpSocket < 0) {
-        debugs(28, DBG_IMPORTANT, "Attempt to open socket for EUI retrieval failed: " << xstrerror());
+        int xerrno = errno;
+        debugs(28, DBG_IMPORTANT, "Attempt to open socket for EUI retrieval failed: " << xstrerr(xerrno));
         clear();
         return false;
     }
@@ -204,7 +205,8 @@ Eui::Eui48::lookup(const Ip::Address &c)
     ifc.ifc_buf = (char *)ifbuffer;
 
     if (ioctl(tmpSocket, SIOCGIFCONF, &ifc) < 0) {
-        debugs(28, DBG_IMPORTANT, "Attempt to retrieve interface list failed: " << xstrerror());
+        int xerrno = errno;
+        debugs(28, DBG_IMPORTANT, "Attempt to retrieve interface list failed: " << xstrerr(xerrno));
         clear();
         close(tmpSocket);
         return false;
@@ -249,17 +251,10 @@ Eui::Eui48::lookup(const Ip::Address &c)
 
         /* Query ARP table */
         if (-1 == ioctl(tmpSocket, SIOCGARP, &arpReq)) {
-            /*
-             * Query failed.  Do not log failed lookups or "device
-             * not supported"
-             */
-
-            if (ENXIO == errno)
-                (void) 0;
-            else if (ENODEV == errno)
-                (void) 0;
-            else
-                debugs(28, DBG_IMPORTANT, "ARP query " << ipAddr << " failed: " << ifr->ifr_name << ": " << xstrerror());
+            int xerrno = errno;
+            //  Query failed.  Do not log failed lookups or "device not supported"
+            if (ENXIO != xerrno && ENODEV != xerrno)
+                debugs(28, DBG_IMPORTANT, "ARP query " << ipAddr << " failed: " << ifr->ifr_name << ": " << xstrerr(xerrno));
 
             continue;
         }
@@ -298,7 +293,8 @@ Eui::Eui48::lookup(const Ip::Address &c)
     /* IPv6 builds do not provide the first http_port as an IPv4 socket for ARP */
     int tmpSocket = socket(AF_INET,SOCK_STREAM,0);
     if (tmpSocket < 0) {
-        debugs(28, DBG_IMPORTANT, "Attempt to open socket for EUI retrieval failed: " << xstrerror());
+        int xerrno = errno;
+        debugs(28, DBG_IMPORTANT, "Attempt to open socket for EUI retrieval failed: " << xstrerr(xerrno));
         clear();
         return false;
     }
@@ -291,8 +291,9 @@ Rock::SwapDir::create()
 void
 Rock::SwapDir::createError(const char *const msg)
 {
+    int xerrno = errno; // XXX: where does errno come from?
     debugs(47, DBG_CRITICAL, "ERROR: Failed to initialize Rock Store db in " <<
-           filePath << "; " << msg << " error: " << xstrerror());
+           filePath << "; " << msg << " error: " << xstrerr(xerrno));
     fatal("Rock Store db creation error");
 }
 
@@ -814,9 +815,11 @@ Rock::SwapDir::ioCompletedNotification()
     if (!theFile)
         fatalf("Rock cache_dir failed to initialize db file: %s", filePath);
 
-    if (theFile->error())
+    if (theFile->error()) {
+        int xerrno = errno; // XXX: where does errno come from
         fatalf("Rock cache_dir at %s failed to open db file: %s", filePath,
-               xstrerror());
+               xstrerr(xerrno));
+    }
 
     debugs(47, 2, "Rock cache_dir[" << index << "] limits: " <<
            std::setw(12) << maxSize() << " disk bytes, " <<
@@ -169,7 +169,8 @@ Fs::Ufs::RebuildState::rebuildFromDirectory()
     ++n_read;
 
     if (fstat(fd, &sb) < 0) {
-        debugs(47, DBG_IMPORTANT, HERE << "fstat(FD " << fd << "): " << xstrerror());
+        int xerrno = errno;
+        debugs(47, DBG_IMPORTANT, MYNAME << "fstat(FD " << fd << "): " << xstrerr(xerrno));
         file_close(fd);
         --store_open_disk_fd;
         fd = -1;
@@ -471,8 +472,9 @@ Fs::Ufs::RebuildState::getNextFile(sfileno * filn_p, int *)
 
             ++dirs_opened;
 
-            if (td == NULL) {
-                debugs(47, DBG_IMPORTANT, HERE << "error in opendir (" << fullpath << "): " << xstrerror());
+            if (!td) {
+                int xerrno = errno;
+                debugs(47, DBG_IMPORTANT, MYNAME << "error in opendir (" << fullpath << "): " << xstrerr(xerrno));
             } else {
                 entry = readdir(td);    /* skip . and .. */
                 entry = readdir(td);
@@ -510,9 +512,10 @@ Fs::Ufs::RebuildState::getNextFile(sfileno * filn_p, int *)
             debugs(47, 3, HERE << "Opening " << fullfilename);
             fd = file_open(fullfilename, O_RDONLY | O_BINARY);
 
-            if (fd < 0)
-                debugs(47, DBG_IMPORTANT, HERE << "error opening " << fullfilename << ": " << xstrerror());
-            else
+            if (fd < 0) {
+                int xerrno = errno;
+                debugs(47, DBG_IMPORTANT, MYNAME << "error opening " << fullfilename << ": " << xstrerr(xerrno));
+            } else
                 ++store_open_disk_fd;
 
             continue;
@@ -100,9 +100,10 @@ UFSCleanLog::write(StoreEntry const &e)
 
     if (outbuf_offset + ss >= CLEAN_BUF_SZ) {
         if (FD_WRITE_METHOD(fd, outbuf, outbuf_offset) < 0) {
+            int xerrno = errno;
             /* XXX This error handling should probably move up to the caller */
-            debugs(50, DBG_CRITICAL, HERE << newLog << ": write: " << xstrerror());
-            debugs(50, DBG_CRITICAL, HERE << "Current swap logfile not replaced.");
+            debugs(50, DBG_CRITICAL, MYNAME << newLog << ": write: " << xstrerr(xerrno));
+            debugs(50, DBG_CRITICAL, MYNAME << "Current swap logfile not replaced.");
             file_close(fd);
             fd = -1;
             unlink(newLog);
@@ -617,8 +618,8 @@ Fs::Ufs::UFSSwapDir::createDirectory(const char *aPath, int should_exist)
         debugs(47, (should_exist ? DBG_IMPORTANT : 3), aPath << " created");
         created = 1;
     } else {
-        fatalf("Failed to make swap directory %s: %s",
-               aPath, xstrerror());
+        int xerrno = errno;
+        fatalf("Failed to make swap directory %s: %s", aPath, xstrerr(xerrno));
     }
 
     return created;
@@ -631,7 +632,8 @@ Fs::Ufs::UFSSwapDir::pathIsDirectory(const char *aPath)const
     struct stat sb;
 
     if (::stat(aPath, &sb) < 0) {
-        debugs(47, DBG_CRITICAL, "ERROR: " << aPath << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(47, DBG_CRITICAL, "ERROR: " << aPath << ": " << xstrerr(xerrno));
         return false;
     }
 
@@ -728,7 +730,8 @@ Fs::Ufs::UFSSwapDir::openLog()
     swaplog_fd = file_open(logPath, O_WRONLY | O_CREAT | O_BINARY);
 
     if (swaplog_fd < 0) {
-        debugs(50, DBG_IMPORTANT, "ERROR opening swap log " << logPath << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "ERROR opening swap log " << logPath << ": " << xstrerr(xerrno));
         fatal("UFSSwapDir::openLog: Failed to open swap log.");
     }
 
@@ -851,7 +854,8 @@ Fs::Ufs::UFSSwapDir::closeTmpSwapLog()
     fd = file_open(swaplog_path, O_WRONLY | O_CREAT | O_BINARY);
 
     if (fd < 0) {
-        debugs(50, DBG_IMPORTANT, "ERROR: " << swaplog_path << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "ERROR: " << swaplog_path << ": " << xstrerr(xerrno));
         fatalf("Failed to open swap log %s", swaplog_path);
     }
 
@@ -892,7 +896,8 @@ Fs::Ufs::UFSSwapDir::openTmpSwapLog(int *clean_flag, int *zero_flag)
     fd = file_open(new_path, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY);
 
     if (fd < 0) {
-        debugs(50, DBG_IMPORTANT, "ERROR: while opening swap log" << new_path << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "ERROR: while opening swap log" << new_path << ": " << xstrerr(xerrno));
         fatalf("Failed to open swap log %s", new_path);
     }
 
@@ -913,8 +918,9 @@ Fs::Ufs::UFSSwapDir::openTmpSwapLog(int *clean_flag, int *zero_flag)
     /* open a read-only stream of the old log */
     fp = fopen(swaplog_path, "rb");
 
-    if (fp == NULL) {
-        debugs(50, DBG_CRITICAL, "ERROR: while opening " << swaplog_path << ": " << xstrerror());
+    if (!fp) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "ERROR: while opening " << swaplog_path << ": " << xstrerr(xerrno));
         fatalf("Failed to open swap log for reading %s", swaplog_path);
     }
 
@@ -1002,8 +1008,9 @@ Fs::Ufs::UFSSwapDir::writeCleanDone()
     state->walker->Done(state->walker);
 
     if (FD_WRITE_METHOD(state->fd, state->outbuf, state->outbuf_offset) < 0) {
-        debugs(50, DBG_CRITICAL, HERE << state->newLog << ": write: " << xstrerror());
-        debugs(50, DBG_CRITICAL, HERE << "Current swap logfile not replaced.");
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << state->newLog << ": write: " << xstrerr(xerrno));
+        debugs(50, DBG_CRITICAL, MYNAME << "Current swap logfile not replaced.");
         file_close(state->fd);
         state->fd = -1;
         ::unlink(state->newLog);
@@ -1327,14 +1334,15 @@ Fs::Ufs::UFSSwapDir::DirClean(int swap_index)
     debugs(36, 3, HERE << "Cleaning directory " << p1);
     dir_pointer = opendir(p1);
 
-    if (dir_pointer == NULL) {
-        if (errno == ENOENT) {
-            debugs(36, DBG_CRITICAL, HERE << "WARNING: Creating " << p1);
+    if (!dir_pointer) {
+        int xerrno = errno;
+        if (xerrno == ENOENT) {
+            debugs(36, DBG_CRITICAL, MYNAME << "WARNING: Creating " << p1);
             if (mkdir(p1, 0777) == 0)
                 return 0;
         }
 
-        debugs(50, DBG_CRITICAL, HERE << p1 << ": " << xstrerror());
+        debugs(50, DBG_CRITICAL, MYNAME << p1 << ": " << xstrerr(xerrno));
         safeunlink(p1, 1);
         return 0;
     }
@@ -58,10 +58,11 @@ file_open(const char *path, int mode)
     ++ statCounter.syscalls.disk.opens;
 
     if (fd < 0) {
-        debugs(50, 3, "file_open: error opening file " << path << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, 3, "error opening file " << path << ": " << xstrerr(xerrno));
         fd = DISK_ERROR;
     } else {
-        debugs(6, 5, "file_open: FD " << fd);
+        debugs(6, 5, "FD " << fd);
         commSetCloseOnExec(fd);
         fd_open(fd, FD_FILE, path);
     }
@@ -216,7 +217,8 @@ diskHandleWrite(int fd, void *)
     if (fdd->write_q->file_offset != -1) {
         errno = 0;
         if (lseek(fd, fdd->write_q->file_offset, SEEK_SET) == -1) {
-            debugs(50, DBG_IMPORTANT, "error in seek for fd " << fd << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(50, DBG_IMPORTANT, "error in seek for FD " << fd << ": " << xstrerr(xerrno));
             // XXX: handle error?
         }
     }
@@ -234,7 +236,8 @@ diskHandleWrite(int fd, void *)
     if (len < 0) {
         if (!ignoreErrno(errno)) {
             status = errno == ENOSPC ? DISK_NO_SPACE_LEFT : DISK_ERROR;
-            debugs(50, DBG_IMPORTANT, "diskHandleWrite: FD " << fd << ": disk write error: " << xstrerror());
+            int xerrno = errno;
+            debugs(50, DBG_IMPORTANT, "diskHandleWrite: FD " << fd << ": disk write error: " << xstrerr(xerrno));
 
             /*
              * If there is no write callback, then this file is
@@ -402,6 +405,8 @@ diskHandleRead(int fd, void *data)
     fde *F = &fd_table[fd];
     int len;
     int rc = DISK_OK;
+    int xerrno;
+
     /*
      * FD < 0 indicates premature close; we just have to free
      * the state data.
@@ -422,8 +427,9 @@ diskHandleRead(int fd, void *data)
         debugs(6, 3, "diskHandleRead: FD " << fd << " seeking to offset " << ctrl_dat->offset);
         errno = 0;
         if (lseek(fd, ctrl_dat->offset, SEEK_SET) == -1) {
+            xerrno = errno;
             // shouldn't happen, let's detect that
-            debugs(50, DBG_IMPORTANT, "error in seek for fd " << fd << ": " << xstrerror());
+            debugs(50, DBG_IMPORTANT, "error in seek for FD " << fd << ": " << xstrerr(xerrno));
             // XXX handle failures?
         }
         ++ statCounter.syscalls.disk.seeks;
@@ -432,6 +438,7 @@ diskHandleRead(int fd, void *data)
 
     errno = 0;
     len = FD_READ_METHOD(fd, ctrl_dat->buf, ctrl_dat->req_len);
+    xerrno = errno;
 
     if (len > 0)
         F->disk.offset += len;
@@ -441,13 +448,13 @@ diskHandleRead(int fd, void *data)
     fd_bytes(fd, len, FD_READ);
 
     if (len < 0) {
-        if (ignoreErrno(errno)) {
+        if (ignoreErrno(xerrno)) {
             Comm::SetSelect(fd, COMM_SELECT_READ, diskHandleRead, ctrl_dat, 0);
             PROF_stop(diskHandleRead);
             return;
         }
 
-        debugs(50, DBG_IMPORTANT, "diskHandleRead: FD " << fd << ": " << xstrerror());
+        debugs(50, DBG_IMPORTANT, "diskHandleRead: FD " << fd << ": " << xstrerr(xerrno));
         len = 0;
         rc = DISK_ERROR;
     } else if (len == 0) {
@@ -491,8 +498,10 @@ safeunlink(const char *s, int quiet)
 {
     ++ statCounter.syscalls.disk.unlinks;
 
-    if (unlink(s) < 0 && !quiet)
-        debugs(50, DBG_IMPORTANT, "safeunlink: Couldn't delete " << s << ": " << xstrerror());
+    if (unlink(s) < 0 && !quiet) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "safeunlink: Couldn't delete " << s << ": " << xstrerr(xerrno));
+    }
 }
 
 /*
@@ -511,7 +520,8 @@ xrename(const char *from, const char *to)
     if (0 == rename(from, to))
         return 0;
 
-    debugs(21, errno == ENOENT ? 2 : 1, "xrename: Cannot rename " << from << " to " << to << ": " << xstrerror());
+    int xerrno = errno;
+    debugs(21, errno == ENOENT ? 2 : 1, "xrename: Cannot rename " << from << " to " << to << ": " << xstrerr(xerrno));
 
     return -1;
 }
@@ -522,7 +532,8 @@ fsBlockSize(const char *path, int *blksize)
     struct statvfs sfs;
 
     if (xstatvfs(path, &sfs)) {
-        debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerr(xerrno));
         *blksize = 2048;
         return 1;
     }
@@ -545,7 +556,8 @@ fsStats(const char *path, int *totl_kb, int *free_kb, int *totl_in, int *free_in
     struct statvfs sfs;
 
     if (xstatvfs(path, &sfs)) {
-        debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "" << path << ": " << xstrerr(xerrno));
         return 1;
     }
 
@@ -784,7 +784,7 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm
     }
 
     if (flag != Comm::OK) {
-        debugs(50, DBG_IMPORTANT, "gopherReadReply: error reading: " << xstrerror());
+        debugs(50, DBG_IMPORTANT, MYNAME << "error reading: " << xstrerr(xerrno));
 
         if (ignoreErrno(xerrno)) {
             AsyncCall::Pointer call = commCbCall(5,4, "gopherReadReply",
@@ -576,12 +576,13 @@ htcpBuildPacket(char *buf, size_t buflen, htcpStuff * stuff)
 static void
 htcpSend(const char *buf, int len, Ip::Address &to)
 {
-    debugs(31, 3, HERE << to);
+    debugs(31, 3, to);
     htcpHexdump("htcpSend", buf, len);
 
-    if (comm_udp_sendto(htcpOutgoingConn->fd, to, buf, len) < 0)
-        debugs(31, 3, HERE << htcpOutgoingConn << " sendto: " << xstrerror());
-    else
+    if (comm_udp_sendto(htcpOutgoingConn->fd, to, buf, len) < 0) {
+        int xerrno = errno;
+        debugs(31, 3, htcpOutgoingConn << " sendto: " << xstrerr(xerrno));
+    } else
         ++statCounter.htcp.pkts_sent;
 }
 
@@ -69,7 +69,8 @@ Icmp4::Open(void)
     icmp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);
 
     if (icmp_sock < 0) {
-        debugs(50, DBG_CRITICAL, HERE << " icmp_sock: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << " icmp_sock: " << xstrerr(xerrno));
         return -1;
     }
 
@@ -142,7 +143,8 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
                S->ai_addrlen);
 
     if (x < 0) {
-        debugs(42, DBG_IMPORTANT, HERE << "Error sending to ICMP packet to " << to << ". ERR: " << xstrerror());
+        int xerrno = errno;
+        debugs(42, DBG_IMPORTANT, MYNAME << "ERROR: sending to ICMP packet to " << to << ": " << xstrerr(xerrno));
     }
 
     Log(to, ' ', NULL, 0, 0);
@@ -101,7 +101,8 @@ Icmp6::Open(void)
     icmp_sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
 
     if (icmp_sock < 0) {
-        debugs(50, DBG_CRITICAL, HERE << " icmp_sock: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << " icmp_sock: " << xstrerr(xerrno));
         return -1;
     }
 
@@ -178,7 +179,8 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
                S->ai_addrlen);
 
     if (x < 0) {
-        debugs(42, DBG_IMPORTANT, HERE << "Error sending to ICMPv6 packet to " << to << ". ERR: " << xstrerror());
+        int xerrno = errno;
+        debugs(42, DBG_IMPORTANT, MYNAME << "ERROR: sending to ICMPv6 packet to " << to << ": " << xstrerr(xerrno));
     }
     debugs(42,9, HERE << "x=" << x);
 
@@ -54,6 +54,7 @@ IcmpPinger::Open(void)
     int x;
 
     struct sockaddr_in PS;
+    int xerrno;
 
     WSAStartup(2, &wsaData);
     atexit(Win32SockCleanup);
@@ -65,8 +66,9 @@ IcmpPinger::Open(void)
     x = read(0, buf, sizeof(wpi));
 
     if (x < (int)sizeof(wpi)) {
+        xerrno = errno;
         getCurrentTime();
-        debugs(42, DBG_CRITICAL, HERE << "read: FD 0: " << xstrerror());
+        debugs(42, DBG_CRITICAL, MYNAME << " read: FD 0: " << xstrerr(xerrno));
         write(1, "ERR\n", 4);
         return -1;
     }
@@ -77,8 +79,9 @@ IcmpPinger::Open(void)
     x = read(0, buf, sizeof(PS));
 
     if (x < (int)sizeof(PS)) {
+        xerrno = errno;
         getCurrentTime();
-        debugs(42, DBG_CRITICAL, HERE << "read: FD 0: " << xstrerror());
+        debugs(42, DBG_CRITICAL, MYNAME << " read: FD 0: " << xstrerr(xerrno));
         write(1, "ERR\n", 4);
         return -1;
     }
@@ -88,17 +91,19 @@ IcmpPinger::Open(void)
     icmp_sock = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, &wpi, 0, 0);
 
     if (icmp_sock == -1) {
+        xerrno = errno;
         getCurrentTime();
-        debugs(42, DBG_CRITICAL, HERE << "WSASocket: " << xstrerror());
+        debugs(42, DBG_CRITICAL, MYNAME << "WSASocket: " << xstrerr(xerrno));
         write(1, "ERR\n", 4);
         return -1;
     }
 
     x = connect(icmp_sock, (struct sockaddr *) &PS, sizeof(PS));
 
     if (SOCKET_ERROR == x) {
+        xerrno = errno;
         getCurrentTime();
-        debugs(42, DBG_CRITICAL, HERE << "connect: " << xstrerror());
+        debugs(42, DBG_CRITICAL, MYNAME << "connect: " << xstrerr(xerrno));
         write(1, "ERR\n", 4);
         return -1;
     }
@@ -108,14 +113,16 @@ IcmpPinger::Open(void)
     x = recv(icmp_sock, (void *) buf, sizeof(buf), 0);
 
     if (x < 3) {
-        debugs(42, DBG_CRITICAL, HERE << "recv: " << xstrerror());
+        xerrno = errno;
+        debugs(42, DBG_CRITICAL, MYNAME << "recv: " << xstrerr(xerrno));
         return -1;
     }
 
     x = send(icmp_sock, (const void *) buf, strlen(buf), 0);
+    xerrno = errno;
 
     if (x < 3 || strncmp("OK\n", buf, 3)) {
-        debugs(42, DBG_CRITICAL, HERE << "recv: " << xstrerror());
+        debugs(42, DBG_CRITICAL, MYNAME << "recv: " << xstrerr(xerrno));
         return -1;
     }
 
@@ -211,7 +218,8 @@ IcmpPinger::SendResult(pingerReplyData &preply, int len)
     debugs(42, 2, HERE << "return result to squid. len=" << len);
 
     if (send(socket_to_squid, &preply, len, 0) < 0) {
-        debugs(42, DBG_CRITICAL, "pinger: FATAL error on send: " << xstrerror());
+        int xerrno = errno;
+        debugs(42, DBG_CRITICAL, "pinger: FATAL error on send: " << xstrerr(xerrno));
         Close();
         exit(1);
     }
@@ -93,11 +93,12 @@ IcmpSquid::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     x = comm_udp_send(icmp_sock, (char *)&pecho, slen, 0);
 
     if (x < 0) {
-        debugs(37, DBG_IMPORTANT, HERE << "send: " << xstrerror());
+        int xerrno = errno;
+        debugs(37, DBG_IMPORTANT, MYNAME << "send: " << xstrerr(xerrno));
 
         /** \li  If the send results in ECONNREFUSED or EPIPE errors from helper, will cleanly shutdown the module. */
         /** \todo This should try restarting the helper a few times?? before giving up? */
-        if (errno == ECONNREFUSED || errno == EPIPE) {
+        if (xerrno == ECONNREFUSED || xerrno == EPIPE) {
             Close();
             return;
         }
@@ -131,12 +132,13 @@ IcmpSquid::Recv()
                       0);
 
     if (n < 0 && EAGAIN != errno) {
-        debugs(37, DBG_IMPORTANT, HERE << "recv: " << xstrerror());
+        int xerrno = errno;
+        debugs(37, DBG_IMPORTANT, MYNAME << "recv: " << xstrerr(xerrno));
 
-        if (errno == ECONNREFUSED)
+        if (xerrno == ECONNREFUSED)
             Close();
 
-        if (errno == ECONNRESET)
+        if (xerrno == ECONNRESET)
             Close();
 
         if (++fail_count == 10)
@@ -499,8 +499,9 @@ netdbSaveState(void *foo)
     unlink(Config.netdbFilename);
     lf = logfileOpen(Config.netdbFilename, 4096, 0);
 
-    if (NULL == lf) {
-        debugs(50, DBG_IMPORTANT, "netdbSaveState: " << Config.netdbFilename << ": " << xstrerror());
+    if (lf) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, MYNAME << Config.netdbFilename << ": " << xstrerr(xerrno));
         return;
     }
 
@@ -600,18 +600,18 @@ icpHandleUdp(int sock, void *)
             break;
 
         if (len < 0) {
-            if (ignoreErrno(errno))
+            int xerrno = errno;
+            if (ignoreErrno(xerrno))
                 break;
 
 #if _SQUID_LINUX_
             /* Some Linux systems seem to set the FD for reading and then
              * return ECONNREFUSED when sendto() fails and generates an ICMP
              * port unreachable message. */
             /* or maybe an EHOSTUNREACH "No route to host" message */
-            if (errno != ECONNREFUSED && errno != EHOSTUNREACH)
+            if (xerrno != ECONNREFUSED && xerrno != EHOSTUNREACH)
 #endif
-
-                debugs(50, DBG_IMPORTANT, "icpHandleUdp: FD " << sock << " recvfrom: " << xstrerror());
+                debugs(50, DBG_IMPORTANT, "icpHandleUdp: FD " << sock << " recvfrom: " << xstrerr(xerrno));
 
             break;
         }
@@ -141,7 +141,8 @@ Ip::Intercept::NetfilterInterception(const Comm::ConnectionPointer &newConn, int
                     &lookup,
                     &len) != 0) {
         if (!silent) {
-            debugs(89, DBG_IMPORTANT, "ERROR: NF getsockopt(ORIGINAL_DST) failed on " << newConn << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(89, DBG_IMPORTANT, "ERROR: NF getsockopt(ORIGINAL_DST) failed on " << newConn << ": " << xstrerr(xerrno));
             lastReported_ = squid_curtime;
         }
         debugs(89, 9, "address: " << newConn);
@@ -235,7 +236,8 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
 
     if (natfd < 0) {
         if (!silent) {
-            debugs(89, DBG_IMPORTANT, "IPF (IPFilter) NAT open failed: " << xstrerror());
+            int xerrno = errno;
+            debugs(89, DBG_IMPORTANT, "IPF (IPFilter) NAT open failed: " << xstrerr(xerrno));
             lastReported_ = squid_curtime;
             return false;
         }
@@ -268,9 +270,10 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
 
 #endif
     if (x < 0) {
-        if (errno != ESRCH) {
+        int xerrno = errno;
+        if (xerrno != ESRCH) {
             if (!silent) {
-                debugs(89, DBG_IMPORTANT, "IPF (IPFilter) NAT lookup failed: ioctl(SIOCGNATL) (v=" << IPFILTER_VERSION << "): " << xstrerror());
+                debugs(89, DBG_IMPORTANT, "IPF (IPFilter) NAT lookup failed: ioctl(SIOCGNATL) (v=" << IPFILTER_VERSION << "): " << xstrerr(xerrno));
                 lastReported_ = squid_curtime;
             }
 
@@ -316,7 +319,8 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
 
     if (pffd < 0) {
         if (!silent) {
-            debugs(89, DBG_IMPORTANT, HERE << "PF open failed: " << xstrerror());
+            int xerrno = errno;
+            debugs(89, DBG_IMPORTANT, MYNAME << "PF open failed: " << xstrerr(xerrno));
             lastReported_ = squid_curtime;
         }
         return false;
@@ -334,9 +338,10 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
     nl.direction = PF_OUT;
 
     if (ioctl(pffd, DIOCNATLOOK, &nl)) {
-        if (errno != ENOENT) {
+        int xerrno = errno;
+        if (xerrno != ENOENT) {
             if (!silent) {
-                debugs(89, DBG_IMPORTANT, HERE << "PF lookup failed: ioctl(DIOCNATLOOK)");
+                debugs(89, DBG_IMPORTANT, HERE << "PF lookup failed: ioctl(DIOCNATLOOK): " << xstrerr(xerrno));
                 lastReported_ = squid_curtime;
             }
             close(pffd);
@@ -24,8 +24,10 @@ Ip::Qos::setSockTos(const int fd, tos_t tos, int type)
     if (type == AF_INET) {
 #if defined(IP_TOS)
         const int x = setsockopt(fd, IPPROTO_IP, IP_TOS, &bTos, sizeof(bTos));
-        if (x < 0)
-            debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IP_TOS) on " << fd << ": " << xstrerror());
+        if (x < 0) {
+            int xerrno = errno;
+            debugs(50, 2, "setsockopt(IP_TOS) on " << fd << ": " << xstrerr(xerrno));
+        }
         return x;
 #else
         debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(IP_TOS) not supported on this platform");
@@ -34,8 +36,10 @@ Ip::Qos::setSockTos(const int fd, tos_t tos, int type)
     } else { // type == AF_INET6
 #if defined(IPV6_TCLASS)
         const int x = setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS, &bTos, sizeof(bTos));
-        if (x < 0)
-            debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IPV6_TCLASS) on " << fd << ": " << xstrerror());
+        if (x < 0) {
+            int xerrno = errno;
+            debugs(50, 2, "setsockopt(IPV6_TCLASS) on " << fd << ": " << xstrerr(xerrno));
+        }
         return x;
 #else
         debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(IPV6_TCLASS) not supported on this platform");
@@ -60,8 +64,10 @@ Ip::Qos::setSockNfmark(const int fd, nfmark_t mark)
 #if SO_MARK && USE_LIBCAP
     debugs(50, 3, "for FD " << fd << " to " << mark);
     const int x = setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(nfmark_t));
-    if (x < 0)
-        debugs(50, 2, "setSockNfmark: setsockopt(SO_MARK) on " << fd << ": " << xstrerror());
+    if (x < 0) {
+        int xerrno = errno;
+        debugs(50, 2, "setsockopt(SO_MARK) on " << fd << ": " << xstrerr(xerrno));
+    }
     return x;
 #elif USE_LIBCAP
     debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(SO_MARK) not supported on this platform");
@@ -68,10 +68,12 @@ Ip::Qos::getTosFromServer(const Comm::ConnectionPointer &server, fde *clientFde)
                 pbuf += CMSG_LEN(o->cmsg_len);
             }
         } else {
-            debugs(33, DBG_IMPORTANT, "QOS: error in getsockopt(IP_PKTOPTIONS) on " << server << " " << xstrerror());
+            int xerrno = errno;
+            debugs(33, DBG_IMPORTANT, "QOS: error in getsockopt(IP_PKTOPTIONS) on " << server << " " << xstrerr(xerrno));
         }
     } else {
-        debugs(33, DBG_IMPORTANT, "QOS: error in setsockopt(IP_RECVTOS) on " << server << " " << xstrerror());
+        int xerrno = errno;
+        debugs(33, DBG_IMPORTANT, "QOS: error in setsockopt(IP_RECVTOS) on " << server << " " << xstrerr(xerrno));
     }
 #endif
 }
@@ -72,6 +72,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     int fd;
     int t1, t2, t3;
     int x;
+    int xerrno;
 
 #if USE_POLL && _SQUID_OSF_
     assert(type != IPC_FIFO);
@@ -124,14 +125,16 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         int c2p[2];
 
         if (pipe(p2c) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: pipe: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: pipe: " << xstrerr(xerrno));
             return -1; // maybe ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
         fd_open(prfd = p2c[0], FD_PIPE, "IPC FIFO Parent Read");
         fd_open(cwfd = p2c[1], FD_PIPE, "IPC FIFO Child Write");
 
         if (pipe(c2p) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: pipe: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: pipe: " << xstrerr(xerrno));
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
         fd_open(crfd = c2p[0], FD_PIPE, "IPC FIFO Child Read");
@@ -147,25 +150,30 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         int buflen = 32768;
 
         if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: socketpair: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: socketpair: " << xstrerr(xerrno));
             return -1;
         }
 
         errno = 0;
         if (setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1)  {
-            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerr(xerrno));
             errno = 0;
         }
         if (setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {
-            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerr(xerrno));
             errno = 0;
         }
         if (setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1) {
-            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerr(xerrno));
             errno = 0;
         }
         if (setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {
-            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerr(xerrno));
             errno = 0;
         }
         fd_open(prfd = pwfd = fds[0], FD_PIPE, "IPC UNIX STREAM Parent");
@@ -177,7 +185,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         int fds[2];
 
         if (socketpair(AF_UNIX, SOCK_DGRAM, 0, fds) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: socketpair: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: socketpair: " << xstrerr(xerrno));
             return -1;
         }
 
@@ -201,8 +210,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         Ip::Address::InitAddr(AI);
 
         if (getsockname(pwfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
+            xerrno = errno;
             Ip::Address::FreeAddr(AI);
-            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerr(xerrno));
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
@@ -215,8 +225,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         Ip::Address::InitAddr(AI);
 
         if (getsockname(crfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
+            xerrno = errno;
             Ip::Address::FreeAddr(AI);
-            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerr(xerrno));
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
@@ -230,7 +241,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 
     if (type == IPC_TCP_SOCKET) {
         if (listen(crfd, 1) < 0) {
-            debugs(54, DBG_IMPORTANT, "ipcCreate: listen FD " << crfd << ": " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_IMPORTANT, "ipcCreate: listen FD " << crfd << ": " << xstrerr(xerrno));
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
@@ -241,7 +253,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     logsFlush();
 
     if ((pid = fork()) < 0) {
-        debugs(54, DBG_IMPORTANT, "ipcCreate: fork: " << xstrerror());
+        xerrno = errno;
+        debugs(54, DBG_IMPORTANT, "ipcCreate: fork: " << xstrerr(xerrno));
         return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
     }
 
@@ -263,12 +276,13 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
             x = comm_udp_recv(prfd, hello_buf, sizeof(hello_buf)-1, 0);
         else
             x = read(prfd, hello_buf, sizeof(hello_buf)-1);
+        xerrno = errno;
         if (x >= 0)
             hello_buf[x] = '\0';
 
         if (x < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: PARENT: hello read test failed");
-            debugs(54, DBG_CRITICAL, "--> read: " << xstrerror());
+            debugs(54, DBG_CRITICAL, "--> read: " << xstrerr(xerrno));
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         } else if (strcmp(hello_buf, hello_string)) {
             debugs(54, DBG_CRITICAL, "ipcCreate: PARENT: hello read test failed");
@@ -319,7 +333,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         debugs(54, 3, "ipcCreate: calling accept on FD " << crfd);
 
         if ((fd = accept(crfd, NULL, NULL)) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: FD " << crfd << " accept: " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: FD " << crfd << " accept: " << xstrerr(xerrno));
             _exit(1);
         }
 
@@ -335,13 +350,15 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         x = comm_udp_send(cwfd, hello_string, strlen(hello_string) + 1, 0);
 
         if (x < 0) {
-            debugs(54, DBG_CRITICAL, "sendto FD " << cwfd << ": " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "sendto FD " << cwfd << ": " << xstrerr(xerrno));
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: hello write test failed");
             _exit(1);
         }
     } else {
         if (write(cwfd, hello_string, strlen(hello_string) + 1) < 0) {
-            debugs(54, DBG_CRITICAL, "write FD " << cwfd << ": " << xstrerror());
+            xerrno = errno;
+            debugs(54, DBG_CRITICAL, "write FD " << cwfd << ": " << xstrerr(xerrno));
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: hello write test failed");
             _exit(1);
         }
@@ -397,10 +414,11 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 #endif
 
     execvp(prog, (char *const *) args);
+    xerrno = errno;
 
     debug_log = fdopen(2, "a+");
 
-    debugs(54, DBG_CRITICAL, "ipcCreate: " << prog << ": " << xstrerror());
+    debugs(54, DBG_CRITICAL, "ipcCreate: " << prog << ": " << xstrerr(xerrno));
 
     _exit(1);
 
@@ -204,7 +204,8 @@ Ipc::ImportFdIntoComm(const Comm::ConnectionPointer &conn, int socktype, int pro
         comm_import_opened(conn, Ipc::FdNote(noteId), addr_info);
         Ip::Address::FreeAddr(addr_info);
     } else {
-        debugs(54, DBG_CRITICAL, "ERROR: Ipc::ImportFdIntoComm: " << conn << ' ' << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_CRITICAL, "ERROR: Ipc::ImportFdIntoComm: " << conn << ' ' << xstrerr(xerrno));
         conn->close();
     }
     return conn;
@@ -69,8 +69,10 @@ Ipc::Mem::Segment::~Segment()
 {
     if (theFD >= 0) {
         detach();
-        if (close(theFD) != 0)
-            debugs(54, 5, HERE << "close " << theName << ": " << xstrerror());
+        if (close(theFD) != 0) {
+            int xerrno = errno;
+            debugs(54, 5, "close " << theName << ": " << xstrerr(xerrno));
+        }
     }
     if (doUnlink)
         unlink();
@@ -89,19 +91,21 @@ Ipc::Mem::Segment::create(const off_t aSize)
     assert(aSize > 0);
     assert(theFD < 0);
 
+    int xerrno = errno; // XXX: where does errno come from?
+
     // Why a brand new segment? A Squid crash may leave a reusable segment, but
     // our placement-new code requires an all-0s segment. We could truncate and
     // resize the old segment, but OS X does not allow using O_TRUNC with
     // shm_open() and does not support ftruncate() for old segments.
-    if (!createFresh() && errno == EEXIST) {
+    if (!createFresh() && xerrno == EEXIST) {
         unlink();
         createFresh();
     }
 
     if (theFD < 0) {
-        debugs(54, 5, HERE << "shm_open " << theName << ": " << xstrerror());
+        debugs(54, 5, "shm_open " << theName << ": " << xstrerr(xerrno));
         fatalf("Ipc::Mem::Segment::create failed to shm_open(%s): %s\n",
-               theName.termedBuf(), xstrerror());
+               theName.termedBuf(), xstrerr(xerrno));
     }
 
     if (ftruncate(theFD, aSize)) {
@@ -133,9 +137,10 @@ Ipc::Mem::Segment::open()
 
     theFD = shm_open(theName.termedBuf(), O_RDWR, 0);
     if (theFD < 0) {
-        debugs(54, 5, HERE << "shm_open " << theName << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(54, 5, "shm_open " << theName << ": " << xstrerr(xerrno));
         fatalf("Ipc::Mem::Segment::open failed to shm_open(%s): %s\n",
-               theName.termedBuf(), xstrerror());
+               theName.termedBuf(), xstrerr(xerrno));
     }
 
     theSize = statSize("Ipc::Mem::Segment::open");
@@ -170,9 +175,10 @@ Ipc::Mem::Segment::attach()
     void *const p =
         mmap(NULL, theSize, PROT_READ | PROT_WRITE, MAP_SHARED, theFD, 0);
     if (p == MAP_FAILED) {
-        debugs(54, 5, HERE << "mmap " << theName << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(54, 5, "mmap " << theName << ": " << xstrerr(xerrno));
         fatalf("Ipc::Mem::Segment::attach failed to mmap(%s): %s\n",
-               theName.termedBuf(), xstrerror());
+               theName.termedBuf(), xstrerr(xerrno));
     }
     theMem = p;
 
@@ -187,9 +193,10 @@ Ipc::Mem::Segment::detach()
         return;
 
     if (munmap(theMem, theSize)) {
-        debugs(54, 5, HERE << "munmap " << theName << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(54, 5, "munmap " << theName << ": " << xstrerr(xerrno));
         fatalf("Ipc::Mem::Segment::detach failed to munmap(%s): %s\n",
-               theName.termedBuf(), xstrerror());
+               theName.termedBuf(), xstrerr(xerrno));
     }
     theMem = 0;
 }
@@ -230,10 +237,11 @@ Ipc::Mem::Segment::lock()
 void
 Ipc::Mem::Segment::unlink()
 {
-    if (shm_unlink(theName.termedBuf()) != 0)
-        debugs(54, 5, HERE << "shm_unlink(" << theName << "): " << xstrerror());
-    else
-        debugs(54, 3, HERE << "unlinked " << theName << " segment");
+    if (shm_unlink(theName.termedBuf()) != 0) {
+        int xerrno = errno;
+        debugs(54, 5, "shm_unlink(" << theName << "): " << xstrerr(xerrno));
+    } else
+        debugs(54, 3, "unlinked " << theName << " segment");
 }
 
 /// determines the size of the underlying "file"
@@ -246,9 +254,10 @@ Ipc::Mem::Segment::statSize(const char *context) const
     memset(&s, 0, sizeof(s));
 
     if (fstat(theFD, &s) != 0) {
-        debugs(54, 5, HERE << context << " fstat " << theName << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(54, 5, context << " fstat " << theName << ": " << xstrerr(xerrno));
         fatalf("Ipc::Mem::Segment::statSize: %s failed to fstat(%s): %s\n",
-               context, theName.termedBuf(), xstrerror());
+               context, theName.termedBuf(), xstrerr(xerrno));
     }
 
     return s.st_size;
@@ -183,7 +183,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         Ip::Address::InitAddr(aiPS);
 
         if (getsockname(pwfd, aiPS->ai_addr, &(aiPS->ai_addrlen) ) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerr(xerrno));
             Ip::Address::FreeAddr(aiPS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
@@ -196,7 +197,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         Ip::Address::InitAddr(aiCS);
 
         if (getsockname(crfd, aiCS->ai_addr, &(aiCS->ai_addrlen) ) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerr(xerrno));
             Ip::Address::FreeAddr(aiCS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
@@ -210,7 +212,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 
     if (type == IPC_TCP_SOCKET) {
         if (listen(crfd, 1) < 0) {
-            debugs(54, DBG_IMPORTANT, "ipcCreate: listen FD " << crfd << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_IMPORTANT, "ipcCreate: listen FD " << crfd << ": " << xstrerr(xerrno));
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
@@ -237,7 +240,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     thread = _beginthreadex(NULL, 0, ipc_thread_1, &params, 0, NULL);
 
     if (thread == 0) {
-        debugs(54, DBG_IMPORTANT, "ipcCreate: _beginthread: " << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_IMPORTANT, "ipcCreate: _beginthread: " << xstrerr(xerrno));
         return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
     }
 
@@ -251,8 +255,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     x = recv(prfd, (void *)hello_buf, HELLO_BUF_SZ - 1, 0);
 
     if (x < 0) {
+        int xerrno = errno;
         debugs(54, DBG_CRITICAL, "ipcCreate: PARENT: hello read test failed");
-        debugs(54, DBG_CRITICAL, "--> read: " << xstrerror());
+        debugs(54, DBG_CRITICAL, "--> read: " << xstrerr(xerrno));
         CloseHandle((HANDLE) thread);
         return ipcCloseAllFD(prfd, pwfd, -1, -1);
     } else if (strcmp(hello_buf, hello_string)) {
@@ -266,8 +271,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     x = send(pwfd, (const void *)ok_string, strlen(ok_string), 0);
 
     if (x < 0) {
+        int xerrno = errno;
         debugs(54, DBG_CRITICAL, "ipcCreate: PARENT: OK write test failed");
-        debugs(54, DBG_CRITICAL, "--> read: " << xstrerror());
+        debugs(54, DBG_CRITICAL, "--> read: " << xstrerr(xerrno));
         CloseHandle((HANDLE) thread);
         return ipcCloseAllFD(prfd, pwfd, -1, -1);
     }
@@ -276,8 +282,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     x = recv(prfd, (void *)hello_buf, HELLO_BUF_SZ - 1, 0);
 
     if (x < 0) {
+        int xerrno = errno;
         debugs(54, DBG_CRITICAL, "ipcCreate: PARENT: OK read test failed");
-        debugs(54, DBG_CRITICAL, "--> read: " << xstrerror());
+        debugs(54, DBG_CRITICAL, "--> read: " << xstrerr(xerrno));
         CloseHandle((HANDLE) thread);
         return ipcCloseAllFD(prfd, pwfd, -1, -1);
     } else if (!strcmp(hello_buf, err_string)) {
@@ -332,12 +339,11 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 static int
 ipcSend(int cwfd, const char *buf, int len)
 {
-    int x;
-
-    x = send(cwfd, (const void *)buf, len, 0);
+    int x = send(cwfd, (const void *)buf, len, 0);
 
     if (x < 0) {
-        debugs(54, DBG_CRITICAL, "sendto FD " << cwfd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_CRITICAL, "sendto FD " << cwfd << ": " << xstrerr(xerrno));
         debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: hello write test failed");
     }
 
@@ -394,7 +400,8 @@ ipc_thread_1(void *in_params)
         debugs(54, 3, "ipcCreate: calling accept on FD " << crfd);
 
         if ((fd = accept(crfd, NULL, NULL)) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: FD " << crfd << " accept: " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: FD " << crfd << " accept: " << xstrerr(xerrno));
             goto cleanup;
         }
 
@@ -412,7 +419,8 @@ ipc_thread_1(void *in_params)
     x = send(cwfd, (const void *)hello_string, strlen(hello_string) + 1, 0);
 
     if (x < 0) {
-        debugs(54, DBG_CRITICAL, "sendto FD " << cwfd << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_CRITICAL, "sendto FD " << cwfd << ": " << xstrerr(xerrno));
         debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: hello write test failed");
         goto cleanup;
     }
@@ -422,8 +430,9 @@ ipc_thread_1(void *in_params)
     x = recv(crfd, (void *)buf1, bufSz-1, 0);
 
     if (x < 0) {
+        int xerrno = errno;
         debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: OK read test failed");
-        debugs(54, DBG_CRITICAL, "--> read: " << xstrerror());
+        debugs(54, DBG_CRITICAL, "--> read: " << xstrerr(xerrno));
         goto cleanup;
     } else if (strcmp(buf1, ok_string)) {
         debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: OK read test failed");
@@ -434,13 +443,15 @@ ipc_thread_1(void *in_params)
 
     /* assign file descriptors to child process */
     if (_pipe(p2c, 1024, _O_BINARY | _O_NOINHERIT) < 0) {
-        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: pipe: " << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: pipe: " << xstrerr(xerrno));
         ipcSend(cwfd, err_string, strlen(err_string));
         goto cleanup;
     }
 
     if (_pipe(c2p, 1024, _O_BINARY | _O_NOINHERIT) < 0) {
-        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: pipe: " << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: pipe: " << xstrerr(xerrno));
         ipcSend(cwfd, err_string, strlen(err_string));
         goto cleanup;
     }
@@ -467,7 +478,8 @@ ipc_thread_1(void *in_params)
         Ip::Address::InitAddr(aiPS_ipc);
 
         if (getsockname(pwfd_ipc, aiPS_ipc->ai_addr, &(aiPS_ipc->ai_addrlen)) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerr(xerrno));
             ipcSend(cwfd, err_string, strlen(err_string));
             Ip::Address::FreeAddr(aiPS_ipc);
             goto cleanup;
@@ -481,7 +493,8 @@ ipc_thread_1(void *in_params)
         Ip::Address::InitAddr(aiCS_ipc);
 
         if (getsockname(crfd_ipc, aiCS_ipc->ai_addr, &(aiCS_ipc->ai_addrlen)) < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerr(xerrno));
             ipcSend(cwfd, err_string, strlen(err_string));
             Ip::Address::FreeAddr(aiCS_ipc);
             goto cleanup;
@@ -577,8 +590,7 @@ ipc_thread_1(void *in_params)
     close(t3);
 
     if (pid == -1) {
-        errno = x;
-        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: " << params->prog << ": " << xstrerror());
+        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: " << params->prog << ": " << xstrerr(x));
 
         ipcSend(cwfd, err_string, strlen(err_string));
         goto cleanup;
@@ -590,28 +602,28 @@ ipc_thread_1(void *in_params)
         memset(&wpi, 0, sizeof(wpi));
 
         if (SOCKET_ERROR == WSADuplicateSocket(crfd_ipc, pid, &wpi)) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: WSADuplicateSocket: " << xstrerror());
-
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: WSADuplicateSocket: " << xstrerr(xerrno));
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
         }
 
         x = write(c2p[1], (const char *) &wpi, sizeof(wpi));
 
         if (x < (ssize_t)sizeof(wpi)) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: write FD " << c2p[1] << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: write FD " << c2p[1] << ": " << xstrerr(xerrno));
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: " << prog << ": socket exchange failed");
-
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
         }
 
         x = read(p2c[0], buf1, bufSz-1);
 
         if (x < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: read FD " << p2c[0] << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: read FD " << p2c[0] << ": " << xstrerr(xerrno));
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: " << prog << ": socket exchange failed");
-
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
         } else if (strncmp(buf1, ok_string, strlen(ok_string))) {
@@ -626,19 +638,19 @@ ipc_thread_1(void *in_params)
         x = write(c2p[1], (const char *) &PS_ipc, sizeof(PS_ipc));
 
         if (x < (ssize_t)sizeof(PS_ipc)) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: write FD " << c2p[1] << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: write FD " << c2p[1] << ": " << xstrerr(xerrno));
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: " << prog << ": socket exchange failed");
-
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
         }
 
         x = read(p2c[0], buf1, bufSz-1);
 
         if (x < 0) {
-            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: read FD " << p2c[0] << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: read FD " << p2c[0] << ": " << xstrerr(xerrno));
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: " << prog << ": socket exchange failed");
-
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
         } else if (strncmp(buf1, ok_string, strlen(ok_string))) {
@@ -684,7 +696,8 @@ ipc_thread_1(void *in_params)
     thread = (HANDLE)_beginthreadex(NULL, 0, ipc_thread_2, &thread_params, 0, NULL);
 
     if (!thread) {
-        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: _beginthreadex: " << xstrerror());
+        int xerrno = errno;
+        debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: _beginthreadex: " << xstrerr(xerrno));
         ipcSend(cwfd, err_string, strlen(err_string));
         goto cleanup;
     }
@@ -106,15 +106,16 @@ logfileHandleWrite(int, void *data)
     ll->flush_pending = 0;
 
     int ret = FD_WRITE_METHOD(ll->wfd, b->buf + b->written_len, b->len - b->written_len);
+    int xerrno = errno;
     debugs(50, 3, lf->path << ": write returned " << ret);
     if (ret < 0) {
-        if (ignoreErrno(errno)) {
+        if (ignoreErrno(xerrno)) {
             /* something temporary */
             Comm::SetSelect(ll->wfd, COMM_SELECT_WRITE, logfileHandleWrite, lf, 0);
             ll->flush_pending = 1;
             return;
         }
-        debugs(50, DBG_IMPORTANT,"logfileHandleWrite: " << lf->path << ": error writing (" << xstrerror() << ")");
+        debugs(50, DBG_IMPORTANT,"logfileHandleWrite: " << lf->path << ": error writing (" << xstrerr(xerrno) << ")");
         /* XXX should handle this better */
         fatal("I don't handle this error well!");
     }
@@ -37,6 +37,7 @@ logfileWriteWrapper(Logfile * lf, const void *buf, size_t len)
     l_stdio_t *ll = (l_stdio_t *) lf->data;
     size_t s;
     s = FD_WRITE_METHOD(ll->fd, (char const *) buf, len);
+    int xerrno = errno;
     fd_bytes(ll->fd, s, FD_WRITE);
 
     if (s == len)
@@ -45,7 +46,7 @@ logfileWriteWrapper(Logfile * lf, const void *buf, size_t len)
     if (!lf->flags.fatal)
         return;
 
-    fatalf("logfileWrite: %s: %s\n", lf->path, xstrerror());
+    fatalf("logfileWrite: %s: %s\n", lf->path, xstrerr(xerrno));
 }
 
 static void
@@ -142,8 +143,9 @@ logfile_mod_stdio_rotate(Logfile * lf, const int16_t nRotate)
     ll->fd = file_open(realpath, O_WRONLY | O_CREAT | O_TEXT);
 
     if (DISK_ERROR == ll->fd && lf->flags.fatal) {
-        debugs(50, DBG_CRITICAL, "ERROR: logfileRotate: " << lf->path << ": " << xstrerror());
-        fatalf("Cannot open %s: %s", lf->path, xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, MYNAME << "ERROR: " << lf->path << ": " << xstrerr(xerrno));
+        fatalf("Cannot open %s: %s", lf->path, xstrerr(xerrno));
     }
 }
 
@@ -182,19 +184,20 @@ logfile_mod_stdio_open(Logfile * lf, const char *path, size_t bufsz, int fatal_f
     ll->fd = file_open(path, O_WRONLY | O_CREAT | O_TEXT);
 
     if (DISK_ERROR == ll->fd) {
-        if (ENOENT == errno && fatal_flag) {
+        int xerrno = errno;
+        if (ENOENT == xerrno && fatal_flag) {
             fatalf("Cannot open '%s' because\n"
                    "\tthe parent directory does not exist.\n"
                    "\tPlease create the directory.\n", path);
-        } else if (EACCES == errno && fatal_flag) {
+        } else if (EACCES == xerrno && fatal_flag) {
             fatalf("Cannot open '%s' for writing.\n"
                    "\tThe parent directory must be writeable by the\n"
                    "\tuser '%s', which is the cache_effective_user\n"
                    "\tset in squid.conf.", path, Config.effectiveUser);
-        } else if (EISDIR == errno && fatal_flag) {
+        } else if (EISDIR == xerrno && fatal_flag) {
             fatalf("Cannot open '%s' because it is a directory, not a file.\n", path);
         } else {
-            debugs(50, DBG_IMPORTANT, "ERROR: logfileOpen " << lf->path << ": " << xstrerror());
+            debugs(50, DBG_IMPORTANT, MYNAME << "ERROR: " << lf->path << ": " << xstrerr(xerrno));
             return 0;
         }
     }
@@ -45,7 +45,8 @@ logfile_mod_udp_write(Logfile * lf, const char *buf, size_t len)
     fd_bytes(ll->fd, s, FD_WRITE);
 #if 0
     if (s < 0) {
-        debugs(1, DBG_IMPORTANT, "logfile (udp): got errno (" << errno << "):" << xstrerror());
+        int xerrno = errno;
+        debugs(1, DBG_IMPORTANT, "logfile (udp): got errno (" << errno << "):" << xstrerr(xerrno));
     }
     if (s != len) {
         debugs(1, DBG_IMPORTANT, "logfile (udp): len=" << len << ", wrote=" << s);
@@ -166,6 +167,7 @@ logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
         any_addr.setIPv4();
 
     ll->fd = comm_open(SOCK_DGRAM, IPPROTO_UDP, any_addr, COMM_NONBLOCKING, "UDP log socket");
+    int xerrno = errno;
     if (ll->fd < 0) {
         if (lf->flags.fatal) {
             fatalf("Unable to open UDP socket for logging\n");
@@ -174,25 +176,26 @@ logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
             return FALSE;
         }
     } else if (!comm_connect_addr(ll->fd, addr)) {
+        xerrno = errno;
         if (lf->flags.fatal) {
-            fatalf("Unable to connect to %s for UDP log: %s\n", lf->path, xstrerror());
+            fatalf("Unable to connect to %s for UDP log: %s\n", lf->path, xstrerr(xerrno));
         } else {
-            debugs(50, DBG_IMPORTANT, "Unable to connect to " << lf->path << " for UDP log: " << xstrerror());
+            debugs(50, DBG_IMPORTANT, "Unable to connect to " << lf->path << " for UDP log: " << xstrerr(xerrno));
             return FALSE;
         }
     }
     if (ll->fd == -1) {
-        if (ENOENT == errno && fatal_flag) {
+        if (ENOENT == xerrno && fatal_flag) {
             fatalf("Cannot open '%s' because\n"
                    "\tthe parent directory does not exist.\n"
                    "\tPlease create the directory.\n", path);
-        } else if (EACCES == errno && fatal_flag) {
+        } else if (EACCES == xerrno && fatal_flag) {
             fatalf("Cannot open '%s' for writing.\n"
                    "\tThe parent directory must be writeable by the\n"
                    "\tuser '%s', which is the cache_effective_user\n"
                    "\tset in squid.conf.", path, Config.effectiveUser);
         } else {
-            debugs(50, DBG_IMPORTANT, "logfileOpen (UDP): " << lf->path << ": " << xstrerror());
+            debugs(50, DBG_IMPORTANT, "logfileOpen (UDP): " << lf->path << ": " << xstrerr(xerrno));
             return 0;
         }
     }
@@ -55,22 +55,26 @@ rotate(const char *path, int rotate_count)
         snprintf(to, MAXPATHLEN, "%s.%d", path, i);
 #if _SQUID_OS2_ || _SQUID_WINDOWS_
         if (remove(to) < 0) {
-            fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerror());
+            int xerrno = errno;
+            fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerr(xerrno));
         }
 #endif
         if (rename(from, to) < 0 && errno != ENOENT) {
-            fprintf(stderr, "WARNING: rename '%s' to '%s' failure: %s\n", from, to, xstrerror());
+            int xerrno = errno;
+            fprintf(stderr, "WARNING: rename '%s' to '%s' failure: %s\n", from, to, xstrerr(xerrno));
         }
     }
     if (rotate_count > 0) {
         snprintf(to, MAXPATHLEN, "%s.%d", path, 0);
 #if _SQUID_OS2_ || _SQUID_WINDOWS_
         if (remove(to) < 0) {
-            fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerror());
+            int xerrno = errno;
+            fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerr(xerrno));
         }
 #endif
         if (rename(path, to) < 0 && errno != ENOENT) {
-            fprintf(stderr, "WARNING: rename %s to %s failure: %s\n", path, to, xstrerror());
+            int xerrno = errno;
+            fprintf(stderr, "WARNING: rename %s to %s failure: %s\n", path, to, xstrerr(xerrno));
         }
     }
 }
@@ -290,8 +290,10 @@ SignalEngine::doShutdown(time_t wait)
 #if KILL_PARENT_OPT
     if (!IamMasterProcess() && !parentKillNotified && ShutdownSignal > 0 && parentPid > 1) {
         debugs(1, DBG_IMPORTANT, "Killing master process, pid " << parentPid);
-        if (kill(parentPid, ShutdownSignal) < 0)
-            debugs(1, DBG_IMPORTANT, "kill " << parentPid << ": " << xstrerror());
+        if (kill(parentPid, ShutdownSignal) < 0) {
+            int xerrno = errno;
+            debugs(1, DBG_IMPORTANT, "kill " << parentPid << ": " << xstrerr(xerrno));
+        }
         parentKillNotified = true;
     }
 #endif
@@ -1058,8 +1060,9 @@ mainChangeDir(const char *dir)
     if (chdir(dir) == 0)
         return true;
 
-    debugs(50, DBG_CRITICAL, "cannot change current directory to " << dir <<
-           ": " << xstrerror());
+    int xerrno = errno;
+    debugs(50, DBG_CRITICAL, "ERROR: cannot change current directory to " << dir <<
+           ": " << xstrerr(xerrno));
     return false;
 }
 
@@ -1071,8 +1074,10 @@ mainSetCwd(void)
     if (Config.chroot_dir && !chrooted) {
         chrooted = true;
 
-        if (chroot(Config.chroot_dir) != 0)
-            fatalf("chroot to %s failed: %s", Config.chroot_dir, xstrerror());
+        if (chroot(Config.chroot_dir) != 0) {
+            int xerrno = errno;
+            fatalf("chroot to %s failed: %s", Config.chroot_dir, xstrerr(xerrno));
+        }
 
         if (!mainChangeDir("/"))
             fatalf("chdir to / after chroot to %s failed", Config.chroot_dir);
@@ -1090,7 +1095,8 @@ mainSetCwd(void)
     if (getcwd(pathbuf, MAXPATHLEN)) {
         debugs(0, DBG_IMPORTANT, "Current Directory is " << pathbuf);
     } else {
-        debugs(50, DBG_CRITICAL, "WARNING: Can't find current directory, getcwd: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "WARNING: Can't find current directory, getcwd: " << xstrerr(xerrno));
     }
 }
 
@@ -1684,9 +1690,10 @@ sendSignal(void)
         if (kill(pid, opt_send_signal) &&
                 /* ignore permissions if just running check */
                 !(opt_send_signal == 0 && errno == EPERM)) {
+            int xerrno = errno;
             fprintf(stderr, "%s: ERROR: Could not send ", APP_SHORTNAME);
             fprintf(stderr, "signal %d to process %d: %s\n",
-                    opt_send_signal, (int) pid, xstrerror());
+                    opt_send_signal, (int) pid, xstrerr(xerrno));
             exit(1);
         }
     } else {
@@ -1805,21 +1812,25 @@ watch_child(char *argv[])
 
     openlog(APP_SHORTNAME, LOG_PID | LOG_NDELAY | LOG_CONS, LOG_LOCAL4);
 
-    if ((pid = fork()) < 0)
-        syslog(LOG_ALERT, "fork failed: %s", xstrerror());
-    else if (pid > 0) {
+    if ((pid = fork()) < 0) {
+        int xerrno = errno;
+        syslog(LOG_ALERT, "fork failed: %s", xstrerr(xerrno));
+    } else if (pid > 0) {
         // parent
         if (opt_foreground) {
             if (WaitForAnyPid(status_f, 0) < 0) {
-                syslog(LOG_ALERT, "WaitForAnyPid failed: %s", xstrerror());
+                int xerrno = errno;
+                syslog(LOG_ALERT, "WaitForAnyPid failed: %s", xstrerr(xerrno));
             }
         }
 
         exit(0);
     }
 
-    if (setsid() < 0)
-        syslog(LOG_ALERT, "setsid failed: %s", xstrerror());
+    if (setsid() < 0) {
+        int xerrno = errno;
+        syslog(LOG_ALERT, "setsid failed: %s", xstrerr(xerrno));
+    }
 
     closelog();
 
@@ -1840,8 +1851,10 @@ watch_child(char *argv[])
     /* Connect stdio to /dev/null in daemon mode */
     nullfd = open(_PATH_DEVNULL, O_RDWR | O_TEXT);
 
-    if (nullfd < 0)
-        fatalf(_PATH_DEVNULL " %s\n", xstrerror());
+    if (nullfd < 0) {
+        int xerrno = errno;
+        fatalf(_PATH_DEVNULL " %s\n", xstrerr(xerrno));
+    }
 
     dup2(nullfd, 0);
 
@@ -1898,7 +1911,8 @@ watch_child(char *argv[])
                 prog = argv[0];
                 argv[0] = const_cast<char*>(kid.name().termedBuf());
                 execvp(prog, argv);
-                syslog(LOG_ALERT, "execvp failed: %s", xstrerror());
+                int xerrno = errno;
+                syslog(LOG_ALERT, "execvp failed: %s", xstrerr(xerrno));
             }
 
             kid.start(pid);
@@ -247,7 +247,8 @@ mimeInit(char *filename)
         return;
 
     if ((fp = fopen(filename, "r")) == NULL) {
-        debugs(25, DBG_IMPORTANT, "mimeInit: " << filename << ": " << xstrerror());
+        int xerrno = errno;
+        debugs(25, DBG_IMPORTANT, "mimeInit: " << filename << ": " << xstrerr(xerrno));
         return;
     }
 
@@ -22,9 +22,10 @@ mcastSetTtl(int fd, int mcast_ttl)
 #ifdef IP_MULTICAST_TTL
     char ttl = (char) mcast_ttl;
 
-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, 1) < 0)
-        debugs(50, DBG_IMPORTANT, "comm_set_mcast_ttl: FD " << fd << ", TTL: " << mcast_ttl << ": " << xstrerror());
-
+    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, 1) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "mcastSetTtl: FD " << fd << ", TTL: " << mcast_ttl << ": " << xstrerr(xerrno));
+    }
 #endif
 
     return 0;
@@ -58,8 +59,10 @@ mcastJoinGroups(const ipcache_addrs *ia, const Dns::LookupDetails &, void *)
             debugs(7, DBG_IMPORTANT, "ERROR: Join failed for " << icpIncomingConn << ", Multicast IP=" << ia->in_addrs[i]);
 
         char c = 0;
-        if (setsockopt(icpIncomingConn->fd, IPPROTO_IP, IP_MULTICAST_LOOP, &c, 1) < 0)
-            debugs(7, DBG_IMPORTANT, "ERROR: " << icpIncomingConn << " can't disable multicast loopback: " << xstrerror());
+        if (setsockopt(icpIncomingConn->fd, IPPROTO_IP, IP_MULTICAST_LOOP, &c, 1) < 0) {
+            int xerrno = errno;
+            debugs(7, DBG_IMPORTANT, "ERROR: " << icpIncomingConn << " can't disable multicast loopback: " << xstrerr(xerrno));
+        }
     }
 
 #endif
@@ -87,15 +87,18 @@ send_announce(const ipcache_addrs *ia, const Dns::LookupDetails &, void *)
             sndbuf[l] = '\0';
             file_close(fd);
         } else {
-            debugs(50, DBG_IMPORTANT, "send_announce: " << file << ": " << xstrerror());
+            int xerrno = errno;
+            debugs(50, DBG_IMPORTANT, "send_announce: " << file << ": " << xstrerr(xerrno));
         }
     }
 
     Ip::Address S = ia->in_addrs[0];
     S.port(port);
     assert(Comm::IsConnOpen(icpOutgoingConn));
 
-    if (comm_udp_sendto(icpOutgoingConn->fd, S, sndbuf, strlen(sndbuf) + 1) < 0)
-        debugs(27, DBG_IMPORTANT, "ERROR: Failed to announce to " << S << " from " << icpOutgoingConn->local << ": " << xstrerror());
+    if (comm_udp_sendto(icpOutgoingConn->fd, S, sndbuf, strlen(sndbuf) + 1) < 0) {
+        int xerrno = errno;
+        debugs(27, DBG_IMPORTANT, "ERROR: Failed to announce to " << S << " from " << icpOutgoingConn->local << ": " << xstrerr(xerrno));
+    }
 }
 
@@ -368,7 +368,8 @@ snmpHandleUdp(int sock, void *)
         xfree(snmp_rq->outbuf);
         xfree(snmp_rq);
     } else {
-        debugs(49, DBG_IMPORTANT, "snmpHandleUdp: FD " << sock << " recvfrom: " << xstrerror());
+        int xerrno = errno;
+        debugs(49, DBG_IMPORTANT, "snmpHandleUdp: FD " << sock << " recvfrom: " << xstrerr(xerrno));
     }
 }
 
@@ -525,10 +525,11 @@ storeClientReadBody(void *data, const char *buf, ssize_t len, StoreIOState::Poin
 bool
 store_client::unpackHeader(char const *buf, ssize_t len)
 {
+    int xerrno = errno; // FIXME: where does errno come from?
     debugs(90, 3, "store_client::unpackHeader: len " << len << "");
 
     if (len < 0) {
-        debugs(90, 3, "WARNING: unpack error: " << xstrerror());
+        debugs(90, 3, "WARNING: unpack error: " << xstrerr(xerrno));
         return false;
     }
 
@@ -389,9 +389,11 @@ sigusr2_handle(int sig)
     }
 
 #if !HAVE_SIGACTION
-    if (signal(sig, sigusr2_handle) == SIG_ERR) /* reinstall */
-        debugs(50, DBG_CRITICAL, "signal: sig=" << sig << " func=sigusr2_handle: " << xstrerror());
-
+    /* reinstall */
+    if (signal(sig, sigusr2_handle) == SIG_ERR) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "signal: sig=" << sig << " func=sigusr2_handle: " << xstrerr(xerrno));
+    }
 #endif
 }
 
@@ -450,7 +452,8 @@ getMyHostname(void)
 
     // still no host. fallback to gethostname()
     if (gethostname(host, SQUIDHOSTNAMELEN) < 0) {
-        debugs(50, DBG_IMPORTANT, "WARNING: gethostname failed: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "WARNING: gethostname failed: " << xstrerr(xerrno));
     } else {
         /* Verify that the hostname given resolves properly */
         struct addrinfo hints;
@@ -469,10 +472,11 @@ getMyHostname(void)
 
             return host;
         }
+        int xerrno = errno;
 
         if (AI)
             freeaddrinfo(AI);
-        debugs(50, DBG_IMPORTANT, "WARNING: '" << host << "' rDNS test failed: " << xstrerror());
+        debugs(50, DBG_IMPORTANT, "WARNING: '" << host << "' rDNS test failed: " << xstrerr(xerrno));
     }
 
     /* throw a configuration error when the Host/IP given has bad DNS/rDNS. */
@@ -500,16 +504,14 @@ leave_suid(void)
     debugs(21, 3, "leave_suid: PID " << getpid() << " called");
 
     if (Config.effectiveGroup) {
-
 #if HAVE_SETGROUPS
-
         setgroups(1, &Config2.effectiveGroupID);
-
 #endif
 
-        if (setgid(Config2.effectiveGroupID) < 0)
-            debugs(50, DBG_CRITICAL, "ALERT: setgid: " << xstrerror());
-
+        if (setgid(Config2.effectiveGroupID) < 0) {
+            int xerrno = errno;
+            debugs(50, DBG_CRITICAL, "ALERT: setgid: " << xstrerr(xerrno));
+        }
     }
 
     if (geteuid() != 0)
@@ -523,8 +525,10 @@ leave_suid(void)
 
     if (!Config.effectiveGroup) {
 
-        if (setgid(Config2.effectiveGroupID) < 0)
-            debugs(50, DBG_CRITICAL, "ALERT: setgid: " << xstrerror());
+        if (setgid(Config2.effectiveGroupID) < 0) {
+            int xerrno = errno;
+            debugs(50, DBG_CRITICAL, "ALERT: setgid: " << xstrerr(xerrno));
+        }
 
         if (initgroups(Config.effectiveUser, Config2.effectiveGroupID) < 0) {
             debugs(50, DBG_CRITICAL, "ALERT: initgroups: unable to set groups for User " <<
@@ -557,9 +561,10 @@ leave_suid(void)
 
 #if HAVE_PRCTL && defined(PR_SET_DUMPABLE)
     /* Set Linux DUMPABLE flag */
-    if (Config.coredump_dir && prctl(PR_SET_DUMPABLE, 1) != 0)
-        debugs(50, 2, "ALERT: prctl: " << xstrerror());
-
+    if (Config.coredump_dir && prctl(PR_SET_DUMPABLE, 1) != 0) {
+        int xerrno = errno;
+        debugs(50, 2, "ALERT: prctl: " << xstrerr(xerrno));
+    }
 #endif
 }
 
@@ -580,9 +585,10 @@ enter_suid(void)
 #if HAVE_PRCTL && defined(PR_SET_DUMPABLE)
     /* Set Linux DUMPABLE flag */
 
-    if (Config.coredump_dir && prctl(PR_SET_DUMPABLE, 1) != 0)
-        debugs(50, 2, "ALERT: prctl: " << xstrerror());
-
+    if (Config.coredump_dir && prctl(PR_SET_DUMPABLE, 1) != 0) {
+        int xerrno = errno;
+        debugs(50, 2, "ALERT: prctl: " << xstrerr(xerrno));
+    }
 #endif
 }
 
@@ -597,19 +603,24 @@ no_suid(void)
     uid = geteuid();
     debugs(21, 3, "no_suid: PID " << getpid() << " giving up root priveleges forever");
 
-    if (setuid(0) < 0)
-        debugs(50, DBG_IMPORTANT, "WARNING: no_suid: setuid(0): " << xstrerror());
+    if (setuid(0) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "WARNING: no_suid: setuid(0): " << xstrerr(xerrno));
+    }
 
-    if (setuid(uid) < 0)
-        debugs(50, DBG_IMPORTANT, "ERROR: no_suid: setuid(" << uid << "): " << xstrerror());
+    if (setuid(uid) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_IMPORTANT, "ERROR: no_suid: setuid(" << uid << "): " << xstrerr(xerrno));
+    }
 
     restoreCapabilities(false);
 
 #if HAVE_PRCTL && defined(PR_SET_DUMPABLE)
     /* Set Linux DUMPABLE flag */
-    if (Config.coredump_dir && prctl(PR_SET_DUMPABLE, 1) != 0)
-        debugs(50, 2, "ALERT: prctl: " << xstrerror());
-
+    if (Config.coredump_dir && prctl(PR_SET_DUMPABLE, 1) != 0) {
+        int xerrno = errno;
+        debugs(50, 2, "ALERT: prctl: " << xstrerr(xerrno));
+    }
 #endif
 }
 
@@ -718,14 +729,15 @@ writePidFile(void)
     old_umask = umask(022);
 
     fd = open(f, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, 0644);
+    int xerrno = errno;
 
     umask(old_umask);
 
     leave_suid();
 
     if (fd < 0) {
-        debugs(50, DBG_CRITICAL, "" << f << ": " << xstrerror());
-        debug_trap("Could not write pid file");
+        debugs(50, DBG_CRITICAL, "" << f << ": " << xstrerr(xerrno));
+        debug_trap("Could not open PID file for write");
         return;
     }
 
@@ -755,7 +767,7 @@ readPidFile(void)
     int i;
 
     if (f == NULL || !strcmp(Config.pidFilename, "none")) {
-        fprintf(stderr, APP_SHORTNAME ": ERROR: No pid file name defined\n");
+        fprintf(stderr, APP_SHORTNAME ": ERROR: No PID file name defined\n");
         exit(1);
     }
 
@@ -766,19 +778,18 @@ readPidFile(void)
         f = chroot_f;
     }
 
-    pid_fp = fopen(f, "r");
-
-    if (pid_fp != NULL) {
+    if ((pid_fp = fopen(f, "r"))) {
         pid = 0;
 
         if (fscanf(pid_fp, "%d", &i) == 1)
             pid = (pid_t) i;
 
         fclose(pid_fp);
     } else {
-        if (errno != ENOENT) {
-            fprintf(stderr, APP_SHORTNAME ": ERROR: Could not read pid file\n");
-            fprintf(stderr, "\t%s: %s\n", f, xstrerror());
+        int xerrno = errno;
+        if (xerrno != ENOENT) {
+            fprintf(stderr, APP_SHORTNAME ": ERROR: Could not open PID file for read\n");
+            fprintf(stderr, "\t%s: %s\n", f, xstrerr(xerrno));
             exit(1);
         }
     }
@@ -810,7 +821,8 @@ setMaxFD(void)
 #endif
 
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
-        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_NOFILE: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_NOFILE: " << xstrerr(xerrno));
     } else if (Config.max_filedescriptors > 0) {
 #if USE_SELECT || USE_SELECT_WIN32
         /* select() breaks if this gets set too big */
@@ -823,16 +835,19 @@ setMaxFD(void)
         if (rl.rlim_cur > rl.rlim_max)
             rl.rlim_max = rl.rlim_cur;
         if (setrlimit(RLIMIT_NOFILE, &rl)) {
-            debugs(50, DBG_CRITICAL, "ERROR: setrlimit: RLIMIT_NOFILE: " << xstrerror());
+            int xerrno = errno;
+            debugs(50, DBG_CRITICAL, "ERROR: setrlimit: RLIMIT_NOFILE: " << xstrerr(xerrno));
             getrlimit(RLIMIT_NOFILE, &rl);
             rl.rlim_cur = rl.rlim_max;
             if (setrlimit(RLIMIT_NOFILE, &rl)) {
-                debugs(50, DBG_CRITICAL, "ERROR: setrlimit: RLIMIT_NOFILE: " << xstrerror());
+                xerrno = errno;
+                debugs(50, DBG_CRITICAL, "ERROR: setrlimit: RLIMIT_NOFILE: " << xstrerr(xerrno));
             }
         }
     }
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
-        debugs(50, DBG_CRITICAL, "ERROR: getrlimit: RLIMIT_NOFILE: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "ERROR: getrlimit: RLIMIT_NOFILE: " << xstrerr(xerrno));
     } else {
         Squid_MaxFD = rl.rlim_cur;
     }
@@ -856,24 +871,28 @@ setSystemLimits(void)
 #endif
 
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
-        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_NOFILE: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_NOFILE: " << xstrerr(xerrno));
     } else {
         rl.rlim_cur = Squid_MaxFD;
         if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
-            snprintf(tmp_error_buf, ERROR_BUF_SZ, "setrlimit: RLIMIT_NOFILE: %s", xstrerror());
+            int xerrno = errno;
+            snprintf(tmp_error_buf, ERROR_BUF_SZ, "setrlimit: RLIMIT_NOFILE: %s", xstrerr(xerrno));
             fatal_dump(tmp_error_buf);
         }
     }
 #endif /* HAVE_SETRLIMIT */
 
 #if HAVE_SETRLIMIT && defined(RLIMIT_DATA) && !_SQUID_CYGWIN_
     if (getrlimit(RLIMIT_DATA, &rl) < 0) {
-        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_DATA: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_DATA: " << xstrerr(xerrno));
     } else if (rl.rlim_max > rl.rlim_cur) {
         rl.rlim_cur = rl.rlim_max;  /* set it to the max */
 
         if (setrlimit(RLIMIT_DATA, &rl) < 0) {
-            snprintf(tmp_error_buf, ERROR_BUF_SZ, "setrlimit: RLIMIT_DATA: %s", xstrerror());
+            int xerrno = errno;
+            snprintf(tmp_error_buf, ERROR_BUF_SZ, "setrlimit: RLIMIT_DATA: %s", xstrerr(xerrno));
             fatal_dump(tmp_error_buf);
         }
     }
@@ -884,12 +903,14 @@ setSystemLimits(void)
 
 #if HAVE_SETRLIMIT && defined(RLIMIT_VMEM) && !_SQUID_CYGWIN_
     if (getrlimit(RLIMIT_VMEM, &rl) < 0) {
-        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_VMEM: " << xstrerror());
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_VMEM: " << xstrerr(xerrno));
     } else if (rl.rlim_max > rl.rlim_cur) {
         rl.rlim_cur = rl.rlim_max;  /* set it to the max */
 
         if (setrlimit(RLIMIT_VMEM, &rl) < 0) {
-            snprintf(tmp_error_buf, ERROR_BUF_SZ, "setrlimit: RLIMIT_VMEM: %s", xstrerror());
+            xerrno = errno;
+            snprintf(tmp_error_buf, ERROR_BUF_SZ, "setrlimit: RLIMIT_VMEM: %s", xstrerr(xerrno));
             fatal_dump(tmp_error_buf);
         }
     }
@@ -906,9 +927,10 @@ squid_signal(int sig, SIGHDLR * func, int flags)
     sa.sa_flags = flags;
     sigemptyset(&sa.sa_mask);
 
-    if (sigaction(sig, &sa, NULL) < 0)
-        debugs(50, DBG_CRITICAL, "sigaction: sig=" << sig << " func=" << func << ": " << xstrerror());
-
+    if (sigaction(sig, &sa, NULL) < 0) {
+        int xerrno = errno;
+        debugs(50, DBG_CRITICAL, "sigaction: sig=" << sig << " func=" << func << ": " << xstrerr(xerrno));
+    }
 #else
 #if _SQUID_WINDOWS_
     /*
@@ -974,22 +996,22 @@ debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm)
 void
 parseEtcHosts(void)
 {
-    FILE *fp;
     char buf[1024];
     char buf2[512];
     char *nt = buf;
     char *lt = buf;
 
-    if (NULL == Config.etcHostsPath)
+    if (!Config.etcHostsPath)
         return;
 
     if (0 == strcmp(Config.etcHostsPath, "none"))
         return;
 
-    fp = fopen(Config.etcHostsPath, "r");
+    FILE *fp = fopen(Config.etcHostsPath, "r");
 
-    if (fp == NULL) {
-        debugs(1, DBG_IMPORTANT, "parseEtcHosts: " << Config.etcHostsPath << ": " << xstrerror());
+    if (!fp) {
+        int xerrno = errno;
+        debugs(1, DBG_IMPORTANT, "parseEtcHosts: " << Config.etcHostsPath << ": " << xstrerr(xerrno));
         return;
     }
 
@@ -526,10 +526,7 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
 void
 TunnelStateData::Connection::error(int const xerrno)
 {
-    /* XXX fixme xstrerror and xerrno... */
-    errno = xerrno;
-
-    debugs(50, debugLevelForError(xerrno), HERE << conn << ": read/write failure: " << xstrerror());
+    debugs(50, debugLevelForError(xerrno), HERE << conn << ": read/write failure: " << xstrerr(xerrno));
 
     if (!ignoreErrno(xerrno))
         conn->close();
@@ -107,7 +107,8 @@ unlinkdUnlink(const char *path)
     bytes_written = write(unlinkd_wfd, buf, l);
 
     if (bytes_written < 0) {
-        debugs(2, DBG_IMPORTANT, "unlinkdUnlink: write FD " << unlinkd_wfd << " failed: " << xstrerror());
+        int xerrno = errno;
+        debugs(2, DBG_IMPORTANT, "unlinkdUnlink: write FD " << unlinkd_wfd << " failed: " << xstrerr(xerrno));
         safeunlink(path, 0);
         return;
     } else if (bytes_written != l) {
@@ -277,12 +277,12 @@ wccpHereIam(void *)
 
     wccp_here_i_am.id = last_id;
     double interval = 10.0; // TODO: make this configurable, possibly negotiate with the router.
-    errno = 0;
     ssize_t sent = comm_udp_send(theWccpConnection, &wccp_here_i_am, sizeof(wccp_here_i_am), 0);
 
     // if we failed to send the whole lot, try again at a shorter interval (20%)
     if (sent != sizeof(wccp_here_i_am)) {
-        debugs(80, 2, "ERROR: failed to send WCCP HERE_I_AM packet: " << xstrerror());
+        int xerrno = errno;
+        debugs(80, 2, "ERROR: failed to send WCCP HERE_I_AM packet: " << xstrerr(xerrno));
         interval = 2.0;
     }
 
@@ -979,8 +979,10 @@ wccp2ConnectionOpen(void)
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
     {
         int i = IP_PMTUDISC_DONT;
-        if (setsockopt(theWccp2Connection, SOL_IP, IP_MTU_DISCOVER, &i, sizeof i) < 0)
-            debugs(80, 2, "WARNING: Path MTU discovery could not be disabled on FD " << theWccp2Connection << ": " << xstrerror());
+        if (setsockopt(theWccp2Connection, SOL_IP, IP_MTU_DISCOVER, &i, sizeof i) < 0) {
+            int xerrno = errno;
+            debugs(80, 2, "WARNING: Path MTU discovery could not be disabled on FD " << theWccp2Connection << ": " << xstrerr(xerrno));
+        }
     }
 
 #endif
@@ -1584,9 +1586,10 @@ wccp2HereIam(void *)
                                 &service_list_ptr->wccp_packet,
                                 service_list_ptr->wccp_packet_size);
             } else {
-                errno = 0;
-                if (send(theWccp2Connection, &service_list_ptr->wccp_packet, service_list_ptr->wccp_packet_size, 0) < static_cast<int>(service_list_ptr->wccp_packet_size))
-                    debugs(80, 2, "ERROR: failed to send WCCPv2 HERE_I_AM packet to " << router << " : " << xstrerror());
+                if (send(theWccp2Connection, &service_list_ptr->wccp_packet, service_list_ptr->wccp_packet_size, 0) < static_cast<int>(service_list_ptr->wccp_packet_size)) {
+                    int xerrno = errno;
+                    debugs(80, 2, "ERROR: failed to send WCCPv2 HERE_I_AM packet to " << router << " : " << xstrerr(xerrno));
+                }
             }
         }
 
@@ -1968,9 +1971,10 @@ wccp2AssignBuckets(void *)
                                     &wccp_packet,
                                     offset);
                 } else {
-                    errno = 0;
-                    if (send(theWccp2Connection, &wccp_packet, offset, 0) < static_cast<int>(offset))
-                        debugs(80, 2, "ERROR: failed to send WCCPv2 HERE_I_AM packet to " << tmp_rtr << " : " << xstrerror());
+                    if (send(theWccp2Connection, &wccp_packet, offset, 0) < static_cast<int>(offset)) {
+                        int xerrno = errno;
+                        debugs(80, 2, "ERROR: failed to send WCCPv2 HERE_I_AM packet to " << tmp_rtr << " : " << xstrerr(xerrno));
+                    }
                 }
             }
             safe_free(weight);
@@ -121,9 +121,9 @@ WhoisState::readReply(const Comm::ConnectionPointer &conn, char *aBuffer, size_t
     debugs(75, 5, "{" << aBuffer << "}");
 
     if (flag != Comm::OK) {
-        debugs(50, 2, HERE  << conn << ": read failure: " << xstrerror() << ".");
+        debugs(50, 2, conn << ": read failure: " << xstrerr(xerrno));
 
-        if (ignoreErrno(errno)) {
+        if (ignoreErrno(xerrno)) {
             AsyncCall::Pointer call = commCbCall(5,4, "whoisReadReply",
                                                  CommIoCbPtrFun(whoisReadReply, this));
             comm_read(conn, aBuffer, BUFSIZ, call);
@@ -820,16 +820,16 @@ process_request(cachemgr_request * req)
 #else
     if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
 #endif
-        snprintf(buf, sizeof(buf), "socket: %s\n", xstrerror());
+        int xerrno = errno;
+        snprintf(buf, sizeof(buf), "socket: %s\n", xstrerr(xerrno));
         error_html(buf);
         Ip::Address::FreeAddr(AI);
         return 1;
     }
 
     if (connect(s, AI->ai_addr, AI->ai_addrlen) < 0) {
-        snprintf(buf, sizeof(buf), "connect %s: %s\n",
-                 S.toUrl(ipbuf,MAX_IPSTRLEN),
-                 xstrerror());
+        int xerrno = errno;
+        snprintf(buf, sizeof(buf), "connect %s: %s\n", S.toUrl(ipbuf,MAX_IPSTRLEN), xstrerr(xerrno));
         error_html(buf);
         Ip::Address::FreeAddr(AI);
         close(s);
@@ -348,7 +348,8 @@ Transport::InitTls()
     debugVerbose(3, "Initializing TLS library...");
     // NP: gnutls init is re-entrant and lock-counted with deinit but not thread safe.
     if (gnutls_global_init() != GNUTLS_E_SUCCESS) {
-        std::cerr << "FATAL ERROR: TLS Initialize failed: " << xstrerror() << std::endl;
+        int xerrno = errno;
+        std::cerr << "FATAL ERROR: TLS Initialize failed: " << xstrerr(xerrno) << std::endl;
         exit(1);
     }
 
@@ -347,15 +347,17 @@ main(int argc, char *argv[])
         set_our_signal();
 
         if (put_fd < 0) {
-            std::cerr << "ERROR: can't open file (" << xstrerror() << ")" << std::endl;
+            int xerrno = errno;
+            std::cerr << "ERROR: can't open file (" << xstrerr(xerrno) << ")" << std::endl;
             exit(-1);
         }
 #if _SQUID_WINDOWS_
         setmode(put_fd, O_BINARY);
 #endif
 
         if (fstat(put_fd, &sb) < 0) {
-            std::cerr << "ERROR: can't identify length of file (" << xstrerror() << ")" << std::endl;
+            int xerrno = errno;
+            std::cerr << "ERROR: can't identify length of file (" << xstrerr(xerrno) << ")" << std::endl;
         }
     }
 
@@ -544,8 +546,10 @@ main(int argc, char *argv[])
         while ((len = Transport::Read(buf, sizeof(buf))) > 0) {
             fsize += len;
 
-            if (to_stdout && fwrite(buf, len, 1, stdout) != 1)
-                std::cerr << "ERROR: writing to stdout: " << xstrerror() << std::endl;
+            if (to_stdout && fwrite(buf, len, 1, stdout) != 1) {
+                int xerrno = errno;
+                std::cerr << "ERROR: writing to stdout: " << xstrerr(xerrno) << std::endl;
+            }
         }
 
 #if USE_GNUTLS