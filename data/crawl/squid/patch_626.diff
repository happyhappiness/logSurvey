@@ -1,3 +1,28 @@
+Changes to squid-3.2.0.11 (28 Aug 2011):
+
+	- Bug 3243: CVE-2009-0801 Bypass of browser same-origin access control
+		- Host: authority validation of intercepted destination IP
+		- Host: authority validation of request URL
+		- Host: authority validation of CONNECT tunnel destination
+		- Preserve client destination IP in intercepted communication
+	- Regression Bug 3316: Failed to connect to nameserver using TCP
+	- Regression Bug 3311: segmentation fault in getMyPort() with only intercept port set
+	- Regression Bug 3310: %<pt translates as %<p
+	- Regression Bug 3301: ERR_DNS_FAIL never shown (partial)
+	- Regression Bug 3288: %<la and %<lp not displaying
+	- Bug 3289: cache manager parameters not parsed without password
+	- Bug 2279: Log Format options to log server source IP and port
+	- Bug 3211: ssl_crtd start even if no ssl-bump port is configured
+	- Bug 3138: squidclient mgr:objects/mgr:vm_objects never ends
+	- Bug 3118: ecap_enable on forces icap_enable on
+	- Bug 3107: ncsa_auth DES silently truncates passwords to 8 bytes
+	- Default to vhost for accelerator mode (reverse proxy)
+	- Display HTTP protocol syntax at section 11 level 2
+	- Support for using custom keys in CARP parents
+	- Optimize regular expression ACLs
+	- ... and a lot of code portability fixes
+	- ... and all bugs and polish changes from 3.1.15
+
 Changes to squid-3.2.0.10 (24 Jul 2011):
 
 	- Port from 2.7: act-as-origin for reverse proxy ports
@@ -221,6 +246,29 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.15 (28 Aug 2011):
+
+	- Regression fix: vhost and defaultsite causing vport to be ignored
+	- Regression Bug 3295: broken escaping in rfc1738_do_escape
+	- Bug #3232: fails to compile with OpenSSL v1.0.0
+	- Bug #3222: cache_peer name is not logging on CONNECT
+	- Bug #3131: fd_table[fd].closing() assert from ConnStateData::noteMoreBodySpaceAvailable()
+	- Bug #3217: "!fd_table[fd].closing()" from ServerStateData::noteMoreBodySpaceAvailable
+	- Bug #3213: https sites (CONNECT) not open when using NTLM
+	- Bug #3114: Memory leak in SSL certificate verify code
+	- Bug #3107: ncsa_auth DES silently truncates passwords to 8 bytes
+	- Bug #2662: cf_gen failure when cross compiling
+	- Bug #2655: passing wrong the username to the url_rewrite_program
+	- Bug #2495: ignore whitespace prefix on config lines
+	- Bug #2051: 'default' cache_peer option does not match documentation
+	- Bug #1842: Optimize order of tests in peerWouldBePinged() and peerHTTPOkay()
+	- Bug #1791: timestampsSet does not validate Date: if server sends very old date
+	- Correct parsing of large Gopher indexes
+	- Enable negative cacheing on unknown or -1 expiry timestamp
+	- Remove hierarchy_stoplist default value
+	- Migrate cf_gen tool from C-style to C++
+	- ... and several documentation and compiler warning fixes
+
 Changes to squid-3.1.14 (04 Jul 2011):
 
 	- Regression Bug 3261: Could not create a DNS socket and exit
@@ -793,6 +841,21 @@ Changes to squid-3.1.0.1 (27 Oct 2008):
 	- Bug #2223: Follow XFF extensions added
 	- ... and many code and documentation cleanups
 
+Changes to squid-3.0.STABLE26 (28 Aug 2011):
+
+	- Regression: header_replace for reply headers
+	- Bug 3183: Invalid URL accepted with url host part of only '@'.
+	- Bug 3107: ncsa_auth DES silently truncates passwords to 8 bytes
+	- Bug 3056: comm.cc "!fd_table[fd].closing()" assertion from helperServerFree
+	- Bug 2991: Wrong parameters to fcntl() in commSetCloseOnExec()
+	- Bug 2933: Verification of the max. port number for WCCP2 dynamic service
+	- Bug 2922: Fix assertion failed: HttpHeader.cc: "Headers[id].stat.aliveCount"
+	- Regression Bug 2899: Restore lost rfc1738_unescape() data type
+	- Regression Bug 2879: headers end finding
+	- Bug 2876: FD_SETSIZE override not working on all linux distributions
+	- Check for NULL and empty strings before calling str*cmp().
+	- Correct parsing of large Gopher indexes
+
 Changes to squid-3.0.STABLE25 (14 Mar 2010):
 
 	- Bug 2845: Rework the http digest auth parser
@@ -156,7 +156,7 @@ int flags;
     const struct afd *afd;
     struct servent *sp;
     struct hostent *hp;
-    u_short port;
+    unsigned short port;
     int family, i;
     const char *addr;
     uint32_t v4a;
@@ -161,7 +161,6 @@ typedef unsigned long ino_t;
 #define SIGUSR1 30	/* user defined signal 1 */
 #define SIGUSR2 31	/* user defined signal 2 */
 
-typedef unsigned short int u_short;
 #if !_SQUID_CYGWIN_
 typedef int uid_t;
 typedef int gid_t;
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.0.STABLE25 release notes</title>
+<title>Squid 3.0.STABLE26 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,13 +13,14 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.0.STABLE25.
+The Squid Team are pleased to announce the release of Squid-3.0.STABLE26.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.0/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
 A large number of the show-stopper bugs have been fixed along with general improvements to the ICAP support and additional Languages.
 
-We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d"> for how to submit a report with a stack trace.
+We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting"> for how to submit a 
+report with a stack trace.
 
 <sect>Known issues
 <p>
@@ -592,6 +593,8 @@ See the accf_http(9) man page.
 	<p>Common options <em>no-store</em>, replaces the older <em>read-only</em> option
 
 	<tag>auth_param</tag>
+	<p>NCSA authenticator updated in 3.0.STALE26 to alert if passwords with more
+	    than 8 characters are used with DES encryption method.
 	<p>Removed Basic auth option
 	<verb>
     blankpasswor, not yet ported to squid-3.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.14 release notes</title>
+<title>Squid 3.1.15 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.14
+The Squid Team are pleased to announce the release of Squid-3.1.15
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -31,7 +31,7 @@ Although this release is deemed good enough for use in many setups, please note
 
 <itemize>
 	<item>The lack of some features available in Squid-2.x series. See the regression sections below for full details.
-	<item>CVE-2009-0801 : NAT interception vulnerability to malicious clients.
+	<item>CVE-2009-0801 : NAT interception vulnerability to malicious clients. This is fixed in 3.2 series.
 </itemize>
 
 <p>Currently known issues which only depends on available developer time and may still be resolved in a future 3.1 release are:
@@ -1010,7 +1010,7 @@ NOCOMMENT_START
 	<tag>auth_param ntlm, basic, digest</tag>
 	<p>BASIC, DIGEST:  New parameter option <em>utf8 on|off</em> to permit helpers to selectively process UTF-8 characters even though
 	   HTTP accepts only ISO-8859-1.</p>
-	<p>NCSA authenticator updated to reject passwords with more than 8 characters when using DES encryption method.
+	<p>NCSA authenticator updated in 3.1.15 to alert if passwords with more than 8 characters are used with DES encryption method.
 	<p>NTLM: The helper binary bundled with Squid under the name <em>ntlm_auth</em> has been renamed to accurately reflect
 	   its real behavior and to prevent confusion with the more useful Samba helper using the same name.
 	<p>Despite being used for NTLM, the helper does not in fact provide true NTLM function. What it does provide is
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.10 release notes</title>
+<title>Squid 3.2.0.11 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,13 +13,14 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.10 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.11 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
 While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
 
-We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d"> for how to submit a report with a stack trace.
+We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting"> for how to submit a 
+report with a stack trace.
 
 <sect1>Known issues
 <p>
@@ -34,6 +35,7 @@ The 3.2 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 
 <p>The most important of these new features are:
 <itemize>
+	<item>Fixed CVE-2009-0801 : NAT interception vulnerability to malicious clients.
 	<item>SMP scalability
 	<item>Helper Multiplexer and On-Demand
 	<item>Helper Name Changes
@@ -49,6 +51,20 @@ The 3.2 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 Most user-facing changes are reflected in squid.conf (see below).
 
 
+<sect1>Fixed CVE-2009-0801 : NAT interception vulnerability to malicious clients.
+<p>Details in Advisory <url url="http://www.squid-cache.org/Advisories/SQUID-2011_1.txt" name="SQUID-2011:1">
+
+<p>Squid locates the authority-URL details available in an HTTP request as
+  defined by RFC 2616 and validates that all found representations are
+  <em>textually</em> equivalent. In the case of intercepted traffic the
+  client destination IP is also compared to the Host: authority domains
+  DNS entries.
+
+<p>When the Host: authority contradicts another authority source Squid will log
+  "SECURITY ALERT: Host: header forgery detected" and respond with a 409 Conflict
+  error status page.
+
+
 <sect1>SMP scalability
 <p>The new "workers" squid.conf option can be used to launch multiple worker
    processes and utilize multiple CPU cores. The overall intent is to make
@@ -393,8 +409,11 @@ This section gives a thorough account of those changes in three categories:
 	  client-side delay pool for the request.
 
 	<tag>client_dst_passthru</tag>
-	<p>New setting to disable Host: header security on interception proxies.
+	<p>New setting to disable extra Host: header security on interception proxies.
 	   Impacts cache integrity/reliability and client browser security.
+	<p><em>IMPORTANT:</em> disabling this directive only allows Squid to change the
+	   destination IP to another source indicated by Host: domain DNS or
+	   cache_peer configuration. It <em>does not</em> affect Host: validation.
 
 	<tag>cpu_affinity_map</tag>
 	<p>New setting for SMP support to map Squid processes onto specific CPU cores.
@@ -143,6 +143,9 @@ main(int argc, char **argv)
         } else if (strlen(passwd) <= 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
             // Bug 3107: crypt() DES functionality silently truncates long passwords.
             SEND_OK("");
+        } else if (strlen(passwd) > 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
+            // Bug 3107: crypt() DES functionality silently truncates long passwords.
+            SEND_ERR("Password too long. Only 8 characters accepted.");
 #endif
         } else if (strcmp(u->passwd, (char *) crypt_md5(passwd, u->passwd)) == 0) {
             SEND_OK("");
@@ -165,7 +165,7 @@ md5_calc(uint8_t out[16], void *in, size_t len)
  *    Receive and verify the result.
  */
 static int
-result_recv(uint32_t host, u_short udp_port, char *buffer, int length)
+result_recv(uint32_t host, unsigned short udp_port, char *buffer, int length)
 {
     AUTH_HDR *auth;
     int totallen;
@@ -280,7 +280,7 @@ static int
 authenticate(int socket_fd, const char *username, const char *passwd)
 {
     AUTH_HDR *auth;
-    u_short total_length;
+    unsigned short total_length;
     u_char *ptr;
     int length;
     char passbuf[MAXPASS];
@@ -445,7 +445,7 @@ main(int argc, char **argv)
     struct sockaddr_in salocal;
     struct sockaddr_in saremote;
     struct servent *svp;
-    u_short svc_port;
+    unsigned short svc_port;
     char username[MAXPWNAM];
     char passwd[MAXPASS];
     char *ptr;
@@ -510,7 +510,7 @@ main(int argc, char **argv)
      */
     svp = getservbyname(svc_name, "udp");
     if (svp != NULL)
-        svc_port = ntohs((u_short) svp->s_port);
+        svc_port = ntohs((unsigned short) svp->s_port);
     else
         svc_port = atoi(svc_name);
     if (svc_port == 0)
@@ -37,7 +37,7 @@
 typedef struct pw_auth_hdr {
     u_char		code;
     u_char		id;
-    u_short		length;
+    uint16_t		length;
     u_char		vector[AUTH_VECTOR_LEN];
     u_char		data[2];
 } AUTH_HDR;
@@ -57,7 +57,7 @@
 /// \ingroup MemPoolsAPI
 #define MEM_MIN_FREE  32
 /// \ingroup MemPoolsAPI
-#define MEM_MAX_FREE  65535	/* u_short is max number of items per chunk */
+#define MEM_MAX_FREE  65535	/* unsigned short is max number of items per chunk */
 
 class MemImplementingAllocator;
 class MemPoolStats;
@@ -12,7 +12,7 @@
 /// \ingroup MemPoolsAPI
 #define MEM_MIN_FREE  32
 /// \ingroup MemPoolsAPI
-#define MEM_MAX_FREE  65535	/* u_short is max number of items per chunk */
+#define MEM_MAX_FREE  65535	/* unsigned short is max number of items per chunk */
 
 class MemChunk;
 
@@ -36,8 +36,8 @@ struct snmp_session {
     int retries;		/* Number of retries before timeout. */
     int timeout;		/* Number of uS until first timeout, then exponential backoff */
     char *peername;		/* Domain name or dotted IP address of default peer */
-    u_short remote_port;	/* UDP port number of peer. */
-    u_short local_port;		/* My UDP port number, 0 for default, picked randomly */
+    unsigned short remote_port;	/* UDP port number of peer. */
+    unsigned short local_port;		/* My UDP port number, 0 for default, picked randomly */
 };
 
 #define RECEIVED_MESSAGE   1
@@ -119,7 +119,7 @@ ntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr
     int32_t o;			/* offset */
     static char buf[NTLM_MAX_FIELD_LENGTH];
     lstring rv;
-    u_short *s, c;
+    unsigned short *s, c;
     char *d, *sc;
 
     lstring_zero(rv);
@@ -135,7 +135,7 @@ ntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr
     rv.str = (char *)packet + o;
     if ((flags & NTLM_NEGOTIATE_ASCII) == 0) {
         /* UNICODE string */
-        s = (u_short *) ((char *) packet + o);
+        s = (unsigned short *) ((char *) packet + o);
         rv.str = d = buf;
 
         for (l >>= 1; l; s++, l--) {
@@ -86,20 +86,20 @@ rfc1738_do_escape(const char *url, int flags)
 {
     static char *buf;
     static size_t bufsize = 0;
-    const char *p;
-    char *q;
+    const char *src;
+    char *dst;
     unsigned int i, do_escape;
 
     if (buf == NULL || strlen(url) * 3 > bufsize) {
         xfree(buf);
         bufsize = strlen(url) * 3 + 1;
         buf = (char*)xcalloc(bufsize, 1);
     }
-    for (p = url, q = buf; *p != '\0' && q < (buf + bufsize - 1); p++, q++) {
+    for (src = url, dst = buf; *src != '\0' && dst < (buf + bufsize - 1); src++, dst++) {
 
         /* a-z, A-Z and 0-9 are SAFE. */
-        if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9')) {
-            *q = *p;
+        if ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9')) {
+            *dst = *src;
             continue;
         }
 
@@ -108,50 +108,47 @@ rfc1738_do_escape(const char *url, int flags)
         /* RFC 1738 defines these chars as unsafe */
         if ((flags & RFC1738_ESCAPE_UNSAFE)) {
             for (i = 0; i < sizeof(rfc1738_unsafe_chars); i++) {
-                if (*p == rfc1738_unsafe_chars[i]) {
+                if (*src == rfc1738_unsafe_chars[i]) {
                     do_escape = 1;
                     break;
                 }
             }
             /* Handle % separately */
-            if (!(flags & RFC1738_ESCAPE_NOPERCENT) && *p == '%')
+            if (!(flags & RFC1738_ESCAPE_NOPERCENT) && *src == '%')
                 do_escape = 1;
             /* Handle space separately */
-            else if (!(flags & RFC1738_ESCAPE_NOSPACE) && *p <= ' ')
+            else if (!(flags & RFC1738_ESCAPE_NOSPACE) && *src <= ' ')
                 do_escape = 1;
         }
         /* RFC 1738 defines these chars as reserved */
         if ((flags & RFC1738_ESCAPE_RESERVED) && do_escape == 0) {
             for (i = 0; i < sizeof(rfc1738_reserved_chars); i++) {
-                if (*p == rfc1738_reserved_chars[i]) {
+                if (*src == rfc1738_reserved_chars[i]) {
                     do_escape = 1;
                     break;
                 }
             }
         }
         if ((flags & RFC1738_ESCAPE_CTRLS) && do_escape == 0) {
             /* RFC 1738 says any control chars (0x00-0x1F) are encoded */
-            if ((unsigned char) *p <= (unsigned char) 0x1F)
+            if ((unsigned char) *src <= (unsigned char) 0x1F)
                 do_escape = 1;
             /* RFC 1738 says 0x7f is encoded */
-            else if (*p == (char) 0x7F)
+            else if (*src == (char) 0x7F)
                 do_escape = 1;
             /* RFC 1738 says any non-US-ASCII are encoded */
-            else if (((unsigned char) *p >= (unsigned char) 0x80))
+            else if (((unsigned char) *src >= (unsigned char) 0x80))
                 do_escape = 1;
         }
         /* Do the triplet encoding, or just copy the char */
-        /* note: we do not need snprintf here as q is appropriately
-         * allocated - KA */
-
         if (do_escape == 1) {
-            (void) snprintf(q, (bufsize-(p-buf)), "%%%02X", (unsigned char) *p);
-            q += sizeof(char) * 2;
+            (void) snprintf(dst, (bufsize-(dst-buf)), "%%%02X", (unsigned char) *src);
+            dst += sizeof(char) * 2;
         } else {
-            *q = *p;
+            *dst = *src;
         }
     }
-    *q = '\0';
+    *dst = '\0';
     return (buf);
 }
 
@@ -49,7 +49,7 @@ void ClientDelayConfig::parsePoolCount()
         debugs(3, 0, "parse_client_delay_pool_count: multiple client_delay_pools lines, aborting all previous client_delay_pools config");
         clean();
     }
-    u_short pools_;
+    unsigned short pools_;
     ConfigParser::ParseUShort(&pools_);
     for (int i = 0; i < pools_; i++) {
         pools.push_back(ClientDelayPool());
@@ -58,7 +58,7 @@ void ClientDelayConfig::parsePoolCount()
 
 void ClientDelayConfig::parsePoolRates()
 {
-    u_short pool;
+    unsigned short pool;
     ConfigParser::ParseUShort(&pool);
 
     if (pool < 1 || pool > pools.size()) {
@@ -74,7 +74,7 @@ void ClientDelayConfig::parsePoolRates()
 
 void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
 {
-    u_short pool;
+    unsigned short pool;
 
     ConfigParser::ParseUShort(&pool);
 
@@ -63,7 +63,7 @@ class ConfigParser
 
 public:
     void destruct();
-    static void ParseUShort(u_short *var);
+    static void ParseUShort(unsigned short *var);
     static void ParseBool(bool *var);
     static void ParseString(char **var);
     static void ParseString(String *var);
@@ -52,15 +52,15 @@
 void
 DelayConfig::parsePoolCount()
 {
-    u_short pools_;
+    unsigned short pools_;
     ConfigParser::ParseUShort(&pools_);
     DelayPools::pools(pools_);
 }
 
 void
 DelayConfig::parsePoolClass()
 {
-    u_short pool;
+    unsigned short pool;
 
     ConfigParser::ParseUShort(&pool);
 
@@ -69,7 +69,7 @@ DelayConfig::parsePoolClass()
         return;
     }
 
-    u_short delay_class_;
+    unsigned short delay_class_;
     ConfigParser::ParseUShort(&delay_class_);
 
     if (delay_class_ < 1 || delay_class_ > 5) {
@@ -85,7 +85,7 @@ DelayConfig::parsePoolClass()
 void
 DelayConfig::parsePoolRates()
 {
-    u_short pool;
+    unsigned short pool;
     ConfigParser::ParseUShort(&pool);
 
     if (pool < 1 || pool > DelayPools::pools()) {
@@ -106,7 +106,7 @@ DelayConfig::parsePoolRates()
 void
 DelayConfig::parsePoolAccess(ConfigParser &parser)
 {
-    u_short pool;
+    unsigned short pool;
 
     ConfigParser::ParseUShort(&pool);
 
@@ -65,7 +65,7 @@ class DelayPools
     static void Init();
     static void Update(void *);
     static unsigned short pools();
-    static void pools (u_short pools);
+    static void pools(unsigned short pools);
     static void FreePools();
     static unsigned char *DelayClasses();
     static void registerForUpdates(Updateable *);
@@ -877,8 +877,7 @@ HttpHeader::addEntry(HttpHeaderEntry * e)
     assert_eid(e->id);
     assert(e->name.size());
 
-    debugs(55, 9, this << " adding entry: " << e->id << " at " <<
-           entries.count);
+    debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
 
     if (CBIT_TEST(mask, e->id))
         Headers[e->id].stat.repCount++;
@@ -900,8 +899,7 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
     assert(e);
     assert_eid(e->id);
 
-    debugs(55, 7, this << " adding entry: " << e->id << " at " <<
-           entries.count);
+    debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
 
     if (CBIT_TEST(mask, e->id))
         Headers[e->id].stat.repCount++;
@@ -148,7 +148,7 @@ class HttpRequest: public HttpMsg
 #if USE_AUTH
     AuthUserRequest::Pointer auth_user_request;
 #endif
-    u_short port;
+    unsigned short port;
 
     String urlpath;
 
@@ -69,7 +69,7 @@ void *LoadableModule::openModule(int mode)
 #	if XSTD_USE_LIBLTDL
     return lt_dlopen(theName.termedBuf());
 #	else
-    return dlopen(theName.c_str(),
+    return dlopen(theName.termedBuf(),
                   mode == lmNow ? RTLD_NOW : RTLD_LAZY);
 #	endif
 }
@@ -111,7 +111,7 @@ GetInteger(void)
     return i;
 }
 
-u_short
+unsigned short
 GetShort(void)
 {
     char *token = strtok(NULL, w_space);
@@ -54,7 +54,7 @@ extern int64_t GetInteger64(void);
  */
 extern int GetInteger(void);
 
-extern u_short GetShort(void);
+extern unsigned short GetShort(void);
 
 // on success, returns true and sets *p (if any) to the end of the integer
 extern bool StringToInt(const char *str, int &result, const char **p, int base);
@@ -156,15 +156,15 @@ class StoreEntry : public hash_link
     time_t expires;
     time_t lastmod;
     uint64_t swap_file_sz;
-    u_short refcount;
-    u_short flags;
+    uint16_t refcount;
+    uint16_t flags;
     /* END OF ON-DISK STORE_META_STD */
 
     sfileno swap_filen:25;
 
     sdirno swap_dirn:7;
 
-    u_short lock_count;		/* Assume < 65536! */
+    unsigned short lock_count;		/* Assume < 65536! */
 
     mem_status_t mem_status:3;
 
@@ -98,9 +98,9 @@ enum {
         time_t lastref;
         time_t expires;
         time_t lastmod;
-        size_t swap_file_sz;
-        u_short refcount;
-        u_short flags;
+        uint64_t swap_file_sz;
+        uint16_t refcount;
+        uint16_t flags;
      \endcode
      */
     STORE_META_STD,
@@ -146,14 +146,14 @@ class StoreSwapLogData
      * Since its a 16-bit quantity, it is susceptible to overflow
      * if a single object is accessed 65,536 times before being replaced.
      */
-    u_short refcount;
+    uint16_t refcount;
 
     /**
      * A copy of the StoreEntry flags field. Used as a sanity
      * check when rebuilding the cache at startup. Objects that
      * have the KEY_PRIVATE flag set are not added back to the cache.
      */
-    u_short flags;
+    uint16_t flags;
 
     /**
      * The 128-bit MD5 hash for this object.
@@ -147,7 +147,7 @@ static void configDoConfigure(void);
 static void parse_refreshpattern(refresh_t **);
 static uint64_t parseTimeUnits(const char *unit,  bool allowMsec);
 static void parseTimeLine(time_msec_t * tptr, const char *units, bool allowMsec);
-static void parse_u_short(u_short * var);
+static void parse_u_short(unsigned short * var);
 static void parse_string(char **);
 static void default_all(void);
 static void defaults_if_none(void);
@@ -2081,7 +2081,7 @@ isUnsignedNumeric(const char *str, size_t len)
  \param proto	'tcp' or 'udp' for protocol
  \returns       Port the named service is supposed to be listening on.
  */
-static u_short
+static unsigned short
 GetService(const char *proto)
 {
     struct servent *port = NULL;
@@ -2095,7 +2095,7 @@ GetService(const char *proto)
     if ( !isUnsignedNumeric(token, strlen(token)) )
         port = getservbyname(token, proto);
     if (port != NULL) {
-        return ntohs((u_short)port->s_port);
+        return ntohs((unsigned short)port->s_port);
     }
     /** Or a numeric translation of the config text. */
     return xatos(token);
@@ -2105,7 +2105,7 @@ GetService(const char *proto)
  \returns       Port the named TCP service is supposed to be listening on.
  \copydoc GetService(const char *proto)
  */
-inline u_short
+inline unsigned short
 GetTcpService(void)
 {
     return GetService("tcp");
@@ -2115,7 +2115,7 @@ GetTcpService(void)
  \returns       Port the named UDP service is supposed to be listening on.
  \copydoc GetService(const char *proto)
  */
-inline u_short
+inline unsigned short
 GetUdpService(void)
 {
     return GetService("udp");
@@ -3184,25 +3184,25 @@ free_b_int64_t(int64_t * var)
 #define free_kb_int64_t free_b_int64_t
 
 static void
-dump_u_short(StoreEntry * entry, const char *name, u_short var)
+dump_u_short(StoreEntry * entry, const char *name, unsigned short var)
 {
     storeAppendPrintf(entry, "%s %d\n", name, var);
 }
 
 static void
-free_u_short(u_short * u)
+free_u_short(unsigned short * u)
 {
     *u = 0;
 }
 
 static void
-parse_u_short(u_short * var)
+parse_u_short(unsigned short * var)
 {
     ConfigParser::ParseUShort(var);
 }
 
 void
-ConfigParser::ParseUShort(u_short *var)
+ConfigParser::ParseUShort(unsigned short *var)
 {
     *var = GetShort();
 }
@@ -1166,18 +1166,23 @@ TYPE: acl_access
 LOC: Config.accessList.miss
 DEFAULT: none
 DOC_START
-	Use to force your neighbors to use you as a sibling instead of
-	a parent.  For example:
+	Determins whether network access is permitted when satisfying a request.
+
+	For example;
+	    to force your neighbors to use you as a sibling instead of
+	    a parent.
 
 		acl localclients src 172.16.0.0/16
 		miss_access allow localclients
 		miss_access deny  !localclients
 
-	This means only your local clients are allowed to fetch
-	MISSES and all other clients can only fetch HITS.
+	This means only your local clients are allowed to fetch relayed/MISS
+	replies from the network and all other clients can only fetch cached
+	objects (HITs).
+
 
-	By default, allow all clients who passed the http_access rules
-	to fetch MISSES from us.
+	The default for this setting allows all clients who passed the
+	http_access rules to relay via this proxy.
 
 	This clause only supports fast acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
@@ -7137,6 +7142,7 @@ NAME: ignore_unknown_nameservers
 TYPE: onoff
 LOC: Config.onoff.ignore_unknown_nameservers
 DEFAULT: on
+IFDEF: !USE_DNSSERVERS
 DOC_START
 	By default Squid checks that DNS responses are received
 	from the same IP addresses they are sent to.  If they
@@ -7149,6 +7155,7 @@ NAME: dns_v4_fallback
 TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.dns_require_A
+IFDEF: !USE_DNSSERVERS
 DOC_START
 	Standard practice with DNS is to lookup either A or AAAA records
 	and use the results if it succeeds. Only looking up the other if
@@ -3422,7 +3422,7 @@ httpsAccept(int, const Comm::ConnectionPointer& details, comm_err_t flag, int xe
     if (!(ssl = httpsCreate(details, sslContext)))
         return;
 
-    debugs(33, 5, HERE << details << " accepted, starting SSL negotiation.");
+    debugs(33, 4, HERE << details << " accepted, starting SSL negotiation.");
     fd_note(details->fd, "client https connect");
 
     if (s->http.tcp_keepalive.enabled) {
@@ -362,7 +362,7 @@ comm_has_incomplete_write(int fd)
  */
 
 /* Return the local port associated with fd. */
-u_short
+unsigned short
 comm_local_port(int fd)
 {
     Ip::Address temp;
@@ -644,7 +644,7 @@ comm_apply_flags(int new_socket,
     if ((flags & COMM_REUSEADDR))
         commSetReuseAddr(new_socket);
 
-    if (addr.GetPort() > (u_short) 0) {
+    if (addr.GetPort() > (unsigned short) 0) {
 #if _SQUID_MSWIN_
         if (sock_type != SOCK_DGRAM)
 #endif
@@ -703,7 +703,7 @@ comm_import_opened(const Comm::ConnectionPointer &conn,
     if (!(conn->flags & COMM_NOCLOEXEC))
         fd_table[conn->fd].flags.close_on_exec = 1;
 
-    if (conn->local.GetPort() > (u_short) 0) {
+    if (conn->local.GetPort() > (unsigned short) 0) {
 #if _SQUID_MSWIN_
         if (AI->ai_socktype != SOCK_DGRAM)
 #endif
@@ -52,7 +52,7 @@ extern int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int f
 extern void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note);
 
 SQUIDCEXTERN int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *);
-SQUIDCEXTERN u_short comm_local_port(int fd);
+SQUIDCEXTERN unsigned short comm_local_port(int fd);
 
 SQUIDCEXTERN int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
 SQUIDCEXTERN void commCallCloseHandlers(int fd);
@@ -192,8 +192,8 @@
 #define SwapMetaType(x) (char)x[0]
 #define SwapMetaSize(x) &x[sizeof(char)]
 #define SwapMetaData(x) &x[STORE_META_TLD_START]
-#define STORE_HDR_METASIZE (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(uint64_t))
-#define STORE_HDR_METASIZE_OLD (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(size_t))
+#define STORE_HDR_METASIZE (4*sizeof(time_t)+2*sizeof(uint16_t)+sizeof(uint64_t))
+#define STORE_HDR_METASIZE_OLD (4*sizeof(time_t)+2*sizeof(uint16_t)+sizeof(size_t))
 
 #define COUNT_INTERVAL 60
 /*
@@ -669,7 +669,7 @@ DelayPools::pools()
 }
 
 void
-DelayPools::pools (u_short newPools)
+DelayPools::pools(unsigned short newPools)
 {
     if (pools()) {
         debugs(3, 0, "parse_delay_pool_count: multiple delay_pools lines, aborting all previous delay_pools config");
@@ -843,6 +843,10 @@ idnsInitVC(int ns)
 
     conn->remote = nameservers[ns].S;
 
+    if (conn->remote.IsIPv4()) {
+        conn->local.SetIPv4();
+    }
+
     AsyncCall::Pointer call = commCbCall(78,3, "idnsInitVCConnected", CommConnectCbPtrFun(idnsInitVCConnected, vc));
 
     Comm::ConnOpener *cs = new Comm::ConnOpener(conn, call, Config.Timeout.connect);
@@ -151,7 +151,7 @@ class ErrorState
     HttpRequest *request;
     char *url;
     int xerrno;
-    u_short port;
+    unsigned short port;
     String dnsError; ///< DNS lookup error message
     time_t ttl;
 
@@ -57,7 +57,7 @@ class fde
 
 public:
     unsigned int type;
-    u_short remote_port;
+    unsigned short remote_port;
 
     Ip::Address local_addr;
     tos_t tosToServer;          /**< The TOS value for packets going towards the server.
@@ -226,12 +226,7 @@ Format::Format::dump(StoreEntry * entry, const char *name)
                 if (arg)
                     storeAppendPrintf(entry, "{%s}", arg);
 
-                for (struct TokenTableEntry *te = TokenTable; te->config != NULL; te++) {
-                    if (te->token_type == type) {
-                        storeAppendPrintf(entry, "%s", te->config);
-                        break;
-                    }
-                }
+                storeAppendPrintf(entry, "%s", t->label);
 
                 if (t->space)
                     entry->append(" ", 1);
@@ -30,17 +30,37 @@ const char *Format::log_tags[] = {
     "LOG_TYPE_MAX"
 };
 
-struct Format::TokenTableEntry Format::TokenTable[] = {
+// Due to token overlaps between 1 and 2 letter tokens (Bug 3310)
+// We split the token table into sets determined by the token length
+namespace Format
+{
+
+/// 1-char tokens.
+static struct TokenTableEntry TokenTable1C[] = {
 
     {">a", LFT_CLIENT_IP_ADDRESS},
     {">p", LFT_CLIENT_PORT},
     {">A", LFT_CLIENT_FQDN},
-    {">eui", LFT_CLIENT_EUI},
 
     {"<a", LFT_SERVER_IP_ADDRESS},
     {"<p", LFT_SERVER_PORT},
     {"<A", LFT_SERVER_FQDN_OR_PEER_NAME},
 
+    {">h", LFT_REQUEST_HEADER},
+    {">h", LFT_REQUEST_ALL_HEADERS},
+    {"<h", LFT_REPLY_HEADER},
+    {"<h", LFT_REPLY_ALL_HEADERS},
+
+    {">v", LFT_REQUEST_VERSION_OLD_2X},
+
+    {"%", LFT_PERCENT},
+
+    {NULL, LFT_NONE}		/* this must be last */
+};
+
+/// 2-char tokens
+static struct TokenTableEntry TokenTable2C[] = {
+
     {">la", LFT_CLIENT_LOCAL_IP},
     {"la", LFT_CLIENT_LOCAL_IP_OLD_31},
     {">lp", LFT_CLIENT_LOCAL_PORT},
@@ -64,10 +84,6 @@ struct Format::TokenTableEntry Format::TokenTable[] = {
 
     {">ha", LFT_ADAPTED_REQUEST_HEADER},
     {">ha", LFT_ADAPTED_REQUEST_ALL_HEADERS},
-    {">h", LFT_REQUEST_HEADER},
-    {">h", LFT_REQUEST_ALL_HEADERS},
-    {"<h", LFT_REPLY_HEADER},
-    {"<h", LFT_REPLY_ALL_HEADERS},
 
     {"un", LFT_USER_NAME},
     {"ul", LFT_USER_LOGIN},
@@ -83,8 +99,6 @@ struct Format::TokenTableEntry Format::TokenTable[] = {
     {"<bs", LFT_HTTP_BODY_BYTES_READ},
 
     {"Ss", LFT_SQUID_STATUS},
-    { "err_code", LFT_SQUID_ERROR },
-    { "err_detail", LFT_SQUID_ERROR_DETAIL },
     {"Sh", LFT_SQUID_HIERARCHY},
 
     {"mt", LFT_MIME_TYPE},
@@ -99,7 +113,6 @@ struct Format::TokenTableEntry Format::TokenTable[] = {
     {"ru", LFT_REQUEST_URI},	/* doesn't include the query-string */
     {"rp", LFT_REQUEST_URLPATH_OLD_31},
     /* { "rq", LFT_REQUEST_QUERY }, * /     / * the query-string, INCLUDING the leading ? */
-    {">v", LFT_REQUEST_VERSION_OLD_2X},
     {"rv", LFT_REQUEST_VERSION},
 
     {"<rm", LFT_SERVER_REQ_METHOD},
@@ -108,17 +121,17 @@ struct Format::TokenTableEntry Format::TokenTable[] = {
     /*{"<rq", LFT_SERVER_REQ_QUERY},*/
     {"<rv", LFT_SERVER_REQ_VERSION},
 
-    { ">st", LFT_REQUEST_SIZE_TOTAL },
+    {">st", LFT_REQUEST_SIZE_TOTAL },
     /*{ ">sl", LFT_REQUEST_SIZE_LINE }, * / / * the request line "GET ... " */
-    { ">sh", LFT_REQUEST_SIZE_HEADERS },
+    {">sh", LFT_REQUEST_SIZE_HEADERS },
     /*{ ">sb", LFT_REQUEST_SIZE_BODY }, */
     /*{ ">sB", LFT_REQUEST_SIZE_BODY_NO_TE }, */
 
     {"<st", LFT_REPLY_SIZE_TOTAL},
     {"<sH", LFT_REPLY_HIGHOFFSET},
     {"<sS", LFT_REPLY_OBJECTSIZE},
     /*{ "<sl", LFT_REPLY_SIZE_LINE }, * /   / * the reply line (protocol, code, text) */
-    { "<sh", LFT_REPLY_SIZE_HEADERS },
+    {"<sh", LFT_REPLY_SIZE_HEADERS },
     /*{ "<sb", LFT_REPLY_SIZE_BODY }, */
     /*{ "<sB", LFT_REPLY_SIZE_BODY_NO_TE }, */
 
@@ -127,38 +140,71 @@ struct Format::TokenTableEntry Format::TokenTable[] = {
     {"ea", LFT_EXT_LOG},
     {"sn", LFT_SEQUENCE_NUMBER},
 
-    {"%", LFT_PERCENT},
+    {NULL, LFT_NONE}		/* this must be last */
+};
 
 #if USE_ADAPTATION
-    {"adapt::all_trs", LTF_ADAPTATION_ALL_XACT_TIMES},
-    {"adapt::sum_trs", LTF_ADAPTATION_SUM_XACT_TIMES},
-    {"adapt::<last_h", LFT_ADAPTATION_LAST_HEADER},
+/// Adaptation (adapt::) tokens
+static struct TokenTableEntry TokenTableAdapt[] = {
+    {"all_trs", LTF_ADAPTATION_ALL_XACT_TIMES},
+    {"sum_trs", LTF_ADAPTATION_SUM_XACT_TIMES},
+    {"<last_h", LFT_ADAPTATION_LAST_HEADER},
+    {NULL, LFT_NONE}		/* this must be last */
+};
 #endif
 
 #if ICAP_CLIENT
-    {"icap::tt", LFT_ICAP_TOTAL_TIME},
-    {"icap::<last_h", LFT_ADAPTATION_LAST_HEADER}, // deprecated
-
-    {"icap::<A",  LFT_ICAP_ADDR},
-    {"icap::<service_name",  LFT_ICAP_SERV_NAME},
-    {"icap::ru",  LFT_ICAP_REQUEST_URI},
-    {"icap::rm",  LFT_ICAP_REQUEST_METHOD},
-    {"icap::>st",  LFT_ICAP_BYTES_SENT},
-    {"icap::<st",  LFT_ICAP_BYTES_READ},
-    {"icap::<bs", LFT_ICAP_BODY_BYTES_READ},
-
-    {"icap::>h",  LFT_ICAP_REQ_HEADER},
-    {"icap::<h",  LFT_ICAP_REP_HEADER},
-
-    {"icap::tr",  LFT_ICAP_TR_RESPONSE_TIME},
-    {"icap::tio",  LFT_ICAP_IO_TIME},
-    {"icap::to",  LFT_ICAP_OUTCOME},
-    {"icap::Hs",  LFT_ICAP_STATUS_CODE},
+/// ICAP (icap::) tokens
+static struct TokenTableEntry TokenTableIcap[] = {
+    {"tt", LFT_ICAP_TOTAL_TIME},
+    {"<last_h", LFT_ADAPTATION_LAST_HEADER}, // deprecated
+
+    {"<A",  LFT_ICAP_ADDR},
+    {"<service_name",  LFT_ICAP_SERV_NAME},
+    {"ru",  LFT_ICAP_REQUEST_URI},
+    {"rm",  LFT_ICAP_REQUEST_METHOD},
+    {">st",  LFT_ICAP_BYTES_SENT},
+    {"<st",  LFT_ICAP_BYTES_READ},
+    {"<bs", LFT_ICAP_BODY_BYTES_READ},
+
+    {">h",  LFT_ICAP_REQ_HEADER},
+    {"<h",  LFT_ICAP_REP_HEADER},
+
+    {"tr",  LFT_ICAP_TR_RESPONSE_TIME},
+    {"tio",  LFT_ICAP_IO_TIME},
+    {"to",  LFT_ICAP_OUTCOME},
+    {"Hs",  LFT_ICAP_STATUS_CODE},
+
+    {NULL, LFT_NONE}		/* this must be last */
+};
 #endif
 
+/// Miscellaneous >2 byte tokens
+static struct TokenTableEntry TokenTableMisc[] = {
+    {">eui", LFT_CLIENT_EUI},
+    {"err_code", LFT_SQUID_ERROR },
+    {"err_detail", LFT_SQUID_ERROR_DETAIL },
     {NULL, LFT_NONE}		/* this must be last */
 };
 
+} // namespace Format
+
+/// Scans a token table to see if the next token exists there
+/// returns a pointer to next unparsed byte and updates type member if found
+char *
+Format::Token::scanForToken(const struct TokenTableEntry *table, char *cur)
+{
+    for (const struct TokenTableEntry *lte = table; lte->config != NULL; lte++) {
+        if (strncmp(lte->config, cur, strlen(lte->config)) == 0) {
+            type = lte->token_type;
+            label = lte->config;
+            debugs(46, 7, HERE << "Found token '" << label << "'");
+            return cur + strlen(lte->config);
+        }
+    }
+    return cur;
+}
+
 /* parses a single token. Returns the token length in characters,
  * and fills in the lt item with the token information.
  * def is for sure null-terminated
@@ -168,7 +214,6 @@ Format::Token::parse(char *def, Quoting *quoting)
 {
     char *cur = def;
 
-    struct TokenTableEntry *lte;
     int l;
 
     l = strcspn(cur, "%");
@@ -275,28 +320,52 @@ Format::Token::parse(char *def, Quoting *quoting)
             cur++;
     }
 
-    // For upward compatibility, assume "http::" prefix as default prefix
-    // for all log access formating codes, except those starting
-    // from "icap::", "adapt::" and "%"
-    if (strncmp(cur,"http::", 6) == 0 &&
-            strncmp(cur+6, "icap::", 6) != 0  &&
-            strncmp(cur+6, "adapt::", 12) != 0 && *(cur+6) != '%' ) {
-        cur += 6;
-    }
-
     type = LFT_NONE;
 
-    for (lte = TokenTable; lte->config != NULL; lte++) {
-        if (strncmp(lte->config, cur, strlen(lte->config)) == 0) {
-            type = lte->token_type;
-            cur += strlen(lte->config);
-            break;
+    // Scan each token namespace
+    if (strncmp(cur, "icap::", 6) == 0) {
+#if ICAP_CLIENT
+        cur += 6;
+        debugs(46, 5, HERE << "scan for icap:: token");
+        cur = scanForToken(TokenTableIcap, cur);
+#else
+        debugs(46, DBG_IMPORTANT, "ERROR: Format uses icap:: token. ICAP disabled!");
+#endif
+    } else if (strncmp(cur, "adapt::", 7) == 0) {
+#if USE_ADAPTATION
+        cur += 7;
+        debugs(46, 5, HERE << "scan for adapt:: token");
+        cur = scanForToken(TokenTableAdapt, cur);
+#else
+        debugs(46, DBG_IMPORTANT, "ERROR: Format uses adapt:: token. Adaptation disabled!");
+#endif
+    } else {
+        // For upward compatibility, assume "http::" prefix as default prefix
+        // for all log access formating codes, except those starting with a
+        // "%" or a known namespace. (ie "icap::", "adapt::")
+        if (strncmp(cur,"http::", 6) == 0 && *(cur+6) != '%' )
+            cur += 6;
+
+        // NP: scan the sets of tokens in decreasing size to guarantee no
+        //     mistakes made with overlapping names. (Bug 3310)
+
+        // Scan for various long tokens
+        debugs(46, 5, HERE << "scan for possible Misc token");
+        cur = scanForToken(TokenTableMisc, cur);
+        // scan for 2-char tokens
+        if (type == LFT_NONE) {
+            debugs(46, 5, HERE << "scan for possible 2C token");
+            cur = scanForToken(TokenTable2C, cur);
+        }
+        // finally scan for 1-char tokens.
+        if (type == LFT_NONE) {
+            debugs(46, 5, HERE << "scan for possible 1C token");
+            cur = scanForToken(TokenTable1C, cur);
         }
     }
 
     if (type == LFT_NONE) {
-        fatalf("Can't parse configuration token: '%s'\n",
-               def);
+        fatalf("Can't parse configuration token: '%s'\n", def);
     }
 
     if (*cur == ' ') {
@@ -467,6 +536,7 @@ Format::Token::parse(char *def, Quoting *quoting)
 
 Format::Token::~Token()
 {
+    label = NULL; // drop reference to global static.
     safe_free(data.string);
     while (next) {
         Token *tokens = next;
@@ -174,11 +174,18 @@ enum Quoting {
     LOG_QUOTE_RAW
 };
 
+struct TokenTableEntry {
+    const char *config;
+    ByteCode_t token_type;
+    int options;
+};
+
 // XXX: inherit from linked list
 class Token
 {
 public:
     Token() : type(LFT_NONE),
+            label(NULL),
             width(0),
             precision(0),
             quote(LOG_QUOTE_NONE),
@@ -197,6 +204,7 @@ class Token
     int parse(char *def, enum Quoting *quote);
 
     ByteCode_t type;
+    const char *label;
     union {
         char *string;
 
@@ -215,16 +223,12 @@ class Token
     unsigned int zero:1;
     int divisor;
     Token *next;	/* todo: move from linked list to array */
-};
 
-struct TokenTableEntry {
-    const char *config;
-    ByteCode_t token_type;
-    int options;
+private:
+    char *scanForToken(const struct TokenTableEntry *table, char *cur);
 };
 
 extern const char *log_tags[];
-extern struct TokenTableEntry TokenTable[];
 
 } // namespace Format
 
@@ -303,13 +303,13 @@ FwdState::startConnectionOrFail()
 
         connectStart();
     } else {
-        debugs(17, 3, HERE << entry->url());
-        ErrorState *anErr = NULL;
-        if (err) {
+        debugs(17, 3, HERE << "Connection failed: " << entry->url());
+        if (!err) {
+            ErrorState *anErr = NULL;
             anErr = errorCon(ERR_CANNOT_FORWARD, HTTP_INTERNAL_SERVER_ERROR, request);
             anErr->xerrno = errno;
+            fail(anErr);
         } // else use actual error from last connection attempt
-        fail(anErr);
         self = NULL;       // refcounted
     }
 }
@@ -63,8 +63,8 @@ class UFSSwapLogParser_v1_32bs:public UFSSwapLogParser
         time_t expires;
         time_t lastmod;
         uint32_t swap_file_sz;
-        u_short refcount;
-        u_short flags;
+        uint16_t refcount;
+        uint16_t flags;
         unsigned char key[SQUID_MD5_DIGEST_LENGTH];
     };
     UFSSwapLogParser_v1_32bs(FILE *fp):UFSSwapLogParser(fp) {
@@ -111,8 +111,8 @@ class UFSSwapLogParser_v1_32bst:public UFSSwapLogParser
         int32_t expires;
         int32_t lastmod;
         uint32_t swap_file_sz;
-        u_short refcount;
-        u_short flags;
+        uint16_t refcount;
+        uint16_t flags;
         unsigned char key[SQUID_MD5_DIGEST_LENGTH];
     };
     UFSSwapLogParser_v1_32bst(FILE *fp):UFSSwapLogParser(fp) {
@@ -157,8 +157,8 @@ class UFSSwapLogParser_v1_64bfn:public UFSSwapLogParser
         time_t expires;
         time_t lastmod;
         uint64_t swap_file_sz;
-        u_short refcount;
-        u_short flags;
+        uint16_t refcount;
+        uint16_t flags;
         unsigned char key[SQUID_MD5_DIGEST_LENGTH];
     };
     UFSSwapLogParser_v1_64bfn(FILE *fp):UFSSwapLogParser(fp) {
@@ -223,7 +223,7 @@ class FtpStateData : public ServerStateData
     struct DataChannel: public FtpChannel {
         MemBuf *readBuf;
         char *host;
-        u_short port;
+        unsigned short port;
         bool read_pending;
     } data;
 
@@ -2431,7 +2431,7 @@ ftpReadEPSV(FtpStateData* ftpState)
     buf = ftpState->ctrl.last_reply + strcspn(ftpState->ctrl.last_reply, "(");
 
     char h1, h2, h3, h4;
-    u_short port;
+    unsigned short port;
     int n = sscanf(buf, "(%c%c%c%hu%c)", &h1, &h2, &h3, &port, &h4);
 
     if (n < 4 || h1 != h2 || h1 != h3 || h1 != h4) {
@@ -2644,7 +2644,7 @@ ftpReadPasv(FtpStateData * ftpState)
     int h1, h2, h3, h4;
     int p1, p2;
     int n;
-    u_short port;
+    unsigned short port;
     Ip::Address ipa_remote;
     char *buf;
     LOCAL_ARRAY(char, ipaddr, 1024);
@@ -427,7 +427,6 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
         return;
     }
 
-    inbuf[len] = '\0';
     String outbuf;
 
     if (!gopherState->HTML_header_added) {
@@ -443,75 +442,48 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
         gopherState->HTML_pre = 1;
     }
 
-    while ((pos != NULL) && (pos < inbuf + len)) {
-
+    while (pos < inbuf + len) {
+        int llen;
+        int left = len - (pos - inbuf);
+        lpos = (char *)memchr(pos, '\n', left);
+        if (lpos) {
+            lpos++;             /* Next line is after \n */
+            llen = lpos - pos;
+        } else {
+            llen = left;
+        }
+        if (gopherState->len + llen >= TEMP_BUF_SIZE) {
+            debugs(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: " << entry->url()  );
+            llen = TEMP_BUF_SIZE - gopherState->len - 1;
+        }
+        if (!lpos) {
+            /* there is no complete line in inbuf */
+            /* copy it to temp buffer */
+            /* note: llen is adjusted above */
+            memcpy(gopherState->buf + gopherState->len, pos, llen);
+            gopherState->len += llen;
+            break;
+        }
+        if (!lpos) {
+            /* there is no complete line in inbuf */
+            /* copy it to temp buffer */
+            /* note: llen is adjusted above */
+            memcpy(gopherState->buf + gopherState->len, pos, llen);
+            gopherState->len += llen;
+            break;
+        }
         if (gopherState->len != 0) {
             /* there is something left from last tx. */
-            xstrncpy(line, gopherState->buf, gopherState->len + 1);
-
-            if (gopherState->len + len > TEMP_BUF_SIZE) {
-                debugs(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: " << entry->url()  );
-                len = TEMP_BUF_SIZE - gopherState->len;
-            }
-
-            lpos = (char *) memccpy(line + gopherState->len, inbuf, '\n', len);
-
-            if (lpos)
-                *lpos = '\0';
-            else {
-                /* there is no complete line in inbuf */
-                /* copy it to temp buffer */
-
-                if (gopherState->len + len > TEMP_BUF_SIZE) {
-                    debugs(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: " << entry->url()  );
-                    len = TEMP_BUF_SIZE - gopherState->len;
-                }
-
-                memcpy(gopherState->buf + gopherState->len, inbuf, len);
-                gopherState->len += len;
-                return;
-            }
-
-            /* skip one line */
-            pos = (char *) memchr(pos, '\n', len);
-
-            if (pos)
-                pos++;
-
-            /* we're done with the remain from last tx. */
+            memcpy(line, gopherState->buf, gopherState->len);
+            memcpy(line + gopherState->len, pos, llen);
+            llen += gopherState->len;
             gopherState->len = 0;
-
-            *(gopherState->buf) = '\0';
         } else {
-
-            lpos = (char *) memccpy(line, pos, '\n', len - (pos - inbuf));
-
-            if (lpos)
-                *lpos = '\0';
-            else {
-                /* there is no complete line in inbuf */
-                /* copy it to temp buffer */
-
-                if ((len - (pos - inbuf)) > TEMP_BUF_SIZE) {
-                    debugs(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: " << entry->url()  );
-                    len = TEMP_BUF_SIZE;
-                }
-
-                if (len > (pos - inbuf)) {
-                    memcpy(gopherState->buf, pos, len - (pos - inbuf));
-                    gopherState->len = len - (pos - inbuf);
-                }
-
-                break;
-            }
-
-            /* skip one line */
-            pos = (char *) memchr(pos, '\n', len);
-
-            if (pos)
-                pos++;
-
+            memcpy(line, pos, llen);
         }
+        line[llen + 1] = '\0';
+        /* move input to next line */
+        pos = lpos;
 
         /* at this point. We should have one line in buffer to process */
 
@@ -467,12 +467,12 @@ htcpBuildTstOpData(char *buf, size_t buflen, htcpStuff * stuff)
 static ssize_t
 htcpBuildClrOpData(char *buf, size_t buflen, htcpStuff * stuff)
 {
-    u_short reason;
+    unsigned short reason;
 
     switch (stuff->rr) {
     case RR_REQUEST:
         debugs(31, 3, "htcpBuildClrOpData: RR_REQUEST");
-        reason = htons((u_short)stuff->reason);
+        reason = htons((unsigned short)stuff->reason);
         memcpy(buf, &reason, 2);
         return htcpBuildSpecifier(buf + 2, buflen - 2, stuff) + 2;
     case RR_RESPONSE:
@@ -2214,12 +2214,12 @@ HttpStateData::finishingBrokenPost()
     }
 
     if (!Comm::IsConnOpen(serverConnection)) {
-        debugs(11,2, HERE << "ignoring broken POST for closed " << serverConnection);
+        debugs(11, 3, HERE << "ignoring broken POST for closed " << serverConnection);
         assert(closeHandler != NULL);
         return true; // prevent caller from proceeding as if nothing happened
     }
 
-    debugs(11, 2, "finishingBrokenPost: fixing broken POST");
+    debugs(11, 3, "finishingBrokenPost: fixing broken POST");
     typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
     requestSender = JobCallback(11,5,
                                 Dialer, this, HttpStateData::wroteLast);
@@ -117,7 +117,7 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     icmp->icmp_code = 0;
     icmp->icmp_cksum = 0;
     icmp->icmp_id = icmp_ident;
-    icmp->icmp_seq = (u_short) icmp_pkts_sent++;
+    icmp->icmp_seq = (unsigned short) icmp_pkts_sent++;
 
     // Construct ICMP packet data content
     echo = (icmpEchoData *) (icmp + 1);
@@ -135,13 +135,13 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
         icmp_pktsize += len;
     }
 
-    icmp->icmp_cksum = CheckSum((u_short *) icmp, icmp_pktsize);
+    icmp->icmp_cksum = CheckSum((unsigned short *) icmp, icmp_pktsize);
 
     to.GetAddrInfo(S);
     ((sockaddr_in*)S->ai_addr)->sin_port = 0;
     assert(icmp_pktsize <= MAX_PKT4_SZ);
 
-    debugs(42, 2, HERE << "Send ICMP packet to " << to << ".");
+    debugs(42, 5, HERE << "Send ICMP packet to " << to << ".");
 
     x = sendto(icmp_sock,
                (const void *) pkt,
@@ -158,7 +158,7 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     icmp->icmp6_code = 0;
     icmp->icmp6_cksum = 0;
     icmp->icmp6_id = icmp_ident;
-    icmp->icmp6_seq = (u_short) icmp_pkts_sent++;
+    icmp->icmp6_seq = (unsigned short) icmp_pkts_sent++;
 
     icmp6_pktsize = sizeof(struct icmp6_hdr);
 
@@ -179,7 +179,7 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
         icmp6_pktsize += len;
     }
 
-    icmp->icmp6_cksum = CheckSum((u_short *) icmp, icmp6_pktsize);
+    icmp->icmp6_cksum = CheckSum((unsigned short *) icmp, icmp6_pktsize);
 
     to.GetAddrInfo(S);
     ((sockaddr_in6*)S->ai_addr)->sin6_port = 0;
@@ -97,7 +97,7 @@ internalStaticCheck(const char *urlpath)
  * makes internal url with a given host and port (remote internal url)
  */
 char *
-internalRemoteUri(const char *host, u_short port, const char *dir, const char *name)
+internalRemoteUri(const char *host, unsigned short port, const char *dir, const char *name)
 {
     static char lc_host[SQUIDHOSTNAMELEN];
     assert(host && name);
@@ -276,8 +276,8 @@ Ip::Address::IsSiteLocal6() const
 bool
 Ip::Address::IsSlaac() const
 {
-    return m_SocketAddr.sin6_addr.s6_addr[10] == htons(0xff) &&
-           m_SocketAddr.sin6_addr.s6_addr[11] == htons(0xfe);
+    return m_SocketAddr.sin6_addr.s6_addr[10] == static_cast<uint8_t>(0xff) &&
+           m_SocketAddr.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xfe);
 }
 
 bool
@@ -791,14 +791,14 @@ Ip::Address::operator <(const Ip::Address &rhs) const
     return ( matchIPAddr(rhs) < 0);
 }
 
-u_short
+unsigned short
 Ip::Address::GetPort() const
 {
     return ntohs( m_SocketAddr.sin6_port );
 }
 
-u_short
-Ip::Address::SetPort(u_short prt)
+unsigned short
+Ip::Address::SetPort(unsigned short prt)
 {
     m_SocketAddr.sin6_port = htons(prt);
 
@@ -184,15 +184,15 @@ class Address
      \retval 0 Port is unset or an error occured.
      \retval n Port associated with this address in host native -endian.
      */
-    u_short GetPort() const;
+    unsigned short GetPort() const;
 
     /** Set the Port value for an address.
      *  Replaces any previously existing Port value.
      \param port Port being assigned in host native -endian.
      \retval 0 Port is unset or an error occured.
      \retval n Port associated with this address in host native -endian.
      */
-    u_short SetPort(u_short port);
+    unsigned short SetPort(unsigned short port);
 
     /// Set object to contain the specific IP case ANY_ADDR (format-neutral).
     /// see IsAnyAddr() for more detail.
@@ -43,7 +43,7 @@ testIpAddress::testDefaults()
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( !anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     CPPUNIT_ASSERT( anIPA.IsIPv6() );
 }
 
@@ -64,7 +64,7 @@ testIpAddress::testInAddrConstructor()
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp(&inval, &outval, sizeof(struct in_addr)) == 0 );
 }
@@ -88,7 +88,7 @@ testIpAddress::testInAddr6Constructor()
     CPPUNIT_ASSERT( !anIPA.IsIPv4() );
     CPPUNIT_ASSERT( anIPA.IsIPv6() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &inval, &outval, sizeof(struct in6_addr)) == 0 );
 }
@@ -117,7 +117,7 @@ testIpAddress::testSockAddrConstructor()
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
     CPPUNIT_ASSERT( anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 80 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.GetPort() );
     anIPA.GetSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
@@ -149,7 +149,7 @@ testIpAddress::testSockAddr6Constructor()
     CPPUNIT_ASSERT( !anIPA.IsIPv4() );
     CPPUNIT_ASSERT( anIPA.IsIPv6() );
     CPPUNIT_ASSERT( anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 80 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.GetPort() );
     anIPA.GetSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in6)) == 0 );
 }
@@ -181,7 +181,7 @@ testIpAddress::testCopyConstructor()
     CPPUNIT_ASSERT( outIPA.IsIPv4() );
     CPPUNIT_ASSERT( !outIPA.IsIPv6() );
     CPPUNIT_ASSERT( outIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 80 , outIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , outIPA.GetPort() );
     outIPA.GetSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
@@ -206,7 +206,7 @@ testIpAddress::testHostentConstructor()
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 }
@@ -226,7 +226,7 @@ testIpAddress::testStringConstructor()
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
@@ -251,7 +251,7 @@ testIpAddress::testStringConstructor()
     CPPUNIT_ASSERT( !bnIPA.IsIPv4() );
     CPPUNIT_ASSERT(  bnIPA.IsIPv6() );
     CPPUNIT_ASSERT( !bnIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , bnIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , bnIPA.GetPort() );
     bnIPA.GetInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 
@@ -269,7 +269,7 @@ testIpAddress::testStringConstructor()
     CPPUNIT_ASSERT( !cnIPA.IsIPv4() );
     CPPUNIT_ASSERT( cnIPA.IsIPv6() );
     CPPUNIT_ASSERT( !cnIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , cnIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , cnIPA.GetPort() );
     cnIPA.GetInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 }
@@ -290,7 +290,7 @@ testIpAddress::testSetEmpty()
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
 
     anIPA.SetEmpty();
 
@@ -300,7 +300,7 @@ testIpAddress::testSetEmpty()
     CPPUNIT_ASSERT( !anIPA.IsIPv4() );
     CPPUNIT_ASSERT( anIPA.IsIPv6() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
 }
 
 void
@@ -740,7 +740,7 @@ testIpAddress::testBugNullingDisplay()
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
@@ -754,7 +754,7 @@ testIpAddress::testBugNullingDisplay()
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
@@ -769,7 +769,7 @@ testIpAddress::testBugNullingDisplay()
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
@@ -783,7 +783,7 @@ testIpAddress::testBugNullingDisplay()
     CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
     CPPUNIT_ASSERT( anIPA.IsIPv4() );
     CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (u_short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
     CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
     anIPA.GetInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
@@ -31,8 +31,8 @@ class StoreMapSlot {
         time_t expires;
         time_t lastmod;
         uint64_t swap_file_sz;
-        u_short refcount;
-        u_short flags;
+        uint16_t refcount;
+        uint16_t flags;
 	} basics;
 
     /// possible persistent states
@@ -985,7 +985,7 @@ mainInitialize(void)
     setEffectiveUser();
 
     if (icpPortNumOverride != 1)
-        Config.Port.icp = (u_short) icpPortNumOverride;
+        Config.Port.icp = (unsigned short) icpPortNumOverride;
 
     _db_init(Debug::cache_log, Debug::debugOptions);
 
@@ -77,7 +77,7 @@ static OBJH neighborDumpPeers;
 static OBJH neighborDumpNonPeers;
 static void dump_peers(StoreEntry * sentry, peer * peers);
 
-static u_short echo_port;
+static unsigned short echo_port;
 
 static int NLateReplies = 0;
 static peer *first_ping = NULL;
@@ -565,7 +565,7 @@ neighbors_init(void)
     peerRefreshDNS((void *) 1);
 
     sep = getservbyname("echo", "udp");
-    echo_port = sep ? ntohs((u_short) sep->s_port) : 7;
+    echo_port = sep ? ntohs((unsigned short) sep->s_port) : 7;
 
     first_ping = Config.peers;
 }
@@ -611,7 +611,7 @@ SQUIDCEXTERN char *urlCanonicalClean(const HttpRequest *);
 SQUIDCEXTERN const char *urlCanonicalFakeHttps(const HttpRequest * request);
 SQUIDCEXTERN bool urlIsRelative(const char *);
 SQUIDCEXTERN char *urlMakeAbsolute(const HttpRequest *, const char *);
-SQUIDCEXTERN char *urlRInternal(const char *host, u_short port, const char *dir, const char *name);
+SQUIDCEXTERN char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
 SQUIDCEXTERN char *urlInternal(const char *dir, const char *name);
 SQUIDCEXTERN int matchDomainName(const char *host, const char *domain);
 SQUIDCEXTERN int urlCheckRequest(const HttpRequest *);
@@ -677,7 +677,7 @@ SQUIDCEXTERN void internalStart(const Comm::ConnectionPointer &clientConn, HttpR
 SQUIDCEXTERN int internalCheck(const char *urlpath);
 SQUIDCEXTERN int internalStaticCheck(const char *urlpath);
 SQUIDCEXTERN char *internalLocalUri(const char *dir, const char *name);
-SQUIDCEXTERN char *internalRemoteUri(const char *, u_short, const char *, const char *);
+SQUIDCEXTERN char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
 SQUIDCEXTERN const char *internalHostname(void);
 SQUIDCEXTERN int internalHostnameIs(const char *);
 
@@ -65,7 +65,7 @@ send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *junk)
 
     char *host = Config.Announce.host;
     char *file = NULL;
-    u_short port = Config.Announce.port;
+    unsigned short port = Config.Announce.port;
     int l;
     int n;
     int fd;
@@ -123,6 +123,8 @@ static size_t parseBytesUnits(const char * unit)
     if (!strncasecmp(unit, B_GBYTES_STR, strlen(B_GBYTES_STR)))
         return 1 << 30;
 
+    std::cerr << "WARNING: Unknown bytes unit '" << unit << "'" << std::endl;
+
     return 0;
 }
 
@@ -253,8 +253,8 @@ struct InitStoreEntry : public unary_function<StoreMeta, void> {
                 time_t expires;
                 time_t lastmod;
                 size_t swap_file_sz;
-                u_short refcount;
-                u_short flags;
+                uint16_t refcount;
+                uint16_t flags;
             } *tmp;
             tmp = (struct old_metahdr *)x.value;
             assert(x.length == STORE_HDR_METASIZE_OLD);
@@ -117,7 +117,7 @@ struct acl_size_t {
 };
 
 struct ushortlist {
-    u_short i;
+    unsigned short i;
     ushortlist *next;
 };
 
@@ -231,14 +231,14 @@ struct SquidConfig {
     acl_size_t *ReplyBodySize;
 
     struct {
-        u_short icp;
+        unsigned short icp;
 #if USE_HTCP
 
-        u_short htcp;
+        unsigned short htcp;
 #endif
 #if SQUID_SNMP
 
-        u_short snmp;
+        unsigned short snmp;
 #endif
     } Port;
 
@@ -347,7 +347,7 @@ struct SquidConfig {
         char *host;
         char *file;
         time_t period;
-        u_short port;
+        unsigned short port;
     } Announce;
 
     struct {
@@ -842,18 +842,18 @@ struct peer {
     struct {
         int version;
         int counts[ICP_END+1];
-        u_short port;
+        unsigned short port;
     } icp;
 
 #if USE_HTCP
     struct {
         double version;
         int counts[2];
-        u_short port;
+        unsigned short port;
     } htcp;
 #endif
 
-    u_short http_port;
+    unsigned short http_port;
     domain_ping *peer_domain;
     domain_type *typelist;
     acl_access *access;
@@ -104,7 +104,7 @@ strtokFile(void)
 }
 
 void
-ConfigParser::ParseUShort(u_short *var)
+ConfigParser::ParseUShort(unsigned short *var)
 {
     fatal("not implemented 10");
 }
@@ -33,7 +33,7 @@ void
 testHttpRequest::testCreateFromUrlAndMethod()
 {
     /* vanilla url */
-    u_short expected_port;
+    unsigned short expected_port;
     char * url = xstrdup("http://foo:90/bar");
     HttpRequest *aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_GET);
     expected_port = 90;
@@ -83,7 +83,7 @@ void
 testHttpRequest::testCreateFromUrl()
 {
     /* vanilla url */
-    u_short expected_port;
+    unsigned short expected_port;
     char * url = xstrdup("http://foo:90/bar");
     HttpRequest *aRequest = HttpRequest::CreateFromUrl(url);
     expected_port = 90;
@@ -102,7 +102,7 @@ testHttpRequest::testCreateFromUrl()
 void
 testHttpRequest::testIPv6HostColonBug()
 {
-    u_short expected_port;
+    unsigned short expected_port;
     char * url = NULL;
     HttpRequest *aRequest = NULL;
 
@@ -1072,7 +1072,7 @@ setSystemLimits(void)
 
 #if HAVE_SETRLIMIT && defined(RLIMIT_VMEM)
     if (getrlimit(RLIMIT_VMEM, &rl) < 0) {
-        debugs(50, 0, "getrlimit: RLIMIT_VMEM: " << xstrerror());
+        debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_VMEM: " << xstrerror());
     } else if (rl.rlim_max > rl.rlim_cur) {
         rl.rlim_cur = rl.rlim_max;	/* set it to the max */
 
@@ -1095,7 +1095,7 @@ squid_signal(int sig, SIGHDLR * func, int flags)
     sigemptyset(&sa.sa_mask);
 
     if (sigaction(sig, &sa, NULL) < 0)
-        debugs(50, 0, "sigaction: sig=" << sig << " func=" << func << ": " << xstrerror());
+        debugs(50, DBG_CRITICAL, "sigaction: sig=" << sig << " func=" << func << ": " << xstrerror());
 
 #else
 #if _SQUID_MSWIN_
@@ -1270,7 +1270,7 @@ getMyPort(void)
     if (Config.Sockaddr.http) {
         // skip any special mode ports
         http_port_list *p = Config.Sockaddr.http;
-        while (p->intercepted || p->accel || p->spoof_client_ip)
+        while (p && (p->intercepted || p->accel || p->spoof_client_ip))
             p = p->next;
         if (p)
             return p->s.GetPort();
@@ -78,10 +78,11 @@ class TunnelStateData
     {
 
     public:
-        Connection() : len (0), buf(), size_ptr(NULL) { buf.init(SQUID_TCP_SO_RCVBUF,SQUID_TCP_SO_RCVBUF); }
-        ~Connection() {};
+        Connection() : len (0), buf ((char *)xmalloc(SQUID_TCP_SO_RCVBUF)), size_ptr(NULL) {}
 
-        int bytesWanted() const;
+        ~Connection();
+
+        int bytesWanted(int lower=0, int upper = INT_MAX) const;
         void bytesIn(int const &);
 #if USE_DELAY_POOLS
 
@@ -91,9 +92,9 @@ class TunnelStateData
         void error(int const xerrno);
         int debugLevelForError(int const xerrno) const;
         void closeIfOpen();
-        void dataSent(size_t amount);
+        void dataSent (size_t amount);
         int len;
-        MemBuf buf;
+        char *buf;
         int64_t *size_ptr;		/* pointer to size in an ConnStateData for logging */
 
         Comm::ConnectionPointer conn;    ///< The currently connected connection.
@@ -112,7 +113,7 @@ class TunnelStateData
 
 private:
     CBDATA_CLASS(TunnelStateData);
-    void copy(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, AsyncCall::Pointer &);
+    void copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *);
     void readServer(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void readClient(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void writeClientDone(char *buf, size_t len, comm_err_t flag, int xerrno);
@@ -179,13 +180,19 @@ tunnelStateFree(TunnelStateData * tunnelState)
     delete tunnelState;
 }
 
+TunnelStateData::Connection::~Connection()
+{
+    safe_free(buf);
+}
+
 int
-TunnelStateData::Connection::bytesWanted() const
+TunnelStateData::Connection::bytesWanted(int lowerbound, int upperbound) const
 {
 #if USE_DELAY_POOLS
-    return delayId.bytesWanted(1, buf.spaceSize());
+    return delayId.bytesWanted(lowerbound, upperbound);
 #else
-    return buf.spaceSize();
+
+    return upperbound;
 #endif
 }
 
@@ -246,10 +253,7 @@ TunnelStateData::readServer(char *buf, size_t len, comm_err_t errcode, int xerrn
         kb_incr(&statCounter.server.other.kbytes_in, len);
     }
 
-    AsyncCall::Pointer call = commCbCall(5,5, "TunnelStateData::WriteClientDone",
-                                         CommIoCbPtrFun(WriteClientDone, this));
-
-    copy (len, errcode, xerrno, server, client, call);
+    copy (len, errcode, xerrno, server, client, WriteClientDone);
 }
 
 void
@@ -292,14 +296,11 @@ TunnelStateData::readClient(char *buf, size_t len, comm_err_t errcode, int xerrn
         kb_incr(&statCounter.client_http.kbytes_in, len);
     }
 
-    AsyncCall::Pointer call = commCbCall(5,5, "TunnelStateData::WriteServerDone",
-                                         CommIoCbPtrFun(WriteServerDone, this));
-
-    copy (len, errcode, xerrno, client, server, call);
+    copy (len, errcode, xerrno, client, server, WriteServerDone);
 }
 
 void
-TunnelStateData::copy(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, AsyncCall::Pointer &call)
+TunnelStateData::copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *completion)
 {
     debugs(26, 3, HERE << "from={" << from.conn << "}, to={" << to.conn << "}");
 
@@ -328,7 +329,9 @@ TunnelStateData::copy(size_t len, comm_err_t errcode, int xerrno, Connection &fr
         }
     } else if (cbdataReferenceValid(this)) {
         debugs(26, 3, HERE << "Schedule Write");
-        Comm::Write(to.conn, &from.buf, call);
+        AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
+                                             CommIoCbPtrFun(completion, this));
+        Comm::Write(to.conn, from.buf, len, call, NULL);
     }
 
     cbdataInternalUnlock(this);	/* ??? */
@@ -473,7 +476,7 @@ TunnelStateData::copyRead(Connection &from, IOCB *completion)
     assert(from.len == 0);
     AsyncCall::Pointer call = commCbCall(5,4, "TunnelBlindCopyReadHandler",
                                          CommIoCbPtrFun(completion, this));
-    comm_read(from.conn, from.buf.space(), from.bytesWanted(), call);
+    comm_read(from.conn, from.buf, from.bytesWanted(1, SQUID_TCP_SO_RCVBUF), call);
 }
 
 /**
@@ -98,8 +98,8 @@ struct MetaStd {
     time_t expires;
     time_t lastmod;
     size_t swap_file_sz;
-    u_short refcount;
-    u_short flags;
+    uint16_t refcount;
+    uint16_t flags;
 };
 
 struct MetaStdLfs {
@@ -108,8 +108,8 @@ struct MetaStdLfs {
     time_t expires;
     time_t lastmod;
     uint64_t swap_file_sz;
-    u_short refcount;
-    u_short flags;
+    uint16_t refcount;
+    uint16_t flags;
 };
 
 struct DumpStoreMeta : public unary_function<StoreMeta, void> {
@@ -447,7 +447,7 @@ urlParseFinish(const HttpRequestMethod& method,
 
     request->SetHost(host);
     xstrncpy(request->login, login, MAX_LOGIN_SZ);
-    request->port = (u_short) port;
+    request->port = (unsigned short) port;
     return request;
 }
 
@@ -139,12 +139,12 @@ wccpConnectionOpen(void)
     }
 
     if ( !Config.Wccp.router.SetIPv4() ) {
-        debugs(1, 1, "WCCPv1 Disabled. Router " << Config.Wccp.router << " is not IPv4.");
+        debugs(80, DBG_CRITICAL, "WCCPv1 Disabled. Router " << Config.Wccp.router << " is not an IPv4 address.");
         return;
     }
 
     if ( !Config.Wccp.address.SetIPv4() ) {
-        debugs(1, 1, "WCCPv1 Disabled. Local address " << Config.Wccp.address << " is not IPv4.");
+        debugs(80, DBG_CRITICAL, "WCCPv1 Disabled. Local address " << Config.Wccp.address << " is not an IPv4 address.");
         return;
     }
 
@@ -985,12 +985,12 @@ wccp2ConnectionOpen(void)
     debugs(80, 5, "wccp2ConnectionOpen: Called");
 
     if (wccp2_numrouters == 0 || !wccp2_service_list_head) {
-        debugs(80, 2, "WCCPv2 Disabled.");
+        debugs(80, 2, "WCCPv2 Disabled. No IPv4 Router(s) configured.");
         return;
     }
 
     if ( !Config.Wccp2.address.SetIPv4() ) {
-        debugs(80, 0, "WCCPv2 Disabled. " << Config.Wccp2.address << " is not an IPv4 address.");
+        debugs(80, DBG_CRITICAL, "WCCPv2 Disabled. Local address " << Config.Wccp2.address << " is not an IPv4 address.");
         return;
     }
 
@@ -1630,7 +1630,7 @@ wccp2AssignBuckets(void *voidnotused)
     int router_len;
     int bucket_counter;
     uint32_t service_flags;
-    u_short port = WCCP_PORT;
+    unsigned short port = WCCP_PORT;
 
     /* Packet segments */
 
@@ -2135,7 +2135,7 @@ parse_wccp2_service(void *v)
     service_id = GetInteger();
 
     if (service_id < 0 || service_id > 255) {
-        debugs(80, 0, "wccp2ParseServiceInfo: service info id " << service_id << " is out of range (0..255)");
+        debugs(80, DBG_CRITICAL, "ERROR: invalid WCCP service id " << service_id << " (must be between 0 .. 255)");
         self_destruct();
     }
 
@@ -2306,7 +2306,7 @@ parse_wccp2_service_info(void *v)
     service_id = GetInteger();
 
     if (service_id < 0 || service_id > 255) {
-        debugs(80, 1, "parse_wccp2_service_info: invalid service id " << service_id << " (must be between 0 .. 255)");
+        debugs(80, DBG_CRITICAL, "ERROR: invalid WCCP service id " << service_id << " (must be between 0 .. 255)");
         self_destruct();
     }
 
@@ -78,18 +78,18 @@ struct StoreMetaStd {
   time_t  expires;
   time_t  lastmod;
   size_t  swap_file_sz;
-  u_short refcount;
-  u_short flags;
+  uint16_t refcount;
+  uint16_t flags;
 };
 
 struct StoreMetaStdLFS {
   time_t  timestamp;
   time_t  lastref;
   time_t  expires;
   time_t  lastmod;
-  uint64_t  swap_file_sz;
-  u_short refcount;
-  u_short flags;
+  uint64_t swap_file_sz;
+  uint16_t refcount;
+  uint16_t flags;
 };
 
 struct SquidTLV {