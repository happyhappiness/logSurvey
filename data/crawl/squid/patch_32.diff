----++++src/acl/SslErrorData.cc
@@ -9,74 +9,43 @@
 #include &quot;squid.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/SslErrorData.h&quot;
-#include "wordlist.h"
+#include "ssl/ErrorDetail.h"
 
-ACLSslErrorData::ACLSslErrorData() : values (NULL)
+ACLSslErrorData::ACLSslErrorData(ACLSslErrorData const &amp;o) :
+    values(o.values)
 {}
 
-ACLSslErrorData::ACLSslErrorData(ACLSslErrorData const &amp;old) : values (NULL)
-{
-    assert (!old.values);
-}
-
-ACLSslErrorData::~ACLSslErrorData()
-{
-    if (values)
-        delete values;
-}
-
 bool
 ACLSslErrorData::match(const Ssl::CertErrors *toFind)
 {
-    for (const Ssl::CertErrors *err = toFind; err; err = err-&gt;next ) {
-        if (values-&gt;findAndTune(err-&gt;element.code))
+    for (const auto *err = toFind; err; err = err-&gt;next) {
+        if (values.count(err-&gt;element.code))
             return true;
     }
     return false;
 }
 
-/* explicit instantiation required for some systems */
-/** \cond AUTODOCS_IGNORE */
-// AYJ: 2009-05-20 : Removing. clashes with template &lt;int&gt; instantiation for other ACLs.
-// template cbdata_type Ssl::Errors::CBDATA_CbDataList;
-/** \endcond */
-
 SBufList
 ACLSslErrorData::dump() const
 {
     SBufList sl;
-    Ssl::Errors *data = values;
-    while (data != NULL) {
-        sl.push_back(SBuf(Ssl::GetErrorName(data-&gt;element)));
-        data = data-&gt;next;
+    for (const auto &amp;e : values) {
+        sl.push_back(SBuf(Ssl::GetErrorName(e)));
     }
     return sl;
 }
 
 void
 ACLSslErrorData::parse()
 {
-    Ssl::Errors **Tail;
-
-    for (Tail = &amp;values; *Tail; Tail = &amp;((*Tail)-&gt;next));
     while (char *t = ConfigParser::strtokFile()) {
-        Ssl::Errors *q = Ssl::ParseErrorString(t);
-        *(Tail) = q;
-        Tail = &amp;q-&gt;tail()-&gt;next;
+        Ssl::ParseErrorString(t, values);
     }
 }
 
-bool
-ACLSslErrorData::empty() const
-{
-    return values == NULL;
-}
-
 ACLSslErrorData *
 ACLSslErrorData::clone() const
 {
-    /* Splay trees don&#39;t clone yet. */
-    assert (!values);
     return new ACLSslErrorData(*this);
 }
 
----++++src/acl/SslErrorData.h
@@ -11,27 +11,24 @@
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Data.h&quot;
-#include &quot;base/CbDataList.h&quot;
-#include &quot;ssl/ErrorDetail.h&quot;
 #include &quot;ssl/support.h&quot;
-#include &lt;vector&gt;
 
 class ACLSslErrorData : public ACLData&lt;const Ssl::CertErrors *&gt;
 {
     MEMPROXY_CLASS(ACLSslErrorData);
 
 public:
-    ACLSslErrorData();
+    ACLSslErrorData() = default;
     ACLSslErrorData(ACLSslErrorData const &amp;);
     ACLSslErrorData &amp;operator= (ACLSslErrorData const &amp;);
-    virtual ~ACLSslErrorData();
+    virtual ~ACLSslErrorData() {}
     bool match(const Ssl::CertErrors *);
     virtual SBufList dump() const;
     void parse();
-    bool empty() const;
+    bool empty() const { return values.empty(); }
     virtual  ACLSslErrorData *clone() const;
 
-    Ssl::Errors *values;
+    Security::Errors values;
 };
 
 #endif /* SQUID_ACLSSL_ERRORDATA_H */
----++++src/security/forward.h
@@ -18,6 +18,7 @@
 #endif
 #endif
 #include &lt;list&gt;
+#include &lt;unordered_set&gt;
 
 #if USE_OPENSSL
 // Macro to be used to define the C++ wrapper functor of the sk_*_pop_free
@@ -78,6 +79,10 @@ class EncryptorAnswer;
 /// Squid defined error code (&lt;0), an error code returned by X.509 API, or SSL_ERROR_NONE
 typedef int ErrorCode;
 
+/// set of Squid defined TLS error codes
+/// \note using std::unordered_set ensures values are unique, with fast lookup
+typedef std::unordered_set&lt;Security::ErrorCode&gt; Errors;
+
 class KeyData;
 class PeerConnector;
 class PeerOptions;
----++++src/ssl/ErrorDetail.cc
@@ -352,20 +352,24 @@ Security::ErrorCode Ssl::GetErrorCode(const char *name)
     return SSL_ERROR_NONE;
 }
 
-Ssl::Errors *
-Ssl::ParseErrorString(const char *name)
+bool
+Ssl::ParseErrorString(const char *name, Security::Errors &amp;errors)
 {
     assert(name);
 
     const Security::ErrorCode ssl_error = GetErrorCode(name);
-    if (ssl_error != SSL_ERROR_NONE)
-        return new Ssl::Errors(ssl_error);
+    if (ssl_error != SSL_ERROR_NONE) {
+        errors.emplace(ssl_error);
+        return true;
+    }
 
     if (xisdigit(*name)) {
         const long int value = strtol(name, NULL, 0);
-        if (SQUID_SSL_ERROR_MIN &lt;= value &amp;&amp; value &lt;= SQUID_SSL_ERROR_MAX)
-            return new Ssl::Errors(value);
-        fatalf(&quot;Too small or too bug SSL error code &#39;%s&#39;&quot;, name);
+        if (SQUID_SSL_ERROR_MIN &lt;= value &amp;&amp; value &lt;= SQUID_SSL_ERROR_MAX) {
+            errors.emplace(value);
+            return true;
+        }
+        fatalf(&quot;Too small or too big TLS error code &#39;%s&#39;&quot;, name);
     }
 
     if (TheSslErrorShortcuts.empty())
@@ -375,15 +379,14 @@ Ssl::ParseErrorString(const char *name)
     if (it != TheSslErrorShortcuts.end()) {
         // Should not be empty...
         assert(it-&gt;second[0] != SSL_ERROR_NONE);
-        Ssl::Errors *errors = new Ssl::Errors(it-&gt;second[0]);
-        for (int i =1; it-&gt;second[i] != SSL_ERROR_NONE; ++i) {
-            errors-&gt;push_back_unique(it-&gt;second[i]);
+        for (int i = 0; it-&gt;second[i] != SSL_ERROR_NONE; ++i) {
+            errors.emplace(it-&gt;second[i]);
         }
-        return errors;
+        return true;
     }
 
-    fatalf("Unknown SSL error name '%s'", name);
-    return NULL; // not reached
+    fatalf("Unknown TLS error name '%s'", name);
+    return false; // not reached
 }
 
 const char *Ssl::GetErrorName(Security::ErrorCode value)
----++++src/ssl/ErrorDetail.h
@@ -17,13 +17,11 @@
 namespace Ssl
 {
 /**
-  \ingroup ServerProtocolSSLAPI
- * Converts user-friendly error &quot;name&quot; into an Ssl::Errors list.
- * The resulting list may have one or more elements, and needs to be
- * released by the caller.
+ * Converts user-friendly error &quot;name&quot; into an Security::ErrorCode
+ * and adds it to the provided container (using emplace).
  * This function can handle numeric error numbers as well as names.
  */
-Ssl::Errors *ParseErrorString(const char *name);
+bool ParseErrorString(const char *name, Security::Errors &amp;);
 
 /// The Security::ErrorCode code of the error described by  &quot;name&quot;.
 Security::ErrorCode GetErrorCode(const char *name);
@@ -34,16 +32,10 @@ const char *GetErrorName(Security::ErrorCode value);
 /// A short description of the TLS error &quot;value&quot;
 const char *GetErrorDescr(Security::ErrorCode value);
 
-/**
-   \ingroup ServerProtocolSSLAPI
-   * Return true if the SSL error is optional and may not supported
-   * by current squid version
- */
-
+/// \return true if the TLS error is optional and may not be supported by current squid version
 bool ErrorIsOptional(const char *name);
 
 /**
-   \ingroup ServerProtocolSSLAPI
  * Used to pass SSL error details to the error pages returned to the
  * end user.
  */
----++++src/ssl/support.h
@@ -69,8 +69,6 @@ namespace Ssl
 /// call before generating any SSL context
 void Initialize();
 
-typedef CbDataList&lt;Security::ErrorCode&gt; Errors;
-
 class ErrorDetail;
 class CertValidationResponse;
 typedef RefCount&lt;CertValidationResponse&gt; CertValidationResponsePointer;
----++++GitHub