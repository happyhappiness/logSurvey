@@ -3,15 +3,15 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.286 2002/09/29 12:55:52 hno Exp $
+dnl  $Id: configure.in,v 1.287 2002/10/02 11:06:28 robertc Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_AUX_DIR(cfgaux)
 AM_INIT_AUTOMAKE(squid, 2.6-DEVEL)
 AM_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.286 $)dnl
+AC_REVISION($Revision: 1.287 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AM_MAINTAINER_MODE
 
@@ -1127,6 +1127,27 @@ AC_ARG_ENABLE(stacktraces,
   fi
 ])
 
+AM_CONDITIONAL(ENABLE_XPROF_STATS, false)
+dnl Enable USE_XPROF_STATS
+AC_ARG_ENABLE(cpu-profiling,
+[  --enable-cpu-profiling
+                          This option allows you to see which internal functions
+                          in Squid are consuming how much CPU. Compiles in probes
+                          that measure time spent in probed functions. Needs
+                          source modifications to add new probes. This is meant
+                          for developers to assist in performance optimisations
+                          of Squid internal functions.
+                          If you are not developer and not interested in the stats
+                          you shouldn't enable this, as overhead added, although
+                          small, is still overhead. See lib/Profiler.c for more.
+                          ],
+[ if test "$enableval" = "yes" ; then
+    echo "Enabling cpu-profiling"
+    AC_DEFINE(USE_XPROF_STATS, 1)
+    AM_CONDITIONAL(ENABLE_XPROF_STATS, true)
+  fi
+])
+
 dnl Enable X-Accelerator-Vary for Vary support within an accelerator setup
 AC_ARG_ENABLE(x_accelerator_vary,
 [  --enable-x-accelerator-vary
@@ -107,6 +107,9 @@
 
 #undef FORW_VIA_DB
 
+/* Define to enable CPU profiling within Squid */
+#undef USE_XPROF_STATS
+
 /* Define if you have problems with memPools and want to disable Pools */
 #undef DISABLE_POOLS
 
@@ -0,0 +1,131 @@
+
+#ifndef _PROFILING_H_
+#define _PROFILING_H_
+
+#include "config.h"
+
+#ifdef USE_XPROF_STATS
+
+#if !defined(_SQUID_SOLARIS_)
+typedef long long hrtime_t;
+#else
+#include <sys/time.h>
+#endif
+
+#if defined(__i386)
+static inline hrtime_t
+get_tick(void)
+{
+    hrtime_t regs;
+    asm volatile ("rdtsc":"=A" (regs));
+    return regs;
+    /* We need return value, we rely on CC to optimise out needless subf calls */
+    /* Note that "rdtsc" is relatively slow OP and stalls the CPU pipes, so use it wisely */
+}
+
+#elif defined(__alpha)
+static inline hrtime_t
+get_tick(void)
+{
+    hrtime_t regs;
+    asm volatile ("rpcc $0":"=A" (regs));	/* I'm not sure of syntax */
+    return regs;
+}
+#else
+#warning Unsupported CPU. Define function get_tick(). Disabling USE_XPROF_STATS...
+#undef USE_XPROF_STATS
+#endif
+
+#endif /* USE_XPROF_STATS - maybe disabled above */
+
+#ifdef USE_XPROF_STATS
+
+typedef enum {
+    XPROF_PROF_UNACCOUNTED,
+    XPROF_PROF_OVERHEAD,
+    XPROF_hash_lookup,
+    XPROF_splay_splay,
+    XPROF_xmalloc,
+    XPROF_malloc,
+    XPROF_xfree,
+    XPROF_xxfree,
+    XPROF_xrealloc,
+    XPROF_xcalloc,
+    XPROF_calloc,
+    XPROF_xstrdup,
+    XPROF_xstrndup,
+    XPROF_xstrncpy,
+    XPROF_xcountws,
+    XPROF_memPoolChunkNew,
+    XPROF_memPoolAlloc,
+    XPROF_memPoolFree,
+    XPROF_memPoolClean,
+    XPROF_aclMatchAclList,
+    XPROF_aclCheckFast,
+    XPROF_comm_open,
+    XPROF_comm_connect_addr,
+    XPROF_comm_accept,
+    XPROF_comm_close,
+    XPROF_comm_udp_sendto,
+    XPROF_commHandleWrite,
+    XPROF_comm_check_incoming,
+    XPROF_comm_poll_prep_pfds,
+    XPROF_comm_poll_normal,
+    XPROF_comm_handle_ready_fd,
+    XPROF_comm_read_handler,
+    XPROF_comm_write_handler,
+    XPROF_storeGet,
+    XPROF_storeMaintainSwapSpace,
+    XPROF_storeRelease,
+    XPROF_diskHandleWrite,
+    XPROF_diskHandleRead,
+    XPROF_file_open,
+    XPROF_file_read,
+    XPROF_file_write,
+    XPROF_file_close,
+    XPROF_LAST
+} xprof_type;
+
+#define XP_NOBEST 9999999999
+
+typedef struct _xprof_stats_node xprof_stats_node;
+typedef struct _xprof_stats_data xprof_stats_data;
+
+struct _xprof_stats_data {
+    hrtime_t start;
+    hrtime_t stop;
+    hrtime_t delta;
+    hrtime_t best;
+    hrtime_t worst;
+    hrtime_t count;
+    long long summ;
+};
+
+struct _xprof_stats_node {
+    const char *name;
+    xprof_stats_data accu;
+    xprof_stats_data hist;
+};
+
+typedef xprof_stats_node TimersArray[1];
+
+/* public Data */
+extern TimersArray *xprof_Timers;
+extern int xprof_nesting;
+
+/* Exported functions */
+extern void xprof_start(xprof_type type, const char *timer);
+extern void xprof_stop(xprof_type type, const char *timer);
+extern void xprof_event(void *data);
+
+#define PROF_start(type) xprof_start(XPROF_##type, #type)
+#define PROF_stop(type) xprof_stop(XPROF_##type, #type)
+
+#else /* USE_XPROF_STATS */
+
+#define PROF_start(ARGS) ((void)0)
+#define PROF_stop(ARGS) ((void)0)
+
+#endif /* USE_XPROF_STATS */
+
+#endif /* _PROFILING_H_ */
@@ -1,8 +1,14 @@
 ## Process this file with automake to produce Makefile.in
 #
-#  $Id: Makefile.am,v 1.4 2002/04/06 08:49:26 adrian Exp $
+#  $Id: Makefile.am,v 1.5 2002/10/02 11:06:30 robertc Exp $
 #
 
+if ENABLE_XPROF_STATS
+XPROF_STATS_SOURCE = Profiler.c
+else
+XPROF_STATS_SOURCE = 
+endif
+
 if NEED_OWN_SNPRINTF
 SNPRINTFSOURCE=snprintf.c
 else
@@ -24,6 +30,7 @@ noinst_LIBRARIES = \
 	@LIBREGEX@
 EXTRA_libmiscutil_a_SOURCES = \
 	md5.c \
+	Profiler.c \
 	snprintf.c
 libmiscutil_a_SOURCES = \
 	MemPool.c \
@@ -46,7 +53,8 @@ libmiscutil_a_SOURCES = \
 	Stack.c \
 	stub_memaccount.c \
 	util.c \
-	uudecode.c
+	uudecode.c \
+	$(XPROF_STATS_SOURCE)
 libmiscutil_a_LIBADD = \
 	@LIBOBJS@
 # $(top_srcdir)/include/version.h should be a dependency
@@ -14,7 +14,7 @@
 @SET_MAKE@
 
 #
-#  $Id: Makefile.in,v 1.67 2002/09/30 00:23:01 hno Exp $
+#  $Id: Makefile.in,v 1.68 2002/10/02 11:06:30 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -117,6 +117,9 @@ am__quote = @am__quote@
 install_sh = @install_sh@
 makesnmplib = @makesnmplib@
 
+@ENABLE_XPROF_STATS_TRUE@XPROF_STATS_SOURCE = Profiler.c
+@ENABLE_XPROF_STATS_FALSE@XPROF_STATS_SOURCE = 
+
 @NEED_OWN_SNPRINTF_TRUE@SNPRINTFSOURCE = snprintf.c
 @NEED_OWN_SNPRINTF_FALSE@SNPRINTFSOURCE = 
 @NEED_OWN_MD5_TRUE@MD5SOURCE = md5.c
@@ -134,6 +137,7 @@ noinst_LIBRARIES = \
 
 EXTRA_libmiscutil_a_SOURCES = \
 	md5.c \
+	Profiler.c \
 	snprintf.c
 
 libmiscutil_a_SOURCES = \
@@ -157,7 +161,8 @@ libmiscutil_a_SOURCES = \
 	Stack.c \
 	stub_memaccount.c \
 	util.c \
-	uudecode.c
+	uudecode.c \
+	$(XPROF_STATS_SOURCE)
 
 libmiscutil_a_LIBADD = \
 	@LIBOBJS@
@@ -193,14 +198,16 @@ libmiscutil_a_DEPENDENCIES = @LIBOBJS@
 @NEED_OWN_MD5_FALSE@am__objects_1 =
 @NEED_OWN_SNPRINTF_TRUE@am__objects_2 = snprintf.$(OBJEXT)
 @NEED_OWN_SNPRINTF_FALSE@am__objects_2 =
+@ENABLE_XPROF_STATS_TRUE@am__objects_3 = Profiler.$(OBJEXT)
+@ENABLE_XPROF_STATS_FALSE@am__objects_3 =
 am_libmiscutil_a_OBJECTS = MemPool.$(OBJEXT) Array.$(OBJEXT) \
 	base64.$(OBJEXT) getfullhostname.$(OBJEXT) hash.$(OBJEXT) \
 	heap.$(OBJEXT) html_quote.$(OBJEXT) iso3307.$(OBJEXT) \
 	$(am__objects_1) radix.$(OBJEXT) rfc1035.$(OBJEXT) \
 	rfc1123.$(OBJEXT) rfc1738.$(OBJEXT) rfc2617.$(OBJEXT) \
 	safe_inet_addr.$(OBJEXT) $(am__objects_2) splay.$(OBJEXT) \
 	Stack.$(OBJEXT) stub_memaccount.$(OBJEXT) util.$(OBJEXT) \
-	uudecode.$(OBJEXT)
+	uudecode.$(OBJEXT) $(am__objects_3)
 libmiscutil_a_OBJECTS = $(am_libmiscutil_a_OBJECTS)
 libntlmauth_a_AR = $(AR) cru
 libntlmauth_a_DEPENDENCIES = @LIBOBJS@
@@ -218,19 +225,20 @@ LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 depcomp = $(SHELL) $(top_srcdir)/cfgaux/depcomp
 @AMDEP_TRUE@DEP_FILES = $(DEPDIR)/Array.Po $(DEPDIR)/GNUregex.Po \
-@AMDEP_TRUE@	$(DEPDIR)/MemPool.Po $(DEPDIR)/Stack.Po \
-@AMDEP_TRUE@	$(DEPDIR)/base64.Po $(DEPDIR)/dlmalloc.Po \
-@AMDEP_TRUE@	$(DEPDIR)/drand48.Po $(DEPDIR)/getfullhostname.Po \
-@AMDEP_TRUE@	$(DEPDIR)/hash.Po $(DEPDIR)/heap.Po \
-@AMDEP_TRUE@	$(DEPDIR)/html_quote.Po $(DEPDIR)/inet_ntoa.Po \
-@AMDEP_TRUE@	$(DEPDIR)/iso3307.Po $(DEPDIR)/md5.Po \
-@AMDEP_TRUE@	$(DEPDIR)/ntlmauth.Po $(DEPDIR)/radix.Po \
-@AMDEP_TRUE@	$(DEPDIR)/rfc1035.Po $(DEPDIR)/rfc1123.Po \
-@AMDEP_TRUE@	$(DEPDIR)/rfc1738.Po $(DEPDIR)/rfc2617.Po \
-@AMDEP_TRUE@	$(DEPDIR)/safe_inet_addr.Po $(DEPDIR)/snprintf.Po \
-@AMDEP_TRUE@	$(DEPDIR)/splay.Po $(DEPDIR)/strerror.Po \
-@AMDEP_TRUE@	$(DEPDIR)/stub_memaccount.Po $(DEPDIR)/tempnam.Po \
-@AMDEP_TRUE@	$(DEPDIR)/util.Po $(DEPDIR)/uudecode.Po
+@AMDEP_TRUE@	$(DEPDIR)/MemPool.Po $(DEPDIR)/Profiler.Po \
+@AMDEP_TRUE@	$(DEPDIR)/Stack.Po $(DEPDIR)/base64.Po \
+@AMDEP_TRUE@	$(DEPDIR)/dlmalloc.Po $(DEPDIR)/drand48.Po \
+@AMDEP_TRUE@	$(DEPDIR)/getfullhostname.Po $(DEPDIR)/hash.Po \
+@AMDEP_TRUE@	$(DEPDIR)/heap.Po $(DEPDIR)/html_quote.Po \
+@AMDEP_TRUE@	$(DEPDIR)/inet_ntoa.Po $(DEPDIR)/iso3307.Po \
+@AMDEP_TRUE@	$(DEPDIR)/md5.Po $(DEPDIR)/ntlmauth.Po \
+@AMDEP_TRUE@	$(DEPDIR)/radix.Po $(DEPDIR)/rfc1035.Po \
+@AMDEP_TRUE@	$(DEPDIR)/rfc1123.Po $(DEPDIR)/rfc1738.Po \
+@AMDEP_TRUE@	$(DEPDIR)/rfc2617.Po $(DEPDIR)/safe_inet_addr.Po \
+@AMDEP_TRUE@	$(DEPDIR)/snprintf.Po $(DEPDIR)/splay.Po \
+@AMDEP_TRUE@	$(DEPDIR)/strerror.Po $(DEPDIR)/stub_memaccount.Po \
+@AMDEP_TRUE@	$(DEPDIR)/tempnam.Po $(DEPDIR)/util.Po \
+@AMDEP_TRUE@	$(DEPDIR)/uudecode.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
@@ -285,6 +293,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/Array.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/GNUregex.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/MemPool.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/Profiler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/Stack.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/base64.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/dlmalloc.Po@am__quote@
@@ -0,0 +1,183 @@
+
+/*
+ * $Id: Profiler.c,v 1.1 2002/10/02 11:06:30 robertc Exp $
+ *
+ * DEBUG: section 81     CPU Profiling Routines
+ * AUTHOR: Andres Kroonmaa, Sep.2000
+ *
+ * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from the
+ *  Internet community.  Development is led by Duane Wessels of the
+ *  National Laboratory for Applied Network Research and funded by the
+ *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
+ *  the Regents of the University of California.  Please see the
+ *  COPYRIGHT file for full details.  Squid incorporates software
+ *  developed and/or copyrighted by other sources.  Please see the
+ *  CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/*
+ * CPU Profiling implementation.
+ * 
+ *  This library implements the Probes needed to gather stats.
+ *  See src/ProfStats.c which implements historical recording and
+ *  presentation in CacheMgr.cgi.
+ * 
+ *  For timing we prefer on-CPU ops that retrieve cpu ticks counter.
+ *  For Intel, this is "rdtsc", which is 64-bit counter that virtually
+ *  never wraps. For alpha, this is "rpcc" which is 32-bit counter and
+ *  wraps every few seconds. Currently, no handling of wrapping counters
+ *  is implemented. Other CPU's are also not covered. Potentially all
+ *  modern CPU's has similar counters.
+ * 
+ * Usage.
+ *  Insert macro PROF_state(probename) in strategic places in code.
+ *    PROF_start(probename);
+ *     ...  section of code measured ...
+ *    PROF_stop(probename);
+ * 
+ *   probename must be added to profiling.h into xprof_type enum list
+ *   with prepended "XPROF_" string.
+ *
+ * Description.
+ *  PROF gathers stats per probename into structures. It indexes these
+ *  structures by enum type index in an array.
+ * 
+ *  PROF records best, best, average and worst values for delta time,
+ *  also, if UNACCED is defined, it measures "empty" time during which
+ *  no probes are in measuring state. This allows to see time "unaccounted"
+ *  for. If OVERHEAD is defined, additional calculations are made at every
+ *  probe to measure approximate overhead of the probe code itself.
+ * 
+ *  Probe data is stored in linked-list, so the more probes you define,
+ *  the more overhead is added to find the deepest nested probe. To reduce
+ *  average overhead, linked list is manipulated each time PR_start is
+ *  called, so that probe just started is moved 1 position up in linkedlist.
+ *  This way frequently used probes are moved closer to the head of list,
+ *  reducing average overhead.
+ *  Note that all overhead is on the scale of one hundred of CPU clock
+ *  ticks, which on the scale of submicroseconds. Yet, to optimise really
+ *  fast and frequent sections of code, we want to reduce this overhead
+ *  to absolute minimum possible.
+ * 
+ *  For actual measurements, probe overhead cancels out mostly. Still,
+ *  do not take the measured times as facts, they should be viewed in
+ *  relative comparison to overall CPU time and on the same platform.
+ * 
+ *  Every 1 second, Event within squid is called that parses gathered
+ *  statistics of every probe, and accumulates that into historical
+ *  structures for last 1,5,30 secs, 1,5,30 mins, and 1,5 and 24 hours.
+ *  Each second active probe stats are reset, and only historical data
+ *  is presented in cachemgr output.
+ * 
+ * Reading stats.
+ *  "Worst case" may be misleading. Anything can happen at any section
+ *  of code that could delay reaching to probe stop. For eg. system may
+ *  need to service interrupt routine, task switch could occur, or page
+ *  fault needs to be handled. In this sense, this is quite meaningless
+ *  metric. "Best case" shows fastest completion of probe section, and
+ *  is also somewhat useless, unless you know that amount of work is
+ *  constant. Best metric to watch is "average time" and total cumulated
+ *  time in given timeframe, which really show percentage of time spent
+ *  in given section of code, and its average completion time. This data
+ *  could be used to detect bottlenecks withing squid and optimise them.
+ * 
+ *  TOTALS are quite off reality. Its there just to summarise cumulative
+ *  times and percent column. Percent values over 100% shows that there
+ *  have been some probes nested into each other.
+ * 
+ */
+
+#include "profiling.h"
+
+#ifdef USE_XPROF_STATS
+
+
+#if HAVE_GNUMALLLOC_H
+#include <gnumalloc.h>
+#elif HAVE_MALLOC_H && !defined(_SQUID_FREEBSD_) && !defined(_SQUID_NEXT_)
+#include <malloc.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+/* Exported Data */
+TimersArray *xprof_Timers = NULL;
+int xprof_nesting = 0;
+
+/* Private stuff */
+
+static inline void
+xprof_update(xprof_stats_data * head)
+{
+    head->delta = head->stop - head->start;
+    if (head->delta < head->best)
+	head->best = head->delta;
+    if (head->worst < head->delta)
+	head->worst = head->delta;
+    head->summ += head->delta;
+    head->count++;
+}
+
+static xprof_stats_data *xp_UNACCOUNTED;
+static int xprof_inited = 0;
+
+static void
+xprof_InitLib(void)
+{
+    if (xprof_inited)
+	return;
+
+    xprof_Timers = calloc(XPROF_LAST + 2, sizeof(xprof_stats_node));
+
+    xprof_Timers[XPROF_PROF_UNACCOUNTED]->name = "PROF_UNACCOUNTED";
+    xprof_Timers[XPROF_PROF_UNACCOUNTED]->accu.start = get_tick();
+    xp_UNACCOUNTED = &xprof_Timers[XPROF_PROF_UNACCOUNTED]->accu;
+    xprof_inited = 1;
+}
+
+void
+xprof_start(xprof_type type, const char *timer)
+{
+    if (!xprof_inited)
+	xprof_InitLib();
+
+    xprof_Timers[type]->accu.start = get_tick();
+    xprof_Timers[type]->name = timer;
+
+    if (xprof_nesting++)
+	return;
+    xp_UNACCOUNTED->stop = xprof_Timers[type]->accu.start;
+    xprof_update(xp_UNACCOUNTED);
+}
+
+void
+xprof_stop(xprof_type type, const char *timer)
+{
+    xprof_Timers[type]->accu.stop = get_tick();
+    xprof_update(&xprof_Timers[type]->accu);
+    if (--xprof_nesting)
+	return;
+    xp_UNACCOUNTED->start = xprof_Timers[type]->accu.stop;
+    xprof_nesting = 0;
+}
+
+#endif /* USE_XPROF_STATS */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: hash.c,v 1.12 2001/03/07 17:57:37 wessels Exp $
+ * $Id: hash.c,v 1.13 2002/10/02 11:06:30 robertc Exp $
  *
  * DEBUG: section 0     Hash Tables
  * AUTHOR: Harvest Derived
@@ -61,6 +61,7 @@
 
 #include "hash.h"
 #include "util.h"
+#include "profiling.h"
 
 static void hash_next_bucket(hash_table * hid);
 
@@ -183,13 +184,17 @@ hash_lookup(hash_table * hid, const void *k)
 {
     hash_link *walker;
     int b;
+    PROF_start(hash_lookup);
     assert(k != NULL);
     b = hid->hash(k, hid->size);
     for (walker = hid->buckets[b]; walker != NULL; walker = walker->next) {
-	if ((hid->cmp) (k, walker->key) == 0)
+	if ((hid->cmp) (k, walker->key) == 0) {
+	    PROF_stop(hash_lookup);
 	    return (walker);
+	}
 	assert(walker != walker->next);
     }
+    PROF_stop(hash_lookup);
     return NULL;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: util.c,v 1.86 2002/08/12 01:21:06 hno Exp $
+ * $Id: util.c,v 1.87 2002/10/02 11:06:30 robertc Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -36,6 +36,7 @@
 #define _etext etext
 
 #include "config.h"
+#include "profiling.h"
 
 #if HAVE_STDIO_H
 #include <stdio.h>
@@ -427,10 +428,14 @@ xmalloc(size_t sz)
 {
     void *p;
 
+    PROF_start(xmalloc);
     if (sz < 1)
 	sz = 1;
 
-    if ((p = malloc(sz)) == NULL) {
+    PROF_start(malloc);
+    p = malloc(sz);
+    PROF_stop(malloc);
+    if (p == NULL) {
 	if (failure_notify) {
 	    snprintf(msg, 128, "xmalloc: Unable to allocate %d bytes!\n",
 		(int) sz);
@@ -453,6 +458,7 @@ xmalloc(size_t sz)
     if (tracefp)
 	fprintf(tracefp, "m:%d:%p\n", sz, p);
 #endif
+    PROF_stop(xmalloc);
     return (p);
 }
 
@@ -462,6 +468,7 @@ xmalloc(size_t sz)
 void
 xfree(void *s)
 {
+    PROF_start(xfree);
 #if XMALLOC_TRACE
     xmalloc_show_trace(s, -1);
 #endif
@@ -476,13 +483,15 @@ xfree(void *s)
     if (tracefp && s)
 	fprintf(tracefp, "f:%p\n", s);
 #endif
+    PROF_stop(xfree);
 }
 
 /* xxfree() - like xfree(), but we already know s != NULL */
 void
 xxfree(const void *s_const)
 {
-    void *s = (void *) s_const;
+    void *s = (void *)s_const;
+    PROF_start(xxfree);
 #if XMALLOC_TRACE
     xmalloc_show_trace(s, -1);
 #endif
@@ -494,6 +503,7 @@ xxfree(const void *s_const)
     if (tracefp && s)
 	fprintf(tracefp, "f:%p\n", s);
 #endif
+    PROF_stop(xxfree);
 }
 
 /*
@@ -505,6 +515,7 @@ xrealloc(void *s, size_t sz)
 {
     void *p;
 
+    PROF_start(xrealloc);
 #if XMALLOC_TRACE
     xmalloc_show_trace(s, -1);
 #endif
@@ -538,6 +549,7 @@ xrealloc(void *s, size_t sz)
     if (tracefp)		/* new ptr, old ptr, new size */
 	fprintf(tracefp, "r:%p:%p:%d\n", p, s, sz);
 #endif
+    PROF_stop(xrealloc);
     return (p);
 }
 
@@ -550,11 +562,15 @@ xcalloc(size_t n, size_t sz)
 {
     void *p;
 
+    PROF_start(xcalloc);
     if (n < 1)
 	n = 1;
     if (sz < 1)
 	sz = 1;
-    if ((p = calloc(n, sz)) == NULL) {
+    PROF_start(calloc);
+    p = calloc(n, sz);
+    PROF_stop(calloc);
+    if (p == NULL) {
 	if (failure_notify) {
 	    snprintf(msg, 128, "xcalloc: Unable to allocate %u blocks of %u bytes!\n",
 		(unsigned int) n, (unsigned int) sz);
@@ -577,6 +593,7 @@ xcalloc(size_t n, size_t sz)
     if (tracefp)
 	fprintf(tracefp, "c:%u:%u:%p\n", (unsigned int) n, (unsigned int) sz, p);
 #endif
+    PROF_stop(xcalloc);
     return (p);
 }
 
@@ -588,6 +605,8 @@ char *
 xstrdup(const char *s)
 {
     size_t sz;
+    void *p;
+    PROF_start(xstrdup);
     if (s == NULL) {
 	if (failure_notify) {
 	    (*failure_notify) ("xstrdup: tried to dup a NULL pointer!\n");
@@ -598,7 +617,9 @@ xstrdup(const char *s)
     }
     /* copy string, including terminating character */
     sz = strlen(s) + 1;
-    return memcpy(xmalloc(sz), s, sz);
+    p = memcpy(xmalloc(sz), s, sz);
+    PROF_stop(xstrdup);
+    return p;
 }
 
 /*
@@ -608,12 +629,16 @@ char *
 xstrndup(const char *s, size_t n)
 {
     size_t sz;
+    void *p;
+    PROF_start(xstrndup);
     assert(s);
     assert(n);
     sz = strlen(s) + 1;
     if (sz > n)
 	sz = n;
-    return xstrncpy(xmalloc(sz), s, sz);
+    p = xstrncpy(xmalloc(sz), s, sz);
+    PROF_stop(xstrndup);
+    return p;
 }
 
 /*
@@ -674,12 +699,14 @@ char *
 xstrncpy(char *dst, const char *src, size_t n)
 {
     char *r = dst;
+    PROF_start(xstrncpy);
     if (!n || !dst)
 	return dst;
     if (src)
 	while (--n != 0 && *src != '\0')
 	    *dst++ = *src++;
     *dst = '\0';
+    PROF_stop(xstrncpy);
     return r;
 }
 
@@ -688,12 +715,14 @@ size_t
 xcountws(const char *str)
 {
     size_t count = 0;
+    PROF_start(xcountws);
     if (str) {
 	while (xisspace(*str)) {
 	    str++;
 	    count++;
 	}
     }
+    PROF_stop(xcountws);
     return count;
 }
 
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.33 2002/09/29 12:55:52 hno Exp $
+#  $Id: Makefile.am,v 1.34 2002/10/02 11:06:31 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -26,6 +26,12 @@ else
 DELAY_POOL_SOURCE = 
 endif
 
+if ENABLE_XPROF_STATS
+XPROF_STATS_SOURCE = ProfStats.c
+else
+XPROF_STATS_SOURCE = 
+endif
+
 if ENABLE_HTCP
 HTCPSOURCE = htcp.c
 endif
@@ -178,6 +184,7 @@ squid_SOURCES = \
 	neighbors.c \
 	net_db.c \
 	Packer.c \
+	$(XPROF_STATS_SOURCE) \
 	pconn.c \
 	peer_digest.c \
 	peer_select.c \
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.247 2002/09/30 00:23:55 hno Exp $
+#  $Id: Makefile.in,v 1.248 2002/10/02 11:06:31 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -132,6 +132,9 @@ makesnmplib = @makesnmplib@
 @USE_DELAY_POOLS_TRUE@DELAY_POOL_SOURCE = delay_pools.c
 @USE_DELAY_POOLS_FALSE@DELAY_POOL_SOURCE = 
 
+@ENABLE_XPROF_STATS_TRUE@XPROF_STATS_SOURCE = ProfStats.c
+@ENABLE_XPROF_STATS_FALSE@XPROF_STATS_SOURCE = 
+
 @ENABLE_HTCP_TRUE@HTCPSOURCE = htcp.c
 
 @MAKE_LEAKFINDER_TRUE@LEAKFINDERSOURCE = leakfinder.c
@@ -272,6 +275,7 @@ squid_SOURCES = \
 	neighbors.c \
 	net_db.c \
 	Packer.c \
+	$(XPROF_STATS_SOURCE) \
 	pconn.c \
 	peer_digest.c \
 	peer_select.c \
@@ -467,56 +471,58 @@ pinger_OBJECTS = $(am_pinger_OBJECTS) $(nodist_pinger_OBJECTS)
 pinger_LDADD = $(LDADD)
 pinger_DEPENDENCIES =
 pinger_LDFLAGS =
-@USE_DELAY_POOLS_FALSE@am__objects_3 =
-@USE_DELAY_POOLS_TRUE@am__objects_3 = delay_pools.$(OBJEXT)
-@USE_DNSSERVER_FALSE@am__objects_4 = dns_internal.$(OBJEXT)
-@USE_DNSSERVER_TRUE@am__objects_4 = dns.$(OBJEXT)
-@ENABLE_HTCP_TRUE@am__objects_5 = htcp.$(OBJEXT)
-@MAKE_LEAKFINDER_TRUE@am__objects_6 = leakfinder.$(OBJEXT)
-@MAKE_LEAKFINDER_FALSE@am__objects_6 =
-@USE_SNMP_TRUE@am__objects_7 = snmp_core.$(OBJEXT) snmp_agent.$(OBJEXT)
-@USE_SNMP_FALSE@am__objects_7 =
-@ENABLE_SSL_FALSE@am__objects_8 =
-@ENABLE_SSL_TRUE@am__objects_8 = ssl_support.$(OBJEXT)
-@ENABLE_UNLINKD_TRUE@am__objects_9 = unlinkd.$(OBJEXT)
-@ENABLE_UNLINKD_FALSE@am__objects_9 =
-@ENABLE_WIN32SPECIFIC_FALSE@am__objects_10 =
-@ENABLE_WIN32SPECIFIC_TRUE@am__objects_10 = win32.$(OBJEXT)
+@USE_DELAY_POOLS_FALSE@am__objects_4 =
+@USE_DELAY_POOLS_TRUE@am__objects_4 = delay_pools.$(OBJEXT)
+@USE_DNSSERVER_FALSE@am__objects_5 = dns_internal.$(OBJEXT)
+@USE_DNSSERVER_TRUE@am__objects_5 = dns.$(OBJEXT)
+@ENABLE_HTCP_TRUE@am__objects_6 = htcp.$(OBJEXT)
+@MAKE_LEAKFINDER_TRUE@am__objects_7 = leakfinder.$(OBJEXT)
+@MAKE_LEAKFINDER_FALSE@am__objects_7 =
+@ENABLE_XPROF_STATS_TRUE@am__objects_3 = ProfStats.$(OBJEXT)
+@ENABLE_XPROF_STATS_FALSE@am__objects_3 =
+@USE_SNMP_TRUE@am__objects_8 = snmp_core.$(OBJEXT) snmp_agent.$(OBJEXT)
+@USE_SNMP_FALSE@am__objects_8 =
+@ENABLE_SSL_FALSE@am__objects_9 =
+@ENABLE_SSL_TRUE@am__objects_9 = ssl_support.$(OBJEXT)
+@ENABLE_UNLINKD_TRUE@am__objects_10 = unlinkd.$(OBJEXT)
+@ENABLE_UNLINKD_FALSE@am__objects_10 =
+@ENABLE_WIN32SPECIFIC_FALSE@am__objects_11 =
+@ENABLE_WIN32SPECIFIC_TRUE@am__objects_11 = win32.$(OBJEXT)
 am_squid_OBJECTS = access_log.$(OBJEXT) acl.$(OBJEXT) asn.$(OBJEXT) \
 	authenticate.$(OBJEXT) cache_cf.$(OBJEXT) CacheDigest.$(OBJEXT) \
 	cache_manager.$(OBJEXT) carp.$(OBJEXT) cbdata.$(OBJEXT) \
 	client_db.$(OBJEXT) client_side.$(OBJEXT) \
 	client_side_reply.$(OBJEXT) client_side_request.$(OBJEXT) \
 	clientStream.$(OBJEXT) comm.$(OBJEXT) comm_select.$(OBJEXT) \
 	comm_poll.$(OBJEXT) comm_kqueue.$(OBJEXT) debug.$(OBJEXT) \
-	$(am__objects_3) disk.$(OBJEXT) $(am__objects_4) \
+	$(am__objects_4) disk.$(OBJEXT) $(am__objects_5) \
 	errorpage.$(OBJEXT) ETag.$(OBJEXT) event.$(OBJEXT) \
 	external_acl.$(OBJEXT) fd.$(OBJEXT) filemap.$(OBJEXT) \
 	forward.$(OBJEXT) fqdncache.$(OBJEXT) ftp.$(OBJEXT) \
-	gopher.$(OBJEXT) helper.$(OBJEXT) $(am__objects_5) \
+	gopher.$(OBJEXT) helper.$(OBJEXT) $(am__objects_6) \
 	http.$(OBJEXT) HttpStatusLine.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrRange.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
 	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
 	HttpBody.$(OBJEXT) HttpMsg.$(OBJEXT) HttpReply.$(OBJEXT) \
 	HttpRequest.$(OBJEXT) icmp.$(OBJEXT) icp_v2.$(OBJEXT) \
 	icp_v3.$(OBJEXT) ident.$(OBJEXT) internal.$(OBJEXT) \
 	ipc.$(OBJEXT) ipcache.$(OBJEXT) IPInterception.$(OBJEXT) \
-	$(am__objects_6) logfile.$(OBJEXT) main.$(OBJEXT) mem.$(OBJEXT) \
+	$(am__objects_7) logfile.$(OBJEXT) main.$(OBJEXT) mem.$(OBJEXT) \
 	MemBuf.$(OBJEXT) mime.$(OBJEXT) multicast.$(OBJEXT) \
 	neighbors.$(OBJEXT) net_db.$(OBJEXT) Packer.$(OBJEXT) \
-	pconn.$(OBJEXT) peer_digest.$(OBJEXT) peer_select.$(OBJEXT) \
-	redirect.$(OBJEXT) referer.$(OBJEXT) refresh.$(OBJEXT) \
-	send-announce.$(OBJEXT) $(am__objects_7) ssl.$(OBJEXT) \
-	$(am__objects_8) stat.$(OBJEXT) StatHist.$(OBJEXT) \
-	String.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
-	store_io.$(OBJEXT) store_client.$(OBJEXT) \
+	$(am__objects_3) pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
+	peer_select.$(OBJEXT) redirect.$(OBJEXT) referer.$(OBJEXT) \
+	refresh.$(OBJEXT) send-announce.$(OBJEXT) $(am__objects_8) \
+	ssl.$(OBJEXT) $(am__objects_9) stat.$(OBJEXT) \
+	StatHist.$(OBJEXT) String.$(OBJEXT) stmem.$(OBJEXT) \
+	store.$(OBJEXT) store_io.$(OBJEXT) store_client.$(OBJEXT) \
 	store_digest.$(OBJEXT) store_dir.$(OBJEXT) \
 	store_key_md5.$(OBJEXT) store_log.$(OBJEXT) \
 	store_rebuild.$(OBJEXT) store_swapin.$(OBJEXT) \
 	store_swapmeta.$(OBJEXT) store_swapout.$(OBJEXT) \
-	tools.$(OBJEXT) $(am__objects_9) url.$(OBJEXT) urn.$(OBJEXT) \
+	tools.$(OBJEXT) $(am__objects_10) url.$(OBJEXT) urn.$(OBJEXT) \
 	useragent.$(OBJEXT) wais.$(OBJEXT) wccp.$(OBJEXT) \
-	whois.$(OBJEXT) $(am__objects_10)
+	whois.$(OBJEXT) $(am__objects_11)
 nodist_squid_OBJECTS = repl_modules.$(OBJEXT) auth_modules.$(OBJEXT) \
 	store_modules.$(OBJEXT) globals.$(OBJEXT) \
 	string_arrays.$(OBJEXT)
@@ -544,15 +550,16 @@ depcomp = $(SHELL) $(top_srcdir)/cfgaux/depcomp
 @AMDEP_TRUE@	$(DEPDIR)/HttpReply.Po $(DEPDIR)/HttpRequest.Po \
 @AMDEP_TRUE@	$(DEPDIR)/HttpStatusLine.Po \
 @AMDEP_TRUE@	$(DEPDIR)/IPInterception.Po $(DEPDIR)/MemBuf.Po \
-@AMDEP_TRUE@	$(DEPDIR)/Packer.Po $(DEPDIR)/StatHist.Po \
-@AMDEP_TRUE@	$(DEPDIR)/String.Po $(DEPDIR)/access_log.Po \
-@AMDEP_TRUE@	$(DEPDIR)/acl.Po $(DEPDIR)/asn.Po \
-@AMDEP_TRUE@	$(DEPDIR)/auth_modules.Po $(DEPDIR)/authenticate.Po \
-@AMDEP_TRUE@	$(DEPDIR)/cache_cf.Po $(DEPDIR)/cache_manager.Po \
-@AMDEP_TRUE@	$(DEPDIR)/cachemgr.Po $(DEPDIR)/carp.Po \
-@AMDEP_TRUE@	$(DEPDIR)/cbdata.Po $(DEPDIR)/cf_gen.Po \
-@AMDEP_TRUE@	$(DEPDIR)/client.Po $(DEPDIR)/clientStream.Po \
-@AMDEP_TRUE@	$(DEPDIR)/client_db.Po $(DEPDIR)/client_side.Po \
+@AMDEP_TRUE@	$(DEPDIR)/Packer.Po $(DEPDIR)/ProfStats.Po \
+@AMDEP_TRUE@	$(DEPDIR)/StatHist.Po $(DEPDIR)/String.Po \
+@AMDEP_TRUE@	$(DEPDIR)/access_log.Po $(DEPDIR)/acl.Po \
+@AMDEP_TRUE@	$(DEPDIR)/asn.Po $(DEPDIR)/auth_modules.Po \
+@AMDEP_TRUE@	$(DEPDIR)/authenticate.Po $(DEPDIR)/cache_cf.Po \
+@AMDEP_TRUE@	$(DEPDIR)/cache_manager.Po $(DEPDIR)/cachemgr.Po \
+@AMDEP_TRUE@	$(DEPDIR)/carp.Po $(DEPDIR)/cbdata.Po \
+@AMDEP_TRUE@	$(DEPDIR)/cf_gen.Po $(DEPDIR)/client.Po \
+@AMDEP_TRUE@	$(DEPDIR)/clientStream.Po $(DEPDIR)/client_db.Po \
+@AMDEP_TRUE@	$(DEPDIR)/client_side.Po \
 @AMDEP_TRUE@	$(DEPDIR)/client_side_reply.Po \
 @AMDEP_TRUE@	$(DEPDIR)/client_side_request.Po $(DEPDIR)/comm.Po \
 @AMDEP_TRUE@	$(DEPDIR)/comm_kqueue.Po $(DEPDIR)/comm_poll.Po \
@@ -742,6 +749,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/IPInterception.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/MemBuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/Packer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ProfStats.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/StatHist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/String.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/access_log.Po@am__quote@
@@ -0,0 +1,293 @@
+
+/*
+ * $Id: ProfStats.cc,v 1.1 2002/10/02 11:06:31 robertc Exp $
+ *
+ * DEBUG: section 81     CPU Profiling Routines
+ * AUTHOR: Andres Kroonmaa
+ *
+ * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from the
+ *  Internet community.  Development is led by Duane Wessels of the
+ *  National Laboratory for Applied Network Research and funded by the
+ *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
+ *  the Regents of the University of California.  Please see the
+ *  COPYRIGHT file for full details.  Squid incorporates software
+ *  developed and/or copyrighted by other sources.  Please see the
+ *  CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+
+#ifdef USE_XPROF_STATS
+
+/* Private stuff */
+
+#define MAX_SORTLIST 200
+
+static hrtime_t xprof_delta = 0;
+static hrtime_t xprof_start_t = 0;
+static hrtime_t xprof_verystart = 0;
+static hrtime_t xprof_average_delta = 0;
+static int xprof_events = 0;
+static int xprof_inited = 0;
+static xprof_stats_data Totals;
+
+static TimersArray *xprof_stats_avg1sec = NULL;
+static TimersArray *xprof_stats_avg5sec = NULL;
+static TimersArray *xprof_stats_avg30sec = NULL;
+static TimersArray *xprof_stats_avg1min = NULL;
+static TimersArray *xprof_stats_avg5min = NULL;
+static TimersArray *xprof_stats_avg30min = NULL;
+static TimersArray *xprof_stats_avg1hour = NULL;
+static TimersArray *xprof_stats_avg5hour = NULL;
+static TimersArray *xprof_stats_avg24hour = NULL;
+
+static xprof_stats_node *sortlist[XPROF_LAST + 2];
+
+static void
+xprof_reset(xprof_stats_data * head)
+{
+    head->summ = 0;
+    head->count = 0;
+    head->delta = 0;
+    head->best = XP_NOBEST;
+    head->worst = 0;
+    head->start = 0;
+    head->stop = 0;
+}
+
+static void
+xprof_move(xprof_stats_data * head, xprof_stats_data * hist)
+{
+    memcpy(hist, head, sizeof(xprof_stats_data));
+}
+
+static int
+xprof_comp(xprof_stats_node ** ii, xprof_stats_node ** jj)
+{
+    if ((*ii)->hist.summ < (*jj)->hist.summ)
+	return (1);
+    if ((*ii)->hist.summ > (*jj)->hist.summ)
+	return (-1);
+
+    return (0);
+}
+
+static void
+xprof_sorthist(TimersArray * xprof_list)
+{
+    int i;
+
+    for (i = 0; i < XPROF_LAST; i++) {
+	sortlist[i] = xprof_list[i];
+    }
+    qsort(&sortlist[XPROF_hash_lookup], XPROF_LAST - XPROF_hash_lookup, sizeof(xprof_stats_node *), (QS *) xprof_comp);
+}
+
+static double time_frame;
+
+static void
+xprof_show_item(StoreEntry * sentry, const char *name, xprof_stats_data * hist)
+{
+    storeAppendPrintf(sentry,
+	"%s\t %llu\t %llu\t %llu\t %llu\t %llu\t %.2f\t %6.3f\t\n",
+	name,
+	hist->count,
+	hist->summ,
+	(hist->best != XP_NOBEST ? hist->best : 0),
+	hist->count ? hist->summ / hist->count : 0,
+	hist->worst,
+	hist->count / time_frame,
+	dpercent((double) hist->summ, (double) hist->delta));
+}
+
+static void
+xprof_summary_item(StoreEntry * sentry, char *descr, TimersArray * list)
+{
+    int i;
+    xprof_stats_node **hist;
+    xprof_stats_data *show;
+    xprof_reset(&Totals);
+    xprof_sorthist(list);
+    hist = &sortlist[0];
+
+    show = &hist[0]->hist;
+    if (!hist[0]->hist.delta)
+	show = &hist[0]->accu;
+
+    time_frame = (double) show->delta / (double) xprof_average_delta;
+
+    storeAppendPrintf(sentry, "\n%s:", descr);
+    storeAppendPrintf(sentry, " (Cumulated time: %llu, %.2f sec)\n",
+	show->delta,
+	time_frame
+	);
+    storeAppendPrintf(sentry,
+	"Probe Name\t  Events\t cumulated time \t best case \t average \t worst case\t Rate / sec \t %% in int\n");
+
+    for (i = 0; i < XPROF_LAST; i++) {
+	if (!hist[i]->name)
+	    continue;
+
+	show = &hist[i]->hist;
+	if (!show->count)
+	    continue;
+	xprof_show_item(sentry, hist[i]->name, show);
+
+	Totals.count += show->count;
+	Totals.summ += show->summ;
+	Totals.best += (show->best != XP_NOBEST ? show->best : 0);
+	Totals.worst += show->worst;
+	Totals.delta = (show->delta > Totals.delta ? show->delta : Totals.delta);
+    }
+    xprof_show_item(sentry, "TOTALS", &Totals);
+}
+
+static void
+xprof_average(TimersArray ** list, int secs)
+{
+    int i;
+    TimersArray *head = xprof_Timers;
+    TimersArray *hist;
+    hrtime_t now;
+    hrtime_t keep;
+    int doavg = (xprof_events % secs);
+
+    if (!*list)
+	*list = xcalloc(XPROF_LAST, sizeof(xprof_stats_node));
+
+    hist = *list;
+    now = get_tick();
+
+    for (i = 0; i < XPROF_LAST; i++) {
+	hist[i]->name = head[i]->name;
+	hist[i]->accu.summ += head[i]->accu.summ;
+	hist[i]->accu.count += head[i]->accu.count;	/* accumulate multisec */
+
+	if (!hist[i]->accu.best)
+	    hist[i]->accu.best = head[i]->accu.best;
+
+	if (hist[i]->accu.best > head[i]->accu.best)
+	    hist[i]->accu.best = head[i]->accu.best;
+
+	if (hist[i]->accu.worst < head[i]->accu.worst)
+	    hist[i]->accu.worst = head[i]->accu.worst;
+
+	hist[i]->accu.delta += xprof_delta;
+	if (!doavg) {
+	    /* we have X seconds accumulated */
+	    xprof_move(&hist[i]->accu, &hist[i]->hist);
+	    xprof_reset(&hist[i]->accu);
+
+	    hist[i]->accu.start = now;
+	}
+	/* reset 0sec counters */
+	if (secs == 1) {
+	    keep = head[i]->accu.start;
+	    xprof_move(&head[i]->accu, &head[i]->hist);
+	    xprof_reset(&head[i]->accu);
+	    hist[i]->accu.delta = 0;
+	    head[i]->accu.start = keep;
+	}
+    }
+}
+
+void
+xprof_summary(StoreEntry * sentry)
+{
+    hrtime_t now = get_tick();
+
+    storeAppendPrintf(sentry, "CPU Profiling Statistics:\n");
+    storeAppendPrintf(sentry,
+	"  (CPU times are in arbitrary units, most probably in CPU clock ticks)\n");
+    storeAppendPrintf(sentry,
+	"Probe Name\t Event Count\t last Interval \t Avg Interval \t since squid start \t (since system boot) \n");
+    storeAppendPrintf(sentry, "Total\t %lu\t %llu \t %llu \t %llu \t %llu\n",
+	(long unsigned) xprof_events,
+	xprof_delta,
+	xprof_average_delta,
+	now - xprof_verystart,
+	now);
+
+    xprof_summary_item(sentry, "Last 1 sec averages", xprof_stats_avg1sec);
+    xprof_summary_item(sentry, "Last 5 sec averages", xprof_stats_avg5sec);
+    xprof_summary_item(sentry, "Last 30 sec averages", xprof_stats_avg30sec);
+    xprof_summary_item(sentry, "Last 1 min averages", xprof_stats_avg1min);
+    xprof_summary_item(sentry, "Last 5 min averages", xprof_stats_avg5min);
+    xprof_summary_item(sentry, "Last 30 min averages", xprof_stats_avg30min);
+    xprof_summary_item(sentry, "Last 1 hour averages", xprof_stats_avg1hour);
+    xprof_summary_item(sentry, "Last 5 hour averages", xprof_stats_avg5hour);
+    xprof_summary_item(sentry, "Last 24 hour averages", xprof_stats_avg24hour);
+}
+
+static inline void
+xprof_chk_overhead(int samples)
+{
+    while (samples--) {
+	PROF_start(PROF_OVERHEAD);
+	PROF_stop(PROF_OVERHEAD);
+    }
+}
+
+static hrtime_t now;
+static void
+xprof_Init(void)
+{
+    if (xprof_inited)
+	return;
+
+    xprof_delta = xprof_verystart = xprof_start_t = now;
+
+    xprof_inited = 1;
+    cachemgrRegister("cpu_profile", "CPU Profiling Stats", xprof_summary, 0, 1);
+}
+
+void
+xprof_event(void *data)
+{
+    now = get_tick();
+    xprof_Init();
+    xprof_delta = now - xprof_start_t;
+    xprof_start_t = now;
+    xprof_events++;
+
+    if (!xprof_average_delta)
+	xprof_average_delta = xprof_delta;
+    if (xprof_average_delta > (xprof_delta >> 1))
+	xprof_average_delta = xprof_average_delta - (xprof_average_delta >> 8) + (xprof_delta >> 8);
+
+    xprof_nesting++;
+    xprof_chk_overhead(2);
+    xprof_average(&xprof_stats_avg24hour, 24 * 3600);
+    xprof_average(&xprof_stats_avg5hour, 5 * 3600);
+    xprof_average(&xprof_stats_avg1hour, 3600);
+    xprof_average(&xprof_stats_avg30min, 1800);
+    xprof_average(&xprof_stats_avg5min, 300);
+    xprof_average(&xprof_stats_avg1min, 60);
+    xprof_average(&xprof_stats_avg30sec, 30);
+    xprof_average(&xprof_stats_avg5sec, 5);
+    xprof_average(&xprof_stats_avg1sec, 1);
+    xprof_chk_overhead(30);
+    xprof_nesting--;
+
+    eventAdd("cpuProfiling", xprof_event, NULL, 1.0, 1);
+}
+
+#endif /* USE_XPROF_STATS */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.286 2002/09/26 13:33:07 robertc Exp $
+ * $Id: acl.cc,v 1.287 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -1682,17 +1682,20 @@ aclMatchAcl(acl * ae, aclCheck_t * checklist)
 int
 aclMatchAclList(const acl_list * list, aclCheck_t * checklist)
 {
+    PROF_start(aclMatchAclList);
     while (list) {
 	AclMatchedName = list->_acl->name;
 	debug(28, 3) ("aclMatchAclList: checking %s%s\n",
 	    list->op ? null_string : "!", list->_acl->name);
 	if (aclMatchAcl(list->_acl, checklist) != list->op) {
 	    debug(28, 3) ("aclMatchAclList: returning 0\n");
+	    PROF_stop(aclMatchAclList);
 	    return 0;
 	}
 	list = list->next;
     }
     debug(28, 3) ("aclMatchAclList: returning 1\n");
+    PROF_stop(aclMatchAclList);
     return 1;
 }
 
@@ -1709,17 +1712,20 @@ int
 aclCheckFast(const acl_access * A, aclCheck_t * checklist)
 {
     allow_t allow = ACCESS_DENIED;
+    PROF_start(aclCheckFast);
     debug(28, 5) ("aclCheckFast: list: %p\n", A);
     while (A) {
 	allow = A->allow;
 	if (aclMatchAclList(A->aclList, checklist)) {
 	    aclCheckCleanup(checklist);
+	    PROF_stop(aclCheckFast);
 	    return allow == ACCESS_ALLOWED;
 	}
 	A = A->next;
     }
     debug(28, 5) ("aclCheckFast: no matches, returning: %d\n", allow == ACCESS_DENIED);
     aclCheckCleanup(checklist);
+    PROF_stop(aclCheckFast);
     return allow == ACCESS_DENIED;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.334 2002/09/15 06:40:57 robertc Exp $
+ * $Id: comm.cc,v 1.335 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -174,6 +174,7 @@ comm_openex(int sock_type,
     int tos = 0;
     fde *F = NULL;
 
+    PROF_start(comm_open);
     /* Create socket for accepting new connections. */
     statCounter.syscalls.sock.sockets++;
     if ((new_socket = socket(AF_INET, sock_type, proto)) < 0) {
@@ -189,6 +190,7 @@ comm_openex(int sock_type,
 	default:
 	    debug(50, 0) ("comm_open: socket failure: %s\n", xstrerror());
 	}
+	PROF_stop(comm_open);
 	return -1;
     }
     /* set TOS if needed */
@@ -221,19 +223,23 @@ comm_openex(int sock_type,
 	if (commBind(new_socket, addr, port) != COMM_OK) {
 	    comm_close(new_socket);
 	    return -1;
+	    PROF_stop(comm_open);
 	}
     }
     F->local_port = port;
 
     if (flags & COMM_NONBLOCKING)
-	if (commSetNonBlocking(new_socket) == COMM_ERROR)
+	if (commSetNonBlocking(new_socket) == COMM_ERROR) {
 	    return -1;
+	    PROF_stop(comm_open);
+	}
 #ifdef TCP_NODELAY
     if (sock_type == SOCK_STREAM)
 	commSetTcpNoDelay(new_socket);
 #endif
     if (Config.tcpRcvBufsz > 0 && sock_type == SOCK_STREAM)
 	commSetTcpRcvbuf(new_socket, Config.tcpRcvBufsz);
+    PROF_stop(comm_open);
     return new_socket;
 }
 
@@ -463,6 +469,7 @@ comm_connect_addr(int sock, const struct sockaddr_in *address)
     int err = 0;
     socklen_t errlen;
     assert(ntohs(address->sin_port) != 0);
+    PROF_start(comm_connect_addr);
     /* Establish connection. */
     errno = 0;
     if (!F->flags.called_connect) {
@@ -498,6 +505,7 @@ comm_connect_addr(int sock, const struct sockaddr_in *address)
 #endif
 #endif
     }
+    PROF_stop(comm_connect_addr);
     if (errno == 0 || errno == EISCONN)
 	status = COMM_OK;
     else if (ignoreErrno(errno))
@@ -527,7 +535,9 @@ comm_accept(int fd, struct sockaddr_in *pn, struct sockaddr_in *me)
     fde *F = NULL;
     Slen = sizeof(P);
     statCounter.syscalls.sock.accepts++;
+    PROF_start(comm_accept);
     if ((sock = accept(fd, (struct sockaddr *) &P, &Slen)) < 0) {
+	PROF_stop(comm_accept);
 	if (ignoreErrno(errno)) {
 	    debug(50, 5) ("comm_accept: FD %d: %s\n", fd, xstrerror());
 	    return COMM_NOMESSAGE;
@@ -554,6 +564,7 @@ comm_accept(int fd, struct sockaddr_in *pn, struct sockaddr_in *me)
     F->remote_port = htons(P.sin_port);
     F->local_port = htons(M.sin_port);
     commSetNonBlocking(sock);
+    PROF_stop(comm_accept);
     return sock;
 }
 
@@ -643,6 +654,7 @@ comm_close(int fd)
 	return;
     assert(F->flags.open);
     assert(F->type != FD_FILE);
+    PROF_start(comm_close);
     F->flags.closing = 1;
 #if USE_SSL
     if (F->ssl)
@@ -662,6 +674,7 @@ comm_close(int fd)
     fd_close(fd);		/* update fdstat */
     close(fd);
     statCounter.syscalls.sock.closes++;
+    PROF_stop(comm_close);
 }
 
 /* Send a udp datagram to specified TO_ADDR. */
@@ -673,8 +686,10 @@ comm_udp_sendto(int fd,
     int len)
 {
     int x;
+    PROF_start(comm_udp_sendto);
     statCounter.syscalls.sock.sendtos++;
     x = sendto(fd, buf, len, 0, (struct sockaddr *) to_addr, addr_len);
+    PROF_stop(comm_udp_sendto);
     if (x < 0) {
 #ifdef _SQUID_LINUX_
 	if (ECONNREFUSED != errno)
@@ -856,6 +871,7 @@ commHandleWrite(int fd, void *data)
     int len = 0;
     int nleft;
 
+    PROF_start(commHandleWrite);
     debug(5, 5) ("commHandleWrite: FD %d: off %ld, sz %ld.\n",
 	fd, (long int) state->offset, (long int) state->size);
 
@@ -904,6 +920,7 @@ commHandleWrite(int fd, void *data)
 	    CommWriteStateCallbackAndFree(fd, COMM_OK);
 	}
     }
+    PROF_stop(commHandleWrite);
 }
 
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_poll.cc,v 1.5 2002/09/15 06:40:57 robertc Exp $
+ * $Id: comm_poll.cc,v 1.6 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -208,6 +208,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
     PF *hdl = NULL;
     int npfds;
     struct pollfd pfds[3 + MAXHTTPPORTS];
+    PROF_start(comm_check_incoming);
     incoming_sockets_accepted = 0;
     for (i = npfds = 0; i < nfds; i++) {
 	int events;
@@ -224,12 +225,16 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
 	    npfds++;
 	}
     }
-    if (!nfds)
+    if (!nfds) {
+	PROF_stop(comm_check_incoming);
 	return -1;
+    }
     getCurrentTime();
     statCounter.syscalls.polls++;
-    if (poll(pfds, npfds, 0) < 1)
+    if (poll(pfds, npfds, 0) < 1) {
+	PROF_stop(comm_check_incoming);
 	return incoming_sockets_accepted;
+    }
     for (i = 0; i < npfds; i++) {
 	int revents;
 	if (((revents = pfds[i].revents) == 0) || ((fd = pfds[i].fd) == -1))
@@ -251,6 +256,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
 		    fd);
 	}
     }
+    PROF_stop(comm_check_incoming);
     return incoming_sockets_accepted;
 }
 
@@ -340,6 +346,7 @@ comm_select(int msec)
 	    comm_poll_dns_incoming();
 	if (commCheckHTTPIncoming)
 	    comm_poll_http_incoming();
+	PROF_start(comm_poll_prep_pfds);
 	callicp = calldns = callhttp = 0;
 	nfds = 0;
 	npending = 0;
@@ -376,6 +383,7 @@ comm_select(int msec)
 		    npending++;
 	    }
 	}
+	PROF_stop(comm_poll_prep_pfds);
 	if (nfds == 0) {
 	    assert(shutting_down);
 	    return COMM_SHUTDOWN;
@@ -385,9 +393,11 @@ comm_select(int msec)
 	if (msec > MAX_POLL_TIME)
 	    msec = MAX_POLL_TIME;
 	for (;;) {
+	    PROF_start(comm_poll_normal);
 	    statCounter.syscalls.polls++;
 	    num = poll(pfds, nfds, msec);
 	    statCounter.select_loops++;
+	    PROF_stop(comm_poll_normal);
 	    if (num >= 0 || npending >= 0)
 		break;
 	    if (ignoreErrno(errno))
@@ -409,6 +419,7 @@ comm_select(int msec)
 	/* scan each socket but the accept socket. Poll this 
 	 * more frequently to minimize losses due to the 5 connect 
 	 * limit in SunOS */
+	PROF_start(comm_handle_ready_fd);
 	for (i = 0; i < nfds; i++) {
 	    fde *F;
 	    int revents = pfds[i].revents;
@@ -441,8 +452,10 @@ comm_select(int msec)
 		    commAddSlowFd(fd);
 #endif
 		else {
+		    PROF_start(comm_read_handler);
 		    F->read_handler = NULL;
 		    hdl(fd, F->read_data);
+		    PROF_stop(comm_read_handler);
 		    statCounter.select_fds++;
 		    if (commCheckICPIncoming)
 			comm_poll_icp_incoming();
@@ -455,8 +468,10 @@ comm_select(int msec)
 	    if (revents & (POLLWRNORM | POLLOUT | POLLHUP | POLLERR)) {
 		debug(5, 5) ("comm_poll: FD %d ready for writing\n", fd);
 		if ((hdl = F->write_handler)) {
+		    PROF_start(comm_write_handler);
 		    F->write_handler = NULL;
 		    hdl(fd, F->write_data);
+		    PROF_stop(comm_write_handler);
 		    statCounter.select_fds++;
 		    if (commCheckICPIncoming)
 			comm_poll_icp_incoming();
@@ -491,6 +506,7 @@ comm_select(int msec)
 		    fd_close(fd);
 	    }
 	}
+	PROF_stop(comm_handle_ready_fd);
 	if (callicp)
 	    comm_poll_icp_incoming();
 	if (calldns)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_select.cc,v 1.59 2002/09/15 15:00:44 robertc Exp $
+ * $Id: comm_select.cc,v 1.60 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -203,7 +203,6 @@ commGetSlowFd(void)
 }
 #endif
 
-
 static int
 comm_check_incoming_select_handlers(int nfds, int *fds)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: disk.cc,v 1.160 2002/09/01 15:16:35 hno Exp $
+ * $Id: disk.cc,v 1.161 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -60,6 +60,7 @@ int
 file_open(const char *path, int mode)
 {
     int fd;
+    PROF_start(file_open);
     if (FILE_MODE(mode) == O_WRONLY)
 	mode |= O_APPEND;
     mode |= SQUID_NONBLOCK;
@@ -75,6 +76,7 @@ file_open(const char *path, int mode)
 	commSetCloseOnExec(fd);
 	fd_open(fd, FD_FILE, path);
     }
+    PROF_stop(file_open);
     return fd;
 }
 
@@ -85,6 +87,7 @@ file_close(int fd)
 {
     fde *F = &fd_table[fd];
     PF *read_callback;
+    PROF_start(file_close);
     assert(fd >= 0);
     assert(F->flags.open);
     if ((read_callback = F->read_handler)) {
@@ -102,6 +105,7 @@ file_close(int fd)
 #else
 	F->flags.close_request = 1;
 	debug(6, 2) ("file_close: FD %d, delaying close\n", fd);
+	PROF_stop(file_close);
 	return;
 #endif
     }
@@ -119,6 +123,7 @@ file_close(int fd)
 	("file_close: FD %d, really closing\n", fd);
     fd_close(fd);
     statCounter.syscalls.disk.closes++;
+    PROF_stop(file_close);
 }
 
 /*
@@ -182,6 +187,7 @@ diskHandleWrite(int fd, void *notused)
     int do_close;
     if (NULL == q)
 	return;
+    PROF_start(diskHandleWrite);
     debug(6, 3) ("diskHandleWrite: FD %d\n", fd);
     F->flags.write_daemon = 0;
     assert(fdd->write_q != NULL);
@@ -272,12 +278,14 @@ diskHandleWrite(int fd, void *notused)
 	     * NOTE, this callback can close the FD, so we must
 	     * not touch 'F', 'fdd', etc. after this.
 	     */
+	    PROF_stop(diskHandleWrite);
 	    return;
 	    /* XXX But what about close_request??? */
 	}
     }
     if (do_close)
 	file_close(fd);
+    PROF_stop(diskHandleWrite);
 }
 
 
@@ -295,6 +303,7 @@ file_write(int fd,
 {
     dwrite_q *wq = NULL;
     fde *F = &fd_table[fd];
+    PROF_start(file_write);
     assert(fd >= 0);
     assert(F->flags.open);
     /* if we got here. Caller is eligible to write. */
@@ -323,6 +332,7 @@ file_write(int fd,
     if (!F->flags.write_daemon) {
 	diskHandleWrite(fd, NULL);
     }
+    PROF_stop(file_write);
 }
 
 /*
@@ -351,6 +361,7 @@ diskHandleRead(int fd, void *data)
 	memFree(ctrl_dat, MEM_DREAD_CTRL);
 	return;
     }
+    PROF_start(diskHandleRead);
     if (F->disk.offset != ctrl_dat->offset) {
 	debug(6, 3) ("diskHandleRead: FD %d seeking to offset %d\n",
 	    fd, (int) ctrl_dat->offset);
@@ -367,6 +378,7 @@ diskHandleRead(int fd, void *data)
     if (len < 0) {
 	if (ignoreErrno(errno)) {
 	    commSetSelect(fd, COMM_SELECT_READ, diskHandleRead, ctrl_dat, 0);
+	    PROF_stop(diskHandleRead);
 	    return;
 	}
 	debug(50, 1) ("diskHandleRead: FD %d: %s\n", fd, xstrerror());
@@ -379,6 +391,7 @@ diskHandleRead(int fd, void *data)
 	ctrl_dat->handler(fd, ctrl_dat->buf, len, rc, ctrl_dat->client_data);
     cbdataReferenceDone(ctrl_dat->client_data);
     memFree(ctrl_dat, MEM_DREAD_CTRL);
+    PROF_stop(diskHandleRead);
 }
 
 
@@ -390,6 +403,7 @@ void
 file_read(int fd, char *buf, int req_len, off_t offset, DRCB * handler, void *client_data)
 {
     dread_ctrl *ctrl_dat;
+    PROF_start(file_read);
     assert(fd >= 0);
     ctrl_dat = memAllocate(MEM_DREAD_CTRL);
     ctrl_dat->fd = fd;
@@ -400,4 +414,5 @@ file_read(int fd, char *buf, int req_len, off_t offset, DRCB * handler, void *cl
     ctrl_dat->handler = handler;
     ctrl_dat->client_data = cbdataReference(client_data);
     diskHandleRead(fd, ctrl_dat);
+    PROF_stop(file_read);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.353 2002/07/28 21:55:33 hno Exp $
+ * $Id: main.cc,v 1.354 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -546,6 +546,9 @@ mainInitialize(void)
 	    eventAdd("start_announce", start_announce, NULL, 3600.0, 1);
 	eventAdd("ipcache_purgelru", ipcache_purgelru, NULL, 10.0, 1);
 	eventAdd("fqdncache_purgelru", fqdncache_purgelru, NULL, 15.0, 1);
+#if USE_XPROF_STATS
+	eventAdd("cpuProfiling", xprof_event, NULL, 1.0, 1);
+#endif
 	eventAdd("memPoolCleanIdlePools", memPoolCleanIdlePools, NULL, 15.0, 1);
     }
     configured_once = 1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.222 2002/09/01 15:16:35 hno Exp $
+ * $Id: squid.h,v 1.223 2002/10/02 11:06:31 robertc Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -396,12 +396,12 @@ struct rusage {
 #include "enums.h"
 #include "typedefs.h"
 #include "util.h"
+#include "profiling.h"
 #include "MemPool.h"
 #include "structs.h"
 #include "protos.h"
 #include "globals.h"
 
-
 #if !HAVE_TEMPNAM
 #include "tempnam.h"
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.546 2002/09/15 05:41:57 robertc Exp $
+ * $Id: store.cc,v 1.547 2002/10/02 11:06:31 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -316,8 +316,12 @@ storeUnlockObject(StoreEntry * e)
 StoreEntry *
 storeGet(const cache_key * key)
 {
+    void *p;
+    PROF_start(storeGet);
     debug(20, 3) ("storeGet: looking up %s\n", storeKeyText(key));
-    return (StoreEntry *) hash_lookup(store_table, key);
+    p = hash_lookup(store_table, key);
+    PROF_stop(storeGet);
+    return (StoreEntry *) p;
 }
 
 StoreEntry *
@@ -819,6 +823,7 @@ storeMaintainSwapSpace(void *datanotused)
     SwapDir *SD;
     static time_t last_warn_time = 0;
 
+    PROF_start(storeMaintainSwapSpace);
     /* walk each fs */
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
 	/* call the maintain function .. */
@@ -838,20 +843,23 @@ storeMaintainSwapSpace(void *datanotused)
     }
     /* Reregister a maintain event .. */
     eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0, 1);
+    PROF_stop(storeMaintainSwapSpace);
 }
 
 
 /* release an object from a cache */
 void
 storeRelease(StoreEntry * e)
 {
+    PROF_start(storeRelease);
     debug(20, 3) ("storeRelease: Releasing: '%s'\n", storeKeyText(e->hash.key));
     /* If, for any reason we can't discard this object because of an
      * outstanding request, mark it for pending release */
     if (storeEntryLocked(e)) {
 	storeExpireNow(e);
 	debug(20, 3) ("storeRelease: Only setting RELEASE_REQUEST bit\n");
 	storeReleaseRequest(e);
+	PROF_stop(storeRelease);
 	return;
     }
     if (store_dirs_rebuilding && e->swap_filen > -1) {
@@ -868,6 +876,7 @@ storeRelease(StoreEntry * e)
 	    e->lock_count++;
 	    EBIT_SET(e->flags, RELEASE_REQUEST);
 	    stackPush(&LateReleaseStack, e);
+	    PROF_stop(storeRelease);
 	    return;
 	} else {
 	    destroy_StoreEntry(e);
@@ -888,6 +897,7 @@ storeRelease(StoreEntry * e)
     }
     storeSetMemStatus(e, NOT_IN_MEMORY);
     destroy_StoreEntry(e);
+    PROF_stop(storeRelease);
 }
 
 static void