@@ -1,6 +1,6 @@
 
 /*
- * $Id: CacheDigest.cc,v 1.16 1998/04/24 06:08:15 wessels Exp $
+ * $Id: CacheDigest.cc,v 1.17 1998/04/24 07:09:26 wessels Exp $
  *
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -40,13 +40,13 @@ typedef struct {
 } CacheDigestStats;
 
 /* local functions */
-static void cacheDigestHashKey(const CacheDigest *cd, const cache_key *key);
+static void cacheDigestHashKey(const CacheDigest * cd, const cache_key * key);
 
 /* static array used by cacheDigestHashKey for optimization purposes */
 static u_num32 hashed_keys[4];
 
 static void
-cacheDigestInit(CacheDigest *cd, int capacity, int bpe)
+cacheDigestInit(CacheDigest * cd, int capacity, int bpe)
 {
     const size_t mask_size = cacheDigestCalcMaskSize(capacity, bpe);
     assert(cd);
@@ -56,15 +56,15 @@ cacheDigestInit(CacheDigest *cd, int capacity, int bpe)
     cd->bits_per_entry = bpe;
     cd->mask_size = mask_size;
     cd->mask = xcalloc(cd->mask_size, 1);
-    debug(70,2) ("cacheDigestInit: capacity: %d entries, pbe: %d; size: %d bytes\n",
+    debug(70, 2) ("cacheDigestInit: capacity: %d entries, pbe: %d; size: %d bytes\n",
 	cd->capacity, cd->bits_per_entry, cd->mask_size);
 }
 
 CacheDigest *
 cacheDigestCreate(int capacity, int bpe)
 {
     CacheDigest *cd = memAllocate(MEM_CACHE_DIGEST);
-    assert(MD5_DIGEST_CHARS == 16);  /* our hash functions rely on 16 byte keys */
+    assert(MD5_DIGEST_CHARS == 16);	/* our hash functions rely on 16 byte keys */
     cacheDigestInit(cd, capacity, bpe);
     return cd;
 }
@@ -217,7 +217,7 @@ cacheDigestBitUtil(const CacheDigest * cd)
 }
 
 void
-cacheDigestGuessStatsUpdate(cd_guess_stats *stats, int real_hit, int guess_hit)
+cacheDigestGuessStatsUpdate(cd_guess_stats * stats, int real_hit, int guess_hit)
 {
     assert(stats);
     if (real_hit) {
@@ -234,16 +234,16 @@ cacheDigestGuessStatsUpdate(cd_guess_stats *stats, int real_hit, int guess_hit)
 }
 
 void
-cacheDigestGuessStatsReport(const cd_guess_stats *stats, StoreEntry * sentry, const char *label)
+cacheDigestGuessStatsReport(const cd_guess_stats * stats, StoreEntry * sentry, const char *label)
 {
     const int true_count = stats->true_hits + stats->true_misses;
     const int false_count = stats->false_hits + stats->false_misses;
     const int hit_count = stats->true_hits + stats->false_hits;
     const int miss_count = stats->true_misses + stats->false_misses;
     const int tot_count = true_count + false_count;
-    
+
     assert(label);
-    assert(tot_count == hit_count + miss_count); /* paranoid */
+    assert(tot_count == hit_count + miss_count);	/* paranoid */
 
     storeAppendPrintf(sentry, "Digest guesses stats for %s:\n", label);
     storeAppendPrintf(sentry, "guess\t hit\t\t miss\t\t total\t\t\n");
@@ -266,7 +266,7 @@ cacheDigestGuessStatsReport(const cd_guess_stats *stats, StoreEntry * sentry, co
 }
 
 void
-cacheDigestReport(CacheDigest *cd, const char *label, StoreEntry * e)
+cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
 {
     CacheDigestStats stats;
     assert(cd && e);
@@ -300,7 +300,7 @@ cacheDigestCalcMaskSize(int cap, int bpe)
 }
 
 static void
-cacheDigestHashKey(const CacheDigest *cd, const cache_key *key)
+cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 {
     const int bit_count = cd->mask_size * 8;
     /* get four hashed values */
@@ -311,6 +311,6 @@ cacheDigestHashKey(const CacheDigest *cd, const cache_key *key)
     hashed_keys[2] %= bit_count;
     hashed_keys[3] %= bit_count;
 
-    debug(70,9) ("cacheDigestHashKey: %s -(%d)-> %d %d %d %d\n",
+    debug(70, 9) ("cacheDigestHashKey: %s -(%d)-> %d %d %d %d\n",
 	storeKeyText(key), bit_count, hashed_keys[0], hashed_keys[1], hashed_keys[2], hashed_keys[3]);
 }
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: HttpBody.cc,v 1.8 1998/04/09 23:51:40 rousskov Exp $
+ * $Id: HttpBody.cc,v 1.9 1998/04/24 07:09:27 wessels Exp $
  *
  * DEBUG: section 56    HTTP Message Body
  * AUTHOR: Alex Rousskov
@@ -73,7 +73,7 @@ httpBodySet(HttpBody * body, const char *buf, int size, FREE * freefunc)
 	freefunc = &xfree;
     } else {
 	/* @?@ @?@ Fix this cast: we should probably have two httpBodySet()s */
-	body->buf = (char*)buf;
+	body->buf = (char *) buf;
     }
     body->freefunc = freefunc;
     body->size = size;
@@ -1,5 +1,5 @@
 /*
- * $Id: HttpHeaderTools.cc,v 1.8 1998/04/06 22:32:08 wessels Exp $
+ * $Id: HttpHeaderTools.cc,v 1.9 1998/04/24 07:09:28 wessels Exp $
  *
  * DEBUG: section 66    HTTP Header Tools
  * AUTHOR: Alex Rousskov
@@ -185,7 +185,7 @@ httpHeaderParseSize(const char *start, size_t * value)
  * parses a given string then packs compiled headers and compares the result
  * with the original, reports discrepancies
  */
-void 
+void
 httpHeaderTestParser(const char *hstr)
 {
     static int bug_count = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StatHist.cc,v 1.6 1998/04/12 06:00:44 rousskov Exp $
+ * $Id: StatHist.cc,v 1.7 1998/04/24 07:09:28 wessels Exp $
  *
  * DEBUG: section 62    Generic Histogram
  * AUTHOR: Duane Wessels
@@ -228,6 +228,6 @@ void
 statHistIntDumper(StoreEntry * sentry, int idx, double val, double size, int count)
 {
     if (count)
-        storeAppendPrintf(sentry, "%2d\t %5d\t %5d\n",
-            idx, (int) val, count);
+	storeAppendPrintf(sentry, "%2d\t %5d\t %5d\n",
+	    idx, (int) val, count);
 }
@@ -1,6 +1,7 @@
 
+
 /*
- * $Id: client.cc,v 1.64 1998/04/06 22:32:12 wessels Exp $
+ * $Id: client.cc,v 1.65 1998/04/24 07:09:29 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.290 1998/04/24 06:08:16 wessels Exp $
+ * $Id: client_side.cc,v 1.291 1998/04/24 07:09:30 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -44,7 +44,7 @@ static CWCB clientWriteComplete;
 static PF clientReadRequest;
 static PF connStateFree;
 static PF requestTimeout;
-static void clientFinishIMS(clientHttpRequest *http);
+static void clientFinishIMS(clientHttpRequest * http);
 static STCB clientGetHeadersForIMS;
 static STCB clientGetHeadersForSpecialIMS;
 static int CheckQuickAbort2(const clientHttpRequest *);
@@ -585,8 +585,7 @@ clientUpdateCounters(clientHttpRequest * http)
 	if (sst)
 	    statHistCount(&Counter.icp.server_svc_time, sst);
 	Counter.icp.times_used++;
-    } else
-    if (H->alg == PEER_SA_DIGEST) {
+    } else if (H->alg == PEER_SA_DIGEST) {
 	statHistCount(&Counter.cd.client_svc_time, svc_time);
 	if (sst)
 	    statHistCount(&Counter.cd.server_svc_time, sst);
@@ -601,20 +600,20 @@ clientUpdateCounters(clientHttpRequest * http)
     if (http->flags.internal && strStr(http->request->urlpath, StoreDigestUrlPath)) {
 	kb_incr(&Counter.cd.kbytes_sent, http->out.size);
 	Counter.cd.msgs_sent++;
-	debug(33, 1) ("Client %s requested local cache digest (%d bytes)\n", 
+	debug(33, 1) ("Client %s requested local cache digest (%d bytes)\n",
 	    inet_ntoa(http->request->client_addr), http->out.size);
     }
     /* @?@ split this ugly if-monster */
-    if (/* we used ICP or CD for peer selecton */
+    if (			/* we used ICP or CD for peer selecton */
 	H->alg != PEER_SA_NONE &&
-	/* a successful CD lookup was made */
+    /* a successful CD lookup was made */
 	H->cd_lookup != LOOKUP_NONE &&
-	/* it was not a CD miss (we go direct on CD MISSes) */
+    /* it was not a CD miss (we go direct on CD MISSes) */
 	!(H->alg == PEER_SA_DIGEST && H->cd_lookup == LOOKUP_MISS) &&
-	/* request was cachable */
+    /* request was cachable */
 	!EBIT_TEST(http->request->flags, REQ_NOCACHE) &&
 	EBIT_TEST(http->request->flags, REQ_CACHABLE) &&
-	/* paranoid: we have a reply pointer */
+    /* paranoid: we have a reply pointer */
 	(reply = storeEntryReply(http->entry))) {
 
 	/* tmp, remove this later */
@@ -626,7 +625,7 @@ clientUpdateCounters(clientHttpRequest * http)
 	const int guess_hit = LOOKUP_HIT == H->cd_lookup;
 	peer *peer = peerFindByName(H->cd_host);
 
-	debug(33,3) ("clientUpdateCounters: peer %s real/guess: %d/%d (%d) for %s!\n",
+	debug(33, 3) ("clientUpdateCounters: peer %s real/guess: %d/%d (%d) for %s!\n",
 	    H->cd_host, real_hit, guess_hit, lookup_hit, http->request->host);
 	cacheDigestGuessStatsUpdate(&Counter.cd.guess, real_hit, guess_hit);
 	/* tmp hack */
@@ -642,7 +641,7 @@ clientUpdateCounters(clientHttpRequest * http)
 	    /* temporary paranoid debug @?@ */
 	    static int max_count = 200;
 	    if (max_count > 0) {
-		debug(33,1) ("clientUpdateCounters: lost peer %s for %s! (%d)\n", 
+		debug(33, 1) ("clientUpdateCounters: lost peer %s for %s! (%d)\n",
 		    H->cd_host, http->request->host, max_count);
 		max_count--;
 	    }
@@ -875,7 +874,7 @@ clientCachable(clientHttpRequest * http)
      * to indicate uncachable objects.
      */
     if (!aclCheckFast(Config.accessList.noCache, &ch))
-	    return 0;
+	return 0;
     if (Config.cache_stop_relist)
 	if (aclMatchRegex(Config.cache_stop_relist, url))
 	    return 0;
@@ -1277,7 +1276,7 @@ clientWriteComplete(int fd, char *bufnotused, size_t size, int errflag, void *da
 
 /* called when clientGetHeadersFor*IMS completes */
 static void
-clientFinishIMS(clientHttpRequest *http)
+clientFinishIMS(clientHttpRequest * http)
 {
     StoreEntry *entry = http->entry;
     MemBuf mb;
@@ -1597,8 +1596,8 @@ clientProcessRequest(clientHttpRequest * http)
 	    http->out.offset,
 	    SM_PAGE_SIZE,
 	    memAllocate(MEM_4K_BUF),
-	    (http->log_type == LOG_TCP_IMS_MISS) ? 
-		clientGetHeadersForIMS : clientGetHeadersForSpecialIMS,
+	    (http->log_type == LOG_TCP_IMS_MISS) ?
+	    clientGetHeadersForIMS : clientGetHeadersForSpecialIMS,
 	    http);
 	break;
     case LOG_TCP_REFRESH_MISS:
@@ -2012,8 +2011,8 @@ clientReadRequest(int fd, void *data)
 	    if (!http->flags.internal)
 		if (0 == strNCmp(request->urlpath, "/squid-internal/", 16))
 		    if (0 == strcasecmp(request->host, getMyHostname()))
-		        if (request->port == Config.Port.http->i)
-	                    http->flags.internal = 1;
+			if (request->port == Config.Port.http->i)
+			    http->flags.internal = 1;
 	    safe_free(http->log_uri);
 	    http->log_uri = xstrdup(urlCanonicalClean(request));
 	    request->client_addr = conn->peer.sin_addr;
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: comm.cc,v 1.251 1998/04/09 21:31:36 wessels Exp $
+ * $Id: comm.cc,v 1.252 1998/04/24 07:09:31 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -1480,4 +1480,5 @@ commSetConnectTimeout(int fd, time_t timeout)
     fde *F = &fd_table[fd];
     F->connect_timeout = timeout;
 }
+
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dnsserver.cc,v 1.48 1998/04/08 00:42:22 wessels Exp $
+ * $Id: dnsserver.cc,v 1.49 1998/04/24 07:09:32 wessels Exp $
  *
  * DEBUG: section 0     DNS Resolver
  * AUTHOR: Harvest Derived
@@ -363,7 +363,7 @@ main(int argc, char *argv[])
 	    }
 	    safe_inet_addr(optarg, &_res.nsaddr_list[_res.nscount++].sin_addr);
 #else
-        fprintf(stderr, "-s is not supported on this resolver\n");
+	    fprintf(stderr, "-s is not supported on this resolver\n");
 #endif /* HAVE_RES_INIT */
 	    break;
 	case 'v':
@@ -142,7 +142,7 @@ typedef enum {
 typedef enum {
     LOOKUP_NONE,
     LOOKUP_HIT,
-    LOOKUP_MISS  
+    LOOKUP_MISS
 } lookup_t;
 
 typedef enum {
@@ -217,7 +217,7 @@ typedef enum {
     HDR_WARNING,
     HDR_WWW_AUTHENTICATE,
     HDR_X_CACHE,
-    HDR_X_CACHE_LOOKUP, /* tmp hack, remove later */
+    HDR_X_CACHE_LOOKUP,		/* tmp hack, remove later */
     HDR_PROXY_CONNECTION,
     HDR_OTHER,
     HDR_ENUM_END
@@ -398,10 +398,10 @@ typedef enum {
 } http_status;
 
 enum {
-    PD_INITED,    /* initialized */
-    PD_USABLE,    /* ready to use */
-    PD_REQUESTED, /* we are in the process of receiving a [fresh] digest */
-    PD_DISABLED   /* do not use/validate the digest */
+    PD_INITED,			/* initialized */
+    PD_USABLE,			/* ready to use */
+    PD_REQUESTED,		/* we are in the process of receiving a [fresh] digest */
+    PD_DISABLED			/* do not use/validate the digest */
 } peer_cd_t;
 
 /* These are for StoreEntry->flag, which is defined as a SHORT */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.53 1998/04/22 16:21:24 rousskov Exp $
+ * $Id: globals.h,v 1.54 1998/04/24 07:09:33 wessels Exp $
  */
 
 extern FILE *debug_log;		/* NULL */
@@ -98,9 +98,8 @@ extern dlink_list store_list;
 extern const String StringNull;	/* { 0, 0, NULL } */
 extern int hot_obj_count;	/* 0 */
 extern int _db_level;
-extern const int CacheDigestHashFuncCount; /* 4 */
-extern CacheDigest *store_digest; /* NULL */
-extern const char *StoreDigestUrlPath; /* "store_digest" */
-extern const char *StoreDigestMimeStr; /* "application/cache-digest" */
-extern const Version CacheDigestVer; /* { 2, 2 } */
-
+extern const int CacheDigestHashFuncCount;	/* 4 */
+extern CacheDigest *store_digest;	/* NULL */
+extern const char *StoreDigestUrlPath;	/* "store_digest" */
+extern const char *StoreDigestMimeStr;	/* "application/cache-digest" */
+extern const Version CacheDigestVer;	/* { 2, 2 } */
@@ -1,6 +1,7 @@
 
+
 /*
- * $Id: gopher.cc,v 1.124 1998/03/27 22:44:21 wessels Exp $
+ * $Id: gopher.cc,v 1.125 1998/04/24 07:09:34 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.264 1998/04/24 05:05:12 wessels Exp $
+ * $Id: http.cc,v 1.265 1998/04/24 07:09:35 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -691,7 +691,7 @@ httpBuildRequestHeader(request_t * request,
 	snprintf(ybuf, YBUF_SZ, "Host: %s", orig_request->host);
 	if (orig_request->port != urlDefaultPort(orig_request->protocol)) {
 	    int l = strlen(ybuf);
-	    snprintf(ybuf+l, YBUF_SZ-l, ":%d", (int) orig_request->port);
+	    snprintf(ybuf + l, YBUF_SZ - l, ":%d", (int) orig_request->port);
 	}
 	httpAppendRequestHeader(hdr_out, ybuf, &len, out_sz, 1);
     }
@@ -469,9 +469,9 @@ icpCount(void *buf, int which, size_t len, int delay)
 	    Counter.icp.replies_sent++;
 	    kb_incr(&Counter.icp.r_kbytes_sent, len);
 	    /* this is the sent-reply service time */
-            statHistCount(&Counter.icp.reply_svc_time, delay);
+	    statHistCount(&Counter.icp.reply_svc_time, delay);
 	}
-        if (ICP_HIT == icp->opcode)
+	if (ICP_HIT == icp->opcode)
 	    Counter.icp.hits_sent++;
     } else if (RECV == which) {
 	Counter.icp.pkts_recv++;
@@ -484,7 +484,7 @@ icpCount(void *buf, int which, size_t len, int delay)
 	    kb_incr(&Counter.icp.r_kbytes_recv, len);
 	    /* Counter.icp.query_svc_time set in clientUpdateCounters */
 	}
-        if (ICP_HIT == icp->opcode)
+	if (ICP_HIT == icp->opcode)
 	    Counter.icp.hits_recv++;
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.181 1998/04/24 06:40:05 wessels Exp $
+ * $Id: ipcache.cc,v 1.182 1998/04/24 07:09:37 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -904,17 +904,17 @@ ipcacheCycleAddr(const char *name)
 #endif
 
 void
-ipcacheCycleAddr(const char *name, ipcache_addrs *ia)
+ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
 {
     ipcache_entry *i;
     unsigned char k;
     assert(name || ia);
     if (NULL == ia) {
-        if ((i = ipcache_get(name)) == NULL)
+	if ((i = ipcache_get(name)) == NULL)
 	    return;
-        if (i->status != IP_CACHED)
+	if (i->status != IP_CACHED)
 	    return;
-        ia = &i->addrs;
+	ia = &i->addrs;
     }
     for (k = 0; k < ia->count; k++) {
 	if (++ia->cur == ia->count)
@@ -923,15 +923,15 @@ ipcacheCycleAddr(const char *name, ipcache_addrs *ia)
 	    break;;
     }
     if (k == ia->count) {
-        /* All bad, reset to All good */
-        debug(14, 3)("ipcacheCycleAddr: Changing ALL %s addrs from BAD to OK\n",
+	/* All bad, reset to All good */
+	debug(14, 3) ("ipcacheCycleAddr: Changing ALL %s addrs from BAD to OK\n",
 	    name);
-        for (k = 0; k < ia->count; k++)
+	for (k = 0; k < ia->count; k++)
 	    ia->bad_mask[k] = 0;
-        ia->badcount = 0;
-        ia->cur = 0;
+	ia->badcount = 0;
+	ia->cur = 0;
     }
-    debug(14,3) ("ipcacheCycleAddr: %s now at %s\n", name,
+    debug(14, 3) ("ipcacheCycleAddr: %s now at %s\n", name,
 	inet_ntoa(ia->in_addrs[ia->cur]));
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.21 1998/04/07 23:43:04 rousskov Exp $
+ * $Id: mem.cc,v 1.22 1998/04/24 07:09:37 wessels Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -41,6 +41,7 @@ static const struct {
     const char *name;
     size_t obj_size;
 } StrPoolsAttrs[mem_str_pool_count] = {
+
     {
 	"Short Strings", 36,
     },				/* to fit rfc1123 and similar */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.62 1998/04/10 00:51:04 wessels Exp $
+ * $Id: mime.cc,v 1.63 1998/04/24 07:09:38 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -487,7 +487,7 @@ mimeLoadIconFile(const char *icon)
     const char *type = mimeGetContentType(icon);
     if (type == NULL)
 	fatal("Unknown icon format while reading mime.conf\n");
-    xstrncpy(url, urlInternal("icons",icon), MAX_URL);
+    xstrncpy(url, urlInternal("icons", icon), MAX_URL);
     key = storeKeyPublic(url, METHOD_GET);
     if (storeGet(key))
 	return;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.200 1998/04/24 06:08:18 wessels Exp $
+ * $Id: neighbors.cc,v 1.201 1998/04/24 07:09:39 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -549,24 +549,21 @@ neighborsUdpPing(request_t * request,
 
 /* lookup the digest of a given peer */
 lookup_t
-peerDigestLookup(peer *p, request_t * request, StoreEntry * entry)
+peerDigestLookup(peer * p, request_t * request, StoreEntry * entry)
 {
 #if USE_CACHE_DIGESTS
     const cache_key *key = request ? storeKeyPublic(storeUrl(entry), request->method) : NULL;
     assert(p);
     assert(request);
     debug(15, 5) ("neighborsDigestPeerLookup: peer %s\n", p->host);
- 	/* does the peeer have a valid digest? */
+    /* does the peeer have a valid digest? */
     if (EBIT_TEST(p->digest.flags, PD_DISABLED)) {
 	return LOOKUP_NONE;
-    } else
-    if (!peerAllowedToUse(p, request)) {
+    } else if (!peerAllowedToUse(p, request)) {
 	return LOOKUP_NONE;
-    } else
-    if (EBIT_TEST(p->digest.flags, PD_USABLE)) {
-	/* fall through; put here to have common case on top */;
-    } else
-    if (!EBIT_TEST(p->digest.flags, PD_INITED)) {
+    } else if (EBIT_TEST(p->digest.flags, PD_USABLE)) {
+	/* fall through; put here to have common case on top */ ;
+    } else if (!EBIT_TEST(p->digest.flags, PD_INITED)) {
 	peerDigestInit(p);
 	return LOOKUP_NONE;
     } else {
@@ -618,7 +615,7 @@ neighborsDigestSelect(request_t * request, StoreEntry * entry)
 	if (!best_p || (p_rtt && p_rtt < best_rtt)) {
 	    best_p = p;
 	    best_rtt = p_rtt;
-	    if (p_rtt) /* informative choice (aka educated guess) */
+	    if (p_rtt)		/* informative choice (aka educated guess) */
 		ichoice_count++;
 	    debug(15, 4) ("neighborsDigestSelect: peer %s leads with rtt %d\n",
 		p->host, best_rtt);
@@ -635,7 +632,7 @@ neighborsDigestSelect(request_t * request, StoreEntry * entry)
 }
 
 void
-peerNoteDigestLookup(request_t * request, peer *p, lookup_t lookup)
+peerNoteDigestLookup(request_t * request, peer * p, lookup_t lookup)
 {
 #if USE_CACHE_DIGESTS
     if (p)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.18 1998/04/24 06:08:19 wessels Exp $
+ * $Id: peer_digest.cc,v 1.19 1998/04/24 07:09:40 wessels Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -36,43 +36,43 @@
 /* local types */
 
 /* local prototypes */
-static void peerDigestClean(peer *p);
-static time_t peerDigestNextDisDelay(const peer *p);
-static time_t peerDigestExpiresDelay(const peer *p, const StoreEntry *e);
-static void peerDigestDisable(peer *p);
-static void peerDigestDelay(peer *p, int disable, time_t delay);
-static void peerDigestValidate(peer *p);
-static void peerDigestRequest(peer *p);
+static void peerDigestClean(peer * p);
+static time_t peerDigestNextDisDelay(const peer * p);
+static time_t peerDigestExpiresDelay(const peer * p, const StoreEntry * e);
+static void peerDigestDisable(peer * p);
+static void peerDigestDelay(peer * p, int disable, time_t delay);
+static void peerDigestValidate(peer * p);
+static void peerDigestRequest(peer * p);
 static void peerDigestFetchReply(void *data, char *buf, ssize_t size);
-static void peerDigestRequest(peer *p);
+static void peerDigestRequest(peer * p);
 static void peerDigestSwapInHeaders(void *data, char *buf, ssize_t size);
 static void peerDigestSwapInCBlock(void *data, char *buf, ssize_t size);
 static STCB peerDigestSwapInMask;
-static int peerDigestFetchedEnough(DigestFetchState *fetch, char *buf, ssize_t size, const char *step_name);
-static void peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg);
-static int peerDigestSetCBlock(peer *p, const char *buf);
-static int peerDigestUseful(const peer *peer);
+static int peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const char *step_name);
+static void peerDigestFetchFinish(DigestFetchState * fetch, char *buf, const char *err_msg);
+static int peerDigestSetCBlock(peer * p, const char *buf);
+static int peerDigestUseful(const peer * peer);
 #define max_delay(t1,t2) ((t1) >= (t2) ? (t1) : (t2))
 
 
 /* local constants */
 #define StoreDigestCBlockSize sizeof(StoreDigestCBlock)
 
 /* min interval for requesting digests from the same peer */
-static const time_t PeerDigestRequestMinGap   = 5 * 60; /* seconds */
+static const time_t PeerDigestRequestMinGap = 5 * 60;	/* seconds */
 /* min interval for requesting digests at start */
-static const time_t GlobalDigestRequestMinGap = 1 * 60; /* seconds */
+static const time_t GlobalDigestRequestMinGap = 1 * 60;		/* seconds */
 
 /* local vars */
 static time_t global_last_req_timestamp = 0;
 
-void 
-peerDigestInit(peer *p)
+void
+peerDigestInit(peer * p)
 {
     assert(p);
     assert(!p->digest.flags);
     assert(!p->digest.cd);
-    assert(SM_PAGE_SIZE == 4096); /* we use MEM_4K_BUF */
+    assert(SM_PAGE_SIZE == 4096);	/* we use MEM_4K_BUF */
     if (EBIT_TEST(p->options, NEIGHBOR_NO_DIGEST)) {
 	peerDigestDisable(p);
     } else {
@@ -83,11 +83,11 @@ peerDigestInit(peer *p)
 }
 
 /* no pending events or requests should exist when you call this */
-static void 
-peerDigestClean(peer *p)
+static void
+peerDigestClean(peer * p)
 {
     if (!cbdataValid(p))
-	debug(72, 2) ("peerDigest: note: peer '%s' was reset or deleted\n", 
+	debug(72, 2) ("peerDigest: note: peer '%s' was reset or deleted\n",
 	    p->host ? p->host : "<null>");
     assert(!EBIT_TEST(p->digest.flags, PD_REQUESTED));
     peerDigestDisable(p);
@@ -96,24 +96,24 @@ peerDigestClean(peer *p)
 
 /* disables peer for good */
 static void
-peerDigestDisable(peer *p)
+peerDigestDisable(peer * p)
 {
     peerDigestDelay(p, 1, -1);
 }
 
 /* next delay for a disabled entry */
 static time_t
-peerDigestNextDisDelay(const peer *p)
+peerDigestNextDisDelay(const peer * p)
 {
     assert(p);
     return p->digest.last_dis_delay ?
-	2 * p->digest.last_dis_delay : /* exponential backoff */
-	PeerDigestRequestMinGap;       /* minimal delay */
+	2 * p->digest.last_dis_delay :	/* exponential backoff */
+	PeerDigestRequestMinGap;	/* minimal delay */
 }
 
 /* artificially increases expires to avoid race conditions */
 static time_t
-peerDigestExpiresDelay(const peer *p, const StoreEntry *e)
+peerDigestExpiresDelay(const peer * p, const StoreEntry * e)
 {
     assert(p);
     if (!e)
@@ -126,7 +126,7 @@ peerDigestExpiresDelay(const peer *p, const StoreEntry *e)
 
 /* delays/disables digest for a psecified delay (disables forever if negative delay) */
 static void
-peerDigestDelay(peer *p, int disable, time_t delay)
+peerDigestDelay(peer * p, int disable, time_t delay)
 {
     assert(p);
     if (disable) {
@@ -137,9 +137,9 @@ peerDigestDelay(peer *p, int disable, time_t delay)
 	assert(delay || !disable);
 	debug(72, 2) ("peerDigestDelay: %s: peer %s for %d secs till %s\n",
 	    disable ? "disabling" : "delaying",
-	    p->host ? p->host : "<null>", 
+	    p->host ? p->host : "<null>",
 	    delay, mkrfc1123(squid_curtime + delay));
-	eventAdd("peerDigestValidate", (EVH*) peerDigestValidate,
+	eventAdd("peerDigestValidate", (EVH *) peerDigestValidate,
 	    p, delay);
     } else {
 	assert(disable);
@@ -152,7 +152,7 @@ peerDigestDelay(peer *p, int disable, time_t delay)
 
 /* request new digest if our copy is too old; schedule next validation */
 static void
-peerDigestValidate(peer *p)
+peerDigestValidate(peer * p)
 {
     StoreEntry *e = NULL;
     int do_request;
@@ -165,13 +165,13 @@ peerDigestValidate(peer *p)
     }
     debug(72, 3) ("current GMT time: %s\n", mkrfc1123(squid_curtime));
     assert(!EBIT_TEST(p->digest.flags, PD_REQUESTED));
-    debug(72, 3) ("peerDigestValidate: %s was %s disabled\n", 
+    debug(72, 3) ("peerDigestValidate: %s was %s disabled\n",
 	p->host, p->digest.last_dis_delay ? "" : "not");
-    if (1 /* p->digest.cd */) {
+    if (1 /* p->digest.cd */ ) {
 	const cache_key *key;
 	key = storeKeyPublic(urlRInternal(p->host, p->http_port, NULL, StoreDigestUrlPath), METHOD_GET);
 	e = storeGet(key);
-	debug(72, 3) ("peerDigestValidate: %s store entry, key: %s, exp: %s\n", 
+	debug(72, 3) ("peerDigestValidate: %s store entry, key: %s, exp: %s\n",
 	    e ? "has" : "no", storeKeyText(key), mkrfc1123(e ? e->expires : 0));
     }
     /* currently we rely on entry->expire information */
@@ -186,7 +186,7 @@ peerDigestValidate(peer *p)
     /* do not request too often from one peer */
     if (req_time - p->digest.last_req_timestamp < PeerDigestRequestMinGap) {
 	if (do_request) {
-	    debug(72, 2) ("peerDigestValidate: %s, avoiding too close peer requests (%d secs).\n", 
+	    debug(72, 2) ("peerDigestValidate: %s, avoiding too close peer requests (%d secs).\n",
 		p->host, req_time - p->digest.last_req_timestamp);
 	    do_request = 0;
 	}
@@ -196,21 +196,21 @@ peerDigestValidate(peer *p)
     if (!EBIT_TEST(p->digest.flags, PD_INITED) &&
 	req_time - global_last_req_timestamp < GlobalDigestRequestMinGap) {
 	if (do_request) {
-	    debug(72, 2) ("peerDigestValidate: %s, avoiding too close requests (%d secs).\n", 
+	    debug(72, 2) ("peerDigestValidate: %s, avoiding too close requests (%d secs).\n",
 		p->host, req_time - global_last_req_timestamp);
 	    do_request = 0;
 	}
 	req_time = global_last_req_timestamp + GlobalDigestRequestMinGap;
 	/* otherwise we have all but one peer returning at the same moment @?@ */
 	debug(72, 5) ("peerDigestValidate: inc req_time (%+d) in anticipation of more reqs\n",
-	    (int)(req_time - global_last_req_timestamp));
+	    (int) (req_time - global_last_req_timestamp));
 	global_last_req_timestamp = req_time;
     }
     /* start request if needed */
     if (do_request) {
 	static nest_level = 0;
 	nest_level++;
-	assert(nest_level  == 1);
+	assert(nest_level == 1);
 	debug(72, 2) ("peerDigestValidate: %s requesting; old entry expires: %s\n",
 	    p->host, e ? mkrfc1123(e->expires) : "no entry");
 	/* will eventually disable digests or call peerDigest Delay */
@@ -225,7 +225,7 @@ peerDigestValidate(peer *p)
 
 /* ask peer cache for a fresh digest */
 static void
-peerDigestRequest(peer *p)
+peerDigestRequest(peer * p)
 {
     StoreEntry *e, *old_e;
     char *url;
@@ -237,7 +237,7 @@ peerDigestRequest(peer *p)
     /* compute future request components */
     url = urlRInternal(p->host, p->http_port, "", StoreDigestUrlPath);
     key = storeKeyPublic(url, METHOD_GET);
-    debug(72,2) ("peerDigestRequest: %s key: %s\n", url, storeKeyText(key));
+    debug(72, 2) ("peerDigestRequest: %s key: %s\n", url, storeKeyText(key));
     req = requestLink(urlParse(METHOD_GET, url));
     assert(req);
     /* add custom headers */
@@ -266,23 +266,23 @@ peerDigestRequest(peer *p)
     EBIT_SET(req->flags, REQ_REFRESH);
     old_e = fetch->old_entry = storeGet(key);
     if (old_e) {
-	debug(72,5) ("peerDigestRequest: found old entry\n");
+	debug(72, 5) ("peerDigestRequest: found old entry\n");
 	storeLockObject(old_e);
 	storeCreateMemObject(old_e, url, url);
 	storeClientListAdd(old_e, fetch);
     }
     e = fetch->entry = storeCreateEntry(url, url, req->flags, req->method);
-    debug(72,5) ("peerDigestRequest: new entry is private: %d\n",
-	(int)EBIT_TEST(e->flag, KEY_PRIVATE));
+    debug(72, 5) ("peerDigestRequest: new entry is private: %d\n",
+	(int) EBIT_TEST(e->flag, KEY_PRIVATE));
     storeClientListAdd(e, fetch);
     /* set lastmod to trigger IMS request if possible */
     if (old_e)
 	e->lastmod = old_e->lastmod;
     fetch->offset = 0;
-    debug(72,3) ("peerDigestRequest: forwarding to protoDispatch...\n");
+    debug(72, 3) ("peerDigestRequest: forwarding to protoDispatch...\n");
     /* push towards peer cache */
     protoDispatch(0, e, req);
-    storeClientCopy(e, 0, 0, SM_PAGE_SIZE, memAllocate(MEM_4K_BUF), 
+    storeClientCopy(e, 0, 0, SM_PAGE_SIZE, memAllocate(MEM_4K_BUF),
 	peerDigestFetchReply, fetch);
 }
 
@@ -318,16 +318,15 @@ peerDigestFetchReply(void *data, char *buf, ssize_t size)
 	    /* get rid of 304 reply */
 	    storeUnregister(fetch->entry, fetch);
 	    /* paranoid assert: storeUnregister should not call us recursively */
-	    assert(fetch->entry); 
+	    assert(fetch->entry);
 	    storeUnlockObject(fetch->entry);
 	    fetch->entry = fetch->old_entry;
 	    fetch->old_entry = NULL;
 	    /* preserve request -- we need its size to update counters */
 	    /* requestUnlink(r); */
 	    /* fetch->entry->mem_obj->request = NULL; */
 	    assert(fetch->entry->mem_obj);
-	} else
-	if (status == HTTP_OK) {
+	} else if (status == HTTP_OK) {
 	    /* get rid of old entry if any */
 	    if (fetch->old_entry) {
 		debug(72, 3) ("peerDigestFetchReply: got new digest, requesting release of old digest\n");
@@ -346,7 +345,7 @@ peerDigestFetchReply(void *data, char *buf, ssize_t size)
 	if (status == HTTP_NOT_MODIFIED && fetch->peer->digest.cd)
 	    peerDigestFetchFinish(fetch, buf, NULL);
 	else
-	    storeClientCopy(fetch->entry, /* have to swap in */
+	    storeClientCopy(fetch->entry,	/* have to swap in */
 		0, 0, SM_PAGE_SIZE, buf, peerDigestSwapInHeaders, fetch);
 	return;
     } else {
@@ -444,7 +443,7 @@ peerDigestSwapInMask(void *data, char *buf, ssize_t size)
     if (fetch->mask_offset >= peer->digest.cd->mask_size) {
 	debug(72, 2) ("peerDigestSwapInMask: Done! Got %d, expected %d\n",
 	    fetch->mask_offset, peer->digest.cd->mask_size);
- 	assert(fetch->mask_offset == peer->digest.cd->mask_size);
+	assert(fetch->mask_offset == peer->digest.cd->mask_size);
 	peerDigestFetchFinish(fetch, NULL, NULL);
 	return;
     }
@@ -459,20 +458,25 @@ peerDigestSwapInMask(void *data, char *buf, ssize_t size)
 }
 
 static int
-peerDigestFetchedEnough(DigestFetchState *fetch, char *buf, ssize_t size, const char *step_name)
+peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const char *step_name)
 {
     const char *reason = NULL;
     const char *no_bug = NULL;
 
     debug(72, 6) ("%s: %s offset: %d size: %d.\n",
-        step_name, fetch->peer->host, fetch->offset, size);
+	step_name, fetch->peer->host, fetch->offset, size);
 
     /* test exiting conditions */
-    if (size < 0) reason = "swap failure";
-    else if (!size) reason = no_bug = "eof";
-    else if (!fetch->entry) reason = "swap abort(?)";
-    else if (fetch->entry->store_status == STORE_ABORTED) reason = "swap abort";
-    else if (!cbdataValid(fetch->peer)) reason = "peer disappeared";
+    if (size < 0)
+	reason = "swap failure";
+    else if (!size)
+	reason = no_bug = "eof";
+    else if (!fetch->entry)
+	reason = "swap abort(?)";
+    else if (fetch->entry->store_status == STORE_ABORTED)
+	reason = "swap abort";
+    else if (!cbdataValid(fetch->peer))
+	reason = "peer disappeared";
 
     /* report exit reason */
     if (reason) {
@@ -485,37 +489,35 @@ peerDigestFetchedEnough(DigestFetchState *fetch, char *buf, ssize_t size, const
 /* free state structures, disables digest on error */
 /* this probably should mimic httpRequestFree() but it does not! @?@ @?@ */
 static void
-peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg)
+peerDigestFetchFinish(DigestFetchState * fetch, char *buf, const char *err_msg)
 {
     peer *peer = fetch->peer;
     MemObject *mem = fetch->entry->mem_obj;
     request_t *req = mem->request;
     const time_t expires = fetch->entry->expires;
     const time_t fetch_resp_time = squid_curtime - fetch->start_time;
-    const int b_read = (fetch->entry->store_status == STORE_PENDING) ? 
-	mem->inmem_hi : mem->object_sz;
+    const int b_read = (fetch->entry->store_status == STORE_PENDING) ?
+    mem->inmem_hi : mem->object_sz;
     assert(req);
     /* final checks */
     if (!err_msg) {
 	if (!peer->digest.cd)
 	    err_msg = "null digest (internal bug?)";
-	else
-	if (fetch->mask_offset != peer->digest.cd->mask_size)
+	else if (fetch->mask_offset != peer->digest.cd->mask_size)
 	    err_msg = "premature eof";
-	else
-	if (!peerDigestUseful(peer))
+	else if (!peerDigestUseful(peer))
 	    err_msg = "useless digest";
     }
     if (fetch->old_entry) {
-	debug(72,2) ("peerDigestFetchFinish: deleting old entry\n");
+	debug(72, 2) ("peerDigestFetchFinish: deleting old entry\n");
 	storeUnregister(fetch->old_entry, fetch);
 	storeReleaseRequest(fetch->old_entry);
 	storeUnlockObject(fetch->old_entry);
 	fetch->old_entry = NULL;
     }
     assert(fetch->entry);
     debug(72, 3) ("peerDigestFetchFinish: %s, read %d b, expires: %s lmt: %s\n",
-	peer->host, b_read, 
+	peer->host, b_read,
 	mkrfc1123(fetch->entry->expires), mkrfc1123(fetch->entry->lastmod));
     if (err_msg) {
 	debug(72, 1) ("disabling corrupted (%s) digest from %s\n",
@@ -526,7 +528,7 @@ peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg)
 	}
 	/* disable for a while */
 	EBIT_CLR(peer->digest.flags, PD_USABLE);
-	peerDigestDelay(peer, 1, 
+	peerDigestDelay(peer, 1,
 	    max_delay(
 		peerDigestExpiresDelay(peer, fetch->entry),
 		peerDigestNextDisDelay(peer)));
@@ -535,9 +537,9 @@ peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg)
     } else {
 	/* ugly condition, but how? */
 	if (fetch->entry->store_status == STORE_OK) {
-	   debug(72, 2) ("re-used old digest from %s\n", peer->host);
+	    debug(72, 2) ("re-used old digest from %s\n", peer->host);
 	} else {
-	   debug(72, 2) ("received valid digest from %s\n", peer->host);
+	    debug(72, 2) ("received valid digest from %s\n", peer->host);
 	}
 	EBIT_SET(peer->digest.flags, PD_USABLE);
 	EBIT_CLR(peer->digest.flags, PD_DISABLED);
@@ -548,12 +550,12 @@ peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg)
     /* update global stats */
     /* note: outgoing numbers are not precise! @?@ */
     kb_incr(&Counter.cd.kbytes_sent, req->headers_sz);
-    kb_incr(&Counter.cd.kbytes_recv, (size_t)b_read);
+    kb_incr(&Counter.cd.kbytes_recv, (size_t) b_read);
     Counter.cd.msgs_sent++;
     Counter.cd.msgs_recv++;
     /* update peer stats */
     kb_incr(&peer->digest.stats.kbytes_sent, req->headers_sz);
-    kb_incr(&peer->digest.stats.kbytes_recv, (size_t)b_read);
+    kb_incr(&peer->digest.stats.kbytes_recv, (size_t) b_read);
     peer->digest.stats.msgs_sent++;
     peer->digest.stats.msgs_recv++;
     /* unlock everything */
@@ -564,7 +566,7 @@ peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg)
     cbdataFree(fetch);
     fetch = NULL;
     if (buf)
-        memFree(MEM_4K_BUF, buf);
+	memFree(MEM_4K_BUF, buf);
     buf = NULL;
     /* set it here and in peerDigestRequest to protect against long downloads */
     peer->digest.last_req_timestamp = squid_curtime;
@@ -575,7 +577,7 @@ peerDigestFetchFinish(DigestFetchState *fetch, char *buf, const char *err_msg)
 }
 
 static int
-peerDigestSetCBlock(peer *peer, const char *buf)
+peerDigestSetCBlock(peer * peer, const char *buf)
 {
     StoreDigestCBlock cblock;
     int freed_size = 0;
@@ -587,38 +589,38 @@ peerDigestSetCBlock(peer *peer, const char *buf)
     cblock.count = ntohl(cblock.count);
     cblock.del_count = ntohl(cblock.del_count);
     cblock.mask_size = ntohl(cblock.mask_size);
-    debug(72,2) ("got digest cblock from %s; ver: %d (req: %d)\n",
-	peer->host, (int)cblock.ver.current, (int)cblock.ver.required);
-    debug(72,2) ("\t size: %d bytes, e-cnt: %d, e-util: %d%%\n",
+    debug(72, 2) ("got digest cblock from %s; ver: %d (req: %d)\n",
+	peer->host, (int) cblock.ver.current, (int) cblock.ver.required);
+    debug(72, 2) ("\t size: %d bytes, e-cnt: %d, e-util: %d%%\n",
 	cblock.mask_size, cblock.count,
 	xpercentInt(cblock.count, cblock.capacity));
     /* check version requirements (both ways) */
     if (cblock.ver.required > CacheDigestVer.current) {
-	debug(72,1) ("%s digest requires version %d; have: %d\n",
+	debug(72, 1) ("%s digest requires version %d; have: %d\n",
 	    peer->host, cblock.ver.required, CacheDigestVer.current);
 	return 0;
     }
     if (cblock.ver.current < CacheDigestVer.required) {
-	debug(72,1) ("%s digest is version %d; we require: %d\n",
+	debug(72, 1) ("%s digest is version %d; we require: %d\n",
 	    peer->host, cblock.ver.current, CacheDigestVer.required);
 	return 0;
     }
     /* check consistency */
-    if (cblock.ver.required > cblock.ver.current || 
+    if (cblock.ver.required > cblock.ver.current ||
 	cblock.mask_size <= 0 || cblock.capacity <= 0 ||
 	cblock.bits_per_entry <= 0 || cblock.hash_func_count <= 0) {
-	debug(72,0) ("%s digest cblock is corrupted.\n", peer->host);
+	debug(72, 0) ("%s digest cblock is corrupted.\n", peer->host);
 	return 0;
     }
     /* check consistency further */
     if (cblock.mask_size != cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry)) {
-	debug(72,0) ("%s digest cblock is corrupted (mask size mismatch: %d ? %d).\n", 
+	debug(72, 0) ("%s digest cblock is corrupted (mask size mismatch: %d ? %d).\n",
 	    peer->host, cblock.mask_size, cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry));
 	return 0;
     }
     /* there are some things we cannot do yet */
     if (cblock.hash_func_count != CacheDigestHashFuncCount) {
-	debug(72,0) ("%s digest: unsupported #hash functions: %d ? %d.\n",
+	debug(72, 0) ("%s digest: unsupported #hash functions: %d ? %d.\n",
 	    peer->host, cblock.hash_func_count, CacheDigestHashFuncCount);
 	return 0;
     }
@@ -627,14 +629,14 @@ peerDigestSetCBlock(peer *peer, const char *buf)
      */
     /* check size changes */
     if (peer->digest.cd && cblock.mask_size != peer->digest.cd->mask_size) {
-	debug(72,2) ("%s digest changed size: %d -> %d\n",
+	debug(72, 2) ("%s digest changed size: %d -> %d\n",
 	    peer->host, cblock.mask_size, peer->digest.cd->mask_size);
 	freed_size = peer->digest.cd->mask_size;
 	cacheDigestDestroy(peer->digest.cd);
 	peer->digest.cd = NULL;
     }
     if (!peer->digest.cd) {
-	debug(72,2) ("cloning %s digest; size: %d (%+d) bytes\n",
+	debug(72, 2) ("cloning %s digest; size: %d (%+d) bytes\n",
 	    peer->host, cblock.mask_size, (int) (cblock.mask_size - freed_size));
 	peer->digest.cd = cacheDigestCreate(cblock.capacity, cblock.bits_per_entry);
 	if (cblock.mask_size >= freed_size)
@@ -648,12 +650,12 @@ peerDigestSetCBlock(peer *peer, const char *buf)
 }
 
 static int
-peerDigestUseful(const peer *peer)
+peerDigestUseful(const peer * peer)
 {
     /* TODO: we should calculate the prob of a false hit instead of bit util */
     const int bit_util = cacheDigestBitUtil(peer->digest.cd);
     if (bit_util > 75) {
-	debug(72,0) ("Warning: %s peer digest has too many bits on (%d%%).\n",
+	debug(72, 0) ("Warning: %s peer digest has too many bits on (%d%%).\n",
 	    peer->host, bit_util);
 	return 0;
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.53 1998/04/24 06:08:20 wessels Exp $
+ * $Id: peer_select.cc,v 1.54 1998/04/24 07:09:41 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -312,19 +312,19 @@ peerSelectFoo(ps_state * psstate)
 	if (squid_random() & 1) {
 	    debug(44, 2) ("peerSelect: Using Cache Digest\n");
 	    request->hier.alg = PEER_SA_DIGEST;
-	    if (1 /* global_digested_peer_count */)
+	    if (1 /* global_digested_peer_count */ )
 		p = neighborsDigestSelect(request, entry);
 	    /* update counters */
 	    statHistCount(&Counter.cd.peer_choice_count, request->hier.n_choices);
 	    statHistCount(&Counter.cd.peer_ichoice_count, request->hier.n_ichoices);
-  	    code = DIRECT;
+	    code = DIRECT;
 	    switch (request->hier.cd_lookup) {
 	    case LOOKUP_HIT:
 		assert(p);
 		code = CACHE_DIGEST_HIT;
 		debug(44, 2) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
 		hierarchyNote(&request->hier, code, &psstate->icp, p->host);
-		peerSelectCallback(psstate, p); /* @?@: p used to be NULL */
+		peerSelectCallback(psstate, p);		/* @?@: p used to be NULL */
 		return;
 	    case LOOKUP_MISS:
 		code = NO_CACHE_DIGEST_DIRECT;
@@ -336,9 +336,9 @@ peerSelectFoo(ps_state * psstate)
 		peerSelectCallback(psstate, NULL);
 		return;
 	    default:
-		assert(0); /* invalid lookup code */
+		assert(0);	/* invalid lookup code */
 	    }
-	    assert(0); /* never reached */
+	    assert(0);		/* never reached */
 	} else {
 	    request->hier.alg = PEER_SA_ICP;
 #endif
@@ -462,7 +462,7 @@ peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
 #if USE_CACHE_DIGESTS
     /* do cd lookup to count false misses */
     if (p && request)
-	peerNoteDigestLookup(request, p, 
+	peerNoteDigestLookup(request, p,
 	    peerDigestLookup(p, request, psstate->entry));
 #endif
     psstate->icp.n_recv++;
@@ -183,7 +183,7 @@ extern int file_map_bit_set(fileMap *, int);
 extern int file_map_bit_test(fileMap *, int);
 extern void file_map_bit_reset(fileMap *, int);
 extern void filemapFreeMemory(fileMap *);
-extern void filemapCopy(fileMap *old, fileMap *new);
+extern void filemapCopy(fileMap * old, fileMap * new);
 
 
 extern void fqdncache_nbgethostbyaddr(struct in_addr, FQDNH *, void *);
@@ -773,7 +773,7 @@ extern void storeSwapOutStart(StoreEntry * e);
 extern void storeSwapOutHandle(int fdnotused, int flag, size_t len, void *data);
 extern void storeCheckSwapOut(StoreEntry * e);
 extern void storeSwapOutFileClose(StoreEntry * e);
-int storeSwapOutWriteQueued(MemObject *mem);
+int storeSwapOutWriteQueued(MemObject * mem);
 
 /*
  * store_client.c
@@ -1,6 +1,6 @@
 
 /*
- * $Id: refresh.cc,v 1.18 1998/04/22 16:22:15 rousskov Exp $
+ * $Id: refresh.cc,v 1.19 1998/04/24 07:09:44 wessels Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -115,7 +115,7 @@ refreshCheck(const StoreEntry * entry, const request_t * request, time_t delta)
 	    return 0;
 	}
 	debug(22, 3) ("refreshCheck: YES: lastvalid <= lastmod (%d <= %d)\n",
-	    (int)entry->timestamp, (int)entry->lastmod);
+	    (int) entry->timestamp, (int) entry->lastmod);
 	return 1;
     }
     factor = 100 * age / (entry->timestamp - entry->lastmod);
@@ -161,12 +161,11 @@ refreshWhen(const StoreEntry * entry)
     if (-1 < entry->expires) {
 	debug(22, 3) ("refreshWhen: expires set\n");
 	refresh_time = entry->expires;
-    } else
-    if (entry->timestamp <= entry->lastmod) {
+    } else if (entry->timestamp <= entry->lastmod) {
 	debug(22, 3) ("refreshWhen: lastvalid <= lastmod\n");
 	refresh_time = squid_curtime;
     } else {
-	refresh_time = pct * (entry->timestamp - entry->lastmod)/100 + entry->timestamp;
+	refresh_time = pct * (entry->timestamp - entry->lastmod) / 100 + entry->timestamp;
 	debug(22, 3) ("refreshWhen: using refresh pct\n");
     }
     /* take min/max into account, max takes priority over min */
@@ -175,7 +174,7 @@ refreshWhen(const StoreEntry * entry)
     if (refresh_time > max)
 	refresh_time = max;
     debug(22, 3) ("refreshWhen: answer: %d (in %d secs)\n",
-	refresh_time, (int)(refresh_time - squid_curtime));
+	refresh_time, (int) (refresh_time - squid_curtime));
     return refresh_time;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.409 1998/04/24 06:08:22 wessels Exp $
+ * $Id: store.cc,v 1.410 1998/04/24 07:09:46 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -676,8 +676,8 @@ storeMaintainSwapSpace(void *datanotused)
 	     * LRU age will go to zero.
 	     */
 	    if (memInUse(MEM_STOREENTRY) > max_scan) {
-	        dlinkDelete(&e->lru, &store_list);
-	        dlinkAdd(e, &e->lru, &store_list);
+		dlinkDelete(&e->lru, &store_list);
+		dlinkAdd(e, &e->lru, &store_list);
 	    }
 	    locked++;
 	} else if (storeCheckExpired(e, 1)) {
@@ -1,5 +1,5 @@
 /*
- * $Id: store_digest.cc,v 1.10 1998/04/24 06:08:24 wessels Exp $
+ * $Id: store_digest.cc,v 1.11 1998/04/24 07:09:47 wessels Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -50,12 +50,12 @@ typedef struct {
 } StoreDigestState;
 
 typedef struct {
-    int del_count;         /* #store entries deleted from store_digest */
-    int del_lost_count;    /* #store entries not found in store_digest on delete */
-    int add_count;         /* #store entries accepted to store_digest */
-    int add_coll_count;    /* #accepted entries that collided with existing ones */
-    int rej_count;         /* #store entries not accepted to store_digest */
-    int rej_coll_count;    /* #not accepted entries that collided with existing ones */
+    int del_count;		/* #store entries deleted from store_digest */
+    int del_lost_count;		/* #store entries not found in store_digest on delete */
+    int add_count;		/* #store entries accepted to store_digest */
+    int add_coll_count;		/* #accepted entries that collided with existing ones */
+    int rej_count;		/* #store entries not accepted to store_digest */
+    int rej_coll_count;		/* #not accepted entries that collided with existing ones */
 } StoreDigestStats;
 
 /*
@@ -121,17 +121,17 @@ storeDigestAdd(const StoreEntry * entry)
 {
     int good_entry = 0;
     assert(entry && store_digest);
-    debug(71,6) ("storeDigestAdd: checking entry, key: %s\n",
+    debug(71, 6) ("storeDigestAdd: checking entry, key: %s\n",
 	storeKeyText(entry->key));
     /* only public entries are digested */
     if (!EBIT_TEST(entry->flag, KEY_PRIVATE)) {
 	const time_t expires = refreshWhen(entry);
-	debug(71,6) ("storeDigestAdd: entry expires in %d secs\n",
-		(int)(expires - squid_curtime));
+	debug(71, 6) ("storeDigestAdd: entry expires in %d secs\n",
+	    (int) (expires - squid_curtime));
 	/* if expires too soon, ignore */
 	/* Note: We should use the time of the next rebuild, not cur_time @?@ */
 	if (expires <= squid_curtime + StoreDigestRebuildPeriod) {
-	    debug(71,6) ("storeDigestAdd: entry expires too early, ignoring\n");
+	    debug(71, 6) ("storeDigestAdd: entry expires too early, ignoring\n");
 	} else {
 	    good_entry = 1;
 	}
@@ -141,7 +141,7 @@ storeDigestAdd(const StoreEntry * entry)
 	if (cacheDigestTest(store_digest, entry->key))
 	    sd_stats.add_coll_count++;
 	cacheDigestAdd(store_digest, entry->key);
-	debug(71,6) ("storeDigestAdd: added entry, key: %s\n",
+	debug(71, 6) ("storeDigestAdd: added entry, key: %s\n",
 	    storeKeyText(entry->key));
     } else {
 	sd_stats.rej_count++;
@@ -154,17 +154,17 @@ void
 storeDigestDel(const StoreEntry * entry)
 {
     assert(entry && store_digest);
-    debug(71,6) ("storeDigestDel: checking entry, key: %s\n",
+    debug(71, 6) ("storeDigestDel: checking entry, key: %s\n",
 	storeKeyText(entry->key));
     if (!EBIT_TEST(entry->flag, KEY_PRIVATE)) {
 	if (!cacheDigestTest(store_digest, entry->key)) {
 	    sd_stats.del_lost_count++;
-	    debug(71,6) ("storeDigestDel: lost entry, key: %s url: %s\n",
+	    debug(71, 6) ("storeDigestDel: lost entry, key: %s url: %s\n",
 		storeKeyText(entry->key), storeUrl(entry));
 	} else {
 	    sd_stats.del_count++;
 	    cacheDigestDel(store_digest, entry->key);
-	    debug(71,6) ("storeDigestDel: deled entry, key: %s\n",
+	    debug(71, 6) ("storeDigestDel: deled entry, key: %s\n",
 		storeKeyText(entry->key));
 	}
     }
@@ -198,7 +198,7 @@ storeDigestRebuildResume()
     sd_state.rebuild_offset = 0;
     /* resize or clear */
     if (!storeDigestResize())
-	cacheDigestClear(store_digest); /* not clean()! */
+	cacheDigestClear(store_digest);		/* not clean()! */
     memset(&sd_stats, 0, sizeof(sd_stats));
     eventAdd("storeDigestRebuildStep", storeDigestRebuildStep, NULL, 0);
 }
@@ -351,7 +351,7 @@ storeDigestCBlockSwapOut(StoreEntry * e)
     sd_state.cblock.mask_size = htonl(store_digest->mask_size);
     sd_state.cblock.bits_per_entry = (unsigned char) StoreDigestBitsPerEntry;
     sd_state.cblock.hash_func_count = (unsigned char) CacheDigestHashFuncCount;
-    storeAppend(e, (char*) &sd_state.cblock, sizeof(sd_state.cblock));
+    storeAppend(e, (char *) &sd_state.cblock, sizeof(sd_state.cblock));
 }
 
 /* calculates digest capacity */
@@ -373,7 +373,7 @@ storeDigestCalcCap()
 	cap = lo_cap;
     /* do not enforce hi_cap limit, average-based estimation may be wrong
      *if (cap > hi_cap)
-     *	cap = hi_cap; 
+     *  cap = hi_cap; 
      */
     return cap;
 }
@@ -390,7 +390,7 @@ storeDigestResize()
 	store_digest->capacity, cap, diff,
 	xpercentInt(diff, store_digest->capacity));
     /* avoid minor adjustments */
-    if (diff <= store_digest->capacity/10) {
+    if (diff <= store_digest->capacity / 10) {
 	debug(71, 2) ("storeDigestResize: small change, will not resize.\n");
 	return 0;
     } else {
@@ -406,12 +406,12 @@ storeDigestReport(StoreEntry * e)
     if (store_digest) {
 	cacheDigestReport(store_digest, "store", e);
 	storeAppendPrintf(e, "\t added: %d rejected: %d ( %.2f %%) del-ed: %d\n",
-	    sd_stats.add_count, 
+	    sd_stats.add_count,
 	    sd_stats.rej_count,
-		xpercent(sd_stats.rej_count, sd_stats.rej_count + sd_stats.add_count),
+	    xpercent(sd_stats.rej_count, sd_stats.rej_count + sd_stats.add_count),
 	    sd_stats.del_count);
 	storeAppendPrintf(e, "\t collisions: on add: %.2f %% on rej: %.2f %%\n",
-	    xpercent(sd_stats.add_coll_count, sd_stats.add_count), 
+	    xpercent(sd_stats.add_coll_count, sd_stats.add_count),
 	    xpercent(sd_stats.rej_coll_count, sd_stats.rej_count));
     } else {
 	storeAppendPrintf(e, "store digest: disabled.\n");
@@ -270,7 +270,7 @@ storeSwapOutFileOpened(void *data, int fd, int errcode)
  * does not include the meta header.
  */
 int
-storeSwapOutWriteQueued(MemObject *mem)
+storeSwapOutWriteQueued(MemObject * mem)
 {
     /*
      * this function doesn't get called much, so I'm using
@@ -1,4 +1,5 @@
 
+
 struct _acl_ip_data {
     struct in_addr addr1;	/* if addr2 non-zero then its a range */
     struct in_addr addr2;
@@ -614,11 +615,11 @@ struct _HierarchyLogEntry {
     char host[SQUIDHOSTNAMELEN];
     icp_ping_data icp;
 #if USE_CACHE_DIGESTS
-    char cd_host[SQUIDHOSTNAMELEN]; /* the host of selected by cd peer */
-    peer_select_alg_t alg; /* peer selection algorithm */
-    lookup_t cd_lookup;    /* cd prediction: none, miss, hit */
-    int n_choices;         /* #peers we selected from (cd only) */
-    int n_ichoices;        /* #peers with known rtt we selected from (cd only) */
+    char cd_host[SQUIDHOSTNAMELEN];	/* the host of selected by cd peer */
+    peer_select_alg_t alg;	/* peer selection algorithm */
+    lookup_t cd_lookup;		/* cd prediction: none, miss, hit */
+    int n_choices;		/* #peers we selected from (cd only) */
+    int n_ichoices;		/* #peers with known rtt we selected from (cd only) */
     struct timeval peer_select_start;
     struct timeval store_complete_stop;
 #endif
@@ -782,8 +783,8 @@ struct _domain_type {
 };
 
 struct _Version {
-    short int current;   /* current version */
-    short int required;  /* minimal version that can safely handle current version */
+    short int current;		/* current version */
+    short int required;		/* minimal version that can safely handle current version */
 };
 
 /* digest control block; used for transmission and storage */
@@ -796,7 +797,7 @@ struct _StoreDigestCBlock {
     unsigned char bits_per_entry;
     unsigned char hash_func_count;
     short int reserved_short;
-    int reserved[32-6];
+    int reserved[32 - 6];
 };
 
 struct _DigestFetchState {
@@ -815,15 +816,15 @@ struct _cd_guess_stats {
     int false_hits;
     int true_misses;
     int false_misses;
-    int close_hits; /* tmp, remove it later */
+    int close_hits;		/* tmp, remove it later */
 };
 
 struct _PeerDigest {
     CacheDigest *cd;
-    int flags;        /* PD_ */
+    int flags;			/* PD_ */
     time_t last_fetch_resp_time;
     time_t last_req_timestamp;
-    time_t last_dis_delay;    /* last disability delay */
+    time_t last_dis_delay;	/* last disability delay */
     struct {
 	cd_guess_stats guess;
 	int used_count;
@@ -1205,7 +1206,7 @@ struct _StatCounters {
 	kb_t r_kbytes_recv;
 	StatHist query_svc_time;
 	StatHist reply_svc_time;
-        int query_timeouts;
+	int query_timeouts;
 #if USE_CACHE_DIGESTS
 	StatHist client_svc_time;
 	StatHist server_svc_time;
@@ -1226,12 +1227,12 @@ struct _StatCounters {
 	kb_t memory;
 	int msgs_sent;
 	int msgs_recv;
-        cd_guess_stats guess;
+	cd_guess_stats guess;
 	StatHist client_svc_time;
 	StatHist server_svc_time;
-	StatHist peer_choice_count;  /* #peer select choices in peerSelectFoo */
-	StatHist peer_ichoice_count; /* #peer select choices with rtt > 0 */
-	StatHist on_xition_count;    /* #(0->1) transitions during cacheDigestAdd */
+	StatHist peer_choice_count;	/* #peer select choices in peerSelectFoo */
+	StatHist peer_ichoice_count;	/* #peer select choices with rtt > 0 */
+	StatHist on_xition_count;	/* #(0->1) transitions during cacheDigestAdd */
     } cd;
 #endif
     int page_faults;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: test_cache_digest.cc,v 1.18 1998/04/22 21:28:24 rousskov Exp $
+ * $Id: test_cache_digest.cc,v 1.19 1998/04/24 07:09:49 wessels Exp $
  *
  * AUTHOR: Alex Rousskov
  *
@@ -272,7 +272,7 @@ cacheResetDigest(Cache * cache)
     if (cache->digest)
 	cacheDigestDestroy(cache->digest);
     hash = cache->hash;
-    cache->digest = cacheDigestCreate(cache->count+1, 6);
+    cache->digest = cacheDigestCreate(cache->count + 1, 6);
     if (!cache->count)
 	return;
     gettimeofday(&t_start, NULL);