@@ -111,7 +111,7 @@ class AccessLogEntry
         {;
         }
 
-        IpAddress caddr;
+        Ip::Address caddr;
         int64_t requestSize;
         int64_t replySize;
         int requestHeadersSize; ///< received, including request line
@@ -178,7 +178,7 @@ class AccessLogEntry
     public:
         IcapLogEntry():request(NULL),reply(NULL),outcome(Adaptation::Icap::xoUnknown),trTime(0),ioTime(0),resStatus(HTTP_STATUS_NONE) {}
 
-        IpAddress hostAddr; ///< ICAP server IP address
+        Ip::Address hostAddr; ///< ICAP server IP address
         String serviceName;        ///< ICAP service name
         String reqUri;             ///< ICAP Request-URI
         Adaptation::Icap::ICAP::Method reqMethod; ///< ICAP request method
@@ -11,7 +11,7 @@ class ClientInfo
 public:
     hash_link hash;             /* must be first */
 
-    IpAddress addr;
+    Ip::Address addr;
 
     struct {
         int result_hist[LOG_TYPE_MAX];
@@ -76,7 +76,7 @@ class CompositePoolNode : public RefCountable, public Updateable
     public:
         CompositeSelectionDetails() {}
 
-        IpAddress src_addr;
+        Ip::Address src_addr;
         AuthUserRequest *user;
         String tag;
     };
@@ -44,9 +44,9 @@ class ConnectionDetail
 
     ConnectionDetail();
 
-    IpAddress me;
+    Ip::Address me;
 
-    IpAddress peer;
+    Ip::Address peer;
 };
 
 #endif
@@ -157,7 +157,7 @@ DiskdIOStrategy::init()
     char skey1[32];
     char skey2[32];
     char skey3[32];
-    IpAddress localhost;
+    Ip::Address localhost;
 
     ikey = (getpid() << 10) + (instanceID << 2);
     ikey &= 0x7fffffff;
@@ -149,7 +149,7 @@ class HttpRequest: public HttpMsg
 #endif
 
 public:
-    IpAddress host_addr;
+    Ip::Address host_addr;
 
     AuthUserRequest *auth_user_request;
 
@@ -169,10 +169,10 @@ class HttpRequest: public HttpMsg
 
     int64_t max_forwards;
 
-    IpAddress client_addr;
+    Ip::Address client_addr;
 
 #if FOLLOW_X_FORWARDED_FOR
-    IpAddress indirect_client_addr;
+    Ip::Address indirect_client_addr;
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
 #if USE_SQUID_EUI
@@ -182,7 +182,7 @@ class HttpRequest: public HttpMsg
     Eui::Eui64 client_eui64;
 #endif
 
-    IpAddress my_addr;
+    Ip::Address my_addr;
 
     HierarchyLogEntry hier;
 
@@ -68,7 +68,7 @@ struct _icp_common_t {
     _icp_common_t();
     _icp_common_t(char *buf, unsigned int len);
 
-    void handleReply(char *buf, IpAddress &from);
+    void handleReply(char *buf, Ip::Address &from);
     static _icp_common_t *createMessage(icp_opcode opcode, int flags, const char *url, int reqnum, int pad);
     icp_opcode getOpCode() const;
 #endif
@@ -99,15 +99,15 @@ class ICPState
     HttpRequest *request;
     int fd;
 
-    IpAddress from;
+    Ip::Address from;
     char *url;
 };
 
 #endif
 
 /// \ingroup ServerProtocolICPAPI
 struct icpUdpData {
-    IpAddress address;
+    Ip::Address address;
     void *msg;
     size_t len;
     icpUdpData *next;
@@ -122,25 +122,25 @@ struct icpUdpData {
 };
 
 /// \ingroup ServerProtocolICPAPI
-HttpRequest* icpGetRequest(char *url, int reqnum, int fd, IpAddress &from);
+HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-int icpAccessAllowed(IpAddress &from, HttpRequest * icp_request);
+int icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const IpAddress &from);
+SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
 extern icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpUdpSend(int, const IpAddress &, icp_common_t *, log_type, int);
+SQUIDCEXTERN int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN log_type icpLogFromICPCode(icp_opcode opcode);
 
 /// \ingroup ServerProtocolICPAPI
-void icpDenyAccess(IpAddress &from, char *url, int reqnum, int fd);
+void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN PF icpHandleUdp;
@@ -149,7 +149,7 @@ SQUIDCEXTERN PF icpHandleUdp;
 SQUIDCEXTERN PF icpUdpSendQueue;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpHandleIcpV3(int, IpAddress &, char *, int);
+SQUIDCEXTERN void icpHandleIcpV3(int, Ip::Address &, char *, int);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
@@ -163,7 +163,7 @@ StringToInt64(const char *s, int64_t &result, const char **p, int base)
 }
 
 bool
-GetHostWithPort(char *token, IpAddress *ipa)
+GetHostWithPort(char *token, Ip::Address *ipa)
 {
     char *t;
     char *host;
@@ -61,11 +61,11 @@ extern bool StringToInt(const char *str, int &result, const char **p, int base);
 extern bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
 
 /**
- * Parse a socket address (host:port), fill the given IpAddress object
+ * Parse a socket address (host:port), fill the given Ip::Address object
  * \retval false     Failure.
  * \retval true      Success.
  * Destroys token during parse.
  */
-extern bool GetHostWithPort(char *token, IpAddress *ipa);
+extern bool GetHostWithPort(char *token, Ip::Address *ipa);
 
 #endif /* SQUID_PARSING_H */
@@ -52,16 +52,16 @@ class ps_state
     void *callback_data;
     FwdServer *servers;
     /*
-     * Why are these IpAddress instead of peer *?  Because a
+     * Why are these Ip::Address instead of peer *?  Because a
      * peer structure can become invalid during the peer selection
      * phase, specifically after a reconfigure.  Thus we need to lookup
      * the peer * based on the address when we are finally ready to
      * reference the peer structure.
      */
 
-    IpAddress first_parent_miss;
+    Ip::Address first_parent_miss;
 
-    IpAddress closest_parent_miss;
+    Ip::Address closest_parent_miss;
     /*
      * ->hit can be peer* because it should only be
      * accessed during the thread when it is set
@@ -14,7 +14,7 @@ struct http_port_list {
 
     http_port_list *next;
 
-    IpAddress s;
+    Ip::Address s;
     char *protocol;            /* protocol name */
     char *name;                /* visible name */
     char *defaultsite;         /* default web site */
@@ -43,7 +43,7 @@
 #include "wordlist.h"
 
 static void aclParseArpList(SplayNode<Eui::Eui48 *> **curlist);
-static int aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, IpAddress &c);
+static int aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, Ip::Address &c);
 static SplayNode<Eui::Eui48 *>::SPLAYCMP aclArpCompare;
 static SplayNode<Eui::Eui48 *>::SPLAYWALKEE aclDumpArpListWalkee;
 
@@ -173,7 +173,7 @@ ACLARP::match(ACLChecklist *cl)
 /* aclMatchArp */
 /***************/
 int
-aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, IpAddress &c)
+aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, Ip::Address &c)
 {
     Eui::Eui48 result;
     SplayNode<Eui::Eui48 *> **Top = dataptr;
@@ -60,9 +60,9 @@ class m_ADDR
 {
 public:
     uint8_t len;
-    IpAddress addr;
+    Ip::Address addr;
 
-    m_ADDR() : len(sizeof(IpAddress)) {};
+    m_ADDR() : len(sizeof(Ip::Address)) {};
 };
 
 /* END of definitions for radix tree entries */
@@ -135,7 +135,7 @@ static OBJH asnStats;
 /* PUBLIC */
 
 int
-asnMatchIp(CbDataList<int> *data, IpAddress &addr)
+asnMatchIp(CbDataList<int> *data, Ip::Address &addr)
 {
     struct squid_radix_node *rn;
     as_info *e;
@@ -401,8 +401,8 @@ asnAddNet(char *as_string, int as_number)
     CbDataList<int> *q = NULL;
     as_info *asinfo = NULL;
 
-    IpAddress mask;
-    IpAddress addr;
+    Ip::Address mask;
+    Ip::Address addr;
     char *t;
     int bitl;
 
@@ -520,8 +520,8 @@ printRadixNode(struct squid_radix_node *rn, void *_sentry)
     CbDataList<int> *q;
     as_info *asinfo;
     char buf[MAX_IPSTRLEN];
-    IpAddress addr;
-    IpAddress mask;
+    Ip::Address addr;
+    Ip::Address mask;
 
     assert(e);
     assert(e->e_info);
@@ -549,7 +549,7 @@ ACLASN::~ACLASN()
 
 bool
 
-ACLASN::match(IpAddress toMatch)
+ACLASN::match(Ip::Address toMatch)
 {
     return asnMatchIp(data, toMatch);
 }
@@ -592,7 +592,7 @@ ACLASN::parse()
     }
 }
 
-ACLData<IpAddress> *
+ACLData<Ip::Address> *
 ACLASN::clone() const
 {
     if (data)
@@ -603,18 +603,18 @@ ACLASN::clone() const
 
 /* explicit template instantiation required for some systems */
 
-template class ACLStrategised<IpAddress>;
+template class ACLStrategised<Ip::Address>;
 
 ACL::Prototype ACLASN::SourceRegistryProtoype(&ACLASN::SourceRegistryEntry_, "src_as");
 
-ACLStrategised<IpAddress> ACLASN::SourceRegistryEntry_(new ACLASN, ACLSourceASNStrategy::Instance(), "src_as");
+ACLStrategised<Ip::Address> ACLASN::SourceRegistryEntry_(new ACLASN, ACLSourceASNStrategy::Instance(), "src_as");
 
 ACL::Prototype ACLASN::DestinationRegistryProtoype(&ACLASN::DestinationRegistryEntry_, "dst_as");
 
-ACLStrategised<IpAddress> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
+ACLStrategised<Ip::Address> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
 
 int
-ACLSourceASNStrategy::match (ACLData<IpAddress> * &data, ACLFilledChecklist *checklist)
+ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist)
 {
     return data->match(checklist->src_addr);
 }
@@ -647,7 +647,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
         debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
         checklist->changeState (DestinationIPLookup::Instance());
     } else {
-        IpAddress noaddr;
+        Ip::Address noaddr;
         noaddr.SetNoAddr();
         return data->match(noaddr);
     }
@@ -38,7 +38,7 @@
 #include "acl/Checklist.h"
 #include "ip/IpAddress.h"
 
-SQUIDCEXTERN int asnMatchIp(CbDataList<int> *, IpAddress &);
+SQUIDCEXTERN int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
 SQUIDCEXTERN void asnInit(void);
@@ -47,26 +47,26 @@ SQUIDCEXTERN void asnInit(void);
 SQUIDCEXTERN void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
-class ACLASN : public ACLData<IpAddress>
+class ACLASN : public ACLData<Ip::Address>
 {
 
 public:
     MEMPROXY_CLASS(ACLASN);
 
     virtual ~ACLASN();
 
-    virtual bool match(IpAddress);
+    virtual bool match(Ip::Address);
     virtual wordlist *dump();
     virtual void parse();
     bool empty() const;
-    virtual ACLData<IpAddress> *clone() const;
+    virtual ACLData<Ip::Address> *clone() const;
     virtual void prepareForUse();
 
 private:
     static ACL::Prototype SourceRegistryProtoype;
-    static ACLStrategised<IpAddress> SourceRegistryEntry_;
+    static ACLStrategised<Ip::Address> SourceRegistryEntry_;
     static ACL::Prototype DestinationRegistryProtoype;
-    static ACLStrategised<IpAddress> DestinationRegistryEntry_;
+    static ACLStrategised<Ip::Address> DestinationRegistryEntry_;
     CbDataList<int> *data;
 };
 
@@ -37,7 +37,7 @@
 #include "ip/IpAddress.h"
 
 /// \ingroup ACLAPI
-class ACLDestinationASNStrategy : public ACLStrategy<IpAddress>
+class ACLDestinationASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
@@ -43,7 +43,7 @@
 #include "wordlist.h"
 
 static void aclParseEuiList(SplayNode<Eui::Eui64 *> **curlist);
-static int aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, IpAddress &c);
+static int aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, Ip::Address &c);
 static SplayNode<Eui::Eui64 *>::SPLAYCMP aclEui64Compare;
 static SplayNode<Eui::Eui64 *>::SPLAYWALKEE aclDumpEuiListWalkee;
 
@@ -147,7 +147,7 @@ ACLEui64::match(ACLChecklist *cl)
 /* aclMatchEui */
 /***************/
 int
-aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, IpAddress &c)
+aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, Ip::Address &c)
 {
     Eui::Eui64 result;
     SplayNode<Eui::Eui64 *> **Top = dataptr;
@@ -43,9 +43,9 @@ class ACLFilledChecklist: public ACLChecklist
     virtual bool hasReply() const { return reply != NULL; }
 
 public:
-    IpAddress src_addr;
-    IpAddress dst_addr;
-    IpAddress my_addr;
+    Ip::Address src_addr;
+    Ip::Address dst_addr;
+    Ip::Address my_addr;
     struct peer *dst_peer;
     char *dst_rdns;
 
@@ -129,7 +129,7 @@ acl_ip_data::toStr(char *buf, int len) const
 int
 aclIpAddrNetworkCompare(acl_ip_data * const &p, acl_ip_data * const &q)
 {
-    IpAddress A = p->addr1;
+    Ip::Address A = p->addr1;
 
     /* apply netmask */
     A.ApplyMask(q->mask);
@@ -196,7 +196,7 @@ acl_ip_data::NetworkCompare(acl_ip_data * const & a, acl_ip_data * const &b)
  * This function should NOT be called if 'asc' is a hostname!
  */
 bool
-acl_ip_data::DecodeMask(const char *asc, IpAddress &mask, int ctype)
+acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
 {
     char junk;
     int a1 = 0;
@@ -258,7 +258,7 @@ acl_ip_data::FactoryParse(const char *t)
     LOCAL_ARRAY(char, mask, 256);
     acl_ip_data *r = NULL;
     acl_ip_data **Q = NULL;
-    IpAddress temp;
+    Ip::Address temp;
     char c;
     unsigned int changed;
     acl_ip_data *q = new acl_ip_data;
@@ -408,13 +408,13 @@ acl_ip_data::FactoryParse(const char *t)
         /*
          * Note, must use plain getaddrinfo() here because at startup
          * ipcache hasn't been initialized
-         * TODO: offload this to one of the IpAddress lookups.
+         * TODO: offload this to one of the Ip::Address lookups.
          */
 
         debugs(28, 5, "aclIpParseIpData: Lookup Host/IP " << addr1);
         struct addrinfo *hp = NULL, *x = NULL;
         struct addrinfo hints;
-        IpAddress *prev_addr = NULL;
+        Ip::Address *prev_addr = NULL;
 
         memset(&hints, 0, sizeof(struct addrinfo));
 
@@ -561,7 +561,7 @@ ACLIP::empty () const
 }
 
 int
-ACLIP::match(IpAddress &clientip)
+ACLIP::match(Ip::Address &clientip)
 {
     static acl_ip_data ClientAddress;
     /*
@@ -581,4 +581,4 @@ ACLIP::match(IpAddress &clientip)
 
 acl_ip_data::acl_ip_data () :addr1(), addr2(), mask(), next (NULL) {}
 
-acl_ip_data::acl_ip_data (IpAddress const &anAddress1, IpAddress const &anAddress2, IpAddress const &aMask, acl_ip_data *aNext) : addr1(anAddress1), addr2(anAddress2), mask(aMask), next(aNext) {}
+acl_ip_data::acl_ip_data (Ip::Address const &anAddress1, Ip::Address const &anAddress2, Ip::Address const &aMask, acl_ip_data *aNext) : addr1(anAddress1), addr2(anAddress2), mask(aMask), next(aNext) {}
@@ -47,20 +47,20 @@ class acl_ip_data
 
     acl_ip_data ();
 
-    acl_ip_data (IpAddress const &, IpAddress const &, IpAddress const &, acl_ip_data *);
+    acl_ip_data (Ip::Address const &, Ip::Address const &, Ip::Address const &, acl_ip_data *);
     void toStr(char *buf, int len) const;
 
-    IpAddress addr1;
+    Ip::Address addr1;
 
-    IpAddress addr2;
+    Ip::Address addr2;
 
-    IpAddress mask; /**< \todo This should perhapse be stored as a CIDR range now instead of a full IP mask. */
+    Ip::Address mask; /**< \todo This should perhapse be stored as a CIDR range now instead of a full IP mask. */
 
     acl_ip_data *next;		/**< used for parsing, not for storing */
 
 private:
 
-    static bool DecodeMask(const char *asc, IpAddress &mask, int string_format_type);
+    static bool DecodeMask(const char *asc, Ip::Address &mask, int string_format_type);
 };
 
 MEMPROXY_CLASS_INLINE(acl_ip_data);
@@ -88,7 +88,7 @@ class ACLIP : public ACL
 
 protected:
 
-    int match(IpAddress &);
+    int match(Ip::Address &);
     IPSplay *data;
 
 private:
@@ -40,7 +40,7 @@ class ACLChecklist;
 #include "acl/Strategy.h"
 #include "ip/IpAddress.h"
 
-class ACLSourceASNStrategy : public ACLStrategy<IpAddress>
+class ACLSourceASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
@@ -1250,7 +1250,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     }
 
     if (TheConfig.send_client_ip && request) {
-        IpAddress client_addr;
+        Ip::Address client_addr;
 #if FOLLOW_X_FORWARDED_FOR
         if (TheConfig.icap_uses_indirect_client) {
             client_addr = request->indirect_client_addr;
@@ -87,7 +87,7 @@ void Adaptation::Icap::Xaction::start()
 // TODO: obey service-specific, OPTIONS-reported connection limit
 void Adaptation::Icap::Xaction::openConnection()
 {
-    IpAddress client_addr;
+    Ip::Address client_addr;
 
     Must(connection < 0);
 
@@ -115,7 +115,7 @@ void Adaptation::Icap::Xaction::openConnection()
 
     disableRetries(); // we only retry pconn failures
 
-    IpAddress outgoing;
+    Ip::Address outgoing;
     connection = comm_open(SOCK_STREAM, 0, outgoing,
                            COMM_NONBLOCKING, s.cfg().uri.termedBuf());
 
@@ -175,7 +175,7 @@ void Adaptation::Icap::Xaction::closeConnection()
         }
 
         if (reuseConnection) {
-            IpAddress client_addr;
+            Ip::Address client_addr;
             //status() adds leading spaces.
             debugs(93,3, HERE << "pushing pconn" << status());
             AsyncCall::Pointer call = NULL;
@@ -112,9 +112,7 @@ ACLMaxUserIP::parse()
  * 1 : Match
  */
 int
-ACLMaxUserIP::match(AuthUserRequest * auth_user_request,
-
-                    IpAddress const &src_addr)
+ACLMaxUserIP::match(AuthUserRequest * auth_user_request, Ip::Address const &src_addr)
 {
     /*
      * the logic for flush the ip list when the limit is hit vs keep
@@ -69,7 +69,7 @@ class ACLMaxUserIP : public ACL
     static Prototype RegistryProtoype;
     static ACLMaxUserIP RegistryEntry_;
 
-    int match(AuthUserRequest *, IpAddress const &);
+    int match(AuthUserRequest *, Ip::Address const &);
     char const *class_;
     int maximum;
 
@@ -240,7 +240,7 @@ AuthUser::clearIp()
 }
 
 void
-AuthUser::removeIp(IpAddress ipaddr)
+AuthUser::removeIp(Ip::Address ipaddr)
 {
     auth_user_ip_t *ipdata = (auth_user_ip_t *) ip_list.head;
 
@@ -263,7 +263,7 @@ AuthUser::removeIp(IpAddress ipaddr)
 }
 
 void
-AuthUser::addIp(IpAddress ipaddr)
+AuthUser::addIp(Ip::Address ipaddr)
 {
     auth_user_ip_t *ipdata = (auth_user_ip_t *) ip_list.head;
     int found = 0;
@@ -85,8 +85,8 @@ class AuthUser
     _SQUID_INLINE_ char const *username() const;
     _SQUID_INLINE_ void username(char const *);
     void clearIp();
-    void removeIp(IpAddress);
-    void addIp(IpAddress);
+    void removeIp(Ip::Address);
+    void addIp(Ip::Address);
     _SQUID_INLINE_ void addRequest(AuthUserRequest *);
 
     void lock();
@@ -200,7 +200,7 @@ AuthUserRequest::denyMessage(char const * const default_message)
 }
 
 static void
-authenticateAuthUserRequestSetIp(AuthUserRequest * auth_user_request, IpAddress &ipaddr)
+authenticateAuthUserRequestSetIp(AuthUserRequest * auth_user_request, Ip::Address &ipaddr)
 {
     AuthUser *auth_user = auth_user_request->user();
 
@@ -211,7 +211,7 @@ authenticateAuthUserRequestSetIp(AuthUserRequest * auth_user_request, IpAddress
 }
 
 void
-authenticateAuthUserRequestRemoveIp(AuthUserRequest * auth_user_request, IpAddress const &ipaddr)
+authenticateAuthUserRequestRemoveIp(AuthUserRequest * auth_user_request, Ip::Address const &ipaddr)
 {
     AuthUser *auth_user = auth_user_request->user();
 
@@ -328,7 +328,7 @@ authTryGetUser (AuthUserRequest **auth_user_request, ConnStateData * conn, HttpR
  * Caller is responsible for locking and unlocking their *auth_user_request!
  */
 auth_acl_t
-AuthUserRequest::authenticate(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, IpAddress &src_addr)
+AuthUserRequest::authenticate(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr)
 {
     const char *proxy_auth;
     assert(headertype != 0);
@@ -503,7 +503,7 @@ AuthUserRequest::authenticate(AuthUserRequest ** auth_user_request, http_hdr_typ
 
 auth_acl_t
 
-AuthUserRequest::tryToAuthenticateAndSetAuthUser(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, IpAddress &src_addr)
+AuthUserRequest::tryToAuthenticateAndSetAuthUser(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr)
 {
     /* If we have already been called, return the cached value */
     AuthUserRequest *t = authTryGetUser (auth_user_request, conn, request);
@@ -48,7 +48,7 @@ struct AuthUserIP {
     dlink_node node;
     /* IP addr this user authenticated from */
 
-    IpAddress ipaddr;
+    Ip::Address ipaddr;
     time_t ip_expiretime;
 };
 
@@ -108,7 +108,7 @@ class AuthUserRequest
 
     virtual void user(AuthUser *aUser) {_auth_user=aUser;}
 
-    static auth_acl_t tryToAuthenticateAndSetAuthUser(AuthUserRequest **, http_hdr_type, HttpRequest *, ConnStateData *, IpAddress &);
+    static auth_acl_t tryToAuthenticateAndSetAuthUser(AuthUserRequest **, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &);
     static void addReplyAuthHeader(HttpReply * rep, AuthUserRequest * auth_user_request, HttpRequest * request, int accelerated, int internal);
 
     AuthUserRequest();
@@ -146,7 +146,7 @@ class AuthUserRequest
 
 private:
 
-    static auth_acl_t authenticate(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, IpAddress &src_addr);
+    static auth_acl_t authenticate(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr);
 
     /** return a message on the 407 error pages */
     char *message;
@@ -176,7 +176,7 @@ extern void authenticateFixHeader(HttpReply *, AuthUserRequest *, HttpRequest *,
 extern void authenticateAddTrailer(HttpReply *, AuthUserRequest *, HttpRequest *, int);
 
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestRemoveIp(AuthUserRequest *, IpAddress const &);
+extern void authenticateAuthUserRequestRemoveIp(AuthUserRequest *, Ip::Address const &);
 /// \ingroup AuthAPI
 extern void authenticateAuthUserRequestClearIp(AuthUserRequest *);
 /// \ingroup AuthAPI
@@ -676,7 +676,7 @@ AuthDigestUserRequest::authenticate(HttpRequest * request, ConnStateData * conn,
             } else {
                 const char *useragent = request->header.getStr(HDR_USER_AGENT);
 
-                static IpAddress last_broken_addr;
+                static Ip::Address last_broken_addr;
                 static int seen_broken_client = 0;
 
                 if (!seen_broken_client) {
@@ -57,6 +57,7 @@
 #include "HttpRequestMethod.h"
 #include "ident/Config.h"
 #include "ip/IpIntercept.h"
+#include "ip/QosConfig.h"
 #include "log/Config.h"
 #include "MemBuf.h"
 #include "Parsing.h"
@@ -154,11 +155,11 @@ static void dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_li
 static void free_denyinfo(acl_deny_info_list ** var);
 
 #if USE_WCCPv2
-static void parse_IpAddress_list(IpAddress_list **);
-static void dump_IpAddress_list(StoreEntry *, const char *, const IpAddress_list *);
-static void free_IpAddress_list(IpAddress_list **);
+static void parse_IpAddress_list(Ip::Address_list **);
+static void dump_IpAddress_list(StoreEntry *, const char *, const Ip::Address_list *);
+static void free_IpAddress_list(Ip::Address_list **);
 #if CURRENTLY_UNUSED
-static int check_null_IpAddress_list(const IpAddress_list *);
+static int check_null_IpAddress_list(const Ip::Address_list *);
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
@@ -1008,14 +1009,14 @@ free_acl_access(acl_access ** head)
 }
 
 static void
-dump_address(StoreEntry * entry, const char *name, IpAddress &addr)
+dump_address(StoreEntry * entry, const char *name, Ip::Address &addr)
 {
     char buf[MAX_IPSTRLEN];
     storeAppendPrintf(entry, "%s %s\n", name, addr.NtoA(buf,MAX_IPSTRLEN) );
 }
 
 static void
-parse_address(IpAddress *addr)
+parse_address(Ip::Address *addr)
 {
     char *token = strtok(NULL, w_space);
 
@@ -1035,7 +1036,7 @@ parse_address(IpAddress *addr)
 }
 
 static void
-free_address(IpAddress *addr)
+free_address(Ip::Address *addr)
 {
     addr->SetEmpty();
 }
@@ -2874,19 +2875,19 @@ parseNeighborType(const char *s)
 
 #if USE_WCCPv2
 static void
-parse_IpAddress_list(IpAddress_list ** head)
+parse_IpAddress_list(Ip::Address_list ** head)
 {
     char *token;
-    IpAddress_list *s;
-    IpAddress ipa;
+    Ip::Address_list *s;
+    Ip::Address ipa;
 
     while ((token = strtok(NULL, w_space))) {
         if (GetHostWithPort(token, &ipa)) {
 
             while (*head)
                 head = &(*head)->next;
 
-            s = static_cast<IpAddress_list *>(xcalloc(1, sizeof(*s)));
+            s = static_cast<Ip::Address_list *>(xcalloc(1, sizeof(*s)));
             s->s = ipa;
 
             *head = s;
@@ -2896,7 +2897,7 @@ parse_IpAddress_list(IpAddress_list ** head)
 }
 
 static void
-dump_IpAddress_list(StoreEntry * e, const char *n, const IpAddress_list * s)
+dump_IpAddress_list(StoreEntry * e, const char *n, const Ip::Address_list * s)
 {
     char ntoabuf[MAX_IPSTRLEN];
 
@@ -2909,7 +2910,7 @@ dump_IpAddress_list(StoreEntry * e, const char *n, const IpAddress_list * s)
 }
 
 static void
-free_IpAddress_list(IpAddress_list ** head)
+free_IpAddress_list(Ip::Address_list ** head)
 {
     if (*head) delete *head;
     *head = NULL;
@@ -2920,7 +2921,7 @@ free_IpAddress_list(IpAddress_list ** head)
  * be used by icp_port and htcp_port
  */
 static int
-check_null_IpAddress_list(const IpAddress_list * s)
+check_null_IpAddress_list(const Ip::Address_list * s)
 {
     return NULL == s;
 }
@@ -3051,7 +3052,7 @@ parse_http_port_option(http_port_list * s, char *token)
 
     } else if (strcmp(token, "transparent") == 0 || strcmp(token, "intercept") == 0) {
         s->intercepted = 1;
-        IpInterceptor.StartInterception();
+        Ip::Interceptor.StartInterception();
         /* Log information regarding the port modes under interception. */
         debugs(3, DBG_IMPORTANT, "Starting Authentication on port " << s->s);
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (interception enabled)");
@@ -3070,12 +3071,12 @@ parse_http_port_option(http_port_list * s, char *token)
             self_destruct();
         }
         s->spoof_client_ip = 1;
-        IpInterceptor.StartTransparency();
+        Ip::Interceptor.StartTransparency();
         /* Log information regarding the port modes under transparency. */
         debugs(3, DBG_IMPORTANT, "Starting IP Spoofing on port " << s->s);
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (IP spoofing enabled)");
 
-        if (!IpInterceptor.ProbeForTproxy(s->s)) {
+        if (!Ip::Interceptor.ProbeForTproxy(s->s)) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: TPROXY support in the system does not work.");
             self_destruct();
         }
@@ -1410,7 +1410,7 @@ NAME: qos_flows
 TYPE: QosConfig
 IFDEF: USE_ZPH_QOS
 DEFAULT: none
-LOC: Config.zph
+LOC: Ip::Qos::TheConfig
 DOC_START
 	Allows you to select a TOS/DSCP value to mark outgoing
 	connections with, based on where the reply was sourced.
@@ -44,7 +44,7 @@
 
 static hash_table *client_table = NULL;
 
-static ClientInfo *clientdbAdd(const IpAddress &addr);
+static ClientInfo *clientdbAdd(const Ip::Address &addr);
 static FREE clientdbFreeItem;
 static void clientdbStartGC(void);
 static void clientdbScheduledGC(void *);
@@ -58,7 +58,7 @@ static int cleanup_removed;
 
 static ClientInfo *
 
-clientdbAdd(const IpAddress &addr)
+clientdbAdd(const Ip::Address &addr)
 {
     ClientInfo *c;
     char *buf = new char[MAX_IPSTRLEN];
@@ -96,7 +96,7 @@ clientdbInit(void)
 }
 
 void
-clientdbUpdate(const IpAddress &addr, log_type ltype, protocol_t p, size_t size)
+clientdbUpdate(const Ip::Address &addr, log_type ltype, protocol_t p, size_t size)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
@@ -140,7 +140,7 @@ clientdbUpdate(const IpAddress &addr, log_type ltype, protocol_t p, size_t size)
  * -1.  To get the current value, simply call with delta = 0.
  */
 int
-clientdbEstablished(const IpAddress &addr, int delta)
+clientdbEstablished(const Ip::Address &addr, int delta)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
@@ -167,7 +167,7 @@ clientdbEstablished(const IpAddress &addr, int delta)
 #define CUTOFF_SECONDS 3600
 int
 
-clientdbCutoffDenied(const IpAddress &addr)
+clientdbCutoffDenied(const Ip::Address &addr)
 {
     char key[MAX_IPSTRLEN];
     int NR;
@@ -381,8 +381,8 @@ clientdbStartGC(void)
 
 #if SQUID_SNMP
 
-IpAddress *
-client_entry(IpAddress *current)
+Ip::Address *
+client_entry(Ip::Address *current)
 {
     ClientInfo *c = NULL;
     char key[MAX_IPSTRLEN];
@@ -415,7 +415,7 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c = NULL;
-    IpAddress keyIp;
+    Ip::Address keyIp;
 
     *ErrP = SNMP_ERR_NOERROR;
     MemBuf tmp;
@@ -170,7 +170,7 @@ static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
 static int connKeepReadingIncompleteRequest(ConnStateData * conn);
 static void connCancelIncompleteRequests(ConnStateData * conn);
 
-static ConnStateData *connStateCreate(const IpAddress &peer, const IpAddress &me, int fd, http_port_list *port);
+static ConnStateData *connStateCreate(const Ip::Address &peer, const Ip::Address &me, int fd, http_port_list *port);
 
 
 int
@@ -2426,10 +2426,10 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      * If transparent or interception mode is working clone the transparent and interception flags
      * from the port settings to the request.
      */
-    if (IpInterceptor.InterceptActive()) {
+    if (Ip::Interceptor.InterceptActive()) {
         request->flags.intercepted = http->flags.intercepted;
     }
-    if (IpInterceptor.TransparentActive()) {
+    if (Ip::Interceptor.TransparentActive()) {
         request->flags.spoof_client_ip = conn->port->spoof_client_ip;
     }
 
@@ -3010,7 +3010,7 @@ clientLifetimeTimeout(int fd, void *data)
 }
 
 ConnStateData *
-connStateCreate(const IpAddress &peer, const IpAddress &me, int fd, http_port_list *port)
+connStateCreate(const Ip::Address &peer, const Ip::Address &me, int fd, http_port_list *port)
 {
     ConnStateData *result = new ConnStateData;
 
@@ -3023,9 +3023,9 @@ connStateCreate(const IpAddress &peer, const IpAddress &me, int fd, http_port_li
     result->port = cbdataReference(port);
 
     if (port->intercepted || port->spoof_client_ip) {
-        IpAddress client, dst;
+        Ip::Address client, dst;
 
-        if (IpInterceptor.NatLookup(fd, me, peer, client, dst) == 0) {
+        if (Ip::Interceptor.NatLookup(fd, me, peer, client, dst) == 0) {
             result->me = client;
             result->peer = dst;
             result->transparent(true);
@@ -191,11 +191,11 @@ class ConnStateData : public BodyProducer/*, public RefCountable*/
      */
     ClientSocketContext::Pointer currentobject;
 
-    IpAddress peer;
+    Ip::Address peer;
 
-    IpAddress me;
+    Ip::Address me;
 
-    IpAddress log_addr;
+    Ip::Address log_addr;
     char rfc931[USER_IDENT_SZ];
     int nrequests;
 
@@ -38,33 +38,34 @@
 
 /* old includes without reasons given. */
 #include "squid.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Gadgets.h"
+#include "auth/UserRequest.h"
+#include "client_side.h"
 #include "client_side_reply.h"
-#include "errorpage.h"
-#include "StoreClient.h"
-#include "Store.h"
-#include "HttpReply.h"
-#include "HttpRequest.h"
-#include "forward.h"
 #include "clientStream.h"
-#include "auth/UserRequest.h"
+#if DELAY_POOLS
+#include "DelayPools.h"
+#endif
+#include "errorpage.h"
 #if USE_SQUID_ESI
 #include "esi/Esi.h"
 #endif
-#include "MemObject.h"
 #include "fde.h"
-#include "acl/FilledChecklist.h"
-#include "acl/Gadgets.h"
-#if DELAY_POOLS
-#include "DelayPools.h"
-#endif
-#include "client_side.h"
+#include "forward.h"
+#include "HttpReply.h"
+#include "HttpRequest.h"
+#include "ip/QosConfig.h"
+#include "MemObject.h"
 #include "SquidTime.h"
+#include "StoreClient.h"
+#include "Store.h"
 
 CBDATA_CLASS_INIT(clientReplyContext);
 
 /* Local functions */
 extern "C" CSS clientReplyStatus;
-extern ErrorState *clientBuildError(err_type, http_status, char const *, IpAddress &, HttpRequest *);
+extern ErrorState *clientBuildError(err_type, http_status, char const *, Ip::Address &, HttpRequest *);
 
 /* privates */
 
@@ -94,7 +95,7 @@ clientReplyContext::clientReplyContext(ClientHttpRequest *clientContext) : http
 void
 clientReplyContext::setReplyToError(
     err_type err, http_status status, const HttpRequestMethod& method, char const *uri,
-    IpAddress &addr, HttpRequest * failedrequest, const char *unparsedrequest,
+    Ip::Address &addr, HttpRequest * failedrequest, const char *unparsedrequest,
     AuthUserRequest * auth_user_request)
 {
     ErrorState *errstate =
@@ -1672,9 +1673,9 @@ clientReplyContext::doGetMoreData()
         assert(http->out.size == 0);
         assert(http->out.offset == 0);
 #if USE_ZPH_QOS
-        if (Config.zph.tos_local_hit) {
-            debugs(33, 2, "ZPH Local hit, TOS=" << Config.zph.tos_local_hit);
-            comm_set_tos(http->getConn()->fd, Config.zph.tos_local_hit);
+        if (Ip::Qos::TheConfig.tos_local_hit) {
+            debugs(33, 2, "ZPH Local hit, TOS=" << Ip::Qos::TheConfig.tos_local_hit);
+            comm_set_tos(http->getConn()->fd, Ip::Qos::TheConfig.tos_local_hit);
         }
 #endif /* USE_ZPH_QOS */
         localTempBuffer.offset = reqofs;
@@ -1770,7 +1771,7 @@ clientReplyContext::next() const
 void
 clientReplyContext::sendBodyTooLargeError()
 {
-    IpAddress tmp_noaddr;
+    Ip::Address tmp_noaddr;
     tmp_noaddr.SetNoAddr(); // TODO: make a global const
     http->logType = LOG_TCP_DENIED_REPLY;
     ErrorState *err = clientBuildError(ERR_TOO_BIG, HTTP_FORBIDDEN, NULL,
@@ -1844,7 +1845,7 @@ clientReplyContext::processReplyAccessResult(bool accessAllowed)
         if (page_id == ERR_NONE)
             page_id = ERR_ACCESS_DENIED;
 
-        IpAddress tmp_noaddr;
+        Ip::Address tmp_noaddr;
         tmp_noaddr.SetNoAddr();
         err = clientBuildError(page_id, HTTP_FORBIDDEN, NULL,
                                http->getConn() != NULL ? http->getConn()->peer : tmp_noaddr,
@@ -1959,14 +1960,14 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
     if (reqofs==0 && !logTypeIsATcpHit(http->logType)) {
         assert(fd >= 0); // the beginning of this method implies fd may be -1
         int tos = 0;
-        if (Config.zph.tos_sibling_hit && http->request->hier.code==SIBLING_HIT ) {
-            tos = Config.zph.tos_sibling_hit;
+        if (Ip::Qos::TheConfig.tos_sibling_hit && http->request->hier.code==SIBLING_HIT ) {
+            tos = Ip::Qos::TheConfig.tos_sibling_hit;
             debugs(33, 2, "ZPH: Sibling Peer hit with hier.code=" << http->request->hier.code << ", TOS=" << tos);
-        } else if (Config.zph.tos_parent_hit && http->request->hier.code==PARENT_HIT) {
-            tos = Config.zph.tos_parent_hit;
+        } else if (Ip::Qos::TheConfig.tos_parent_hit && http->request->hier.code==PARENT_HIT) {
+            tos = Ip::Qos::TheConfig.tos_parent_hit;
             debugs(33, 2, "ZPH: Parent Peer hit with hier.code=" << http->request->hier.code << ", TOS=" << tos);
-        } else if (Config.zph.preserve_miss_tos && Config.zph.preserve_miss_tos_mask) {
-            tos = fd_table[fd].upstreamTOS & Config.zph.preserve_miss_tos_mask;
+        } else if (Ip::Qos::TheConfig.preserve_miss_tos && Ip::Qos::TheConfig.preserve_miss_tos_mask) {
+            tos = fd_table[fd].upstreamTOS & Ip::Qos::TheConfig.preserve_miss_tos_mask;
             debugs(33, 2, "ZPH: Preserving TOS on miss, TOS="<<tos);
         }
         comm_set_tos(fd,tos);
@@ -2078,7 +2079,7 @@ clientReplyContext::createStoreEntry(const HttpRequestMethod& m, request_flags r
 
 ErrorState *
 clientBuildError(err_type page_id, http_status status, char const *url,
-                 IpAddress &src_addr, HttpRequest * request)
+                 Ip::Address &src_addr, HttpRequest * request)
 {
     ErrorState *err = errorCon(page_id, status, request);
     err->src_addr = src_addr;
@@ -38,7 +38,7 @@
 #include "client_side_request.h"
 
 class ErrorState;
-class IpAddress;
+class Ip::Address;
 
 /* XXX make static method */
 
@@ -72,7 +72,7 @@ class clientReplyContext : public RefCountable, public StoreClient
     int storeOKTransferDone() const;
     int storeNotOKTransferDone() const;
 
-    void setReplyToError(err_type, http_status, const HttpRequestMethod&, char const *, IpAddress &, HttpRequest *, const char *, AuthUserRequest *);
+    void setReplyToError(err_type, http_status, const HttpRequestMethod&, char const *, Ip::Address &, HttpRequest *, const char *, AuthUserRequest *);
     void createStoreEntry(const HttpRequestMethod& m, request_flags flags);
     void removeStoreReference(store_client ** scp, StoreEntry ** ep);
     void removeClientStoreReference(store_client **scp, ClientHttpRequest *http);
@@ -440,7 +440,7 @@ clientFollowXForwardedForCheck(int answer, void *data)
         const char *p;
         const char *asciiaddr;
         int l;
-        IpAddress addr;
+        Ip::Address addr;
         p = request->x_forwarded_for_iterator.termedBuf();
         l = request->x_forwarded_for_iterator.size();
 
@@ -616,7 +616,7 @@ ClientRequestContext::clientAccessCheckDone(int answer)
         clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        IpAddress tmpnoaddr;
+        Ip::Address tmpnoaddr;
         tmpnoaddr.SetNoAddr();
         repContext->setReplyToError(page_id, status,
                                     http->request->method, NULL,
@@ -1518,7 +1518,7 @@ ClientHttpRequest::handleAdaptationFailure(bool bypassable)
     // The original author of the code also wanted to pass an errno to
     // setReplyToError, but it seems unlikely that the errno reflects the
     // true cause of the error at this point, so I did not pass it.
-    IpAddress noAddr;
+    Ip::Address noAddr;
     noAddr.SetNoAddr();
     ConnStateData * c = getConn();
     repContext->setReplyToError(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR,
@@ -209,11 +209,11 @@ class ConnectStateData
 // defaults given by client
     char *host;
     u_short default_port;
-    IpAddress default_addr;
+    Ip::Address default_addr;
     // NP: CANNOT store the default addr:port together as it gets set/reset differently.
 
     DnsLookupDetails dns; ///< host lookup details
-    IpAddress S;
+    Ip::Address S;
     AsyncCall::Pointer callback;
 
     int fd;
@@ -470,7 +470,7 @@ comm_read_cancel(int fd, AsyncCall::Pointer &callback)
  * synchronous wrapper around udp socket functions
  */
 int
-comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, IpAddress &from)
+comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
 {
     statCounter.syscalls.sock.recvfroms++;
     int x = 0;
@@ -494,7 +494,7 @@ comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, IpAddress &from)
 int
 comm_udp_recv(int fd, void *buf, size_t len, int flags)
 {
-    IpAddress nul;
+    Ip::Address nul;
     return comm_udp_recvfrom(fd, buf, len, flags, nul);
 }
 
@@ -521,7 +521,7 @@ comm_has_incomplete_write(int fd)
 u_short
 comm_local_port(int fd)
 {
-    IpAddress temp;
+    Ip::Address temp;
     struct addrinfo *addr = NULL;
     fde *F = &fd_table[fd];
 
@@ -588,7 +588,7 @@ commBind(int s, struct addrinfo &inaddr)
 int
 comm_open(int sock_type,
           int proto,
-          IpAddress &addr,
+          Ip::Address &addr,
           int flags,
           const char *note)
 {
@@ -598,7 +598,7 @@ comm_open(int sock_type,
 int
 comm_open_listener(int sock_type,
                    int proto,
-                   IpAddress &addr,
+                   Ip::Address &addr,
                    int flags,
                    const char *note)
 {
@@ -681,7 +681,7 @@ comm_set_transparent(int fd)
 int
 comm_openex(int sock_type,
             int proto,
-            IpAddress &addr,
+            Ip::Address &addr,
             int flags,
             unsigned char TOS,
             const char *note)
@@ -947,7 +947,7 @@ int
 ConnectStateData::commResetFD()
 {
     struct addrinfo *AI = NULL;
-    IpAddress nul;
+    Ip::Address nul;
     int new_family = AF_UNSPEC;
 
 // XXX: do we have to check this?
@@ -1196,7 +1196,7 @@ int commSetTimeout(int fd, int timeout, AsyncCall::Pointer &callback)
 }
 
 int
-comm_connect_addr(int sock, const IpAddress &address)
+comm_connect_addr(int sock, const Ip::Address &address)
 {
     comm_err_t status = COMM_OK;
     fde *F = &fd_table[sock];
@@ -1544,7 +1544,7 @@ _comm_close(int fd, char const *file, int line)
 /* Send a udp datagram to specified TO_ADDR. */
 int
 comm_udp_sendto(int fd,
-                const IpAddress &to_addr,
+                const Ip::Address &to_addr,
                 const void *buf,
                 int len)
 {
@@ -50,11 +50,11 @@ SQUIDCEXTERN void comm_lingering_close(int fd);
 SQUIDCEXTERN void commConnectStart(int fd, const char *, u_short, CNCB *, void *);
 void commConnectStart(int fd, const char *, u_short, AsyncCall::Pointer &cb);
 
-SQUIDCEXTERN int comm_connect_addr(int sock, const IpAddress &addr);
+SQUIDCEXTERN int comm_connect_addr(int sock, const Ip::Address &addr);
 SQUIDCEXTERN void comm_init(void);
 SQUIDCEXTERN void comm_exit(void);
 
-SQUIDCEXTERN int comm_open(int, int, IpAddress &, int, const char *note);
+SQUIDCEXTERN int comm_open(int, int, Ip::Address &, int, const char *note);
 
 /**
  * Open a port specially bound for listening or sending through a specific port.
@@ -71,16 +71,16 @@ SQUIDCEXTERN int comm_open(int, int, IpAddress &, int, const char *note);
  * (in debugs or cachemgr) will occur in Native IPv4 format.
  * A reconfigure is needed to reset the stored IP in most cases and attempt a port re-open.
  */
-SQUIDCEXTERN int comm_open_listener(int sock_type, int proto, IpAddress &addr, int flags, const char *note);
+SQUIDCEXTERN int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note);
 
-SQUIDCEXTERN int comm_openex(int, int, IpAddress &, int, unsigned char TOS, const char *);
+SQUIDCEXTERN int comm_openex(int, int, Ip::Address &, int, unsigned char TOS, const char *);
 SQUIDCEXTERN u_short comm_local_port(int fd);
 SQUIDCEXTERN int comm_set_tos(int fd, int tos);
 
 SQUIDCEXTERN void commSetSelect(int, unsigned int, PF *, void *, time_t);
 SQUIDCEXTERN void commResetSelect(int);
 
-SQUIDCEXTERN int comm_udp_sendto(int sock, const IpAddress &to, const void *buf, int buflen);
+SQUIDCEXTERN int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
 extern void comm_write(int fd, const char *buf, int len, IOCB *callback, void *callback_data, FREE *func);
 extern void comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE * free_func = NULL);
 SQUIDCEXTERN void comm_write_mbuf(int fd, MemBuf *mb, IOCB * handler, void *handler_data);
@@ -114,7 +114,7 @@ extern void comm_read(int fd, char *buf, int len, IOCB *handler, void *data);
 extern void comm_read(int fd, char *buf, int len, AsyncCall::Pointer &callback);
 extern void comm_read_cancel(int fd, IOCB *callback, void *data);
 extern void comm_read_cancel(int fd, AsyncCall::Pointer &callback);
-extern int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, IpAddress &from);
+extern int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from);
 extern int comm_udp_recv(int fd, void *buf, size_t len, int flags);
 extern ssize_t comm_udp_send(int s, const void *buf, size_t len, int flags);
 extern bool comm_has_incomplete_write(int);
@@ -159,7 +159,7 @@ class VectorPool : public CompositePoolNode
 
     virtual char const *label() const = 0;
 
-    virtual unsigned int makeKey(IpAddress &src_addr) const = 0;
+    virtual unsigned int makeKey(Ip::Address &src_addr) const = 0;
 
     DelaySpec spec;
 
@@ -190,7 +190,7 @@ class IndividualPool : public VectorPool
 
 protected:
     virtual char const *label() const {return "Individual";}
-    virtual unsigned int makeKey(IpAddress &src_addr) const;
+    virtual unsigned int makeKey(Ip::Address &src_addr) const;
 };
 
 /// \ingroup DelayPoolsInternal
@@ -203,7 +203,7 @@ class ClassCNetPool : public VectorPool
 
 protected:
     virtual char const *label() const {return "Network";}
-    virtual unsigned int makeKey (IpAddress &src_addr) const;
+    virtual unsigned int makeKey (Ip::Address &src_addr) const;
 };
 
 /* don't use remote storage for these */
@@ -247,9 +247,9 @@ class ClassCHostPool : public CompositePoolNode
 
     virtual char const *label() const {return "Individual";}
 
-    virtual unsigned int makeKey (IpAddress &src_addr) const;
+    virtual unsigned int makeKey(Ip::Address &src_addr) const;
 
-    unsigned char makeHostKey (IpAddress &src_addr) const;
+    unsigned char makeHostKey(Ip::Address &src_addr) const;
 
     DelaySpec spec;
     VectorMap<unsigned char, ClassCBucket> buckets;
@@ -855,7 +855,7 @@ VectorPool::Id::bytesIn(int qty)
 }
 
 unsigned int
-IndividualPool::makeKey (IpAddress &src_addr) const
+IndividualPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
     if ( !src_addr.IsIPv4() )
@@ -881,7 +881,7 @@ ClassCNetPool::operator delete (void *address)
 }
 
 unsigned int
-ClassCNetPool::makeKey (IpAddress &src_addr) const
+ClassCNetPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
     if ( !src_addr.IsIPv4() )
@@ -954,7 +954,7 @@ ClassCHostPool::keyAllocated (unsigned char const key) const
 }
 
 unsigned char
-ClassCHostPool::makeHostKey (IpAddress &src_addr) const
+ClassCHostPool::makeHostKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
     if ( !src_addr.IsIPv4() )
@@ -967,7 +967,7 @@ ClassCHostPool::makeHostKey (IpAddress &src_addr) const
 }
 
 unsigned int
-ClassCHostPool::makeKey (IpAddress &src_addr) const
+ClassCHostPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
     if ( !src_addr.IsIPv4() )
@@ -137,7 +137,7 @@ struct _nsvc {
 };
 
 struct _ns {
-    IpAddress S;
+    Ip::Address S;
     int nqueries;
     int nreplies;
     nsvc *vc;
@@ -180,7 +180,7 @@ static void idnsSendQuery(idns_query * q);
 static IOCB idnsReadVCHeader;
 static void idnsDoSendQueryVC(nsvc *vc);
 
-static int idnsFromKnownNameserver(IpAddress const &from);
+static int idnsFromKnownNameserver(Ip::Address const &from);
 static idns_query *idnsFindQuery(unsigned short id);
 static void idnsGrokReply(const char *buf, size_t sz);
 static PF idnsRead;
@@ -191,7 +191,7 @@ static void idnsRcodeCount(int, int);
 static void
 idnsAddNameserver(const char *buf)
 {
-    IpAddress A;
+    Ip::Address A;
 
     if (!(A = buf)) {
         debugs(78, 0, "WARNING: rejecting '" << buf << "' as a name server, because it is not a numeric IP address");
@@ -734,7 +734,7 @@ idnsInitVC(int ns)
     nameservers[ns].vc = vc;
     vc->ns = ns;
 
-    IpAddress addr;
+    Ip::Address addr;
 
     if (!Config.Addrs.udp_outgoing.IsNoAddr())
         addr = Config.Addrs.udp_outgoing;
@@ -856,7 +856,7 @@ idnsSendQuery(idns_query * q)
 }
 
 static int
-idnsFromKnownNameserver(IpAddress const &from)
+idnsFromKnownNameserver(Ip::Address const &from)
 {
     int i;
 
@@ -1132,7 +1132,7 @@ idnsRead(int fd, void *data)
     int max = INCOMING_DNS_MAX;
     static char rbuf[SQUID_UDP_SO_RCVBUF];
     int ns;
-    IpAddress from;
+    Ip::Address from;
 
     debugs(78, 3, "idnsRead: starting with FD " << fd);
 
@@ -1143,7 +1143,7 @@ idnsRead(int fd, void *data)
      *  The cause of this is still unknown, however copying the data appears
      *  to allow it to be passed further without this erasure.
      */
-    IpAddress bugbypass;
+    Ip::Address bugbypass;
 
     while (max--) {
         len = comm_udp_recvfrom(fd, rbuf, SQUID_UDP_SO_RCVBUF, 0, bugbypass);
@@ -1359,15 +1359,15 @@ idnsInit(void)
     if (DnsSocketA < 0 && DnsSocketB < 0) {
         int port;
 
-        IpAddress addr; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
+        Ip::Address addr; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
         if (!Config.Addrs.udp_outgoing.IsNoAddr())
             addr = Config.Addrs.udp_outgoing;
         else
             addr = Config.Addrs.udp_incoming;
 
 #if IPV6_SPECIAL_SPLITSTACK
-        IpAddress addr4 = addr;
+        Ip::Address addr4 = addr;
 
         if ( addr.IsAnyAddr() || addr.IsIPv6() ) {
             debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addr);
@@ -1580,7 +1580,7 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
 }
 
 void
-idnsPTRLookup(const IpAddress &addr, IDNSCB * callback, void *data)
+idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 {
     idns_query *q;
 
@@ -179,7 +179,7 @@ lookup(const char *buf)
     int ttl = 0;
     int retry = 0;
     unsigned int i = 0;
-    IpAddress ipa;
+    Ip::Address ipa;
     char ntoabuf[MAX_IPSTRLEN];
     struct addrinfo hints;
     struct addrinfo *AI = NULL;
@@ -374,7 +374,7 @@ squid_res_setservers(int reset)
     int ns6count = 0;
 #endif
 #if HAVE_RES_INIT
-    IpAddress ipa;
+    Ip::Address ipa;
 #ifdef _SQUID_RES_NSADDR_LIST
     extern char *optarg;
 #endif
@@ -135,7 +135,7 @@ class ErrorState
     String dnsError; ///< DNS lookup error message
     time_t ttl;
 
-    IpAddress src_addr;
+    Ip::Address src_addr;
     char *redirect_url;
     ERCB *callback;
     void *callback_data;
@@ -1441,7 +1441,7 @@ ESIContext::freeResources ()
     /* don't touch incoming, it's a pointer into buffered anyway */
 }
 
-extern ErrorState *clientBuildError (err_type, http_status, char const *, IpAddress &, HttpRequest *);
+extern ErrorState *clientBuildError (err_type, http_status, char const *, Ip::Address &, HttpRequest *);
 
 
 /* This can ONLY be used before we have sent *any* data to the client */
@@ -56,7 +56,7 @@
 
 struct arpreq {
 
-    IpAddress arp_pa;   /* protocol address */
+    Ip::Address arp_pa;   /* protocol address */
 
     struct sockaddr arp_ha;   /* hardware address */
     int arp_flags;            /* flags */
@@ -152,14 +152,14 @@ Eui::Eui48::encode(char *buf, const int len)
 
 // return binary representation of the EUI
 bool
-Eui::Eui48::lookup(IpAddress &c)
+Eui::Eui48::lookup(Ip::Address &c)
 {
     struct arpreq arpReq;
 #if !defined(_SQUID_WIN32_)
     struct sockaddr_in *sa = NULL;
 #endif /* !_SQUID_WIN32_ */
 
-    IpAddress ipAddr = c;
+    Ip::Address ipAddr = c;
     ipAddr.SetPort(0);
 
 #if defined(_SQUID_LINUX_)
@@ -8,7 +8,9 @@
 /* EUI-48 is 6 bytes. */
 #define SZ_EUI48_BUF 6
 
-class IpAddress;
+namespace Ip {
+    class Address;
+};
 
 #if HAVE_CSTRING
 #include <cstring>
@@ -63,7 +65,7 @@ class Eui48
     bool encode(char *buf, const int len);
 
     // lookup an EUI-48 / MAC address via ARP
-    bool lookup(IpAddress &c);
+    bool lookup(Ip::Address &c);
 
 private:
     unsigned char eui[SZ_EUI48_BUF];
@@ -36,7 +36,7 @@ Eui::Eui64::encode(char *buf, const int len)
 
 // return binary representation of the EUI
 bool
-Eui::Eui64::lookup(IpAddress &c)
+Eui::Eui64::lookup(Ip::Address &c)
 {
     /* try to short-circuit slow OS lookups by using SLAAC data */
     if (lookupSlaac(c)) return true;
@@ -46,7 +46,7 @@ Eui::Eui64::lookup(IpAddress &c)
 }
 
 bool
-Eui::Eui64::lookupSlaac(IpAddress &c)
+Eui::Eui64::lookupSlaac(Ip::Address &c)
 {
 #if USE_IPV6
     /* RFC 4291 Link-Local unicast addresses which contain SLAAC - usually trustable. */
@@ -65,7 +65,7 @@ Eui::Eui64::lookupSlaac(IpAddress &c)
 
 // return binary representation of the EUI
 bool
-Eui::Eui64::lookupNdp(IpAddress &c)
+Eui::Eui64::lookupNdp(Ip::Address &c)
 {
 #if USE_IPV6
 
@@ -5,7 +5,9 @@
 
 #if USE_SQUID_EUI
 
-class IpAddress;
+namespace Ip {
+    class Address;
+};
 
 #if HAVE_CSTRING
 #include <cstring>
@@ -70,13 +72,13 @@ class Eui64
     bool encode(char *buf, const int len);
 
     // lookup an EUI-64 address via IPv6 SLAAC or NDP
-    bool lookup(IpAddress &c);
+    bool lookup(Ip::Address &c);
 
     // lookup an EUI-64 address via IPv6 NDP
-    bool lookupNdp(IpAddress &c);
+    bool lookupNdp(Ip::Address &c);
 
     // lookup an EUI-64 address via decoding the IPv6 address SLAAC data
-    bool lookupSlaac(IpAddress &c);
+    bool lookupSlaac(Ip::Address &c);
 
 private:
     unsigned char eui[SZ_EUI64_BUF];
@@ -128,7 +128,7 @@ class external_acl
         QUOTE_METHOD_URL
     } quote;
 
-    IpAddress local_addr;
+    Ip::Address local_addr;
 };
 
 struct _external_acl_format {
@@ -55,7 +55,7 @@ class fde
     unsigned int type;
     u_short remote_port;
 
-    IpAddress local_addr;
+    Ip::Address local_addr;
     unsigned char tos;
     int sock_family;
     char ipaddr[MAX_IPSTRLEN];            /* dotted decimal address of peer */
@@ -121,7 +121,7 @@ class fde
         halfClosedReader = NULL;
         // XXX: the following memset may corrupt or leak new or changed members
         memset(this, 0, sizeof(fde));
-        local_addr.SetEmpty(); // IpAddress likes to be setup nicely.
+        local_addr.SetEmpty(); // Ip::Address likes to be setup nicely.
     }
 
 };
@@ -773,9 +773,9 @@ FwdState::connectStart()
     int ctimeout;
     int ftimeout = Config.Timeout.forward - (squid_curtime - start_t);
 
-    IpAddress outgoing;
+    Ip::Address outgoing;
     unsigned short tos;
-    IpAddress client_addr;
+    Ip::Address client_addr;
     assert(fs);
     assert(server_fd == -1);
     debugs(17, 3, "fwdConnectStart: " << url);
@@ -915,7 +915,7 @@ FwdState::connectStart()
     if (!fs->_peer && request->flags.spoof_client_ip) {
         // try to set the outgoing address using TPROXY v2
         // if it fails we abort any further TPROXY actions on this connection
-        if (IpInterceptor.SetTproxy2OutgoingAddr(fd, src) == -1) {
+        if (Ip::Interceptor.SetTproxy2OutgoingAddr(fd, src) == -1) {
             request->flags.spoof_client_ip = 0;
         }
     }
@@ -1197,7 +1197,7 @@ FwdState::reforwardableStatus(http_status s)
  *  -  address of the client for which we made the connection
  */
 void
-FwdState::pconnPush(int fd, const peer *_peer, const HttpRequest *req, const char *domain, IpAddress &client_addr)
+FwdState::pconnPush(int fd, const peer *_peer, const HttpRequest *req, const char *domain, Ip::Address &client_addr)
 {
     if (_peer) {
         fwdPconnPool->push(fd, _peer->name, _peer->http_port, domain, client_addr);
@@ -1311,12 +1311,12 @@ fwdServerFree(FwdServer * fs)
     memFree(fs, MEM_FWD_SERVER);
 }
 
-static IpAddress
+static Ip::Address
 aclMapAddr(acl_address * head, ACLChecklist * ch)
 {
     acl_address *l;
 
-    IpAddress addr;
+    Ip::Address addr;
 
     for (l = head; l; l = l->next) {
         if (!l->aclList || ch->matchAclListFast(l->aclList))
@@ -1344,7 +1344,7 @@ aclMapTOS(acl_tos * head, ACLChecklist * ch)
     return 0;
 }
 
-IpAddress
+Ip::Address
 getOutgoingAddr(HttpRequest * request, struct peer *dst_peer)
 {
     if (request && request->flags.spoof_client_ip) {
@@ -1354,7 +1354,7 @@ getOutgoingAddr(HttpRequest * request, struct peer *dst_peer)
     }
 
     if (!Config.accessList.outgoing_address) {
-        return IpAddress(); // anything will do.
+        return Ip::Address(); // anything will do.
     }
 
     ACLFilledChecklist ch(NULL, request, NULL);
@@ -43,7 +43,7 @@ class FwdState : public RefCountable
     bool checkRetry();
     bool checkRetriable();
     void dispatch();
-    void pconnPush(int fd, const peer *_peer, const HttpRequest *req, const char *domain, IpAddress &client_addr);
+    void pconnPush(int fd, const peer *_peer, const HttpRequest *req, const char *domain, Ip::Address &client_addr);
 
     bool dontRetry() { return flags.dont_retry; }
 
@@ -98,7 +98,7 @@ class FwdState : public RefCountable
         unsigned int forward_completed:1;
     } flags;
 
-    IpAddress src; /* Client address for this connection. Needed for transparent operations. */
+    Ip::Address src; /* Client address for this connection. Needed for transparent operations. */
 
     // NP: keep this last. It plays with private/public
     CBDATA_CLASS2(FwdState);
@@ -524,7 +524,7 @@ fqdncacheHandleReply(void *data, rfc1035_rr * answers, int na, const char *error
  * 			and does not affect the FQDN cache.
  */
 void
-fqdncache_nbgethostbyaddr(IpAddress &addr, FQDNH * handler, void *handlerData)
+fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handlerData)
 {
     fqdncache_entry *f = NULL;
     char name[MAX_IPSTRLEN];
@@ -642,7 +642,7 @@ fqdncache_init(void)
  *
  */
 const char *
-fqdncache_gethostbyaddr(IpAddress &addr, int flags)
+fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
 {
     char name[MAX_IPSTRLEN];
     fqdncache_entry *f = NULL;
@@ -747,7 +747,7 @@ dummy_handler(const char *, const DnsLookupDetails &, void *)
 
 /// \ingroup FQDNCacheAPI
 const char *
-fqdnFromAddr(IpAddress &addr)
+fqdnFromAddr(const Ip::Address &addr)
 {
     const char *n;
     static char buf[MAX_IPSTRLEN];
@@ -2297,7 +2297,7 @@ ftpReadEPSV(FtpStateData* ftpState)
     char h1, h2, h3, h4;
     int n;
     u_short port;
-    IpAddress ipa_remote;
+    Ip::Address ipa_remote;
     int fd = ftpState->data.fd;
     char *buf;
     debugs(9, 3, HERE);
@@ -2418,7 +2418,7 @@ ftpReadEPSV(FtpStateData* ftpState)
 static void
 ftpSendPassive(FtpStateData * ftpState)
 {
-    IpAddress addr;
+    Ip::Address addr;
     struct addrinfo *AI = NULL;
 
     /** Checks the server control channel is still available before running. */
@@ -2603,7 +2603,7 @@ ftpReadPasv(FtpStateData * ftpState)
     int p1, p2;
     int n;
     u_short port;
-    IpAddress ipa_remote;
+    Ip::Address ipa_remote;
     int fd = ftpState->data.fd;
     char *buf;
     LOCAL_ARRAY(char, ipaddr, 1024);
@@ -2709,8 +2709,7 @@ static int
 ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
 {
     int fd;
-
-    IpAddress addr;
+    Ip::Address addr;
     struct addrinfo *AI = NULL;
     int on = 1;
     int x = 0;
@@ -2780,8 +2779,7 @@ static void
 ftpSendPORT(FtpStateData * ftpState)
 {
     int fd;
-
-    IpAddress ipa;
+    Ip::Address ipa;
     struct addrinfo *AI = NULL;
     unsigned char *addrptr;
     unsigned char *portptr;
@@ -2852,7 +2850,7 @@ static void
 ftpSendEPRT(FtpStateData * ftpState)
 {
     int fd;
-    IpAddress addr;
+    Ip::Address addr;
     struct addrinfo *AI = NULL;
     char buf[MAX_IPSTRLEN];
 
@@ -2865,10 +2863,10 @@ ftpSendEPRT(FtpStateData * ftpState)
     ftpState->flags.pasv_supported = 0;
     fd = ftpOpenListenSocket(ftpState, 0);
 
-    addr.InitAddrInfo(AI);
+    Ip::Address::InitAddrInfo(AI);
 
     if (getsockname(fd, AI->ai_addr, &AI->ai_addrlen)) {
-        addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         debugs(9, DBG_CRITICAL, HERE << "getsockname(" << fd << ",..): " << xstrerror());
 
         /* XXX Need to set error message */
@@ -2888,7 +2886,7 @@ ftpSendEPRT(FtpStateData * ftpState)
     ftpState->writeCommand(cbuf);
     ftpState->state = SENT_EPRT;
 
-    addr.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 }
 
 static void
@@ -114,9 +114,6 @@ extern "C" {
 
     extern struct acl_deny_info_list *DenyInfoList;	/* NULL */
 
-//MOVED:icp_v2.cc    extern IpAddress theOutICPAddr;
-//MOVED:snmp_core.cc    extern IpAddress theOutSNMPAddr;
-
     extern struct timeval squid_start;
     extern int starting_up;	/* 1 */
     extern int shutting_down;	/* 0 */
@@ -59,7 +59,7 @@ class helper
     const char *id_name;
     HelperChildConfig childs;    ///< Configuration settings for number running.
     int ipc_type;
-    IpAddress addr;
+    Ip::Address addr;
     time_t last_queue_warn;
     time_t last_restart;
 
@@ -97,7 +97,7 @@ class HelperServerBase
 public:
     int index;
     int pid;
-    IpAddress addr;
+    Ip::Address addr;
     int rfd;
     int wfd;
     void *hIpc;
@@ -153,8 +153,8 @@ class htcpSpecifier : public StoreClient
     void checkHit();
     void checkedHit(StoreEntry *e);
 
-    void setFrom (IpAddress &from);
-    void setDataHeader (htcpDataHeader *);
+    void setFrom(Ip::Address &from);
+    void setDataHeader(htcpDataHeader *);
     char *method;
     char *uri;
     char *version;
@@ -164,7 +164,7 @@ class htcpSpecifier : public StoreClient
 private:
     HttpRequest *checkHitRequest;
 
-    IpAddress from; // was a ptr. return to such IFF needed. otherwise copy should do.
+    Ip::Address from; // was a ptr. return to such IFF needed. otherwise copy should do.
     htcpDataHeader *dhdr;
 };
 
@@ -232,7 +232,7 @@ static int htcpOutSocket = -1;
 static u_int32_t queried_id[N_QUERIED_KEYS];
 static cache_key queried_keys[N_QUERIED_KEYS][SQUID_MD5_DIGEST_LENGTH];
 
-static IpAddress queried_addr[N_QUERIED_KEYS];
+static Ip::Address queried_addr[N_QUERIED_KEYS];
 static MemAllocator *htcpDetailPool = NULL;
 
 static int old_squid_format = 0;
@@ -251,26 +251,26 @@ static ssize_t htcpBuildTstOpData(char *buf, size_t buflen, htcpStuff * stuff);
 static void htcpFreeSpecifier(htcpSpecifier * s);
 static void htcpFreeDetail(htcpDetail * s);
 
-static void htcpHandleMsg(char *buf, int sz, IpAddress &from);
+static void htcpHandleMsg(char *buf, int sz, Ip::Address &from);
 
-static void htcpLogHtcp(IpAddress &, int, log_type, const char *);
-static void htcpHandleMon(htcpDataHeader *, char *buf, int sz, IpAddress &from);
+static void htcpLogHtcp(Ip::Address &, int, log_type, const char *);
+static void htcpHandleMon(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
-static void htcpHandleNop(htcpDataHeader *, char *buf, int sz, IpAddress &from);
+static void htcpHandleNop(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
-static void htcpHandleSet(htcpDataHeader *, char *buf, int sz, IpAddress &from);
+static void htcpHandleSet(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
-static void htcpHandleTst(htcpDataHeader *, char *buf, int sz, IpAddress &from);
+static void htcpHandleTst(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
 static void htcpRecv(int fd, void *data);
 
-static void htcpSend(const char *buf, int len, IpAddress &to);
+static void htcpSend(const char *buf, int len, Ip::Address &to);
 
-static void htcpTstReply(htcpDataHeader *, StoreEntry *, htcpSpecifier *, IpAddress &);
+static void htcpTstReply(htcpDataHeader *, StoreEntry *, htcpSpecifier *, Ip::Address &);
 
-static void htcpHandleTstRequest(htcpDataHeader *, char *buf, int sz, IpAddress &from);
+static void htcpHandleTstRequest(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
-static void htcpHandleTstResponse(htcpDataHeader *, char *, int, IpAddress &);
+static void htcpHandleTstResponse(htcpDataHeader *, char *, int, Ip::Address &);
 
 static void
 htcpHexdump(const char *tag, const char *s, int sz)
@@ -593,7 +593,7 @@ htcpBuildPacket(char *buf, size_t buflen, htcpStuff * stuff)
 
 static void
 
-htcpSend(const char *buf, int len, IpAddress &to)
+htcpSend(const char *buf, int len, Ip::Address &to)
 {
     int x;
 
@@ -617,13 +617,13 @@ htcpSend(const char *buf, int len, IpAddress &to)
 
 void
 
-htcpSpecifier::setFrom (IpAddress &aSocket)
+htcpSpecifier::setFrom(Ip::Address &aSocket)
 {
     from = aSocket;
 }
 
 void
-htcpSpecifier::setDataHeader (htcpDataHeader *aDataHeader)
+htcpSpecifier::setDataHeader(htcpDataHeader *aDataHeader)
 {
     dhdr = aDataHeader;
 }
@@ -837,7 +837,7 @@ htcpUnpackDetail(char *buf, int sz)
 }
 
 static int
-htcpAccessCheck(acl_access * acl, htcpSpecifier * s, IpAddress &from)
+htcpAccessCheck(acl_access * acl, htcpSpecifier * s, Ip::Address &from)
 {
     /* default deny if no access list present */
     if (!acl)
@@ -851,7 +851,7 @@ htcpAccessCheck(acl_access * acl, htcpSpecifier * s, IpAddress &from)
 }
 
 static void
-htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, IpAddress &from)
+htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Address &from)
 {
     htcpStuff stuff;
     static char pkt[8192];
@@ -940,7 +940,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, IpAddr
 
 static void
 
-htcpClrReply(htcpDataHeader * dhdr, int purgeSucceeded, IpAddress &from)
+htcpClrReply(htcpDataHeader * dhdr, int purgeSucceeded, Ip::Address &from)
 {
     htcpStuff stuff;
     static char pkt[8192];
@@ -977,7 +977,7 @@ htcpClrReply(htcpDataHeader * dhdr, int purgeSucceeded, IpAddress &from)
 
 static void
 
-htcpHandleNop(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
+htcpHandleNop(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
     debugs(31, 3, "htcpHandleNop: Unimplemented");
 }
@@ -1074,7 +1074,7 @@ htcpClrStore(const htcpSpecifier * s)
 
 static void
 
-htcpHandleTst(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
+htcpHandleTst(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
     debugs(31, 3, "htcpHandleTst: sz = " << sz);
 
@@ -1089,12 +1089,12 @@ HtcpReplyData::HtcpReplyData() : hdr(hoHtcpReply)
 
 static void
 
-htcpHandleTstResponse(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
+htcpHandleTstResponse(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
     htcpReplyData htcpReply;
     cache_key *key = NULL;
 
-    IpAddress *peer;
+    Ip::Address *peer;
     htcpDetail *d = NULL;
     char *t;
 
@@ -1161,7 +1161,7 @@ htcpHandleTstResponse(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
 
 static void
 
-htcpHandleTstRequest(htcpDataHeader * dhdr, char *buf, int sz, IpAddress &from)
+htcpHandleTstRequest(htcpDataHeader * dhdr, char *buf, int sz, Ip::Address &from)
 {
     /* buf should be a SPECIFIER */
     htcpSpecifier *s;
@@ -1222,20 +1222,20 @@ htcpSpecifier::checkedHit(StoreEntry *e)
 
 static void
 
-htcpHandleMon(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
+htcpHandleMon(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
     debugs(31, 3, "htcpHandleMon: Unimplemented");
 }
 
 static void
 
-htcpHandleSet(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
+htcpHandleSet(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
     debugs(31, 3, "htcpHandleSet: Unimplemented");
 }
 
 static void
-htcpHandleClr(htcpDataHeader * hdr, char *buf, int sz, IpAddress &from)
+htcpHandleClr(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
     htcpSpecifier *s;
     /* buf[0/1] is reserved and reason */
@@ -1330,7 +1330,7 @@ htcpForwardClr(char *buf, int sz)
  * hands it off to other functions to break apart message-specific data.
  */
 static void
-htcpHandleMsg(char *buf, int sz, IpAddress &from)
+htcpHandleMsg(char *buf, int sz, Ip::Address &from)
 {
     htcpHeader htcpHdr;
     htcpDataHeader hdr;
@@ -1450,7 +1450,7 @@ htcpRecv(int fd, void *data)
 {
     static char buf[8192];
     int len;
-    static IpAddress from;
+    static Ip::Address from;
 
     /* Receive up to 8191 bytes, leaving room for a null */
 
@@ -1480,7 +1480,7 @@ htcpInit(void)
         return;
     }
 
-    IpAddress incomingAddr = Config.Addrs.udp_incoming;
+    Ip::Address incomingAddr = Config.Addrs.udp_incoming;
     incomingAddr.SetPort(Config.Port.htcp);
 
     enter_suid();
@@ -1499,7 +1499,7 @@ htcpInit(void)
     debugs(31, 1, "Accepting HTCP messages on port " << Config.Port.htcp << ", FD " << htcpInSocket << ".");
 
     if (!Config.Addrs.udp_outgoing.IsNoAddr()) {
-        IpAddress outgoingAddr = Config.Addrs.udp_outgoing;
+        Ip::Address outgoingAddr = Config.Addrs.udp_outgoing;
         outgoingAddr.SetPort(Config.Port.htcp);
 
         enter_suid();
@@ -1701,7 +1701,7 @@ htcpSocketClose(void)
 }
 
 static void
-htcpLogHtcp(IpAddress &caddr, int opcode, log_type logcode, const char *url)
+htcpLogHtcp(Ip::Address &caddr, int opcode, log_type logcode, const char *url)
 {
     AccessLogEntry al;
     if (LOG_TAG_NONE == logcode)
@@ -34,7 +34,7 @@
 
 #include "HttpHeader.h"
 
-class IpAddress;
+class Ip::Address;
 
 /// \ingroup ServerProtocolHTCP
 class HtcpReplyData
@@ -59,7 +59,7 @@ class HtcpReplyData
 typedef class HtcpReplyData htcpReplyData;
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void neighborsHtcpReply(const cache_key *, htcpReplyData *, const IpAddress &);
+SQUIDCEXTERN void neighborsHtcpReply(const cache_key *, htcpReplyData *, const Ip::Address &);
 
 /// \ingroup ServerProtocolHTCP
 SQUIDCEXTERN void htcpInit(void);
@@ -1291,7 +1291,7 @@ void
 HttpStateData::processReplyBody()
 {
     AsyncCall::Pointer call;
-    IpAddress client_addr;
+    Ip::Address client_addr;
     bool ispinned = false;
 
     if (!flags.headers_parsed) {
@@ -107,7 +107,7 @@ Icmp::ipHops(int ttl)
 }
 
 void
-Icmp::Log(const IpAddress &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops)
+Icmp::Log(const Ip::Address &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops)
 {
     debugs(42, 2, "pingerLog: " << std::setw(9) << current_time.tv_sec  <<
            "." << std::setfill('0') << std::setw(6) <<
@@ -47,15 +47,15 @@
 
 /* This is a line-data format struct. DO NOT alter. */
 struct pingerEchoData {
-    IpAddress to;
+    Ip::Address to;
     unsigned char opcode;
     int psize;
     char payload[PINGER_PAYLOAD_SZ];
 };
 
 /* This is a line-data format struct. DO NOT alter. */
 struct pingerReplyData {
-    IpAddress from;
+    Ip::Address from;
     unsigned char opcode;
     int rtt;
     int hops;
@@ -109,7 +109,7 @@ class Icmp
      *                Content longer than MAX_PAYLOAD will be truncated.
      \param len       Length of the payload in bytes if any is to be sent or 0.
      */
-    virtual void SendEcho(IpAddress &to, int opcode, const char *payload=NULL, int len=0) =0;
+    virtual void SendEcho(Ip::Address &to, int opcode, const char *payload=NULL, int len=0) =0;
 
     /// Handle ICMP responses.
     virtual void Recv(void) =0;
@@ -137,7 +137,7 @@ class Icmp
     int ipHops(int ttl);
 
     /// Log the packet.
-    void Log(const IpAddress &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops);
+    void Log(const Ip::Address &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops);
 
     /* no use wasting memory */
     int icmp_sock;
@@ -90,7 +90,7 @@ Icmp4::Open(void)
 }
 
 void
-Icmp4::SendEcho(IpAddress &to, int opcode, const char *payload, int len)
+Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
 {
     int x;
     LOCAL_ARRAY(char, pkt, MAX_PKT4_SZ);
@@ -167,7 +167,7 @@ class Icmp4 : public Icmp
     virtual int Open();
 
 #if USE_ICMP
-    virtual void SendEcho(IpAddress &, int, const char*, int);
+    virtual void SendEcho(Ip::Address &, int, const char*, int);
     virtual void Recv(void);
 #endif
 };
@@ -133,7 +133,7 @@ Icmp6::Open(void)
  * Generates an RFC 4443 Icmp6 ECHO Packet and sends into the network.
  */
 void
-Icmp6::SendEcho(IpAddress &to, int opcode, const char *payload, int len)
+Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
 {
     int x;
     LOCAL_ARRAY(char, pkt, MAX_PKT6_SZ);
@@ -76,7 +76,7 @@ class Icmp6 : public Icmp
     virtual int Open();
 
 #if USE_ICMP
-    virtual void SendEcho(IpAddress &, int, const char*, int);
+    virtual void SendEcho(Ip::Address &, int, const char*, int);
     virtual void Recv(void);
 #endif
 };
@@ -62,7 +62,7 @@ class IcmpPinger : public Icmp
 
 private:
     // unused in IcmpPinger
-    virtual void SendEcho(IpAddress &to, int opcode, const char *payload, int len) {};
+    virtual void SendEcho(Ip::Address &to, int opcode, const char *payload, int len) {};
 
     /**
      * Control channel(s) to squid.
@@ -69,7 +69,7 @@ IcmpSquid::~IcmpSquid()
 #if USE_ICMP
 
 void
-IcmpSquid::SendEcho(IpAddress &to, int opcode, const char *payload, int len)
+IcmpSquid::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
 {
     static pingerEchoData pecho;
     int x, slen;
@@ -141,7 +141,7 @@ IcmpSquid::Recv()
     int n;
     static int fail_count = 0;
     pingerReplyData preply;
-    static IpAddress F;
+    static Ip::Address F;
 
     commSetSelect(icmp_sock, COMM_SELECT_READ, icmpSquidRecv, NULL, 0);
     memset(&preply, '\0', sizeof(pingerReplyData));
@@ -196,7 +196,7 @@ IcmpSquid::Recv()
 #endif /* USE_ICMP */
 
 void
-IcmpSquid::DomainPing(IpAddress &to, const char *domain)
+IcmpSquid::DomainPing(Ip::Address &to, const char *domain)
 {
 #if USE_ICMP
     debugs(37, 4, HERE << "'" << domain << "' (" << to << ")");
@@ -211,7 +211,7 @@ IcmpSquid::Open(void)
     const char *args[2];
     int rfd;
     int wfd;
-    IpAddress localhost;
+    Ip::Address localhost;
 
     /* User configured disabled. */
     if (!Config.pinger.enable) {
@@ -52,10 +52,10 @@ class IcmpSquid : public Icmp
     virtual int Open();
     virtual void Close();
 
-    void DomainPing(IpAddress &to, const char *domain);
+    void DomainPing(Ip::Address &to, const char *domain);
 
 #if USE_ICMP
-    virtual void SendEcho(IpAddress &to, int opcode, const char* payload=NULL, int len=0);
+    virtual void SendEcho(Ip::Address &to, int opcode, const char* payload=NULL, int len=0);
     virtual void Recv(void);
 #endif
 };
@@ -82,10 +82,10 @@ typedef struct {
 static hash_table *addr_table = NULL;
 static hash_table *host_table = NULL;
 
-IpAddress networkFromInaddr(const IpAddress &a);
+Ip::Address networkFromInaddr(const Ip::Address &a);
 static void netdbRelease(netdbEntry * n);
 
-static void netdbHashInsert(netdbEntry * n, IpAddress &addr);
+static void netdbHashInsert(netdbEntry * n, Ip::Address &addr);
 static void netdbHashDelete(const char *key);
 static void netdbHostInsert(netdbEntry * n, const char *hostname);
 static void netdbHostDelete(const net_db_name * x);
@@ -110,7 +110,7 @@ static void netdbExchangeDone(void *);
 static wordlist *peer_names = NULL;
 
 static void
-netdbHashInsert(netdbEntry * n, IpAddress &addr)
+netdbHashInsert(netdbEntry * n, Ip::Address &addr)
 {
     networkFromInaddr(addr).NtoA(n->network, MAX_IPSTRLEN);
     n->hash.key = n->network;
@@ -246,7 +246,7 @@ netdbPurgeLRU(void)
 }
 
 static netdbEntry *
-netdbLookupAddr(const IpAddress &addr)
+netdbLookupAddr(const Ip::Address &addr)
 {
     netdbEntry *n;
     char *key = new char[MAX_IPSTRLEN];
@@ -256,7 +256,7 @@ netdbLookupAddr(const IpAddress &addr)
 }
 
 static netdbEntry *
-netdbAdd(IpAddress &addr)
+netdbAdd(Ip::Address &addr)
 {
     netdbEntry *n;
 
@@ -274,7 +274,7 @@ netdbAdd(IpAddress &addr)
 static void
 netdbSendPing(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 {
-    IpAddress addr;
+    Ip::Address addr;
     char *hostname = NULL;
     static_cast<generic_cbdata *>(data)->unwrap(&hostname);
     netdbEntry *n;
@@ -339,10 +339,10 @@ netdbSendPing(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
     xfree(hostname);
 }
 
-IpAddress
-networkFromInaddr(const IpAddress &in)
+Ip::Address
+networkFromInaddr(const Ip::Address &in)
 {
-    IpAddress out;
+    Ip::Address out;
 
     out = in;
 #if USE_IPV6
@@ -535,7 +535,7 @@ netdbReloadState(void)
     netdbEntry *n;
     netdbEntry N;
 
-    IpAddress addr;
+    Ip::Address addr;
     int count = 0;
 
     struct timeval start = current_time;
@@ -676,7 +676,7 @@ netdbFreeNameEntry(void *data)
 static void
 netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 {
-    IpAddress addr;
+    Ip::Address addr;
 
     netdbExchangeState *ex = (netdbExchangeState *)data;
     int rec_sz = 0;
@@ -936,7 +936,7 @@ netdbPingSite(const char *hostname)
 }
 
 void
-netdbHandlePingReply(const IpAddress &from, int hops, int rtt)
+netdbHandlePingReply(const Ip::Address &from, int hops, int rtt)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -983,7 +983,7 @@ netdbFreeMemory(void)
 
 #if 0 // AYJ: Looks to be unused code.
 int
-netdbHops(IpAddress &addr)
+netdbHops(Ip::Address &addr)
 {
 #if USE_ICMP
     netdbEntry *n = netdbLookupAddr(addr);
@@ -1150,7 +1150,7 @@ netdbUpdatePeer(HttpRequest * r, peer * e, int irtt, int ihops)
 }
 
 void
-netdbExchangeUpdatePeer(IpAddress &addr, peer * e, double rtt, double hops)
+netdbExchangeUpdatePeer(Ip::Address &addr, peer * e, double rtt, double hops)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -1192,7 +1192,7 @@ netdbExchangeUpdatePeer(IpAddress &addr, peer * e, double rtt, double hops)
 }
 
 void
-netdbDeleteAddrNetwork(IpAddress &addr)
+netdbDeleteAddrNetwork(Ip::Address &addr)
 {
 #if USE_ICMP
     netdbEntry *n = netdbLookupAddr(addr);
@@ -1213,7 +1213,7 @@ netdbBinaryExchange(StoreEntry * s)
     HttpReply *reply = new HttpReply;
 #if USE_ICMP
 
-    IpAddress addr;
+    Ip::Address addr;
 
     netdbEntry *n;
     int i;
@@ -3,7 +3,10 @@
 
 #include "config.h"
 
-class IpAddress;
+namespace Ip {
+    class Address;
+};
+
 class StoreEntry;
 class HttpRequest;
 
@@ -13,24 +16,20 @@ class HttpRequest;
 
 SQUIDCEXTERN void netdbInit(void);
 
-SQUIDCEXTERN void netdbHandlePingReply(const IpAddress &from, int hops, int rtt);
+SQUIDCEXTERN void netdbHandlePingReply(const Ip::Address &from, int hops, int rtt);
 SQUIDCEXTERN void netdbPingSite(const char *hostname);
 SQUIDCEXTERN void netdbDump(StoreEntry *);
 
-#if 0 // AYJ: Looks to be unused now.
-SQUIDCEXTERN int netdbHops(IpAddress &);
-#endif
-
 SQUIDCEXTERN void netdbFreeMemory(void);
 SQUIDCEXTERN int netdbHostHops(const char *host);
 SQUIDCEXTERN int netdbHostRtt(const char *host);
 SQUIDCEXTERN void netdbUpdatePeer(HttpRequest *, peer * e, int rtt, int hops);
 
-SQUIDCEXTERN void netdbDeleteAddrNetwork(IpAddress &addr);
+SQUIDCEXTERN void netdbDeleteAddrNetwork(Ip::Address &addr);
 SQUIDCEXTERN void netdbBinaryExchange(StoreEntry *);
 SQUIDCEXTERN void netdbExchangeStart(void *);
 
-SQUIDCEXTERN void netdbExchangeUpdatePeer(IpAddress &, peer *, double, double);
+SQUIDCEXTERN void netdbExchangeUpdatePeer(Ip::Address &, peer *, double, double);
 SQUIDCEXTERN peer *netdbClosestParent(HttpRequest *);
 SQUIDCEXTERN void netdbHostData(const char *host, int *samp, int *rtt, int *hops);
 
@@ -1,6 +1,8 @@
 #ifndef SQUID_SRC_TEST_URL_H
 #define SQUID_SRC_TEST_URL_H
 
+#define SQUID_UNIT_TEST 1
+
 #include "Icmp.h"
 #include <cppunit/extensions/HelperMacros.h>
 
@@ -15,7 +17,7 @@ class stubIcmp : public Icmp
     virtual void Close() {};
 
     /// Construct ECHO request
-    virtual void SendEcho(IpAddress &to, int opcode, const char *payload, int len) {};
+    virtual void SendEcho(Ip::Address &to, int opcode, const char *payload, int len) {};
 
     /// Handle ICMP responses.
     virtual void Recv(void) {};
@@ -51,10 +51,10 @@
 #include "rfc1738.h"
 
 /// \ingroup ServerProtocolICPInternal2
-static void icpLogIcp(const IpAddress &, log_type, int, const char *, int);
+static void icpLogIcp(const Ip::Address &, log_type, int, const char *, int);
 
 /// \ingroup ServerProtocolICPInternal2
-static void icpHandleIcpV2(int, IpAddress &, char *, int);
+static void icpHandleIcpV2(int, Ip::Address &, char *, int);
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpCount(void *, int, size_t, int);
@@ -69,7 +69,7 @@ static icpUdpData *IcpQueueHead = NULL;
 static icpUdpData *IcpQueueTail = NULL;
 
 /// \ingroup ServerProtocolICPInternal2
-IpAddress theOutICPAddr;
+Ip::Address theOutICPAddr;
 
 /* icp_common_t */
 _icp_common_t::_icp_common_t() : opcode(ICP_INVALID), version(0), length(0), reqnum(0), flags(0), pad(0), shostid(0)
@@ -174,7 +174,7 @@ ICP2State::created(StoreEntry *newEntry)
 
 /// \ingroup ServerProtocolICPInternal2
 static void
-icpLogIcp(const IpAddress &caddr, log_type logcode, int len, const char *url, int delay)
+icpLogIcp(const Ip::Address &caddr, log_type logcode, int len, const char *url, int delay)
 {
     AccessLogEntry al;
 
@@ -271,7 +271,7 @@ _icp_common_t::createMessage(
 
 int
 icpUdpSend(int fd,
-           const IpAddress &to,
+           const Ip::Address &to,
            icp_common_t * msg,
            log_type logcode,
            int delay)
@@ -381,14 +381,14 @@ icpLogFromICPCode(icp_opcode opcode)
 }
 
 void
-icpCreateAndSend(icp_opcode opcode, int flags, char const *url, int reqnum, int pad, int fd, const IpAddress &from)
+icpCreateAndSend(icp_opcode opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from)
 {
     icp_common_t *reply = _icp_common_t::createMessage(opcode, flags, url, reqnum, pad);
     icpUdpSend(fd, from, reply, icpLogFromICPCode(opcode), 0);
 }
 
 void
-icpDenyAccess(IpAddress &from, char *url, int reqnum, int fd)
+icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd)
 {
     debugs(12, 2, "icpDenyAccess: Access Denied for " << from << " by " << AclMatchedName << ".");
 
@@ -404,7 +404,7 @@ icpDenyAccess(IpAddress &from, char *url, int reqnum, int fd)
 }
 
 int
-icpAccessAllowed(IpAddress &from, HttpRequest * icp_request)
+icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request)
 {
     /* absent an explicit allow, we deny all */
     if (!Config.accessList.icp)
@@ -427,7 +427,7 @@ icpGetUrlToSend(char *url)
 }
 
 HttpRequest *
-icpGetRequest(char *url, int reqnum, int fd, IpAddress &from)
+icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from)
 {
     if (strpbrk(url, w_space)) {
         url = rfc1738_escape(url);
@@ -445,7 +445,7 @@ icpGetRequest(char *url, int reqnum, int fd, IpAddress &from)
 }
 
 static void
-doV2Query(int fd, IpAddress &from, char *buf, icp_common_t header)
+doV2Query(int fd, Ip::Address &from, char *buf, icp_common_t header)
 {
     int rtt = 0;
     int src_rtt = 0;
@@ -496,7 +496,7 @@ doV2Query(int fd, IpAddress &from, char *buf, icp_common_t header)
 }
 
 void
-_icp_common_t::handleReply(char *buf, IpAddress &from)
+_icp_common_t::handleReply(char *buf, Ip::Address &from)
 {
     if (neighbors_do_private_keys && reqnum == 0) {
         debugs(12, 0, "icpHandleIcpV2: Neighbor " << from << " returned reqnum = 0");
@@ -513,7 +513,7 @@ _icp_common_t::handleReply(char *buf, IpAddress &from)
 }
 
 static void
-icpHandleIcpV2(int fd, IpAddress &from, char *buf, int len)
+icpHandleIcpV2(int fd, Ip::Address &from, char *buf, int len)
 {
     if (len <= 0) {
         debugs(12, 3, "icpHandleIcpV2: ICP message is too small");
@@ -565,8 +565,7 @@ icpHandleIcpV2(int fd, IpAddress &from, char *buf, int len)
 static void
 icpPktDump(icp_common_t * pkt)
 {
-
-    IpAddress a;
+    Ip::Address a;
 
     debugs(12, 9, "opcode:     " << std::setw(3) << pkt->opcode  << " " << icp_opcode_str[pkt->opcode]);
     debugs(12, 9, "version: "<< std::left << std::setw(8) << pkt->version);
@@ -585,7 +584,7 @@ icpHandleUdp(int sock, void *data)
 {
     int *N = &incoming_sockets_accepted;
 
-    IpAddress from;
+    Ip::Address from;
     LOCAL_ARRAY(char, buf, SQUID_UDP_SO_RCVBUF);
     int len;
     int icp_version;
@@ -651,8 +650,7 @@ void
 icpConnectionsOpen(void)
 {
     u_int16_t port;
-
-    IpAddress addr;
+    Ip::Address addr;
 
     struct addrinfo *xai = NULL;
     int x;
@@ -56,7 +56,7 @@ class ICP3State : public ICPState, public StoreClient
 
 /// \ingroup ServerProtocolICPInternal3
 static void
-doV3Query(int fd, IpAddress &from, char *buf, icp_common_t header)
+doV3Query(int fd, Ip::Address &from, char *buf, icp_common_t header)
 {
     /* We have a valid packet */
     char *url = buf + sizeof(icp_common_t) + sizeof(u_int32_t);
@@ -109,7 +109,7 @@ ICP3State::created(StoreEntry *newEntry)
 /// \ingroup ServerProtocolICPInternal3
 /* Currently Harvest cached-2.x uses ICP_VERSION_3 */
 void
-icpHandleIcpV3(int fd, IpAddress&from, char *buf, int len)
+icpHandleIcpV3(int fd, Ip::Address &from, char *buf, int len)
 {
     if (len <= 0) {
         debugs(12, 3, "icpHandleIcpV3: ICP message is too small");
@@ -58,9 +58,8 @@ typedef struct _IdentStateData {
     hash_link hash;		/* must be first */
     int fd;			/* IDENT fd */
 
-    IpAddress me;
-
-    IpAddress my_peer;
+    Ip::Address me;
+    Ip::Address my_peer;
     IdentClient *clients;
     char buf[4096];
 } IdentStateData;
@@ -214,7 +213,7 @@ CBDATA_TYPE(IdentStateData);
  * start a TCP connection to the peer host on port 113
  */
 void
-Ident::Start(IpAddress &me, IpAddress &my_peer, IDCB * callback, void *data)
+Ident::Start(Ip::Address &me, Ip::Address &my_peer, IDCB * callback, void *data)
 {
     IdentStateData *state;
     int fd;
@@ -235,7 +234,7 @@ Ident::Start(IpAddress &me, IpAddress &my_peer, IDCB * callback, void *data)
         return;
     }
 
-    IpAddress addr = me;
+    Ip::Address addr = me;
     addr.SetPort(0); // NP: use random port for secure outbound to IDENT_PORT
 
     fd = comm_open_listener(SOCK_STREAM,
@@ -15,7 +15,7 @@
 
 #include "cbdata.h"
 
-class IpAddress;
+class Ip::Address;
 
 namespace Ident
 {
@@ -28,7 +28,7 @@ namespace Ident
  * Self-registers with a global ident lookup manager,
  * will call Ident::Init() itself if the manager has not been initialized already.
  */
-void Start(IpAddress &me, IpAddress &my_peer, IDCB * callback, void *cbdata);
+void Start(Ip::Address &me, Ip::Address &my_peer, IDCB * callback, void *cbdata);
 
 /**
  \ingroup IdentAPI
@@ -103,7 +103,7 @@ internalRemoteUri(const char *host, u_short port, const char *dir, const char *n
 
 #if USE_IPV6
     /* check for an IP address and format appropriately if found */
-    IpAddress test = lc_host;
+    Ip::Address test = lc_host;
     if ( !test.IsAnyAddr() ) {
         test.ToHostname(lc_host,SQUIDHOSTNAMELEN);
     }
@@ -14,7 +14,7 @@
  *  developed and/or copyrighted by other sources.  Please see the
  *  CREDITS file for full details.
  *
- *  This IpAddress code is copyright (C) 2007 by Treehouse Networks Ltd
+ *  This Ip::Address code is copyright (C) 2007 by Treehouse Networks Ltd
  *  of New Zealand. It is published and Lisenced as an extension of
  *  squid under the same conditions as the main squid application.
  *
@@ -70,7 +70,7 @@
 #if USE_IPV6
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("IpAddress invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
+		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
 		printf("ADDRESS:"); \
 		for(unsigned int i = 0; i < sizeof(m_SocketAddr.sin6_addr); i++) { \
 			printf(" %x", m_SocketAddr.sin6_addr.s6_addr[i]); \
@@ -79,24 +79,24 @@
 #else
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("IpAddress invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
+		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
 		printf("ADDRESS: %x\n", (unsigned int)m_SocketAddr.sin_addr.s_addr); \
 		assert(b); \
 	}
 #endif
 
-IpAddress::IpAddress()
+Ip::Address::Address()
 {
     SetEmpty();
 }
 
-IpAddress::~IpAddress()
+Ip::Address::~Address()
 {
-    memset(this,0,sizeof(IpAddress));
+    memset(this,0,sizeof(Ip::Address));
 }
 
 int
-IpAddress::GetCIDR() const
+Ip::Address::GetCIDR() const
 {
     uint8_t shift,byte;
     uint8_t bit,caught;
@@ -145,7 +145,8 @@ IpAddress::GetCIDR() const
     return len;
 }
 
-const int IpAddress::ApplyMask(IpAddress const &mask_addr)
+const int
+Ip::Address::ApplyMask(Ip::Address const &mask_addr)
 {
     uint32_t *p1 = (uint32_t*)(&m_SocketAddr.sin6_addr);
     uint32_t const *p2 = (uint32_t const *)(&mask_addr.m_SocketAddr.sin6_addr);
@@ -165,7 +166,8 @@ const int IpAddress::ApplyMask(IpAddress const &mask_addr)
     return changes;
 }
 
-bool IpAddress::ApplyMask(const unsigned int cidr, int mtype)
+bool
+Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
 {
     uint8_t clearbits = 0;
     uint8_t* p = NULL;
@@ -224,12 +226,14 @@ bool IpAddress::ApplyMask(const unsigned int cidr, int mtype)
     return true;
 }
 
-bool IpAddress::IsSockAddr() const
+bool
+Ip::Address::IsSockAddr() const
 {
     return (m_SocketAddr.sin6_port != 0);
 }
 
-bool IpAddress::IsIPv4() const
+bool
+Ip::Address::IsIPv4() const
 {
 #if USE_IPV6
     return IsAnyAddr() || IsNoAddr() || IN6_IS_ADDR_V4MAPPED( &m_SocketAddr.sin6_addr );
@@ -238,7 +242,8 @@ bool IpAddress::IsIPv4() const
 #endif
 }
 
-bool IpAddress::IsIPv6() const
+bool
+Ip::Address::IsIPv6() const
 {
 #if USE_IPV6
     return IsAnyAddr() || IsNoAddr() || !IN6_IS_ADDR_V4MAPPED( &m_SocketAddr.sin6_addr );
@@ -247,7 +252,8 @@ bool IpAddress::IsIPv6() const
 #endif
 }
 
-bool IpAddress::IsAnyAddr() const
+bool
+Ip::Address::IsAnyAddr() const
 {
 #if USE_IPV6
     return IN6_IS_ADDR_UNSPECIFIED( &m_SocketAddr.sin6_addr );
@@ -257,7 +263,8 @@ bool IpAddress::IsAnyAddr() const
 }
 
 /// NOTE: Does NOT clear the Port stored. Ony the Address and Type.
-void IpAddress::SetAnyAddr()
+void
+Ip::Address::SetAnyAddr()
 {
 #if USE_IPV6
     memset(&m_SocketAddr.sin6_addr, 0, sizeof(struct in6_addr) );
@@ -266,26 +273,28 @@ void IpAddress::SetAnyAddr()
 #endif
 }
 
-/// NOTE: completely empties the IpAddress structure. Address, Port, Type, everything.
-void IpAddress::SetEmpty()
+/// NOTE: completely empties the Ip::Address structure. Address, Port, Type, everything.
+void
+Ip::Address::SetEmpty()
 {
     memset(&m_SocketAddr, 0, sizeof(m_SocketAddr) );
 }
 
 #if USE_IPV6
-const struct in6_addr IpAddress::v4_localhost = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+const struct in6_addr Ip::Address::v4_localhost = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x01 }}
 };
-const struct in6_addr IpAddress::v4_anyaddr = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+const struct in6_addr Ip::Address::v4_anyaddr = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}
 };
-const struct in6_addr IpAddress::v6_noaddr = {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+const struct in6_addr Ip::Address::v6_noaddr = {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}
 };
 #endif
 
 
-bool IpAddress::SetIPv4()
+bool
+Ip::Address::SetIPv4()
 {
 #if USE_IPV6
     if ( IsLocalhost() ) {
@@ -308,7 +317,8 @@ bool IpAddress::SetIPv4()
 #endif
 }
 
-bool IpAddress::IsLocalhost() const
+bool
+Ip::Address::IsLocalhost() const
 {
 #if USE_IPV6
     return IN6_IS_ADDR_LOOPBACK( &m_SocketAddr.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_localhost );
@@ -317,7 +327,8 @@ bool IpAddress::IsLocalhost() const
 #endif
 }
 
-void IpAddress::SetLocalhost()
+void
+Ip::Address::SetLocalhost()
 {
 #if USE_IPV6
     m_SocketAddr.sin6_addr = in6addr_loopback;
@@ -328,7 +339,8 @@ void IpAddress::SetLocalhost()
 #endif
 }
 
-bool IpAddress::IsSiteLocal6() const
+bool
+Ip::Address::IsSiteLocal6() const
 {
 #if USE_IPV6
     return IN6_IS_ADDR_SITELOCAL( &m_SocketAddr.sin6_addr );
@@ -337,7 +349,8 @@ bool IpAddress::IsSiteLocal6() const
 #endif
 }
 
-bool IpAddress::IsSlaac() const
+bool
+Ip::Address::IsSlaac() const
 {
 #if USE_IPV6
     return m_SocketAddr.sin6_addr.s6_addr[10] == htons(0xff) &&
@@ -347,7 +360,8 @@ bool IpAddress::IsSlaac() const
 #endif
 }
 
-bool IpAddress::IsNoAddr() const
+bool
+Ip::Address::IsNoAddr() const
 {
     // IFF the address == 0xff..ff (all ones)
 #if USE_IPV6
@@ -357,7 +371,8 @@ bool IpAddress::IsNoAddr() const
 #endif
 }
 
-void IpAddress::SetNoAddr()
+void
+Ip::Address::SetNoAddr()
 {
 #if USE_IPV6
     memset(&m_SocketAddr.sin6_addr, 0xFF, sizeof(struct in6_addr) );
@@ -369,8 +384,8 @@ void IpAddress::SetNoAddr()
 }
 
 #if USE_IPV6
-
-bool IpAddress::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
+bool
+Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
 {
     char *p = buf;
     unsigned char const *r = dat.s6_addr;
@@ -395,10 +410,10 @@ bool IpAddress::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr
 
     return true;
 }
-
 #endif
 
-bool IpAddress::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
+bool
+Ip::Address::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
 {
     unsigned int i = (unsigned int) ntohl(dat.s_addr);
     snprintf(buf, 32, "%u.%u.%u.%u.in-addr.arpa.",
@@ -409,7 +424,8 @@ bool IpAddress::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &
     return true;
 }
 
-bool IpAddress::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
+bool
+Ip::Address::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
 {
 
     if (show_type == AF_UNSPEC) {
@@ -438,29 +454,33 @@ bool IpAddress::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
     return false;
 }
 
-IpAddress& IpAddress::operator =(const IpAddress &s)
+Ip::Address&
+Ip::Address::operator =(const Ip::Address &s)
 {
-    memcpy(this, &s, sizeof(IpAddress));
+    memcpy(this, &s, sizeof(Ip::Address));
     return *this;
 };
 
-IpAddress::IpAddress(const char*s)
+Ip::Address::Address(const char*s)
 {
     SetEmpty();
     operator=(s);
 }
 
-bool IpAddress::operator =(const char* s)
+bool
+Ip::Address::operator =(const char* s)
 {
     return LookupHostIP(s, true);
 }
 
-bool IpAddress::GetHostByName(const char* s)
+bool
+Ip::Address::GetHostByName(const char* s)
 {
     return LookupHostIP(s, false);
 }
 
-bool IpAddress::LookupHostIP(const char *s, bool nodns)
+bool
+Ip::Address::LookupHostIP(const char *s, bool nodns)
 {
     int err = 0;
 
@@ -504,13 +524,14 @@ bool IpAddress::LookupHostIP(const char *s, bool nodns)
     return true;
 }
 
-IpAddress::IpAddress(struct sockaddr_in const &s)
+Ip::Address::Address(struct sockaddr_in const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IpAddress& IpAddress::operator =(struct sockaddr_in const &s)
+Ip::Address &
+Ip::Address::operator =(struct sockaddr_in const &s)
 {
 #if USE_IPV6
     Map4to6((const in_addr)s.sin_addr, m_SocketAddr.sin6_addr);
@@ -527,7 +548,8 @@ IpAddress& IpAddress::operator =(struct sockaddr_in const &s)
     return *this;
 };
 
-IpAddress& IpAddress::operator =(const struct sockaddr_storage &s)
+Ip::Address &
+Ip::Address::operator =(const struct sockaddr_storage &s)
 {
 #if USE_IPV6
     /* some AF_* magic to tell socket types apart and what we need to do */
@@ -544,37 +566,39 @@ IpAddress& IpAddress::operator =(const struct sockaddr_storage &s)
     return *this;
 };
 
-void IpAddress::check4Mapped()
+void
+Ip::Address::check4Mapped()
 {
     // obsolete.
     // TODO use this NOW to set the sin6_family properly on exporting. not on import.
 }
 
 #if USE_IPV6
-IpAddress::IpAddress(struct sockaddr_in6 const &s)
+Ip::Address::Address(struct sockaddr_in6 const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IpAddress& IpAddress::operator =(struct sockaddr_in6 const &s)
+Ip::Address &
+Ip::Address::operator =(struct sockaddr_in6 const &s)
 {
     memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in6));
 
     /* maintain address family properly */
     check4Mapped();
     return *this;
 };
-
 #endif
 
-IpAddress::IpAddress(struct in_addr const &s)
+Ip::Address::Address(struct in_addr const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IpAddress& IpAddress::operator =(struct in_addr const &s)
+Ip::Address &
+Ip::Address::operator =(struct in_addr const &s)
 {
 #if USE_IPV6
     Map4to6((const in_addr)s, m_SocketAddr.sin6_addr);
@@ -593,14 +617,14 @@ IpAddress& IpAddress::operator =(struct in_addr const &s)
 };
 
 #if USE_IPV6
-
-IpAddress::IpAddress(struct in6_addr const &s)
+Ip::Address::Address(struct in6_addr const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IpAddress& IpAddress::operator =(struct in6_addr const &s)
+Ip::Address &
+Ip::Address::operator =(struct in6_addr const &s)
 {
 
     memcpy(&m_SocketAddr.sin6_addr, &s, sizeof(struct in6_addr));
@@ -611,29 +635,29 @@ IpAddress& IpAddress::operator =(struct in6_addr const &s)
 
     return *this;
 };
-
 #endif
 
-IpAddress::IpAddress(const IpAddress &s)
+Ip::Address::Address(const Ip::Address &s)
 {
     SetEmpty();
     operator=(s);
 }
 
-IpAddress::IpAddress(IpAddress *s)
+Ip::Address::Address(Ip::Address *s)
 {
     SetEmpty();
     if (s)
-        memcpy(this, s, sizeof(IpAddress));
+        memcpy(this, s, sizeof(Ip::Address));
 }
 
-IpAddress::IpAddress(const struct hostent &s)
+Ip::Address::Address(const struct hostent &s)
 {
     SetEmpty();
     operator=(s);
 }
 
-bool IpAddress::operator =(const struct hostent &s)
+bool
+Ip::Address::operator =(const struct hostent &s)
 {
 
     struct in_addr* ipv4 = NULL;
@@ -679,13 +703,14 @@ bool IpAddress::operator =(const struct hostent &s)
     return true;
 }
 
-IpAddress::IpAddress(const struct addrinfo &s)
+Ip::Address::Address(const struct addrinfo &s)
 {
     SetEmpty();
     operator=(s);
 }
 
-bool IpAddress::operator =(const struct addrinfo &s)
+bool
+Ip::Address::operator =(const struct addrinfo &s)
 {
 
     struct sockaddr_in* ipv4 = NULL;
@@ -754,7 +779,8 @@ bool IpAddress::operator =(const struct addrinfo &s)
     return true;
 }
 
-void IpAddress::GetAddrInfo(struct addrinfo *&dst, int force) const
+void
+Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
 {
     if (dst == NULL) {
         dst = new addrinfo;
@@ -820,7 +846,8 @@ void IpAddress::GetAddrInfo(struct addrinfo *&dst, int force) const
         }
 }
 
-void IpAddress::InitAddrInfo(struct addrinfo *&ai) const
+void
+Ip::Address::InitAddrInfo(struct addrinfo *&ai)
 {
     if (ai == NULL) {
         ai = new addrinfo;
@@ -837,7 +864,8 @@ void IpAddress::InitAddrInfo(struct addrinfo *&ai) const
 
 }
 
-void IpAddress::FreeAddrInfo(struct addrinfo *&ai) const
+void
+Ip::Address::FreeAddrInfo(struct addrinfo *&ai)
 {
     if (ai == NULL) return;
 
@@ -853,7 +881,8 @@ void IpAddress::FreeAddrInfo(struct addrinfo *&ai) const
     ai = NULL;
 }
 
-int IpAddress::matchIPAddr(const IpAddress &rhs) const
+int
+Ip::Address::matchIPAddr(const Ip::Address &rhs) const
 {
 #if USE_IPV6
     uint8_t *l = (uint8_t*)m_SocketAddr.sin6_addr.s6_addr;
@@ -878,54 +907,62 @@ int IpAddress::matchIPAddr(const IpAddress &rhs) const
     return 0;
 }
 
-bool IpAddress::operator ==(const IpAddress &s) const
+bool
+Ip::Address::operator ==(const Ip::Address &s) const
 {
     return (0 == matchIPAddr(s));
 }
 
-bool IpAddress::operator !=(const IpAddress &s) const
+bool
+Ip::Address::operator !=(const Ip::Address &s) const
 {
     return ! ( operator==(s) );
 }
 
-bool IpAddress::operator <=(const IpAddress &rhs) const
+bool
+Ip::Address::operator <=(const Ip::Address &rhs) const
 {
     if (IsAnyAddr() && !rhs.IsAnyAddr())
         return true;
 
     return (matchIPAddr(rhs) <= 0);
 }
 
-bool IpAddress::operator >=(const IpAddress &rhs) const
+bool
+Ip::Address::operator >=(const Ip::Address &rhs) const
 {
     if (IsNoAddr() && !rhs.IsNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) >= 0);
 }
 
-bool IpAddress::operator >(const IpAddress &rhs) const
+bool
+Ip::Address::operator >(const Ip::Address &rhs) const
 {
     if (IsNoAddr() && !rhs.IsNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) > 0);
 }
 
-bool IpAddress::operator <(const IpAddress &rhs) const
+bool
+Ip::Address::operator <(const Ip::Address &rhs) const
 {
     if (IsNoAddr() && !rhs.IsNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) < 0);
 }
 
-u_short IpAddress::GetPort() const
+u_short
+Ip::Address::GetPort() const
 {
     return ntohs( m_SocketAddr.sin6_port );
 }
 
-u_short IpAddress::SetPort(u_short prt)
+u_short
+Ip::Address::SetPort(u_short prt)
 {
     m_SocketAddr.sin6_port = htons(prt);
 
@@ -942,7 +979,8 @@ u_short IpAddress::SetPort(u_short prt)
  *
  * A copy of the buffer is also returned for simple immediate display.
  */
-char* IpAddress::NtoA(char* buf, const unsigned int blen, int force) const
+char *
+Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
 {
     // Ensure we have a buffer.
     if (buf == NULL) {
@@ -997,7 +1035,8 @@ char* IpAddress::NtoA(char* buf, const unsigned int blen, int force) const
     return buf;
 }
 
-unsigned int IpAddress::ToHostname(char *buf, const unsigned int blen) const
+unsigned int
+Ip::Address::ToHostname(char *buf, const unsigned int blen) const
 {
     char *p = buf;
 
@@ -1028,7 +1067,8 @@ unsigned int IpAddress::ToHostname(char *buf, const unsigned int blen) const
     return (p - buf);
 }
 
-char* IpAddress::ToURL(char* buf, unsigned int blen) const
+char *
+Ip::Address::ToURL(char* buf, unsigned int blen) const
 {
     char *p = buf;
 
@@ -1051,13 +1091,14 @@ char* IpAddress::ToURL(char* buf, unsigned int blen) const
     return buf;
 }
 
-void IpAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) const
+void
+Ip::Address::GetSockAddr(struct sockaddr_storage &addr, const int family) const
 {
     struct sockaddr_in *sin = NULL;
 
     if ( family == AF_INET && !IsIPv4()) {
         // FIXME INET6: caller using the wrong socket type!
-        debugs(14, DBG_CRITICAL, HERE << "IpAddress::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
+        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
         assert(false);
     }
 
@@ -1077,7 +1118,8 @@ void IpAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) con
 #endif /* USE_IPV6 */
 }
 
-void IpAddress::GetSockAddr(struct sockaddr_in &buf) const
+void
+Ip::Address::GetSockAddr(struct sockaddr_in &buf) const
 {
 #if USE_IPV6
 
@@ -1086,7 +1128,7 @@ void IpAddress::GetSockAddr(struct sockaddr_in &buf) const
         buf.sin_port = m_SocketAddr.sin6_port;
         Map6to4( m_SocketAddr.sin6_addr, buf.sin_addr);
     } else {
-        debugs(14, DBG_CRITICAL, HERE << "IpAddress::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
+        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
 
         memset(&buf,0xFFFFFFFF,sizeof(struct sockaddr_in));
         assert(false);
@@ -1110,8 +1152,8 @@ void IpAddress::GetSockAddr(struct sockaddr_in &buf) const
 }
 
 #if USE_IPV6
-
-void IpAddress::GetSockAddr(struct sockaddr_in6 &buf) const
+void
+Ip::Address::GetSockAddr(struct sockaddr_in6 &buf) const
 {
     memcpy(&buf, &m_SocketAddr, sizeof(struct sockaddr_in6));
     /* maintain address family. It may have changed inside us. */
@@ -1122,12 +1164,11 @@ void IpAddress::GetSockAddr(struct sockaddr_in6 &buf) const
     buf.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 }
-
 #endif
 
 #if USE_IPV6
-
-void IpAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const
+void
+Ip::Address::Map4to6(const struct in_addr &in, struct in6_addr &out) const
 {
     /* check for special cases */
 
@@ -1149,7 +1190,8 @@ void IpAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const
     }
 }
 
-void IpAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const
+void
+Ip::Address::Map6to4(const struct in6_addr &in, struct in_addr &out) const
 {
     /* ANYADDR */
     /* NOADDR */
@@ -1162,17 +1204,15 @@ void IpAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const
     ((uint8_t *)&out.s_addr)[3] = in.s6_addr[15];
 }
 
-#endif
-
-#if USE_IPV6
-void IpAddress::GetInAddr(in6_addr &buf) const
+void
+Ip::Address::GetInAddr(in6_addr &buf) const
 {
     memcpy(&buf, &m_SocketAddr.sin6_addr, sizeof(struct in6_addr));
 }
-
 #endif
 
-bool IpAddress::GetInAddr(struct in_addr &buf) const
+bool
+Ip::Address::GetInAddr(struct in_addr &buf) const
 {
 
 #if USE_IPV6
@@ -1191,7 +1231,7 @@ bool IpAddress::GetInAddr(struct in_addr &buf) const
     // default:
     // non-compatible IPv6 Pure Address
 
-    debugs(14,1, HERE << "IpAddress::GetInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
+    debugs(14,1, HERE << "Ip::Address::GetInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
     memset(&buf,0xFFFFFFFF,sizeof(struct in_addr));
     assert(false);
     return false;
@@ -14,7 +14,7 @@
  *  developed and/or copyrighted by other sources.  Please see the
  *  CREDITS file for full details.
  *
- *  This IpAddress code is copyright (C) 2007 by Treehouse Networks Ltd
+ *  This Ip::Address code is copyright (C) 2007 by Treehouse Networks Ltd
  *  of New Zealand. It is published and Lisenced as an extension of
  *  squid under the same conditions as the main squid application.
  *
@@ -33,8 +33,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-#ifndef _INC_IPADDRESS_H
-#define _INC_IPADDRESS_H
+#ifndef _SQUID_IP_IPADDRESS_H
+#define _SQUID_IP_IPADDRESS_H
 
 #include "config.h"
 
@@ -58,6 +58,8 @@
 #include <ostream>
 #endif
 
+namespace Ip {
+
 /* FreeBSD hack:
  *   This OS has at least one version that defines these as private
  *   kernel macros commented as being 'non-standard'.
@@ -90,14 +92,14 @@
 /**
  * Holds and manipulates IPv4, IPv6, and Socket Addresses.
  */
-class IpAddress
+class Address
 {
 
 public:
     /** @name Constructors and Destructor */
     /*@{*/
-    IpAddress();
-    IpAddress(const IpAddress &);
+    Address();
+    Address(const Address &);
 
     /**
      * This constructor takes its own copy of the object pointed to for memory-safe usage later.
@@ -106,34 +108,34 @@ class IpAddress
      \deprecated Use of pointers can be nasty. Consider this a last-resort.
      *           Prefer the by-reference (&) version instead.
      */
-    IpAddress(IpAddress *);
+    Address(Address *);
 
-    IpAddress(const struct in_addr &);
+    Address(const struct in_addr &);
 
-    IpAddress(const struct sockaddr_in &);
+    Address(const struct sockaddr_in &);
 #if USE_IPV6
 
-    IpAddress(const struct in6_addr &);
+    Address(const struct in6_addr &);
 
-    IpAddress(const struct sockaddr_in6 &);
+    Address(const struct sockaddr_in6 &);
 #endif
 
-    IpAddress(const struct hostent &);
-    IpAddress(const struct addrinfo &);
-    IpAddress(const char*);
+    Address(const struct hostent &);
+    Address(const struct addrinfo &);
+    Address(const char*);
     /// Default destructor.
-    ~IpAddress();
+    ~Address();
     /*@}*/
 
     /** @name Assignment Operators */
     /*@{*/
-    IpAddress& operator =(const IpAddress &s);
-    IpAddress& operator =(struct sockaddr_in const &s);
-    IpAddress& operator =(struct sockaddr_storage const &s);
-    IpAddress& operator =(struct in_addr const &s);
+    Address& operator =(const Address &s);
+    Address& operator =(struct sockaddr_in const &s);
+    Address& operator =(struct sockaddr_storage const &s);
+    Address& operator =(struct in_addr const &s);
 #if USE_IPV6
-    IpAddress& operator =(struct in6_addr const &s);
-    IpAddress& operator =(struct sockaddr_in6 const &s);
+    Address& operator =(struct in6_addr const &s);
+    Address& operator =(struct sockaddr_in6 const &s);
 #endif
     bool operator =(const struct hostent &s);
     bool operator =(const struct addrinfo &s);
@@ -142,12 +144,12 @@ class IpAddress
 
     /** @name Boolean Operators */
     /*@{*/
-    bool operator ==(IpAddress const &s) const;
-    bool operator !=(IpAddress const &s) const;
-    bool operator >=(IpAddress const &rhs) const;
-    bool operator <=(IpAddress const &rhs) const;
-    bool operator >(IpAddress const &rhs) const;
-    bool operator <(IpAddress const &rhs) const;
+    bool operator ==(Address const &s) const;
+    bool operator !=(Address const &s) const;
+    bool operator >=(Address const &rhs) const;
+    bool operator <=(Address const &rhs) const;
+    bool operator >(Address const &rhs) const;
+    bool operator <(Address const &rhs) const;
 
 public:
     /* methods */
@@ -174,7 +176,7 @@ class IpAddress
     bool IsSockAddr() const;
 
     /** Content-neutral test for whether the specific IP case ANY_ADDR is stored.
-     *  This is the default content of a new undefined IpAddress object.
+     *  This is the default content of a new undefined Ip::Address object.
      \retval true IPv4 0.0.0.0
      \retval true IPv6 ::
      \retval false anything else.
@@ -189,7 +191,7 @@ class IpAddress
     bool IsNoAddr() const;
 
     /** Content-neutral test for whether the specific IP case LOCALHOST is stored.
-     *  This is the default content of a new undefined IpAddress object.
+     *  This is the default content of a new undefined Ip::Address object.
      \retval true IPv4 127.0.0.1
      \retval true IPv6 ::1
      \retval false anything else.
@@ -257,7 +259,7 @@ class IpAddress
     /** Apply a mask to the stored address.
      \param mask Netmask format to be bit-mask-AND'd over the stored address.
      */
-    const int ApplyMask(const IpAddress &mask);
+    const int ApplyMask(const Address &mask);
 
     /** Apply a mask to the stored address.
      *  CIDR will be converted appropriate to map the stored content.
@@ -316,10 +318,10 @@ class IpAddress
      \retval  1  IP rhs is greater (numerically) than that stored.
      \retval -1  IP rhs is less (numerically) than that stored.
      */
-    int matchIPAddr(const IpAddress &rhs) const;
+    int matchIPAddr(const Address &rhs) const;
 
     /**
-     *  Get RFC 3493 addrinfo structure from the IpAddress data
+     *  Get RFC 3493 addrinfo structure from the Ip::Address data
      *  for protocol-neutral socket operations.
      *  Should be passed a NULL pointer of type struct addrinfo* it will
      *  allocate memory for the structures involved. (see FreeAddrInfo to clear).
@@ -328,7 +330,7 @@ class IpAddress
      *  Some situations may also require an actual call to the system getaddrinfo()
      *  to pull relevant OS details for the socket.
      \par
-     *  IpAddress allocated objects MUST be destructed by IpAddress::FreeAddrInfo
+     *  Ip::Address allocated objects MUST be destructed by Ip::Address::FreeAddrInfo
      *  System getaddrinfo() allocated objects MUST be freed with system freeaddrinfo()
      \par
      *  Some OS require that IPv4 addresses are pre-mapped by the client.
@@ -344,17 +346,17 @@ class IpAddress
 #endif
 
     /**
-     *  Equivalent to the sysem call freeaddrinfo() but for IpAddress allocated data
+     *  Equivalent to the sysem call freeaddrinfo() but for Ip::Address allocated data
      */
-    void FreeAddrInfo(struct addrinfo *&ai) const;
+    static void FreeAddrInfo(struct addrinfo *&ai);
 
     /**
      *  Initializes an empty addrinfo properly for use.
      *  It is intended for use in cases such as getsockopt() where the addrinfo is
      *  about to be changed and the stored details may not match the new ones coming.
      \param ai addrinfo struct to be initialized as AF_UNSPEC with large address buffer
      */
-    void InitAddrInfo(struct addrinfo *&ai) const;
+    static void InitAddrInfo(struct addrinfo *&ai);
 
     /**
      *  Lookup a Host by Name. Equivalent to system call gethostbyname(char*)
@@ -376,18 +378,10 @@ class IpAddress
      */
 
     void GetSockAddr(struct sockaddr_storage &addr, const int family) const;
-
-    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     void GetSockAddr(struct sockaddr_in &) const;
-
-    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     bool GetInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
 #if USE_IPV6
-
-    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     void GetSockAddr(struct sockaddr_in6 &) const;
-
-    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     void GetInAddr(struct in6_addr &) const;
 #endif
 
@@ -412,10 +406,8 @@ class IpAddress
 
     /* variables */
 #if USE_IPV6
-
     struct sockaddr_in6 m_SocketAddr;
 #else
-
     struct sockaddr_in m_SocketAddr;
 #endif
 
@@ -438,23 +430,26 @@ class IpAddress
 
 
 inline std::ostream &
-operator << (std::ostream &os, const IpAddress &ipa)
+operator << (std::ostream &os, const Address &ipa)
 {
     char buf[MAX_IPSTRLEN];
     os << ipa.ToURL(buf,MAX_IPSTRLEN);
     return os;
 }
 
 // WAS _sockaddr_in_list in an earlier incarnation
-class IpAddress_list
+class Address_list
 {
 public:
-    IpAddress_list() { next = NULL; };
-    ~IpAddress_list() { if (next) delete next; next = NULL; };
+    Address_list() { next = NULL; };
+    ~Address_list() { if (next) delete next; next = NULL; };
 
-    IpAddress s;
-    IpAddress_list *next;
+    Address s;
+    Address_list *next;
 };
 
+}; // namespace Ip
+
+extern void parse_IpAddress_list_token(Ip::Address_list **, char *);
 
-#endif /* _INC_IPADDRESS_H */
+#endif /* _SQUID_IP_IPADDRESS_H */
@@ -100,10 +100,10 @@
 
 
 // single global instance for access by other components.
-IpIntercept IpInterceptor;
+Ip::Intercept Ip::Interceptor;
 
 void
-IpIntercept::StopTransparency(const char *str)
+Ip::Intercept::StopTransparency(const char *str)
 {
     if (transparent_active) {
         debugs(89, DBG_IMPORTANT, "Stopping full transparency: " << str);
@@ -112,7 +112,7 @@ IpIntercept::StopTransparency(const char *str)
 }
 
 void
-IpIntercept::StopInterception(const char *str)
+Ip::Intercept::StopInterception(const char *str)
 {
     if (intercept_active) {
         debugs(89, DBG_IMPORTANT, "Stopping IP interception: " << str);
@@ -121,7 +121,7 @@ IpIntercept::StopInterception(const char *str)
 }
 
 int
-IpIntercept::NetfilterInterception(int fd, const IpAddress &me, IpAddress &dst, int silent)
+Ip::Intercept::NetfilterInterception(int fd, const Ip::Address &me, Ip::Address &dst, int silent)
 {
 #if LINUX_NETFILTER
     struct addrinfo *lookup = NULL;
@@ -139,7 +139,7 @@ IpIntercept::NetfilterInterception(int fd, const IpAddress &me, IpAddress &dst,
         dst = *lookup;
     }
 
-    dst.FreeAddrInfo(lookup);
+    Address::FreeAddrInfo(lookup);
 
     if (me != dst) {
         debugs(89, 5, HERE << "address NAT: me= " << me << ", dst= " << dst);
@@ -152,7 +152,7 @@ IpIntercept::NetfilterInterception(int fd, const IpAddress &me, IpAddress &dst,
 }
 
 int
-IpIntercept::NetfilterTransparent(int fd, const IpAddress &me, IpAddress &client, int silent)
+Ip::Intercept::NetfilterTransparent(int fd, const Ip::Address &me, Ip::Address &client, int silent)
 {
 #if LINUX_NETFILTER
 
@@ -171,7 +171,7 @@ IpIntercept::NetfilterTransparent(int fd, const IpAddress &me, IpAddress &client
 }
 
 int
-IpIntercept::IpfwInterception(int fd, const IpAddress &me, IpAddress &dst, int silent)
+Ip::Intercept::IpfwInterception(int fd, const Ip::Address &me, Ip::Address &dst, int silent)
 {
 #if IPFW_TRANSPARENT
     struct addrinfo *lookup = NULL;
@@ -189,7 +189,7 @@ IpIntercept::IpfwInterception(int fd, const IpAddress &me, IpAddress &dst, int s
         dst = *lookup;
     }
 
-    dst.FreeAddrInfo(lookup);
+    Address::FreeAddrInfo(lookup);
 
     if (me != dst) {
         debugs(89, 5, HERE << "address NAT: me= " << me << ", dst= " << dst);
@@ -202,7 +202,7 @@ IpIntercept::IpfwInterception(int fd, const IpAddress &me, IpAddress &dst, int s
 }
 
 int
-IpIntercept::IpfInterception(int fd, const IpAddress &me, IpAddress &client, IpAddress &dst, int silent)
+Ip::Intercept::IpfInterception(int fd, const Ip::Address &me, Ip::Address &client, Ip::Address &dst, int silent)
 {
 #if IPF_TRANSPARENT  /* --enable-ipf-transparent */
 
@@ -299,7 +299,7 @@ IpIntercept::IpfInterception(int fd, const IpAddress &me, IpAddress &client, IpA
 }
 
 int
-IpIntercept::PfInterception(int fd, const IpAddress &me, IpAddress &client, IpAddress &dst, int silent)
+Ip::Intercept::PfInterception(int fd, const Ip::Address &me, Ip::Address &client, Ip::Address &dst, int silent)
 {
 #if PF_TRANSPARENT  /* --enable-pf-transparent */
 
@@ -356,7 +356,7 @@ IpIntercept::PfInterception(int fd, const IpAddress &me, IpAddress &client, IpAd
 
 
 int
-IpIntercept::NatLookup(int fd, const IpAddress &me, const IpAddress &peer, IpAddress &client, IpAddress &dst)
+Ip::Intercept::NatLookup(int fd, const Ip::Address &me, const Ip::Address &peer, Ip::Address &client, Ip::Address &dst)
 {
     /* --enable-linux-netfilter    */
     /* --enable-ipfw-transparent   */
@@ -406,9 +406,9 @@ IpIntercept::NatLookup(int fd, const IpAddress &me, const IpAddress &peer, IpAdd
 
 #if LINUX_TPROXY2
 int
-IpIntercept::SetTproxy2OutgoingAddr(int fd, const IpAddress &src)
+Ip::Intercept::SetTproxy2OutgoingAddr(int fd, const Ip::Address &src)
 {
-    IpAddress addr;
+    Address addr;
     struct in_tproxy itp;
 
     src.GetInAddr(itp.v.addr.faddr);
@@ -440,7 +440,7 @@ IpIntercept::SetTproxy2OutgoingAddr(int fd, const IpAddress &src)
 #endif
 
 bool
-IpIntercept::ProbeForTproxy(IpAddress &test)
+Ip::Intercept::ProbeForTproxy(Ip::Address &test)
 {
     debugs(3, 3, "Detect TPROXY support on port " << test);
 #if LINUX_TPROXY2
@@ -468,7 +468,7 @@ IpIntercept::ProbeForTproxy(IpAddress &test)
         debugs(3, 3, "...Probing for IPv6 TPROXY support.");
 
         struct sockaddr_in6 tmp_ip6;
-        IpAddress tmp = "::2";
+        Ip::Address tmp = "::2";
         tmp.SetPort(0);
         tmp.GetSockAddr(tmp_ip6);
 
@@ -497,7 +497,7 @@ IpIntercept::ProbeForTproxy(IpAddress &test)
         debugs(3, 3, "...Probing for IPv4 TPROXY support.");
 
         struct sockaddr_in tmp_ip4;
-        IpAddress tmp = "127.0.0.2";
+        Ip::Address tmp = "127.0.0.2";
         tmp.SetPort(0);
         tmp.GetSockAddr(tmp_ip4);
 
@@ -4,14 +4,16 @@
  * AUTHOR: Amos Jeffries
  *
  */
-#ifndef SQUID_IPINTERCEPTION_H
-#define SQUID_IPINTERCEPTION_H
-
-class IpAddress;
+#ifndef SQUID_IP_IPINTERCEPT_H
+#define SQUID_IP_IPINTERCEPT_H
 
 /* for time_t */
 #include "SquidTime.h"
 
+namespace Ip {
+
+class Address;
+
 /**
  \defgroup IpInterceptAPI IP Interception and Transparent Proxy API
  \ingroup SquidComponent
@@ -20,19 +22,19 @@ class IpAddress;
  * instead there is this neutral API which other connection state machines
  * and the comm layer use to co-ordinate their own state for transparency.
  */
-class IpIntercept
+class Intercept
 {
 public:
-    IpIntercept() : transparent_active(0), intercept_active(0), last_reported(0) {};
-    ~IpIntercept() {};
+    Intercept() : transparent_active(0), intercept_active(0), last_reported(0) {};
+    ~Intercept() {};
 
     /** Perform NAT lookups */
-    int NatLookup(int fd, const IpAddress &me, const IpAddress &peer, IpAddress &client, IpAddress &dst);
+    int NatLookup(int fd, const Address &me, const Address &peer, Address &client, Address &dst);
 
 #if LINUX_TPROXY2
     // only relevant to TPROXY v2 connections.
     // which require the address be set specifically post-connect.
-    int SetTproxy2OutgoingAddr(int fd, const IpAddress &src);
+    int SetTproxy2OutgoingAddr(int fd, const Address &src);
 #endif
 
     /**
@@ -44,7 +46,7 @@ class IpIntercept
      * \retval true   TPROXY is available.
      * \retval false  TPROXY is not available.
      */
-    bool ProbeForTproxy(IpAddress &test);
+    bool ProbeForTproxy(Address &test);
 
     /**
      \retval 0	Full transparency is disabled.
@@ -103,7 +105,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int NetfilterInterception(int fd, const IpAddress &me, IpAddress &client, int silent);
+    int NetfilterInterception(int fd, const Address &me, Address &client, int silent);
 
     /**
      * perform Lookups on Netfilter fully-transparent interception targets (TPROXY).
@@ -117,7 +119,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int NetfilterTransparent(int fd, const IpAddress &me, IpAddress &dst, int silent);
+    int NetfilterTransparent(int fd, const Address &me, Address &dst, int silent);
 
     /**
      * perform Lookups on IPFW interception.
@@ -131,7 +133,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int IpfwInterception(int fd, const IpAddress &me, IpAddress &client, int silent);
+    int IpfwInterception(int fd, const Address &me, Address &client, int silent);
 
     /**
      * perform Lookups on IPF interception.
@@ -148,7 +150,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int IpfInterception(int fd, const IpAddress &me, IpAddress &client, IpAddress &dst, int silent);
+    int IpfInterception(int fd, const Address &me, Address &client, Address &dst, int silent);
 
     /**
      * perform Lookups on PF interception.
@@ -165,7 +167,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int PfInterception(int fd, const IpAddress &me, IpAddress &client, IpAddress &dst, int silent);
+    int PfInterception(int fd, const Address &me, Address &client, Address &dst, int silent);
 
 
     int transparent_active;
@@ -182,6 +184,8 @@ class IpIntercept
  \ingroup IpInterceptAPI
  * Globally available instance of the IP Interception manager.
  */
-extern IpIntercept IpInterceptor;
+extern Intercept Interceptor;
+
+}; // namespace Ip
 
-#endif /* SQUID_IPINTERCEPTION_H */
+#endif /* SQUID_IP_IPINTERCEPT_H */
@@ -4,7 +4,9 @@
 
 #include "QosConfig.h"
 
-QosConfig::QosConfig() :
+Ip::Qos::QosConfig Ip::Qos::TheConfig;
+
+Ip::Qos::QosConfig::QosConfig() :
         tos_local_hit(0),
         tos_sibling_hit(0),
         tos_parent_hit(0),
@@ -15,7 +17,7 @@ QosConfig::QosConfig() :
 }
 
 void
-QosConfig::parseConfigLine()
+Ip::Qos::QosConfig::parseConfigLine()
 {
     // %i honors 0 and 0x prefixes, which are important for things like umask
     /* parse options ... */
@@ -43,7 +45,7 @@ QosConfig::parseConfigLine()
  * which means no StoreEntry refrences. Just a basic char* buffer.
  */
 void
-QosConfig::dumpConfigLine(char *entry, const char *name) const
+Ip::Qos::QosConfig::dumpConfigLine(char *entry, const char *name) const
 {
     char *p = entry;
     snprintf(p, 10, "%s", name); // strlen("qos_flows ");
@@ -5,6 +5,10 @@
 
 #if USE_ZPH_QOS
 
+namespace Ip {
+
+namespace Qos {
+
 class QosConfig
 {
 public:
@@ -22,6 +26,8 @@ class QosConfig
     void dumpConfigLine(char *entry, const char *name) const;
 };
 
+extern QosConfig TheConfig;
+
 /* legacy parser access wrappers */
 #define parse_QosConfig(X)	(X)->parseConfigLine()
 #define free_QosConfig(X)
@@ -31,5 +37,8 @@ class QosConfig
 	        storeAppendPrintf(e, "%s", temp); \
 	} while(0);
 
+}; // namespace Qos
+}; // namespace Ip
+
 #endif /* USE_ZPH_QOS */
 #endif /* SQUID_QOSCONFIG_H */
@@ -35,7 +35,7 @@ int shutting_down = 0;
 void
 testIpAddress::testDefaults()
 {
-    IpAddress anIPA;
+    Ip::Address anIPA;
 
     /* test stored values */
     CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
@@ -59,7 +59,7 @@ testIpAddress::testInAddrConstructor()
     inval.s_addr = htonl(0xC0A8640C);
     outval.s_addr = htonl(0x00000000);
 
-    IpAddress anIPA(inval);
+    Ip::Address anIPA(inval);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -84,7 +84,7 @@ testIpAddress::testInAddr6Constructor()
     inval.s6_addr32[2] = htonl(0xFFFFFFFF);
     inval.s6_addr32[3] = htonl(0xFFFFFFFF);
 
-    IpAddress anIPA(inval);
+    Ip::Address anIPA(inval);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -114,7 +114,7 @@ testIpAddress::testSockAddrConstructor()
     insock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-    IpAddress anIPA((const struct sockaddr_in)insock);
+    Ip::Address anIPA((const struct sockaddr_in)insock);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -147,7 +147,7 @@ testIpAddress::testSockAddr6Constructor()
     insock.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 
-    IpAddress anIPA((const struct sockaddr_in6)insock);
+    Ip::Address anIPA((const struct sockaddr_in6)insock);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -178,8 +178,8 @@ testIpAddress::testCopyConstructor()
     insock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-    IpAddress inIPA(insock);
-    IpAddress outIPA(inIPA);
+    Ip::Address inIPA(insock);
+    Ip::Address outIPA(inIPA);
 
 
     /* test stored values */
@@ -205,7 +205,7 @@ testIpAddress::testHostentConstructor()
     hp = gethostbyname("192.168.100.12");
     CPPUNIT_ASSERT( hp != NULL /* gethostbyname failure.*/ );
 
-    IpAddress anIPA(*hp);
+    Ip::Address anIPA(*hp);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -226,7 +226,7 @@ testIpAddress::testStringConstructor()
 
     expectval.s_addr = htonl(0xC0A8640C);
 
-    IpAddress anIPA = "192.168.100.12";
+    Ip::Address anIPA = "192.168.100.12";
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -247,7 +247,7 @@ testIpAddress::testStringConstructor()
     expectv6.s6_addr32[2] = htonl(0x00000000);
     expectv6.s6_addr32[3] = htonl(0x00000045);
 
-    IpAddress bnIPA = "2000:800::45";
+    Ip::Address bnIPA = "2000:800::45";
 
     /* test stored values */
     CPPUNIT_ASSERT( !bnIPA.IsAnyAddr() );
@@ -260,7 +260,7 @@ testIpAddress::testStringConstructor()
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 
     /* test IPv6 as an old netmask format. This is invalid but sometimes use. */
-    IpAddress cnIPA = "ffff:ffff:fff0::";
+    Ip::Address cnIPA = "ffff:ffff:fff0::";
 
     expectv6.s6_addr32[0] = htonl(0xFFFFFFFF);
     expectv6.s6_addr32[1] = htonl(0xFFF00000);
@@ -282,7 +282,7 @@ testIpAddress::testStringConstructor()
 void
 testIpAddress::testSetEmpty()
 {
-    IpAddress anIPA;
+    Ip::Address anIPA;
     struct in_addr inval;
 
     inval.s_addr = htonl(0xC0A8640C);
@@ -315,8 +315,8 @@ testIpAddress::testSetEmpty()
 void
 testIpAddress::testBooleans()
 {
-    IpAddress lhsIPA;
-    IpAddress rhsIPA;
+    Ip::Address lhsIPA;
+    Ip::Address rhsIPA;
     struct in_addr valLow;
     struct in_addr valHigh;
 
@@ -363,7 +363,7 @@ testIpAddress::testNtoA()
 {
     struct in_addr inval;
     char buf[MAX_IPSTRLEN];
-    IpAddress anIPA;
+    Ip::Address anIPA;
 
     anIPA.SetAnyAddr();
 
@@ -399,7 +399,7 @@ testIpAddress::testToURL_fromInAddr()
 
     inval.s_addr = htonl(0xC0A8640C);
 
-    IpAddress anIPA(inval);
+    Ip::Address anIPA(inval);
 
     /* test values */
     anIPA.ToURL(buf,MAX_IPSTRLEN);
@@ -415,7 +415,7 @@ testIpAddress::testToURL_fromInAddr()
     ip6val.s6_addr32[2] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[3] = htonl(0xFFFFFFFF);
 
-    IpAddress bnIPA(ip6val);
+    Ip::Address bnIPA(ip6val);
 
     bnIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]", buf, 41) == 0 );
@@ -434,7 +434,7 @@ testIpAddress::testToURL_fromSockAddr()
     sock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-    IpAddress anIPA(sock);
+    Ip::Address anIPA(sock);
     char buf[MAX_IPSTRLEN];
 
     /* test values */
@@ -456,7 +456,7 @@ testIpAddress::testToURL_fromSockAddr()
     ip6val.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 
-    IpAddress bnIPA(ip6val);
+    Ip::Address bnIPA(ip6val);
 
     bnIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]:80", buf, 44) == 0 );
@@ -473,7 +473,7 @@ testIpAddress::testGetReverseString()
     struct in_addr ipv4val;
     ipv4val.s_addr = htonl(0xC0A8640C);
 
-    IpAddress v4IPA(ipv4val);
+    Ip::Address v4IPA(ipv4val);
 
     /* test IPv4 output */
     v4IPA.GetReverseString(buf);
@@ -494,7 +494,7 @@ testIpAddress::testGetReverseString()
     ip6val.s6_addr32[2] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[3] = htonl(0xFFFFFFFF);
 
-    IpAddress v6IPA(ip6val);
+    Ip::Address v6IPA(ip6val);
 
     /* test IPv6 output */
     v6IPA.GetReverseString(buf);
@@ -508,8 +508,8 @@ void
 testIpAddress::testMasking()
 {
     char buf[MAX_IPSTRLEN];
-    IpAddress anIPA;
-    IpAddress maskIPA;
+    Ip::Address anIPA;
+    Ip::Address maskIPA;
 
     /* Test Basic CIDR Routine */
     anIPA.SetAnyAddr();
@@ -548,7 +548,7 @@ testIpAddress::testMasking()
     CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff::", buf, 26) == 0 );
 #endif
 
-    /* Test Network Bitmask from IpAddress */
+    /* Test Network Bitmask from Ip::Address */
     anIPA.SetNoAddr();
     maskIPA = "255.255.240.0";
     CPPUNIT_ASSERT_EQUAL( 20 , maskIPA.GetCIDR() );
@@ -609,7 +609,7 @@ testIpAddress::testAddrInfo()
 
     hints.ai_flags = AI_NUMERICHOST;
 
-    IpAddress anIP = "127.0.0.1";
+    Ip::Address anIP = "127.0.0.1";
 
     /* assert this just to check that getaddrinfo is working properly */
     CPPUNIT_ASSERT( getaddrinfo("127.0.0.1", NULL, &hints, &expect ) == 0 );
@@ -711,7 +711,7 @@ testIpAddress::testBugNullingDisplay()
 
     expectval.s_addr = htonl(0xC0A8640C);
 
-    IpAddress anIPA = "192.168.100.12";
+    Ip::Address anIPA = "192.168.100.12";
 
 
     /* test stored values */
@@ -73,11 +73,11 @@ PutEnvironment()
 }
 
 pid_t
-ipcCreate(int type, const char *prog, const char *const args[], const char *name, IpAddress &local_addr, int *rfd, int *wfd, void **hIpc)
+ipcCreate(int type, const char *prog, const char *const args[], const char *name, Ip::Address &local_addr, int *rfd, int *wfd, void **hIpc)
 {
     pid_t pid;
-    IpAddress ChS;
-    IpAddress PaS;
+    Ip::Address ChS;
+    Ip::Address PaS;
     struct addrinfo *AI = NULL;
     int crfd = -1;
     int prfd = -1;
@@ -47,7 +47,7 @@ struct ipc_params {
     int type;
     int crfd;
     int cwfd;
-    IpAddress local_addr;
+    Ip::Address local_addr;
     struct addrinfo PS;
     const char *prog;
     char **args;
@@ -105,7 +105,7 @@ PutEnvironment()
 }
 
 pid_t
-ipcCreate(int type, const char *prog, const char *const args[], const char *name, IpAddress &local_addr, int *rfd, int *wfd, void **hIpc)
+ipcCreate(int type, const char *prog, const char *const args[], const char *name, Ip::Address &local_addr, int *rfd, int *wfd, void **hIpc)
 {
     unsigned long thread;
 
@@ -115,7 +115,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     DWORD ecode = 0;
     pid_t pid;
 
-    IpAddress tmp_addr;
+    Ip::Address tmp_addr;
     struct addrinfo *aiCS = NULL;
     struct addrinfo *aiPS = NULL;
 
@@ -252,7 +252,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
     }
 
-    /* NP: tmp_addr was left with eiether empty or aiCS in IpAddress format */
+    /* NP: tmp_addr was left with eiether empty or aiCS in Ip::Address format */
     if (comm_connect_addr(pwfd, tmp_addr) == COMM_ERROR) {
         CloseHandle((HANDLE) thread);
         return ipcCloseAllFD(prfd, pwfd, -1, -1);
@@ -377,8 +377,8 @@ ipc_thread_1(void *in_params)
     int prfd_ipc = -1, pwfd_ipc = -1, crfd_ipc = -1, cwfd_ipc = -1;
     char *prog = NULL, *buf1 = NULL;
 
-    IpAddress PS_ipc;
-    IpAddress CS_ipc;
+    Ip::Address PS_ipc;
+    Ip::Address CS_ipc;
     struct addrinfo *aiPS_ipc = NULL;
     struct addrinfo *aiCS_ipc = NULL;
 
@@ -388,8 +388,8 @@ ipc_thread_1(void *in_params)
     int cwfd = params->cwfd;
     char **args = params->args;
 
-    IpAddress PS = params->PS;
-    IpAddress local_addr = params->local_addr;
+    Ip::Address PS = params->PS;
+    Ip::Address local_addr = params->local_addr;
 
     buf1 = (char *)xcalloc(1, 8192);
     strcpy(buf1, params->prog);
@@ -426,7 +426,7 @@ ipcacheParse(ipcache_entry *i, const char *inbuf)
     if (ipcount > 0) {
         int j, k;
 
-        i->addrs.in_addrs = (IpAddress *)xcalloc(ipcount, sizeof(IpAddress));
+        i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(ipcount, sizeof(Ip::Address)));
         for (int l = 0; l < ipcount; l++)
             i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
         i->addrs.bad_mask = (unsigned char *)xcalloc(ipcount, sizeof(unsigned char));
@@ -561,7 +561,7 @@ ipcacheParse(ipcache_entry *i, rfc1035_rr * answers, int nr, const char *error_m
         return 0;
     }
 
-    i->addrs.in_addrs = (IpAddress *)xcalloc(na, sizeof(IpAddress));
+    i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(na, sizeof(Ip::Address)));
     for (int l = 0; l < na; l++)
         i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
     i->addrs.bad_mask = (unsigned char *)xcalloc(na, sizeof(unsigned char));
@@ -787,8 +787,8 @@ ipcache_init(void)
     memset(&lru_list, '\0', sizeof(lru_list));
     memset(&static_addrs, '\0', sizeof(ipcache_addrs));
 
-    static_addrs.in_addrs = (IpAddress *)xcalloc(1, sizeof(IpAddress));
-    static_addrs.in_addrs->SetEmpty(); // properly setup the IpAddress!
+    static_addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(1, sizeof(Ip::Address)));
+    static_addrs.in_addrs->SetEmpty(); // properly setup the Ip::Address!
     static_addrs.bad_mask = (unsigned char *)xcalloc(1, sizeof(unsigned char));
     ipcache_high = (long) (((float) Config.ipcache.size *
                             (float) Config.ipcache.high) / (float) 100);
@@ -959,7 +959,7 @@ stat_ipcache_get(StoreEntry * sentry)
 
 #if DNS_CNAME
 /**
- * Takes two IpAddress arrays and merges them into a single array
+ * Takes two Ip::Address arrays and merges them into a single array
  * which is allocated dynamically to fit the number of unique addresses
  *
  \param aaddrs	One list to merge
@@ -970,22 +970,22 @@ stat_ipcache_get(StoreEntry * sentry)
  \param outlen	Size of list out
  */
 void
-ipcacheMergeIPLists(const IpAddress *aaddrs, const int alen,
-                    const IpAddress *baddrs, const int blen,
-                    IpAddress **out, int &outlen )
+ipcacheMergeIPLists(const Ip::Address *aaddrs, const int alen,
+                    const Ip::Address *baddrs, const int blen,
+                    Ip::Address **out, int &outlen )
 {
     int fc=0, t=0, c=0;
 
-    IpAddress const *ip4ptrs[255];
+    Ip::Address const *ip4ptrs[255];
 #if USE_IPV6
-    IpAddress const *ip6ptrs[255];
+    Ip::Address const *ip6ptrs[255];
 #endif
     int num_ip4 = 0;
     int num_ip6 = 0;
 
-    memset(ip4ptrs, 0, sizeof(IpAddress*)*255);
+    memset(ip4ptrs, 0, sizeof(Ip::Address*)*255);
 #if USE_IPV6
-    memset(ip6ptrs, 0, sizeof(IpAddress*)*255);
+    memset(ip6ptrs, 0, sizeof(Ip::Address*)*255);
 #endif
 
     // for each unique address in list A - grab ptr
@@ -1048,7 +1048,7 @@ ipcacheMergeIPLists(const IpAddress *aaddrs, const int alen,
     debugs(14, 5, "ipcacheMergeIPLists: Merge " << alen << "+" << blen << " into " << fc << " unique IPs.");
 
     // copy the old IPs into the new list buffer.
-    (*out) = (IpAddress*)xcalloc(fc, sizeof(IpAddress));
+    (*out) = static_cast<Ip::Address*>(xcalloc(fc, sizeof(Ip::Address)));
     outlen=0;
 
     assert(out != NULL);
@@ -1079,7 +1079,7 @@ ipcacheHandleCnameRecurse(const ipcache_addrs *addrs, const DnsLookupDetails &,
 #if DNS_CNAME
     ipcache_entry *i = NULL;
     char *pname = NULL;
-    IpAddress *tmpbuf = NULL;
+    Ip::Address *tmpbuf = NULL;
     int fc = 0;
     int ttl = 0;
     generic_cbdata* gcb = (generic_cbdata*)cbdata;
@@ -1214,8 +1214,7 @@ ipcacheInvalidateNegative(const char *name)
 ipcache_addrs *
 ipcacheCheckNumeric(const char *name)
 {
-
-    IpAddress ip;
+    Ip::Address ip;
     /* check if it's already a IP address in text form. */
 
     /* it may be IPv6-wrapped */
@@ -1319,7 +1318,7 @@ ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
  \param addr	specific addres to be marked bad
  */
 void
-ipcacheMarkBadAddr(const char *name, IpAddress &addr)
+ipcacheMarkBadAddr(const char *name, const Ip::Address &addr)
 {
     ipcache_entry *i;
     ipcache_addrs *ia;
@@ -1354,7 +1353,7 @@ ipcacheMarkBadAddr(const char *name, IpAddress &addr)
 
 /// \ingroup IPCacheAPI
 void
-ipcacheMarkGoodAddr(const char *name, IpAddress &addr)
+ipcacheMarkGoodAddr(const char *name, const Ip::Address &addr)
 {
     ipcache_entry *i;
     ipcache_addrs *ia;
@@ -1437,7 +1436,7 @@ ipcacheAddEntryFromHosts(const char *name, const char *ipaddr)
 {
     ipcache_entry *i;
 
-    IpAddress ip;
+    Ip::Address ip;
 
     if (!(ip = ipaddr)) {
 #if USE_IPV6
@@ -1469,7 +1468,7 @@ ipcacheAddEntryFromHosts(const char *name, const char *ipaddr)
     i->addrs.cur = 0;
     i->addrs.badcount = 0;
 
-    i->addrs.in_addrs = (IpAddress *)xcalloc(1, sizeof(IpAddress));
+    i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(1, sizeof(Ip::Address)));
     i->addrs.bad_mask = (unsigned char *)xcalloc(1, sizeof(unsigned char));
     i->addrs.in_addrs[0] = ip;
     i->addrs.bad_mask[0] = FALSE;
@@ -242,7 +242,7 @@ logfile_mod_daemon_open(Logfile * lf, const char *path, size_t bufsz, int fatal_
     lf->data = ll;
     ll->eol = 1;
     {
-        IpAddress localhost;
+        Ip::Address localhost;
         args[0] = "(logfile-daemon)";
         args[1] = path;
         args[2] = NULL;
@@ -148,7 +148,7 @@ logfile_mod_udp_close(Logfile * lf)
 int
 logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_flag)
 {
-    IpAddress addr;
+    Ip::Address addr;
     char *strAddr;
 
     lf->f_close = logfile_mod_udp_close;
@@ -176,7 +176,7 @@ logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
     }
     safe_free(strAddr);
 
-    IpAddress any_addr;
+    Ip::Address any_addr;
     any_addr.SetAnyAddr();
 
 #if USE_IPV6
@@ -67,7 +67,7 @@ static void peerCountMcastPeersStart(void *data);
 static void peerCountMcastPeersSchedule(peer * p, time_t when);
 static IRCB peerCountHandleIcpReply;
 
-static void neighborIgnoreNonPeer(const IpAddress &, icp_opcode);
+static void neighborIgnoreNonPeer(const Ip::Address &, icp_opcode);
 static OBJH neighborDumpPeers;
 static OBJH neighborDumpNonPeers;
 static void dump_peers(StoreEntry * sentry, peer * peers);
@@ -95,7 +95,7 @@ neighborTypeStr(const peer * p)
 
 
 peer *
-whichPeer(const IpAddress &from)
+whichPeer(const Ip::Address &from)
 {
     int j;
 
@@ -554,7 +554,7 @@ neighborsRegisterWithCacheManager()
 void
 neighbors_init(void)
 {
-    IpAddress nul;
+    Ip::Address nul;
     struct addrinfo *AI = NULL;
     struct servent *sep = NULL;
     const char *me = getMyHostname();
@@ -960,7 +960,7 @@ neighborCountIgnored(peer * p)
 static peer *non_peers = NULL;
 
 static void
-neighborIgnoreNonPeer(const IpAddress &from, icp_opcode opcode)
+neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
 {
     peer *np;
 
@@ -1020,7 +1020,7 @@ ignoreMulticastReply(peer * p, MemObject * mem)
  * If a hit process is already started, then sobeit
  */
 void
-neighborsUdpAck(const cache_key * key, icp_common_t * header, const IpAddress &from)
+neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address &from)
 {
     peer *p = NULL;
     StoreEntry *entry;
@@ -1379,7 +1379,7 @@ peerProbeConnect(peer * p)
     if (squid_curtime - p->stats.last_connect_probe == 0)
         return ret;/* don't probe to often */
 
-    IpAddress temp(getOutgoingAddr(NULL,p));
+    Ip::Address temp(getOutgoingAddr(NULL,p));
 
     fd = comm_open(SOCK_STREAM, IPPROTO_TCP, temp, COMM_NONBLOCKING, p->host);
 
@@ -1760,7 +1760,7 @@ dump_peers(StoreEntry * sentry, peer * peers)
 
 #if USE_HTCP
 void
-neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const IpAddress &from)
+neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const Ip::Address &from)
 {
     StoreEntry *e = Store::Root().get(key);
     MemObject *mem = NULL;
@@ -177,7 +177,7 @@ IdleConnList::timeout(int fd, void *data)
 /* ========== PconnPool PRIVATE FUNCTIONS ============================================ */
 
 const char *
-PconnPool::key(const char *host, u_short port, const char *domain, IpAddress &client_address)
+PconnPool::key(const char *host, u_short port, const char *domain, Ip::Address &client_address)
 {
     LOCAL_ARRAY(char, buf, SQUIDHOSTNAMELEN * 3 + 10);
     char ntoabuf[MAX_IPSTRLEN];
@@ -248,7 +248,7 @@ PconnPool::~PconnPool()
 }
 
 void
-PconnPool::push(int fd, const char *host, u_short port, const char *domain, IpAddress &client_address)
+PconnPool::push(int fd, const char *host, u_short port, const char *domain, Ip::Address &client_address)
 {
     IdleConnList *list;
     const char *aKey;
@@ -293,7 +293,7 @@ PconnPool::push(int fd, const char *host, u_short port, const char *domain, IpAd
  * transactions create persistent connections but are not retriable.
  */
 int
-PconnPool::pop(const char *host, u_short port, const char *domain, IpAddress &client_address, bool isRetriable)
+PconnPool::pop(const char *host, u_short port, const char *domain, Ip::Address &client_address, bool isRetriable)
 {
     const char * aKey = key(host, port, domain, client_address);
 
@@ -57,7 +57,7 @@ class IdleConnList
 };
 
 
-class IpAddress;
+class Ip::Address;
 class StoreEntry;
 class IdleConnLimit;
 
@@ -73,16 +73,16 @@ class PconnPool
     ~PconnPool();
 
     void moduleInit();
-    void push(int fd, const char *host, u_short port, const char *domain, IpAddress &client_address);
-    int pop(const char *host, u_short port, const char *domain, IpAddress &client_address, bool retriable);
+    void push(int fd, const char *host, u_short port, const char *domain, Ip::Address &client_address);
+    int pop(const char *host, u_short port, const char *domain, Ip::Address &client_address, bool retriable);
     void count(int uses);
     void dumpHist(StoreEntry *e);
     void dumpHash(StoreEntry *e);
     void unlinkList(IdleConnList *list) const;
 
 private:
 
-    static const char *key(const char *host, u_short port, const char *domain, IpAddress &client_address);
+    static const char *key(const char *host, u_short port, const char *domain, Ip::Address &client_address);
 
     int hist[PCONN_HIST_SZ];
     hash_table *table;
@@ -77,20 +77,18 @@ SQUIDCEXTERN void parse_wordlist(wordlist ** list);
 SQUIDCEXTERN void requirePathnameExists(const char *name, const char *path);
 SQUIDCEXTERN void parse_time_t(time_t * var);
 
-SQUIDCEXTERN void parse_IpAddress_list_token(IpAddress_list **, char *);
-
 
 /* client_side.c - FD related client side routines */
 
 SQUIDCEXTERN void clientdbInit(void);
 
-SQUIDCEXTERN void clientdbUpdate(const IpAddress &, log_type, protocol_t, size_t);
+SQUIDCEXTERN void clientdbUpdate(const Ip::Address &, log_type, protocol_t, size_t);
 
-SQUIDCEXTERN int clientdbCutoffDenied(const IpAddress &);
+SQUIDCEXTERN int clientdbCutoffDenied(const Ip::Address &);
 void clientdbDump(StoreEntry *);
 SQUIDCEXTERN void clientdbFreeMemory(void);
 
-SQUIDCEXTERN int clientdbEstablished(const IpAddress &, int);
+SQUIDCEXTERN int clientdbEstablished(const Ip::Address &, int);
 SQUIDCEXTERN void clientOpenListenSockets(void);
 SQUIDCEXTERN void clientHttpConnectionsClose(void);
 SQUIDCEXTERN void httpRequestFree(void *);
@@ -137,7 +135,7 @@ SQUIDCEXTERN void idnsInit(void);
 SQUIDCEXTERN void idnsShutdown(void);
 SQUIDCEXTERN void idnsALookup(const char *, IDNSCB *, void *);
 
-SQUIDCEXTERN void idnsPTRLookup(const IpAddress &, IDNSCB *, void *);
+SQUIDCEXTERN void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
 
 SQUIDCEXTERN void fd_close(int fd);
 SQUIDCEXTERN void fd_open(int fd, unsigned int type, const char *);
@@ -155,14 +153,14 @@ SQUIDCEXTERN void file_map_bit_reset(fileMap *, int);
 SQUIDCEXTERN void filemapFreeMemory(fileMap *);
 
 
-SQUIDCEXTERN void fqdncache_nbgethostbyaddr(IpAddress &, FQDNH *, void *);
+SQUIDCEXTERN void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
 
-SQUIDCEXTERN const char *fqdncache_gethostbyaddr(IpAddress &, int flags);
+SQUIDCEXTERN const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
 SQUIDCEXTERN void fqdncache_init(void);
 SQUIDCEXTERN void fqdnStats(StoreEntry *);
 SQUIDCEXTERN void fqdncacheReleaseInvalid(const char *);
 
-SQUIDCEXTERN const char *fqdnFromAddr(IpAddress &);
+SQUIDCEXTERN const char *fqdnFromAddr(const Ip::Address &);
 SQUIDCEXTERN int fqdncacheQueueDrain(void);
 SQUIDCEXTERN void fqdncacheFreeMemory(void);
 SQUIDCEXTERN void fqdncache_restart(void);
@@ -290,10 +288,10 @@ SQUIDCEXTERN void snmpConnectionShutdown(void);
 SQUIDCEXTERN void snmpConnectionClose(void);
 SQUIDCEXTERN const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
 
-SQUIDCEXTERN void addr2oid(IpAddress &addr, oid *Dest);
-SQUIDCEXTERN void oid2addr(oid *Dest, IpAddress &addr, u_int code);
+SQUIDCEXTERN void addr2oid(Ip::Address &addr, oid *Dest);
+SQUIDCEXTERN void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
 
-SQUIDCEXTERN IpAddress *client_entry(IpAddress *current);
+SQUIDCEXTERN Ip::Address *client_entry(Ip::Address *current);
 SQUIDCEXTERN variable_list *snmp_basicFn(variable_list *, snint *);
 SQUIDCEXTERN variable_list *snmp_confFn(variable_list *, snint *);
 SQUIDCEXTERN variable_list *snmp_sysFn(variable_list *, snint *);
@@ -333,10 +331,8 @@ SQUIDCEXTERN void ipcacheInvalidateNegative(const char *);
 SQUIDCEXTERN void ipcache_init(void);
 SQUIDCEXTERN void stat_ipcache_get(StoreEntry *);
 SQUIDCEXTERN void ipcacheCycleAddr(const char *name, ipcache_addrs *);
-
-SQUIDCEXTERN void ipcacheMarkBadAddr(const char *name, IpAddress &);
-
-SQUIDCEXTERN void ipcacheMarkGoodAddr(const char *name, IpAddress &);
+SQUIDCEXTERN void ipcacheMarkBadAddr(const char *name, const Ip::Address &);
+SQUIDCEXTERN void ipcacheMarkGoodAddr(const char *name, const Ip::Address &);
 SQUIDCEXTERN void ipcacheFreeMemory(void);
 SQUIDCEXTERN ipcache_addrs *ipcacheCheckNumeric(const char *name);
 SQUIDCEXTERN void ipcache_restart(void);
@@ -372,7 +368,7 @@ SQUIDCEXTERN int neighborsUdpPing(HttpRequest *,
                                   int *timeout);
 SQUIDCEXTERN void neighborAddAcl(const char *, const char *);
 
-SQUIDCEXTERN void neighborsUdpAck(const cache_key *, icp_common_t *, const IpAddress &);
+SQUIDCEXTERN void neighborsUdpAck(const cache_key *, icp_common_t *, const Ip::Address &);
 SQUIDCEXTERN void neighborAdd(const char *, const char *, int, int, int, int, int);
 SQUIDCEXTERN void neighbors_init(void);
 #if USE_HTCP
@@ -399,7 +395,7 @@ SQUIDCEXTERN void peerConnectSucceded(peer *);
 SQUIDCEXTERN void dump_peer_options(StoreEntry *, peer *);
 SQUIDCEXTERN int peerHTTPOkay(const peer *, HttpRequest *);
 
-SQUIDCEXTERN peer *whichPeer(const IpAddress &from);
+SQUIDCEXTERN peer *whichPeer(const Ip::Address &from);
 
 SQUIDCEXTERN void peerSelect(HttpRequest *, StoreEntry *, PSC *, void *data);
 SQUIDCEXTERN void peerSelectInit(void);
@@ -411,7 +407,7 @@ SQUIDCEXTERN void peerDigestNeeded(PeerDigest * pd);
 SQUIDCEXTERN void peerDigestNotePeerGone(PeerDigest * pd);
 SQUIDCEXTERN void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
 
-extern IpAddress getOutgoingAddr(HttpRequest * request, struct peer *dst_peer);
+extern Ip::Address getOutgoingAddr(HttpRequest * request, struct peer *dst_peer);
 unsigned long getOutgoingTOS(HttpRequest * request);
 
 SQUIDCEXTERN void urnStart(HttpRequest *, StoreEntry *);
@@ -656,7 +652,7 @@ SQUIDCEXTERN pid_t ipcCreate(int type,
                              const char *prog,
                              const char *const args[],
                              const char *name,
-                             IpAddress &local_addr,
+                             Ip::Address &local_addr,
                              int *rfd,
                              int *wfd,
                              void **hIpc);
@@ -49,7 +49,7 @@ typedef struct {
     void *data;
     char *orig_url;
 
-    IpAddress client_addr;
+    Ip::Address client_addr;
     const char *client_ident;
     const char *method_s;
     RH *handler;
@@ -60,7 +60,7 @@ send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *junk)
     LOCAL_ARRAY(char, tbuf, 256);
     LOCAL_ARRAY(char, sndbuf, BUFSIZ);
 
-    IpAddress S;
+    Ip::Address S;
     char *host = Config.Announce.host;
     char *file = NULL;
     u_short port = Config.Announce.port;
@@ -200,7 +200,7 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
 {
     variable_list *Answer = NULL;
 
-    IpAddress laddr;
+    Ip::Address laddr;
     char *cp = NULL;
     peer *p = NULL;
     int cnt = 0;
@@ -39,7 +39,7 @@
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
 
-IpAddress theOutSNMPAddr;
+Ip::Address theOutSNMPAddr;
 
 typedef struct _mib_tree_entry mib_tree_entry;
 typedef oid *(instance_Fn) (oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
@@ -397,7 +397,7 @@ void
 snmpHandleUdp(int sock, void *not_used)
 {
     LOCAL_ARRAY(char, buf, SNMP_REQUEST_SIZE);
-    IpAddress from;
+    Ip::Address from;
     snmp_request_t *snmp_rq;
     int len;
 
@@ -788,8 +788,8 @@ static oid *
 client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
 {
     oid *instance = NULL;
-    IpAddress laddr;
-    IpAddress *aux;
+    Ip::Address laddr;
+    Ip::Address *aux;
     int size = 0;
     int newshift = 0;
 
@@ -1100,7 +1100,7 @@ snmpSnmplibDebug(int lvl, char *buf)
    oid == 32.1.50.239.162.33.251.20.50.0.0.0.0.0.0.0.0.0.1
 */
 void
-addr2oid(IpAddress &addr, oid * Dest)
+addr2oid(Ip::Address &addr, oid * Dest)
 {
     u_int i ;
     u_char *cp = NULL;
@@ -1139,7 +1139,7 @@ addr2oid(IpAddress &addr, oid * Dest)
    IPv6 adress : 20:01:32:ef:a2:21:fb:32:00:00:00:00:00:00:00:00:OO:01
 */
 void
-oid2addr(oid * id, IpAddress &addr, u_int size)
+oid2addr(oid * id, Ip::Address &addr, u_int size)
 {
     struct in_addr iaddr;
     u_int i;
@@ -75,7 +75,7 @@ struct _snmp_request_t {
     long reqid;
     int outlen;
 
-    IpAddress from;
+    Ip::Address from;
 
     struct snmp_pdu *PDU;
     ACLChecklist *acl_checklist;
@@ -92,7 +92,7 @@ struct acl_address {
     acl_address *next;
     ACLList *aclList;
 
-    IpAddress addr;
+    Ip::Address addr;
 };
 
 struct acl_tos {
@@ -126,10 +126,6 @@ struct relist {
 #include "icmp/IcmpConfig.h"
 #endif
 
-#if USE_ZPH_QOS
-#include "ip/QosConfig.h"
-#endif
-
 #include "HelperChildConfig.h"
 
 /* forward decl for SquidConfig, see RemovalPolicy.h */
@@ -225,19 +221,16 @@ struct SquidConfig {
 #if USE_WCCP
 
     struct {
-
-        IpAddress router;
-
-        IpAddress address;
+        Ip::Address router;
+        Ip::Address address;
         int version;
     } Wccp;
 #endif
 #if USE_WCCPv2
 
     struct {
-        IpAddress_list *router;
-
-        IpAddress address;
+        Ip::Address_list *router;
+        Ip::Address address;
         int forwarding_method;
         int return_method;
         int assignment_method;
@@ -337,17 +330,14 @@ struct SquidConfig {
 
     struct {
 
-        IpAddress udp_incoming;
-
-        IpAddress udp_outgoing;
+        Ip::Address udp_incoming;
+        Ip::Address udp_outgoing;
 #if SQUID_SNMP
-
-        IpAddress snmp_incoming;
-
-        IpAddress snmp_outgoing;
+        Ip::Address snmp_incoming;
+        Ip::Address snmp_outgoing;
 #endif
         /* FIXME INET6 : this should really be a CIDR value */
-        IpAddress client_netmask;
+        Ip::Address client_netmask;
     } Addrs;
     size_t tcpRcvBufsz;
     size_t udpMaxHitObjsz;
@@ -556,7 +546,7 @@ struct SquidConfig {
 
     struct {
 
-        IpAddress addr;
+        Ip::Address addr;
         int ttl;
         unsigned short port;
         char *encode_key;
@@ -599,10 +589,6 @@ struct SquidConfig {
     time_t minimum_expiry_time;	/* seconds */
     external_acl *externalAclHelperList;
 
-#if USE_ZPH_QOS
-    QosConfig zph;
-#endif
-
 #if USE_SSL
 
     struct {
@@ -782,7 +768,7 @@ struct _http_state_flags {
 };
 
 struct _ipcache_addrs {
-    IpAddress *in_addrs;
+    Ip::Address *in_addrs;
     unsigned char *bad_mask;
     unsigned char count;
     unsigned char cur;
@@ -824,7 +810,7 @@ struct peer {
     char *host;
     peer_t type;
 
-    IpAddress in_addr;
+    Ip::Address in_addr;
 
     struct {
         int pings_sent;
@@ -918,7 +904,7 @@ struct peer {
 
     int tcp_up;			/* 0 if a connect() fails */
 
-    IpAddress addresses[10];
+    Ip::Address addresses[10];
     int n_addresses;
     int rr_count;
     peer *next;
@@ -133,7 +133,7 @@ commUnsetNonBlocking(int fd)
 /* bah, cheating on stub count */
 
 pid_t
-ipcCreate(int type, const char *prog, const char *const args[], const char *name, IpAddress &local_addr, int *rfd, int *wfd, void **hIpc)
+ipcCreate(int type, const char *prog, const char *const args[], const char *name, Ip::Address &local_addr, int *rfd, int *wfd, void **hIpc)
 {
     fatal ("Not implemented");
     return -1;
@@ -588,7 +588,7 @@ getMyHostname(void)
     LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
     static int present = 0;
     struct addrinfo *AI = NULL;
-    IpAddress sa;
+    Ip::Address sa;
 
     if (Config.visibleHostname != NULL)
         return Config.visibleHostname;
@@ -1209,10 +1209,10 @@ strwordquote(MemBuf * mb, const char *str)
 void
 keepCapabilities(void)
 {
-#if HAVE_PRCTL && defined(PR_SET_KEEPCAPS) && USE_LIBCAP
+#if USE_LIBCAP && HAVE_PRCTL && defined(PR_SET_KEEPCAPS)
 
     if (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0)) {
-        IpInterceptor.StopTransparency("capability setting has failed.");
+        Ip::Interceptor.StopTransparency("capability setting has failed.");
     }
 #endif
 }
@@ -1228,14 +1228,14 @@ restoreCapabilities(int keep)
     else
         caps = cap_init();
     if (!caps) {
-        IpInterceptor.StopTransparency("Can't get current capabilities");
+        Ip::Interceptor.StopTransparency("Can't get current capabilities");
     } else {
         int ncaps = 0;
         int rc = 0;
         cap_value_t cap_list[10];
         cap_list[ncaps++] = CAP_NET_BIND_SERVICE;
 
-        if (IpInterceptor.TransparentActive()) {
+        if (Ip::Interceptor.TransparentActive()) {
             cap_list[ncaps++] = CAP_NET_ADMIN;
 #if LINUX_TPROXY2
             cap_list[ncaps++] = CAP_NET_BROADCAST;
@@ -1247,12 +1247,12 @@ restoreCapabilities(int keep)
         rc |= cap_set_flag(caps, CAP_PERMITTED, ncaps, cap_list, CAP_SET);
 
         if (rc || cap_set_proc(caps) != 0) {
-            IpInterceptor.StopTransparency("Error enabling needed capabilities.");
+            Ip::Interceptor.StopTransparency("Error enabling needed capabilities.");
         }
         cap_free(caps);
     }
 #elif defined(_SQUID_LINUX_)
-    IpInterceptor.StopTransparency("Missing needed capability support.");
+    Ip::Interceptor.StopTransparency("Missing needed capability support.");
 #endif /* HAVE_SYS_CAPABILITY_H */
 }
 
@@ -640,7 +640,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
     statCounter.server.all.requests++;
     statCounter.server.other.requests++;
     /* Create socket. */
-    IpAddress temp = getOutgoingAddr(request,NULL);
+    Ip::Address temp = getOutgoingAddr(request,NULL);
     int flags = COMM_NONBLOCKING;
     if (request->flags.spoof_client_ip) {
         flags |= COMM_TRANSPARENT;
@@ -192,7 +192,7 @@ void
 unlinkdInit(void)
 {
     const char *args[2];
-    IpAddress localhost;
+    Ip::Address localhost;
 
     args[0] = "(unlinkd)";
     args[1] = NULL;
@@ -59,18 +59,18 @@ struct wccp_here_i_am_t {
 };
 
 struct wccp_cache_entry_t {
-    IpAddress ip_addr;
+    struct in_addr ip_addr;  // WCCP on-the-wire in 32-bit IPv4-only.
     int revision;
     char hash[WCCP_HASH_SIZE];
     int reserved;
 };
 
 struct wccp_i_see_you_t {
-    int type;
-    int version;
-    int change;
-    int id;
-    int number;
+    int32_t type;
+    int32_t version;
+    int32_t change;
+    int32_t id;
+    int32_t number;
 
     struct wccp_cache_entry_t wccp_cache_entry[WCCP_ACTIVE_CACHES];
 };
@@ -91,7 +91,7 @@ static int last_id;
 static int last_assign_buckets_change;
 static unsigned int number_caches;
 
-static IpAddress local_ip;
+static Ip::Address local_ip;
 
 static PF wccpHandleUdp;
 static int wccpLowestIP(void);
@@ -203,8 +203,7 @@ wccpConnectionClose(void)
 static void
 wccpHandleUdp(int sock, void *not_used)
 {
-
-    IpAddress from;
+    Ip::Address from;
     int len;
 
     debugs(80, 6, "wccpHandleUdp: Called.");
@@ -288,10 +287,10 @@ wccpLowestIP(void)
     for (loop = 0; loop < (unsigned) ntohl(wccp_i_see_you.number); loop++) {
         assert(loop < WCCP_ACTIVE_CACHES);
 
-        if (wccp_i_see_you.wccp_cache_entry[loop].ip_addr < local_ip)
+        if (local_ip >= wccp_i_see_you.wccp_cache_entry[loop].ip_addr)
             return 0;
 
-        if (wccp_i_see_you.wccp_cache_entry[loop].ip_addr == local_ip)
+        if (local_ip == wccp_i_see_you.wccp_cache_entry[loop].ip_addr)
             found = 1;
     }
 
@@ -678,7 +678,7 @@ wccp2_check_security(struct wccp2_service_list_t *srv, char *security, char *pac
 void
 wccp2Init(void)
 {
-    IpAddress_list *s;
+    Ip::Address_list *s;
     char *ptr;
     uint32_t service_flags;
 
@@ -1179,7 +1179,7 @@ wccp2HandleUdp(int sock, void *not_used)
     commSetSelect(sock, COMM_SELECT_READ, wccp2HandleUdp, NULL, 0);
 
     /* FIXME INET6 : drop conversion boundary */
-    IpAddress from_tmp;
+    Ip::Address from_tmp;
 
     len = comm_udp_recvfrom(sock,
                             &wccp2_i_see_you,
@@ -1543,7 +1543,7 @@ wccp2HereIam(void *voidnotused)
 
     struct wccp2_mask_identity_info_t *wccp2_mask_identity_info_ptr;
 
-    IpAddress router;
+    Ip::Address router;
 
     debugs(80, 6, "wccp2HereIam: Called");
 
@@ -1983,7 +1983,7 @@ wccp2AssignBuckets(void *voidnotused)
 
                 if (wccp2_numrouters > 1) {
                     /* FIXME INET6 : drop temp conversion */
-                    IpAddress tmp_rtr(router);
+                    Ip::Address tmp_rtr(router);
                     comm_udp_sendto(theWccp2Connection,
                                     tmp_rtr,
                                     &wccp_packet,
@@ -55,9 +55,9 @@ int WIN32_pipe(int handles[2])
     int new_socket;
     fde *F = NULL;
 
-    IpAddress localhost;
-    IpAddress handle0;
-    IpAddress handle1;
+    Ip::Address localhost;
+    Ip::Address handle0;
+    Ip::Address handle1;
     struct addrinfo *AI = NULL;
 
     localhost.SetLocalhost();
@@ -766,7 +766,7 @@ process_request(cachemgr_request * req)
 
     char ipbuf[MAX_IPSTRLEN];
     struct addrinfo *AI = NULL;
-    IpAddress S;
+    Ip::Address S;
     int s;
     int l;
 
@@ -93,9 +93,9 @@ using namespace Squid;
 typedef void SIGHDLR(int sig);
 
 /* Local functions */
-static int client_comm_bind(int, const IpAddress &);
+static int client_comm_bind(int, const Ip::Address &);
 
-static int client_comm_connect(int, const IpAddress &, struct timeval *);
+static int client_comm_connect(int, const Ip::Address &, struct timeval *);
 static void usage(const char *progname);
 
 static int Now(struct timeval *);
@@ -167,7 +167,7 @@ main(int argc, char *argv[])
     int opt_noaccept = 0;
     int opt_verbose = 0;
     const char *hostname, *localhost;
-    IpAddress iaddr;
+    Ip::Address iaddr;
     char url[BUFSIZ], msg[MESSAGELEN], buf[BUFSIZ];
     char extra_hdrs[HEADERLEN];
     const char *method = "GET";
@@ -630,7 +630,7 @@ main(int argc, char *argv[])
 }
 
 static int
-client_comm_bind(int sock, const IpAddress &addr)
+client_comm_bind(int sock, const Ip::Address &addr)
 {
 
     int res;
@@ -649,7 +649,7 @@ client_comm_bind(int sock, const IpAddress &addr)
 }
 
 static int
-client_comm_connect(int sock, const IpAddress &addr, struct timeval *tvp)
+client_comm_connect(int sock, const Ip::Address &addr, struct timeval *tvp)
 {
     int res;
     static struct addrinfo *AI = NULL;