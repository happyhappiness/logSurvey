@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACL.h,v 1.6 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACL.h,v 1.7 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -46,8 +46,11 @@ SQUIDCEXTERN void aclParseAccessLine(acl_access **);
 SQUIDCEXTERN void aclParseAclList(acl_list **);
 SQUIDCEXTERN int aclIsProxyAuth(const char *name);
 SQUIDCEXTERN err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name);
+
 SQUIDCEXTERN void aclParseDenyInfoLine(struct _acl_deny_info_list **);
+
 SQUIDCEXTERN void aclDestroyDenyInfoList(struct _acl_deny_info_list **);
+
 SQUIDCEXTERN void aclDestroyRegexList(struct _relist *data);
 SQUIDCEXTERN int aclMatchRegex(relist * data, const char *word);
 wordlist *aclDumpRegexList(relist * data);
@@ -57,8 +60,10 @@ SQUIDCEXTERN int aclPurgeMethodInUse(acl_access *);
 SQUIDCEXTERN void aclCacheMatchFlush(dlink_list * cache);
 extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
 
-class ACL {
-  public:
+class ACL
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -77,53 +82,64 @@ class ACL {
     virtual void parse();
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return type;}
+
     virtual bool isProxyAuth() const;
     virtual bool requiresRequest() const;
     virtual int match(ACLChecklist * checklist);
     virtual wordlist *dumpGeneric() const;
     virtual wordlist *dump() const;
     virtual bool valid () const;
     int checklistMatches(ACLChecklist *);
-    
+
     /* only relevant to METHOD acl's */
     virtual bool containsPURGE() const;
 
     /* only relecant to ASN acl's */
     void startCache();
-    
+
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
 
     char name[ACL_NAME_SZ];
     char *cfgline;
     ACL *next;
-  private:
+
+private:
     static MemPool *Pool;
     squid_acl type;
-  protected:
+
+protected:
     void *data;
-  public:
-    class Prototype {
-      public:
-	Prototype ();
-	Prototype (ACL const *, char const *);
-	~Prototype();
-	static bool Registered(char const *);
-	static ACL *Factory (char const *);
-      private:
-	ACL const*prototype;
-	char const *typeString;
-      private:
-	static Vector<Prototype const *> * Registry;
-	static void *Initialized;
-	typedef Vector<Prototype const*>::iterator iterator;
-	typedef Vector<Prototype const*>::const_iterator const_iterator;
-	void registerMe();
+
+public:
+
+    class Prototype
+    {
+
+    public:
+        Prototype ();
+        Prototype (ACL const *, char const *);
+        ~Prototype();
+        static bool Registered(char const *);
+        static ACL *Factory (char const *);
+
+    private:
+        ACL const*prototype;
+        char const *typeString;
+
+    private:
+        static Vector<Prototype const *> * Registry;
+        static void *Initialized;
+        typedef Vector<Prototype const*>::iterator iterator;
+        typedef Vector<Prototype const*>::const_iterator const_iterator;
+        void registerMe();
     };
 };
 
-class acl_access {
-  public:
+class acl_access
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -132,12 +148,15 @@ class acl_access {
     acl_list *aclList;
     char *cfgline;
     acl_access *next;
-  private:
+
+private:
     CBDATA_CLASS(acl_access);
 };
 
-class ACLList {
-  public:
+class ACLList
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -148,7 +167,8 @@ class ACLList {
     int op;
     acl *_acl;
     ACLList *next;
-  private:
+
+private:
     static MemPool *Pool;
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLASN.h,v 1.1 2003/02/16 02:23:18 robertc Exp $
+ * $Id: ACLASN.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,12 +38,16 @@
 #include "ACLChecklist.h"
 #include "ACLIP.h"
 
-class ASNLookup : public ACLChecklist::AsyncState {
-  public:
+class ASNLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static ASNLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static ASNLookup instance_;
     static IPH LookupDone;
 };
+
 #endif /* SQUID_ACLASN_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLBrowser.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLBrowser.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,8 +40,10 @@
 #include "ACLRequestHeaderStrategy.h"
 #include "ACLStrategised.h"
 
-class ACLBrowser {
-  private:
+class ACLBrowser
+{
+
+private:
     static ACL::Prototype RegistryProtoype;
     static ACLStrategised<char const *> RegistryEntry_;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLCertificate.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLCertificate.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -43,22 +43,28 @@
 
 class ACLCertificateStrategy : public ACLMatchStrategy<SSL *>
 {
-  public:
+
+public:
     virtual int match (ACLData<MatchType> * &, ACLChecklist *);
     static ACLCertificateStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLCertificateStrategy(ACLCertificateStrategy const &);
-  private:
+
+private:
     static ACLCertificateStrategy Instance_;
     ACLCertificateStrategy(){}
+
     ACLCertificateStrategy&operator=(ACLCertificateStrategy const &);
 };
 
-class ACLCertificate {
-  public:
-  private:
+class ACLCertificate
+{
+
+public:
+
+private:
     static ACL::Prototype UserRegistryProtoype;
     static ACLStrategised<SSL*> UserRegistryEntry_;
     static ACL::Prototype CARegistryProtoype;
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLCertificateData.cc,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLCertificateData.cc,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -45,8 +45,10 @@ ACLCertificateData::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLCertificateData));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLCertificateData", sizeof (ACLCertificateData));
+        Pool = memPoolCreate("ACLCertificateData", sizeof (ACLCertificateData));
+
     return memPoolAlloc(Pool);
 }
 
@@ -64,14 +66,14 @@ ACLCertificateData::deleteSelf() const
 
 
 ACLCertificateData::ACLCertificateData(SSLGETATTRIBUTE *sslStrategy) : attribute (NULL), values (NULL), sslAttributeCall (sslStrategy)
-{
-}
+{}
 
 ACLCertificateData::ACLCertificateData(ACLCertificateData const &old) : attribute (NULL), values (NULL), sslAttributeCall (old.sslAttributeCall)
 {
     assert (!old.values);
+
     if (old.attribute)
-	attribute = xstrdup (old.attribute);
+        attribute = xstrdup (old.attribute);
 }
 
 template<class T>
@@ -84,9 +86,10 @@ xRefFree(T &thing)
 ACLCertificateData::~ACLCertificateData()
 {
     safe_free (attribute);
+
     if (values)
-	values->destroy(xRefFree);
-} 
+        values->destroy(xRefFree);
+}
 
 template<class T>
 inline int
@@ -106,15 +109,20 @@ bool
 ACLCertificateData::match(SSL *ssl)
 {
     if (!ssl)
-	return 0;
-    
+        return 0;
+
     char const *value = sslAttributeCall(ssl, attribute);
+
     if (value == NULL)
-	return 0;
+        return 0;
+
     debug(28, 3) ("aclMatchCertificateList: checking '%s'\n", value);
+
     values = values->splay((char *)value, splaystrcmp);
+
     debug(28, 3) ("aclMatchCertificateList: '%s' %s\n",
-	value, splayLastResult ? "NOT found" : "found");
+                  value, splayLastResult ? "NOT found" : "found");
+
     return !splayLastResult;
 }
 
@@ -142,17 +150,21 @@ void
 ACLCertificateData::parse()
 {
     char *newAttribute = strtokFile();
+
     if (!newAttribute)
-	self_destruct();
+        self_destruct();
+
     /* an acl must use consistent attributes in all config lines */
     if (attribute) {
-	if (strcasecmp(newAttribute, attribute) != 0)
-	    self_destruct();
+        if (strcasecmp(newAttribute, attribute) != 0)
+            self_destruct();
     } else
-	attribute = xstrdup(newAttribute);
+        attribute = xstrdup(newAttribute);
+
     char *t;
+
     while ((t = strtokFile())) {
-	values = values->insert(xstrdup(t), splaystrcmp);
+        values = values->insert(xstrdup(t), splaystrcmp);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLCertificateData.h,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLCertificateData.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,8 +40,10 @@
 #include "ACLData.h"
 #include "ssl_support.h"
 
-class ACLCertificateData : public ACLData<SSL *> {
-  public:
+class ACLCertificateData : public ACLData<SSL *>
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -54,10 +56,11 @@ class ACLCertificateData : public ACLData<SSL *> {
     wordlist *dump();
     void parse();
     virtual ACLData<SSL *> *clone() const;
-    
+
     char *attribute;
     SplayNode<char *> *values;
-  private:
+
+private:
     static MemPool *Pool;
     SSLGETATTRIBUTE *sslAttributeCall;
 };
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLChecklist.cc,v 1.6 2003/02/21 12:02:30 robertc Exp $
+ * $Id: ACLChecklist.cc,v 1.7 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -43,44 +43,53 @@ int
 ACLChecklist::authenticated()
 {
     http_hdr_type headertype;
+
     if (NULL == request) {
-	fatal ("requiresRequest SHOULD have been true for this ACL!!");
-	return 0;
+        fatal ("requiresRequest SHOULD have been true for this ACL!!");
+        return 0;
     } else if (!request->flags.accelerated) {
-	/* Proxy authorization on proxy requests */
-	headertype = HDR_PROXY_AUTHORIZATION;
+        /* Proxy authorization on proxy requests */
+        headertype = HDR_PROXY_AUTHORIZATION;
     } else if (request->flags.internal) {
-	/* WWW authorization on accelerated internal requests */
-	headertype = HDR_AUTHORIZATION;
+        /* WWW authorization on accelerated internal requests */
+        headertype = HDR_AUTHORIZATION;
     } else {
 #if AUTH_ON_ACCELERATION
-	/* WWW authorization on accelerated requests */
-	headertype = HDR_AUTHORIZATION;
+        /* WWW authorization on accelerated requests */
+        headertype = HDR_AUTHORIZATION;
 #else
-	debug(28, 1) ("ACHChecklist::authenticated: authentication not applicable on accelerated requests.\n");
-	return -1;
+
+        debug(28, 1) ("ACHChecklist::authenticated: authentication not applicable on accelerated requests.\n");
+        return -1;
 #endif
+
     }
+
     /* get authed here */
     /* Note: this fills in auth_user_request when applicable */
     switch (authenticateTryToAuthenticateAndSetAuthUser(&auth_user_request, headertype, request, conn(), src_addr)) {
+
     case AUTH_ACL_CANNOT_AUTHENTICATE:
-	debug(28, 4) ("aclMatchAcl: returning  0 user authenticated but not authorised.\n");
-	return 0;
+        debug(28, 4) ("aclMatchAcl: returning  0 user authenticated but not authorised.\n");
+        return 0;
+
     case AUTH_AUTHENTICATED:
-	return 1;
-	break;
+        return 1;
+        break;
+
     case AUTH_ACL_HELPER:
-	debug(28, 4) ("aclMatchAcl: returning 0 sending credentials to helper.\n");
-	changeState (ProxyAuthLookup::Instance());
-	return 0;
+        debug(28, 4) ("aclMatchAcl: returning 0 sending credentials to helper.\n");
+        changeState (ProxyAuthLookup::Instance());
+        return 0;
+
     case AUTH_ACL_CHALLENGE:
-	debug(28, 4) ("aclMatchAcl: returning 0 sending authentication challenge.\n");
-	changeState (ProxyAuthNeeded::Instance());
-	return 0;
+        debug(28, 4) ("aclMatchAcl: returning 0 sending authentication challenge.\n");
+        changeState (ProxyAuthNeeded::Instance());
+        return 0;
+
     default:
-	fatal("unexpected authenticateAuthenticate reply\n");
-	return 0;
+        fatal("unexpected authenticateAuthenticate reply\n");
+        return 0;
     }
 }
 
@@ -95,58 +104,68 @@ ACLChecklist::currentAnswer(allow_t const newAnswer)
 {
     allow_ = newAnswer;
 }
-    
+
 void
 ACLChecklist::check()
 {
     if (checking())
-	return;
+        return;
+
     /* deny if no rules present */
     currentAnswer(ACCESS_DENIED);
+
     /* NOTE: This holds a cbdata reference to the current access_list
      * entry, not the whole list.
      */
     while (accessList != NULL) {
-	/*
-	 * If the _acl_access is no longer valid (i.e. its been
-	 * freed because of a reconfigure), then bail on this
-	 * access check.  For now, return ACCESS_DENIED.
-	 */
-	if (!cbdataReferenceValid(accessList)) {
-	    cbdataReferenceDone(accessList);
-	    debug (28,4)("ACLChecklist::check: %p accessList is invalid\n", this);
-	    continue;
-	}
-
-	checking (true);
-	checkAccessList();
-	checking (false);
-	if (asyncInProgress()) {
-	    return;
-	}
-
-	if (finished()) {
-	    /*
-	     * We are done.  Either the request
-	     * is allowed, denied, requires authentication.
-	     */
-	    debug(28, 3) ("ACLChecklist::check: %p match found, calling back with %d\n", this, currentAnswer());
-	    cbdataReferenceDone(accessList); /* A */
-	    checkCallback(currentAnswer());
-	    /* From here on in, this may be invalid */
-	    return;
-	}
-	/*
-	 * Reference the next access entry
-	 */
-	const acl_access *A = accessList;
-	assert (A);
-	accessList = cbdataReference(A->next);
-	cbdataReferenceDone(A);
+        /*
+         * If the _acl_access is no longer valid (i.e. its been
+         * freed because of a reconfigure), then bail on this
+         * access check.  For now, return ACCESS_DENIED.
+         */
+
+        if (!cbdataReferenceValid(accessList)) {
+            cbdataReferenceDone(accessList);
+            debug (28,4)("ACLChecklist::check: %p accessList is invalid\n", this);
+            continue;
+        }
+
+        checking (true);
+        checkAccessList();
+        checking (false);
+
+        if (asyncInProgress()) {
+            return;
+        }
+
+        if (finished()) {
+            /*
+             * We are done.  Either the request
+             * is allowed, denied, requires authentication.
+             */
+            debug(28, 3) ("ACLChecklist::check: %p match found, calling back with %d\n", this, currentAnswer());
+            cbdataReferenceDone(accessList); /* A */
+            checkCallback(currentAnswer());
+            /* From here on in, this may be invalid */
+            return;
+        }
+
+        /*
+         * Reference the next access entry
+         */
+        const acl_access *A = accessList;
+
+        assert (A);
+
+        accessList = cbdataReference(A->next);
+
+        cbdataReferenceDone(A);
     }
+
     /* dropped off the end of the list */
     debug(28, 3) ("ACLChecklist::check: %p NO match found, returning %d\n", this,
-		  currentAnswer() != ACCESS_DENIED ? ACCESS_DENIED : ACCESS_ALLOWED);
+                  currentAnswer() != ACCESS_DENIED ? ACCESS_DENIED : ACCESS_ALLOWED);
+
     checkCallback(currentAnswer() != ACCESS_DENIED ? ACCESS_DENIED : ACCESS_ALLOWED);
 }
 
@@ -186,10 +205,11 @@ ACLChecklist::checkAccessList()
     currentAnswer(accessList->allow);
     /* does the current AND clause match */
     bool match = matchAclList(accessList->aclList);
+
     if (match)
-	markFinished();
+        markFinished();
     else
-	checkForAsync();
+        checkForAsync();
 }
 
 void
@@ -206,37 +226,47 @@ ACLChecklist::checkCallback(allow_t answer)
     debug(28, 3) ("ACLChecklist::checkCallback: %p answer=%d\n", this, answer);
     /* During reconfigure, we can end up not finishing call
      * sequences into the auth code */
+
     if (auth_user_request) {
-	/* the checklist lock */
-	authenticateAuthUserRequestUnlock(auth_user_request);
-	/* it might have been connection based */
-	assert(conn());
-	conn()->auth_user_request = NULL;
-	conn()->auth_type = AUTH_BROKEN;
-	auth_user_request = NULL;
+        /* the checklist lock */
+        authenticateAuthUserRequestUnlock(auth_user_request);
+        /* it might have been connection based */
+        assert(conn());
+        conn()->auth_user_request = NULL;
+        conn()->auth_type = AUTH_BROKEN;
+        auth_user_request = NULL;
     }
+
     callback_ = callback;
     callback = NULL;
+
     if (cbdataReferenceValidDone(callback_data, &cbdata_))
-	callback_(answer, cbdata_);
+        callback_(answer, cbdata_);
+
     delete this;
 }
+
 bool
 ACLChecklist::matchAclList(const acl_list * head, bool const fast)
 {
     PROF_start(aclMatchAclList);
     const acl_list *node = head;
+
     while (node) {
-	bool nodeMatched = node->matches(this);
-	if (fast)
-	    changeState(NullState::Instance());
-	if (!nodeMatched || state_ != NullState::Instance()) {
-	    debug(28, 3) ("aclmatchAclList: %p returning false (AND list entry failed to match)\n", this);
-	    PROF_stop(aclMatchAclList);
-	    return false;
-	}
-	node = node->next;
+        bool nodeMatched = node->matches(this);
+
+        if (fast)
+            changeState(NullState::Instance());
+
+        if (!nodeMatched || state_ != NullState::Instance()) {
+            debug(28, 3) ("aclmatchAclList: %p returning false (AND list entry failed to match)\n", this);
+            PROF_stop(aclMatchAclList);
+            return false;
+        }
+
+        node = node->next;
     }
+
     debug(28, 3) ("aclmatchAclList: %p returning true (AND list satisfied)\n", this);
     PROF_stop(aclMatchAclList);
     return true;
@@ -255,7 +285,7 @@ ACLChecklist::operator new (size_t size)
     cbdataReference(result);
     return result;
 }
- 
+
 void
 ACLChecklist::operator delete (void *address)
 {
@@ -272,24 +302,27 @@ ACLChecklist::deleteSelf() const
 }
 
 ACLChecklist::ACLChecklist() : accessList (NULL), my_port (0), request (NULL),
-  reply (NULL),
-  auth_user_request (NULL)
+        reply (NULL),
+        auth_user_request (NULL)
 #if SQUID_SNMP
-    ,snmp_community(NULL)
+        ,snmp_community(NULL)
 #endif
-  , callback (NULL),
-  callback_data (NULL),
-  extacl_entry (NULL),
-  conn_(NULL),
-  async_(false),
-  finished_(false),
-  allow_(ACCESS_DENIED),
-  state_(NullState::Instance()),
-  destinationDomainChecked_(false),
-  sourceDomainChecked_(false)
+        , callback (NULL),
+        callback_data (NULL),
+        extacl_entry (NULL),
+        conn_(NULL),
+        async_(false),
+        finished_(false),
+        allow_(ACCESS_DENIED),
+        state_(NullState::Instance()),
+        destinationDomainChecked_(false),
+        sourceDomainChecked_(false)
 {
+
     memset (&src_addr, '\0', sizeof (struct in_addr));
+
     memset (&dst_addr, '\0', sizeof (struct in_addr));
+
     memset (&my_addr, '\0', sizeof (struct in_addr));
     rfc931[0] = '\0';
     memset (&state, '\0', sizeof (state));
@@ -298,13 +331,19 @@ ACLChecklist::ACLChecklist() : accessList (NULL), my_port (0), request (NULL),
 ACLChecklist::~ACLChecklist()
 {
     assert (!asyncInProgress());
+
     if (extacl_entry)
-	cbdataReferenceDone(extacl_entry);
+        cbdataReferenceDone(extacl_entry);
+
     if (request)
-	requestUnlink(request);
+        requestUnlink(request);
+
     request = NULL;
+
     cbdataReferenceDone(conn_);
+
     cbdataReferenceDone(accessList);
+
     debug (28,4)("ACLChecklist::~ACLChecklist: destroyed %p\n", this);
 }
 
@@ -336,8 +375,7 @@ ACLChecklist::NullState::Instance()
 
 void
 ACLChecklist::NullState::checkForAsync(ACLChecklist *) const
-{
-}
+    {}
 
 ACLChecklist::NullState ACLChecklist::NullState::_instance;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLChecklist.h,v 1.6 2003/02/21 12:02:30 robertc Exp $
+ * $Id: ACLChecklist.h,v 1.7 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,8 +36,10 @@
 
 #include "typedefs.h"
 
-class ACLChecklist {
-  public:
+class ACLChecklist
+{
+
+public:
 
     /* State class.
      * This abstract class defines the behaviour of
@@ -52,22 +54,28 @@ class ACLChecklist {
      * refcounted objects.
      */
 
-    class AsyncState {
-      public:
-	virtual void checkForAsync(ACLChecklist *) const = 0;
-      protected:
-	void changeState (ACLChecklist *, AsyncState *) const;
+    class AsyncState
+    {
+
+    public:
+        virtual void checkForAsync(ACLChecklist *) const = 0;
+
+    protected:
+        void changeState (ACLChecklist *, AsyncState *) const;
     };
 
-    class NullState : public AsyncState {
-      public:
-	static NullState *Instance();
-	virtual void checkForAsync(ACLChecklist *) const;
-      private:
-	static NullState _instance;
+class NullState : public AsyncState
+    {
+
+    public:
+        static NullState *Instance();
+        virtual void checkForAsync(ACLChecklist *) const;
+
+    private:
+        static NullState _instance;
     };
-    
-    
+
+
     void *operator new(size_t);
     void operator delete(void *);
     void deleteSelf() const;
@@ -96,10 +104,13 @@ class ACLChecklist {
     void checkForAsync();
     void changeState (AsyncState *);
     AsyncState *asyncState() const;
-    
+
     const acl_access *accessList;
+
     struct in_addr src_addr;
+
     struct in_addr dst_addr;
+
     struct in_addr my_addr;
     unsigned short my_port;
     request_t *request;
@@ -109,15 +120,18 @@ class ACLChecklist {
     auth_user_request_t *auth_user_request;
     acl_lookup_state state[ACL_ENUM_MAX];
 #if SQUID_SNMP
+
     char *snmp_community;
 #endif
+
     PF *callback;
     void *callback_data;
     external_acl_entry *extacl_entry;
     bool destinationDomainChecked() const;
     void markDestinationDomainChecked();
     bool sourceDomainChecked() const;
     void markSourceDomainChecked();
+
 private:
     CBDATA_CLASS(ACLChecklist);
     ConnStateData *conn_;	/* hack for ident and NTLM */
@@ -133,8 +147,8 @@ class ACLChecklist {
 };
 
 SQUIDCEXTERN ACLChecklist *aclChecklistCreate(const acl_access *,
-    request_t *,
-    const char *ident);
+        request_t *,
+        const char *ident);
 SQUIDCEXTERN int aclCheckFast(const acl_access *A, ACLChecklist *);
 
 #endif /* SQUID_ACLCHECKLIST_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLData.h,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLData.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,11 +37,15 @@
 #define SQUID_ACLDATA_H
 
 template <class M>
-class ACLData {
-  public:
+
+class ACLData
+{
+
+public:
     virtual void deleteSelf() const =0;
 
     virtual ~ACLData() {}
+
     virtual bool match(M) =0;
     virtual wordlist *dump() =0;
     virtual void parse() =0;
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLDestinationDomain.cc,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLDestinationDomain.cc,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -47,8 +47,10 @@ ACLDestinationDomain::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLDestinationDomain));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLDestinationDomain", sizeof (ACLDestinationDomain));
+        Pool = memPoolCreate("ACLDestinationDomain", sizeof (ACLDestinationDomain));
+
     return memPoolAlloc(Pool);
 }
 
@@ -70,9 +72,10 @@ ACLDestinationDomain::~ACLDestinationDomain()
 }
 
 ACLDestinationDomain::ACLDestinationDomain(ACLData<char const *> *newData, char const *theType) : data (newData), type_(theType) {}
+
 ACLDestinationDomain::ACLDestinationDomain (ACLDestinationDomain const &old) : data (old.data->clone()), type_(old.type_)
-{
-}
+{}
+
 ACLDestinationDomain &
 ACLDestinationDomain::operator= (ACLDestinationDomain const &rhs)
 {
@@ -97,18 +100,24 @@ int
 ACLDestinationDomain::match(ACLChecklist *checklist)
 {
     const ipcache_addrs *ia = NULL;
+
     if ((ia = ipcacheCheckNumeric(checklist->request->host)) == NULL)
-	return data->match(checklist->request->host);
+        return data->match(checklist->request->host);
+
     const char *fqdn = NULL;
+
     fqdn = fqdncache_gethostbyaddr(ia->in_addrs[0], FQDN_LOOKUP_IF_MISS);
+
     if (fqdn)
-	return data->match(fqdn);
+        return data->match(fqdn);
+
     if (!checklist->destinationDomainChecked()) {
-	debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
-		      name, inet_ntoa(ia->in_addrs[0]));
-	checklist->changeState(DestinationDomainLookup::Instance());
-	return 0;
+        debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+                      name, inet_ntoa(ia->in_addrs[0]));
+        checklist->changeState(DestinationDomainLookup::Instance());
+        return 0;
     }
+
     return data->match("none");
 }
 
@@ -138,15 +147,16 @@ DestinationDomainLookup::checkForAsync(ACLChecklist *checklist)const
 
     ipcache_addrs *ia;
     ia = ipcacheCheckNumeric(checklist->request->host);
+
     if (ia == NULL) {
-	/* Make fatal? XXX this is checked during match() */
-	checklist->markDestinationDomainChecked();
-	checklist->changeState (ACLChecklist::NullState::Instance());
+        /* Make fatal? XXX this is checked during match() */
+        checklist->markDestinationDomainChecked();
+        checklist->changeState (ACLChecklist::NullState::Instance());
     } else {
-	checklist->asyncInProgress(true);
-	checklist->dst_addr = ia->in_addrs[0];
-	fqdncache_nbgethostbyaddr(checklist->dst_addr,
-				  LookupDone, checklist);
+        checklist->asyncInProgress(true);
+        checklist->dst_addr = ia->in_addrs[0];
+        fqdncache_nbgethostbyaddr(checklist->dst_addr,
+                                  LookupDone, checklist);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLDestinationDomain.h,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLDestinationDomain.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,17 +39,22 @@
 #include "ACLData.h"
 #include "ACLChecklist.h"
 
-class DestinationDomainLookup : public ACLChecklist::AsyncState {
-  public:
+class DestinationDomainLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static DestinationDomainLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static DestinationDomainLookup instance_;
     static void LookupDone(const char *, void *);
 };
 
-class ACLDestinationDomain : public ACL {
-  public:
+class ACLDestinationDomain : public ACL
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -58,16 +63,19 @@ class ACLDestinationDomain : public ACL {
     ACLDestinationDomain(ACLData<char const *> *, char const *);
     ACLDestinationDomain (ACLDestinationDomain const &);
     ACLDestinationDomain &operator= (ACLDestinationDomain const &);
-    
+
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
     virtual bool valid () const;
     virtual bool requiresRequest() const {return true;}
+
     virtual ACL *clone()const;
-  private:
+
+private:
     static MemPool *Pool;
     static Prototype LiteralRegistryProtoype;
     static Prototype LegacyRegistryProtoype;
@@ -43,8 +43,10 @@ ACLDestinationIP::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLDestinationIP));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLDestinationIP", sizeof (ACLDestinationIP));
+        Pool = memPoolCreate("ACLDestinationIP", sizeof (ACLDestinationIP));
+
     return memPoolAlloc(Pool);
 }
 
@@ -70,21 +72,24 @@ int
 ACLDestinationIP::match(ACLChecklist *checklist)
 {
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->host, IP_LOOKUP_IF_MISS);
+
     if (ia) {
-	/* Entry in cache found */
-	for (int k = 0; k < (int) ia->count; k++) {
-	    if (ACLIP::match(ia->in_addrs[k]))
-		return 1;
-	}
-	return 0;
+        /* Entry in cache found */
+
+        for (int k = 0; k < (int) ia->count; k++) {
+            if (ACLIP::match(ia->in_addrs[k]))
+                return 1;
+        }
+
+        return 0;
     } else if (!checklist->request->flags.destinationIPLookedUp()) {
-	/* No entry in cache, lookup not attempted */
-	debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
-		      name, checklist->request->host);
-	checklist->changeState (DestinationIPLookup::Instance());
-	return 0;
+        /* No entry in cache, lookup not attempted */
+        debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+                      name, checklist->request->host);
+        checklist->changeState (DestinationIPLookup::Instance());
+        return 0;
     } else {
-	return ACLIP::match(no_addr);
+        return ACLIP::match(no_addr);
     }
 }
 
@@ -38,27 +38,35 @@
 #include "ACLChecklist.h"
 #include "ACLIP.h"
 
-class DestinationIPLookup : public ACLChecklist::AsyncState {
-  public:
+class DestinationIPLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static DestinationIPLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static DestinationIPLookup instance_;
     static IPH LookupDone;
 };
 
-class ACLDestinationIP : public ACLIP {
-  public:
+class ACLDestinationIP : public ACLIP
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
 
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual int match(ACLChecklist *checklist);
     virtual bool requiresRequest() const {return true;}
+
     virtual ACL *clone()const;
-  private:
+
+private:
     static MemPool *Pool;
     static Prototype RegistryProtoype;
     static ACLDestinationIP RegistryEntry_;
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLDomainData.cc,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLDomainData.cc,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -45,8 +45,10 @@ ACLDomainData::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLDomainData));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLDomainData", sizeof (ACLDomainData));
+        Pool = memPoolCreate("ACLDomainData", sizeof (ACLDomainData));
+
     return memPoolAlloc(Pool);
 }
 
@@ -72,8 +74,8 @@ xRefFree(T &thing)
 ACLDomainData::~ACLDomainData()
 {
     if (domains)
-	domains->destroy(xRefFree);
-} 
+        domains->destroy(xRefFree);
+}
 
 template<class T>
 inline int
@@ -102,17 +104,20 @@ aclDomainCompare(T const &a, T const &b)
     char * const d2 = (char *const )a;
     int ret;
     ret = aclHostDomainCompare(d1, d2);
+
     if (ret != 0) {
-	char *const d3 = d2;
-	char *const d4 = d1;
-	ret = aclHostDomainCompare(d3, d4);
+        char *const d3 = d2;
+        char *const d4 = d1;
+        ret = aclHostDomainCompare(d3, d4);
     }
+
     /* FIXME this warning may display d1 and d2 when it should display d3 and d4 */
     if (ret == 0) {
-	debug(28, 0) ("WARNING: '%s' is a subdomain of '%s'\n", d1, d2);
-	debug(28, 0) ("WARNING: because of this '%s' is ignored to keep splay tree searching predictable\n", (char *) a);
-	debug(28, 0) ("WARNING: You should probably remove '%s' from the ACL named '%s'\n", d1, AclMatchedName);
+        debug(28, 0) ("WARNING: '%s' is a subdomain of '%s'\n", d1, d2);
+        debug(28, 0) ("WARNING: because of this '%s' is ignored to keep splay tree searching predictable\n", (char *) a);
+        debug(28, 0) ("WARNING: You should probably remove '%s' from the ACL named '%s'\n", d1, AclMatchedName);
     }
+
     return ret;
 }
 
@@ -131,11 +136,15 @@ bool
 ACLDomainData::match(char const *host)
 {
     if (host == NULL)
-	return 0;
+        return 0;
+
     debug(28, 3) ("aclMatchDomainList: checking '%s'\n", host);
+
     domains = domains->splay((char *)host, aclHostDomainCompare);
+
     debug(28, 3) ("aclMatchDomainList: '%s' %s\n",
-	host, splayLastResult ? "NOT found" : "found");
+                  host, splayLastResult ? "NOT found" : "found");
+
     return !splayLastResult;
 }
 
@@ -162,9 +171,10 @@ void
 ACLDomainData::parse()
 {
     char *t = NULL;
+
     while ((t = strtokFile())) {
-	Tolower(t);
-	domains = domains->insert(xstrdup(t), aclDomainCompare);
+        Tolower(t);
+        domains = domains->insert(xstrdup(t), aclDomainCompare);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLDomainData.h,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLDomainData.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,8 +39,10 @@
 #include "ACL.h"
 #include "ACLData.h"
 
-class ACLDomainData : public ACLData<char const *> {
-  public:
+class ACLDomainData : public ACLData<char const *>
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -50,9 +52,10 @@ class ACLDomainData : public ACLData<char const *> {
     wordlist *dump();
     void parse();
     virtual ACLData<char const *> *clone() const;
-    
+
     SplayNode<char *> *domains;
-  private:
+
+private:
     static MemPool *Pool;
 };
 
@@ -57,11 +57,15 @@ ACLIP::DumpIpListWalkee(acl_ip_data * const & ip, void *state)
     wordlist **W = static_cast<wordlist **>(state);
     memBufDefInit(&mb);
     memBufPrintf(&mb, "%s", inet_ntoa(ip->addr1));
+
     if (ip->addr2.s_addr != any_addr.s_addr)
-	memBufPrintf(&mb, "-%s", inet_ntoa(ip->addr2));
+        memBufPrintf(&mb, "-%s", inet_ntoa(ip->addr2));
+
     if (ip->mask.s_addr != no_addr.s_addr)
-	memBufPrintf(&mb, "/%s", inet_ntoa(ip->mask));
+        memBufPrintf(&mb, "/%s", inet_ntoa(ip->mask));
+
     wordlistAdd(W, mb.buf);
+
     memBufClean(&mb);
 }
 
@@ -76,14 +80,17 @@ acl_ip_data::toStr(char *buf, int len) const
     char b2[20];
     char b3[20];
     snprintf(b1, 20, "%s", inet_ntoa(addr1));
+
     if (addr2.s_addr != any_addr.s_addr)
-	snprintf(b2, 20, "-%s", inet_ntoa(addr2));
+        snprintf(b2, 20, "-%s", inet_ntoa(addr2));
     else
-	b2[0] = '\0';
+        b2[0] = '\0';
+
     if (mask.s_addr != no_addr.s_addr)
-	snprintf(b3, 20, "/%s", inet_ntoa(mask));
+        snprintf(b3, 20, "/%s", inet_ntoa(mask));
     else
-	b3[0] = '\0';
+        b3[0] = '\0';
+
     snprintf(buf, len, "%s%s%s", b1, b2, b3);
 }
 
@@ -104,24 +111,30 @@ acl_ip_data::toStr(char *buf, int len) const
 int
 aclIpAddrNetworkCompare(acl_ip_data * const &p, acl_ip_data * const &q)
 {
+
     struct in_addr A = p->addr1;
+
     const struct in_addr B = q->addr1;
+
     const struct in_addr C = q->addr2;
     A.s_addr &= q->mask.s_addr;	/* apply netmask */
+
     if (C.s_addr == 0) {	/* single address check */
-	if (ntohl(A.s_addr) > ntohl(B.s_addr))
-	    return 1;
-	else if (ntohl(A.s_addr) < ntohl(B.s_addr))
-	    return -1;
-	else
-	    return 0;
+
+        if (ntohl(A.s_addr) > ntohl(B.s_addr))
+            return 1;
+        else if (ntohl(A.s_addr) < ntohl(B.s_addr))
+            return -1;
+        else
+            return 0;
     } else {			/* range address check */
-	if (ntohl(A.s_addr) > ntohl(C.s_addr))
-	    return  1;
-	else if (ntohl(A.s_addr) < ntohl(B.s_addr))
-	    return -1;
-	else
-	    return 0;
+
+        if (ntohl(A.s_addr) > ntohl(C.s_addr))
+            return  1;
+        else if (ntohl(A.s_addr) < ntohl(B.s_addr))
+            return -1;
+        else
+            return 0;
     }
 }
 
@@ -137,24 +150,27 @@ acl_ip_data::NetworkCompare(acl_ip_data * const & a, acl_ip_data * const &b)
 {
     int ret;
     ret = aclIpAddrNetworkCompare(b, a);
+
     if (ret != 0) {
-	ret = aclIpAddrNetworkCompare(a, b);
+        ret = aclIpAddrNetworkCompare(a, b);
     }
+
     if (ret == 0) {
-	char buf_n1[60];
-	char buf_n2[60];
-	char buf_a[60];
-	b->toStr(buf_n1, 60);
-	a->toStr(buf_n2, 60);
-	a->toStr(buf_a, 60);
-	/* TODO: this warning may display the wrong way around */
-	debug(28, 0) ("WARNING: '%s' is a subnetwork of "
-	    "'%s'\n", buf_n1, buf_n2);
-	debug(28, 0) ("WARNING: because of this '%s' is ignored "
-	    "to keep splay tree searching predictable\n", buf_a);
-	debug(28, 0) ("WARNING: You should probably remove '%s' "
-	    "from the ACL named '%s'\n", buf_n1, AclMatchedName);
+        char buf_n1[60];
+        char buf_n2[60];
+        char buf_a[60];
+        b->toStr(buf_n1, 60);
+        a->toStr(buf_n2, 60);
+        a->toStr(buf_a, 60);
+        /* TODO: this warning may display the wrong way around */
+        debug(28, 0) ("WARNING: '%s' is a subnetwork of "
+                      "'%s'\n", buf_n1, buf_n2);
+        debug(28, 0) ("WARNING: because of this '%s' is ignored "
+                      "to keep splay tree searching predictable\n", buf_a);
+        debug(28, 0) ("WARNING: You should probably remove '%s' "
+                      "from the ACL named '%s'\n", buf_n1, AclMatchedName);
     }
+
     return ret;
 }
 
@@ -164,43 +180,54 @@ acl_ip_data::NetworkCompare(acl_ip_data * const & a, acl_ip_data * const &b)
  * This function should NOT be called if 'asc' is a hostname!
  */
 bool
+
 acl_ip_data::DecodeAddress(const char *asc, struct in_addr *addr, struct in_addr *mask)
 {
     u_int32_t a;
     int a1 = 0, a2 = 0, a3 = 0, a4 = 0;
 
-    switch (sscanf(asc, "%d.%d.%d.%d", &a1, &a2, &a3, &a4)) {
+    switch (sscanf(asc, "%d.%d.%d.%d", &a1, &a2, &a3, &a4))
+    {
+
     case 4:			/* a dotted quad */
-	if (!safe_inet_addr(asc, addr)) {
-	    debug(28, 0) ("DecodeAddress: unsafe IP address: '%s'\n", asc);
-	    fatal("DecodeAddress: unsafe IP address");
-	}
-	break;
+
+        if (!safe_inet_addr(asc, addr)) {
+            debug(28, 0) ("DecodeAddress: unsafe IP address: '%s'\n", asc);
+            fatal("DecodeAddress: unsafe IP address");
+        }
+
+        break;
+
     case 1:			/* a significant bits value for a mask */
-	if (a1 >= 0 && a1 < 33) {
-	    addr->s_addr = a1 ? htonl(0xfffffffful << (32 - a1)) : 0;
-	    break;
-	}
+
+        if (a1 >= 0 && a1 < 33) {
+            addr->s_addr = a1 ? htonl(0xfffffffful << (32 - a1)) : 0;
+            break;
+        }
+
     default:
-	debug(28, 0) ("DecodeAddress: Invalid IP address '%s'\n", asc);
-	return 0;		/* This is not valid address */
+        debug(28, 0) ("DecodeAddress: Invalid IP address '%s'\n", asc);
+        return 0;		/* This is not valid address */
     }
 
-    if (mask != NULL) {		/* mask == NULL if called to decode a netmask */
-
-	/* Guess netmask */
-	a = (u_int32_t) ntohl(addr->s_addr);
-	if (!(a & 0xFFFFFFFFul))
-	    mask->s_addr = htonl(0x00000000ul);
-	else if (!(a & 0x00FFFFFF))
-	    mask->s_addr = htonl(0xFF000000ul);
-	else if (!(a & 0x0000FFFF))
-	    mask->s_addr = htonl(0xFFFF0000ul);
-	else if (!(a & 0x000000FF))
-	    mask->s_addr = htonl(0xFFFFFF00ul);
-	else
-	    mask->s_addr = htonl(0xFFFFFFFFul);
+    if (mask != NULL)
+    {		/* mask == NULL if called to decode a netmask */
+
+        /* Guess netmask */
+        a = (u_int32_t) ntohl(addr->s_addr);
+
+        if (!(a & 0xFFFFFFFFul))
+            mask->s_addr = htonl(0x00000000ul);
+        else if (!(a & 0x00FFFFFF))
+            mask->s_addr = htonl(0xFF000000ul);
+        else if (!(a & 0x0000FFFF))
+            mask->s_addr = htonl(0xFFFF0000ul);
+        else if (!(a & 0x000000FF))
+            mask->s_addr = htonl(0xFFFFFF00ul);
+        else
+            mask->s_addr = htonl(0xFFFFFFFFul);
     }
+
     return 1;
 }
 
@@ -220,93 +247,116 @@ acl_ip_data::FactoryParse(const char *t)
     char c;
     debug(28, 5) ("aclParseIpData: %s\n", t);
     acl_ip_data *q = new acl_ip_data;
+
     if (!strcasecmp(t, "all")) {
-	q->addr1.s_addr = 0;
-	q->addr2.s_addr = 0;
-	q->mask.s_addr = 0;
-	return q;
+        q->addr1.s_addr = 0;
+        q->addr2.s_addr = 0;
+        q->mask.s_addr = 0;
+        return q;
     }
+
     LOCAL_ARRAY(char, addr1, 256);
+
     if (sscanf(t, SCAN_ACL1, addr1, addr2, mask) == 3) {
-	(void) 0;
+        (void) 0;
     } else if (sscanf(t, SCAN_ACL2, addr1, addr2, &c) == 2) {
-	mask[0] = '\0';
+        mask[0] = '\0';
     } else if (sscanf(t, SCAN_ACL3, addr1, mask) == 2) {
-	addr2[0] = '\0';
+        addr2[0] = '\0';
     } else if (sscanf(t, SCAN_ACL4, addr1, &c) == 1) {
-	addr2[0] = '\0';
-	mask[0] = '\0';
+        addr2[0] = '\0';
+        mask[0] = '\0';
     } else if (sscanf(t, "%[^/]/%s", addr1, mask) == 2) {
-	addr2[0] = '\0';
+        addr2[0] = '\0';
     } else if (sscanf(t, "%s", addr1) == 1) {
-	/*
-	 * Note, must use plain gethostbyname() here because at startup
-	 * ipcache hasn't been initialized
-	 */
-	struct hostent *hp;
-	if ((hp = gethostbyname(addr1)) == NULL) {
-	    debug(28, 0) ("aclParseIpData: Bad host/IP: '%s'\n", t);
-	    delete q;
-	    return NULL;
-	}
-	Q = &q;
-	for (x = hp->h_addr_list; x != NULL && *x != NULL; x++) {
-	    if ((r = *Q) == NULL)
-		r = *Q = new acl_ip_data;
-	    xmemcpy(&r->addr1.s_addr, *x, sizeof(r->addr1.s_addr));
-	    r->addr2.s_addr = 0;
-	    r->mask.s_addr = no_addr.s_addr;	/* 255.255.255.255 */
-	    Q = &r->next;
-	    debug(28, 3) ("%s --> %s\n", addr1, inet_ntoa(r->addr1));
-	}
-	return q;
+        /*
+         * Note, must use plain gethostbyname() here because at startup
+         * ipcache hasn't been initialized
+         */
+
+        struct hostent *hp;
+
+        if ((hp = gethostbyname(addr1)) == NULL) {
+            debug(28, 0) ("aclParseIpData: Bad host/IP: '%s'\n", t);
+            delete q;
+            return NULL;
+        }
+
+        Q = &q;
+
+        for (x = hp->h_addr_list; x != NULL && *x != NULL; x++) {
+            if ((r = *Q) == NULL)
+                r = *Q = new acl_ip_data;
+
+            xmemcpy(&r->addr1.s_addr, *x, sizeof(r->addr1.s_addr));
+
+            r->addr2.s_addr = 0;
+
+            r->mask.s_addr = no_addr.s_addr;	/* 255.255.255.255 */
+
+            Q = &r->next;
+
+            debug(28, 3) ("%s --> %s\n", addr1, inet_ntoa(r->addr1));
+        }
+
+        return q;
     } else {
-	debug(28, 0) ("aclParseIpData: Bad host/IP: '%s'\n", t);
-	delete q;
-	return NULL;
+        debug(28, 0) ("aclParseIpData: Bad host/IP: '%s'\n", t);
+        delete q;
+        return NULL;
     }
+
     /* Decode addr1 */
     if (!DecodeAddress(addr1, &q->addr1, &q->mask)) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown first address '%s'\n", addr1);
-	delete q;
-	return NULL;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown first address '%s'\n", addr1);
+        delete q;
+        return NULL;
     }
+
     /* Decode addr2 */
     if (*addr2 && !DecodeAddress(addr2, &q->addr2, &q->mask)) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown second address '%s'\n", addr2);
-	delete q;
-	return NULL;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown second address '%s'\n", addr2);
+        delete q;
+        return NULL;
     }
+
     /* Decode mask */
     if (*mask && !DecodeAddress(mask, &q->mask, NULL)) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown netmask '%s'\n", mask);
-	delete q;
-	return NULL;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown netmask '%s'\n", mask);
+        delete q;
+        return NULL;
     }
+
     if ((q->addr1.s_addr & q->mask.s_addr) != q->addr1.s_addr ||
-	(q->addr2.s_addr & q->mask.s_addr) != q->addr2.s_addr)
-	debug(28, 0) ("aclParseIpData: WARNING: Netmask masks away part of the specified IP in '%s'\n", t);
+            (q->addr2.s_addr & q->mask.s_addr) != q->addr2.s_addr)
+        debug(28, 0) ("aclParseIpData: WARNING: Netmask masks away part of the specified IP in '%s'\n", t);
+
     q->addr1.s_addr &= q->mask.s_addr;
+
     q->addr2.s_addr &= q->mask.s_addr;
+
     /* 1.2.3.4/255.255.255.0  --> 1.2.3.0 */
     return q;
 }
+
 void
 ACLIP::parse()
 {
     char *t = NULL;
+
     while ((t = strtokFile())) {
-	acl_ip_data *q = acl_ip_data::FactoryParse(t);
-	while (q != NULL) {
-	    data = data->insert(q, acl_ip_data::NetworkCompare);
-	    q = q->next;
-	}
+        acl_ip_data *q = acl_ip_data::FactoryParse(t);
+
+        while (q != NULL) {
+            data = data->insert(q, acl_ip_data::NetworkCompare);
+            q = q->next;
+        }
     }
 }
 
@@ -330,6 +380,7 @@ ACLIP::valid () const
 }
 
 int
+
 ACLIP::match(struct in_addr &clientip)
 {
     static acl_ip_data ClientAddress (any_addr, any_addr, no_addr, NULL);
@@ -344,7 +395,7 @@ ACLIP::match(struct in_addr &clientip)
     acl_ip_data *ClientAddressPointer = &ClientAddress;
     data = data->splay(ClientAddressPointer, aclIpAddrNetworkCompare);
     debug(28, 3) ("aclMatchIp: '%s' %s\n",
-	inet_ntoa(clientip), splayLastResult ? "NOT found" : "found");
+                  inet_ntoa(clientip), splayLastResult ? "NOT found" : "found");
     return !splayLastResult;
 }
 
@@ -354,8 +405,10 @@ acl_ip_data::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (acl_ip_data));
+
     if (!Pool)
-	Pool = memPoolCreate("acl_ip_data", sizeof (acl_ip_data));
+        Pool = memPoolCreate("acl_ip_data", sizeof (acl_ip_data));
+
     return memPoolAlloc(Pool);
 }
 
@@ -372,4 +425,5 @@ acl_ip_data::deleteSelf() const
 }
 
 acl_ip_data::acl_ip_data () :addr1(any_addr), addr2(any_addr), mask (any_addr), next (NULL) {}
+
 acl_ip_data::acl_ip_data (struct in_addr const &anAddress1, struct in_addr const &anAddress2, struct in_addr const &aMask, acl_ip_data *aNext) : addr1(anAddress1), addr2(anAddress2), mask(aMask), next(aNext){}
@@ -38,48 +38,62 @@
 #include "ACL.h"
 #include "splay.h"
 
-class acl_ip_data {
-  public:
+class acl_ip_data
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
     static acl_ip_data *FactoryParse(char const *);
     static int NetworkCompare(acl_ip_data * const & a, acl_ip_data * const &b);
-  
+
     acl_ip_data ();
+
     acl_ip_data (struct in_addr const &, struct in_addr const &, struct in_addr const &, acl_ip_data *);
     void toStr(char *buf, int len) const;
+
     struct in_addr addr1;	/* if addr2 non-zero then its a range */
+
     struct in_addr addr2;
+
     struct in_addr mask;
     acl_ip_data *next;		/* used for parsing, not for storing */
-  private:
+
+private:
+
     static bool DecodeAddress(const char *asc, struct in_addr *addr, struct in_addr *mask);
     static MemPool *Pool;
 };
 
-class ACLIP : public ACL {
-  public:
+class ACLIP : public ACL
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const = 0;
 
     ACLIP() : data(NULL){}
+
     ~ACLIP();
-    
+
     typedef SplayNode<acl_ip_data *> IPSplay;
 
     virtual char const *typeString() const = 0;
     virtual squid_acl aclType() const = 0;
     virtual void parse();
-//    virtual bool isProxyAuth() const {return true;}
+    //    virtual bool isProxyAuth() const {return true;}
     virtual int match(ACLChecklist *checklist) = 0;
     virtual wordlist *dump() const;
     virtual bool valid () const;
-  protected:
+
+protected:
+
     int match(struct in_addr &);
     IPSplay *data;
-  private:
+
+private:
     static void DumpIpListWalkee(acl_ip_data * const & ip, void *state);
 };
 
@@ -47,8 +47,10 @@ ACLIdent::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLIdent));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLIdent", sizeof (ACLIdent));
+        Pool = memPoolCreate("ACLIdent", sizeof (ACLIdent));
+
     return memPoolAlloc(Pool);
 }
 
@@ -70,9 +72,10 @@ ACLIdent::~ACLIdent()
 }
 
 ACLIdent::ACLIdent(ACLData<char const *> *newData, char const *newType) : data (newData), type_ (newType) {}
+
 ACLIdent::ACLIdent (ACLIdent const &old) : data (old.data->clone()), type_ (old.type_)
-{
-}
+{}
+
 ACLIdent &
 ACLIdent::operator= (ACLIdent const &rhs)
 {
@@ -99,10 +102,10 @@ int
 ACLIdent::match(ACLChecklist *checklist)
 {
     if (checklist->rfc931[0]) {
-	return data->match(checklist->rfc931);
+        return data->match(checklist->rfc931);
     } else {
-	checklist->changeState(IdentLookup::Instance());
-	return 0;
+        checklist->changeState(IdentLookup::Instance());
+        return 0;
     }
 }
 
@@ -142,13 +145,14 @@ IdentLookup::checkForAsync(ACLChecklist *checklist)const
 {
     checklist->asyncInProgress(true);
     debug(28, 3) ("IdentLookup::checkForAsync: Doing ident lookup\n");
+
     if (checklist->conn() && cbdataReferenceValid(checklist->conn())) {
-	identStart(&checklist->conn()->me, &checklist->conn()->peer,
-		       LookupDone, checklist);
+        identStart(&checklist->conn()->me, &checklist->conn()->peer,
+                   LookupDone, checklist);
     } else {
-	debug(28, 1) ("IdentLookup::checkForAsync: Can't start ident lookup. No client connection\n");
-	checklist->currentAnswer(ACCESS_DENIED);
-	checklist->markFinished();
+        debug(28, 1) ("IdentLookup::checkForAsync: Can't start ident lookup. No client connection\n");
+        checklist->currentAnswer(ACCESS_DENIED);
+        checklist->markFinished();
     }
 }
 
@@ -159,17 +163,21 @@ IdentLookup::LookupDone(const char *ident, void *data)
     assert (checklist->asyncState() == IdentLookup::Instance());
 
     if (ident) {
-	xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
+        xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
     } else {
-	xstrncpy(checklist->rfc931, dash_str, USER_IDENT_SZ);
+        xstrncpy(checklist->rfc931, dash_str, USER_IDENT_SZ);
     }
+
     /*
      * Cache the ident result in the connection, to avoid redoing ident lookup
      * over and over on persistent connections
      */
     if (cbdataReferenceValid(checklist->conn()) && !checklist->conn()->rfc931[0])
-	xstrncpy(checklist->conn()->rfc931, checklist->rfc931, USER_IDENT_SZ);
+        xstrncpy(checklist->conn()->rfc931, checklist->rfc931, USER_IDENT_SZ);
+
     checklist->asyncInProgress(false);
+
     checklist->changeState (ACLChecklist::NullState::Instance());
+
     checklist->check();
 }
@@ -39,17 +39,22 @@
 #include "ACLChecklist.h"
 #include "ACLData.h"
 
-class IdentLookup : public ACLChecklist::AsyncState {
-  public:
+class IdentLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static IdentLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static IdentLookup instance_;
     static void LookupDone(const char *ident, void *data);
 };
 
-class ACLIdent : public ACL {
-  public:
+class ACLIdent : public ACL
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -58,16 +63,19 @@ class ACLIdent : public ACL {
     ACLIdent (ACLIdent const &old);
     ACLIdent & operator= (ACLIdent const &rhs);
     ~ACLIdent();
-    
+
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
+
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
     virtual bool valid () const;
     virtual ACL *clone()const;
-  private:
+
+private:
     static MemPool *Pool;
     static Prototype UserRegistryProtoype;
     static ACLIdent UserRegistryEntry_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLMatchStrategy.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLMatchStrategy.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,13 +39,19 @@
 #include "ACLData.h"
 
 /* Perhaps this should live in ACL? */
+
 template<class M>
-class ACLMatchStrategy {
-  public:
+
+class ACLMatchStrategy
+{
+
+public:
     typedef M MatchType;
     virtual int match (ACLData<M> * &, ACLChecklist *) = 0;
     virtual bool requiresRequest() const {return false;}
-    virtual ~ACLMatchStrategy(){}
-};
+
+    virtual ~ACLMatchStrategy(){}}
+
+;
 
 #endif /* SQUID_ACLMATCHSTRATEGY_H */
@@ -43,8 +43,10 @@ ACLMyIP::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLMyIP));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLMyIP", sizeof (ACLMyIP));
+        Pool = memPoolCreate("ACLMyIP", sizeof (ACLMyIP));
+
     return memPoolAlloc(Pool);
 }
 
@@ -37,18 +37,22 @@
 #define SQUID_ACLMYIP_H
 #include "ACLIP.h"
 
-class ACLMyIP : public ACLIP {
-  public:
+class ACLMyIP : public ACLIP
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
     static ACLMyIP const &RegistryEntry();
 
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
-  private:
+
+private:
     static MemPool *Pool;
     static Prototype RegistryProtoype;
     static ACLMyIP RegistryEntry_;
@@ -47,8 +47,10 @@ ACLProxyAuth::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLProxyAuth));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLProxyAuth", sizeof (ACLProxyAuth));
+        Pool = memPoolCreate("ACLProxyAuth", sizeof (ACLProxyAuth));
+
     return memPoolAlloc(Pool);
 }
 
@@ -70,9 +72,10 @@ ACLProxyAuth::~ACLProxyAuth()
 }
 
 ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) : data (newData), type_(theType) {}
+
 ACLProxyAuth::ACLProxyAuth (ACLProxyAuth const &old) : data (old.data->clone()), type_(old.type_)
-{
-}
+{}
+
 ACLProxyAuth &
 ACLProxyAuth::operator= (ACLProxyAuth const &rhs)
 {
@@ -91,25 +94,30 @@ void
 ACLProxyAuth::parse()
 {
     if (authenticateSchemeCount() == 0) {
-	debug(28, 0) ("aclProxyAuth::parse: IGNORING: Proxy Auth ACL '%s' "
-		      "because no authentication schemes were compiled.\n", cfgline);
-	return;
+        debug(28, 0) ("aclProxyAuth::parse: IGNORING: Proxy Auth ACL '%s' "
+                      "because no authentication schemes were compiled.\n", cfgline);
+        return;
     }
+
     if (authenticateActiveSchemeCount() == 0) {
-	debug(28, 0) ("aclProxyAuth::parse: IGNORING: Proxy Auth ACL '%s' "
-		      "because no authentication schemes are fully configured.\n", cfgline);
-	return;
+        debug(28, 0) ("aclProxyAuth::parse: IGNORING: Proxy Auth ACL '%s' "
+                      "because no authentication schemes are fully configured.\n", cfgline);
+        return;
     }
+
     data->parse();
 }
 
 int
 ACLProxyAuth::match(ACLChecklist *checklist)
 {
     int ti;
+
     if ((ti = checklist->authenticated()) != 1)
-	return ti;
+        return ti;
+
     ti = matchProxyAuth(checklist);
+
     return ti;
 }
 
@@ -146,7 +154,7 @@ ProxyAuthLookup::checkForAsync(ACLChecklist *checklist)const
 {
     checklist->asyncInProgress(true);
     debug(28, 3)
-      ("ACLChecklist::checkForAsync: checking password via authenticator\n");
+    ("ACLChecklist::checkForAsync: checking password via authenticator\n");
 
     auth_user_request_t *auth_user_request;
     /* make sure someone created auth_user_request for us */
@@ -164,18 +172,22 @@ ProxyAuthLookup::LookupDone(void *data, char *result)
     assert (checklist->asyncState() == ProxyAuthLookup::Instance());
 
     if (result != NULL)
-	fatal("AclLookupProxyAuthDone: Old code floating around somewhere.\nMake clean and if that doesn't work, report a bug to the squid developers.\n");
+        fatal("AclLookupProxyAuthDone: Old code floating around somewhere.\nMake clean and if that doesn't work, report a bug to the squid developers.\n");
+
     if (!authenticateValidateUser(checklist->auth_user_request) || checklist->conn() == NULL) {
-	/* credentials could not be checked either way
-	 * restart the whole process */
-	/* OR the connection was closed, there's no way to continue */
-	authenticateAuthUserRequestUnlock(checklist->auth_user_request);
-	if (checklist->conn()) {
-	    checklist->conn()->auth_user_request = NULL;
-	    checklist->conn()->auth_type = AUTH_BROKEN;
-	}
-	checklist->auth_user_request = NULL;
+        /* credentials could not be checked either way
+         * restart the whole process */
+        /* OR the connection was closed, there's no way to continue */
+        authenticateAuthUserRequestUnlock(checklist->auth_user_request);
+
+        if (checklist->conn()) {
+            checklist->conn()->auth_user_request = NULL;
+            checklist->conn()->auth_type = AUTH_BROKEN;
+        }
+
+        checklist->auth_user_request = NULL;
     }
+
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->check();
@@ -221,7 +233,7 @@ ACLProxyAuth::matchProxyAuth(ACLChecklist *checklist)
     checkAuthForCaching(checklist);
     /* check to see if we have matched the user-acl before */
     int result = cacheMatchAcl(&checklist->auth_user_request->auth_user->
-	proxy_match_cache, checklist);
+                               proxy_match_cache, checklist);
     checklist->auth_user_request = NULL;
     return result;
 }
@@ -39,25 +39,33 @@
 #include "ACLData.h"
 #include "ACLChecklist.h"
 
-class ProxyAuthLookup : public ACLChecklist::AsyncState {
-  public:
+class ProxyAuthLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static ProxyAuthLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static ProxyAuthLookup instance_;
     static void LookupDone(void *data, char *result);
 };
 
-class ProxyAuthNeeded : public ACLChecklist::AsyncState {
-  public:
+class ProxyAuthNeeded : public ACLChecklist::AsyncState
+{
+
+public:
     static ProxyAuthNeeded *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static ProxyAuthNeeded instance_;
 };
 
-class ACLProxyAuth : public ACL {
-  public:
+class ACLProxyAuth : public ACL
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -66,18 +74,22 @@ class ACLProxyAuth : public ACL {
     ACLProxyAuth(ACLData<char const *> *, char const *);
     ACLProxyAuth (ACLProxyAuth const &);
     ACLProxyAuth &operator= (ACLProxyAuth const &);
-    
+
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
+
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
     virtual bool valid () const;
     virtual bool requiresRequest() const {return true;}
+
     virtual ACL *clone()const;
     virtual int matchForCache(ACLChecklist *checklist);
-  private:
+
+private:
     static MemPool *Pool;
     static Prototype UserRegistryProtoype;
     static ACLProxyAuth UserRegistryEntry_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLReferer.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLReferer.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,8 +40,10 @@
 #include "ACLRequestHeaderStrategy.h"
 #include "ACLStrategised.h"
 
-class ACLReferer {
-  private:
+class ACLReferer
+{
+
+private:
     static ACL::Prototype RegistryProtoype;
     static ACLStrategised<char const *> RegistryEntry_;
 };
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLRegexData.cc,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLRegexData.cc,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -46,8 +46,10 @@ ACLRegexData::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLRegexData));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLRegexData", sizeof (ACLRegexData));
+        Pool = memPoolCreate("ACLRegexData", sizeof (ACLRegexData));
+
     return memPoolAlloc(Pool);
 }
 
@@ -66,7 +68,7 @@ ACLRegexData::deleteSelf() const
 ACLRegexData::~ACLRegexData()
 {
     aclDestroyRegexList(data);
-} 
+}
 
 bool
 ACLRegexData::match(char const *user)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRegexData.h,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLRegexData.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,8 +37,10 @@
 #define SQUID_ACLREGEXDATA_H
 #include "ACLData.h"
 
-class ACLRegexData : public ACLData<char const *> {
-  public:
+class ACLRegexData : public ACLData<char const *>
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -48,7 +50,8 @@ class ACLRegexData : public ACLData<char const *> {
     virtual wordlist *dump();
     virtual void parse();
     virtual ACLData<char const *> *clone() const;
-  private:
+
+private:
     static MemPool *Pool;
     relist *data;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRequestHeaderStrategy.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLRequestHeaderStrategy.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,19 +40,24 @@
 #include "ACLMatchStrategy.h"
 
 template <http_hdr_type header>
+
 class ACLRequestHeaderStrategy : public ACLMatchStrategy<char const *>
 {
-  public:
+
+public:
     virtual int match (ACLData<char const *> * &, ACLChecklist *);
     virtual bool requiresRequest() const {return true;}
+
     static ACLRequestHeaderStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLRequestHeaderStrategy(ACLRequestHeaderStrategy const &);
-  private:
+
+private:
     static ACLRequestHeaderStrategy Instance_;
     ACLRequestHeaderStrategy(){}
+
     ACLRequestHeaderStrategy&operator=(ACLRequestHeaderStrategy const &);
 };
 
@@ -61,8 +66,10 @@ int
 ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
     char const *theHeader = httpHeaderGetStr(&checklist->request->header, header);
+
     if (NULL == theHeader)
-	return 0;
+        return 0;
+
     return data->match(theHeader);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLRequestMIMEType.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLRequestMIMEType.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -41,8 +41,10 @@
 #include "ACLStrategised.h"
 #include "ACLChecklist.h"
 
-class ACLRequestMIMEType {
-  private:
+class ACLRequestMIMEType
+{
+
+private:
     static ACL::Prototype RegistryProtoype;
     static ACLStrategised<char const *> RegistryEntry_;
 };
@@ -52,8 +54,10 @@ int
 ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
     char const *theHeader = httpHeaderGetStr(&checklist->request->header, HDR_CONTENT_TYPE);
+
     if (NULL == theHeader)
-	theHeader = "";
+        theHeader = "";
+
     return data->match(theHeader);
 }
 
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLSourceDomain.cc,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLSourceDomain.cc,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -77,16 +77,18 @@ ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checkl
 {
     const char *fqdn = NULL;
     fqdn = fqdncache_gethostbyaddr(checklist->src_addr, FQDN_LOOKUP_IF_MISS);
+
     if (fqdn) {
-	return data->match(fqdn);
+        return data->match(fqdn);
     } else if (!checklist->sourceDomainChecked()) {
-	/* FIXME: reinstate a means to get to "name" 
-	debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
-		      name, inet_ntoa(checklist->src_addr));
-		      */
-	checklist->changeState(SourceDomainLookup::Instance());
-	return 0;
+        /* FIXME: reinstate a means to get to "name"
+        debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+        	      name, inet_ntoa(checklist->src_addr));
+        	      */
+        checklist->changeState(SourceDomainLookup::Instance());
+        return 0;
     }
+
     return data->match("none");
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLSourceDomain.h,v 1.2 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLSourceDomain.h,v 1.3 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -42,30 +42,38 @@
 
 class ACLSourceDomainStrategy : public ACLMatchStrategy<char const *>
 {
-  public:
+
+public:
     virtual int match (ACLData<MatchType> * &, ACLChecklist *);
     static ACLSourceDomainStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLSourceDomainStrategy(ACLSourceDomainStrategy const &);
-  private:
+
+private:
     static ACLSourceDomainStrategy Instance_;
     ACLSourceDomainStrategy(){}
+
     ACLSourceDomainStrategy&operator=(ACLSourceDomainStrategy const &);
 };
 
-class SourceDomainLookup : public ACLChecklist::AsyncState {
-  public:
+class SourceDomainLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static SourceDomainLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static SourceDomainLookup instance_;
     static void LookupDone(const char *, void *);
 };
 
-class ACLSourceDomain {
-  private:
+class ACLSourceDomain
+{
+
+private:
     static ACL::Prototype LiteralRegistryProtoype;
     static ACLStrategised<char const *> LiteralRegistryEntry_;
     static ACL::Prototype RegexRegistryProtoype;
@@ -43,8 +43,10 @@ ACLSourceIP::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLSourceIP));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLSourceIP", sizeof (ACLSourceIP));
+        Pool = memPoolCreate("ACLSourceIP", sizeof (ACLSourceIP));
+
     return memPoolAlloc(Pool);
 }
 
@@ -37,17 +37,21 @@
 #define SQUID_ACLSOURCEIP_H
 #include "ACLIP.h"
 
-class ACLSourceIP : public ACLIP {
-  public:
+class ACLSourceIP : public ACLIP
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
 
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
-  private:
+
+private:
     static MemPool *Pool;
     static Prototype RegistryProtoype;
     static ACLSourceIP RegistryEntry_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLStrategised.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLStrategised.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,8 +40,11 @@
 #include "ACLMatchStrategy.h"
 
 template <class M>
-class ACLStrategised : public ACL {
-  public:
+
+class ACLStrategised : public ACL
+{
+
+public:
     typedef M MatchType;
     void *operator new(size_t);
     void operator delete(void *);
@@ -51,16 +54,19 @@ class ACLStrategised : public ACL {
     ACLStrategised(ACLData<MatchType> *, ACLMatchStrategy<MatchType> *, char const *);
     ACLStrategised (ACLStrategised const &);
     ACLStrategised &operator= (ACLStrategised const &);
-    
+
     virtual char const *typeString() const;
     virtual squid_acl aclType() const { return ACL_DERIVED;}
+
     virtual bool requiresRequest() const {return matcher->requiresRequest();}
+
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
     virtual bool valid () const;
     virtual ACL *clone()const;
-  private:
+
+private:
     static MemPool *Pool;
     ACLData<MatchType> *data;
     char const *type_;
@@ -78,8 +84,10 @@ ACLStrategised<MatchType>::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLStrategised<MatchType>));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLStrategised", sizeof (ACLStrategised<MatchType>));
+        Pool = memPoolCreate("ACLStrategised", sizeof (ACLStrategised<MatchType>));
+
     return memPoolAlloc(Pool);
 }
 
@@ -105,10 +113,11 @@ ACLStrategised<MatchType>::~ACLStrategised()
 
 template <class MatchType>
 ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLMatchStrategy<MatchType> *theStrategy, char const *theType) : data (newData), type_(theType), matcher(theStrategy) {}
+
 template <class MatchType>
 ACLStrategised<MatchType>::ACLStrategised (ACLStrategised const &old) : data (old.data->clone()), type_(old.type_), matcher (old.matcher)
-{
-}
+{}
+
 template <class MatchType>
 ACLStrategised<MatchType> &
 ACLStrategised<MatchType>::operator= (ACLStrategised const &rhs)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLTime.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLTime.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -42,21 +42,26 @@
 
 class ACLTimeStrategy : public ACLMatchStrategy<time_t>
 {
-  public:
+
+public:
     virtual int match (ACLData<MatchType> * &, ACLChecklist *);
     static ACLTimeStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLTimeStrategy(ACLTimeStrategy const &);
-  private:
+
+private:
     static ACLTimeStrategy Instance_;
     ACLTimeStrategy(){}
+
     ACLTimeStrategy&operator=(ACLTimeStrategy const &);
 };
 
-class ACLTime {
-  public:
+class ACLTime
+{
+
+public:
     static ACL::Prototype RegistryProtoype;
     static ACLStrategised<time_t> RegistryEntry_;
 };
@@ -1,5 +1,5 @@
 /*
- * $Id: ACLTimeData.cc,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLTimeData.cc,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -45,8 +45,10 @@ ACLTimeData::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLTimeData));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLTimeData", sizeof (ACLTimeData));
+        Pool = memPoolCreate("ACLTimeData", sizeof (ACLTimeData));
+
     return memPoolAlloc(Pool);
 }
 
@@ -63,11 +65,11 @@ ACLTimeData::deleteSelf() const
 }
 
 ACLTimeData::ACLTimeData () : weekbits (0), start (0), stop (0), next (NULL) {}
- 
-ACLTimeData::ACLTimeData(ACLTimeData const &old) : weekbits(old.weekbits), start (old.start), stop (old.stop), next (NULL) 
+
+ACLTimeData::ACLTimeData(ACLTimeData const &old) : weekbits(old.weekbits), start (old.start), stop (old.stop), next (NULL)
 {
     if (old.next)
-	next = (ACLTimeData *)old.next->clone();
+        next = (ACLTimeData *)old.next->clone();
 }
 
 ACLTimeData&
@@ -77,37 +79,46 @@ ACLTimeData::operator=(ACLTimeData const &old)
     start = old.start;
     stop = old.stop;
     next = NULL;
+
     if (old.next)
-	next = (ACLTimeData *)old.next->clone();
+        next = (ACLTimeData *)old.next->clone();
+
     return *this;
 }
 
 ACLTimeData::~ACLTimeData()
 {
     if (next)
-	next->deleteSelf();
-} 
+        next->deleteSelf();
+}
 
 bool
 ACLTimeData::match(time_t when)
 {
     static time_t last_when = 0;
+
     static struct tm tm;
     time_t t;
+
     if (when != last_when) {
-	last_when = when;
-	xmemcpy(&tm, localtime(&when), sizeof(struct tm));
+        last_when = when;
+
+        xmemcpy(&tm, localtime(&when), sizeof(struct tm));
     }
+
     t = (time_t) (tm.tm_hour * 60 + tm.tm_min);
     ACLTimeData *data = this;
+
     while (data) {
-	debug(28, 3) ("aclMatchTime: checking %d in %d-%d, weekbits=%x\n",
-		      (int) t, (int) data->start, (int) data->stop, data->weekbits);
+        debug(28, 3) ("aclMatchTime: checking %d in %d-%d, weekbits=%x\n",
+                      (int) t, (int) data->start, (int) data->stop, data->weekbits);
 
-	if (t >= data->start && t <= data->stop && (data->weekbits & (1 << tm.tm_wday)))
-	    return 1;
-	data = data->next;
+        if (t >= data->start && t <= data->stop && (data->weekbits & (1 << tm.tm_wday)))
+            return 1;
+
+        data = data->next;
     }
+
     return 0;
 }
 
@@ -117,101 +128,131 @@ ACLTimeData::dump()
     wordlist *W = NULL;
     char buf[128];
     ACLTimeData *t = this;
+
     while (t != NULL) {
-	snprintf(buf, sizeof(buf), "%c%c%c%c%c%c%c %02d:%02d-%02d:%02d",
-	    t->weekbits & ACL_SUNDAY ? 'S' : '-',
-	    t->weekbits & ACL_MONDAY ? 'M' : '-',
-	    t->weekbits & ACL_TUESDAY ? 'T' : '-',
-	    t->weekbits & ACL_WEDNESDAY ? 'W' : '-',
-	    t->weekbits & ACL_THURSDAY ? 'H' : '-',
-	    t->weekbits & ACL_FRIDAY ? 'F' : '-',
-	    t->weekbits & ACL_SATURDAY ? 'A' : '-',
-	    t->start / 60, t->start % 60, t->stop / 60, t->stop % 60);
-	wordlistAdd(&W, buf);
-	t = t->next;
+        snprintf(buf, sizeof(buf), "%c%c%c%c%c%c%c %02d:%02d-%02d:%02d",
+                 t->weekbits & ACL_SUNDAY ? 'S' : '-',
+                 t->weekbits & ACL_MONDAY ? 'M' : '-',
+                 t->weekbits & ACL_TUESDAY ? 'T' : '-',
+                 t->weekbits & ACL_WEDNESDAY ? 'W' : '-',
+                 t->weekbits & ACL_THURSDAY ? 'H' : '-',
+                 t->weekbits & ACL_FRIDAY ? 'F' : '-',
+                 t->weekbits & ACL_SATURDAY ? 'A' : '-',
+                 t->start / 60, t->start % 60, t->stop / 60, t->stop % 60);
+        wordlistAdd(&W, buf);
+        t = t->next;
     }
+
     return W;
 }
 
 void
 ACLTimeData::parse()
 {
     ACLTimeData **Tail;
-    for (Tail = &next; *Tail; Tail = &((*Tail)->next));
+
+    for (Tail = &next; *Tail; Tail = &((*Tail)->next))
+
+        ;
     ACLTimeData *q = NULL;
+
     if (Tail == &next)
-	q = new ACLTimeData;
+        q = new ACLTimeData;
     else
-	q = this;
+        q = this;
+
     int h1, m1, h2, m2;
+
     char *t = NULL;
+
     while ((t = strtokFile())) {
-	if (*t < '0' || *t > '9') {
-	    /* assume its day-of-week spec */
-	    while (*t) {
-		switch (*t++) {
-		case 'S':
-		    q->weekbits |= ACL_SUNDAY;
-		    break;
-		case 'M':
-		    q->weekbits |= ACL_MONDAY;
-		    break;
-		case 'T':
-		    q->weekbits |= ACL_TUESDAY;
-		    break;
-		case 'W':
-		    q->weekbits |= ACL_WEDNESDAY;
-		    break;
-		case 'H':
-		    q->weekbits |= ACL_THURSDAY;
-		    break;
-		case 'F':
-		    q->weekbits |= ACL_FRIDAY;
-		    break;
-		case 'A':
-		    q->weekbits |= ACL_SATURDAY;
-		    break;
-		case 'D':
-		    q->weekbits |= ACL_WEEKDAYS;
-		    break;
-		case '-':
-		    /* ignore placeholder */
-		    break;
-		default:
-		    debug(28, 0) ("%s line %d: %s\n",
-			cfg_filename, config_lineno, config_input_line);
-		    debug(28, 0) ("aclParseTimeSpec: Bad Day '%c'\n", *t);
-		    break;
-		}
-	    }
-	} else {
-	    /* assume its time-of-day spec */
-	    if (sscanf(t, "%d:%d-%d:%d", &h1, &m1, &h2, &m2) < 4) {
-		debug(28, 0) ("%s line %d: %s\n",
-		    cfg_filename, config_lineno, config_input_line);
-		debug(28, 0) ("aclParseTimeSpec: IGNORING Bad time range\n");
-		if (q != this)
-		    q->deleteSelf();
-		return;
-	    }
-	    q->start = h1 * 60 + m1;
-	    q->stop = h2 * 60 + m2;
-	    if (q->start > q->stop) {
-		debug(28, 0) ("%s line %d: %s\n",
-		    cfg_filename, config_lineno, config_input_line);
-		debug(28, 0) ("aclParseTimeSpec: IGNORING Reversed time range\n");
-		if (q != this)
-		    q->deleteSelf();
-		return;
-	    }
-	}
+        if (*t < '0' || *t > '9') {
+            /* assume its day-of-week spec */
+
+            while (*t) {
+                switch (*t++) {
+
+                case 'S':
+                    q->weekbits |= ACL_SUNDAY;
+                    break;
+
+                case 'M':
+                    q->weekbits |= ACL_MONDAY;
+                    break;
+
+                case 'T':
+                    q->weekbits |= ACL_TUESDAY;
+                    break;
+
+                case 'W':
+                    q->weekbits |= ACL_WEDNESDAY;
+                    break;
+
+                case 'H':
+                    q->weekbits |= ACL_THURSDAY;
+                    break;
+
+                case 'F':
+                    q->weekbits |= ACL_FRIDAY;
+                    break;
+
+                case 'A':
+                    q->weekbits |= ACL_SATURDAY;
+                    break;
+
+                case 'D':
+                    q->weekbits |= ACL_WEEKDAYS;
+                    break;
+
+                case '-':
+                    /* ignore placeholder */
+                    break;
+
+                default:
+                    debug(28, 0) ("%s line %d: %s\n",
+                                  cfg_filename, config_lineno, config_input_line);
+                    debug(28, 0) ("aclParseTimeSpec: Bad Day '%c'\n", *t);
+                    break;
+                }
+            }
+        } else {
+            /* assume its time-of-day spec */
+
+            if (sscanf(t, "%d:%d-%d:%d", &h1, &m1, &h2, &m2) < 4) {
+                debug(28, 0) ("%s line %d: %s\n",
+                              cfg_filename, config_lineno, config_input_line);
+                debug(28, 0) ("aclParseTimeSpec: IGNORING Bad time range\n");
+
+                if (q != this)
+                    q->deleteSelf();
+
+                return;
+            }
+
+            q->start = h1 * 60 + m1;
+            q->stop = h2 * 60 + m2;
+
+            if (q->start > q->stop) {
+                debug(28, 0) ("%s line %d: %s\n",
+                              cfg_filename, config_lineno, config_input_line);
+                debug(28, 0) ("aclParseTimeSpec: IGNORING Reversed time range\n");
+
+                if (q != this)
+                    q->deleteSelf();
+
+                return;
+            }
+        }
     }
+
     if (q->start == 0 && q->stop == 0)
-	q->stop = 23 * 60 + 59;
+        q->stop = 23 * 60 + 59;
+
     if (q->weekbits == 0)
-	q->weekbits = ACL_ALLWEEK;
+        q->weekbits = ACL_ALLWEEK;
+
     if (q != this)
-	*(Tail) = q;
+        *(Tail) = q;
 }
 
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLTimeData.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLTimeData.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,8 +39,10 @@
 #include "ACL.h"
 #include "ACLData.h"
 
-class ACLTimeData : public ACLData<time_t> {
-  public:
+class ACLTimeData : public ACLData<time_t>
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -53,8 +55,8 @@ class ACLTimeData : public ACLData<time_t> {
     wordlist *dump();
     void parse();
     virtual ACLData<time_t> *clone() const;
-    
-  private:
+
+private:
     static MemPool *Pool;
     int weekbits;
     int start;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLUrl.h,v 1.1 2003/02/17 07:01:34 robertc Exp $
+ * $Id: ACLUrl.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -41,22 +41,28 @@
 
 class ACLUrlStrategy : public ACLMatchStrategy<char const *>
 {
-  public:
+
+public:
     virtual int match (ACLData<char const *> * &, ACLChecklist *);
     virtual bool requiresRequest() const {return true;}
+
     static ACLUrlStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLUrlStrategy(ACLUrlStrategy const &);
-  private:
+
+private:
     static ACLUrlStrategy Instance_;
     ACLUrlStrategy(){}
+
     ACLUrlStrategy&operator=(ACLUrlStrategy const &);
 };
 
-class ACLUrl {
-  public:
+class ACLUrl
+{
+
+public:
     static ACL::Prototype RegistryProtoype;
     static ACL::Prototype LegacyRegistryProtoype;
     static ACLStrategised<char const *> RegistryEntry_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ACLUrlPath.h,v 1.1 2003/02/17 07:01:35 robertc Exp $
+ * $Id: ACLUrlPath.h,v 1.2 2003/02/21 22:50:04 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -42,22 +42,28 @@
 
 class ACLUrlPathStrategy : public ACLMatchStrategy<char const *>
 {
-  public:
+
+public:
     virtual int match (ACLData<char const *> * &, ACLChecklist *);
     virtual bool requiresRequest() const {return true;}
+
     static ACLUrlPathStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLUrlPathStrategy(ACLUrlPathStrategy const &);
-  private:
+
+private:
     static ACLUrlPathStrategy Instance_;
     ACLUrlPathStrategy(){}
+
     ACLUrlPathStrategy&operator=(ACLUrlPathStrategy const &);
 };
 
-class ACLUrlPath {
-  public:
+class ACLUrlPath
+{
+
+public:
     static ACL::Prototype RegistryProtoype;
     static ACL::Prototype LegacyRegistryProtoype;
     static ACLStrategised<char const *> RegistryEntry_;
@@ -45,8 +45,10 @@ ACLUserData::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLUserData));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLUserData", sizeof (ACLUserData));
+        Pool = memPoolCreate("ACLUserData", sizeof (ACLUserData));
+
     return memPoolAlloc(Pool);
 }
 
@@ -72,8 +74,8 @@ xRefFree(T &thing)
 ACLUserData::~ACLUserData()
 {
     if (names)
-	names->destroy(xRefFree);
-} 
+        names->destroy(xRefFree);
+}
 
 template<class T>
 inline int
@@ -95,25 +97,29 @@ ACLUserData::match(char const *user)
     SplayNode<char *> *Top = names;
 
     debug(28, 7) ("aclMatchUser: user is %s, case_insensitive is %d\n",
-	user, flags.case_insensitive);
+                  user, flags.case_insensitive);
     debug(28, 8) ("Top is %p, Top->data is %s\n", Top,
-	(char *) (Top != NULL ? (Top)->data : "Unavailable"));
+                  (char *) (Top != NULL ? (Top)->data : "Unavailable"));
 
     if (user == NULL)
-	return 0;
+        return 0;
 
     if (flags.required) {
-	debug(28, 7) ("aclMatchUser: user REQUIRED and auth-info present.\n");
-	return 1;
+        debug(28, 7) ("aclMatchUser: user REQUIRED and auth-info present.\n");
+        return 1;
     }
+
     if (flags.case_insensitive)
-	Top = Top->splay((char *)user, splaystrcasecmp);
+        Top = Top->splay((char *)user, splaystrcasecmp);
     else
-	Top = Top->splay((char *)user, splaystrcmp);
+        Top = Top->splay((char *)user, splaystrcmp);
+
     /* Top=splay_splay(user,Top,(splayNode::SPLAYCMP *)dumping_strcmp); */
     debug(28, 7) ("aclMatchUser: returning %d,Top is %p, Top->data is %s\n",
-	!splayLastResult, Top, (char *) (Top ? Top->data : "Unavailable"));
+                  !splayLastResult, Top, (char *) (Top ? Top->data : "Unavailable"));
+
     names = Top;
+
     return !splayLastResult;
 }
 
@@ -128,16 +134,19 @@ wordlist *
 ACLUserData::dump()
 {
     wordlist *wl = NULL;
+
     if (flags.case_insensitive)
-	wordlistAdd(&wl, "-i");
+        wordlistAdd(&wl, "-i");
+
     /* damn this is VERY inefficient for long ACL lists... filling
      * a wordlist this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
     if (flags.required)
-	wordlistAdd(&wl, "REQUIRED");
+        wordlistAdd(&wl, "REQUIRED");
     else if (names)
-	names->walk(aclDumpUserListWalkee, &wl);
+        names->walk(aclDumpUserListWalkee, &wl);
+
     return wl;
 }
 
@@ -146,30 +155,37 @@ ACLUserData::parse()
 {
     debug(28, 2) ("aclParseUserList: parsing user list\n");
     char *t = NULL;
+
     if ((t = strtokFile())) {
-	debug(28, 5) ("aclParseUserList: First token is %s\n", t);
-	if (strcmp("-i", t) == 0) {
-	    debug(28, 5) ("aclParseUserList: Going case-insensitive\n");
-	    flags.case_insensitive = 1;
-	} else if (strcmp("REQUIRED", t) == 0) {
-	    debug(28, 5) ("aclParseUserList: REQUIRED-type enabled\n");
-	    flags.required = 1;
-	} else {
-	    if (flags.case_insensitive)
-		Tolower(t);
-	    names = names->insert(xstrdup(t), splaystrcmp);
-	}
+        debug(28, 5) ("aclParseUserList: First token is %s\n", t);
+
+        if (strcmp("-i", t) == 0) {
+            debug(28, 5) ("aclParseUserList: Going case-insensitive\n");
+            flags.case_insensitive = 1;
+        } else if (strcmp("REQUIRED", t) == 0) {
+            debug(28, 5) ("aclParseUserList: REQUIRED-type enabled\n");
+            flags.required = 1;
+        } else {
+            if (flags.case_insensitive)
+                Tolower(t);
+
+            names = names->insert(xstrdup(t), splaystrcmp);
+        }
     }
+
     debug(28, 3) ("aclParseUserList: Case-insensitive-switch is %d\n",
-	flags.case_insensitive);
+                  flags.case_insensitive);
     /* we might inherit from a previous declaration */
 
     debug(28, 4) ("aclParseUserList: parsing user list\n");
+
     while ((t = strtokFile())) {
-	debug(28, 6) ("aclParseUserList: Got token: %s\n", t);
-	if (flags.case_insensitive)
-	    Tolower(t);
-	names = names->insert(xstrdup(t), splaystrcmp);
+        debug(28, 6) ("aclParseUserList: Got token: %s\n", t);
+
+        if (flags.case_insensitive)
+            Tolower(t);
+
+        names = names->insert(xstrdup(t), splaystrcmp);
     }
 }
 
@@ -39,8 +39,10 @@
 #include "ACL.h"
 #include "ACLData.h"
 
-class ACLUserData : public ACLData<char const *> {
-  public:
+class ACLUserData : public ACLData<char const *>
+{
+
+public:
     void *operator new(size_t);
     void operator delete(void *);
     virtual void deleteSelf() const;
@@ -50,13 +52,22 @@ class ACLUserData : public ACLData<char const *> {
     wordlist *dump();
     void parse();
     virtual ACLData<char const *> *clone() const;
-    
+
     SplayNode<char *> *names;
-    struct {
-	unsigned int case_insensitive:1;
-	unsigned int required:1;
-    } flags;
-  private:
+
+    struct
+    {
+
+unsigned int case_insensitive:
+        1;
+
+unsigned int required:
+        1;
+    }
+
+    flags;
+
+private:
     static MemPool *Pool;
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: CacheDigest.cc,v 1.35 2003/01/23 00:37:12 robertc Exp $
+ * $Id: CacheDigest.cc,v 1.36 2003/02/21 22:50:04 robertc Exp $
  *
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -39,12 +39,16 @@
 #if USE_CACHE_DIGESTS
 
 /* local types */
-typedef struct {
+
+typedef struct
+{
     int bit_count;		/* total number of bits */
     int bit_on_count;		/* #bits turned on */
     int bseq_len_sum;		/* sum of all bit seq length */
     int bseq_count;		/* number of bit seqs */
-} CacheDigestStats;
+}
+
+CacheDigestStats;
 
 /* local functions */
 static void cacheDigestHashKey(const CacheDigest * cd, const cache_key * key);
@@ -64,7 +68,7 @@ cacheDigestInit(CacheDigest * cd, int capacity, int bpe)
     cd->mask_size = mask_size;
     cd->mask = (char *)xcalloc(cd->mask_size, 1);
     debug(70, 2) ("cacheDigestInit: capacity: %d entries, bpe: %d; size: %d bytes\n",
-	cd->capacity, cd->bits_per_entry, cd->mask_size);
+                  cd->capacity, cd->bits_per_entry, cd->mask_size);
 }
 
 CacheDigest *
@@ -131,10 +135,10 @@ cacheDigestTest(const CacheDigest * cd, const cache_key * key)
     cacheDigestHashKey(cd, key);
     /* test corresponding bits */
     return
-	CBIT_TEST(cd->mask, hashed_keys[0]) &&
-	CBIT_TEST(cd->mask, hashed_keys[1]) &&
-	CBIT_TEST(cd->mask, hashed_keys[2]) &&
-	CBIT_TEST(cd->mask, hashed_keys[3]);
+        CBIT_TEST(cd->mask, hashed_keys[0]) &&
+        CBIT_TEST(cd->mask, hashed_keys[1]) &&
+        CBIT_TEST(cd->mask, hashed_keys[2]) &&
+        CBIT_TEST(cd->mask, hashed_keys[3]);
 }
 
 void
@@ -145,30 +149,41 @@ cacheDigestAdd(CacheDigest * cd, const cache_key * key)
     cacheDigestHashKey(cd, key);
     /* turn on corresponding bits */
 #if CD_FAST_ADD
+
     CBIT_SET(cd->mask, hashed_keys[0]);
     CBIT_SET(cd->mask, hashed_keys[1]);
     CBIT_SET(cd->mask, hashed_keys[2]);
     CBIT_SET(cd->mask, hashed_keys[3]);
 #else
+
     {
-	int on_xition_cnt = 0;
-	if (!CBIT_TEST(cd->mask, hashed_keys[0])) {
-	    CBIT_SET(cd->mask, hashed_keys[0]);
-	    on_xition_cnt++;
-	}
-	if (!CBIT_TEST(cd->mask, hashed_keys[1])) {
-	    CBIT_SET(cd->mask, hashed_keys[1]);
-	    on_xition_cnt++;
-	}
-	if (!CBIT_TEST(cd->mask, hashed_keys[2])) {
-	    CBIT_SET(cd->mask, hashed_keys[2]);
-	    on_xition_cnt++;
-	}
-	if (!CBIT_TEST(cd->mask, hashed_keys[3])) {
-	    CBIT_SET(cd->mask, hashed_keys[3]);
-	    on_xition_cnt++;
-	}
-	statHistCount(&statCounter.cd.on_xition_count, on_xition_cnt);
+        int on_xition_cnt = 0;
+
+        if (!CBIT_TEST(cd->mask, hashed_keys[0]))
+        {
+            CBIT_SET(cd->mask, hashed_keys[0]);
+            on_xition_cnt++;
+        }
+
+        if (!CBIT_TEST(cd->mask, hashed_keys[1]))
+        {
+            CBIT_SET(cd->mask, hashed_keys[1]);
+            on_xition_cnt++;
+        }
+
+        if (!CBIT_TEST(cd->mask, hashed_keys[2]))
+        {
+            CBIT_SET(cd->mask, hashed_keys[2]);
+            on_xition_cnt++;
+        }
+
+        if (!CBIT_TEST(cd->mask, hashed_keys[3]))
+        {
+            CBIT_SET(cd->mask, hashed_keys[3]);
+            on_xition_cnt++;
+        }
+
+        statHistCount(&statCounter.cd.on_xition_count, on_xition_cnt);
     }
 #endif
     cd->count++;
@@ -194,18 +209,23 @@ cacheDigestStats(const CacheDigest * cd, CacheDigestStats * stats)
     int cur_seq_type = 1;
     assert(stats);
     memset(stats, 0, sizeof(*stats));
+
     while (pos-- > 0) {
-	const int is_on = 0 != CBIT_TEST(cd->mask, pos);
-	if (is_on)
-	    on_count++;
-	if (is_on != cur_seq_type || !pos) {
-	    seq_len_sum += cur_seq_len;
-	    seq_count++;
-	    cur_seq_type = is_on;
-	    cur_seq_len = 0;
-	}
-	cur_seq_len++;
+        const int is_on = 0 != CBIT_TEST(cd->mask, pos);
+
+        if (is_on)
+            on_count++;
+
+        if (is_on != cur_seq_type || !pos) {
+            seq_len_sum += cur_seq_len;
+            seq_count++;
+            cur_seq_type = is_on;
+            cur_seq_len = 0;
+        }
+
+        cur_seq_len++;
     }
+
     stats->bit_count = cd->mask_size * 8;
     stats->bit_on_count = on_count;
     stats->bseq_len_sum = seq_len_sum;
@@ -225,16 +245,17 @@ void
 cacheDigestGuessStatsUpdate(cd_guess_stats * stats, int real_hit, int guess_hit)
 {
     assert(stats);
+
     if (real_hit) {
-	if (guess_hit)
-	    stats->true_hits++;
-	else
-	    stats->false_misses++;
+        if (guess_hit)
+            stats->true_hits++;
+        else
+            stats->false_misses++;
     } else {
-	if (guess_hit)
-	    stats->false_hits++;
-	else
-	    stats->true_misses++;
+        if (guess_hit)
+            stats->false_hits++;
+        else
+            stats->true_misses++;
     }
 }
 
@@ -251,26 +272,27 @@ cacheDigestGuessStatsReport(const cd_guess_stats * stats, StoreEntry * sentry, c
     assert(tot_count == hit_count + miss_count);	/* paranoid */
 
     if (!tot_count) {
-	storeAppendPrintf(sentry, "no guess stats for %s available\n", label);
-	return;
+        storeAppendPrintf(sentry, "no guess stats for %s available\n", label);
+        return;
     }
+
     storeAppendPrintf(sentry, "Digest guesses stats for %s:\n", label);
     storeAppendPrintf(sentry, "guess\t hit\t\t miss\t\t total\t\t\n");
     storeAppendPrintf(sentry, " \t #\t %%\t #\t %%\t #\t %%\t\n");
     storeAppendPrintf(sentry, "true\t %d\t %.2f\t %d\t %.2f\t %d\t %.2f\n",
-	stats->true_hits, xpercent(stats->true_hits, tot_count),
-	stats->true_misses, xpercent(stats->true_misses, tot_count),
-	true_count, xpercent(true_count, tot_count));
+                      stats->true_hits, xpercent(stats->true_hits, tot_count),
+                      stats->true_misses, xpercent(stats->true_misses, tot_count),
+                      true_count, xpercent(true_count, tot_count));
     storeAppendPrintf(sentry, "false\t %d\t %.2f\t %d\t %.2f\t %d\t %.2f\n",
-	stats->false_hits, xpercent(stats->false_hits, tot_count),
-	stats->false_misses, xpercent(stats->false_misses, tot_count),
-	false_count, xpercent(false_count, tot_count));
+                      stats->false_hits, xpercent(stats->false_hits, tot_count),
+                      stats->false_misses, xpercent(stats->false_misses, tot_count),
+                      false_count, xpercent(false_count, tot_count));
     storeAppendPrintf(sentry, "all\t %d\t %.2f\t %d\t %.2f\t %d\t %.2f\n",
-	hit_count, xpercent(hit_count, tot_count),
-	miss_count, xpercent(miss_count, tot_count),
-	tot_count, xpercent(tot_count, tot_count));
+                      hit_count, xpercent(hit_count, tot_count),
+                      miss_count, xpercent(miss_count, tot_count),
+                      tot_count, xpercent(tot_count, tot_count));
     storeAppendPrintf(sentry, "\tclose_hits: %d ( %d%%) /* cd said hit, doc was in the peer cache, but we got a miss */\n",
-	stats->close_hits, xpercentInt(stats->close_hits, stats->false_hits));
+                      stats->close_hits, xpercentInt(stats->close_hits, stats->false_hits));
 }
 
 void
@@ -280,25 +302,25 @@ cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
     assert(cd && e);
     cacheDigestStats(cd, &stats);
     storeAppendPrintf(e, "%s digest: size: %d bytes\n",
-	label ? label : "", stats.bit_count / 8
-	);
+                      label ? label : "", stats.bit_count / 8
+                     );
     storeAppendPrintf(e, "\t entries: count: %d capacity: %d util: %d%%\n",
-	cd->count,
-	cd->capacity,
-	xpercentInt(cd->count, cd->capacity)
-	);
+                      cd->count,
+                      cd->capacity,
+                      xpercentInt(cd->count, cd->capacity)
+                     );
     storeAppendPrintf(e, "\t deletion attempts: %d\n",
-	cd->del_count
-	);
+                      cd->del_count
+                     );
     storeAppendPrintf(e, "\t bits: per entry: %d on: %d capacity: %d util: %d%%\n",
-	cd->bits_per_entry,
-	stats.bit_on_count, stats.bit_count,
-	xpercentInt(stats.bit_on_count, stats.bit_count)
-	);
+                      cd->bits_per_entry,
+                      stats.bit_on_count, stats.bit_count,
+                      xpercentInt(stats.bit_on_count, stats.bit_count)
+                     );
     storeAppendPrintf(e, "\t bit-seq: count: %d avg.len: %.2f\n",
-	stats.bseq_count,
-	xdiv(stats.bseq_len_sum, stats.bseq_count)
-	);
+                      stats.bseq_count,
+                      xdiv(stats.bseq_len_sum, stats.bseq_count)
+                     );
 }
 
 size_t
@@ -319,8 +341,8 @@ cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
     hashed_keys[2] = htonl(tmp_keys[2]) % bit_count;
     hashed_keys[3] = htonl(tmp_keys[3]) % bit_count;
     debug(70, 9) ("cacheDigestHashKey: %s -(%d)-> %d %d %d %d\n",
-	storeKeyText(key), bit_count,
-	hashed_keys[0], hashed_keys[1], hashed_keys[2], hashed_keys[3]);
+                  storeKeyText(key), bit_count,
+                  hashed_keys[0], hashed_keys[1], hashed_keys[2], hashed_keys[3]);
 }
 
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: CommonPool.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: CommonPool.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -50,17 +50,22 @@
  * Then we have a legacy composite which returns class 1/2/3, and new 
  * composites which return a descriptor of some sort.
  */
-class CommonPool {
-  public:
+
+class CommonPool
+{
+
+public:
     void *operator new(size_t);
     void operator delete (void *);
     void deleteSelf() const;
     static CommonPool *Factory (unsigned char _class, CompositePoolNode::Pointer&);
     char const* theClassTypeLabel() const {return typeLabel.buf();}
+
 protected:
     CommonPool();
     String typeLabel;
 };
+
 #endif
 #endif /* COMMONPOOL_H */
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: CompositePoolNode.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: CompositePoolNode.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -48,19 +48,26 @@
 #include "DelayIdComposite.h"
 
 class StoreEntry;
+
 class AuthUserRequest;
-class CompositePoolNode : public RefCountable, public Updateable {
+
+class CompositePoolNode : public RefCountable, public Updateable
+{
+
 public:
     typedef RefCount<CompositePoolNode> Pointer;
     void *operator new(size_t);
     void operator delete (void *);
     virtual void deleteSelf() const;
     virtual ~CompositePoolNode(){}
+
     virtual void stats(StoreEntry * sentry) =0;
     virtual void dump(StoreEntry *entry) const =0;
     virtual void update(int incr) =0;
     virtual void parse() = 0;
+
     virtual DelayIdComposite::Pointer id(struct in_addr &src_addr, AuthUserRequest *) = 0;
 };
+
 #endif
 #endif /* COMPOSITEPOOLNODE_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Config.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: Config.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,10 +35,12 @@
 
 #ifndef SQUID_CONFIG_H_
 #define SQUID_CONFIG_H_
-  
-class ConfigParser {
+
+class ConfigParser
+{
+
 public:
-  static void ParseUShort(u_short *var);
+    static void ParseUShort(u_short *var);
 };
 
 #endif /* SQUID_CONFIG_H_ */
@@ -1,5 +1,5 @@
 /*
- * $Id: ConnectionDetail.h,v 1.1 2003/02/14 13:59:50 robertc Exp $
+ * $Id: ConnectionDetail.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Robert Collins
@@ -37,9 +37,13 @@
 #ifndef _SQUIDCONNECTIONDETAIL_H_
 #define _SQUIDCONNECTIONDETAIL_H_
 
-class ConnectionDetail {
-  public:
+class ConnectionDetail
+{
+
+public:
+
     struct sockaddr_in me;
+
     struct sockaddr_in peer;
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Debug.h,v 1.2 2003/01/23 00:37:12 robertc Exp $
+ * $Id: Debug.h,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 0     Debug Routines
  * AUTHOR: Harvest Derived
@@ -36,11 +36,12 @@
 #ifndef SQUID_DEBUG
 #define SQUID_DEBUG
 
-class Debug 
+class Debug
 {
+
 public:
-  static int Levels[MAX_DEBUG_SECTIONS];
-  static int level;
+    static int Levels[MAX_DEBUG_SECTIONS];
+    static int level;
 };
 
 #endif /* SQUID_DEBUG */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayBucket.cc,v 1.2 2003/02/13 22:20:37 robertc Exp $
+ * $Id: DelayBucket.cc,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -72,8 +72,8 @@ void
 DelayBucket::update (DelaySpec const &rate, int incr)
 {
     if (rate.restore_bps != -1 &&
-	(level() += rate.restore_bps * incr) > rate.max_bytes)
-	level() = rate.max_bytes;
+            (level() += rate.restore_bps * incr) > rate.max_bytes)
+        level() = rate.max_bytes;
 }
 
 int
@@ -93,8 +93,8 @@ void
 DelayBucket::init (DelaySpec const &rate)
 {
     level() = (int) (((double)rate.max_bytes *
-	      Config.Delay.initial) / 100);
+                      Config.Delay.initial) / 100);
 }
- 
+
 #endif
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayBucket.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelayBucket.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,15 +38,21 @@
 
 class DelaySpec;
 /* don't use remote storage for these */
-class DelayBucket {
+
+class DelayBucket
+{
+
 public:
     int const& level() const {return level_;}
+
     int & level() {return level_;}
+
     void stats(StoreEntry *)const;
     void update (DelaySpec const &, int incr);
     int bytesWanted (int min, int max) const;
     void bytesIn(int qty);
     void init (DelaySpec const &);
+
 private:
     int level_;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayConfig.cc,v 1.3 2003/02/12 06:10:58 robertc Exp $
+ * $Id: DelayConfig.cc,v 1.4 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -62,16 +62,20 @@ DelayConfig::parsePoolClass()
     ushort pool;
 
     ConfigParser::ParseUShort(&pool);
+
     if (pool < 1 || pool > DelayPools::pools()) {
-	debug(3, 0) ("parse_delay_pool_class: Ignoring pool %d not in 1 .. %d\n", pool, DelayPools::pools());
-	return;
+        debug(3, 0) ("parse_delay_pool_class: Ignoring pool %d not in 1 .. %d\n", pool, DelayPools::pools());
+        return;
     }
+
     ushort delay_class_;
     ConfigParser::ParseUShort(&delay_class_);
+
     if (delay_class_ < 1 || delay_class_ > 4) {
-	debug(3, 0) ("parse_delay_pool_class: Ignoring pool %d class %d not in 1 .. 4\n", pool, delay_class_);
-	return;
+        debug(3, 0) ("parse_delay_pool_class: Ignoring pool %d class %d not in 1 .. 4\n", pool, delay_class_);
+        return;
     }
+
     pool--;
 
     DelayPools::delay_data[pool].createPool(delay_class_);
@@ -82,16 +86,19 @@ DelayConfig::parsePoolRates()
 {
     ushort pool;
     ConfigParser::ParseUShort(&pool);
+
     if (pool < 1 || pool > DelayPools::pools()) {
-	debug(3, 0) ("parse_delay_pool_rates: Ignoring pool %d not in 1 .. %d\n", pool, DelayPools::pools());
-	return;
+        debug(3, 0) ("parse_delay_pool_rates: Ignoring pool %d not in 1 .. %d\n", pool, DelayPools::pools());
+        return;
     }
+
     pool--;
 
     if (!DelayPools::delay_data[pool].theComposite().getRaw()) {
-	debug(3, 0) ("parse_delay_pool_rates: Ignoring pool %d attempt to set rates with class not set\n", pool + 1);
-	return;
+        debug(3, 0) ("parse_delay_pool_rates: Ignoring pool %d attempt to set rates with class not set\n", pool + 1);
+        return;
     }
+
     DelayPools::delay_data[pool].parse();
 }
 
@@ -101,10 +108,12 @@ DelayConfig::parsePoolAccess()
     ushort pool;
 
     ConfigParser::ParseUShort(&pool);
+
     if (pool < 1 || pool > DelayPools::pools()) {
-	debug(3, 0) ("parse_delay_pool_rates: Ignoring pool %d not in 1 .. %d\n", pool, DelayPools::pools());
-	return;
+        debug(3, 0) ("parse_delay_pool_rates: Ignoring pool %d not in 1 .. %d\n", pool, DelayPools::pools());
+        return;
     }
+
     --pool;
     aclParseAccessLine(&DelayPools::delay_data[pool].access);
 }
@@ -122,11 +131,14 @@ DelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
     int i;
 
     if (!DelayPools::pools()) {
-	storeAppendPrintf(entry, "%s 0\n", name);
-	return;
+        storeAppendPrintf(entry, "%s 0\n", name);
+        return;
     }
+
     storeAppendPrintf(entry, "%s %d\n", name, DelayPools::pools());
+
     for (i = 0; i < DelayPools::pools(); i++)
-	DelayPools::delay_data[i].dump (entry, i);
+        DelayPools::delay_data[i].dump (entry, i);
 }
+
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayConfig.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelayConfig.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,8 +36,10 @@
 #ifndef SQUID_DELAYCONFIG_H
 #define SQUID_DELAYCONFIG_H
 
-class DelayConfig {
-  public:
+class DelayConfig
+{
+
+public:
     void freePoolCount();
     void dumpPoolCount(StoreEntry * entry, const char *name) const;
     void parsePoolCount();
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayId.cc,v 1.3 2003/02/13 10:28:01 robertc Exp $
+ * $Id: DelayId.cc,v 1.4 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -65,18 +65,16 @@
 */
 
 DelayId::DelayId () : pool_ (0), compositeId(NULL)
-{
-}
+{}
 
-DelayId::DelayId (unsigned short aPool) : 
-pool_ (aPool), compositeId (NULL)
+DelayId::DelayId (unsigned short aPool) :
+        pool_ (aPool), compositeId (NULL)
 {
     debug (77,3)("DelayId::DelayId: Pool %du\n", aPool);
 }
 
 DelayId::~DelayId ()
-{
-}
+{}
 
 void
 DelayId::compositePosition(DelayIdComposite::Pointer newPosition)
@@ -99,7 +97,7 @@ DelayId::operator == (DelayId const &rhs) const
     return pool_ == rhs.pool_ && compositeId == rhs.compositeId;
 }
 
-DelayId::operator bool() const 
+DelayId::operator bool() const
 {
     return pool_ || compositeId.getRaw();
 }
@@ -113,24 +111,28 @@ DelayId::DelayClient(clientHttpRequest * http)
     r = http->request;
 
     if (r->client_addr.s_addr == INADDR_BROADCAST) {
-	debug(77, 2) ("delayClient: WARNING: Called with 'allones' address, ignoring\n");
-	return DelayId();
+        debug(77, 2) ("delayClient: WARNING: Called with 'allones' address, ignoring\n");
+        return DelayId();
     }
 
     ACLChecklist ch;
     ch.src_addr = r->client_addr;
     ch.my_addr = r->my_addr;
     ch.my_port = r->my_port;
+
     if (http->conn)
-	ch.conn(cbdataReference(http->conn));
+        ch.conn(cbdataReference(http->conn));
+
     ch.request = requestLink(r);
+
     for (pool = 0; pool < DelayPools::pools(); pool++)
-	if (DelayPools::delay_data[pool].theComposite().getRaw() &&
-	    aclCheckFast(DelayPools::delay_data[pool].access, &ch)) {
-	    DelayId result (pool + 1);
-	    result.compositePosition(DelayPools::delay_data[pool].theComposite()->id(ch.src_addr, r->auth_user_request));
-	    return result;
-	}
+        if (DelayPools::delay_data[pool].theComposite().getRaw() &&
+                aclCheckFast(DelayPools::delay_data[pool].access, &ch)) {
+            DelayId result (pool + 1);
+            result.compositePosition(DelayPools::delay_data[pool].theComposite()->id(ch.src_addr, r->auth_user_request));
+            return result;
+        }
+
     return DelayId();
 }
 
@@ -142,13 +144,16 @@ int
 DelayId::bytesWanted(int min, int max) const
 {
     /* unlimited */
+
     if (! (*this))
-	return XMAX(min, max);
-    
+        return XMAX(min, max);
+
     /* limited */
     int nbytes = XMAX(min, max);
+
     if (compositeId.getRaw())
-	nbytes = compositeId->bytesWanted(min, nbytes);
+        nbytes = compositeId->bytesWanted(min, nbytes);
+
     return nbytes;
 }
 
@@ -161,14 +166,15 @@ void
 DelayId::bytesIn(int qty)
 {
     if (! (*this))
-	return;
+        return;
 
     unsigned short tempPool = pool() - 1;
 
     assert (tempPool != 0xFFFF);
 
     if (compositeId.getRaw())
-	compositeId->bytesIn(qty);
+        compositeId->bytesIn(qty);
 }
+
 #endif
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayId.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelayId.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -39,8 +39,10 @@
 class ClientHttpRequest;
 #include "DelayIdComposite.h"
 
-class DelayId {
-  public:
+class DelayId
+{
+
+public:
     static DelayId DelayClient (ClientHttpRequest *);
     DelayId ();
     DelayId (unsigned short);
@@ -53,8 +55,10 @@ class DelayId {
     operator bool() const;
     int bytesWanted(int min, int max) const;
     void bytesIn (int qty);
-  private:
+
+private:
     unsigned short pool_;
     DelayIdComposite::Pointer compositeId;
 };
+
 #endif /* SQUID_DELAYID_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayIdComposite.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelayIdComposite.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -45,11 +45,14 @@
 #include "squid.h"
 #include "RefCount.h"
 
-class DelayIdComposite : public RefCountable {
+class DelayIdComposite : public RefCountable
+{
+
 public:
     typedef RefCount<DelayIdComposite> Pointer;
     virtual void deleteSelf() const = 0;
     virtual inline ~DelayIdComposite(){}
+
     virtual int bytesWanted (int min, int max) const =0;
     virtual void bytesIn(int qty) = 0;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayPool.cc,v 1.2 2003/02/06 09:57:35 robertc Exp $
+ * $Id: DelayPool.cc,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -53,9 +53,10 @@ DelayPool::DelayPool() : pool (NULL), access (NULL)
 DelayPool::~DelayPool()
 {
     if (pool)
-	freeData();
+        freeData();
+
     if (access)
-	aclDestroyAccessList(&access);
+        aclDestroyAccessList(&access);
 }
 
 void
@@ -68,22 +69,30 @@ DelayPool::parse()
 void
 DelayPool::dump (StoreEntry *entry, unsigned int i) const
 {
-	if (!theComposite().getRaw())
-	    return;
-	storeAppendPrintf(entry, "delay_class %d %s\n", i + 1, pool->theClassTypeLabel());
-	LOCAL_ARRAY(char, nom, 32);
-	snprintf(nom, 32, "delay_access %d", i + 1);
-	dump_acl_access(entry, nom, access);
-	storeAppendPrintf(entry, "delay_parameters %d", i + 1);
-	theComposite()->dump (entry);
-	storeAppendPrintf(entry, "\n");
+    if (!theComposite().getRaw())
+        return;
+
+    storeAppendPrintf(entry, "delay_class %d %s\n", i + 1, pool->theClassTypeLabel());
+
+    LOCAL_ARRAY(char, nom, 32);
+
+    snprintf(nom, 32, "delay_access %d", i + 1);
+
+    dump_acl_access(entry, nom, access);
+
+    storeAppendPrintf(entry, "delay_parameters %d", i + 1);
+
+    theComposite()->dump (entry);
+
+    storeAppendPrintf(entry, "\n");
 }
 
 void
 DelayPool::createPool(u_char delay_class)
 {
     if (pool)
-	freeData();
+        freeData();
+
     pool = CommonPool::Factory(delay_class, theComposite_);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayPool.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelayPool.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -47,11 +47,15 @@
 #include "CompositePoolNode.h"
 
 class StoreEntry;
+
 class CommonPool;
+
 class acl_access;
 
-class DelayPool {
-  public:
+class DelayPool
+{
+
+public:
     DelayPool();
     ~DelayPool();
     void freeData();
@@ -60,10 +64,14 @@ class DelayPool {
     void dump (StoreEntry *, unsigned int poolNumberMinusOne) const;
     CommonPool *pool;
     CompositePoolNode::Pointer theComposite() {return theComposite_;}
+
     CompositePoolNode::Pointer const theComposite() const{return theComposite_;}
+
     acl_access *access;
-  private:
+
+private:
     CompositePoolNode::Pointer theComposite_;
 };
+
 #endif
 #endif /* DELAYPOOL_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayPools.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelayPools.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,15 +38,21 @@
 
 #include "Array.h"
 
-class Updateable {
-  public:
+class Updateable
+{
+
+public:
     virtual ~Updateable(){}
+
     virtual void update(int) = 0;
 };
 
 class DelayPool;
-class DelayPools {
-  public:
+
+class DelayPools
+{
+
+public:
     static void Init();
     static void Update(void *);
     static void SetNoDelay(int fd);
@@ -60,7 +66,8 @@ class DelayPools {
     static void deregisterForUpdates (Updateable *);
     static long MemoryUsed;
     static DelayPool *delay_data;
-  private:
+
+private:
     static void Stats(StoreEntry *);
     static void InitDelayData();
     static time_t LastUpdate;
@@ -69,4 +76,5 @@ class DelayPools {
     static void FreeDelayData ();
     static Vector<Updateable *> toUpdate;
 };
+
 #endif /* SQUID_DELAYPOOLS_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelaySpec.cc,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelaySpec.cc,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -45,16 +45,16 @@
 #include "Store.h"
 
 DelaySpec::DelaySpec() : restore_bps(-1), max_bytes (-1)
-{
-}
+{}
 
 void
 DelaySpec::stats (StoreEntry * sentry, char const *label) const
 {
     if (restore_bps == -1) {
-	storeAppendPrintf(sentry, "\t%s:\n\t\tDisabled.\n\n", label);
-	return;
+        storeAppendPrintf(sentry, "\t%s:\n\t\tDisabled.\n\n", label);
+        return;
     }
+
     storeAppendPrintf(sentry, "\t%s:\n", label);
     storeAppendPrintf(sentry, "\t\tMax: %d\n", max_bytes);
     storeAppendPrintf(sentry, "\t\tRestore: %d\n", restore_bps);
@@ -72,13 +72,19 @@ DelaySpec::parse()
     int i;
     char *token;
     token = strtok(NULL, "/");
+
     if (token == NULL)
-	self_destruct();
+        self_destruct();
+
     if (sscanf(token, "%d", &i) != 1)
-	self_destruct();
+        self_destruct();
+
     restore_bps = i;
+
     i = GetInteger();
+
     max_bytes = i;
 }
+
 #endif
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelaySpec.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: DelaySpec.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -34,8 +34,10 @@
 #ifndef SQUID_DELAYSPEC_H
 #define SQUID_DELAYSPEC_H
 
-class DelaySpec {
-  public:
+class DelaySpec
+{
+
+public:
     DelaySpec();
     void stats (StoreEntry * sentry, char const *) const;
     void dump (StoreEntry *) const;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayUser.cc,v 1.3 2003/02/08 01:45:47 robertc Exp $
+ * $Id: DelayUser.cc,v 1.4 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -88,8 +88,7 @@ DelayUserCmp(DelayUserBucket::Pointer const &left, DelayUserBucket::Pointer cons
 
 void
 DelayUserFree(DelayUserBucket::Pointer &)
-{
-}
+{}
 
 void
 DelayUserStatsWalkee(DelayUserBucket::Pointer const &current, void *state)
@@ -101,13 +100,17 @@ void
 DelayUser::stats(StoreEntry * sentry)
 {
     spec.stats (sentry, "Per User");
+
     if (spec.restore_bps == -1)
-	return;
+        return;
+
     storeAppendPrintf(sentry, "\t\tCurrent: ");
+
     if (!buckets.head) {
-	storeAppendPrintf (sentry, "Not used yet.\n\n");
-	return;
+        storeAppendPrintf (sentry, "Not used yet.\n\n");
+        return;
     }
+
     buckets.head->walk(DelayUserStatsWalkee, sentry);
     storeAppendPrintf(sentry, "\n\n");
 }
@@ -118,19 +121,22 @@ DelayUser::dump(StoreEntry *entry) const
     spec.dump(entry);
 }
 
-struct DelayUserUpdater 
+struct DelayUserUpdater
 {
     DelayUserUpdater (DelaySpec &_spec, int _incr):spec(_spec),incr(_incr){};
+
     DelaySpec spec;
     int incr;
 };
+
 void
 DelayUserUpdateWalkee(DelayUserBucket::Pointer const &current, void *state)
 {
     DelayUserUpdater *t = (DelayUserUpdater *)state;
     /* This doesn't change the value of the DelayUserBucket, so is safe */
     const_cast<DelayUserBucket *>(current.getRaw())->theBucket.update(t->spec, t->incr);
 }
+
 void
 DelayUser::update(int incr)
 {
@@ -145,10 +151,12 @@ DelayUser::parse()
 }
 
 DelayIdComposite::Pointer
+
 DelayUser::id(struct in_addr &src_addr, AuthUserRequest *authRequest)
 {
     if (!authRequest)
-	return new NullDelayId;
+        return new NullDelayId;
+
     return new Id(this, authRequest->auth_user);
 }
 
@@ -209,10 +217,12 @@ DelayUser::Id::Id(DelayUser::Pointer aDelayUser,AuthUser *aUser) : theUser(aDela
 {
     theBucket = new DelayUserBucket(aUser);
     DelayUserBucket::Pointer const *existing = theUser->buckets.find(theBucket, DelayUserCmp);
+
     if (existing) {
-	theBucket = *existing;
-	return;
+        theBucket = *existing;
+        return;
     }
+
     theBucket->theBucket.init(theUser->spec);
     theUser->buckets.head = theUser->buckets.head->insert (theBucket, DelayUserCmp);
 }
@@ -233,4 +243,5 @@ DelayUser::Id::bytesIn(int qty)
 {
     theBucket->theBucket.bytesIn(qty);
 }
+
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayUser.h,v 1.2 2003/02/08 01:45:47 robertc Exp $
+ * $Id: DelayUser.h,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -49,20 +49,25 @@
 #include "Array.h"
 #include "splay.h"
 
-class DelayUserBucket : public RefCountable {
-  public:
+class DelayUserBucket : public RefCountable
+{
+
+public:
     typedef RefCount<DelayUserBucket> Pointer;
     void *operator new(size_t);
     void operator delete (void *);
     virtual void deleteSelf() const {delete this;}
+
     void stats(StoreEntry *)const;
     DelayUserBucket(AuthUser *);
     ~DelayUserBucket();
     DelayBucket theBucket;
     AuthUser *authUser;
 };
 
-class DelayUser : public CompositePoolNode {
+class DelayUser : public CompositePoolNode
+{
+
 public:
     typedef RefCount<DelayUser> Pointer;
     void *operator new(size_t);
@@ -74,23 +79,30 @@ class DelayUser : public CompositePoolNode {
     virtual void dump(StoreEntry *entry) const;
     virtual void update(int incr);
     virtual void parse();
+
     virtual DelayIdComposite::Pointer id(struct in_addr &src_addr, AuthUserRequest *);
 
 private:
-    class Id:public DelayIdComposite {
-      public:
-	void *operator new(size_t);
-	void operator delete (void *);
-	virtual void deleteSelf() const;
-	Id (DelayUser::Pointer, AuthUser *);
-	~Id();
-	virtual int bytesWanted (int min, int max) const;
-	virtual void bytesIn(int qty);
-      private:
-	DelayUser::Pointer theUser;
-	DelayUserBucket::Pointer theBucket;
+
+class Id:public DelayIdComposite
+    {
+
+    public:
+        void *operator new(size_t);
+        void operator delete (void *);
+        virtual void deleteSelf() const;
+        Id (DelayUser::Pointer, AuthUser *);
+        ~Id();
+        virtual int bytesWanted (int min, int max) const;
+        virtual void bytesIn(int qty);
+
+    private:
+        DelayUser::Pointer theUser;
+        DelayUserBucket::Pointer theBucket;
     };
+
     DelaySpec spec;
     Splay<DelayUserBucket::Pointer> buckets;
 };
+
 #endif /* DELAYUSER_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayVector.cc,v 1.2 2003/02/06 09:57:36 robertc Exp $
+ * $Id: DelayVector.cc,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -64,50 +64,54 @@ DelayVector::deleteSelf() const
 }
 
 DelayVector::~DelayVector()
-{
-}
+{}
 
 void
 DelayVector::stats(StoreEntry * sentry)
 {
     iterator pos = pools.begin();
+
     while (pos != pools.end()) {
-	(*pos)->stats(sentry);
-	++pos;
+        (*pos)->stats(sentry);
+        ++pos;
     }
 }
 
 void
 DelayVector::dump(StoreEntry *entry) const
 {
     const_iterator pos = pools.begin();
+
     while (pos != pools.end()) {
-	(*pos)->dump(entry);
-	++pos;
+        (*pos)->dump(entry);
+        ++pos;
     }
 }
 
 void
 DelayVector::update(int incr)
 {
     iterator pos = pools.begin();
+
     while (pos != pools.end()) {
-	(*pos)->update(incr);
-	++pos;
+        (*pos)->update(incr);
+        ++pos;
     }
 }
 
 void
 DelayVector::parse()
 {
     iterator pos = pools.begin();
+
     while (pos != pools.end()) {
-	(*pos)->parse();
-	++pos;
+        (*pos)->parse();
+        ++pos;
     }
 }
 
 DelayIdComposite::Pointer
+
 DelayVector::id(struct in_addr &src_addr, AuthUserRequest *authUser)
 {
     return new Id(this, src_addr, authUser);
@@ -143,9 +147,11 @@ DelayVector::Id::Id(DelayVector::Pointer aDelayVector,struct in_addr &src_addr,
 {
     debug(77,3)("DelayVector::Id::Id\n");
     DelayVector::iterator pos = theVector->pools.begin();
-    while (pos != theVector->pools.end()) {
-	ids.push_back ((*pos)->id (src_addr, authUser));
-	++pos;
+
+    while (pos != theVector->pools.end())
+    {
+        ids.push_back ((*pos)->id (src_addr, authUser));
+        ++pos;
     }
 }
 
@@ -159,10 +165,12 @@ DelayVector::Id::bytesWanted (int min, int max) const
 {
     int nbytes = max;
     const_iterator pos = ids.begin();
+
     while (pos != ids.end()) {
-	nbytes = XMIN (nbytes, (*pos)->bytesWanted(min, nbytes));
-	++pos;
+        nbytes = XMIN (nbytes, (*pos)->bytesWanted(min, nbytes));
+        ++pos;
     }
+
     nbytes = XMAX(min, nbytes);
     return nbytes;
 }
@@ -171,9 +179,11 @@ void
 DelayVector::Id::bytesIn(int qty)
 {
     iterator pos = ids.begin();
+
     while (pos != ids.end()) {
-	(*pos)->bytesIn(qty);
-	++pos;
+        (*pos)->bytesIn(qty);
+        ++pos;
     }
 }
+
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: DelayVector.h,v 1.2 2003/02/06 09:57:36 robertc Exp $
+ * $Id: DelayVector.h,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,7 +38,9 @@
 
 #include "CompositePoolNode.h"
 
-class DelayVector : public CompositePoolNode{
+class DelayVector : public CompositePoolNode
+{
+
 public:
     typedef RefCount<DelayVector> Pointer;
     void *operator new(size_t);
@@ -49,24 +51,32 @@ class DelayVector : public CompositePoolNode{
     virtual void dump(StoreEntry *entry) const;
     virtual void update(int incr);
     virtual void parse();
+
     virtual DelayIdComposite::Pointer id(struct in_addr &src_addr, AuthUserRequest *);
     void push_back (CompositePoolNode::Pointer);
+
 private:
-    class Id:public DelayIdComposite {
-      public:
-	void *operator new(size_t);
-	void operator delete (void *);
-	virtual void deleteSelf() const;
-	Id (DelayVector::Pointer,struct in_addr &src_addr, AuthUserRequest *);
-	~Id();
-	virtual int bytesWanted (int min, int max) const;
-	virtual void bytesIn(int qty);
-      private:
-	DelayVector::Pointer theVector;
-	Vector<DelayIdComposite::Pointer> ids;
-	typedef Vector<DelayIdComposite::Pointer>::iterator iterator;
-	typedef Vector<DelayIdComposite::Pointer>::const_iterator const_iterator;
+
+class Id:public DelayIdComposite
+    {
+
+    public:
+        void *operator new(size_t);
+        void operator delete (void *);
+        virtual void deleteSelf() const;
+
+        Id (DelayVector::Pointer,struct in_addr &src_addr, AuthUserRequest *);
+        ~Id();
+        virtual int bytesWanted (int min, int max) const;
+        virtual void bytesIn(int qty);
+
+    private:
+        DelayVector::Pointer theVector;
+        Vector<DelayIdComposite::Pointer> ids;
+        typedef Vector<DelayIdComposite::Pointer>::iterator iterator;
+        typedef Vector<DelayIdComposite::Pointer>::const_iterator const_iterator;
     };
+
     Vector<CompositePoolNode::Pointer> pools;
     typedef Vector<CompositePoolNode::Pointer>::iterator iterator;
     typedef Vector<CompositePoolNode::Pointer>::const_iterator const_iterator;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ETag.cc,v 1.9 2003/01/23 00:37:12 robertc Exp $
+ * $Id: ETag.cc,v 1.10 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: none          ETag parsing support
  * AUTHOR: Alex Rousskov
@@ -49,12 +49,16 @@ etagParseInit(ETag * etag, const char *str)
     assert(etag && str);
     etag->str = NULL;
     etag->weak = !strncmp(str, "W/", 2);
+
     if (etag->weak)
-	str += 2;
+        str += 2;
+
     /* check format (quoted-string) */
     len = strlen(str);
+
     if (len >= 2 && str[0] == '"' && str[len - 1] == '"')
-	etag->str = str;
+        etag->str = str;
+
     return etag->str != NULL;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ExternalACL.h,v 1.1 2003/02/13 08:07:47 robertc Exp $
+ * $Id: ExternalACL.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,12 +36,17 @@
 #ifndef SQUID_EXTERNALACL_H
 #define SQUID_EXTERNALACL_H
 #include "ACLChecklist.h"
-class ExternalACLLookup : public ACLChecklist::AsyncState {
-  public:
+
+class ExternalACLLookup : public ACLChecklist::AsyncState
+{
+
+public:
     static ExternalACLLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
-  private:
+
+private:
     static ExternalACLLookup instance_;
     static void LookupDone(void *data, void *result);
 };
+
 #endif /* SQUID_EXTERNALACL_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Generic.h,v 1.3 2003/01/23 00:37:12 robertc Exp $
+ * $Id: Generic.h,v 1.4 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,7 +35,9 @@
 #define SQUID_GENERIC_H
 
 template <class _Arg, class _Result>
-struct unary_function {
+
+struct unary_function
+{
     typedef _Arg argument_type;
     typedef _Result result_type;
 };
@@ -44,7 +46,8 @@ template <class L, class T>
 T& for_each(L const &head, T& visitor)
 {
     for (L const *node = &head; node; node=node->next)
-	visitor(*node);
+        visitor(*node);
+
     return visitor;
 }
 
@@ -53,7 +56,8 @@ template <class T>
 T& for_each(dlink_list const &collection, T& visitor)
 {
     for (dlink_node const *node = collection.head; node; node=node->next)
-	visitor(*(typename T::argument_type const *)node->data);
+        visitor(*(typename T::argument_type const *)node->data);
+
     return visitor;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpBody.cc,v 1.19 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpBody.cc,v 1.20 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 56    HTTP Message Body
  * AUTHOR: Alex Rousskov
@@ -46,8 +46,9 @@ void
 httpBodyClean(HttpBody * body)
 {
     assert(body);
+
     if (!memBufIsNull(&body->mb))
-	memBufClean(&body->mb);
+        memBufClean(&body->mb);
 }
 
 /* set body by absorbing mb */
@@ -63,8 +64,9 @@ void
 httpBodyPackInto(const HttpBody * body, Packer * p)
 {
     assert(body && p);
+
     if (body->mb.size)
-	packerAppend(p, body->mb.buf, body->mb.size);
+        packerAppend(p, body->mb.buf, body->mb.size);
 }
 
 #if UNUSED_CODE
@@ -73,4 +75,5 @@ httpBodyPtr(const HttpBody * body)
 {
     return body->mb.buf ? body->mb.buf : "";
 }
+
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrCc.cc,v 1.24 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHdrCc.cc,v 1.25 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 65    HTTP Cache Control Header
  * AUTHOR: Alex Rousskov
@@ -39,20 +39,22 @@
 
 /* this table is used for parsing cache control header */
 static const HttpHeaderFieldAttrs CcAttrs[CC_ENUM_END] =
-{
-    {"public", (http_hdr_type)CC_PUBLIC},
-    {"private", (http_hdr_type)CC_PRIVATE},
-    {"no-cache", (http_hdr_type)CC_NO_CACHE},
-    {"no-store", (http_hdr_type)CC_NO_STORE},
-    {"no-transform", (http_hdr_type)CC_NO_TRANSFORM},
-    {"must-revalidate", (http_hdr_type)CC_MUST_REVALIDATE},
-    {"proxy-revalidate", (http_hdr_type)CC_PROXY_REVALIDATE},
-    {"only-if-cached", (http_hdr_type)CC_ONLY_IF_CACHED},
-    {"max-age", (http_hdr_type)CC_MAX_AGE},
-    {"s-maxage", (http_hdr_type)CC_S_MAXAGE},
-    {"max-stale", (http_hdr_type)CC_MAX_STALE},
-    {"Other,", (http_hdr_type)CC_OTHER}	/* ',' will protect from matches */
-};
+    {
+        {"public", (http_hdr_type)CC_PUBLIC},
+
+        {"private", (http_hdr_type)CC_PRIVATE},
+        {"no-cache", (http_hdr_type)CC_NO_CACHE},
+        {"no-store", (http_hdr_type)CC_NO_STORE},
+        {"no-transform", (http_hdr_type)CC_NO_TRANSFORM},
+        {"must-revalidate", (http_hdr_type)CC_MUST_REVALIDATE},
+        {"proxy-revalidate", (http_hdr_type)CC_PROXY_REVALIDATE},
+        {"only-if-cached", (http_hdr_type)CC_ONLY_IF_CACHED},
+        {"max-age", (http_hdr_type)CC_MAX_AGE},
+        {"s-maxage", (http_hdr_type)CC_S_MAXAGE},
+        {"max-stale", (http_hdr_type)CC_MAX_STALE},
+        {"Other,", (http_hdr_type)CC_OTHER}	/* ',' will protect from matches */
+    };
+
 HttpHeaderFieldInfo *CcFieldsInfo = NULL;
 
 http_hdr_cc_type &operator++ (http_hdr_cc_type &aHeader)
@@ -96,10 +98,12 @@ HttpHdrCc *
 httpHdrCcParseCreate(const String * str)
 {
     HttpHdrCc *cc = httpHdrCcCreate();
+
     if (!httpHdrCcParseInit(cc, str)) {
-	httpHdrCcDestroy(cc);
-	cc = NULL;
+        httpHdrCcDestroy(cc);
+        cc = NULL;
     }
+
     return cc;
 }
 
@@ -115,52 +119,72 @@ httpHdrCcParseInit(HttpHdrCc * cc, const String * str)
     assert(cc && str);
 
     /* iterate through comma separated list */
+
     while (strListGetItem(str, ',', &item, &ilen, &pos)) {
-	/* strip '=' statements @?@ */
-	if ((p = strchr(item, '=')) && (p - item < ilen))
-	    ilen = p++ - item;
-	/* find type */
-	type = (http_hdr_cc_type ) httpHeaderIdByName(item, ilen,
-	    CcFieldsInfo, CC_ENUM_END);
-	if (type < 0) {
-	    debug(65, 2) ("hdr cc: unknown cache-directive: near '%s' in '%s'\n", item, str->buf());
-	    type = CC_OTHER;
-	}
-	if (EBIT_TEST(cc->mask, type)) {
-	    if (type != CC_OTHER)
-		debug(65, 2) ("hdr cc: ignoring duplicate cache-directive: near '%s' in '%s'\n", item, str->buf());
-	    CcFieldsInfo[type].stat.repCount++;
-	    continue;
-	}
-	/* update mask */
-	EBIT_SET(cc->mask, type);
-	/* post-processing special cases */
-	switch (type) {
-	case CC_MAX_AGE:
-	    if (!p || !httpHeaderParseInt(p, &cc->max_age)) {
-		debug(65, 2) ("cc: invalid max-age specs near '%s'\n", item);
-		cc->max_age = -1;
-		EBIT_CLR(cc->mask, type);
-	    }
-	    break;
-	case CC_S_MAXAGE:
-	    if (!p || !httpHeaderParseInt(p, &cc->s_maxage)) {
-		debug(65, 2) ("cc: invalid s-maxage specs near '%s'\n", item);
-		cc->s_maxage = -1;
-		EBIT_CLR(cc->mask, type);
-	    }
-	    break;
-	case CC_MAX_STALE:
-	    if (!p || !httpHeaderParseInt(p, &cc->max_stale)) {
-		debug(65, 2) ("cc: max-stale directive is valid without value\n");
-		cc->max_stale = -1;
-	    }
-	    break;
-	default:
-	    /* note that we ignore most of '=' specs */
-	    break;
-	}
+        /* strip '=' statements @?@ */
+
+        if ((p = strchr(item, '=')) && (p - item < ilen))
+            ilen = p++ - item;
+
+        /* find type */
+        type = (http_hdr_cc_type ) httpHeaderIdByName(item, ilen,
+                CcFieldsInfo, CC_ENUM_END);
+
+        if (type < 0) {
+            debug(65, 2) ("hdr cc: unknown cache-directive: near '%s' in '%s'\n", item, str->buf());
+            type = CC_OTHER;
+        }
+
+        if (EBIT_TEST(cc->mask, type)) {
+            if (type != CC_OTHER)
+                debug(65, 2) ("hdr cc: ignoring duplicate cache-directive: near '%s' in '%s'\n", item, str->buf());
+
+            CcFieldsInfo[type].stat.repCount++;
+
+            continue;
+        }
+
+        /* update mask */
+        EBIT_SET(cc->mask, type);
+
+        /* post-processing special cases */
+        switch (type) {
+
+        case CC_MAX_AGE:
+
+            if (!p || !httpHeaderParseInt(p, &cc->max_age)) {
+                debug(65, 2) ("cc: invalid max-age specs near '%s'\n", item);
+                cc->max_age = -1;
+                EBIT_CLR(cc->mask, type);
+            }
+
+            break;
+
+        case CC_S_MAXAGE:
+
+            if (!p || !httpHeaderParseInt(p, &cc->s_maxage)) {
+                debug(65, 2) ("cc: invalid s-maxage specs near '%s'\n", item);
+                cc->s_maxage = -1;
+                EBIT_CLR(cc->mask, type);
+            }
+
+            break;
+
+        case CC_MAX_STALE:
+
+            if (!p || !httpHeaderParseInt(p, &cc->max_stale)) {
+                debug(65, 2) ("cc: max-stale directive is valid without value\n");
+                cc->max_stale = -1;
+            }
+
+            break;
+
+        default:
+            /* note that we ignore most of '=' specs */
+            break;
+        }
     }
+
     return cc->mask != 0;
 }
 
@@ -190,37 +214,43 @@ httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p)
     http_hdr_cc_type flag;
     int pcount = 0;
     assert(cc && p);
+
     for (flag = CC_PUBLIC; flag < CC_ENUM_END; ++flag) {
-	if (EBIT_TEST(cc->mask, flag) && flag != CC_OTHER) {
+        if (EBIT_TEST(cc->mask, flag) && flag != CC_OTHER) {
+
+            /* print option name */
+            packerPrintf(p, (pcount ? ", %s" : "%s"), CcFieldsInfo[flag].name.buf());
 
-	    /* print option name */
-	    packerPrintf(p, (pcount ? ", %s" : "%s"), CcFieldsInfo[flag].name.buf());
+            /* handle options with values */
 
-	    /* handle options with values */
-	    if (flag == CC_MAX_AGE)
-		packerPrintf(p, "=%d", (int) cc->max_age);
+            if (flag == CC_MAX_AGE)
+                packerPrintf(p, "=%d", (int) cc->max_age);
 
-	    if (flag == CC_S_MAXAGE)
-		packerPrintf(p, "=%d", (int) cc->s_maxage);
+            if (flag == CC_S_MAXAGE)
+                packerPrintf(p, "=%d", (int) cc->s_maxage);
 
-	    if (flag == CC_MAX_STALE)
-		packerPrintf(p, "=%d", (int) cc->max_stale);
+            if (flag == CC_MAX_STALE)
+                packerPrintf(p, "=%d", (int) cc->max_stale);
 
-	    pcount++;
-	}
+            pcount++;
+        }
     }
 }
 
 void
 httpHdrCcJoinWith(HttpHdrCc * cc, const HttpHdrCc * new_cc)
 {
     assert(cc && new_cc);
+
     if (cc->max_age < 0)
-	cc->max_age = new_cc->max_age;
+        cc->max_age = new_cc->max_age;
+
     if (cc->s_maxage < 0)
-	cc->s_maxage = new_cc->s_maxage;
+        cc->s_maxage = new_cc->s_maxage;
+
     if (cc->max_stale < 0)
-	cc->max_stale = new_cc->max_stale;
+        cc->max_stale = new_cc->max_stale;
+
     cc->mask |= new_cc->mask;
 }
 
@@ -230,10 +260,11 @@ httpHdrCcSetMaxAge(HttpHdrCc * cc, int max_age)
 {
     assert(cc);
     cc->max_age = max_age;
+
     if (max_age >= 0)
-	EBIT_SET(cc->mask, CC_MAX_AGE);
+        EBIT_SET(cc->mask, CC_MAX_AGE);
     else
-	EBIT_CLR(cc->mask, CC_MAX_AGE);
+        EBIT_CLR(cc->mask, CC_MAX_AGE);
 }
 
 /* negative s_maxage will clean old s-maxage setting */
@@ -242,20 +273,22 @@ httpHdrCcSetSMaxAge(HttpHdrCc * cc, int s_maxage)
 {
     assert(cc);
     cc->s_maxage = s_maxage;
+
     if (s_maxage >= 0)
-	EBIT_SET(cc->mask, CC_S_MAXAGE);
+        EBIT_SET(cc->mask, CC_S_MAXAGE);
     else
-	EBIT_CLR(cc->mask, CC_S_MAXAGE);
+        EBIT_CLR(cc->mask, CC_S_MAXAGE);
 }
 
 void
 httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist)
 {
     http_hdr_cc_type c;
     assert(cc);
+
     for (c = CC_PUBLIC; c < CC_ENUM_END; ++c)
-	if (EBIT_TEST(cc->mask, c))
-	    statHistCount(hist, c);
+        if (EBIT_TEST(cc->mask, c))
+            statHistCount(hist, c);
 }
 
 void
@@ -265,7 +298,8 @@ httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int c
     const int id = (int) val;
     const int valid_id = id >= 0 && id < CC_ENUM_END;
     const char *name = valid_id ? CcFieldsInfo[id].name.buf() : "INVALID";
+
     if (count || valid_id)
-	storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
-	    id, name, count, xdiv(count, dump_stat->ccParsedCount));
+        storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
+                          id, name, count, xdiv(count, dump_stat->ccParsedCount));
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrContRange.cc,v 1.16 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHdrContRange.cc,v 1.17 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 68    HTTP Content-Range Header
  * AUTHOR: Alex Rousskov
@@ -66,36 +66,46 @@ httpHdrRangeRespSpecParseInit(HttpHdrRangeSpec * spec, const char *field, int fl
     const char *p;
     assert(spec);
     spec->offset = spec->length = range_spec_unknown;
+
     if (flen < 2)
-	return 0;
+        return 0;
+
     /* is spec given ? */
     if (*field == '*')
-	return 1;
+        return 1;
+
     /* check format, must be %d-%d */
     if (!((p = strchr(field, '-')) && (p - field < flen))) {
-	debug(68, 2) ("invalid (no '-') resp-range-spec near: '%s'\n", field);
-	return 0;
+        debug(68, 2) ("invalid (no '-') resp-range-spec near: '%s'\n", field);
+        return 0;
     }
+
     /* parse offset */
     if (!httpHeaderParseSize(field, &spec->offset))
-	return 0;
+        return 0;
+
     p++;
+
     /* do we have last-pos ? */
     if (p - field < flen) {
-	ssize_t last_pos;
-	if (!httpHeaderParseSize(p, &last_pos))
-	    return 0;
-	spec->length = size_diff(last_pos + 1, spec->offset);
+        ssize_t last_pos;
+
+        if (!httpHeaderParseSize(p, &last_pos))
+            return 0;
+
+        spec->length = size_diff(last_pos + 1, spec->offset);
     }
+
     /* Ensure typecast is safe */
     assert (spec->length >= 0);
-	   
+
     /* we managed to parse, check if the result makes sence */
     if (known_spec((size_t)spec->length) && spec->length == 0) {
-	debug(68, 2) ("invalid range (%ld += %ld) in resp-range-spec near: '%s'\n",
-	    (long int) spec->offset, (long int) spec->length, field);
-	return 0;
+        debug(68, 2) ("invalid range (%ld += %ld) in resp-range-spec near: '%s'\n",
+                      (long int) spec->offset, (long int) spec->length, field);
+        return 0;
     }
+
     return 1;
 }
 
@@ -105,12 +115,12 @@ httpHdrRangeRespSpecPackInto(const HttpHdrRangeSpec * spec, Packer * p)
     /* Ensure typecast is safe */
     assert (spec->length >= 0);
     assert (spec->length >= 0);
-	
+
     if (!known_spec((size_t)spec->offset) || !known_spec((size_t)spec->length))
-	packerPrintf(p, "*");
+        packerPrintf(p, "*");
     else
-	packerPrintf(p, "bytes %ld-%ld",
-	    (long int) spec->offset, (long int) spec->offset + spec->length - 1);
+        packerPrintf(p, "bytes %ld-%ld",
+                     (long int) spec->offset, (long int) spec->offset + spec->length - 1);
 }
 
 /*
@@ -130,10 +140,12 @@ HttpHdrContRange *
 httpHdrContRangeParseCreate(const char *str)
 {
     HttpHdrContRange *r = httpHdrContRangeCreate();
+
     if (!httpHdrContRangeParseInit(r, str)) {
-	httpHdrContRangeDestroy(r);
-	r = NULL;
+        httpHdrContRangeDestroy(r);
+        r = NULL;
     }
+
     return r;
 }
 
@@ -145,24 +157,32 @@ httpHdrContRangeParseInit(HttpHdrContRange * range, const char *str)
     assert(range && str);
     debug(68, 8) ("parsing content-range field: '%s'\n", str);
     /* check range type */
+
     if (strncasecmp(str, "bytes ", 6))
-	return 0;
+        return 0;
+
     str += 6;
+
     /* split */
     if (!(p = strchr(str, '/')))
-	return 0;
+        return 0;
+
     if (*str == '*')
-	range->spec.offset = range->spec.length = range_spec_unknown;
+        range->spec.offset = range->spec.length = range_spec_unknown;
     else if (!httpHdrRangeRespSpecParseInit(&range->spec, str, p - str))
-	return 0;
+        return 0;
+
     p++;
+
     if (*p == '*')
-	range->elength = range_spec_unknown;
+        range->elength = range_spec_unknown;
     else if (!httpHeaderParseSize(p, &range->elength))
-	return 0;
+        return 0;
+
     debug(68, 8) ("parsed content-range field: %ld-%ld / %ld\n",
-	(long int) range->spec.offset, (long int) range->spec.offset + range->spec.length - 1,
-	(long int) range->elength);
+                  (long int) range->spec.offset, (long int) range->spec.offset + range->spec.length - 1,
+                  (long int) range->elength);
+
     return 1;
 }
 
@@ -190,10 +210,11 @@ httpHdrContRangePackInto(const HttpHdrContRange * range, Packer * p)
     httpHdrRangeRespSpecPackInto(&range->spec, p);
     /* Ensure typecast is safe */
     assert (range->elength >= 0);
+
     if (!known_spec((size_t)range->elength))
-	packerPrintf(p, "/*");
+        packerPrintf(p, "/*");
     else
-	packerPrintf(p, "/%ld", (long int) range->elength);
+        packerPrintf(p, "/%ld", (long int) range->elength);
 }
 
 void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrContRange.h,v 1.1 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHdrContRange.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,7 +37,10 @@
 #include "HttpHeaderRange.h"
 
 /* http content-range header field */
-class HttpHdrContRange {
+
+class HttpHdrContRange
+{
+
 public:
     HttpHdrRangeSpec spec;
     ssize_t elength;		/* entity length, not content length */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrExtField.cc,v 1.10 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHdrExtField.cc,v 1.11 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 69    HTTP Header: Extension Field
  * AUTHOR: Alex Rousskov
@@ -43,7 +43,7 @@ static HttpHdrExtField *httpHdrExtFieldDoCreate(const char *name, int name_len,
 
 static HttpHdrExtField *
 httpHdrExtFieldDoCreate(const char *name, int name_len,
-    const char *value, int value_len)
+                        const char *value, int value_len)
 {
     HttpHdrExtField *f = xcalloc(1, sizeof(HttpHdrExtField));
     stringLimitInit(&f->name, name, name_len);
@@ -55,8 +55,8 @@ HttpHdrExtField *
 httpHdrExtFieldCreate(const char *name, const char *value)
 {
     return httpHdrExtFieldDoCreate(
-	name, strlen(name),
-	value, strlen(value));
+               name, strlen(name),
+               value, strlen(value));
 }
 
 /* parses ext field; returns fresh ext field on success and NULL on failure */
@@ -69,16 +69,17 @@ httpHdrExtFieldParseCreate(const char *field_start, const char *field_end)
     /* note: value_end == field_end */
 
     if (!name_end || name_end <= field_start || name_end > field_end)
-	return NULL;
+        return NULL;
 
     value_start = name_end + 1;	/* skip ':' */
+
     /* skip white space */
     while (value_start < field_end && xisspace(*value_start))
-	value_start++;
+        value_start++;
 
     return httpHdrExtFieldDoCreate(
-	field_start, name_end - field_start,
-	value_start, field_end - value_start);
+               field_start, name_end - field_start,
+               value_start, field_end - value_start);
 }
 
 void
@@ -95,6 +96,6 @@ httpHdrExtFieldDup(HttpHdrExtField * f)
 {
     assert(f);
     return httpHdrExtFieldDoCreate(
-	f->name.buf(), f->name.size(),
-	f->value.buf(), f->value.size());
+               f->name.buf(), f->name.size(),
+               f->value.buf(), f->value.size());
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrRange.cc,v 1.30 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHdrRange.cc,v 1.31 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 64    HTTP Range Header
  * AUTHOR: Alex Rousskov
@@ -74,8 +74,10 @@ void *
 HttpHdrRangeSpec::operator new(size_t size)
 {
     assert (size == sizeof (HttpHdrRangeSpec));
+
     if (!Pool)
-	Pool = memPoolCreate ("HttpHdrRangeSpec", sizeof (HttpHdrRangeSpec));
+        Pool = memPoolCreate ("HttpHdrRangeSpec", sizeof (HttpHdrRangeSpec));
+
     return memPoolAlloc(Pool);
 }
 
@@ -90,75 +92,86 @@ HttpHdrRangeSpec::deleteSelf() const
 {
     delete this;
 }
-    
+
 HttpHdrRangeSpec::HttpHdrRangeSpec() : offset(UnknownPosition), length(UnknownPosition){}
 
 /* parses range-spec and returns new object on success */
 HttpHdrRangeSpec *
 HttpHdrRangeSpec::Create(const char *field, int flen)
 {
     HttpHdrRangeSpec spec;
+
     if (!spec.parseInit(field, flen))
-	return NULL;
+        return NULL;
+
     return new HttpHdrRangeSpec(spec);
 }
 
 bool
 HttpHdrRangeSpec::parseInit(const char *field, int flen)
 {
     const char *p;
+
     if (flen < 2)
-	return false;
+        return false;
+
     /* is it a suffix-byte-range-spec ? */
     if (*field == '-') {
-	if (!httpHeaderParseSize(field + 1, &length))
-	    return false;
+        if (!httpHeaderParseSize(field + 1, &length))
+            return false;
     } else
-	/* must have a '-' somewhere in _this_ field */
-    if (!((p = strchr(field, '-')) || (p - field >= flen))) {
-	debug(64, 2) ("ignoring invalid (missing '-') range-spec near: '%s'\n", field);
-	return false;
-    } else {
-	if (!httpHeaderParseSize(field, &offset))
-	    return false;
-	p++;
-	/* do we have last-pos ? */
-	if (p - field < flen) {
-	    ssize_t last_pos;
-	    if (!httpHeaderParseSize(p, &last_pos))
-		return false;
-	    HttpHdrRangeSpec::HttpRange aSpec (offset, last_pos + 1);
-	    length = aSpec.size();
-	}
-    }
+        /* must have a '-' somewhere in _this_ field */
+        if (!((p = strchr(field, '-')) || (p - field >= flen))) {
+            debug(64, 2) ("ignoring invalid (missing '-') range-spec near: '%s'\n", field);
+            return false;
+        } else {
+            if (!httpHeaderParseSize(field, &offset))
+                return false;
+
+            p++;
+
+            /* do we have last-pos ? */
+            if (p - field < flen) {
+                ssize_t last_pos;
+
+                if (!httpHeaderParseSize(p, &last_pos))
+                    return false;
+
+                HttpHdrRangeSpec::HttpRange aSpec (offset, last_pos + 1);
+
+                length = aSpec.size();
+            }
+        }
+
     /* we managed to parse, check if the result makes sence */
     if (length == 0) {
-	debug(64, 2) ("ignoring invalid (zero length) range-spec near: '%s'\n", field);
-	return false;
+        debug(64, 2) ("ignoring invalid (zero length) range-spec near: '%s'\n", field);
+        return false;
     }
+
     return true;
 }
 
 void
 HttpHdrRangeSpec::packInto(Packer * packer) const
 {
     if (!known_spec(offset))	/* suffix */
-	packerPrintf(packer, "-%ld", (long int) length);
+        packerPrintf(packer, "-%ld", (long int) length);
     else if (!known_spec(length))		/* trailer */
-	packerPrintf(packer, "%ld-", (long int) offset);
+        packerPrintf(packer, "%ld-", (long int) offset);
     else			/* range */
-	packerPrintf(packer, "%ld-%ld",
-	    (long int) offset, (long int) offset + length - 1);
+        packerPrintf(packer, "%ld-%ld",
+                     (long int) offset, (long int) offset + length - 1);
 }
 
 void
 HttpHdrRangeSpec::outputInfo( char const *note) const
 {
     debug(64, 5) ("HttpHdrRangeSpec::canonize: %s: [%ld, %ld) len: %ld\n",
-	note, (long int) offset, (long int) offset + length, (long int) length);
+                  note, (long int) offset, (long int) offset + length, (long int) length);
 }
 
-/* fills "absent" positions in range specification based on response body size 
+/* fills "absent" positions in range specification based on response body size
  * returns true if the range is still valid
  * range is valid if its intersection with [0,length-1] is not empty
  */
@@ -167,26 +180,34 @@ HttpHdrRangeSpec::canonize(size_t clen)
 {
     outputInfo ("have");
     HttpRange object(0, clen);
-    if (!known_spec(offset))	/* suffix */ {
-	assert(known_spec(length));
-	offset = object.intersection(HttpRange (clen - length, clen)).start;
-    } else if (!known_spec(length))		/* trailer */ {
-	assert(known_spec(offset));
-	HttpRange newRange = object.intersection(HttpRange (offset, clen));
-	length = newRange.size();
+
+    if (!known_spec(offset))	/* suffix */
+    {
+        assert(known_spec(length));
+        offset = object.intersection(HttpRange (clen - length, clen)).start;
+    } else if (!known_spec(length))		/* trailer */
+    {
+        assert(known_spec(offset));
+        HttpRange newRange = object.intersection(HttpRange (offset, clen));
+        length = newRange.size();
     }
     /* we have a "range" now, adjust length if needed */
     assert(known_spec(length));
+
     assert(known_spec(offset));
+
     HttpRange newRange = object.intersection (HttpRange (offset, offset + length));
+
     length = newRange.size();
+
     outputInfo ("done");
+
     return length > 0;
 }
 
-/* merges recepient with donor if possible; returns true on success 
+/* merges recepient with donor if possible; returns true on success
  * both specs must be canonized prior to merger, of course */
-bool 
+bool
 HttpHdrRangeSpec::mergeWith(const HttpHdrRangeSpec * donor)
 {
     bool merged (false);
@@ -199,24 +220,28 @@ HttpHdrRangeSpec::mergeWith(const HttpHdrRangeSpec * donor)
     assert(length > 0);
     assert(donor->length > 0);
     /* do we have a left hand side overlap? */
+
     if (donor->offset < offset && offset <= donor_rhs) {
-	offset = donor->offset;	/* decrease left offset */
-	merged = 1;
+        offset = donor->offset;	/* decrease left offset */
+        merged = 1;
     }
+
     /* do we have a right hand side overlap? */
     if (donor->offset <= rhs && rhs < donor_rhs) {
-	rhs = donor_rhs;	/* increase right offset */
-	merged = 1;
+        rhs = donor_rhs;	/* increase right offset */
+        merged = 1;
     }
+
     /* adjust length if offsets have been changed */
     if (merged) {
-	assert(rhs > offset);
-	length = rhs - offset;
+        assert(rhs > offset);
+        length = rhs - offset;
     } else {
-	/* does recepient contain donor? */
-	merged =
-	    offset <= donor->offset && donor->offset < rhs;
+        /* does recepient contain donor? */
+        merged =
+            offset <= donor->offset && donor->offset < rhs;
     }
+
 #endif
     return merged;
 }
@@ -231,8 +256,10 @@ void *
 HttpHdrRange::operator new(size_t size)
 {
     assert (size == sizeof (HttpHdrRange));
+
     if (!Pool)
-	Pool = memPoolCreate ("HttpHdrRange", sizeof (HttpHdrRange));
+        Pool = memPoolCreate ("HttpHdrRange", sizeof (HttpHdrRange));
+
     return memPoolAlloc(Pool);
 }
 
@@ -247,19 +274,20 @@ HttpHdrRange::deleteSelf() const
 {
     delete this;
 }
- 
+
 HttpHdrRange::HttpHdrRange () : clen (HttpHdrRangeSpec::UnknownPosition)
-{
-}
+{}
 
 HttpHdrRange *
 HttpHdrRange::ParseCreate(const String * range_spec)
 {
     HttpHdrRange *r = new HttpHdrRange;
+
     if (!r->parseInit(range_spec)) {
-	r->deleteSelf();
-	r = NULL;
+        r->deleteSelf();
+        r = NULL;
     }
+
     return r;
 }
 
@@ -275,36 +303,44 @@ HttpHdrRange::parseInit(const String * range_spec)
     ++ParsedCount;
     debug(64, 8) ("parsing range field: '%s'\n", range_spec->buf());
     /* check range type */
+
     if (range_spec->nCaseCmp("bytes=", 6))
-	return 0;
+        return 0;
+
     /* skip "bytes="; hack! */
     pos = range_spec->buf() + 5;
+
     /* iterate through comma separated list */
     while (strListGetItem(range_spec, ',', &item, &ilen, &pos)) {
-	HttpHdrRangeSpec *spec = HttpHdrRangeSpec::Create(item, ilen);
-	/*
-	 * HTTP/1.1 draft says we must ignore the whole header field if one spec
-	 * is invalid. However, RFC 2068 just says that we must ignore that spec.
-	 */
-	if (spec)
-	    specs.push_back(spec);
-	++count;
+        HttpHdrRangeSpec *spec = HttpHdrRangeSpec::Create(item, ilen);
+        /*
+         * HTTP/1.1 draft says we must ignore the whole header field if one spec
+         * is invalid. However, RFC 2068 just says that we must ignore that spec.
+         */
+
+        if (spec)
+            specs.push_back(spec);
+
+        ++count;
     }
+
     debug(64, 8) ("parsed range range count: %d, kept %d\n", count, specs.size());
     return specs.count != 0;
 }
 
 HttpHdrRange::~HttpHdrRange()
 {
     while (specs.size())
-	specs.pop_back()->deleteSelf();
+        specs.pop_back()->deleteSelf();
 }
 
 HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) : specs()
 {
     specs.reserve(old.specs.size());
+
     for (const_iterator i = old.begin(); i != old.end(); ++i)
-	specs.push_back(new HttpHdrRangeSpec ( **i));
+        specs.push_back(new HttpHdrRangeSpec ( **i));
+
     assert(old.specs.size() == specs.size());
 }
 
@@ -337,11 +373,14 @@ HttpHdrRange::packInto(Packer * packer) const
 {
     const_iterator pos = begin();
     assert(this);
+
     while (pos != end()) {
-	if (pos != begin())
-	    packerAppend(packer, ",", 1);
-	(*pos)->packInto(packer);
-	++pos;
+        if (pos != begin())
+            packerAppend(packer, ",", 1);
+
+        (*pos)->packInto(packer);
+
+        ++pos;
     }
 }
 
@@ -354,32 +393,37 @@ HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
      * take one spec from "goods" and merge it with specs from 
      * "specs" (if any) until there is no overlap */
     iterator i = basis.begin();
+
     while (i != basis.end()) {
-	if (specs.size() && (*i)->mergeWith(specs.back())) {
-	    /* merged with current so get rid of the prev one */
-	    specs.pop_back()->deleteSelf();
-	    continue;	/* re-iterate */
-	}
-	specs.push_back (*i);
-	++i;			/* progress */
+        if (specs.size() && (*i)->mergeWith(specs.back())) {
+            /* merged with current so get rid of the prev one */
+            specs.pop_back()->deleteSelf();
+            continue;	/* re-iterate */
+        }
+
+        specs.push_back (*i);
+        ++i;			/* progress */
     }
+
     debug(64, 3) ("HttpHdrRange::merge: had %d specs, merged %d specs\n",
-	basis.size(), basis.size() - specs.size());
+                  basis.size(), basis.size() - specs.size());
 }
 
 
 void
 HttpHdrRange::getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy)
 {
     /* canonize each entry and destroy bad ones if any */
+
     for (iterator pos (begin()); pos != end(); ++pos) {
-	if ((*pos)->canonize(clen))
-	    copy.push_back (*pos);
-	else
-	    (*pos)->deleteSelf();
+        if ((*pos)->canonize(clen))
+            copy.push_back (*pos);
+        else
+            (*pos)->deleteSelf();
     }
+
     debug(64, 3) ("HttpHdrRange::getCanonizedSpecs: found %d bad specs\n",
-	specs.size() - copy.size());
+                  specs.size() - copy.size());
 }
 
 #include "HttpHdrContRange.h"
@@ -395,10 +439,12 @@ int
 HttpHdrRange::canonize(HttpReply *rep)
 {
     assert(this && rep);
+
     if (rep->content_range)
-	clen = rep->content_range->elength;
+        clen = rep->content_range->elength;
     else
-	clen = rep->content_length;
+        clen = rep->content_length;
+
     return canonize (clen);
 }
 
@@ -411,7 +457,7 @@ HttpHdrRange::canonize (size_t newClen)
     getCanonizedSpecs(goods);
     merge (goods);
     debug(64, 3) ("HttpHdrRange::canonize: finished with %d specs\n",
-	specs.count);
+                  specs.count);
     return specs.count > 0;
 }
 
@@ -424,14 +470,19 @@ HttpHdrRange::isComplex() const
     assert(this);
     /* check that all rangers are in "strong" order */
     const_iterator pos (begin());
+
     while (pos != end()) {
-	/* Ensure typecasts is safe */
-	assert ((*pos)->offset >= 0);
-	if ((unsigned int)(*pos)->offset < offset)
-	    return 1;
-	offset = (*pos)->offset + (*pos)->length;
-	++pos;
+        /* Ensure typecasts is safe */
+        assert ((*pos)->offset >= 0);
+
+        if ((unsigned int)(*pos)->offset < offset)
+            return 1;
+
+        offset = (*pos)->offset + (*pos)->length;
+
+        ++pos;
     }
+
     return 0;
 }
 
@@ -446,17 +497,23 @@ HttpHdrRange::willBeComplex() const
     /* check that all rangers are in "strong" order, */
     /* as far as we can tell without the content length */
     size_t offset = 0;
+
     for (const_iterator pos (begin()); pos != end(); ++pos) {
-	if (!known_spec((*pos)->offset))	/* ignore unknowns */
-	    continue;
-	/* Ensure typecasts is safe */
-	assert ((*pos)->offset >= 0);
-	if ((size_t) (*pos)->offset < offset)
-	    return true;
-	offset = (*pos)->offset;
-	if (known_spec((*pos)->length))	/* avoid  unknowns */
-	    offset += (*pos)->length;
+        if (!known_spec((*pos)->offset))	/* ignore unknowns */
+            continue;
+
+        /* Ensure typecasts is safe */
+        assert ((*pos)->offset >= 0);
+
+        if ((size_t) (*pos)->offset < offset)
+            return true;
+
+        offset = (*pos)->offset;
+
+        if (known_spec((*pos)->length))	/* avoid  unknowns */
+            offset += (*pos)->length;
     }
+
     return false;
 }
 
@@ -471,11 +528,14 @@ HttpHdrRange::firstOffset() const
     ssize_t offset = HttpHdrRangeSpec::UnknownPosition;
     assert(this);
     const_iterator pos = begin();
+
     while (pos != end()) {
-	if ((*pos)->offset < offset || !known_spec(offset))
-	    offset = (*pos)->offset;
-	++pos;
+        if ((*pos)->offset < offset || !known_spec(offset))
+            offset = (*pos)->offset;
+
+        ++pos;
     }
+
     return offset;
 }
 
@@ -491,67 +551,78 @@ HttpHdrRange::lowestOffset(ssize_t size) const
     ssize_t offset = HttpHdrRangeSpec::UnknownPosition;
     const_iterator pos = begin();
     assert(this);
+
     while (pos != end()) {
-	ssize_t current = (*pos)->offset;
-	if (!known_spec(current)) {
-	    if ((*pos)->length > size || !known_spec((*pos)->length))
-		return 0;	/* Unknown. Assume start of file */
-	    current = size - (*pos)->length;
-	}
-	if (current < offset || !known_spec(offset))
-	    offset = current;
-	++pos;
+        ssize_t current = (*pos)->offset;
+
+        if (!known_spec(current)) {
+            if ((*pos)->length > size || !known_spec((*pos)->length))
+                return 0;	/* Unknown. Assume start of file */
+
+            current = size - (*pos)->length;
+        }
+
+        if (current < offset || !known_spec(offset))
+            offset = current;
+
+        ++pos;
     }
+
     return known_spec(offset) ? offset : 0;
 }
 
-/*  
+/*
  * Return true if the first range offset is larger than the configured
  * limit.
  */
 bool
 HttpHdrRange::offsetLimitExceeded() const
 {
     if (NULL == this)
-	/* not a range request */
-	return false;
+        /* not a range request */
+        return false;
+
     if (-1 == (ssize_t)Config.rangeOffsetLimit)
-	/* disabled */
-	return false;
+        /* disabled */
+        return false;
+
     if ((ssize_t)Config.rangeOffsetLimit >= firstOffset())
-	/* below the limit */
-	return false;
+        /* below the limit */
+        return false;
+
     return true;
 }
 
 const HttpHdrRangeSpec *
 HttpHdrRangeIter::currentSpec() const
 {
     if (pos.incrementable())
-	return *pos;
+        return *pos;
+
     return NULL;
 }
 
 void
 HttpHdrRangeIter::updateSpec()
 {
     assert (debt_size == 0);
+
     if (pos.incrementable()) {
-	debt(currentSpec()->length);
+        debt(currentSpec()->length);
     }
 }
 
 ssize_t
 HttpHdrRangeIter::debt() const
 {
     debug(64, 3) ("HttpHdrRangeIter::debt: debt is %d\n",
-	(int)debt_size);
+                  (int)debt_size);
     return debt_size;
 }
 
 void HttpHdrRangeIter::debt(ssize_t newDebt)
 {
     debug(64, 3) ("HttpHdrRangeIter::debt: was %d now %d\n",
-	(int)debt_size, (int)newDebt);
+                  (int)debt_size, (int)newDebt);
     debt_size = newDebt;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.84 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHeader.cc,v 1.85 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -68,73 +68,75 @@
  * After reorganization, field id can be used as an index to the table.
  */
 static const HttpHeaderFieldAttrs HeadersAttrs[] =
-{
-    {"Accept", HDR_ACCEPT, ftStr},
-    {"Accept-Charset", HDR_ACCEPT_CHARSET, ftStr},
-    {"Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr},
-    {"Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr},
-    {"Accept-Ranges", HDR_ACCEPT_RANGES, ftStr},
-    {"Age", HDR_AGE, ftInt},
-    {"Allow", HDR_ALLOW, ftStr},
-    {"Authorization", HDR_AUTHORIZATION, ftStr},	/* for now */
-    {"Cache-Control", HDR_CACHE_CONTROL, ftPCc},
-    {"Connection", HDR_CONNECTION, ftStr},
-    {"Content-Base", HDR_CONTENT_BASE, ftStr},
-    {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
-    {"Content-Language", HDR_CONTENT_LANGUAGE, ftStr},
-    {"Content-Length", HDR_CONTENT_LENGTH, ftInt},
-    {"Content-Location", HDR_CONTENT_LOCATION, ftStr},
-    {"Content-MD5", HDR_CONTENT_MD5, ftStr},	/* for now */
-    {"Content-Range", HDR_CONTENT_RANGE, ftPContRange},
-    {"Content-Type", HDR_CONTENT_TYPE, ftStr},
-    {"Cookie", HDR_COOKIE, ftStr},
-    {"Date", HDR_DATE, ftDate_1123},
-    {"ETag", HDR_ETAG, ftETag},
-    {"Expires", HDR_EXPIRES, ftDate_1123},
-    {"From", HDR_FROM, ftStr},
-    {"Host", HDR_HOST, ftStr},
-    {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
-    {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
-    {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
-    {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
-    {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
-    {"Link", HDR_LINK, ftStr},
-    {"Location", HDR_LOCATION, ftStr},
-    {"Max-Forwards", HDR_MAX_FORWARDS, ftInt},
-    {"Mime-Version", HDR_MIME_VERSION, ftStr},	/* for now */
-    {"Pragma", HDR_PRAGMA, ftStr},
-    {"Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftStr},
-    {"Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, ftStr},
-    {"Proxy-Authorization", HDR_PROXY_AUTHORIZATION, ftStr},
-    {"Proxy-Connection", HDR_PROXY_CONNECTION, ftStr},
-    {"Public", HDR_PUBLIC, ftStr},
-    {"Range", HDR_RANGE, ftPRange},
-    {"Referer", HDR_REFERER, ftStr},
-    {"Request-Range", HDR_REQUEST_RANGE, ftPRange},	/* usually matches HDR_RANGE */
-    {"Retry-After", HDR_RETRY_AFTER, ftStr},	/* for now (ftDate_1123 or ftInt!) */
-    {"Server", HDR_SERVER, ftStr},
-    {"Set-Cookie", HDR_SET_COOKIE, ftStr},
-    {"Title", HDR_TITLE, ftStr},
-    {"Transfer-Encoding", HDR_TRANSFER_ENCODING, ftStr},
-    {"Upgrade", HDR_UPGRADE, ftStr},	/* for now */
-    {"User-Agent", HDR_USER_AGENT, ftStr},
-    {"Vary", HDR_VARY, ftStr},	/* for now */
-    {"Via", HDR_VIA, ftStr},	/* for now */
-    {"Warning", HDR_WARNING, ftStr},	/* for now */
-    {"WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftStr},
-    {"Authentication-Info", HDR_AUTHENTICATION_INFO, ftStr},
-    {"X-Cache", HDR_X_CACHE, ftStr},
-    {"X-Cache-Lookup", HDR_X_CACHE_LOOKUP, ftStr},
-    {"X-Forwarded-For", HDR_X_FORWARDED_FOR, ftStr},
-    {"X-Request-URI", HDR_X_REQUEST_URI, ftStr},
-    {"X-Squid-Error", HDR_X_SQUID_ERROR, ftStr},
-    {"Negotiate", HDR_NEGOTIATE, ftStr},
+    {
+        {"Accept", HDR_ACCEPT, ftStr},
+
+        {"Accept-Charset", HDR_ACCEPT_CHARSET, ftStr},
+        {"Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr},
+        {"Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr},
+        {"Accept-Ranges", HDR_ACCEPT_RANGES, ftStr},
+        {"Age", HDR_AGE, ftInt},
+        {"Allow", HDR_ALLOW, ftStr},
+        {"Authorization", HDR_AUTHORIZATION, ftStr},	/* for now */
+        {"Cache-Control", HDR_CACHE_CONTROL, ftPCc},
+        {"Connection", HDR_CONNECTION, ftStr},
+        {"Content-Base", HDR_CONTENT_BASE, ftStr},
+        {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
+        {"Content-Language", HDR_CONTENT_LANGUAGE, ftStr},
+        {"Content-Length", HDR_CONTENT_LENGTH, ftInt},
+        {"Content-Location", HDR_CONTENT_LOCATION, ftStr},
+        {"Content-MD5", HDR_CONTENT_MD5, ftStr},	/* for now */
+        {"Content-Range", HDR_CONTENT_RANGE, ftPContRange},
+        {"Content-Type", HDR_CONTENT_TYPE, ftStr},
+        {"Cookie", HDR_COOKIE, ftStr},
+        {"Date", HDR_DATE, ftDate_1123},
+        {"ETag", HDR_ETAG, ftETag},
+        {"Expires", HDR_EXPIRES, ftDate_1123},
+        {"From", HDR_FROM, ftStr},
+        {"Host", HDR_HOST, ftStr},
+        {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
+        {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
+        {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
+        {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
+        {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
+        {"Link", HDR_LINK, ftStr},
+        {"Location", HDR_LOCATION, ftStr},
+        {"Max-Forwards", HDR_MAX_FORWARDS, ftInt},
+        {"Mime-Version", HDR_MIME_VERSION, ftStr},	/* for now */
+        {"Pragma", HDR_PRAGMA, ftStr},
+        {"Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftStr},
+        {"Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, ftStr},
+        {"Proxy-Authorization", HDR_PROXY_AUTHORIZATION, ftStr},
+        {"Proxy-Connection", HDR_PROXY_CONNECTION, ftStr},
+        {"Public", HDR_PUBLIC, ftStr},
+        {"Range", HDR_RANGE, ftPRange},
+        {"Referer", HDR_REFERER, ftStr},
+        {"Request-Range", HDR_REQUEST_RANGE, ftPRange},	/* usually matches HDR_RANGE */
+        {"Retry-After", HDR_RETRY_AFTER, ftStr},	/* for now (ftDate_1123 or ftInt!) */
+        {"Server", HDR_SERVER, ftStr},
+        {"Set-Cookie", HDR_SET_COOKIE, ftStr},
+        {"Title", HDR_TITLE, ftStr},
+        {"Transfer-Encoding", HDR_TRANSFER_ENCODING, ftStr},
+        {"Upgrade", HDR_UPGRADE, ftStr},	/* for now */
+        {"User-Agent", HDR_USER_AGENT, ftStr},
+        {"Vary", HDR_VARY, ftStr},	/* for now */
+        {"Via", HDR_VIA, ftStr},	/* for now */
+        {"Warning", HDR_WARNING, ftStr},	/* for now */
+        {"WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftStr},
+        {"Authentication-Info", HDR_AUTHENTICATION_INFO, ftStr},
+        {"X-Cache", HDR_X_CACHE, ftStr},
+        {"X-Cache-Lookup", HDR_X_CACHE_LOOKUP, ftStr},
+        {"X-Forwarded-For", HDR_X_FORWARDED_FOR, ftStr},
+        {"X-Request-URI", HDR_X_REQUEST_URI, ftStr},
+        {"X-Squid-Error", HDR_X_SQUID_ERROR, ftStr},
+        {"Negotiate", HDR_NEGOTIATE, ftStr},
 #if X_ACCELERATOR_VARY
-    {"X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, ftStr},
+        {"X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, ftStr},
 #endif
-    {"Front-End-Https", HDR_FRONT_END_HTTPS, ftStr},
-    {"Other:", HDR_OTHER, ftStr}	/* ':' will not allow matches */
-};
+        {"Front-End-Https", HDR_FRONT_END_HTTPS, ftStr},
+        {"Other:", HDR_OTHER, ftStr}	/* ':' will not allow matches */
+    };
+
 static HttpHeaderFieldInfo *Headers = NULL;
 
 http_hdr_type &operator++ (http_hdr_type &aHeader)
@@ -150,88 +152,88 @@ http_hdr_type &operator++ (http_hdr_type &aHeader)
  */
 static HttpHeaderMask ListHeadersMask;	/* set run-time using  ListHeadersArr */
 static http_hdr_type ListHeadersArr[] =
-{
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES, HDR_ALLOW,
-    HDR_CACHE_CONTROL,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONNECTION,
-    HDR_IF_MATCH, HDR_IF_NONE_MATCH,
-    HDR_LINK, HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_VARY,
-    HDR_VIA,
-    /* HDR_WARNING, */
-    HDR_WWW_AUTHENTICATE,
-    HDR_AUTHENTICATION_INFO,
-    HDR_PROXY_AUTHENTICATION_INFO,
-    /* HDR_EXPECT, HDR_TE, HDR_TRAILER */
+    {
+        HDR_ACCEPT,
+        HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
+        HDR_ACCEPT_RANGES, HDR_ALLOW,
+        HDR_CACHE_CONTROL,
+        HDR_CONTENT_ENCODING,
+        HDR_CONTENT_LANGUAGE,
+        HDR_CONNECTION,
+        HDR_IF_MATCH, HDR_IF_NONE_MATCH,
+        HDR_LINK, HDR_PRAGMA,
+        HDR_PROXY_CONNECTION,
+        HDR_TRANSFER_ENCODING,
+        HDR_UPGRADE,
+        HDR_VARY,
+        HDR_VIA,
+        /* HDR_WARNING, */
+        HDR_WWW_AUTHENTICATE,
+        HDR_AUTHENTICATION_INFO,
+        HDR_PROXY_AUTHENTICATION_INFO,
+        /* HDR_EXPECT, HDR_TE, HDR_TRAILER */
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+        HDR_X_ACCELERATOR_VARY,
 #endif
-    HDR_X_FORWARDED_FOR
-};
+        HDR_X_FORWARDED_FOR
+    };
 
 /* general-headers */
 static http_hdr_type GeneralHeadersArr[] =
-{
-    HDR_CACHE_CONTROL, HDR_CONNECTION, HDR_DATE, HDR_PRAGMA,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    /* HDR_TRAILER, */
-    HDR_VIA
-};
+    {
+        HDR_CACHE_CONTROL, HDR_CONNECTION, HDR_DATE, HDR_PRAGMA,
+        HDR_TRANSFER_ENCODING,
+        HDR_UPGRADE,
+        /* HDR_TRAILER, */
+        HDR_VIA
+    };
 
 /* entity-headers */
 static http_hdr_type EntityHeadersArr[] =
-{
-    HDR_ALLOW, HDR_CONTENT_BASE, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE,
-    HDR_CONTENT_LENGTH, HDR_CONTENT_LOCATION, HDR_CONTENT_MD5,
-    HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_ETAG, HDR_EXPIRES, HDR_LAST_MODIFIED, HDR_LINK,
-    HDR_OTHER
-};
+    {
+        HDR_ALLOW, HDR_CONTENT_BASE, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE,
+        HDR_CONTENT_LENGTH, HDR_CONTENT_LOCATION, HDR_CONTENT_MD5,
+        HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_ETAG, HDR_EXPIRES, HDR_LAST_MODIFIED, HDR_LINK,
+        HDR_OTHER
+    };
 
 static HttpHeaderMask ReplyHeadersMask;		/* set run-time using ReplyHeaders */
 static http_hdr_type ReplyHeadersArr[] =
-{
-    HDR_ACCEPT, HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES, HDR_AGE,
-    HDR_LOCATION, HDR_MAX_FORWARDS,
-    HDR_MIME_VERSION, HDR_PUBLIC, HDR_RETRY_AFTER, HDR_SERVER, HDR_SET_COOKIE,
-    HDR_VARY,
-    HDR_WARNING, HDR_PROXY_CONNECTION, HDR_X_CACHE,
-    HDR_X_CACHE_LOOKUP,
-    HDR_X_REQUEST_URI,
+    {
+        HDR_ACCEPT, HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
+        HDR_ACCEPT_RANGES, HDR_AGE,
+        HDR_LOCATION, HDR_MAX_FORWARDS,
+        HDR_MIME_VERSION, HDR_PUBLIC, HDR_RETRY_AFTER, HDR_SERVER, HDR_SET_COOKIE,
+        HDR_VARY,
+        HDR_WARNING, HDR_PROXY_CONNECTION, HDR_X_CACHE,
+        HDR_X_CACHE_LOOKUP,
+        HDR_X_REQUEST_URI,
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+        HDR_X_ACCELERATOR_VARY,
 #endif
-    HDR_X_SQUID_ERROR
-};
+        HDR_X_SQUID_ERROR
+    };
 
 static HttpHeaderMask RequestHeadersMask;	/* set run-time using RequestHeaders */
 static http_hdr_type RequestHeadersArr[] =
-{
-    HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
-    HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
-    HDR_IF_RANGE, HDR_MAX_FORWARDS, HDR_PROXY_CONNECTION,
-    HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
-    HDR_USER_AGENT, HDR_X_FORWARDED_FOR
-};
+    {
+        HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
+        HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
+        HDR_IF_RANGE, HDR_MAX_FORWARDS, HDR_PROXY_CONNECTION,
+        HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
+        HDR_USER_AGENT, HDR_X_FORWARDED_FOR
+    };
 
 /* header accounting */
 static HttpHeaderStat HttpHeaderStats[] =
-{
-    {"all"},
+    {
+        {"all"},
 #if USE_HTCP
-    {"HTCP reply"},
+        {"HTCP reply"},
 #endif
-    {"request"},
-    {"reply"}
-};
+        {"request"},
+        {"reply"}
+    };
 static int HttpHeaderStatCount = countof(HttpHeaderStats);
 
 static int HeaderEntryParsedCount = 0;
@@ -262,33 +264,52 @@ httpHeaderInitModule(void)
     assert(8 * sizeof(HttpHeaderMask) >= HDR_ENUM_END);
     /* all headers must be described */
     assert(countof(HeadersAttrs) == HDR_ENUM_END);
+
     if (!Headers)
-	Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+
     /* create masks */
     httpHeaderMaskInit(&ListHeadersMask, 0);
+
     httpHeaderCalcMask(&ListHeadersMask, (const int *) ListHeadersArr, countof(ListHeadersArr));
+
     httpHeaderMaskInit(&ReplyHeadersMask, 0);
+
     httpHeaderCalcMask(&ReplyHeadersMask, (const int *) ReplyHeadersArr, countof(ReplyHeadersArr));
+
     httpHeaderCalcMask(&ReplyHeadersMask, (const int *) GeneralHeadersArr, countof(GeneralHeadersArr));
+
     httpHeaderCalcMask(&ReplyHeadersMask, (const int *) EntityHeadersArr, countof(EntityHeadersArr));
+
     httpHeaderMaskInit(&RequestHeadersMask, 0);
+
     httpHeaderCalcMask(&RequestHeadersMask, (const int *) RequestHeadersArr, countof(RequestHeadersArr));
+
     httpHeaderCalcMask(&RequestHeadersMask, (const int *) GeneralHeadersArr, countof(GeneralHeadersArr));
+
     httpHeaderCalcMask(&RequestHeadersMask, (const int *) EntityHeadersArr, countof(EntityHeadersArr));
+
     /* init header stats */
     assert(HttpHeaderStatCount == hoReply + 1);
+
     for (i = 0; i < HttpHeaderStatCount; i++)
-	httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
+        httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
+
     HttpHeaderStats[hoRequest].owner_mask = &RequestHeadersMask;
+
     HttpHeaderStats[hoReply].owner_mask = &ReplyHeadersMask;
+
 #if USE_HTCP
+
     HttpHeaderStats[hoHtcpReply].owner_mask = &ReplyHeadersMask;
+
 #endif
     /* init dependent modules */
     httpHdrCcInitModule();
+
     /* register with cache manager */
     cachemgrRegister("http_headers",
-	"HTTP Header Statistics", httpHeaderStoreReport, 0, 1);
+                     "HTTP Header Statistics", httpHeaderStoreReport, 0, 1);
 }
 
 void
@@ -339,17 +360,20 @@ httpHeaderClean(HttpHeader * hdr)
     statHistCount(&HttpHeaderStats[hdr->owner].hdrUCountDistr, hdr->entries.count);
     HttpHeaderStats[hdr->owner].destroyedCount++;
     HttpHeaderStats[hdr->owner].busyDestroyedCount += hdr->entries.count > 0;
+
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	/* tmp hack to try to avoid coredumps */
-	if (e->id < 0 || e->id >= HDR_ENUM_END) {
-	    debug(55, 0) ("httpHeaderClean BUG: entry[%d] is invalid (%d). Ignored.\n",
-		(int) pos, e->id);
-	} else {
-	    statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
-	    /* yes, this destroy() leaves us in an incosistent state */
-	    httpHeaderEntryDestroy(e);
-	}
+        /* tmp hack to try to avoid coredumps */
+
+        if (e->id < 0 || e->id >= HDR_ENUM_END) {
+            debug(55, 0) ("httpHeaderClean BUG: entry[%d] is invalid (%d). Ignored.\n",
+                          (int) pos, e->id);
+        } else {
+            statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
+            /* yes, this destroy() leaves us in an incosistent state */
+            httpHeaderEntryDestroy(e);
+        }
     }
+
     arrayClean(&hdr->entries);
 }
 
@@ -364,7 +388,7 @@ httpHeaderAppend(HttpHeader * dest, const HttpHeader * src)
     debug(55, 7) ("appending hdr: %p += %p\n", dest, src);
 
     while ((e = httpHeaderGetEntry(src, &pos))) {
-	httpHeaderAddEntry(dest, httpHeaderEntryClone(e));
+        httpHeaderAddEntry(dest, httpHeaderEntryClone(e));
     }
 }
 
@@ -379,11 +403,14 @@ httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMas
     debug(55, 7) ("updating hdr: %p <- %p\n", old, fresh);
 
     while ((e = httpHeaderGetEntry(fresh, &pos))) {
-	/* deny bad guys (ok to check for HDR_OTHER) here */
-	if (denied_mask && CBIT_TEST(*denied_mask, e->id))
-	    continue;
-	httpHeaderDelByName(old, e->name.buf());
-	httpHeaderAddEntry(old, httpHeaderEntryClone(e));
+        /* deny bad guys (ok to check for HDR_OTHER) here */
+
+        if (denied_mask && CBIT_TEST(*denied_mask, e->id))
+            continue;
+
+        httpHeaderDelByName(old, e->name.buf());
+
+        httpHeaderAddEntry(old, httpHeaderEntryClone(e));
     }
 }
 
@@ -410,33 +437,43 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
     debug(55, 7) ("parsing hdr: (%p)\n%s\n", hdr, getStringPrefix(header_start, header_end));
     HttpHeaderStats[hdr->owner].parsedCount++;
     /* commonn format headers are "<name>:[ws]<value>" lines delimited by <CRLF> */
+
     while (field_start < header_end) {
-	const char *field_end;
-	const char *field_ptr = field_start;
-	do {
-	    field_end = field_ptr = field_ptr + strcspn(field_ptr, "\r\n");
-	    /* skip CRLF */
-	    if (*field_ptr == '\r')
-		field_ptr++;
-	    if (*field_ptr == '\n')
-		field_ptr++;
-	}
-	while (*field_ptr == ' ' || *field_ptr == '\t');
-	if (!*field_end || field_end > header_end)
-	    return httpHeaderReset(hdr);	/* missing <CRLF> */
-	e = httpHeaderEntryParseCreate(field_start, field_end);
-	if (e != NULL)
-	    httpHeaderAddEntry(hdr, e);
-	else
-	    debug(55, 2) ("warning: ignoring unparseable http header field near '%s'\n",
-		getStringPrefix(field_start, field_end));
-	field_start = field_end;
-	/* skip CRLF */
-	if (*field_start == '\r')
-	    field_start++;
-	if (*field_start == '\n')
-	    field_start++;
+        const char *field_end;
+        const char *field_ptr = field_start;
+
+        do {
+            field_end = field_ptr = field_ptr + strcspn(field_ptr, "\r\n");
+            /* skip CRLF */
+
+            if (*field_ptr == '\r')
+                field_ptr++;
+
+            if (*field_ptr == '\n')
+                field_ptr++;
+        } while (*field_ptr == ' ' || *field_ptr == '\t');
+
+        if (!*field_end || field_end > header_end)
+            return httpHeaderReset(hdr);	/* missing <CRLF> */
+
+        e = httpHeaderEntryParseCreate(field_start, field_end);
+
+        if (e != NULL)
+            httpHeaderAddEntry(hdr, e);
+        else
+            debug(55, 2) ("warning: ignoring unparseable http header field near '%s'\n",
+                          getStringPrefix(field_start, field_end));
+
+        field_start = field_end;
+
+        /* skip CRLF */
+        if (*field_start == '\r')
+            field_start++;
+
+        if (*field_start == '\n')
+            field_start++;
     }
+
     return 1;			/* even if no fields where found, it is a valid header */
 }
 
@@ -449,8 +486,9 @@ httpHeaderPackInto(const HttpHeader * hdr, Packer * p)
     assert(hdr && p);
     debug(55, 7) ("packing hdr: (%p)\n", hdr);
     /* pack all entries one by one */
+
     while ((e = httpHeaderGetEntry(hdr, &pos)))
-	httpHeaderEntryPackInto(e, p);
+        httpHeaderEntryPackInto(e, p);
 }
 
 /* returns next valid entry */
@@ -459,10 +497,12 @@ httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
 {
     assert(hdr && pos);
     assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)hdr->entries.count);
+
     for ((*pos)++; *pos < (ssize_t)hdr->entries.count; (*pos)++) {
-	if (hdr->entries.items[*pos])
-	    return (HttpHeaderEntry*)hdr->entries.items[*pos];
+        if (hdr->entries.items[*pos])
+            return (HttpHeaderEntry*)hdr->entries.items[*pos];
     }
+
     return NULL;
 }
 
@@ -481,15 +521,19 @@ httpHeaderFindEntry(const HttpHeader * hdr, http_hdr_type id)
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
+
     if (!CBIT_TEST(hdr->mask, id))
-	return NULL;
+        return NULL;
+
     /* looks like we must have it, do linear search */
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id)
-	    return e;
+        if (e->id == id)
+            return e;
     }
+
     /* hm.. we thought it was there, but it was not found */
     assert(0);
+
     return NULL;		/* not reached */
 }
 
@@ -507,13 +551,16 @@ httpHeaderFindLastEntry(const HttpHeader * hdr, http_hdr_type id)
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
+
     if (!CBIT_TEST(hdr->mask, id))
-	return NULL;
+        return NULL;
+
     /* looks like we must have it, do linear search */
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id)
-	    result = e;
+        if (e->id == id)
+            result = e;
     }
+
     assert(result);		/* must be there! */
     return result;
 }
@@ -529,13 +576,15 @@ httpHeaderDelByName(HttpHeader * hdr, const char *name)
     HttpHeaderEntry *e;
     httpHeaderMaskInit(&hdr->mask, 0);	/* temporal inconsistency */
     debug(55, 7) ("deleting '%s' fields in hdr %p\n", name, hdr);
+
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (!strCaseCmp(e->name, name)) {
-	    httpHeaderDelAt(hdr, pos);
-	    count++;
-	} else
-	    CBIT_SET(hdr->mask, e->id);
+        if (!strCaseCmp(e->name, name)) {
+            httpHeaderDelAt(hdr, pos);
+            count++;
+        } else
+            CBIT_SET(hdr->mask, e->id);
     }
+
     return count;
 }
 
@@ -550,14 +599,17 @@ httpHeaderDelById(HttpHeader * hdr, http_hdr_type id)
     assert(hdr);
     assert_eid(id);
     assert_eid(id != HDR_OTHER);	/* does not make sense */
+
     if (!CBIT_TEST(hdr->mask, id))
-	return 0;
+        return 0;
+
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id) {
-	    httpHeaderDelAt(hdr, pos);
-	    count++;
-	}
+        if (e->id == id) {
+            httpHeaderDelAt(hdr, pos);
+            count++;
+        }
     }
+
     CBIT_CLR(hdr->mask, id);
     assert(count);
     return count;
@@ -581,7 +633,7 @@ httpHeaderDelAt(HttpHeader * hdr, HttpHeaderPos pos)
 }
 
 
-/* appends an entry; 
+/* appends an entry;
  * does not call httpHeaderEntryClone() so one should not reuse "*e"
  */
 void
@@ -591,12 +643,15 @@ httpHeaderAddEntry(HttpHeader * hdr, HttpHeaderEntry * e)
     assert_eid(e->id);
 
     debug(55, 7) ("%p adding entry: %d at %d\n",
-	hdr, e->id, hdr->entries.count);
+                  hdr, e->id, hdr->entries.count);
+
     if (CBIT_TEST(hdr->mask, e->id))
-	Headers[e->id].stat.repCount++;
+        Headers[e->id].stat.repCount++;
     else
-	CBIT_SET(hdr->mask, e->id);
+        CBIT_SET(hdr->mask, e->id);
+
     arrayAppend(&hdr->entries, e);
+
     /* increment header length, allow for ": " and crlf */
     hdr->len += e->name.size() + 2 + e->value.size() + 2;
 }
@@ -611,21 +666,27 @@ httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
     debug(55, 6) ("%p: joining for id %d\n", hdr, id);
     /* only fields from ListHeaders array can be "listed" */
     assert(CBIT_TEST(ListHeadersMask, id));
+
     if (!CBIT_TEST(hdr->mask, id))
-	return s;
+        return s;
+
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == id)
-	    strListAdd(&s, e->value.buf(), ',');
+        if (e->id == id)
+            strListAdd(&s, e->value.buf(), ',');
     }
+
     /*
      * note: we might get an empty (len==0) string if there was an "empty"
      * header; we must not get a NULL string though.
      */
     assert(s.buf());
+
     /* temporary warning: remove it! @?@ @?@ @?@ */
     if (!s.size())
-	debug(55, 3) ("empty list header: %s (%d)\n", Headers[id].name.buf(), id);
+        debug(55, 3) ("empty list header: %s (%d)\n", Headers[id].name.buf(), id);
+
     debug(55, 6) ("%p: joined for id %d: %s\n", hdr, id, s.buf());
+
     return s;
 }
 
@@ -636,9 +697,11 @@ httpHeaderGetStrOrList(const HttpHeader * hdr, http_hdr_type id)
     HttpHeaderEntry *e;
 
     if (CBIT_TEST(ListHeadersMask, id))
-	return httpHeaderGetList(hdr, id);
+        return httpHeaderGetList(hdr, id);
+
     if ((e = httpHeaderFindEntry(hdr, id)))
-	return e->value;
+        return e->value;
+
     return String::Null;
 }
 
@@ -658,15 +721,17 @@ httpHeaderGetByName(const HttpHeader * hdr, const char *name)
 
     /* First try the quick path */
     id = httpHeaderIdByNameDef(name, strlen(name));
+
     if (id != -1)
-	return httpHeaderGetStrOrList(hdr, id);
+        return httpHeaderGetStrOrList(hdr, id);
 
     /* Sorry, an unknown header name. Do linear search */
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	if (e->id == HDR_OTHER && strCaseCmp(e->name, name) == 0) {
-	    strListAdd(&result, e->value.buf(), ',');
-	}
+        if (e->id == HDR_OTHER && strCaseCmp(e->name, name) == 0) {
+            strListAdd(&result, e->value.buf(), ',');
+        }
     }
+
     return result;
 }
 
@@ -689,11 +754,12 @@ httpHeaderGetByNameListMember(const HttpHeader * hdr, const char *name, const ch
     header = httpHeaderGetByName(hdr, name);
 
     while (strListGetItem(&header, separator, &item, &ilen, &pos)) {
-	if (strncmp(item, member, mlen) == 0 && item[mlen] == '=') {
-	    result.append(item + mlen + 1, ilen - mlen - 1);
-	    break;
-	}
+        if (strncmp(item, member, mlen) == 0 && item[mlen] == '=') {
+            result.append(item + mlen + 1, ilen - mlen - 1);
+            break;
+        }
     }
+
     return result;
 }
 
@@ -716,11 +782,12 @@ httpHeaderGetListMember(const HttpHeader * hdr, http_hdr_type id, const char *me
     header = httpHeaderGetStrOrList(hdr, id);
 
     while (strListGetItem(&header, separator, &item, &ilen, &pos)) {
-	if (strncmp(item, member, mlen) == 0 && item[mlen] == '=') {
-	    result.append(item + mlen + 1, ilen - mlen - 1);
-	    break;
-	}
+        if (strncmp(item, member, mlen) == 0 && item[mlen] == '=') {
+            result.append(item + mlen + 1, ilen - mlen - 1);
+            break;
+        }
     }
+
     header.clean();
     return result;
 }
@@ -858,8 +925,10 @@ httpHeaderGetInt(const HttpHeader * hdr, http_hdr_type id)
     assert_eid(id);
     assert(Headers[id].type == ftInt);	/* must be of an appropriate type */
     HttpHeaderEntry *e;
+
     if ((e = httpHeaderFindEntry(hdr, id)))
-	return httpHeaderEntryGetInt (e);
+        return httpHeaderEntryGetInt (e);
+
     return -1;
 }
 
@@ -870,10 +939,12 @@ httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id)
     time_t value = -1;
     assert_eid(id);
     assert(Headers[id].type == ftDate_1123);	/* must be of an appropriate type */
+
     if ((e = httpHeaderFindEntry(hdr, id))) {
-	value = parse_rfc1123(e->value.buf());
-	httpHeaderNoteParsedEntry(e->id, e->value, value < 0);
+        value = parse_rfc1123(e->value.buf());
+        httpHeaderNoteParsedEntry(e->id, e->value, value < 0);
     }
+
     return value;
 }
 
@@ -884,10 +955,12 @@ httpHeaderGetStr(const HttpHeader * hdr, http_hdr_type id)
     HttpHeaderEntry *e;
     assert_eid(id);
     assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
+
     if ((e = httpHeaderFindEntry(hdr, id))) {
-	httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
-	return e->value.buf();
+        httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
+        return e->value.buf();
     }
+
     return NULL;
 }
 
@@ -898,10 +971,12 @@ httpHeaderGetLastStr(const HttpHeader * hdr, http_hdr_type id)
     HttpHeaderEntry *e;
     assert_eid(id);
     assert(Headers[id].type == ftStr);	/* must be of an appropriate type */
+
     if ((e = httpHeaderFindLastEntry(hdr, id))) {
-	httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
-	return e->value.buf();
+        httpHeaderNoteParsedEntry(e->id, e->value, 0);	/* no errors are possible */
+        return e->value.buf();
     }
+
     return NULL;
 }
 
@@ -910,15 +985,23 @@ httpHeaderGetCc(const HttpHeader * hdr)
 {
     HttpHdrCc *cc;
     String s;
+
     if (!CBIT_TEST(hdr->mask, HDR_CACHE_CONTROL))
-	return NULL;
+        return NULL;
+
     s = httpHeaderGetList(hdr, HDR_CACHE_CONTROL);
+
     cc = httpHdrCcParseCreate(&s);
+
     HttpHeaderStats[hdr->owner].ccParsedCount++;
+
     if (cc)
-	httpHdrCcUpdateStats(cc, &HttpHeaderStats[hdr->owner].ccTypeDistr);
+        httpHdrCcUpdateStats(cc, &HttpHeaderStats[hdr->owner].ccTypeDistr);
+
     httpHeaderNoteParsedEntry(HDR_CACHE_CONTROL, s, !cc);
+
     s.clean();
+
     return cc;
 }
 
@@ -931,11 +1014,13 @@ httpHeaderGetRange(const HttpHeader * hdr)
      * who knows, some clients might send Request-Range only;
      * this "if" should work correctly in both cases;
      * hopefully no clients send mismatched headers! */
+
     if ((e = httpHeaderFindEntry(hdr, HDR_RANGE)) ||
-	(e = httpHeaderFindEntry(hdr, HDR_REQUEST_RANGE))) {
-	r = HttpHdrRange::ParseCreate(&e->value);
-	httpHeaderNoteParsedEntry(e->id, e->value, !r);
+            (e = httpHeaderFindEntry(hdr, HDR_REQUEST_RANGE))) {
+        r = HttpHdrRange::ParseCreate(&e->value);
+        httpHeaderNoteParsedEntry(e->id, e->value, !r);
     }
+
     return r;
 }
 
@@ -944,10 +1029,12 @@ httpHeaderGetContRange(const HttpHeader * hdr)
 {
     HttpHdrContRange *cr = NULL;
     HttpHeaderEntry *e;
+
     if ((e = httpHeaderFindEntry(hdr, HDR_CONTENT_RANGE))) {
-	cr = httpHdrContRangeParseCreate(e->value.buf());
-	httpHeaderNoteParsedEntry(e->id, e->value, !cr);
+        cr = httpHdrContRangeParseCreate(e->value.buf());
+        httpHeaderNoteParsedEntry(e->id, e->value, !cr);
     }
+
     return cr;
 }
 
@@ -958,30 +1045,40 @@ httpHeaderGetAuth(const HttpHeader * hdr, http_hdr_type id, const char *auth_sch
     int l;
     assert(hdr && auth_scheme);
     field = httpHeaderGetStr(hdr, id);
+
     if (!field)			/* no authorization field */
-	return NULL;
+        return NULL;
+
     l = strlen(auth_scheme);
+
     if (!l || strncasecmp(field, auth_scheme, l))	/* wrong scheme */
-	return NULL;
+        return NULL;
+
     field += l;
+
     if (!xisspace(*field))	/* wrong scheme */
-	return NULL;
+        return NULL;
+
     /* skip white space */
     field += xcountws(field);
+
     if (!*field)		/* no authorization cookie */
-	return NULL;
+        return NULL;
+
     return base64_decode(field);
 }
 
 ETag
 httpHeaderGetETag(const HttpHeader * hdr, http_hdr_type id)
 {
     ETag etag =
-    {NULL, -1};
+        {NULL, -1};
     HttpHeaderEntry *e;
     assert(Headers[id].type == ftETag);		/* must be of an appropriate type */
+
     if ((e = httpHeaderFindEntry(hdr, id)))
-	etagParseInit(&etag, e->value.buf());
+        etagParseInit(&etag, e->value.buf());
+
     return etag;
 }
 
@@ -992,19 +1089,22 @@ httpHeaderGetTimeOrTag(const HttpHeader * hdr, http_hdr_type id)
     HttpHeaderEntry *e;
     assert(Headers[id].type == ftDate_1123_or_ETag);	/* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
+
     if ((e = httpHeaderFindEntry(hdr, id))) {
-	const char *str = e->value.buf();
-	/* try as an ETag */
-	if (etagParseInit(&tot.tag, str)) {
-	    tot.valid = tot.tag.str != NULL;
-	    tot.time = -1;
-	} else {
-	    /* or maybe it is time? */
-	    tot.time = parse_rfc1123(str);
-	    tot.valid = tot.time >= 0;
-	    tot.tag.str = NULL;
-	}
+        const char *str = e->value.buf();
+        /* try as an ETag */
+
+        if (etagParseInit(&tot.tag, str)) {
+            tot.valid = tot.tag.str != NULL;
+            tot.time = -1;
+        } else {
+            /* or maybe it is time? */
+            tot.time = parse_rfc1123(str);
+            tot.valid = tot.time >= 0;
+            tot.tag.str = NULL;
+        }
     }
+
     assert(tot.time < 0 || !tot.tag.str);	/* paranoid */
     return tot;
 }
@@ -1020,13 +1120,18 @@ httpHeaderEntryCreate(http_hdr_type id, const char *name, const char *value)
     assert_eid(id);
     e = (HttpHeaderEntry *)memAllocate(MEM_HTTP_HDR_ENTRY);
     e->id = id;
+
     if (id != HDR_OTHER)
-	e->name = Headers[id].name;
+        e->name = Headers[id].name;
     else
-	e->name = name;
+        e->name = name;
+
     e->value = value;
+
     Headers[id].stat.aliveCount++;
+
     debug(55, 9) ("created entry %p: '%s: %s'\n", e, e->name.buf(), e->value.buf());
+
     return e;
 }
 
@@ -1037,12 +1142,18 @@ httpHeaderEntryDestroy(HttpHeaderEntry * e)
     assert_eid(e->id);
     debug(55, 9) ("destroying entry %p: '%s: %s'\n", e, e->name.buf(), e->value.buf());
     /* clean name if needed */
+
     if (e->id == HDR_OTHER)
-	e->name.clean();
+        e->name.clean();
+
     e->value.clean();
+
     assert(Headers[e->id].stat.aliveCount);
+
     Headers[e->id].stat.aliveCount--;
+
     e->id = HDR_BAD_HDR;
+
     memFree(e, MEM_HTTP_HDR_ENTRY);
 }
 
@@ -1061,44 +1172,63 @@ httpHeaderEntryParseCreate(const char *field_start, const char *field_end)
     HeaderEntryParsedCount++;
 
     /* do we have a valid field name within this field? */
+
     if (!name_len || name_end > field_end)
-	return NULL;
+        return NULL;
+
     if (name_len > 65536) {
-	/* String has a 64K limit */
-	debug(55, 1) ("WARNING: ignoring header name of %d bytes\n", name_len);
-	return NULL;
+        /* String has a 64K limit */
+        debug(55, 1) ("WARNING: ignoring header name of %d bytes\n", name_len);
+        return NULL;
     }
+
     /* now we know we can parse it */
     e = (HttpHeaderEntry *)memAllocate(MEM_HTTP_HDR_ENTRY);
+
     debug(55, 9) ("creating entry %p: near '%s'\n", e, getStringPrefix(field_start, field_end));
+
     /* is it a "known" field? */
     id = httpHeaderIdByName(field_start, name_len, Headers, HDR_ENUM_END);
+
     if (id < 0)
-	id = HDR_OTHER;
+        id = HDR_OTHER;
+
     assert_eid(id);
+
     e->id = id;
+
     /* set field name */
     if (id == HDR_OTHER)
-	e->name.limitInit(field_start, name_len);
+        e->name.limitInit(field_start, name_len);
     else
-	e->name = Headers[id].name;
+        e->name = Headers[id].name;
+
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
-	value_start++;
+        value_start++;
+
     if (field_end - value_start > 65536) {
-	/* String has a 64K limit */
-	debug(55, 1) ("WARNING: ignoring '%s' header of %d bytes\n",
-	    e->name.buf(), (int) (field_end - value_start));
-	if (e->id == HDR_OTHER)
-	    e->name.clean();
-	memFree(e, MEM_HTTP_HDR_ENTRY);
-	return NULL;
+        /* String has a 64K limit */
+        debug(55, 1) ("WARNING: ignoring '%s' header of %d bytes\n",
+                      e->name.buf(), (int) (field_end - value_start));
+
+        if (e->id == HDR_OTHER)
+            e->name.clean();
+
+        memFree(e, MEM_HTTP_HDR_ENTRY);
+
+        return NULL;
     }
+
     /* set field value */
     e->value.limitInit(value_start, field_end - value_start);
+
     Headers[id].stat.seenCount++;
+
     Headers[id].stat.aliveCount++;
+
     debug(55, 9) ("created entry %p: '%s: %s'\n", e, e->name.buf(), e->value.buf());
+
     return e;
 }
 
@@ -1122,10 +1252,11 @@ static void
 httpHeaderNoteParsedEntry(http_hdr_type id, String context, int error)
 {
     Headers[id].stat.parsCount++;
+
     if (error) {
-	Headers[id].stat.errCount++;
-	debug(55, 2) ("cannot parse hdr field: '%s: %s'\n",
-	    Headers[id].name.buf(), context.buf());
+        Headers[id].stat.errCount++;
+        debug(55, 2) ("cannot parse hdr field: '%s: %s'\n",
+                      Headers[id].name.buf(), context.buf());
     }
 }
 
@@ -1145,20 +1276,22 @@ httpHeaderFieldStatDumper(StoreEntry * sentry, int idx, double val, double size,
     const char *name = valid_id ? Headers[id].name.buf() : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
+
     if (!visible && valid_id && dump_stat->owner_mask)
-	visible = CBIT_TEST(*dump_stat->owner_mask, id);
+        visible = CBIT_TEST(*dump_stat->owner_mask, id);
+
     if (visible)
-	storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
-	    id, name, count, xdiv(count, dump_stat->busyDestroyedCount));
+        storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
+                          id, name, count, xdiv(count, dump_stat->busyDestroyedCount));
 }
 
 static void
 httpHeaderFldsPerHdrDumper(StoreEntry * sentry, int idx, double val, double size, int count)
 {
     if (count)
-	storeAppendPrintf(sentry, "%2d\t %5d\t %5d\t %6.2f\n",
-	    idx, (int) val, count,
-	    xpercent(count, dump_stat->destroyedCount));
+        storeAppendPrintf(sentry, "%2d\t %5d\t %5d\t %6.2f\n",
+                          idx, (int) val, count,
+                          xpercent(count, dump_stat->destroyedCount));
 }
 
 
@@ -1171,15 +1304,15 @@ httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
     storeAppendPrintf(e, "\nHeader Stats: %s\n", hs->label);
     storeAppendPrintf(e, "\nField type distribution\n");
     storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\n",
-	"id", "name", "count", "#/header");
+                      "id", "name", "count", "#/header");
     statHistDump(&hs->fieldTypeDistr, e, httpHeaderFieldStatDumper);
     storeAppendPrintf(e, "\nCache-control directives distribution\n");
     storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\n",
-	"id", "name", "count", "#/cc_field");
+                      "id", "name", "count", "#/cc_field");
     statHistDump(&hs->ccTypeDistr, e, httpHdrCcStatDumper);
     storeAppendPrintf(e, "\nNumber of fields per header distribution\n");
     storeAppendPrintf(e, "%2s\t %-5s\t %5s\t %6s\n",
-	"id", "#flds", "count", "%total");
+                      "id", "#flds", "count", "%total");
     statHistDump(&hs->hdrUCountDistr, e, httpHeaderFldsPerHdrDumper);
     dump_stat = NULL;
 }
@@ -1192,63 +1325,73 @@ httpHeaderStoreReport(StoreEntry * e)
     assert(e);
 
     HttpHeaderStats[0].parsedCount =
-	HttpHeaderStats[hoRequest].parsedCount + HttpHeaderStats[hoReply].parsedCount;
+        HttpHeaderStats[hoRequest].parsedCount + HttpHeaderStats[hoReply].parsedCount;
     HttpHeaderStats[0].ccParsedCount =
-	HttpHeaderStats[hoRequest].ccParsedCount + HttpHeaderStats[hoReply].ccParsedCount;
+        HttpHeaderStats[hoRequest].ccParsedCount + HttpHeaderStats[hoReply].ccParsedCount;
     HttpHeaderStats[0].destroyedCount =
-	HttpHeaderStats[hoRequest].destroyedCount + HttpHeaderStats[hoReply].destroyedCount;
+        HttpHeaderStats[hoRequest].destroyedCount + HttpHeaderStats[hoReply].destroyedCount;
     HttpHeaderStats[0].busyDestroyedCount =
-	HttpHeaderStats[hoRequest].busyDestroyedCount + HttpHeaderStats[hoReply].busyDestroyedCount;
+        HttpHeaderStats[hoRequest].busyDestroyedCount + HttpHeaderStats[hoReply].busyDestroyedCount;
 
     for (i = 1; i < HttpHeaderStatCount; i++) {
-	httpHeaderStatDump(HttpHeaderStats + i, e);
-	storeAppendPrintf(e, "%s\n", "<br>");
+        httpHeaderStatDump(HttpHeaderStats + i, e);
+        storeAppendPrintf(e, "%s\n", "<br>");
     }
+
     /* field stats for all messages */
     storeAppendPrintf(e, "\nHttp Fields Stats (replies and requests)\n");
+
     storeAppendPrintf(e, "%2s\t %-20s\t %5s\t %6s\t %6s\n",
-	"id", "name", "#alive", "%err", "%repeat");
+                      "id", "name", "#alive", "%err", "%repeat");
+
     for (ht = (http_hdr_type)0; ht < HDR_ENUM_END; ++ht) {
-	HttpHeaderFieldInfo *f = Headers + ht;
-	storeAppendPrintf(e, "%2d\t %-20s\t %5d\t %6.3f\t %6.3f\n",
-	    f->id, f->name.buf(), f->stat.aliveCount,
-	    xpercent(f->stat.errCount, f->stat.parsCount),
-	    xpercent(f->stat.repCount, f->stat.seenCount));
+        HttpHeaderFieldInfo *f = Headers + ht;
+        storeAppendPrintf(e, "%2d\t %-20s\t %5d\t %6.3f\t %6.3f\n",
+                          f->id, f->name.buf(), f->stat.aliveCount,
+                          xpercent(f->stat.errCount, f->stat.parsCount),
+                          xpercent(f->stat.repCount, f->stat.seenCount));
     }
+
     storeAppendPrintf(e, "Headers Parsed: %d + %d = %d\n",
-	HttpHeaderStats[hoRequest].parsedCount,
-	HttpHeaderStats[hoReply].parsedCount,
-	HttpHeaderStats[0].parsedCount);
+                      HttpHeaderStats[hoRequest].parsedCount,
+                      HttpHeaderStats[hoReply].parsedCount,
+                      HttpHeaderStats[0].parsedCount);
     storeAppendPrintf(e, "Hdr Fields Parsed: %d\n", HeaderEntryParsedCount);
 }
 
 http_hdr_type
 httpHeaderIdByName(const char *name, int name_len, const HttpHeaderFieldInfo * info, int end)
 {
     int i;
+
     for (i = 0; i < end; ++i) {
-	if (name_len >= 0 && name_len != info[i].name.size())
-	    continue;
-	if (!strncasecmp(name, info[i].name.buf(),
-		name_len < 0 ? info[i].name.size() + 1 : name_len))
-	    return info[i].id;
+        if (name_len >= 0 && name_len != info[i].name.size())
+            continue;
+
+        if (!strncasecmp(name, info[i].name.buf(),
+                         name_len < 0 ? info[i].name.size() + 1 : name_len))
+            return info[i].id;
     }
+
     return HDR_BAD_HDR;
 }
 
 http_hdr_type
 httpHeaderIdByNameDef(const char *name, int name_len)
 {
     if (!Headers)
-	Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+
     return httpHeaderIdByName(name, name_len, Headers, HDR_ENUM_END);
 }
 
 const char *
 httpHeaderNameById(int id)
 {
     if (!Headers)
-	Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+
     assert(id >= 0 && id < HDR_ENUM_END);
+
     return HeadersAttrs[id].name;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.h,v 1.2 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHeader.h,v 1.3 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,7 +38,9 @@
 #include "HttpHeaderRange.h"
 
 /* constant attributes of http header fields */
-struct _HttpHeaderFieldAttrs {
+
+struct _HttpHeaderFieldAttrs
+{
     const char *name;
     http_hdr_type id;
     field_type type;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeaderRange.h,v 1.1 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpHeaderRange.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -38,14 +38,17 @@
 
 typedef struct _HttpReply HttpReply;
 /* http byte-range-spec */
-class HttpHdrRangeSpec {
-  public:
+
+class HttpHdrRangeSpec
+{
+
+public:
     void *operator new(size_t);
     void operator delete (void *);
     void deleteSelf() const;
     typedef Range<ssize_t> HttpRange;
     static ssize_t const UnknownPosition;
-    
+
     HttpHdrRangeSpec();
     static HttpHdrRangeSpec *Create(const char *field, int fieldLen);
 
@@ -56,6 +59,7 @@ class HttpHdrRangeSpec {
     bool mergeWith(const HttpHdrRangeSpec * donor);
     ssize_t offset;
     ssize_t length;
+
 private:
     static MemPool *Pool;
 };
@@ -64,7 +68,10 @@ class HttpHdrRangeSpec {
  * This object holds all range specs in order of their appearence
  * in the request because we SHOULD preserve that order.
  */
-class HttpHdrRange {
+
+class HttpHdrRange
+{
+
 public:
     void *operator new(size_t);
     void operator delete (void *);
@@ -85,7 +92,7 @@ class HttpHdrRange {
     const_iterator begin () const;
     iterator end();
     const_iterator end() const;
-    
+
     /* adjust specs after the length is known */
     int canonize(size_t);
     int canonize(HttpReply *rep);
@@ -99,6 +106,7 @@ class HttpHdrRange {
     ssize_t lowestOffset(ssize_t) const;
     bool offsetLimitExceeded() const;
     Vector<HttpHdrRangeSpec *> specs;
+
 private:
     static MemPool *Pool;
     void getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy);
@@ -107,8 +115,11 @@ class HttpHdrRange {
 };
 
 /* data for iterating thru range specs */
-class HttpHdrRangeIter {
-  public:
+
+class HttpHdrRangeIter
+{
+
+public:
     HttpHdrRange::iterator pos;
     const HttpHdrRangeSpec *currentSpec() const;
     void updateSpec();
@@ -118,4 +129,5 @@ class HttpHdrRangeIter {
     String boundary;		/* boundary for multipart responses */
     bool valid;
 };
+
 #endif /* SQUID_HTTPHEADERRANGE_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeaderTools.cc,v 1.37 2003/02/12 06:10:58 robertc Exp $
+ * $Id: HttpHeaderTools.cc,v 1.38 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 66    HTTP Header Tools
  * AUTHOR: Alex Rousskov
@@ -55,29 +55,32 @@ httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count)
     table = (HttpHeaderFieldInfo *)xcalloc(count, sizeof(HttpHeaderFieldInfo));
 
     for (i = 0; i < count; ++i) {
-	const http_hdr_type id = attrs[i].id;
-	HttpHeaderFieldInfo *info = table + id;
-	/* sanity checks */
-	assert(id >= 0 && id < count);
-	assert(attrs[i].name);
-	assert(info->id == 0 && info->type == 0);	/* was not set before */
-	/* copy and init fields */
-	info->id = id;
-	info->type = attrs[i].type;
-	info->name = attrs[i].name;
-	assert(info->name.size());
-	/* init stats */
-	memset(&info->stat, 0, sizeof(info->stat));
+        const http_hdr_type id = attrs[i].id;
+        HttpHeaderFieldInfo *info = table + id;
+        /* sanity checks */
+        assert(id >= 0 && id < count);
+        assert(attrs[i].name);
+        assert(info->id == 0 && info->type == 0);	/* was not set before */
+        /* copy and init fields */
+        info->id = id;
+        info->type = attrs[i].type;
+        info->name = attrs[i].name;
+        assert(info->name.size());
+        /* init stats */
+        memset(&info->stat, 0, sizeof(info->stat));
     }
+
     return table;
 }
 
 void
 httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * table, int count)
 {
     int i;
+
     for (i = 0; i < count; ++i)
-	table[i].name.clean();
+        table[i].name.clean();
+
     xfree(table);
 }
 
@@ -96,8 +99,8 @@ httpHeaderCalcMask(HttpHeaderMask * mask, const int *enums, size_t count)
     assert(count < sizeof(*mask) * 8);	/* check for overflow */
 
     for (i = 0; i < count; ++i) {
-	assert(!CBIT_TEST(*mask, enums[i]));	/* check for duplicates */
-	CBIT_SET(*mask, enums[i]);
+        assert(!CBIT_TEST(*mask, enums[i]));	/* check for duplicates */
+        CBIT_SET(*mask, enums[i]);
     }
 }
 
@@ -107,13 +110,14 @@ void
 httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...)
 #else
 httpHeaderPutStrf(va_alist)
-     va_dcl
+va_dcl
 #endif
 {
 #if STDC_HEADERS
     va_list args;
     va_start(args, fmt);
 #else
+
     va_list args;
     HttpHeader *hdr = NULL;
     http_hdr_type id = HDR_ENUM_END;
@@ -123,6 +127,7 @@ httpHeaderPutStrf(va_alist)
     id = va_arg(args, http_hdr_type);
     fmt = va_arg(args, char *);
 #endif
+
     httpHeaderPutStrvf(hdr, id, fmt, args);
     va_end(args);
 }
@@ -163,16 +168,20 @@ httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
     http_hdr_type ht;
     int res;
     /* what type of header do we have? */
+
     if (httpHeaderHas(hdr, HDR_PROXY_CONNECTION))
-	ht = HDR_PROXY_CONNECTION;
+        ht = HDR_PROXY_CONNECTION;
     else if (httpHeaderHas(hdr, HDR_CONNECTION))
-	ht = HDR_CONNECTION;
+        ht = HDR_CONNECTION;
     else
-	return 0;
+        return 0;
 
     list = httpHeaderGetList(hdr, ht);
+
     res = strListIsMember(&list, directive, ',');
+
     list.clean();
+
     return res;
 }
 
@@ -186,10 +195,12 @@ strListIsMember(const String * list, const char *m, char del)
     int mlen;
     assert(list && m);
     mlen = strlen(m);
+
     while (strListGetItem(list, del, &item, &ilen, &pos)) {
-	if (mlen == ilen && !strncasecmp(item, m, ilen))
-	    return 1;
+        if (mlen == ilen && !strncasecmp(item, m, ilen))
+            return 1;
     }
+
     return 0;
 }
 
@@ -209,13 +220,16 @@ strListIsSubstr(const String * list, const char *s, char del)
      */
 
 #ifdef BROKEN_CODE
+
     const char *pos = NULL;
     const char *item;
     assert(list && s);
+
     while (strListGetItem(list, del, &item, NULL, &pos)) {
-	if (strstr(item, s))
-	    return 1;
+        if (strstr(item, s))
+            return 1;
     }
+
     return 0;
 #endif
 }
@@ -225,13 +239,15 @@ void
 strListAdd(String * str, const char *item, char del)
 {
     assert(str && item);
+
     if (str->size()) {
-	char buf[3];
-	buf[0] = del;
-	buf[1] = ' ';
-	buf[2] = '\0';
-	str->append(buf, 2);
+        char buf[3];
+        buf[0] = del;
+        buf[1] = ' ';
+        buf[2] = '\0';
+        str->append(buf, 2);
     }
+
     str->append(item, strlen(item));
 }
 
@@ -248,30 +264,39 @@ strListGetItem(const String * str, char del, const char **item, int *ilen, const
 {
     size_t len;
     assert(str && item && pos);
+
     if (*pos) {
-	if (!**pos)		/* end of string */
-	    return 0;
-	else
-	    (*pos)++;
+        if (!**pos)		/* end of string */
+            return 0;
+        else
+            (*pos)++;
     } else {
-	*pos = str->buf();
-	if (!*pos)
-	    return 0;
+        *pos = str->buf();
+
+        if (!*pos)
+            return 0;
     }
 
     /* skip leading ws (ltrim) */
     *pos += xcountws(*pos);
+
     *item = *pos;		/* remember item's start */
+
     /* find next delimiter */
     *pos = strchr(*item, del);
+
     if (!*pos)			/* last item */
-	*pos = *item + strlen(*item);
+        *pos = *item + strlen(*item);
+
     len = *pos - *item;		/* *pos points to del or '\0' */
+
     /* rtrim */
     while (len > 0 && xisspace((*item)[len - 1]))
-	len--;
+        len--;
+
     if (ilen)
-	*ilen = len;
+        *ilen = len;
+
     return len > 0;
 }
 
@@ -295,10 +320,12 @@ httpHeaderParseInt(const char *start, int *value)
 {
     assert(value);
     *value = atoi(start);
+
     if (!*value && !xisdigit(*start)) {
-	debug(66, 2) ("failed to parse an int header field near '%s'\n", start);
-	return 0;
+        debug(66, 2) ("failed to parse an int header field near '%s'\n", start);
+        return 0;
     }
+
     return 1;
 }
 
@@ -330,44 +357,59 @@ httpHeaderTestParser(const char *hstr)
     MemBuf mb;
     assert(hstr);
     /* skip start line if any */
+
     if (!strncasecmp(hstr, "HTTP/", 5)) {
-	const char *p = strchr(hstr, '\n');
-	if (p)
-	    hstr = p + 1;
+        const char *p = strchr(hstr, '\n');
+
+        if (p)
+            hstr = p + 1;
     }
+
     /* skip invalid first line if any */
     if (xisspace(*hstr)) {
-	const char *p = strchr(hstr, '\n');
-	if (p)
-	    hstr = p + 1;
+        const char *p = strchr(hstr, '\n');
+
+        if (p)
+            hstr = p + 1;
     }
+
     hstr_len = strlen(hstr);
     /* skip terminator if any */
+
     if (strstr(hstr, "\n\r\n"))
-	hstr_len -= 2;
+        hstr_len -= 2;
     else if (strstr(hstr, "\n\n"))
-	hstr_len -= 1;
+        hstr_len -= 1;
+
     httpHeaderInit(&hdr, hoReply);
+
     /* Debug::Levels[55] = 8; */
     parse_success = httpHeaderParse(&hdr, hstr, hstr + hstr_len);
+
     /* Debug::Levels[55] = 2; */
     if (!parse_success) {
-	debug(66, 2) ("TEST (%d): failed to parsed a header: {\n%s}\n", bug_count, hstr);
-	return;
+        debug(66, 2) ("TEST (%d): failed to parsed a header: {\n%s}\n", bug_count, hstr);
+        return;
     }
+
     /* we think that we parsed it, veryfy */
     memBufDefInit(&mb);
+
     packerToMemInit(&p, &mb);
+
     httpHeaderPackInto(&hdr, &p);
+
     if ((pos = abs(httpHeaderStrCmp(hstr, mb.buf, hstr_len)))) {
-	bug_count++;
-	debug(66, 2) ("TEST (%d): hdr parsing bug (pos: %d near '%s'): expected: {\n%s} got: {\n%s}\n",
-	    bug_count, pos, hstr + pos, hstr, mb.buf);
+        bug_count++;
+        debug(66, 2) ("TEST (%d): hdr parsing bug (pos: %d near '%s'): expected: {\n%s} got: {\n%s}\n",
+                      bug_count, pos, hstr + pos, hstr, mb.buf);
     }
+
     httpHeaderClean(&hdr);
     packerClean(&p);
     memBufClean(&mb);
 }
+
 #endif
 
 
@@ -380,25 +422,34 @@ httpHeaderStrCmp(const char *h1, const char *h2, int len)
     int len2 = 0;
     assert(h1 && h2);
     /* fast check first */
+
     if (!strncasecmp(h1, h2, len))
-	return 0;
+        return 0;
+
     while (1) {
-	const char c1 = xtoupper(h1[len1 += xcountws(h1 + len1)]);
-	const char c2 = xtoupper(h2[len2 += xcountws(h2 + len2)]);
-	if (c1 < c2)
-	    return -len1;
-	if (c1 > c2)
-	    return +len1;
-	if (!c1 && !c2)
-	    return 0;
-	if (c1)
-	    len1++;
-	if (c2)
-	    len2++;
+        const char c1 = xtoupper(h1[len1 += xcountws(h1 + len1)]);
+        const char c2 = xtoupper(h2[len2 += xcountws(h2 + len2)]);
+
+        if (c1 < c2)
+            return -len1;
+
+        if (c1 > c2)
+            return +len1;
+
+        if (!c1 && !c2)
+            return 0;
+
+        if (c1)
+            len1++;
+
+        if (c2)
+            len2++;
     }
+
     /* NOTREACHED */
     return 0;
 }
+
 #endif
 
 /*
@@ -416,19 +467,20 @@ httpHdrMangle(HttpHeaderEntry * e, request_t * request)
     assert(e);
     hm = &Config.header_access[e->id];
     checklist = aclChecklistCreate(hm->access_list, request, NULL);
+
     if (1 == aclCheckFast(hm->access_list, checklist)) {
-	/* aclCheckFast returns 1 for allow. */
-	retval = 1;
+        /* aclCheckFast returns 1 for allow. */
+        retval = 1;
     } else if (NULL == hm->replacement) {
-	/* It was denied, and we don't have any replacement */
-	retval = 0;
+        /* It was denied, and we don't have any replacement */
+        retval = 0;
     } else {
-	/* It was denied, but we have a replacement. Replace the
-	 * header on the fly, and return that the new header
-	 * is allowed.
-	 */
-	e->value = hm->replacement;
-	retval = 1;
+        /* It was denied, but we have a replacement. Replace the
+         * header on the fly, and return that the new header
+         * is allowed.
+         */
+        e->value = hm->replacement;
+        retval = 1;
     }
 
     delete checklist;
@@ -441,7 +493,8 @@ httpHdrMangleList(HttpHeader * l, request_t * request)
 {
     HttpHeaderEntry *e;
     HttpHeaderPos p = HttpHeaderInitPos;
+
     while ((e = httpHeaderGetEntry(l, &p)))
-	if (0 == httpHdrMangle(e, request))
-	    httpHeaderDelAt(l, p);
+        if (0 == httpHdrMangle(e, request))
+            httpHeaderDelAt(l, p);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpMsg.cc,v 1.11 2003/01/23 00:37:12 robertc Exp $
+ * $Id: HttpMsg.cc,v 1.12 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 74    HTTP Message
  * AUTHOR: Alex Rousskov
@@ -47,70 +47,83 @@ httpMsgIsolateHeaders(const char **parse_start, const char **blk_start, const ch
     size_t l = strlen(*parse_start);
     size_t end = headersEnd(*parse_start, l);
     int nnl;
+
     if (end) {
-	*blk_start = *parse_start;
-	*blk_end = *parse_start + end - 1;
-	/*
-	 * leave blk_end pointing to the first character after the
-	 * first newline which terminates the headers
-	 */
-	assert(**blk_end == '\n');
-	while (*(*blk_end - 1) == '\r')
-	    (*blk_end)--;
-	assert(*(*blk_end - 1) == '\n');
-	*parse_start += end;
-	return 1;
+        *blk_start = *parse_start;
+        *blk_end = *parse_start + end - 1;
+        /*
+         * leave blk_end pointing to the first character after the
+         * first newline which terminates the headers
+         */
+        assert(**blk_end == '\n');
+
+        while (*(*blk_end - 1) == '\r')
+            (*blk_end)--;
+
+        assert(*(*blk_end - 1) == '\n');
+
+        *parse_start += end;
+
+        return 1;
     }
+
     /*
      * If we didn't find the end of headers, and parse_start does
      * NOT point to a CR or NL character, then return failure
      */
     if (**parse_start != '\r' && **parse_start != '\n')
-	return 0;		/* failure */
+        return 0;		/* failure */
+
     /*
      * If we didn't find the end of headers, and parse_start does point
      * to an empty line, then we have empty headers.  Skip all CR and
      * NL characters up to the first NL.  Leave parse_start pointing at
      * the first character after the first NL.
      */
     *blk_start = *parse_start;
+
     *blk_end = *blk_start;
+
     for (nnl = 0; nnl == 0; (*parse_start)++) {
-	if (**parse_start == '\r')
-	    (void) 0;
-	else if (**parse_start == '\n')
-	    nnl++;
-	else
-	    break;
+        if (**parse_start == '\r')
+            (void) 0;
+        else if (**parse_start == '\n')
+            nnl++;
+        else
+            break;
     }
+
     return 1;
 }
 
-/* returns true if connection should be "persistent" 
+/* returns true if connection should be "persistent"
  * after processing this message */
 int
 httpMsgIsPersistent(http_version_t http_ver, const HttpHeader * hdr)
 {
     if ((http_ver.major >= 1) && (http_ver.minor >= 1)) {
-	/*
-	 * for modern versions of HTTP: persistent unless there is
-	 * a "Connection: close" header.
-	 */
-	return !httpHeaderHasConnDir(hdr, "close");
+        /*
+         * for modern versions of HTTP: persistent unless there is
+         * a "Connection: close" header.
+         */
+        return !httpHeaderHasConnDir(hdr, "close");
     } else {
-	/*
-	 * Persistent connections in Netscape 3.x are allegedly broken,
-	 * return false if it is a browser connection.  If there is a
-	 * VIA header, then we assume this is NOT a browser connection.
-	 */
-	const char *agent = httpHeaderGetStr(hdr, HDR_USER_AGENT);
-	if (agent && !httpHeaderHas(hdr, HDR_VIA)) {
-	    if (!strncasecmp(agent, "Mozilla/3.", 10))
-		return 0;
-	    if (!strncasecmp(agent, "Netscape/3.", 11))
-		return 0;
-	}
-	/* for old versions of HTTP: persistent if has "keep-alive" */
-	return httpHeaderHasConnDir(hdr, "keep-alive");
+        /*
+         * Persistent connections in Netscape 3.x are allegedly broken,
+         * return false if it is a browser connection.  If there is a
+         * VIA header, then we assume this is NOT a browser connection.
+         */
+        const char *agent = httpHeaderGetStr(hdr, HDR_USER_AGENT);
+
+        if (agent && !httpHeaderHas(hdr, HDR_VIA)) {
+            if (!strncasecmp(agent, "Mozilla/3.", 10))
+                return 0;
+
+            if (!strncasecmp(agent, "Netscape/3.", 11))
+                return 0;
+        }
+
+        /* for old versions of HTTP: persistent if has "keep-alive" */
+        return httpHeaderHasConnDir(hdr, "keep-alive");
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpReply.cc,v 1.53 2003/02/12 06:10:58 robertc Exp $
+ * $Id: HttpReply.cc,v 1.54 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 58    HTTP Reply (Response)
  * AUTHOR: Alex Rousskov
@@ -45,11 +45,11 @@
 /* these entity-headers must be ignored if a bogus server sends them in 304 */
 static HttpHeaderMask Denied304HeadersMask;
 static http_hdr_type Denied304HeadersArr[] =
-{
-    HDR_ALLOW, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE, HDR_CONTENT_LENGTH,
-    HDR_CONTENT_LOCATION, HDR_CONTENT_RANGE, HDR_LAST_MODIFIED, HDR_LINK,
-    HDR_OTHER
-};
+    {
+        HDR_ALLOW, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE, HDR_CONTENT_LENGTH,
+        HDR_CONTENT_LOCATION, HDR_CONTENT_RANGE, HDR_LAST_MODIFIED, HDR_LINK,
+        HDR_OTHER
+    };
 
 HttpMsgParseState &operator++ (HttpMsgParseState &aState)
 {
@@ -213,7 +213,7 @@ httpReplySwapOut(HttpReply * rep, StoreEntry * e)
 
 MemBuf
 httpPackedReply(http_version_t ver, http_status status, const char *ctype,
-    int clen, time_t lmt, time_t expires)
+                int clen, time_t lmt, time_t expires)
 {
     HttpReply *rep = httpReplyCreate();
     MemBuf mb;
@@ -226,8 +226,8 @@ httpPackedReply(http_version_t ver, http_status status, const char *ctype,
 HttpReply *
 httpReplyMake304 (const HttpReply * rep)
 {
-    static const http_hdr_type ImsEntries[] =
-      {HDR_DATE, HDR_CONTENT_TYPE, HDR_EXPIRES, HDR_LAST_MODIFIED, /* eof */ HDR_OTHER};
+    static const http_hdr_type ImsEntries[] = {HDR_DATE, HDR_CONTENT_TYPE, HDR_EXPIRES, HDR_LAST_MODIFIED, /* eof */ HDR_OTHER};
+
     HttpReply *rv;
     int t;
     HttpHeaderEntry *e;
@@ -245,9 +245,12 @@ httpReplyMake304 (const HttpReply * rep)
     /* rv->keep_alive */
     httpBuildVersion(&ver, 1, 0);
     httpStatusLineSet(&rv->sline, ver,
-        HTTP_NOT_MODIFIED, "");
+                      HTTP_NOT_MODIFIED, "");
+
     for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
-	if ((e = httpHeaderFindEntry(&rep->header, ImsEntries[t])))httpHeaderAddEntry(&rv->header, httpHeaderEntryClone(e));
+        if ((e = httpHeaderFindEntry(&rep->header, ImsEntries[t])))
+            httpHeaderAddEntry(&rv->header, httpHeaderEntryClone(e));
+
     /* rv->body */
     return rv;
 }
@@ -269,7 +272,7 @@ httpPacked304Reply(const HttpReply * rep)
 
 void
 httpReplySetHeaders(HttpReply * reply, http_version_t ver, http_status status, const char *reason,
-    const char *ctype, int clen, time_t lmt, time_t expires)
+                    const char *ctype, int clen, time_t lmt, time_t expires)
 {
     HttpHeader *hdr;
     assert(reply);
@@ -278,20 +281,28 @@ httpReplySetHeaders(HttpReply * reply, http_version_t ver, http_status status, c
     httpHeaderPutStr(hdr, HDR_SERVER, full_appname_string);
     httpHeaderPutStr(hdr, HDR_MIME_VERSION, "1.0");
     httpHeaderPutTime(hdr, HDR_DATE, squid_curtime);
+
     if (ctype) {
-	httpHeaderPutStr(hdr, HDR_CONTENT_TYPE, ctype);
-	reply->content_type = ctype;
+        httpHeaderPutStr(hdr, HDR_CONTENT_TYPE, ctype);
+        reply->content_type = ctype;
     } else
-	reply->content_type = StringNull;
+        reply->content_type = StringNull;
+
     if (clen >= 0)
-	httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, clen);
+        httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, clen);
+
     if (expires >= 0)
-	httpHeaderPutTime(hdr, HDR_EXPIRES, expires);
+        httpHeaderPutTime(hdr, HDR_EXPIRES, expires);
+
     if (lmt > 0)		/* this used to be lmt != 0 @?@ */
-	httpHeaderPutTime(hdr, HDR_LAST_MODIFIED, lmt);
+        httpHeaderPutTime(hdr, HDR_LAST_MODIFIED, lmt);
+
     reply->date = squid_curtime;
+
     reply->content_length = clen;
+
     reply->expires = expires;
+
     reply->last_modified = lmt;
 }
 
@@ -317,34 +328,44 @@ httpRedirectReply(HttpReply * reply, http_status status, const char *loc)
  * 0 = they do not match
  */
 int
-httpReplyValidatorsMatch(HttpReply const * rep, HttpReply const * otherRep) {
+httpReplyValidatorsMatch(HttpReply const * rep, HttpReply const * otherRep)
+{
     String one,two;
     assert (rep && otherRep);
     /* Numbers first - easiest to check */
     /* Content-Length */
     /* TODO: remove -1 bypass */
+
     if (rep->content_length != otherRep->content_length
-       && rep->content_length > -1 &&
-       otherRep->content_length > -1)
-       return 0;
+            && rep->content_length > -1 &&
+            otherRep->content_length > -1)
+        return 0;
+
     /* ETag */
     one = httpHeaderGetStrOrList(&rep->header, HDR_ETAG);
+
     two = httpHeaderGetStrOrList(&otherRep->header, HDR_ETAG);
+
     if (!one.buf() || !two.buf() || strcasecmp (one.buf(), two.buf())) {
-       one.clean();
-       two.clean();
-       return 0;
+        one.clean();
+        two.clean();
+        return 0;
     }
+
     if (rep->last_modified != otherRep->last_modified)
-       return 0;
+        return 0;
+
     /* MD5 */
     one = httpHeaderGetStrOrList(&rep->header, HDR_CONTENT_MD5);
+
     two = httpHeaderGetStrOrList(&otherRep->header, HDR_CONTENT_MD5);
+
     if (strcasecmp (one.buf(), two.buf())) {
-       one.clean();
-       two.clean();
-       return 0;
+        one.clean();
+        two.clean();
+        return 0;
     }
+
     return 1;
 }
 
@@ -359,7 +380,7 @@ httpReplyUpdateOnNotModified(HttpReply * rep, HttpReply const * freshRep)
     httpReplyHdrCacheClean(rep);
     /* update raw headers */
     httpHeaderUpdate(&rep->header, &freshRep->header,
-	(const HttpHeaderMask *) &Denied304HeadersMask);
+                     (const HttpHeaderMask *) &Denied304HeadersMask);
     /* init cache */
     httpReplyHdrCacheInit(rep);
 }
@@ -378,39 +399,47 @@ static time_t
 httpReplyHdrExpirationTime(const HttpReply * rep)
 {
     /* The s-maxage and max-age directive takes priority over Expires */
+
     if (rep->cache_control) {
-	if (rep->date >= 0) {
-	    if (rep->cache_control->s_maxage >= 0)
-		return rep->date + rep->cache_control->s_maxage;
-	    if (rep->cache_control->max_age >= 0)
-		return rep->date + rep->cache_control->max_age;
-	} else {
-	    /*
-	     * Conservatively handle the case when we have a max-age
-	     * header, but no Date for reference?
-	     */
-	    if (rep->cache_control->s_maxage >= 0)
-		return squid_curtime;
-	    if (rep->cache_control->max_age >= 0)
-		return squid_curtime;
-	}
+        if (rep->date >= 0) {
+            if (rep->cache_control->s_maxage >= 0)
+                return rep->date + rep->cache_control->s_maxage;
+
+            if (rep->cache_control->max_age >= 0)
+                return rep->date + rep->cache_control->max_age;
+        } else {
+            /*
+             * Conservatively handle the case when we have a max-age
+             * header, but no Date for reference?
+             */
+
+            if (rep->cache_control->s_maxage >= 0)
+                return squid_curtime;
+
+            if (rep->cache_control->max_age >= 0)
+                return squid_curtime;
+        }
     }
+
     if (Config.onoff.vary_ignore_expire &&
-	httpHeaderHas(&rep->header, HDR_VARY)) {
-	const time_t d = httpHeaderGetTime(&rep->header, HDR_DATE);
-	const time_t e = httpHeaderGetTime(&rep->header, HDR_EXPIRES);
-	if (d == e)
-	    return -1;
+            httpHeaderHas(&rep->header, HDR_VARY)) {
+        const time_t d = httpHeaderGetTime(&rep->header, HDR_DATE);
+        const time_t e = httpHeaderGetTime(&rep->header, HDR_EXPIRES);
+
+        if (d == e)
+            return -1;
     }
+
     if (httpHeaderHas(&rep->header, HDR_EXPIRES)) {
-	const time_t e = httpHeaderGetTime(&rep->header, HDR_EXPIRES);
-	/*
-	 * HTTP/1.0 says that robust implementations should consider
-	 * bad or malformed Expires header as equivalent to "expires
-	 * immediately."
-	 */
-	return e < 0 ? squid_curtime : e;
+        const time_t e = httpHeaderGetTime(&rep->header, HDR_EXPIRES);
+        /*
+         * HTTP/1.0 says that robust implementations should consider
+         * bad or malformed Expires header as equivalent to "expires
+         * immediately."
+         */
+        return e < 0 ? squid_curtime : e;
     }
+
     return -1;
 }
 
@@ -424,13 +453,18 @@ httpReplyHdrCacheInit(HttpReply * rep)
     rep->date = httpHeaderGetTime(hdr, HDR_DATE);
     rep->last_modified = httpHeaderGetTime(hdr, HDR_LAST_MODIFIED);
     str = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE);
+
     if (str)
-	rep->content_type.limitInit(str, strcspn(str, ";\t "));
+        rep->content_type.limitInit(str, strcspn(str, ";\t "));
     else
-	rep->content_type = StringNull;
+        rep->content_type = StringNull;
+
     rep->cache_control = httpHeaderGetCc(hdr);
+
     rep->content_range = httpHeaderGetContRange(hdr);
+
     rep->keep_alive = httpMsgIsPersistent(rep->sline.version, &rep->header);
+
     /* be sure to set expires after date and cache-control */
     rep->expires = httpReplyHdrExpirationTime(rep);
 }
@@ -440,10 +474,12 @@ static void
 httpReplyHdrCacheClean(HttpReply * rep)
 {
     rep->content_type.clean();
+
     if (rep->cache_control)
-	httpHdrCcDestroy(rep->cache_control);
+        httpHdrCcDestroy(rep->cache_control);
+
     if (rep->content_range)
-	httpHdrContRangeDestroy(rep->content_range);
+        httpHdrContRangeDestroy(rep->content_range);
 }
 
 /*
@@ -464,32 +500,41 @@ httpReplyParseStep(HttpReply * rep, const char *buf, int atEnd)
     assert(rep->pstate < psParsed);
 
     *parse_end_ptr = parse_start;
+
     if (rep->pstate == psReadyToParseStartLine) {
-	if (!httpReplyIsolateStart(&parse_start, &blk_start, &blk_end))
-	    return 0;
-	if (!httpStatusLineParse(&rep->sline, blk_start, blk_end))
-	    return httpReplyParseError(rep);
-
-	*parse_end_ptr = parse_start;
-	rep->hdr_sz = *parse_end_ptr - buf;
-	++rep->pstate;
+        if (!httpReplyIsolateStart(&parse_start, &blk_start, &blk_end))
+            return 0;
+
+        if (!httpStatusLineParse(&rep->sline, blk_start, blk_end))
+            return httpReplyParseError(rep);
+
+        *parse_end_ptr = parse_start;
+
+        rep->hdr_sz = *parse_end_ptr - buf;
+
+        ++rep->pstate;
     }
+
     if (rep->pstate == psReadyToParseHeaders) {
-	if (!httpMsgIsolateHeaders(&parse_start, &blk_start, &blk_end)) {
-	    if (atEnd)
-		blk_start = parse_start, blk_end = blk_start + strlen(blk_start);
-	    else
-		return 0;
-	}
-	if (!httpHeaderParse(&rep->header, blk_start, blk_end))
-	    return httpReplyParseError(rep);
-
-	httpReplyHdrCacheInit(rep);
-
-	*parse_end_ptr = parse_start;
-	rep->hdr_sz = *parse_end_ptr - buf;
-	++rep->pstate;
+        if (!httpMsgIsolateHeaders(&parse_start, &blk_start, &blk_end)) {
+            if (atEnd)
+                blk_start = parse_start, blk_end = blk_start + strlen(blk_start);
+            else
+                return 0;
+        }
+
+        if (!httpHeaderParse(&rep->header, blk_start, blk_end))
+            return httpReplyParseError(rep);
+
+        httpReplyHdrCacheInit(rep);
+
+        *parse_end_ptr = parse_start;
+
+        rep->hdr_sz = *parse_end_ptr - buf;
+
+        ++rep->pstate;
     }
+
     return 1;
 }
 
@@ -510,17 +555,22 @@ static int
 httpReplyIsolateStart(const char **parse_start, const char **blk_start, const char **blk_end)
 {
     int slen = strcspn(*parse_start, "\r\n");
+
     if (!(*parse_start)[slen])	/* no CRLF found */
-	return 0;
+        return 0;
 
     *blk_start = *parse_start;
+
     *blk_end = *blk_start + slen;
+
     while (**blk_end == '\r')	/* CR */
-	(*blk_end)++;
+        (*blk_end)++;
+
     if (**blk_end == '\n')	/* LF */
-	(*blk_end)++;
+        (*blk_end)++;
 
     *parse_start = *blk_end;
+
     return 1;
 }
 
@@ -531,15 +581,16 @@ int
 httpReplyBodySize(method_t method, HttpReply const * reply)
 {
     if (METHOD_HEAD == method)
-	return 0;
+        return 0;
     else if (reply->sline.status == HTTP_OK)
-	(void) 0;		/* common case, continue */
+        (void) 0;		/* common case, continue */
     else if (reply->sline.status == HTTP_NO_CONTENT)
-	return 0;
+        return 0;
     else if (reply->sline.status == HTTP_NOT_MODIFIED)
-	return 0;
+        return 0;
     else if (reply->sline.status < HTTP_OK)
-	return 0;
+        return 0;
+
     return reply->content_length;
 }
 
@@ -552,18 +603,21 @@ httpReplyBodyBuildSize(request_t * request, HttpReply * reply, dlink_list * body
     body_size *bs;
     ACLChecklist *checklist;
     bs = (body_size *) bodylist->head;
+
     while (bs) {
-	checklist = aclChecklistCreate(bs->access_list, request, NULL);
-	checklist->reply = reply;
-	if (1 != aclCheckFast(bs->access_list, checklist)) {
-	    /* deny - skip this entry */
-	    bs = (body_size *) bs->node.next;
-	} else {
-	    /* Allow - use this entry */
-	    reply->maxBodySize = bs->maxsize;
-	    bs = NULL;
-	    debug(58, 3) ("httpReplyBodyBuildSize: Setting maxBodySize to %ld\n", (long int) reply->maxBodySize);
-	}
-	delete checklist;
+        checklist = aclChecklistCreate(bs->access_list, request, NULL);
+        checklist->reply = reply;
+
+        if (1 != aclCheckFast(bs->access_list, checklist)) {
+            /* deny - skip this entry */
+            bs = (body_size *) bs->node.next;
+        } else {
+            /* Allow - use this entry */
+            reply->maxBodySize = bs->maxsize;
+            bs = NULL;
+            debug(58, 3) ("httpReplyBodyBuildSize: Setting maxBodySize to %ld\n", (long int) reply->maxBodySize);
+        }
+
+        delete checklist;
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpReply.h,v 1.1 2003/01/23 00:37:13 robertc Exp $
+ * $Id: HttpReply.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -56,10 +56,10 @@ extern MemBuf httpReplyPack(const HttpReply * rep);
 extern void httpReplySwapOut(HttpReply * rep, StoreEntry * e);
 /* set commonly used info with one call */
 extern void httpReplySetHeaders(HttpReply * rep, http_version_t ver, http_status status,
-    const char *reason, const char *ctype, int clen, time_t lmt, time_t expires);
+                                    const char *reason, const char *ctype, int clen, time_t lmt, time_t expires);
 /* do everything in one call: init, set, pack, clean, return MemBuf */
 extern MemBuf httpPackedReply(http_version_t ver, http_status status, const char *ctype,
-    int clen, time_t lmt, time_t expires);
+                                  int clen, time_t lmt, time_t expires);
 /* construct 304 reply and pack it into MemBuf, return MemBuf */
 extern MemBuf httpPacked304Reply(const HttpReply * rep);
 /* construct a 304 reply and return it */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpRequest.cc,v 1.34 2003/02/12 06:10:58 robertc Exp $
+ * $Id: HttpRequest.cc,v 1.35 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 73    HTTP Request
  * AUTHOR: Duane Wessels
@@ -46,33 +46,50 @@ requestCreate(method_t method, protocol_t protocol, const char *aUrlpath)
     request_t *req = static_cast<request_t *>(memAllocate(MEM_REQUEST_T));
     req->method = method;
     req->protocol = protocol;
+
     if (aUrlpath)
-	req->urlpath = aUrlpath;
+        req->urlpath = aUrlpath;
+
     req->max_forwards = -1;
+
     req->lastmod = -1;
+
     req->client_addr = no_addr;
+
     req->my_addr = no_addr;
+
     httpHeaderInit(&req->header, hoRequest);
+
     httpRequestHdrCacheInit(req);
+
     return req;
 }
 
 void
 requestDestroy(request_t * req)
 {
     assert(req);
+
     if (req->body_connection)
-	clientAbortBody(req);
+        clientAbortBody(req);
+
     if (req->auth_user_request)
-	authenticateAuthUserRequestUnlock(req->auth_user_request);
+        authenticateAuthUserRequestUnlock(req->auth_user_request);
+
     safe_free(req->canonical);
+
     safe_free(req->vary_headers);
+
     req->urlpath.clean();
+
     httpHeaderClean(&req->header);
+
     if (req->cache_control)
-	httpHdrCcDestroy(req->cache_control);
+        httpHdrCcDestroy(req->cache_control);
+
     if (req->range)
-	req->range->deleteSelf();
+        req->range->deleteSelf();
+
     memFree(req, MEM_REQUEST_T);
 }
 
@@ -88,22 +105,29 @@ void
 requestUnlink(request_t * request)
 {
     if (!request)
-	return;
+        return;
+
     assert(request->link_count > 0);
+
     if (--request->link_count > 0)
-	return;
+        return;
+
     requestDestroy(request);
 }
 
 int
 httpRequestParseHeader(request_t * req, const char *parse_start)
 {
     const char *blk_start, *blk_end;
+
     if (!httpMsgIsolateHeaders(&parse_start, &blk_start, &blk_end))
-	return 0;
+        return 0;
+
     int result = httpHeaderParse(&req->header, blk_start, blk_end);
+
     if (result)
-	httpRequestHdrCacheInit(req);
+        httpRequestHdrCacheInit(req);
+
     return result;
 }
 
@@ -125,7 +149,7 @@ httpRequestPack(const request_t * req, Packer * p)
     assert(req && p);
     /* pack request-line */
     packerPrintf(p, "%s %s HTTP/1.0\r\n",
-	RequestMethodStr[req->method], req->urlpath.buf());
+                 RequestMethodStr[req->method], req->urlpath.buf());
     /* headers */
     httpHeaderPackInto(&req->header, p);
     /* trailer */
@@ -149,9 +173,9 @@ httpRequestPrefixLen(const request_t * req)
 {
     assert(req);
     return strlen(RequestMethodStr[req->method]) + 1 +
-	req->urlpath.size() + 1 +
-	4 + 1 + 3 + 2 +
-	req->header.len + 2;
+           req->urlpath.size() + 1 +
+           4 + 1 + 3 + 2 +
+           req->header.len + 2;
 }
 
 /*
@@ -163,8 +187,10 @@ httpRequestHdrAllowed(const HttpHeaderEntry * e, String * strConn)
 {
     assert(e);
     /* check connection header */
+
     if (strConn && strListIsMember(strConn, e->name.buf(), ','))
-	return 0;
+        return 0;
+
     return 1;
 }
 
@@ -173,25 +199,33 @@ static void
 httpRequestHdrCacheInit(request_t * req)
 {
     const HttpHeader *hdr = &req->header;
-/*  const char *str; */
+    /*  const char *str; */
     req->content_length = httpHeaderGetInt(hdr, HDR_CONTENT_LENGTH);
     /* TODO: canonicalise these into an HttpEntity */
 #if 0
+
     req->date = httpHeaderGetTime(hdr, HDR_DATE);
     req->last_modified = httpHeaderGetTime(hdr, HDR_LAST_MODIFIED);
     str = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE);
+
     if (str)
-       stringLimitInit(&req->content_type, str, strcspn(str, ";\t "));
+        stringLimitInit(&req->content_type, str, strcspn(str, ";\t "));
     else
-       req->content_type = StringNull;
+        req->content_type = StringNull;
+
 #endif
+
     req->cache_control = httpHeaderGetCc(hdr);
+
     req->range = httpHeaderGetRange(hdr);
+
 #if 0
+
     req->keep_alive = httpMsgIsPersistent(req->http_ver, &req->header);
 
     /* be sure to set expires after date and cache-control */
     req->expires = httpReplyHdrExpirationTime(req);
+
 #endif
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpStatusLine.cc,v 1.26 2003/01/23 00:37:13 robertc Exp $
+ * $Id: HttpStatusLine.cc,v 1.27 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 57    HTTP Status-line
  * AUTHOR: Alex Rousskov
@@ -73,10 +73,10 @@ httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p)
     assert(sline && p);
     debug(57, 9) ("packing sline %p using %p:\n", sline, p);
     debug(57, 9) (HttpStatusLineFormat, sline->version.major,
-	sline->version.minor, sline->status,
-	sline->reason ? sline->reason : httpStatusString(sline->status));
+                  sline->version.minor, sline->status,
+                  sline->reason ? sline->reason : httpStatusString(sline->status));
     packerPrintf(p, HttpStatusLineFormat, sline->version.major,
-	sline->version.minor, sline->status, httpStatusLineReason(sline));
+                 sline->version.minor, sline->status, httpStatusLineReason(sline));
 }
 
 /* pack fields using Packer */
@@ -85,17 +85,24 @@ httpStatusLineParse(HttpStatusLine * sline, const char *start, const char *end)
 {
     assert(sline);
     sline->status = HTTP_INVALID_HEADER;	/* Squid header parsing error */
+
     if (strncasecmp(start, "HTTP/", 5))
-	return 0;
+        return 0;
+
     start += 5;
+
     if (!xisdigit(*start))
-	return 0;
+        return 0;
+
     if (sscanf(start, "%d.%d", &sline->version.major, &sline->version.minor) != 2) {
-	debug(57, 7) ("httpStatusLineParse: Invalid HTTP identifier.\n");
+        debug(57, 7) ("httpStatusLineParse: Invalid HTTP identifier.\n");
     }
+
     if (!(start = strchr(start, ' ')))
-	return 0;
+        return 0;
+
     sline->status = (http_status) atoi(++start);
+
     /* we ignore 'reason-phrase' */
     return 1;			/* success */
 }
@@ -112,128 +119,170 @@ httpStatusString(http_status status)
 {
     /* why not to return matching string instead of using "p" ? @?@ */
     const char *p = NULL;
+
     switch (status) {
+
     case 0:
-	p = "Init";		/* we init .status with code 0 */
-	break;
+        p = "Init";		/* we init .status with code 0 */
+        break;
+
     case HTTP_CONTINUE:
-	p = "Continue";
-	break;
+        p = "Continue";
+        break;
+
     case HTTP_SWITCHING_PROTOCOLS:
-	p = "Switching Protocols";
-	break;
+        p = "Switching Protocols";
+        break;
+
     case HTTP_OK:
-	p = "OK";
-	break;
+        p = "OK";
+        break;
+
     case HTTP_CREATED:
-	p = "Created";
-	break;
+        p = "Created";
+        break;
+
     case HTTP_ACCEPTED:
-	p = "Accepted";
-	break;
+        p = "Accepted";
+        break;
+
     case HTTP_NON_AUTHORITATIVE_INFORMATION:
-	p = "Non-Authoritative Information";
-	break;
+        p = "Non-Authoritative Information";
+        break;
+
     case HTTP_NO_CONTENT:
-	p = "No Content";
-	break;
+        p = "No Content";
+        break;
+
     case HTTP_RESET_CONTENT:
-	p = "Reset Content";
-	break;
+        p = "Reset Content";
+        break;
+
     case HTTP_PARTIAL_CONTENT:
-	p = "Partial Content";
-	break;
+        p = "Partial Content";
+        break;
+
     case HTTP_MULTIPLE_CHOICES:
-	p = "Multiple Choices";
-	break;
+        p = "Multiple Choices";
+        break;
+
     case HTTP_MOVED_PERMANENTLY:
-	p = "Moved Permanently";
-	break;
+        p = "Moved Permanently";
+        break;
+
     case HTTP_MOVED_TEMPORARILY:
-	p = "Moved Temporarily";
-	break;
+        p = "Moved Temporarily";
+        break;
+
     case HTTP_SEE_OTHER:
-	p = "See Other";
-	break;
+        p = "See Other";
+        break;
+
     case HTTP_NOT_MODIFIED:
-	p = "Not Modified";
-	break;
+        p = "Not Modified";
+        break;
+
     case HTTP_USE_PROXY:
-	p = "Use Proxy";
-	break;
+        p = "Use Proxy";
+        break;
+
     case HTTP_TEMPORARY_REDIRECT:
-	p = "Temporary Redirect";
-	break;
+        p = "Temporary Redirect";
+        break;
+
     case HTTP_BAD_REQUEST:
-	p = "Bad Request";
-	break;
+        p = "Bad Request";
+        break;
+
     case HTTP_UNAUTHORIZED:
-	p = "Unauthorized";
-	break;
+        p = "Unauthorized";
+        break;
+
     case HTTP_PAYMENT_REQUIRED:
-	p = "Payment Required";
-	break;
+        p = "Payment Required";
+        break;
+
     case HTTP_FORBIDDEN:
-	p = "Forbidden";
-	break;
+        p = "Forbidden";
+        break;
+
     case HTTP_NOT_FOUND:
-	p = "Not Found";
-	break;
+        p = "Not Found";
+        break;
+
     case HTTP_METHOD_NOT_ALLOWED:
-	p = "Method Not Allowed";
-	break;
+        p = "Method Not Allowed";
+        break;
+
     case HTTP_NOT_ACCEPTABLE:
-	p = "Not Acceptable";
-	break;
+        p = "Not Acceptable";
+        break;
+
     case HTTP_PROXY_AUTHENTICATION_REQUIRED:
-	p = "Proxy Authentication Required";
-	break;
+        p = "Proxy Authentication Required";
+        break;
+
     case HTTP_REQUEST_TIMEOUT:
-	p = "Request Time-out";
-	break;
+        p = "Request Time-out";
+        break;
+
     case HTTP_CONFLICT:
-	p = "Conflict";
-	break;
+        p = "Conflict";
+        break;
+
     case HTTP_GONE:
-	p = "Gone";
-	break;
+        p = "Gone";
+        break;
+
     case HTTP_LENGTH_REQUIRED:
-	p = "Length Required";
-	break;
+        p = "Length Required";
+        break;
+
     case HTTP_PRECONDITION_FAILED:
-	p = "Precondition Failed";
-	break;
+        p = "Precondition Failed";
+        break;
+
     case HTTP_REQUEST_ENTITY_TOO_LARGE:
-	p = "Request Entity Too Large";
-	break;
+        p = "Request Entity Too Large";
+        break;
+
     case HTTP_REQUEST_URI_TOO_LARGE:
-	p = "Request-URI Too Large";
-	break;
+        p = "Request-URI Too Large";
+        break;
+
     case HTTP_UNSUPPORTED_MEDIA_TYPE:
-	p = "Unsupported Media Type";
-	break;
+        p = "Unsupported Media Type";
+        break;
+
     case HTTP_INTERNAL_SERVER_ERROR:
-	p = "Internal Server Error";
-	break;
+        p = "Internal Server Error";
+        break;
+
     case HTTP_NOT_IMPLEMENTED:
-	p = "Not Implemented";
-	break;
+        p = "Not Implemented";
+        break;
+
     case HTTP_BAD_GATEWAY:
-	p = "Bad Gateway";
-	break;
+        p = "Bad Gateway";
+        break;
+
     case HTTP_SERVICE_UNAVAILABLE:
-	p = "Service Unavailable";
-	break;
+        p = "Service Unavailable";
+        break;
+
     case HTTP_GATEWAY_TIMEOUT:
-	p = "Gateway Time-out";
-	break;
+        p = "Gateway Time-out";
+        break;
+
     case HTTP_HTTP_VERSION_NOT_SUPPORTED:
-	p = "HTTP Version not supported";
-	break;
+        p = "HTTP Version not supported";
+        break;
+
     default:
-	p = "Unknown";
-	debug(57, 3) ("Unknown HTTP status code: %d\n", status);
-	break;
+        p = "Unknown";
+        debug(57, 3) ("Unknown HTTP status code: %d\n", status);
+        break;
     }
+
     return p;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ICP.h,v 1.3 2003/01/23 00:37:13 robertc Exp $
+ * $Id: ICP.h,v 1.4 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,7 +40,9 @@
  * DO NOT add ore move fields on pain of breakage.
  * DO NOT add virtual methods.
  */
-struct _icp_common_t {
+
+struct _icp_common_t
+{
     unsigned char opcode;	/* opcode */
     unsigned char version;	/* version number */
     unsigned short length;	/* total length (bytes) */
@@ -49,8 +51,10 @@ struct _icp_common_t {
     u_int32_t pad;
     u_int32_t shostid;		/* sender host id */
 #ifdef __cplusplus
-              _icp_common_t();
-              _icp_common_t(char *buf, unsigned int len);
+
+    _icp_common_t();
+    _icp_common_t(char *buf, unsigned int len);
+
     void handleReply(char *buf, struct sockaddr_in *from);
     static _icp_common_t *createMessage(icp_opcode opcode, int flags, const char *url, int reqnum, int pad);
     icp_opcode getOpCode() const;
@@ -59,51 +63,67 @@ struct _icp_common_t {
 
 #ifdef __cplusplus
 
-inline icp_opcode & operator++ (icp_opcode & aCode) {
+inline icp_opcode & operator++ (icp_opcode & aCode)
+{
     aCode = (icp_opcode) (++(int) aCode);
     return aCode;
 }
 
 
 /* todo: mempool this */
-class ICPState {
-    public:
+
+class ICPState
+{
+
+public:
     ICPState(icp_common_t &);
     virtual ~ ICPState();
     icp_common_t header;
     request_t *request;
     int fd;
+
     struct sockaddr_in from;
     char *url;
 };
 
 #endif
 
 typedef struct _icpUdpData icpUdpData;
-struct _icpUdpData {
+
+struct _icpUdpData
+{
+
     struct sockaddr_in address;
     void *msg;
     size_t len;
     icpUdpData *next;
 #ifndef LESS_TIMING
+
     struct timeval start;
 #endif
+
     log_type logcode;
+
     struct timeval queue_time;
 };
 
 
 request_t *
-          icpGetRequest(char *url, int reqnum, int fd, struct sockaddr_in *from);
+
+icpGetRequest(char *url, int reqnum, int fd, struct sockaddr_in *from);
+
 int icpAccessAllowed(struct sockaddr_in *from, request_t * icp_request);
+
 SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const struct sockaddr_in *from);
 extern icp_opcode icpGetCommonOpcode();
 
 SQUIDCEXTERN int icpUdpSend(int, const struct sockaddr_in *, icp_common_t *, log_type, int);
 SQUIDCEXTERN log_type icpLogFromICPCode(icp_opcode opcode);
+
 void icpDenyAccess(struct sockaddr_in *from, char *url, int reqnum, int fd);
 SQUIDCEXTERN PF icpHandleUdp;
 SQUIDCEXTERN PF icpUdpSendQueue;
+
 SQUIDCEXTERN void icpHandleIcpV3(int, struct sockaddr_in, char *, int);
 SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, request_t * request);
 SQUIDCEXTERN void icpConnectionsOpen(void);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: IPInterception.cc,v 1.5 2003/02/21 19:53:01 hno Exp $
+ * $Id: IPInterception.cc,v 1.6 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 89    NAT / IP Interception 
  * AUTHOR: Robert Collins
@@ -80,8 +80,10 @@
 
 #if IPF_TRANSPARENT
 int
+
 clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct sockaddr_in *dst)
 {
+
     struct natlookup natLookup;
     static int natfd = -1;
     static int siocgnatl_cmd = SIOCGNATL & 0xff;
@@ -92,79 +94,108 @@ clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct s
     natLookup.nl_inip = me.sin_addr;
     natLookup.nl_outip = peer.sin_addr;
     natLookup.nl_flags = IPN_TCP;
-    if (natfd < 0) {
-	int save_errno;
-	enter_suid();
-	natfd = open(IPL_NAT, O_RDONLY, 0);
-	save_errno = errno;
-	leave_suid();
-	errno = save_errno;
+
+    if (natfd < 0)
+    {
+        int save_errno;
+        enter_suid();
+        natfd = open(IPL_NAT, O_RDONLY, 0);
+        save_errno = errno;
+        leave_suid();
+        errno = save_errno;
     }
-    if (natfd < 0) {
-	debug(50, 1) ("parseHttpRequest: NAT open failed: %s\n",
-	    xstrerror());
-	return -1;
+
+    if (natfd < 0)
+    {
+        debug(50, 1) ("parseHttpRequest: NAT open failed: %s\n",
+                      xstrerror());
+        return -1;
     }
+
     /*
      * IP-Filter changed the type for SIOCGNATL between
      * 3.3 and 3.4.  It also changed the cmd value for
      * SIOCGNATL, so at least we can detect it.  We could
      * put something in configure and use ifdefs here, but
      * this seems simpler.
      */
-    if (63 == siocgnatl_cmd) {
-	struct natlookup *nlp = &natLookup;
-	x = ioctl(natfd, SIOCGNATL, &nlp);
-    } else {
-	x = ioctl(natfd, SIOCGNATL, &natLookup);
+    if (63 == siocgnatl_cmd)
+    {
+
+        struct natlookup *nlp = &natLookup;
+        x = ioctl(natfd, SIOCGNATL, &nlp);
+    } else
+    {
+        x = ioctl(natfd, SIOCGNATL, &natLookup);
+    }
+
+    if (x < 0)
+    {
+        if (errno != ESRCH) {
+            debug(50, 1) ("parseHttpRequest: NAT lookup failed: ioctl(SIOCGNATL)\n");
+            close(natfd);
+            natfd = -1;
+        }
+
+        return -1;
+    } else
+    {
+        if (me.sin_addr.s_addr != natLookup.nl_realip.s_addr)
+            dst->sin_family = AF_INET;
+
+        dst->sin_port = natLookup.nl_realport;
+
+        dst->sin_addr = natLookup.nl_realip;
+
+        return 0;
     }
-    if (x < 0) {
-	if (errno != ESRCH) {
-	    debug(50, 1) ("parseHttpRequest: NAT lookup failed: ioctl(SIOCGNATL)\n");
-	    close(natfd);
-	    natfd = -1;
-	}
-	return -1;
-    } else {
-	if (me.sin_addr.s_addr != natLookup.nl_realip.s_addr)
-	    dst->sin_family = AF_INET;
-	    dst->sin_port = natLookup.nl_realport;
-	    dst->sin_addr = natLookup.nl_realip;
-	    return 0;
-	} else {
-	    return -1;
-	}
+    else
+    {
+        return -1;
     }
 }
+}
+
 #elif LINUX_NETFILTER
 int
+
 clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct sockaddr_in *dst)
 {
     size_t sock_sz = sizeof(*dst);
     memcpy(dst, &me, sizeof(*dst));
+
     if (getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, dst, &sock_sz) != 0)
-	return -1;
+        return -1;
 
     debug(33, 5) ("clientNatLookup: addr = %s", inet_ntoa(dst->sin_addr));
+
     if (me.sin_addr.s_addr != dst->sin_addr.s_addr)
-	return 0;
+        return 0;
     else
-	return -1;
+        return -1;
 }
+
 #elif PF_TRANSPARENT
 int
+
 clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct sockaddr_in *dst)
 {
+
     struct pfioc_natlook nl;
     static int pffd = -1;
+
+    if (pffd < 0)
+        pffd = open("/dev/pf", O_RDWR);
+
     if (pffd < 0)
-	pffd = open("/dev/pf", O_RDWR);
-    if (pffd < 0) {
-	debug(50, 1) ("parseHttpRequest: PF open failed: %s\n",
-	    xstrerror());
-	return -1;
+    {
+        debug(50, 1) ("parseHttpRequest: PF open failed: %s\n",
+                      xstrerror());
+        return -1;
     }
+
     memset(dst, 0, sizeof(*dst));
+
     memset(&nl, 0, sizeof(struct pfioc_natlook));
     nl.saddr.v4.s_addr = peer.sin_addr.s_addr;
     nl.sport = peer.sin_port;
@@ -173,30 +204,38 @@ clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct s
     nl.af = AF_INET;
     nl.proto = IPPROTO_TCP;
     nl.direction = PF_OUT;
-    if (ioctl(pffd, DIOCNATLOOK, &nl)) {
-	if (errno != ENOENT) {
-	    debug(50, 1) ("parseHttpRequest: PF lookup failed: ioctl(DIOCNATLOOK)\n");
-	    close(pffd);
-	    pffd = -1;
-	}
-	return -1;
-    } else {
-	int natted = me.sin_addr.s_addr != nt.rdaddr.v4.s_addr;
-	dst->sin_family = AF_INET;
-	dst->sin_port = nl.rdport;
-	dst->sin_addr = nl.rdaddr.v4;
-	if (natted)
-	    return 0;
-	else
-	    return -1;
+
+    if (ioctl(pffd, DIOCNATLOOK, &nl))
+    {
+        if (errno != ENOENT) {
+            debug(50, 1) ("parseHttpRequest: PF lookup failed: ioctl(DIOCNATLOOK)\n");
+            close(pffd);
+            pffd = -1;
+        }
+
+        return -1;
+    } else
+    {
+        int natted = me.sin_addr.s_addr != nt.rdaddr.v4.s_addr;
+        dst->sin_family = AF_INET;
+        dst->sin_port = nl.rdport;
+        dst->sin_addr = nl.rdaddr.v4;
+
+        if (natted)
+            return 0;
+        else
+            return -1;
     }
 }
+
 #else
 int
+
 clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct sockaddr_in *dst)
 {
     debug(33, 1) ("WARNING: transparent proxying not supported\n");
     return -1;
 }
+
 #endif
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: IPInterception.h,v 1.5 2003/02/21 19:53:01 hno Exp $
+ * $Id: IPInterception.h,v 1.6 2003/02/21 22:50:05 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,6 +35,7 @@
 #define SQUID_IPINTERCEPTION_H
 
 SQUIDCEXTERN int
+
 clientNatLookup(int fd, struct sockaddr_in me, struct sockaddr_in peer, struct sockaddr_in *dst);
 
 #endif /* SQUID_IPINTERCEPTION_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Mem.h,v 1.1 2003/01/23 00:37:14 robertc Exp $
+ * $Id: Mem.h,v 1.2 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -36,13 +36,15 @@
 #ifndef SQUID_MEM
 #define SQUID_MEM
 
-class Mem {
+class Mem
+{
+
 public:
-  static void Init();
-  static void Stats(StoreEntry *);
-  static void CleanIdlePools(void *unused);
-  static void Report(StoreEntry *);
-  static void PoolReport(const MemPoolStats * mp_st, const MemPoolMeter * AllMeter, StoreEntry * e);
+    static void Init();
+    static void Stats(StoreEntry *);
+    static void CleanIdlePools(void *unused);
+    static void Report(StoreEntry *);
+    static void PoolReport(const MemPoolStats * mp_st, const MemPoolMeter * AllMeter, StoreEntry * e);
 };
 
 #endif /* SQUID_MEM */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: MemBuf.cc,v 1.33 2003/01/23 00:37:14 robertc Exp $
+ * $Id: MemBuf.cc,v 1.34 2003/02/21 22:50:05 robertc Exp $
  *
  * DEBUG: section 59    auto-growing Memory Buffer with printf
  * AUTHOR: Alex Rousskov
@@ -152,20 +152,20 @@ memBufClean(MemBuf * mb)
     mb->size = mb->capacity = 0;
 }
 
-/* cleans the buffer without changing its capacity 
+/* cleans the buffer without changing its capacity
  * if called with a Null buffer, calls memBufDefInit() */
 void
 memBufReset(MemBuf * mb)
 {
     assert(mb);
 
     if (memBufIsNull(mb)) {
-	memBufDefInit(mb);
+        memBufDefInit(mb);
     } else {
-	assert(!mb->stolen);	/* not frozen */
-	/* reset */
-	memset(mb->buf, 0, mb->capacity);
-	mb->size = 0;
+        assert(!mb->stolen);	/* not frozen */
+        /* reset */
+        memset(mb->buf, 0, mb->capacity);
+        mb->size = 0;
     }
 }
 
@@ -174,9 +174,12 @@ int
 memBufIsNull(MemBuf * mb)
 {
     assert(mb);
+
     if (!mb->buf && !mb->max_capacity && !mb->capacity && !mb->size)
-	return 1;		/* is null (not initialized) */
+        return 1;		/* is null (not initialized) */
+
     assert(mb->buf && mb->max_capacity && mb->capacity);	/* paranoid */
+
     return 0;
 }
 
@@ -190,12 +193,16 @@ memBufAppend(MemBuf * mb, const char *buf, mb_size_t sz)
     assert(!mb->stolen);	/* not frozen */
 
     if (sz > 0) {
-	if (mb->size + sz + 1 > mb->capacity)
-	    memBufGrow(mb, mb->size + sz + 1);
-	assert(mb->size + sz <= mb->capacity);	/* paranoid */
-	xmemcpy(mb->buf + mb->size, buf, sz);
-	mb->size += sz;
-	mb->buf[mb->size] = '\0';	/* \0 terminate in case we are used as a string. Not counted in the size */
+        if (mb->size + sz + 1 > mb->capacity)
+            memBufGrow(mb, mb->size + sz + 1);
+
+        assert(mb->size + sz <= mb->capacity);	/* paranoid */
+
+        xmemcpy(mb->buf + mb->size, buf, sz);
+
+        mb->size += sz;
+
+        mb->buf[mb->size] = '\0';	/* \0 terminate in case we are used as a string. Not counted in the size */
     }
 }
 
@@ -209,7 +216,7 @@ memBufPrintf(MemBuf * mb, const char *fmt,...)
 #else
 void
 memBufPrintf(va_alist)
-     va_dcl
+va_dcl
 {
     va_list args;
     MemBuf *mb = NULL;
@@ -219,40 +226,44 @@ memBufPrintf(va_alist)
     mb = va_arg(args, MemBuf *);
     fmt = va_arg(args, char *);
 #endif
+
     memBufVPrintf(mb, fmt, args);
     va_end(args);
 }
 
 
 /* vprintf for other printf()'s to use; calls vsnprintf, extends buf if needed */
 void
-memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs)
-{
+memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs) {
     int sz = 0;
     assert(mb && fmt);
     assert(mb->buf);
     assert(!mb->stolen);	/* not frozen */
     /* assert in Grow should quit first, but we do not want to have a scary infinite loop */
+
     while (mb->capacity <= mb->max_capacity) {
-	mb_size_t free_space = mb->capacity - mb->size;
-	/* put as much as we can */
-	sz = vsnprintf(mb->buf + mb->size, free_space, fmt, vargs);
-	/* check for possible overflow */
-	/* snprintf on Linuz returns -1 on overflows */
-	/* snprintf on FreeBSD returns at least free_space on overflows */
-	if (sz < 0 || sz >= free_space)
-	    memBufGrow(mb, mb->capacity + 1);
-	else
-	    break;
+        mb_size_t free_space = mb->capacity - mb->size;
+        /* put as much as we can */
+        sz = vsnprintf(mb->buf + mb->size, free_space, fmt, vargs);
+        /* check for possible overflow */
+        /* snprintf on Linuz returns -1 on overflows */
+        /* snprintf on FreeBSD returns at least free_space on overflows */
+
+        if (sz < 0 || sz >= free_space)
+            memBufGrow(mb, mb->capacity + 1);
+        else
+            break;
     }
+
     mb->size += sz;
     /* on Linux and FreeBSD, '\0' is not counted in return value */
     /* on XXX it might be counted */
     /* check that '\0' is appended and not counted */
+
     if (!mb->size || mb->buf[mb->size - 1]) {
-	assert(!mb->buf[mb->size]);
+        assert(!mb->buf[mb->size]);
     } else {
-	mb->size--;
+        mb->size--;
     }
 }
 
@@ -264,8 +275,7 @@ memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs)
  *   (you still can read-access .buf and .size)
  */
 FREE *
-memBufFreeFunc(MemBuf * mb)
-{
+memBufFreeFunc(MemBuf * mb) {
     FREE *ff;
     assert(mb);
     assert(mb->buf);
@@ -278,8 +288,7 @@ memBufFreeFunc(MemBuf * mb)
 
 /* grows (doubles) internal buffer to satisfy required minimal capacity */
 static void
-memBufGrow(MemBuf * mb, mb_size_t min_cap)
-{
+memBufGrow(MemBuf * mb, mb_size_t min_cap) {
     size_t new_cap;
     size_t buf_cap;
 
@@ -288,22 +297,26 @@ memBufGrow(MemBuf * mb, mb_size_t min_cap)
     assert(mb->capacity < min_cap);
 
     /* determine next capacity */
+
     if (min_cap > 64 * 1024) {
-	new_cap = 64 * 1024;
-	while (new_cap < (size_t) min_cap)
-	    new_cap += 64 * 1024;	/* increase in reasonable steps */
+        new_cap = 64 * 1024;
+
+        while (new_cap < (size_t) min_cap)
+            new_cap += 64 * 1024;	/* increase in reasonable steps */
     } else {
-	new_cap = (size_t) min_cap;
+        new_cap = (size_t) min_cap;
     }
 
     /* last chance to fit before we assert(!overflow) */
     if (new_cap > (size_t) mb->max_capacity)
-	new_cap = (size_t) mb->max_capacity;
+        new_cap = (size_t) mb->max_capacity;
 
     assert(new_cap <= (size_t) mb->max_capacity);	/* no overflow */
+
     assert(new_cap > (size_t) mb->capacity);	/* progress */
 
     buf_cap = (size_t) mb->capacity;
+
     mb->buf = (char *)memReallocBuf(mb->buf, new_cap, &buf_cap);
 
     /* done */
@@ -315,8 +328,7 @@ memBufGrow(MemBuf * mb, mb_size_t min_cap)
 
 /* puts report on MemBuf _module_ usage into mb */
 void
-memBufReport(MemBuf * mb)
-{
+memBufReport(MemBuf * mb) {
     assert(mb);
     memBufPrintf(mb, "memBufReport is not yet implemented @?@\n");
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: MemBuf.h,v 1.1 2003/01/23 00:37:14 robertc Exp $
+ * $Id: MemBuf.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,8 +36,11 @@
 
 /* auto-growing memory-resident buffer with printf interface */
 /* note: when updating this struct, update MemBufNULL #define */
-class MemBuf {
-  public:
+
+class MemBuf
+{
+
+public:
     _SQUID_INLINE_ MemBuf();
     /* public, read-only */
     char *buf;
@@ -46,7 +49,9 @@ class MemBuf {
     /* private, stay away; use interface function instead */
     mb_size_t max_capacity;	/* when grows: assert(new_capacity <= max_capacity) */
     mb_size_t capacity;		/* allocated space */
-    unsigned stolen:1;		/* the buffer has been stolen for use by someone else */
+
+unsigned stolen:
+    1;		/* the buffer has been stolen for use by someone else */
 };
 
 /* to initialize static variables (see also MemBufNull) */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: MemObject.cc,v 1.4 2003/02/13 22:20:37 robertc Exp $
+ * $Id: MemObject.cc,v 1.5 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 19    Store Memory Primitives
  * AUTHOR: Robert Collins
@@ -59,6 +59,7 @@ url_checksum(const char *url)
     xmemcpy(&ck, digest, sizeof(ck));
     return ck;
 }
+
 #endif
 
 MemPool *MemObject::pool = NULL;
@@ -68,8 +69,10 @@ MemObject::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (MemObject));
+
     if (!pool)
-	pool = memPoolCreate("MemObject", sizeof (MemObject));
+        pool = memPoolCreate("MemObject", sizeof (MemObject));
+
     return memPoolAlloc(pool);
 }
 
@@ -83,19 +86,24 @@ size_t
 MemObject::inUseCount()
 {
     if (!pool)
-	return 0;
+        return 0;
+
     MemPoolStats stats;
+
     memPoolGetStats (&stats, pool);
+
     return stats.items_inuse;
 }
 
 MemObject::MemObject(char const *aUrl, char const *aLog_url) :
-_reply (httpReplyCreate())
+        _reply (httpReplyCreate())
 {
     url = xstrdup(aUrl);
 #if URL_CHECKSUM_DEBUG
+
     chksum = url_checksum(url);
 #endif
+
     log_url = xstrdup(aLog_url);
     object_sz = -1;
     fd = -1;
@@ -108,22 +116,33 @@ MemObject::~MemObject()
     const Ctx ctx = ctx_enter(url);
     debug(20, 3) ("destroy_MemObject: destroying %p\n", this);
 #if URL_CHECKSUM_DEBUG
+
     assert(chksum == url_checksum(url));
 #endif
+
     if (!shutting_down)
         assert(swapout.sio == NULL);
+
     data_hdr.freeContent();
+
     /*
      * There is no way to abort FD-less clients, so they might
      * still have mem->clients set if mem->fd == -1
      */
     assert(fd == -1 || clients.head == NULL);
+
     httpReplyDestroy((HttpReply *)_reply);
+
     requestUnlink(request);
+
     request = NULL;
+
     ctx_exit(ctx);              /* must exit before we free mem->url */
+
     safe_free(url);
+
     safe_free(log_url);    /* XXX account log_url */
+
     safe_free(vary_headers);
 }
 
@@ -156,30 +175,31 @@ void
 MemObject::dump() const
 {
     debug(20, 1) ("MemObject->data.head: %p\n",
-	data_hdr.head);
+                  data_hdr.head);
     debug(20, 1) ("MemObject->data.tail: %p\n",
-	data_hdr.tail);
+                  data_hdr.tail);
 #if 0
     /* do we want this one? */
     debug(20, 1) ("MemObject->data.origin_offset: %d\n",
-	data_hdr.head ? data_hdr.head->nodeBuffer.offset : 0);
+                  data_hdr.head ? data_hdr.head->nodeBuffer.offset : 0);
 #endif
+
     debug(20, 1) ("MemObject->start_ping: %d.%06d\n",
-	(int) start_ping.tv_sec,
-	(int) start_ping.tv_usec);
+                  (int) start_ping.tv_sec,
+                  (int) start_ping.tv_usec);
     debug(20, 1) ("MemObject->inmem_hi: %d\n",
-	(int) data_hdr.endOffset());
+                  (int) data_hdr.endOffset());
     debug(20, 1) ("MemObject->inmem_lo: %d\n",
-	(int) inmem_lo);
+                  (int) inmem_lo);
     debug(20, 1) ("MemObject->nclients: %d\n",
-	nclients);
+                  nclients);
     debug(20, 1) ("MemObject->reply: %p\n",
-	_reply);
+                  _reply);
     debug(20, 1) ("MemObject->request: %p\n",
-	request);
+                  request);
     debug(20, 1) ("MemObject->log_url: %p %s\n",
-	log_url,
-	checkNullString(log_url));
+                  log_url,
+                  checkNullString(log_url));
 }
 
 HttpReply const *
@@ -191,19 +211,25 @@ MemObject::getReply() const
 struct LowestMemReader : public unary_function<store_client, void>
 {
     LowestMemReader(off_t seed):current(seed){}
-    void operator() (store_client const &x) 
-      { 
-	if (x.memReaderHasLowerOffset(current))
-	    current = x.copyInto.offset; }
+
+    void operator() (store_client const &x)
+    {
+        if (x.memReaderHasLowerOffset(current))
+            current = x.copyInto.offset;
+    }
+
     off_t current;
 };
 
 struct StoreClientStats : public unary_function<store_client, void>
 {
     StoreClientStats(StoreEntry *anEntry):where(anEntry),index(0){}
-    void operator()(store_client const &x) {
-	x.dumpStats(where, index++);
+
+    void operator()(store_client const &x)
+    {
+        x.dumpStats(where, index++);
     }
+
     StoreEntry *where;
     size_t index;
 };
@@ -212,15 +238,18 @@ void
 MemObject::stat (StoreEntry *s) const
 {
     storeAppendPrintf(s, "\t%s %s\n",
-	RequestMethodStr[method], log_url);
+                      RequestMethodStr[method], log_url);
     storeAppendPrintf(s, "\tinmem_lo: %d\n", (int) inmem_lo);
     storeAppendPrintf(s, "\tinmem_hi: %d\n", (int) data_hdr.endOffset());
     storeAppendPrintf(s, "\tswapout: %d bytes queued\n",
-	(int) swapout.queue_offset);
+                      (int) swapout.queue_offset);
+
     if (swapout.sio.getRaw())
-	storeAppendPrintf(s, "\tswapout: %d bytes written\n",
-	    (int) swapout.sio->offset());
+        storeAppendPrintf(s, "\tswapout: %d bytes written\n",
+                          (int) swapout.sio->offset());
+
     StoreClientStats statsVisitor(s);
+
     for_each(clients, statsVisitor);
 }
 
@@ -233,8 +262,9 @@ MemObject::endOffset () const
 size_t
 MemObject::size() const
 {
-    if (object_sz < 0) 
-	return endOffset();
+    if (object_sz < 0)
+        return endOffset();
+
     return object_sz;
 }
 
@@ -254,7 +284,7 @@ MemObject::lowestMemReaderOffset() const
     LowestMemReader lowest (endOffset() + 1);
 
     for_each (clients, lowest);
-    
+
     return lowest.current;
 }
 
@@ -278,6 +308,7 @@ MemObject::checkUrlChecksum () const
 {
     assert(chksum == url_checksum(url));
 }
+
 #endif
 
 /*
@@ -297,11 +328,15 @@ MemObject::objectBytesOnDisk() const
      * meaning we haven't even opened the swapout file
      * yet.
      */
+
     if (swapout.sio.getRaw() == NULL)
-	return 0;
+        return 0;
+
     off_t nwritten = swapout.sio->offset();
+
     if (nwritten <= (off_t)swap_hdr_sz)
-	return 0;
+        return 0;
+
     return (size_t) (nwritten - swap_hdr_sz);
 }
 
@@ -313,10 +348,11 @@ MemObject::policyLowestOffsetToKeep() const
      * as in the case of a range request.
      */
     off_t lowest_offset = lowestMemReaderOffset();
+
     if (endOffset() < lowest_offset ||
-	endOffset() - inmem_lo > (ssize_t)Config.Store.maxInMemObjSize)
-	return lowest_offset;
-    
+            endOffset() - inmem_lo > (ssize_t)Config.Store.maxInMemObjSize)
+        return lowest_offset;
+
     return inmem_lo;
 }
 
@@ -333,11 +369,15 @@ MemObject::trimSwappable()
      * walked to the next page. (mem->swapout.memnode)
      */
     off_t on_disk;
+
     if ((on_disk = objectBytesOnDisk()) - 1 < new_mem_lo)
-	new_mem_lo = on_disk - 1;
+        new_mem_lo = on_disk - 1;
+
     if (new_mem_lo == -1)
-	new_mem_lo = 0;	/* the above might become -1 */
+        new_mem_lo = 0;	/* the above might become -1 */
+
     data_hdr.freeDataUpto(new_mem_lo);
+
     inmem_lo = new_mem_lo;
 }
 
@@ -358,7 +398,7 @@ MemObject::isContiguous() const
     bool result = data_hdr.hasContigousContentRange (inmem_lo, endOffset());
     /* XXX : make this higher level */
     debug (19, result ? 2 : 1) ("MemObject::isContiguous: Returning %s\n",
-				result ? "true" : "false");
+                                result ? "true" : "false");
     return result;
 }
 
@@ -368,21 +408,27 @@ MemObject::mostBytesWanted(int max) const
 #if DELAY_POOLS
 #if 0
     int i = -1;
+
     for (dlink_node *node = clients.head; node; node = node->next) {
-	store_client *sc = (store_client *) node->data;
-	if (!sc->callbackPending())
-	    /* not waiting for more data */
-	    continue;
-	if (sc->getType() != STORE_MEM_CLIENT)
-	    continue;
-	i = sc->delayId.bytesWanted(i, XMIN(sc->copyInto.length, (size_t)max));
+        store_client *sc = (store_client *) node->data;
+
+        if (!sc->callbackPending())
+            /* not waiting for more data */
+            continue;
+
+        if (sc->getType() != STORE_MEM_CLIENT)
+            continue;
+
+        i = sc->delayId.bytesWanted(i, XMIN(sc->copyInto.length, (size_t)max));
     }
+
     return XMAX(i, 0);
 #endif
     /* identify delay id with largest allowance */
     DelayId largestAllowance = mostBytesAllowed ();
     return largestAllowance.bytesWanted(0, max);
 #else
+
     return max;
 #endif
 }
@@ -394,28 +440,36 @@ MemObject::mostBytesAllowed() const
     int j;
     int jmax = -1;
     DelayId result;
+
     for (dlink_node *node = clients.head; node; node = node->next) {
-	store_client *sc = (store_client *) node->data;
+        store_client *sc = (store_client *) node->data;
 #if 0
-	/* This test is invalid because the client may be writing data
-	 * and thus will want data immediately.
-	 * If we include the test, there is a race condition when too much
-	 * data is read - if all sc's are writing when a read is scheduled.
-	 * XXX: fixme.
-	 */
-	if (!sc->callbackPending())
-	    /* not waiting for more data */
-	    continue;
+        /* This test is invalid because the client may be writing data
+         * and thus will want data immediately.
+         * If we include the test, there is a race condition when too much
+         * data is read - if all sc's are writing when a read is scheduled.
+         * XXX: fixme.
+         */
+
+        if (!sc->callbackPending())
+            /* not waiting for more data */
+            continue;
+
 #endif
-	if (sc->getType() != STORE_MEM_CLIENT)
-	    /* reading off disk */
-	    continue;
-	j = sc->delayId.bytesWanted(0, sc->copyInto.length);
-	if (j > jmax) {
-	    jmax = j;
-	    result = sc->delayId;
-	}
+
+        if (sc->getType() != STORE_MEM_CLIENT)
+            /* reading off disk */
+            continue;
+
+        j = sc->delayId.bytesWanted(0, sc->copyInto.length);
+
+        if (j > jmax) {
+            jmax = j;
+            result = sc->delayId;
+        }
     }
+
     return result;
 }
+
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: MemObject.h,v 1.2 2003/02/05 10:36:48 robertc Exp $
+ * $Id: MemObject.h,v 1.3 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -44,10 +44,12 @@ class store_client;
 #include "DelayId.h"
 #endif
 
-class MemObject {
+class MemObject
+{
+
 public:
     static size_t inUseCount();
-  
+
     void dump() const;
     void *operator new (size_t);
     void operator delete (void *);
@@ -59,12 +61,12 @@ class MemObject {
     HttpReply const *getReply() const;
     void stat (StoreEntry *s) const;
     off_t endOffset () const;
-    size_t size() const;   
+    size_t size() const;
     void reset();
     off_t lowestMemReaderOffset() const;
     bool readAheadPolicyCanRead() const;
     void addClient(store_client *);
-    /* XXX belongs in MemObject::swapout, once swaphdrsz is managed 
+    /* XXX belongs in MemObject::swapout, once swaphdrsz is managed
      * better
      */
     size_t objectBytesOnDisk() const;
@@ -74,11 +76,13 @@ class MemObject {
     bool isContiguous() const;
     int mostBytesWanted(int max) const;
 #if DELAY_POOLS
+
     DelayId mostBytesAllowed() const;
 #endif
 
 
 #if URL_CHECKSUM_DEBUG
+
     void checkUrlChecksum() const;
 #endif
 
@@ -88,31 +92,43 @@ class MemObject {
     off_t inmem_lo;
     dlink_list clients;
     int nclients;
-    struct {
+
+    struct
+    {
         off_t queue_offset;     /* relative to in-mem data */
         mem_node *memnode;      /* which node we're currently paging out */
-	StoreIOState::Pointer sio;
-    } swapout;
+        StoreIOState::Pointer sio;
+    }
+
+    swapout;
     /* Read only - this reply must be preserved by store clients */
     /* The original reply. possibly with updated metadata. */
     request_t *request;
+
     struct timeval start_ping;
     IRCB *ping_reply_callback;
     void *ircb_data;
     int fd;                     /* FD of client creating this entry */
-    struct {
+
+    struct
+    {
         STABH *callback;
         void *data;
-    } abort;
+    }
+
+    abort;
     char *log_url;
     RemovalPolicyNode repl;
     int id;
     ssize_t object_sz;
     size_t swap_hdr_sz;
 #if URL_CHECKSUM_DEBUG
+
     unsigned int chksum;
 #endif
+
     const char *vary_headers;
+
 private:
     static MemPool *pool;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: NullDelayId.cc,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: NullDelayId.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -63,5 +63,6 @@ NullDelayId::deleteSelf() const
 {
     delete this;
 }
+
 #endif
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: NullDelayId.h,v 1.1 2003/02/05 10:36:48 robertc Exp $
+ * $Id: NullDelayId.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: Robert Collins <robertc@squid-cache.org>
@@ -46,13 +46,17 @@
 #include "RefCount.h"
 #include "DelayIdComposite.h"
 
-class NullDelayId : public DelayIdComposite {
-  public:
+class NullDelayId : public DelayIdComposite
+{
+
+public:
     void *operator new(size_t);
     void operator delete (void *);
     virtual void deleteSelf() const;
     virtual int bytesWanted (int min, int max) const {return XMAX(min,max);}
-    virtual void bytesIn(int qty) {}
-};
+
+    virtual void bytesIn(int qty) {}}
+
+;
 #endif
 #endif /* NULLDELAYID_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Packer.cc,v 1.15 2003/01/23 00:37:14 robertc Exp $
+ * $Id: Packer.cc,v 1.16 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 60    Packer: A uniform interface to store-like modules
  * AUTHOR: Alex Rousskov
@@ -151,7 +151,7 @@ packerPrintf(Packer * p, const char *fmt,...)
 #else
 void
 packerPrintf(va_alist)
-     va_dcl
+va_dcl
 {
     va_list args;
     Packer *p = NULL;
@@ -161,6 +161,7 @@ packerPrintf(va_alist)
     p = va_arg(args, Packer *);
     fmt = va_arg(args, char *);
 #endif
+
     assert(p);
     assert(p->real_handler && p->vprintf);
     p->vprintf(p->real_handler, fmt, args);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ProfStats.cc,v 1.3 2003/01/23 00:37:14 robertc Exp $
+ * $Id: ProfStats.cc,v 1.4 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 81     CPU Profiling Routines
  * AUTHOR: Andres Kroonmaa
@@ -84,9 +84,10 @@ static int
 xprof_comp(xprof_stats_node ** ii, xprof_stats_node ** jj)
 {
     if ((*ii)->hist.summ < (*jj)->hist.summ)
-	return (1);
+        return (1);
+
     if ((*ii)->hist.summ > (*jj)->hist.summ)
-	return (-1);
+        return (-1);
 
     return (0);
 }
@@ -97,8 +98,9 @@ xprof_sorthist(TimersArray * xprof_list)
     int i;
 
     for (i = 0; i < XPROF_LAST; i++) {
-	sortlist[i] = xprof_list[i];
+        sortlist[i] = xprof_list[i];
     }
+
     qsort(&sortlist[XPROF_hash_lookup], XPROF_LAST - XPROF_hash_lookup, sizeof(xprof_stats_node *), (QS *) xprof_comp);
 }
 
@@ -108,15 +110,15 @@ static void
 xprof_show_item(StoreEntry * sentry, const char *name, xprof_stats_data * hist)
 {
     storeAppendPrintf(sentry,
-	"%s\t %llu\t %llu\t %llu\t %llu\t %llu\t %.2f\t %6.3f\t\n",
-	name,
-	hist->count,
-	hist->summ,
-	(hist->best != XP_NOBEST ? hist->best : 0),
-	hist->count ? hist->summ / hist->count : 0,
-	hist->worst,
-	hist->count / time_frame,
-	dpercent((double) hist->summ, (double) hist->delta));
+                      "%s\t %llu\t %llu\t %llu\t %llu\t %llu\t %.2f\t %6.3f\t\n",
+                      name,
+                      hist->count,
+                      hist->summ,
+                      (hist->best != XP_NOBEST ? hist->best : 0),
+                      hist->count ? hist->summ / hist->count : 0,
+                      hist->worst,
+                      hist->count / time_frame,
+                      dpercent((double) hist->summ, (double) hist->delta));
 }
 
 static void
@@ -130,34 +132,44 @@ xprof_summary_item(StoreEntry * sentry, char *descr, TimersArray * list)
     hist = &sortlist[0];
 
     show = &hist[0]->hist;
+
     if (!hist[0]->hist.delta)
-	show = &hist[0]->accu;
+        show = &hist[0]->accu;
 
     time_frame = (double) show->delta / (double) xprof_average_delta;
 
     storeAppendPrintf(sentry, "\n%s:", descr);
+
     storeAppendPrintf(sentry, " (Cumulated time: %llu, %.2f sec)\n",
-	show->delta,
-	time_frame
-	);
+                      show->delta,
+                      time_frame
+                     );
+
     storeAppendPrintf(sentry,
-	"Probe Name\t  Events\t cumulated time \t best case \t average \t worst case\t Rate / sec \t %% in int\n");
+                      "Probe Name\t  Events\t cumulated time \t best case \t average \t worst case\t Rate / sec \t %% in int\n");
 
     for (i = 0; i < XPROF_LAST; i++) {
-	if (!hist[i]->name)
-	    continue;
-
-	show = &hist[i]->hist;
-	if (!show->count)
-	    continue;
-	xprof_show_item(sentry, hist[i]->name, show);
-
-	Totals.count += show->count;
-	Totals.summ += show->summ;
-	Totals.best += (show->best != XP_NOBEST ? show->best : 0);
-	Totals.worst += show->worst;
-	Totals.delta = (show->delta > Totals.delta ? show->delta : Totals.delta);
+        if (!hist[i]->name)
+            continue;
+
+        show = &hist[i]->hist;
+
+        if (!show->count)
+            continue;
+
+        xprof_show_item(sentry, hist[i]->name, show);
+
+        Totals.count += show->count;
+
+        Totals.summ += show->summ;
+
+        Totals.best += (show->best != XP_NOBEST ? show->best : 0);
+
+        Totals.worst += show->worst;
+
+        Totals.delta = (show->delta > Totals.delta ? show->delta : Totals.delta);
     }
+
     xprof_show_item(sentry, "TOTALS", &Totals);
 }
 
@@ -172,41 +184,44 @@ xprof_average(TimersArray ** list, int secs)
     int doavg = (xprof_events % secs);
 
     if (!*list)
-	*list = (TimersArray *)xcalloc(XPROF_LAST, sizeof(xprof_stats_node));
+        *list = (TimersArray *)xcalloc(XPROF_LAST, sizeof(xprof_stats_node));
 
     hist = *list;
+
     now = get_tick();
 
     for (i = 0; i < XPROF_LAST; i++) {
-	hist[i]->name = head[i]->name;
-	hist[i]->accu.summ += head[i]->accu.summ;
-	hist[i]->accu.count += head[i]->accu.count;	/* accumulate multisec */
-
-	if (!hist[i]->accu.best)
-	    hist[i]->accu.best = head[i]->accu.best;
-
-	if (hist[i]->accu.best > head[i]->accu.best)
-	    hist[i]->accu.best = head[i]->accu.best;
-
-	if (hist[i]->accu.worst < head[i]->accu.worst)
-	    hist[i]->accu.worst = head[i]->accu.worst;
-
-	hist[i]->accu.delta += xprof_delta;
-	if (!doavg) {
-	    /* we have X seconds accumulated */
-	    xprof_move(&hist[i]->accu, &hist[i]->hist);
-	    xprof_reset(&hist[i]->accu);
-
-	    hist[i]->accu.start = now;
-	}
-	/* reset 0sec counters */
-	if (secs == 1) {
-	    keep = head[i]->accu.start;
-	    xprof_move(&head[i]->accu, &head[i]->hist);
-	    xprof_reset(&head[i]->accu);
-	    hist[i]->accu.delta = 0;
-	    head[i]->accu.start = keep;
-	}
+        hist[i]->name = head[i]->name;
+        hist[i]->accu.summ += head[i]->accu.summ;
+        hist[i]->accu.count += head[i]->accu.count;	/* accumulate multisec */
+
+        if (!hist[i]->accu.best)
+            hist[i]->accu.best = head[i]->accu.best;
+
+        if (hist[i]->accu.best > head[i]->accu.best)
+            hist[i]->accu.best = head[i]->accu.best;
+
+        if (hist[i]->accu.worst < head[i]->accu.worst)
+            hist[i]->accu.worst = head[i]->accu.worst;
+
+        hist[i]->accu.delta += xprof_delta;
+
+        if (!doavg) {
+            /* we have X seconds accumulated */
+            xprof_move(&hist[i]->accu, &hist[i]->hist);
+            xprof_reset(&hist[i]->accu);
+
+            hist[i]->accu.start = now;
+        }
+
+        /* reset 0sec counters */
+        if (secs == 1) {
+            keep = head[i]->accu.start;
+            xprof_move(&head[i]->accu, &head[i]->hist);
+            xprof_reset(&head[i]->accu);
+            hist[i]->accu.delta = 0;
+            head[i]->accu.start = keep;
+        }
     }
 }
 
@@ -217,15 +232,15 @@ xprof_summary(StoreEntry * sentry)
 
     storeAppendPrintf(sentry, "CPU Profiling Statistics:\n");
     storeAppendPrintf(sentry,
-	"  (CPU times are in arbitrary units, most probably in CPU clock ticks)\n");
+                      "  (CPU times are in arbitrary units, most probably in CPU clock ticks)\n");
     storeAppendPrintf(sentry,
-	"Probe Name\t Event Count\t last Interval \t Avg Interval \t since squid start \t (since system boot) \n");
+                      "Probe Name\t Event Count\t last Interval \t Avg Interval \t since squid start \t (since system boot) \n");
     storeAppendPrintf(sentry, "Total\t %lu\t %llu \t %llu \t %llu \t %llu\n",
-	(long unsigned) xprof_events,
-	xprof_delta,
-	xprof_average_delta,
-	now - xprof_verystart,
-	now);
+                      (long unsigned) xprof_events,
+                      xprof_delta,
+                      xprof_average_delta,
+                      now - xprof_verystart,
+                      now);
 
     xprof_summary_item(sentry, "Last 1 sec averages", xprof_stats_avg1sec);
     xprof_summary_item(sentry, "Last 5 sec averages", xprof_stats_avg5sec);
@@ -242,8 +257,8 @@ static inline void
 xprof_chk_overhead(int samples)
 {
     while (samples--) {
-	PROF_start(PROF_OVERHEAD);
-	PROF_stop(PROF_OVERHEAD);
+        PROF_start(PROF_OVERHEAD);
+        PROF_stop(PROF_OVERHEAD);
     }
 }
 
@@ -252,11 +267,12 @@ static void
 xprof_Init(void)
 {
     if (xprof_inited)
-	return;
+        return;
 
     xprof_delta = xprof_verystart = xprof_start_t = now;
 
     xprof_inited = 1;
+
     cachemgrRegister("cpu_profile", "CPU Profiling Stats", xprof_summary, 0, 1);
 }
 
@@ -270,22 +286,35 @@ xprof_event(void *data)
     xprof_events++;
 
     if (!xprof_average_delta)
-	xprof_average_delta = xprof_delta;
+        xprof_average_delta = xprof_delta;
+
     if (xprof_average_delta > (xprof_delta >> 1))
-	xprof_average_delta = xprof_average_delta - (xprof_average_delta >> 8) + (xprof_delta >> 8);
+        xprof_average_delta = xprof_average_delta - (xprof_average_delta >> 8) + (xprof_delta >> 8);
 
     xprof_nesting++;
+
     xprof_chk_overhead(2);
+
     xprof_average(&xprof_stats_avg24hour, 24 * 3600);
+
     xprof_average(&xprof_stats_avg5hour, 5 * 3600);
+
     xprof_average(&xprof_stats_avg1hour, 3600);
+
     xprof_average(&xprof_stats_avg30min, 1800);
+
     xprof_average(&xprof_stats_avg5min, 300);
+
     xprof_average(&xprof_stats_avg1min, 60);
+
     xprof_average(&xprof_stats_avg30sec, 30);
+
     xprof_average(&xprof_stats_avg5sec, 5);
+
     xprof_average(&xprof_stats_avg1sec, 1);
+
     xprof_chk_overhead(30);
+
     xprof_nesting--;
 
     eventAdd("cpuProfiling", xprof_event, NULL, 1.0, 1);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: SquidString.h,v 1.1 2003/02/02 13:27:43 robertc Exp $
+ * $Id: SquidString.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 67    String
  * AUTHOR: Duane Wessels
@@ -36,17 +36,19 @@
 #ifndef SQUID_STRING_H
 #define SQUID_STRING_H
 
-class String {
+class String
+{
+
 public:
     static const String Null;
     _SQUID_INLINE_ String();
     String (char const *);
     String (String const &);
     ~String();
-    
+
     String &operator =(char const *);
     String &operator =(String const &);
-    
+
     _SQUID_INLINE_ int size() const;
     _SQUID_INLINE_ char const * buf() const;
     void init (char const *);
@@ -59,9 +61,11 @@ class String {
     void append (String const &);
     void absorb(String &old);
     _SQUID_INLINE_ int nCaseCmp (char const *aString, int aLen) const;
+
 private:
     /* never reference these directly! */
     unsigned short int size_;	/* buffer size; 64K limit */
+
 public:
     unsigned short int len_;	/* current length  */
     char *buf_;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StatHist.cc,v 1.29 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StatHist.cc,v 1.30 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 62    Generic Histogram
  * AUTHOR: Duane Wessels
@@ -54,10 +54,10 @@ static int statHistBin(const StatHist * H, double v);
 static double statHistVal(const StatHist * H, int bin);
 static StatHistBinDumper statHistBinDumper;
 #if !defined(_SQUID_HPUX_) || !defined(__GNUC__)
-    /*
-     * HP-UX and GCC (2.8?) give strange errors when these simple
-     * functions are static.
-     */
+/*
+ * HP-UX and GCC (2.8?) give strange errors when these simple
+ * functions are static.
+ */
 static hbase_f Log;
 static hbase_f Exp;
 static hbase_f Null;
@@ -111,7 +111,7 @@ statHistCopy(StatHist * Dest, const StatHist * Orig)
     assert(Dest->bins);
     /* better be safe than sorry */
     debug(62, 3) ("statHistCopy: capacity %d %d\n",
-	Dest->capacity, Orig->capacity);
+                  Dest->capacity, Orig->capacity);
     assert(Dest->capacity == Orig->capacity);
     debug(62, 3) ("statHistCopy: min %f %f\n", Dest->min, Orig->min);
     assert(Dest->min == Orig->min);
@@ -123,9 +123,9 @@ statHistCopy(StatHist * Dest, const StatHist * Orig)
     assert(Dest->val_out == Orig->val_out);
     /* actual copy */
     debug(62, 3) ("statHistCopy: copying %ld bytes to %p from %p\n",
-	(long int) (Dest->capacity * sizeof(*Dest->bins)),
-	Dest->bins,
-	Orig->bins);
+                  (long int) (Dest->capacity * sizeof(*Dest->bins)),
+                  Dest->bins,
+                  Orig->bins);
     xmemcpy(Dest->bins, Orig->bins, Dest->capacity * sizeof(*Dest->bins));
 }
 
@@ -139,8 +139,9 @@ statHistSafeCopy(StatHist * Dest, const StatHist * Orig)
 {
     assert(Dest && Orig);
     assert(Dest->bins);
+
     if (Dest->capacity == Orig->capacity)
-	statHistCopy(Dest, Orig);
+        statHistCopy(Dest, Orig);
 }
 
 void
@@ -157,17 +158,24 @@ statHistBin(const StatHist * H, double v)
 {
     int bin;
 #if BROKEN_STAT_HIST_BIN
+
     return 0;
     /* NOTREACHED */
 #endif
+
     v -= H->min;		/* offset */
+
     if (v <= 0.0)		/* too small */
-	return 0;
+        return 0;
+
     bin = (int) floor(H->scale * H->val_in(v) + 0.5);
+
     if (bin < 0)		/* should not happen */
-	bin = 0;
+        bin = 0;
+
     if (bin >= H->capacity)	/* too big */
-	bin = H->capacity - 1;
+        bin = H->capacity - 1;
+
     return bin;
 }
 
@@ -191,55 +199,72 @@ statHistDeltaMedian(const StatHist * A, const StatHist * B)
     double f;
     int *D = (int *)xcalloc(A->capacity, sizeof(int));
     assert(A->capacity == B->capacity);
+
     for (i = 0; i < A->capacity; i++) {
-	D[i] = B->bins[i] - A->bins[i];
-	assert(D[i] >= 0);
+        D[i] = B->bins[i] - A->bins[i];
+        assert(D[i] >= 0);
     }
+
     for (i = 0; i < A->capacity; i++)
-	s1 += D[i];
+        s1 += D[i];
+
     h = s1 >> 1;
+
     for (i = 0; i < A->capacity; i++) {
-	J = i;
-	b += D[J];
-	if (a <= h && h <= b)
-	    break;
-	I = i;
-	a += D[I];
+        J = i;
+        b += D[J];
+
+        if (a <= h && h <= b)
+            break;
+
+        I = i;
+
+        a += D[I];
     }
+
     xfree(D);
+
     if (s1 == 0)
-	return 0.0;
+        return 0.0;
+
     if (a > h)
-	return 0.0;
+        return 0.0;
+
     if (a >= b)
-	return 0.0;
+        return 0.0;
+
     if (I >= J)
-	return 0.0;
+        return 0.0;
+
     f = (h - a) / (b - a);
+
     K = (int) floor(f * (double) (J - I) + I);
+
     return statHistVal(A, K);
 }
 
 static void
 statHistBinDumper(StoreEntry * sentry, int idx, double val, double size, int count)
 {
     if (count)
-	storeAppendPrintf(sentry, "\t%3d/%f\t%d\t%f\n",
-	    idx, val, count, count / size);
+        storeAppendPrintf(sentry, "\t%3d/%f\t%d\t%f\n",
+                          idx, val, count, count / size);
 }
 
 void
 statHistDump(const StatHist * H, StoreEntry * sentry, StatHistBinDumper * bd)
 {
     int i;
     double left_border = H->min;
+
     if (!bd)
-	bd = statHistBinDumper;
+        bd = statHistBinDumper;
+
     for (i = 0; i < H->capacity; i++) {
-	const double right_border = statHistVal(H, i + 1);
-	assert(right_border - left_border > 0.0);
-	bd(sentry, i, left_border, right_border - left_border, H->bins[i]);
-	left_border = right_border;
+        const double right_border = statHistVal(H, i + 1);
+        assert(right_border - left_border > 0.0);
+        bd(sentry, i, left_border, right_border - left_border, H->bins[i]);
+        left_border = right_border;
     }
 }
 
@@ -290,8 +315,8 @@ void
 statHistEnumDumper(StoreEntry * sentry, int idx, double val, double size, int count)
 {
     if (count)
-	storeAppendPrintf(sentry, "%2d\t %5d\t %5d\n",
-	    idx, (int) val, count);
+        storeAppendPrintf(sentry, "%2d\t %5d\t %5d\n",
+                          idx, (int) val, count);
 }
 
 void
@@ -304,5 +329,5 @@ void
 statHistIntDumper(StoreEntry * sentry, int idx, double val, double size, int count)
 {
     if (count)
-	storeAppendPrintf(sentry, "%9d\t%9d\n", (int) val, count);
+        storeAppendPrintf(sentry, "%9d\t%9d\n", (int) val, count);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: Store.h,v 1.6 2003/01/23 00:37:14 robertc Exp $
+ * $Id: Store.h,v 1.7 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -37,14 +37,18 @@
 #include "StoreIOBuffer.h"
 
 class StoreClient;
+
 class MemObject;
 
 typedef void STSETUP(storefs_entry_t *);
-class StoreEntry : public hash_link {
+
+class StoreEntry : public hash_link
+{
+
 public:
     static int CheckDeferRead(int fd, void *data);
     static void FsAdd(const char *, STSETUP *);
-  
+
     virtual const char *getMD5Text() const;
     virtual HttpReply const *getReply() const;
     virtual void write (StoreIOBuffer);
@@ -67,24 +71,40 @@ class StoreEntry : public hash_link {
     u_short refcount;
     u_short flags;
     /* END OF ON-DISK STORE_META_STD */
-    sfileno swap_filen:25;
-    sdirno swap_dirn:7;
+
+sfileno swap_filen:
+    25;
+
+sdirno swap_dirn:
+    7;
     u_short lock_count;		/* Assume < 65536! */
-    mem_status_t mem_status:3;
-    ping_status_t ping_status:3;
-    store_status_t store_status:3;
-    swap_status_t swap_status:3;
+
+mem_status_t mem_status:
+    3;
+
+ping_status_t ping_status:
+    3;
+
+store_status_t store_status:
+    3;
+
+swap_status_t swap_status:
+    3;
+
 public:
     static size_t inUseCount();
     static void getPublicByRequestMethod(StoreClient * aClient, request_t * request, const method_t method);
     static void getPublicByRequest(StoreClient * aClient, request_t * request);
     static void getPublic(StoreClient * aClient, const char *uri, const method_t method);
 
-    virtual bool isNull() {
-	return false;
+    virtual bool isNull()
+    {
+        return false;
     }
+
     void *operator new(size_t byteCount);
     void operator delete(void *address);
+
 private:
     static MemPool *pool;
 
@@ -93,25 +113,34 @@ class StoreEntry : public hash_link {
 
 class NullStoreEntry:public StoreEntry
 {
+
 public:
     static NullStoreEntry *getInstance();
-    bool isNull() {
-	return true;
+    bool isNull()
+    {
+        return true;
     }
+
     const char *getMD5Text() const;
     _SQUID_INLINE_ HttpReply const *getReply() const;
     void write (StoreIOBuffer){}
+
     bool isEmpty () const {return true;}
+
     int checkDeferRead(int fd) const {return 1;}
+
     void operator delete(void *address);
     void complete(){}
-         private:
+
+private:
     store_client_t storeClientType() const{return STORE_MEM_CLIENT;}
+
     char const *getSerialisedMetaData();
     bool swapoutPossible() {return false;}
+
     void trimMemory() {}
 
-    
+
     static NullStoreEntry _instance;
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreClient.h,v 1.8 2003/02/06 09:57:36 robertc Exp $
+ * $Id: StoreClient.h,v 1.9 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -40,18 +40,24 @@ typedef void STCB(void *, StoreIOBuffer);	/* store callback */
 
 class StoreEntry;
 
-class StoreClient {
+class StoreClient
+{
+
 public:
-  virtual ~StoreClient () {}
-  virtual void created (StoreEntry *newEntry) = 0;
+    virtual ~StoreClient () {}
+
+    virtual void created (StoreEntry *newEntry) = 0;
 };
 
 #if DELAY_POOLS
 #include "DelayId.h"
 #endif
 
 /* keep track each client receiving data from that particular StoreEntry */
-class store_client {
+
+class store_client
+{
+
 public:
     void *operator new (size_t);
     void operator delete(void *);
@@ -69,36 +75,56 @@ class store_client {
 
     off_t cmp_offset;
 #if STORE_CLIENT_LIST_DEBUG
+
     void *owner;
 #endif
+
     StoreEntry *entry;		/* ptr to the parent StoreEntry, argh! */
     StoreIOState::Pointer swapin_sio;
-    struct {
-	unsigned int disk_io_pending:1;
-	unsigned int store_copying:1;
-	unsigned int copy_event_pending:1;
-    } flags;
+
+    struct
+    {
+
+unsigned int disk_io_pending:
+        1;
+
+unsigned int store_copying:
+        1;
+
+unsigned int copy_event_pending:
+        1;
+    }
+
+    flags;
 #if DELAY_POOLS
+
     DelayId delayId;
     void setDelayId(DelayId delay_id);
 #endif
+
     dlink_node node;
     /* Below here is private - do no alter outside storeClient calls */
     StoreIOBuffer copyInto;
+
 private:
     static MemPool *pool;
 
     void fileRead();
     void unpackHeader(char const *buf, ssize_t len);
-    
+
     int type;
     bool object_ok;
-    struct Callback {
-	Callback ():callback_handler(NULL), callback_data(NULL){}
-	Callback (STCB *, void *);
-	STCB *callback_handler;
-	void *callback_data;
-    } _callback;
+
+    struct Callback
+    {
+        Callback ():callback_handler(NULL), callback_data(NULL){}
+
+        Callback (STCB *, void *);
+        STCB *callback_handler;
+        void *callback_data;
+    }
+
+    _callback;
 };
 
 SQUIDCEXTERN void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreIOBuffer.h,v 1.2 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreIOBuffer.h,v 1.3 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -34,17 +34,26 @@
 #ifndef SQUID_STOREIORESULT_H
 #define SQUID_STOREIORESULT_H
 
-class StoreIOBuffer {
+class StoreIOBuffer
+{
+
 public:
     StoreIOBuffer():length(0), offset (0), data (NULL){flags.error = 0;}
+
     StoreIOBuffer(size_t aLength, off_t anOffset, char *someData) :
-      length (aLength), offset (anOffset), data (someData)
-      {
-	flags.error = 0;
-      }
-    struct {
-	int error:1;
-    } flags;
+            length (aLength), offset (anOffset), data (someData)
+    {
+        flags.error = 0;
+    }
+
+    struct
+    {
+
+int error:
+        1;
+    }
+
+    flags;
     size_t length;
     off_t offset;
     char *data;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreIOState.cc,v 1.2 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreIOState.cc,v 1.3 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section ??    Swap Dir base object
  * AUTHOR: Robert Collins
@@ -35,15 +35,15 @@
 
 #include "squid.h"
 #include "StoreIOState.h"
-    
+
 void *
 storeIOState::operator new (size_t amount)
 {
     assert(0);
     return (void *)1;
 }
 
-void 
+void
 storeIOState::operator delete (void *address){assert (0);}
 
 storeIOState::storeIOState()
@@ -60,7 +60,8 @@ storeIOState::offset() const
 storeIOState::~storeIOState()
 {
     if (read.callback_data)
-	cbdataReferenceDone(read.callback_data);
+        cbdataReferenceDone(read.callback_data);
+
     if (callback_data)
-	cbdataReferenceDone(callback_data);
+        cbdataReferenceDone(callback_data);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreIOState.h,v 1.3 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreIOState.h,v 1.4 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,7 +35,10 @@
 #define SQUID_STOREIOSTATE_H
 
 #include "RefCount.h"
-class storeIOState : public RefCountable{
+
+class storeIOState : public RefCountable
+{
+
 public:
 
     /* storeIOState does not get mempooled - it's children do */
@@ -51,7 +54,7 @@ class storeIOState : public RefCountable{
     virtual void read_(char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data) = 0;
     virtual void write(char const *buf, size_t size, off_t offset, FREE * free_func) = 0;
     virtual void close() = 0;
-    
+
     sdirno swap_dirn;
     sfileno swap_filen;
     StoreEntry *e;		/* Need this so the FS layers can play god */
@@ -60,16 +63,28 @@ class storeIOState : public RefCountable{
     STFNCB *file_callback;	/* called on delayed sfileno assignments */
     STIOCB *callback;
     void *callback_data;
-    struct {
-	STRCB *callback;
-	void *callback_data;
-    } read;
-    struct {
-	unsigned int closing:1;	/* debugging aid */
-    } flags;
+
+    struct
+    {
+        STRCB *callback;
+        void *callback_data;
+    }
+
+    read;
+
+    struct
+    {
+
+unsigned int closing:
+        1;	/* debugging aid */
+    }
+
+    flags;
 };
 
-class StoreIOState {
+class StoreIOState
+{
+
 public:
     typedef RefCount<storeIOState> Pointer;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMeta.cc,v 1.1 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreMeta.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -46,37 +46,45 @@ bool
 StoreMeta::validType(char type)
 {
     /* VOID is reserved, and new types have to be added as classes */
+
     if (type <= STORE_META_VOID || type >= STORE_META_END) {
-	debug(20, 0) ("storeSwapMetaUnpack: bad type (%d)!\n", type);
-	return false;
+        debug(20, 0) ("storeSwapMetaUnpack: bad type (%d)!\n", type);
+        return false;
     }
+
     /* Unused in any current squid code */
     if (type == STORE_META_KEY_URL ||
-	type == STORE_META_KEY_SHA ||
-	type == STORE_META_HITMETERING || 
-	type == STORE_META_VALID) {
-	debug (20,0)("Obsolete and unused type (%d) in disk metadata\n", type);
-	return false;
+            type == STORE_META_KEY_SHA ||
+            type == STORE_META_HITMETERING ||
+            type == STORE_META_VALID) {
+        debug (20,0)("Obsolete and unused type (%d) in disk metadata\n", type);
+        return false;
     }
+
     return true;
 }
 
-class IntRange{
+class IntRange
+{
+
 public:
-    IntRange (int minimum, int maximum) : _min (minimum), _max (maximum) 
-      {
-	if (_min > _max) {
-	    int temp = _min;
-	    _min = _max;
-	    _max = temp;
-	}
-      }
+    IntRange (int minimum, int maximum) : _min (minimum), _max (maximum)
+    {
+        if (_min > _max) {
+            int temp = _min;
+            _min = _max;
+            _max = temp;
+        }
+    }
+
     bool includes (int anInt) const
-      {
-	if (anInt < _min || anInt > _max)
-	    return false;
-	return true;
-      }
+    {
+        if (anInt < _min || anInt > _max)
+            return false;
+
+        return true;
+    }
+
 private:
     int _min;
     int _max;
@@ -88,10 +96,11 @@ const int StoreMeta::MaximumTLVLength = 1 << 16;
 bool
 StoreMeta::validLength(int length) const
 {
-    if (!IntRange (MinimumTLVLength, MaximumTLVLength).includes(length)){
-	debug(20, 0) ("storeSwapMetaUnpack: insane length (%d)!\n", length);
-	return false;
+    if (!IntRange (MinimumTLVLength, MaximumTLVLength).includes(length)) {
+        debug(20, 0) ("storeSwapMetaUnpack: insane length (%d)!\n", length);
+        return false;
     }
+
     return true;
 }
 
@@ -101,28 +110,37 @@ StoreMeta::Factory (char type, size_t len, void const *value)
 {
     if (!validType(type))
         return NULL;
+
     StoreMeta *result;
+
     switch (type) {
-      case STORE_META_KEY:
-      result = new StoreMetaMD5;
-      break;
-      case STORE_META_URL:
-      result = new StoreMetaURL;
-      break;
-      case STORE_META_STD:
-      result = new StoreMetaSTD;
-      break;
-      case STORE_META_VARY_HEADERS:
-      result = new StoreMetaVary;
-      break;
-      default:
-      debug (20,0)("Attempt to create unknown concrete StoreMeta\n");
-      return NULL;
+
+    case STORE_META_KEY:
+        result = new StoreMetaMD5;
+        break;
+
+    case STORE_META_URL:
+        result = new StoreMetaURL;
+        break;
+
+    case STORE_META_STD:
+        result = new StoreMetaSTD;
+        break;
+
+    case STORE_META_VARY_HEADERS:
+        result = new StoreMetaVary;
+        break;
+
+    default:
+        debug (20,0)("Attempt to create unknown concrete StoreMeta\n");
+        return NULL;
     }
+
     if (!result->validLength(len)) {
-	result->deleteSelf();
-	return NULL;
+        result->deleteSelf();
+        return NULL;
     }
+
     result->length = len;
     result->value = xmalloc(len);
     xmemcpy(result->value, value, len);
@@ -133,10 +151,11 @@ void
 StoreMeta::FreeList(StoreMeta **head)
 {
     StoreMeta *node;
+
     while ((node = *head) != NULL) {
-	*head = node->next;
-	xfree(node->value);
-	node->deleteSelf();
+        *head = node->next;
+        xfree(node->value);
+        node->deleteSelf();
     }
 }
 
@@ -148,22 +167,27 @@ StoreMeta::Add(StoreMeta **tail, StoreMeta *aNode)
     return &aNode->next;		/* return new tail pointer */
 }
 
-bool 
+bool
 StoreMeta::checkConsistency(StoreEntry *e) const
 {
-    switch (getType())
-      {
-	case STORE_META_KEY:
-	case STORE_META_URL:
-	case STORE_META_VARY_HEADERS:
-	    assert(0);
-	    break;
-	case STORE_META_STD:
-	    break;
-	default:
-	    debug(20, 1) ("WARNING: got unused STORE_META type %d\n", getType());
-	    break;
-	}
+    switch (getType()) {
+
+    case STORE_META_KEY:
+
+    case STORE_META_URL:
+
+    case STORE_META_VARY_HEADERS:
+        assert(0);
+        break;
+
+    case STORE_META_STD:
+        break;
+
+    default:
+        debug(20, 1) ("WARNING: got unused STORE_META type %d\n", getType());
+        break;
+    }
+
     return true;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMeta.h,v 1.1 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreMeta.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,8 +35,12 @@
 #define SQUID_TYPELENGTHVALUE_H
 
 class StoreEntry;
+
 typedef class StoreMeta tlv;
-class StoreMeta {
+
+class StoreMeta
+{
+
 public:
     virtual void deleteSelf() = 0;
     static bool validType(char);
@@ -45,15 +49,16 @@ class StoreMeta {
     static StoreMeta *Factory (char type, size_t len, void const *value);
     static StoreMeta **Add(StoreMeta **tail, StoreMeta *aNode);
     static void FreeList (StoreMeta **head);
-    
+
     virtual char getType() const = 0;
     virtual bool validLength(int) const;
     virtual bool checkConsistency(StoreEntry *) const;
     virtual ~StoreMeta(){}
-    
+
     int length;
     void *value;
     tlv *next;
+
 private:
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaMD5.cc,v 1.1 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreMetaMD5.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -45,8 +45,10 @@ StoreMetaMD5::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (StoreMetaMD5));
+
     if (!pool)
-	pool = memPoolCreate("StoreMetaMD5", sizeof (StoreMetaMD5));
+        pool = memPoolCreate("StoreMetaMD5", sizeof (StoreMetaMD5));
+
     return memPoolAlloc(pool);
 }
 
@@ -62,28 +64,32 @@ StoreMetaMD5::deleteSelf()
     delete this;
 }
 
-bool 
+bool
 StoreMetaMD5::validLength(int len) const
 {
     return len == MD5_DIGEST_CHARS;
 }
 
 int StoreMetaMD5::md5_mismatches = 0;
 
-bool 
+bool
 StoreMetaMD5::checkConsistency(StoreEntry *e) const
 {
     assert (getType() == STORE_META_KEY_MD5);
     assert(length == MD5_DIGEST_CHARS);
+
     if (!EBIT_TEST(e->flags, KEY_PRIVATE) &&
-	memcmp(value, e->key, MD5_DIGEST_CHARS)) {
-	debug(20, 2) ("storeClientReadHeader: swapin MD5 mismatch\n");
-//	debug(20, 2) ("\t%s\n", storeKeyText((const cache_key *)value));
-	debug(20, 2) ("\t%s\n", e->getMD5Text());
-	if (isPowTen(++md5_mismatches))
-	    debug(20, 1) ("WARNING: %d swapin MD5 mismatches\n",
-			  md5_mismatches);
-	return false;
+            memcmp(value, e->key, MD5_DIGEST_CHARS)) {
+        debug(20, 2) ("storeClientReadHeader: swapin MD5 mismatch\n");
+        //	debug(20, 2) ("\t%s\n", storeKeyText((const cache_key *)value));
+        debug(20, 2) ("\t%s\n", e->getMD5Text());
+
+        if (isPowTen(++md5_mismatches))
+            debug(20, 1) ("WARNING: %d swapin MD5 mismatches\n",
+                          md5_mismatches);
+
+        return false;
     }
+
     return true;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaMD5.h,v 1.1 2003/01/23 00:37:14 robertc Exp $
+ * $Id: StoreMetaMD5.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,16 +36,19 @@
 
 #include "StoreMeta.h"
 
-class StoreMetaMD5 : public StoreMeta {
+class StoreMetaMD5 : public StoreMeta
+{
+
 public:
     void *operator new (size_t);
     void operator delete (void *);
     void deleteSelf();
-    
+
     char getType() const {return STORE_META_KEY_MD5;}
+
     bool validLength(int) const;
     bool checkConsistency(StoreEntry *) const;
-    
+
 private:
     static MemPool *pool;
     static int md5_mismatches;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaSTD.cc,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaSTD.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -45,8 +45,10 @@ StoreMetaSTD::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (StoreMetaSTD));
+
     if (!pool)
-	pool = memPoolCreate("StoreMetaSTD", sizeof (StoreMetaSTD));
+        pool = memPoolCreate("StoreMetaSTD", sizeof (StoreMetaSTD));
+
     return memPoolAlloc(pool);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaSTD.h,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaSTD.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,16 +36,19 @@
 
 #include "StoreMeta.h"
 
-class StoreMetaSTD : public StoreMeta {
+class StoreMetaSTD : public StoreMeta
+{
+
 public:
     void *operator new (size_t);
     void operator delete (void *);
     void deleteSelf();
-    
+
     char getType() const {return STORE_META_STD;}
+
     bool validLength(int) const;
-//    bool checkConsistency(StoreEntry *) const;
-    
+    //    bool checkConsistency(StoreEntry *) const;
+
 private:
     static MemPool *pool;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaURL.cc,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaURL.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -45,8 +45,10 @@ StoreMetaURL::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (StoreMetaURL));
+
     if (!pool)
-	pool = memPoolCreate("StoreMetaURL", sizeof (StoreMetaURL));
+        pool = memPoolCreate("StoreMetaURL", sizeof (StoreMetaURL));
+
     return memPoolAlloc(pool);
 }
 
@@ -62,16 +64,19 @@ StoreMetaURL::deleteSelf()
     delete this;
 }
 
-bool 
+bool
 StoreMetaURL::checkConsistency(StoreEntry *e) const
 {
     assert (getType() == STORE_META_URL);
+
     if (!e->mem_obj->url)
-	return true;
+        return true;
+
     if (strcasecmp(e->mem_obj->url, (char *)value)) {
-	debug(20, 1) ("storeClientReadHeader: URL mismatch\n");
-	debug(20, 1) ("\t{%s} != {%s}\n", (char *) value, e->mem_obj->url);
-	return false;
+        debug(20, 1) ("storeClientReadHeader: URL mismatch\n");
+        debug(20, 1) ("\t{%s} != {%s}\n", (char *) value, e->mem_obj->url);
+        return false;
     }
+
     return true;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaURL.h,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaURL.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,15 +36,18 @@
 
 #include "StoreMeta.h"
 
-class StoreMetaURL : public StoreMeta {
+class StoreMetaURL : public StoreMeta
+{
+
 public:
     void *operator new (size_t);
     void operator delete (void *);
     void deleteSelf();
-    
+
     char getType() const {return STORE_META_URL;}
+
     bool checkConsistency(StoreEntry *) const;
-    
+
 private:
     static MemPool *pool;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaUnpacker.cc,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaUnpacker.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Unpacker
  * AUTHOR: Robert Collins
@@ -43,16 +43,20 @@ bool
 StoreMetaUnpacker::isBufferSane()
 {
     if (buf[0] != (char) STORE_META_OK)
-	return false;
+        return false;
+
     /*
      * sanity check on 'buflen' value.  It should be at least big
      * enough to hold one type and one length.
      */
     getBufferLength();
+
     if (*hdr_len <= MinimumBufferLength)
-	return false;
+        return false;
+
     if (*hdr_len > buflen)
-	return false;
+        return false;
+
     return true;
 }
 
@@ -85,17 +89,23 @@ StoreMetaUnpacker::doOneEntry()
 {
     getType();
     getLength();
+
     if (position + length > *hdr_len) {
         debug(20, 0) ("storeSwapMetaUnpack: overflow!\n");
         debug(20, 0) ("\ttype=%d, length=%d, *hdr_len=%d, offset=%d\n",
-            type, length, *hdr_len, (int) position);
+                      type, length, *hdr_len, (int) position);
         return false;
     }
+
     StoreMeta *newNode = StoreMeta::Factory(type, length, &buf[position]);
+
     if (!newNode)
-	return false;
+        return false;
+
     tail = StoreMeta::Add (tail, newNode);
+
     position += length;
+
     return true;
 }
 
@@ -111,13 +121,18 @@ StoreMetaUnpacker::createStoreMeta ()
     tlv *TLV = NULL;
     tail = &TLV;
     assert(hdr_len != NULL);
+
     if (!isBufferSane())
-	return NULL;
+        return NULL;
+
     getBufferLength();
+
     assert (position == 1 + sizeof(int));
+
     while (moreToProcess()) {
-	if (!doOneEntry())
-	    break;
+        if (!doOneEntry())
+            break;
     }
+
     return TLV;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaUnpacker.h,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaUnpacker.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -35,14 +35,18 @@
 #define SQUID_TYPELENGTHVALUEUNPACKER_H
 
 class StoreMeta;
-class StoreMetaUnpacker {
+
+class StoreMetaUnpacker
+{
+
 public:
     StoreMetaUnpacker (const char *buf, ssize_t bufferLength, int *hdrlen);
     StoreMeta *createStoreMeta();
     bool isBufferSane();
+
 private:
     static off_t const MinimumBufferLength;
-    
+
     void getBufferLength();
     void getType();
     void getLength();
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaVary.cc,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaVary.cc,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -45,8 +45,10 @@ StoreMetaVary::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (StoreMetaVary));
+
     if (!pool)
-	pool = memPoolCreate("StoreMetaVary", sizeof (StoreMetaVary));
+        pool = memPoolCreate("StoreMetaVary", sizeof (StoreMetaVary));
+
     return memPoolAlloc(pool);
 }
 
@@ -62,17 +64,20 @@ StoreMetaVary::deleteSelf()
     delete this;
 }
 
-bool 
+bool
 StoreMetaVary::checkConsistency(StoreEntry *e) const
 {
     assert (getType() == STORE_META_VARY_HEADERS);
+
     if (!e->mem_obj->vary_headers) {
-	/* XXX separate this mutator from the query */
-	/* Assume the object is OK.. remember the vary request headers */
-	e->mem_obj->vary_headers = xstrdup((char *)value);
-	return true;
+        /* XXX separate this mutator from the query */
+        /* Assume the object is OK.. remember the vary request headers */
+        e->mem_obj->vary_headers = xstrdup((char *)value);
+        return true;
     }
+
     if (strcmp(e->mem_obj->vary_headers, (char *)value) != 0)
-	return false;
+        return false;
+
     return true;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StoreMetaVary.h,v 1.1 2003/01/23 00:37:15 robertc Exp $
+ * $Id: StoreMetaVary.h,v 1.2 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -36,15 +36,18 @@
 
 #include "StoreMeta.h"
 
-class StoreMetaVary : public StoreMeta {
+class StoreMetaVary : public StoreMeta
+{
+
 public:
     void *operator new (size_t);
     void operator delete (void *);
     void deleteSelf();
-    
+
     char getType() const {return STORE_META_VARY_HEADERS;}
+
     bool checkConsistency(StoreEntry *) const;
-    
+
 private:
     static MemPool *pool;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: String.cc,v 1.12 2003/01/23 00:37:15 robertc Exp $
+ * $Id: String.cc,v 1.13 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 67    String
  * AUTHOR: Duane Wessels
@@ -49,10 +49,11 @@ void
 String::init(char const *str)
 {
     assert(this);
+
     if (str)
-	limitInit(str, strlen(str));
+        limitInit(str, strlen(str));
     else
-	clean();
+        clean();
 }
 
 String::String (char const *aString) : size_(0), len_(0), buf_(NULL)
@@ -72,11 +73,13 @@ String &
 String::operator = (String const &old)
 {
     clean ();
+
     if (old.len_)
-	limitInit (old.buf_, old.len_);
+        limitInit (old.buf_, old.len_);
+
     return *this;
 }
-  
+
 void
 String::limitInit(const char *str, int len)
 {
@@ -96,10 +99,14 @@ void
 String::clean()
 {
     assert(this);
+
     if (buf_)
-	memFreeString(size_, buf_);
+        memFreeString(size_, buf_);
+
     len_ = 0;
+
     size_ = 0;
+
     buf_ = NULL;
 }
 
@@ -120,19 +127,24 @@ String::append(const char *str, int len)
 {
     assert(this);
     assert(str && len >= 0);
+
     if (len_ + len < size_) {
-	strncat(buf_, str, len);
-	len_ += len;
+        strncat(buf_, str, len);
+        len_ += len;
     } else {
-	String snew;
-	snew.len_ = len_ + len;
-	snew.initBuf(snew.len_ + 1);
-	if (buf_)
-	    xmemcpy(snew.buf_, buf_, len_);
-	if (len)
-	    xmemcpy(snew.buf_ + len_, str, len);
-	snew.buf_[snew.len_] = '\0';
-	absorb(snew);
+        String snew;
+        snew.len_ = len_ + len;
+        snew.initBuf(snew.len_ + 1);
+
+        if (buf_)
+            xmemcpy(snew.buf_, buf_, len_);
+
+        if (len)
+            xmemcpy(snew.buf_ + len_, str, len);
+
+        snew.buf_[snew.len_] = '\0';
+
+        absorb(snew);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: SwapDir.cc,v 1.2 2003/01/23 00:37:15 robertc Exp $
+ * $Id: SwapDir.cc,v 1.3 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section ??    Swap Dir base object
  * AUTHOR: Robert Collins
@@ -45,7 +45,8 @@ SwapDir::Factory (_storefs_entry const &fs)
     return result;
 }
 
-SwapDir::~SwapDir() {
+SwapDir::~SwapDir()
+{
     xfree(path);
 }
 
@@ -90,17 +91,23 @@ bool
 SwapDir::canLog(StoreEntry const &e)const
 {
     if (e.swap_filen < 0)
-	return false;
+        return false;
+
     if (e.swap_status != SWAPOUT_DONE)
-	return false;
+        return false;
+
     if (e.swap_file_sz <= 0)
-	return false;
+        return false;
+
     if (EBIT_TEST(e.flags, RELEASE_REQUEST))
-	return false;
+        return false;
+
     if (EBIT_TEST(e.flags, KEY_PRIVATE))
-	return false;
+        return false;
+
     if (EBIT_TEST(e.flags, ENTRY_SPECIAL))
-	return false;
+        return false;
+
     return true;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: SwapDir.h,v 1.2 2003/01/23 00:37:15 robertc Exp $
+ * $Id: SwapDir.h,v 1.3 2003/02/21 22:50:06 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -41,12 +41,17 @@
 typedef void STFSSTARTUP(void);
 typedef void STFSSHUTDOWN(void);
 typedef SwapDir *STFSNEW(void);
-struct SwapDir {
+
+struct SwapDir
+{
+
 public:
     static SwapDir *Factory (_storefs_entry const &fs);
-    SwapDir() : max_objsize (-1){
-	fs.blksize = 1024;
+    SwapDir() : max_objsize (-1)
+    {
+        fs.blksize = 1024;
     }
+
     virtual ~SwapDir();
     virtual void reconfigure(int, char *) = 0;
     const char *type;
@@ -59,10 +64,18 @@ struct SwapDir {
     RemovalPolicy *repl;
     int removals;
     int scanned;
-    struct {
-	unsigned int selected:1;
-	unsigned int read_only:1;
-    } flags;
+
+    struct
+    {
+
+unsigned int selected:
+        1;
+
+unsigned int read_only:
+        1;
+    }
+
+    flags;
     virtual void init() = 0;	/* Initialise the fs */
     virtual void newFileSystem();	/* Create a new fs */
     virtual void dump(StoreEntry &)const;	/* Dump fs config snippet */
@@ -83,18 +96,28 @@ struct SwapDir {
     virtual void openLog();
     virtual void closeLog();
     virtual void logEntry(const StoreEntry & e, int op) const;
-    class CleanLog {
-      public:
-	virtual ~CleanLog(){}
-	virtual const StoreEntry *nextEntry() = 0;
-	virtual void write(StoreEntry const &) = 0;
+
+    class CleanLog
+    {
+
+    public:
+        virtual ~CleanLog(){}
+
+        virtual const StoreEntry *nextEntry() = 0;
+        virtual void write(StoreEntry const &) = 0;
     };
+
     CleanLog *cleanLog;
     virtual int writeCleanStart();
     virtual void writeCleanDone();
     virtual void parse(int index, char *path) = 0;
-    struct {
-	int blksize;
-    } fs;
+
+    struct
+    {
+        int blksize;
+    }
+
+    fs;
 };
+
 #endif /* SQUID_SWAPDIR_H */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.79 2003/01/23 00:37:15 robertc Exp $
+ * $Id: access_log.cc,v 1.80 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -45,42 +45,47 @@ static Logfile *headerslog = NULL;
 
 #if MULTICAST_MISS_STREAM
 static int mcast_miss_fd = -1;
+
 static struct sockaddr_in mcast_miss_to;
 static void mcast_encode(unsigned int *, size_t, const unsigned int *);
 #endif
 
 const char *log_tags[] =
-{
-    "NONE",
-    "TCP_HIT",
-    "TCP_MISS",
-    "TCP_REFRESH_HIT",
-    "TCP_REF_FAIL_HIT",
-    "TCP_REFRESH_MISS",
-    "TCP_CLIENT_REFRESH_MISS",
-    "TCP_IMS_HIT",
-    "TCP_SWAPFAIL_MISS",
-    "TCP_NEGATIVE_HIT",
-    "TCP_MEM_HIT",
-    "TCP_DENIED",
-    "TCP_OFFLINE_HIT",
+    {
+        "NONE",
+        "TCP_HIT",
+        "TCP_MISS",
+        "TCP_REFRESH_HIT",
+        "TCP_REF_FAIL_HIT",
+        "TCP_REFRESH_MISS",
+        "TCP_CLIENT_REFRESH_MISS",
+        "TCP_IMS_HIT",
+        "TCP_SWAPFAIL_MISS",
+        "TCP_NEGATIVE_HIT",
+        "TCP_MEM_HIT",
+        "TCP_DENIED",
+        "TCP_OFFLINE_HIT",
 #if LOG_TCP_REDIRECTS
-    "TCP_REDIRECT",
+        "TCP_REDIRECT",
 #endif
-    "UDP_HIT",
-    "UDP_MISS",
-    "UDP_DENIED",
-    "UDP_INVALID",
-    "UDP_MISS_NOFETCH",
-    "ICP_QUERY",
-    "LOG_TYPE_MAX"
-};
+        "UDP_HIT",
+        "UDP_MISS",
+        "UDP_DENIED",
+        "UDP_INVALID",
+        "UDP_MISS_NOFETCH",
+        "ICP_QUERY",
+        "LOG_TYPE_MAX"
+    };
 
 #if FORW_VIA_DB
-typedef struct {
+
+typedef struct
+{
     hash_link hash;
     int n;
-} fvdb_entry;
+}
+
+fvdb_entry;
 static hash_table *via_table = NULL;
 static hash_table *forw_table = NULL;
 static void fvdbInit(void);
@@ -96,22 +101,22 @@ static int LogfileStatus = LOG_DISABLE;
 #define LOG_BUF_SZ (MAX_URL<<2)
 
 static const char c2x[] =
-"000102030405060708090a0b0c0d0e0f"
-"101112131415161718191a1b1c1d1e1f"
-"202122232425262728292a2b2c2d2e2f"
-"303132333435363738393a3b3c3d3e3f"
-"404142434445464748494a4b4c4d4e4f"
-"505152535455565758595a5b5c5d5e5f"
-"606162636465666768696a6b6c6d6e6f"
-"707172737475767778797a7b7c7d7e7f"
-"808182838485868788898a8b8c8d8e8f"
-"909192939495969798999a9b9c9d9e9f"
-"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
-"b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
-"c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
-"d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
-"e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
-"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
+    "000102030405060708090a0b0c0d0e0f"
+    "101112131415161718191a1b1c1d1e1f"
+    "202122232425262728292a2b2c2d2e2f"
+    "303132333435363738393a3b3c3d3e3f"
+    "404142434445464748494a4b4c4d4e4f"
+    "505152535455565758595a5b5c5d5e5f"
+    "606162636465666768696a6b6c6d6e6f"
+    "707172737475767778797a7b7c7d7e7f"
+    "808182838485868788898a8b8c8d8e8f"
+    "909192939495969798999a9b9c9d9e9f"
+    "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
+    "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
+    "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
+    "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
+    "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
+    "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
 
 /* log_quote -- URL-style encoding on MIME headers. */
 
@@ -122,11 +127,13 @@ log_quote(const char *header)
     int i;
     char *buf;
     char *buf_cursor;
+
     if (header == NULL) {
-	buf = static_cast<char *>(xcalloc(1, 1));
-	*buf = '\0';
-	return buf;
+        buf = static_cast<char *>(xcalloc(1, 1));
+        *buf = '\0';
+        return buf;
     }
+
     buf = static_cast<char *>(xcalloc(1, (strlen(header) * 3) + 1));
     buf_cursor = buf;
     /*
@@ -135,49 +142,54 @@ log_quote(const char *header)
      * modulo the inclusion of space (x40) to make the raw logs a bit
      * more readable.
      */
+
     while ((c = *(const unsigned char *) header++) != '\0') {
 #if !OLD_LOG_MIME
-	if (c == '\r') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'r';
-	} else if (c == '\n') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'n';
-	} else
+
+        if (c == '\r') {
+            *buf_cursor++ = '\\';
+            *buf_cursor++ = 'r';
+        } else if (c == '\n') {
+            *buf_cursor++ = '\\';
+            *buf_cursor++ = 'n';
+        } else
 #endif
-	    if (c <= 0x1F
-		|| c >= 0x7F
+            if (c <= 0x1F
+                    || c >= 0x7F
 #if OLD_LOG_MIME
-		|| c == '"'
-		|| c == '#'
-		|| c == '%'
-		|| c == ';'
-		|| c == '<'
-		|| c == '>'
-		|| c == '?'
-		|| c == '{'
-		|| c == '}'
-		|| c == '|'
-		|| c == '\\'
-		|| c == '^'
-		|| c == '~'
-		|| c == '`'
+                    || c == '"'
+                    || c == '#'
+                    || c == '%'
+                    || c == ';'
+                    || c == '<'
+                    || c == '>'
+                    || c == '?'
+                    || c == '{'
+                    || c == '}'
+                    || c == '|'
+                    || c == '\\'
+                    || c == '^'
+                    || c == '~'
+                    || c == '`'
 #endif
-		|| c == '['
-	    || c == ']') {
-	    *buf_cursor++ = '%';
-	    i = c * 2;
-	    *buf_cursor++ = c2x[i];
-	    *buf_cursor++ = c2x[i + 1];
+                    || c == '['
+                    || c == ']') {
+                *buf_cursor++ = '%';
+                i = c * 2;
+                *buf_cursor++ = c2x[i];
+                *buf_cursor++ = c2x[i + 1];
 #if !OLD_LOG_MIME
-	} else if (c == '\\') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = '\\';
+
+            } else if (c == '\\') {
+                *buf_cursor++ = '\\';
+                *buf_cursor++ = '\\';
 #endif
-	} else {
-	    *buf_cursor++ = (char) c;
-	}
+
+            } else {
+                *buf_cursor++ = (char) c;
+            }
     }
+
     *buf_cursor = '\0';
     return buf;
 }
@@ -190,35 +202,39 @@ username_quote(const char *header)
     int i;
     char *buf;
     char *buf_cursor;
+
     if (header == NULL) {
-	buf = static_cast<char *>(xcalloc(1, 1));
-	*buf = '\0';
-	return buf;
+        buf = static_cast<char *>(xcalloc(1, 1));
+        *buf = '\0';
+        return buf;
     }
+
     buf = static_cast<char *>(xcalloc(1, (strlen(header) * 3) + 1));
     buf_cursor = buf;
     /*
      * We escape: space \x00-\x1F and space (0x40) and \x7F-\xFF
      * to prevent garbage in the logs. CR and LF are also there just in case. 
      */
+
     while ((c = *(const unsigned char *) header++) != '\0') {
-	if (c == '\r') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'r';
-	} else if (c == '\n') {
-	    *buf_cursor++ = '\\';
-	    *buf_cursor++ = 'n';
-	} else if (c <= 0x1F
-		|| c >= 0x7F
-	    || c == ' ') {
-	    *buf_cursor++ = '%';
-	    i = c * 2;
-	    *buf_cursor++ = c2x[i];
-	    *buf_cursor++ = c2x[i + 1];
-	} else {
-	    *buf_cursor++ = (char) c;
-	}
+        if (c == '\r') {
+            *buf_cursor++ = '\\';
+            *buf_cursor++ = 'r';
+        } else if (c == '\n') {
+            *buf_cursor++ = '\\';
+            *buf_cursor++ = 'n';
+        } else if (c <= 0x1F
+                   || c >= 0x7F
+                   || c == ' ') {
+            *buf_cursor++ = '%';
+            i = c * 2;
+            *buf_cursor++ = c2x[i];
+            *buf_cursor++ = c2x[i + 1];
+        } else {
+            *buf_cursor++ = (char) c;
+        }
     }
+
     *buf_cursor = '\0';
     return buf;
 }
@@ -227,7 +243,8 @@ static char *
 accessLogFormatName(const char *name)
 {
     if (NULL == name)
-	return NULL;
+        return NULL;
+
     return username_quote(name);
 }
 
@@ -236,34 +253,44 @@ accessLogSquid(AccessLogEntry * al)
 {
     const char *client = NULL;
     const char *user = NULL;
+
     if (Config.onoff.log_fqdn)
-	client = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
+        client = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
+
     if (client == NULL)
-	client = inet_ntoa(al->cache.caddr);
+        client = inet_ntoa(al->cache.caddr);
+
     user = accessLogFormatName(al->cache.authuser);
+
 #if USE_SSL
+
     if (!user)
-	user = accessLogFormatName(al->cache.ssluser);
+        user = accessLogFormatName(al->cache.ssluser);
+
 #endif
+
     if (!user)
-	user = accessLogFormatName(al->cache.rfc931);
+        user = accessLogFormatName(al->cache.rfc931);
+
     if (user && !*user)
-	safe_free(user);
+        safe_free(user);
+
     logfilePrintf(logfile, "%9d.%03d %6d %s %s/%03d %ld %s %s %s %s%s/%s %s",
-	(int) current_time.tv_sec,
-	(int) current_time.tv_usec / 1000,
-	al->cache.msec,
-	client,
-	log_tags[al->cache.code],
-	al->http.code,
-	(long int) al->cache.size,
-	al->_private.method_str,
-	al->url,
-	user ? user : dash_str,
-	al->hier.ping.timedout ? "TIMEOUT_" : "",
-	hier_strings[al->hier.code],
-	al->hier.host,
-	al->http.content_type);
+                  (int) current_time.tv_sec,
+                  (int) current_time.tv_usec / 1000,
+                  al->cache.msec,
+                  client,
+                  log_tags[al->cache.code],
+                  al->http.code,
+                  (long int) al->cache.size,
+                  al->_private.method_str,
+                  al->url,
+                  user ? user : dash_str,
+                  al->hier.ping.timedout ? "TIMEOUT_" : "",
+                  hier_strings[al->hier.code],
+                  al->hier.host,
+                  al->http.content_type);
+
     safe_free(user);
 }
 
@@ -272,78 +299,96 @@ accessLogCommon(AccessLogEntry * al)
 {
     const char *client = NULL;
     char *user1 = NULL, *user2 = NULL;
+
     if (Config.onoff.log_fqdn)
-	client = fqdncache_gethostbyaddr(al->cache.caddr, 0);
+        client = fqdncache_gethostbyaddr(al->cache.caddr, 0);
+
     if (client == NULL)
-	client = inet_ntoa(al->cache.caddr);
+        client = inet_ntoa(al->cache.caddr);
+
     user1 = accessLogFormatName(al->cache.authuser);
+
     user2 = accessLogFormatName(al->cache.rfc931);
+
     logfilePrintf(logfile, "%s %s %s [%s] \"%s %s HTTP/%d.%d\" %d %ld %s:%s",
-	client,
-	user2 ? user2 : dash_str,
-	user1 ? user1 : dash_str,
-	mkhttpdlogtime(&squid_curtime),
-	al->_private.method_str,
-	al->url,
-	al->http.version.major, al->http.version.minor,
-	al->http.code,
-	(long int) al->cache.size,
-	log_tags[al->cache.code],
-	hier_strings[al->hier.code]);
+                  client,
+                  user2 ? user2 : dash_str,
+                  user1 ? user1 : dash_str,
+                  mkhttpdlogtime(&squid_curtime),
+                  al->_private.method_str,
+                  al->url,
+                  al->http.version.major, al->http.version.minor,
+                  al->http.code,
+                  (long int) al->cache.size,
+                  log_tags[al->cache.code],
+                  hier_strings[al->hier.code]);
+
     safe_free(user1);
+
     safe_free(user2);
 }
 
 void
 accessLogLog(AccessLogEntry * al)
 {
     if (LogfileStatus != LOG_ENABLE)
-	return;
+        return;
+
     if (al->url == NULL)
-	al->url = dash_str;
+        al->url = dash_str;
+
     if (!al->http.content_type || *al->http.content_type == '\0')
-	al->http.content_type = dash_str;
+        al->http.content_type = dash_str;
+
     if (al->icp.opcode)
-	al->_private.method_str = icp_opcode_str[al->icp.opcode];
+        al->_private.method_str = icp_opcode_str[al->icp.opcode];
     else
-	al->_private.method_str = RequestMethodStr[al->http.method];
+        al->_private.method_str = RequestMethodStr[al->http.method];
+
     if (al->hier.host[0] == '\0')
-	xstrncpy(al->hier.host, dash_str, SQUIDHOSTNAMELEN);
+        xstrncpy(al->hier.host, dash_str, SQUIDHOSTNAMELEN);
 
     if (Config.onoff.common_log)
-	accessLogCommon(al);
+        accessLogCommon(al);
     else
-	accessLogSquid(al);
+        accessLogSquid(al);
+
     if (Config.onoff.log_mime_hdrs) {
-	char *ereq = log_quote(al->headers.request);
-	char *erep = log_quote(al->headers.reply);
-	logfilePrintf(logfile, " [%s] [%s]\n", ereq, erep);
-	safe_free(ereq);
-	safe_free(erep);
+        char *ereq = log_quote(al->headers.request);
+        char *erep = log_quote(al->headers.reply);
+        logfilePrintf(logfile, " [%s] [%s]\n", ereq, erep);
+        safe_free(ereq);
+        safe_free(erep);
     } else {
-	logfilePrintf(logfile, "\n");
+        logfilePrintf(logfile, "\n");
     }
+
     logfileFlush(logfile);
 #if MULTICAST_MISS_STREAM
+
     if (al->cache.code != LOG_TCP_MISS)
-	(void) 0;
+        (void) 0;
     else if (al->http.method != METHOD_GET)
-	(void) 0;
+        (void) 0;
     else if (mcast_miss_fd < 0)
-	(void) 0;
+        (void) 0;
     else {
-	unsigned int ibuf[365];
-	size_t isize;
-	xstrncpy((char *) ibuf, al->url, 364 * sizeof(int));
-	isize = ((strlen(al->url) + 8) / 8) * 2;
-	if (isize > 364)
-	    isize = 364;
-	mcast_encode((unsigned int *) ibuf, isize,
-	    (const unsigned int *) Config.mcast_miss.encode_key);
-	comm_udp_sendto(mcast_miss_fd,
-	    &mcast_miss_to, sizeof(mcast_miss_to),
-	    ibuf, isize * sizeof(int));
+        unsigned int ibuf[365];
+        size_t isize;
+        xstrncpy((char *) ibuf, al->url, 364 * sizeof(int));
+        isize = ((strlen(al->url) + 8) / 8) * 2;
+
+        if (isize > 364)
+            isize = 364;
+
+        mcast_encode((unsigned int *) ibuf, isize,
+                     (const unsigned int *) Config.mcast_miss.encode_key);
+
+        comm_udp_sendto(mcast_miss_fd,
+                        &mcast_miss_to, sizeof(mcast_miss_to),
+                        ibuf, isize * sizeof(int));
     }
+
 #endif
 }
 
@@ -353,31 +398,42 @@ accessLogRotate(void)
 #if FORW_VIA_DB
     fvdbClear();
 #endif
+
     if (NULL == logfile)
-	return;
+        return;
+
     logfileRotate(logfile);
+
 #if HEADERS_LOG
+
     logfileRotate(headerslog);
+
 #endif
 }
 
 void
 accessLogClose(void)
 {
     if (NULL == logfile)
-	return;
+        return;
+
     logfileClose(logfile);
+
     logfile = NULL;
+
 #if HEADERS_LOG
+
     logfileClose(headerslog);
+
     headerslog = NULL;
+
 #endif
 }
 
 void
 hierarchyNote(HierarchyLogEntry * hl,
-    hier_code code,
-    const char *cache_peer)
+              hier_code code,
+              const char *cache_peer)
 {
     assert(hl != NULL);
     hl->code = code;
@@ -388,51 +444,69 @@ void
 accessLogInit(void)
 {
     assert(sizeof(log_tags) == (LOG_TYPE_MAX + 1) * sizeof(char *));
+
     if (strcasecmp(Config.Log.access, "none") == 0)
-	return;
+        return;
+
     logfile = logfileOpen(Config.Log.access, MAX_URL << 1, 1);
+
     LogfileStatus = LOG_ENABLE;
+
 #if HEADERS_LOG
+
     headerslog = logfileOpen("/usr/local/squid/logs/headers.log", 512);
+
     assert(NULL != headerslog);
+
 #endif
 #if FORW_VIA_DB
+
     fvdbInit();
+
 #endif
 #if MULTICAST_MISS_STREAM
+
     if (Config.mcast_miss.addr.s_addr != no_addr.s_addr) {
-	memset(&mcast_miss_to, '\0', sizeof(mcast_miss_to));
-	mcast_miss_to.sin_family = AF_INET;
-	mcast_miss_to.sin_port = htons(Config.mcast_miss.port);
-	mcast_miss_to.sin_addr.s_addr = Config.mcast_miss.addr.s_addr;
-	mcast_miss_fd = comm_open(SOCK_DGRAM,
-	    0,
-	    Config.Addrs.udp_incoming,
-	    Config.mcast_miss.port,
-	    COMM_NONBLOCKING,
-	    "Multicast Miss Stream");
-	if (mcast_miss_fd < 0)
-	    fatal("Cannot open Multicast Miss Stream Socket");
-	debug(46, 1) ("Multicast Miss Stream Socket opened on FD %d\n",
-	    mcast_miss_fd);
-	mcastSetTtl(mcast_miss_fd, Config.mcast_miss.ttl);
-	if (strlen(Config.mcast_miss.encode_key) < 16)
-	    fatal("mcast_encode_key is too short, must be 16 characters");
+        memset(&mcast_miss_to, '\0', sizeof(mcast_miss_to));
+        mcast_miss_to.sin_family = AF_INET;
+        mcast_miss_to.sin_port = htons(Config.mcast_miss.port);
+        mcast_miss_to.sin_addr.s_addr = Config.mcast_miss.addr.s_addr;
+        mcast_miss_fd = comm_open(SOCK_DGRAM,
+                                  0,
+                                  Config.Addrs.udp_incoming,
+                                  Config.mcast_miss.port,
+                                  COMM_NONBLOCKING,
+                                  "Multicast Miss Stream");
+
+        if (mcast_miss_fd < 0)
+            fatal("Cannot open Multicast Miss Stream Socket");
+
+        debug(46, 1) ("Multicast Miss Stream Socket opened on FD %d\n",
+                      mcast_miss_fd);
+
+        mcastSetTtl(mcast_miss_fd, Config.mcast_miss.ttl);
+
+        if (strlen(Config.mcast_miss.encode_key) < 16)
+            fatal("mcast_encode_key is too short, must be 16 characters");
     }
+
 #endif
 }
 
 const char *
 accessLogTime(time_t t)
 {
+
     struct tm *tm;
     static char buf[128];
     static time_t last_t = 0;
+
     if (t != last_t) {
-	tm = localtime(&t);
-	strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
-	last_t = t;
+        tm = localtime(&t);
+        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
+        last_t = t;
     }
+
     return buf;
 }
 
@@ -446,21 +520,25 @@ fvdbInit(void)
     forw_table = hash_create((HASHCMP *) strcmp, 977, hash4);
     cachemgrRegister("via_headers", "Via Request Headers", fvdbDumpVia, 0, 1);
     cachemgrRegister("forw_headers", "X-Forwarded-For Request Headers",
-	fvdbDumpForw, 0, 1);
+                     fvdbDumpForw, 0, 1);
 }
 
 static void
 fvdbCount(hash_table * hash, const char *key)
 {
     fvdb_entry *fv;
+
     if (NULL == hash)
-	return;
+        return;
+
     fv = hash_lookup(hash, key);
+
     if (NULL == fv) {
-	fv = static_cast <fvdb_entry *>(xcalloc(1, sizeof(fvdb_entry)));
-	fv->hash.key = xstrdup(key);
-	hash_join(hash, &fv->hash);
+        fv = static_cast <fvdb_entry *>(xcalloc(1, sizeof(fvdb_entry)));
+        fv->hash.key = xstrdup(key);
+        hash_join(hash, &fv->hash);
     }
+
     fv->n++;
 }
 
@@ -481,12 +559,15 @@ fvdbDumpTable(StoreEntry * e, hash_table * hash)
 {
     hash_link *h;
     fvdb_entry *fv;
+
     if (hash == NULL)
-	return;
+        return;
+
     hash_first(hash);
+
     while ((h = hash_next(hash))) {
-	fv = (fvdb_entry *) h;
-	storeAppendPrintf(e, "%9d %s\n", fv->n, hashKeyStr(&fv->hash));
+        fv = (fvdb_entry *) h;
+        storeAppendPrintf(e, "%9d %s\n", fv->n, hashKeyStr(&fv->hash));
     }
 }
 
@@ -546,17 +627,20 @@ mcast_encode(unsigned int *ibuf, size_t isize, const unsigned int *key)
     const unsigned int k2 = htonl(key[2]);
     const unsigned int k3 = htonl(key[3]);
     int i;
+
     for (i = 0; i < isize; i += 2) {
-	y = htonl(ibuf[i]);
-	z = htonl(ibuf[i + 1]);
-	sum = 0;
-	for (n = 32; n; n--) {
-	    sum += delta;
-	    y += (z << 4) + (k0 ^ z) + (sum ^ (z >> 5)) + k1;
-	    z += (y << 4) + (k2 ^ y) + (sum ^ (y >> 5)) + k3;
-	}
-	ibuf[i] = htonl(y);
-	ibuf[i + 1] = htonl(z);
+        y = htonl(ibuf[i]);
+        z = htonl(ibuf[i + 1]);
+        sum = 0;
+
+        for (n = 32; n; n--) {
+            sum += delta;
+            y += (z << 4) + (k0 ^ z) + (sum ^ (z >> 5)) + k1;
+            z += (y << 4) + (k2 ^ y) + (sum ^ (y >> 5)) + k3;
+        }
+
+        ibuf[i] = htonl(y);
+        ibuf[i + 1] = htonl(z);
     }
 }
 
@@ -573,41 +657,53 @@ headersLog(int cs, int pq, method_t m, void *data)
     unsigned short S;
     char *hmask;
     int ccmask = 0;
+
     if (0 == pq) {
-	/* reply */
-	rep = data;
-	req = NULL;
-	magic = 0x0050;
-	hmask = rep->header.mask;
-	if (rep->cache_control)
-	    ccmask = rep->cache_control->mask;
+        /* reply */
+        rep = data;
+        req = NULL;
+        magic = 0x0050;
+        hmask = rep->header.mask;
+
+        if (rep->cache_control)
+            ccmask = rep->cache_control->mask;
     } else {
-	/* request */
-	req = data;
-	rep = NULL;
-	magic = 0x0051;
-	hmask = req->header.mask;
-	if (req->cache_control)
-	    ccmask = req->cache_control->mask;
+        /* request */
+        req = data;
+        rep = NULL;
+        magic = 0x0051;
+        hmask = req->header.mask;
+
+        if (req->cache_control)
+            ccmask = req->cache_control->mask;
     }
+
     if (0 == cs) {
-	/* client */
-	magic |= 0x4300;
+        /* client */
+        magic |= 0x4300;
     } else {
-	/* server */
-	magic |= 0x5300;
+        /* server */
+        magic |= 0x5300;
     }
+
     magic = htons(magic);
     ccmask = htonl(ccmask);
+
     if (0 == pq)
-	S = (unsigned short) rep->sline.status;
+        S = (unsigned short) rep->sline.status;
     else
-	S = (unsigned short) HTTP_STATUS_NONE;
+        S = (unsigned short) HTTP_STATUS_NONE;
+
     logfileWrite(headerslog, &magic, sizeof(magic));
+
     logfileWrite(headerslog, &M, sizeof(M));
+
     logfileWrite(headerslog, &S, sizeof(S));
+
     logfileWrite(headerslog, hmask, sizeof(HttpHeaderMask));
+
     logfileWrite(headerslog, &ccmask, sizeof(int));
+
     logfileFlush(headerslog);
 }
 
@@ -625,20 +721,28 @@ int
 logTypeIsATcpHit(log_type code)
 {
     /* this should be a bitmap for better optimization */
+
     if (code == LOG_TCP_HIT)
-	return 1;
+        return 1;
+
     if (code == LOG_TCP_IMS_HIT)
-	return 1;
+        return 1;
+
     if (code == LOG_TCP_REFRESH_FAIL_HIT)
-	return 1;
+        return 1;
+
     if (code == LOG_TCP_REFRESH_HIT)
-	return 1;
+        return 1;
+
     if (code == LOG_TCP_NEGATIVE_HIT)
-	return 1;
+        return 1;
+
     if (code == LOG_TCP_MEM_HIT)
-	return 1;
+        return 1;
+
     if (code == LOG_TCP_OFFLINE_HIT)
-	return 1;
+        return 1;
+
     return 0;
 }
 
@@ -1,5 +1,5 @@
 /*
- * $Id: acl.cc,v 1.304 2003/02/17 07:01:35 robertc Exp $
+ * $Id: acl.cc,v 1.305 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -57,6 +57,7 @@ static int aclMatchWordList(wordlist *, const char *);
 static void aclParseUserMaxIP(void *data);
 static void aclDestroyUserMaxIP(void *data);
 static wordlist *aclDumpUserMaxIP(void *data);
+
 static int aclMatchUserMaxIP(void *, auth_user_request_t *, struct in_addr);
 static squid_acl aclStrToType(const char *s);
 static wordlist *aclDumpIntlistList(intlist * data);
@@ -68,6 +69,7 @@ static wordlist *aclDumpMethodList(intlist * data);
 #if USE_ARP_ACL
 static void aclParseArpList(void *curlist);
 static int decode_eth(const char *asc, char *eth);
+
 static int aclMatchArp(void *dataptr, struct in_addr c);
 static wordlist *aclDumpArpList(void *);
 static splayNode::SPLAYCMP aclArpCompare;
@@ -80,8 +82,10 @@ ACL::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACL));
+
     if (!Pool)
-	Pool = memPoolCreate("ACL", sizeof (ACL));
+        Pool = memPoolCreate("ACL", sizeof (ACL));
+
     return memPoolAlloc(Pool);
 }
 
@@ -116,37 +120,54 @@ static squid_acl
 aclStrToType(const char *s)
 {
     if (!strcmp(s, "port"))
-	return ACL_URL_PORT;
+        return ACL_URL_PORT;
+
     if (!strcmp(s, "myport"))
-	return ACL_MY_PORT;
+        return ACL_MY_PORT;
+
     if (!strcmp(s, "maxconn"))
-	return ACL_MAXCONN;
+        return ACL_MAXCONN;
+
     if (!strncmp(s, "proto", 5))
-	return ACL_PROTO;
+        return ACL_PROTO;
+
     if (!strcmp(s, "method"))
-	return ACL_METHOD;
+        return ACL_METHOD;
+
     if (!strcmp(s, "src_as"))
-	return ACL_SRC_ASN;
+        return ACL_SRC_ASN;
+
     if (!strcmp(s, "dst_as"))
-	return ACL_DST_ASN;
+        return ACL_DST_ASN;
+
 #if SQUID_SNMP
+
     if (!strcmp(s, "snmp_community"))
-	return ACL_SNMP_COMMUNITY;
+        return ACL_SNMP_COMMUNITY;
+
 #endif
 #if SRC_RTT_NOT_YET_FINISHED
+
     if (!strcmp(s, "src_rtt"))
-	return ACL_NETDB_SRC_RTT;
+        return ACL_NETDB_SRC_RTT;
+
 #endif
 #if USE_ARP_ACL
+
     if (!strcmp(s, "arp"))
-	return ACL_SRC_ARP;
+        return ACL_SRC_ARP;
+
 #endif
+
     if (!strcmp(s, "rep_mime_type"))
-	return ACL_REP_MIME_TYPE;
+        return ACL_REP_MIME_TYPE;
+
     if (!strcmp(s, "max_user_ip"))
-	return ACL_MAX_USER_IP;
+        return ACL_MAX_USER_IP;
+
     if (!strcmp(s, "external"))
-	return ACL_EXTERNAL;
+        return ACL_EXTERNAL;
+
     return ACL_NONE;
 }
 
@@ -155,47 +176,66 @@ const char *
 aclTypeToStr(squid_acl type)
 {
     if (type == ACL_URL_PORT)
-	return "port";
+        return "port";
+
     if (type == ACL_MY_PORT)
-	return "myport";
+        return "myport";
+
     if (type == ACL_MAXCONN)
-	return "maxconn";
+        return "maxconn";
+
     if (type == ACL_PROTO)
-	return "proto";
+        return "proto";
+
     if (type == ACL_METHOD)
-	return "method";
+        return "method";
+
     if (type == ACL_SRC_ASN)
-	return "src_as";
+        return "src_as";
+
     if (type == ACL_DST_ASN)
-	return "dst_as";
+        return "dst_as";
+
 #if SQUID_SNMP
+
     if (type == ACL_SNMP_COMMUNITY)
-	return "snmp_community";
+        return "snmp_community";
+
 #endif
 #if SRC_RTT_NOT_YET_FINISHED
+
     if (type == ACL_NETDB_SRC_RTT)
-	return "src_rtt";
+        return "src_rtt";
+
 #endif
 #if USE_ARP_ACL
+
     if (type == ACL_SRC_ARP)
-	return "arp";
+        return "arp";
+
 #endif
+
     if (type == ACL_REP_MIME_TYPE)
-	return "rep_mime_type";
+        return "rep_mime_type";
+
     if (type == ACL_MAX_USER_IP)
-	return "max_user_ip";
+        return "max_user_ip";
+
     if (type == ACL_EXTERNAL)
-	return "external";
+        return "external";
+
     return "ERROR";
 }
 
 acl *
 ACL::FindByName(const char *name)
 {
     acl *a;
+
     for (a = Config.aclList; a; a = a->next)
-	if (!strcasecmp(a->name, name))
-	    return a;
+        if (!strcasecmp(a->name, name))
+            return a;
+
     return NULL;
 }
 
@@ -205,12 +245,15 @@ aclParseIntlist(void *curlist)
     intlist **Tail;
     intlist *q = NULL;
     char *t = NULL;
-    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next));
+
+    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next))
+
+        ;
     while ((t = strtokFile())) {
-	q = (intlist *)memAllocate(MEM_INTLIST);
-	q->i = atoi(t);
-	*(Tail) = q;
-	Tail = &q->next;
+        q = (intlist *)memAllocate(MEM_INTLIST);
+        q->i = atoi(t);
+        *(Tail) = q;
+        Tail = &q->next;
     }
 }
 
@@ -220,17 +263,23 @@ aclParseIntRange(void *curlist)
     intrange **Tail;
     intrange *q = NULL;
     char *t = NULL;
-    for (Tail = (intrange **)curlist; *Tail; Tail = &((*Tail)->next));
+
+    for (Tail = (intrange **)curlist; *Tail; Tail = &((*Tail)->next))
+
+        ;
     while ((t = strtokFile())) {
-	q = (intrange *)xcalloc(1, sizeof(intrange));
-	q->i = atoi(t);
-	t = strchr(t, '-');
-	if (t && *(++t))
-	    q->j = atoi(t);
-	else
-	    q->j = q->i;
-	*(Tail) = q;
-	Tail = &q->next;
+        q = (intrange *)xcalloc(1, sizeof(intrange));
+        q->i = atoi(t);
+        t = strchr(t, '-');
+
+        if (t && *(++t))
+            q->j = atoi(t);
+        else
+            q->j = q->i;
+
+        *(Tail) = q;
+
+        Tail = &q->next;
     }
 }
 
@@ -241,13 +290,16 @@ aclParseProtoList(void *curlist)
     intlist *q = NULL;
     char *t = NULL;
     protocol_t protocol;
-    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next));
+
+    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next))
+
+        ;
     while ((t = strtokFile())) {
-	protocol = urlParseProtocol(t);
-	q = (intlist *)memAllocate(MEM_INTLIST);
-	q->i = (int) protocol;
-	*(Tail) = q;
-	Tail = &q->next;
+        protocol = urlParseProtocol(t);
+        q = (intlist *)memAllocate(MEM_INTLIST);
+        q->i = (int) protocol;
+        *(Tail) = q;
+        Tail = &q->next;
     }
 }
 
@@ -257,12 +309,15 @@ aclParseMethodList(void *curlist)
     intlist **Tail;
     intlist *q = NULL;
     char *t = NULL;
-    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next));
+
+    for (Tail = (intlist **)curlist; *Tail; Tail = &((*Tail)->next))
+
+        ;
     while ((t = strtokFile())) {
-	q = (intlist *)memAllocate(MEM_INTLIST);
-	q->i = (int) urlParseMethod(t);
-	*(Tail) = q;
-	Tail = &q->next;
+        q = (intlist *)memAllocate(MEM_INTLIST);
+        q->i = (int) urlParseMethod(t);
+        *(Tail) = q;
+        Tail = &q->next;
     }
 }
 
@@ -275,30 +330,36 @@ aclParseRegexList(void *curlist)
     regex_t comp;
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
-    for (Tail = (relist **)curlist; *Tail; Tail = &((*Tail)->next));
+
+    for (Tail = (relist **)curlist; *Tail; Tail = &((*Tail)->next))
+
+        ;
     while ((t = strtokFile())) {
-	if (strcmp(t, "-i") == 0) {
-	    flags |= REG_ICASE;
-	    continue;
-	}
-	if (strcmp(t, "+i") == 0) {
-	    flags &= ~REG_ICASE;
-	    continue;
-	}
-	if ((errcode = regcomp(&comp, t, flags)) != 0) {
-	    char errbuf[256];
-	    regerror(errcode, &comp, errbuf, sizeof errbuf);
-	    debug(28, 0) ("%s line %d: %s\n",
-		cfg_filename, config_lineno, config_input_line);
-	    debug(28, 0) ("aclParseRegexList: Invalid regular expression '%s': %s\n",
-		t, errbuf);
-	    continue;
-	}
-	q = (relist *)memAllocate(MEM_RELIST);
-	q->pattern = xstrdup(t);
-	q->regex = comp;
-	*(Tail) = q;
-	Tail = &q->next;
+        if (strcmp(t, "-i") == 0) {
+            flags |= REG_ICASE;
+            continue;
+        }
+
+        if (strcmp(t, "+i") == 0) {
+            flags &= ~REG_ICASE;
+            continue;
+        }
+
+        if ((errcode = regcomp(&comp, t, flags)) != 0) {
+            char errbuf[256];
+            regerror(errcode, &comp, errbuf, sizeof errbuf);
+            debug(28, 0) ("%s line %d: %s\n",
+                          cfg_filename, config_lineno, config_input_line);
+            debug(28, 0) ("aclParseRegexList: Invalid regular expression '%s': %s\n",
+                          t, errbuf);
+            continue;
+        }
+
+        q = (relist *)memAllocate(MEM_RELIST);
+        q->pattern = xstrdup(t);
+        q->regex = comp;
+        *(Tail) = q;
+        Tail = &q->next;
     }
 }
 
@@ -307,55 +368,75 @@ static void
 aclParseWordList(void *curlist)
 {
     char *t = NULL;
+
     while ((t = strtokFile()))
-	wordlistAdd((wordlist **)curlist, t);
+        wordlistAdd((wordlist **)curlist, t);
 }
+
 #endif
 
 ACL *
 ACL::Factory (char const *type)
 {
     ACL *result = Prototype::Factory (type);
+
     if (result)
-	return result;
+        return result;
+
     squid_acl const acltype = aclStrToType(type);
+
     switch (acltype) {
-      case ACL_URL_PORT:
-      case ACL_MY_PORT:
-      case ACL_MAXCONN:
-      case ACL_PROTO:
-      case ACL_METHOD:
-      case ACL_SRC_ASN:
-      case ACL_DST_ASN:
+
+    case ACL_URL_PORT:
+
+    case ACL_MY_PORT:
+
+    case ACL_MAXCONN:
+
+    case ACL_PROTO:
+
+    case ACL_METHOD:
+
+    case ACL_SRC_ASN:
+
+    case ACL_DST_ASN:
 #if SQUID_SNMP
-      case ACL_SNMP_COMMUNITY:
+
+    case ACL_SNMP_COMMUNITY:
 #endif
 #if SRC_RTT_NOT_YET_FINISHED
-      case ACL_NETDB_SRC_RTT:
+
+    case ACL_NETDB_SRC_RTT:
 #endif
 #if USE_ARP_ACL
-      case ACL_SRC_ARP:
+
+    case ACL_SRC_ARP:
 #endif
-      case ACL_REP_MIME_TYPE:
-      case ACL_MAX_USER_IP:
-      case ACL_EXTERNAL:
-	result = new ACL(acltype);
-	break;
-      case ACL_DERIVED:
-      default:
-	fatal ("Unknown acl type in ACL::Factory");
+
+    case ACL_REP_MIME_TYPE:
+
+    case ACL_MAX_USER_IP:
+
+    case ACL_EXTERNAL:
+        result = new ACL(acltype);
+        break;
+
+    case ACL_DERIVED:
+
+    default:
+        fatal ("Unknown acl type in ACL::Factory");
     };
+
     assert (result);
+
     return result;
 }
 
 ACL::ACL (squid_acl const acltype) : type (acltype)
-{
-}
+{}
 
 ACL::ACL () : type(ACL_NONE)
-{
-}
+{}
 
 char const *
 ACL::typeString() const
@@ -374,41 +455,49 @@ ACL::ParseAclLine(acl ** head)
     int new_acl = 0;
 
     /* snarf the ACL name */
+
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseAclLine: missing ACL name.\n");
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseAclLine: missing ACL name.\n");
+        return;
     }
+
     xstrncpy(aclname, t, ACL_NAME_SZ);
     /* snarf the ACL type */
+
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseAclLine: missing ACL type.\n");
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseAclLine: missing ACL type.\n");
+        return;
     }
+
     if ((acltype = aclStrToType(t)) == ACL_NONE && !Prototype::Registered (t)) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseAclLine: Invalid ACL type '%s'\n", t);
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseAclLine: Invalid ACL type '%s'\n", t);
+        return;
     }
+
     if ((A = FindByName(aclname)) == NULL) {
-	debug(28, 3) ("aclParseAclLine: Creating ACL '%s'\n", aclname);
-	A = ACL::Factory(t);
-	xstrncpy(A->name, aclname, ACL_NAME_SZ);
-	A->cfgline = xstrdup(config_input_line);
-	new_acl = 1;
+        debug(28, 3) ("aclParseAclLine: Creating ACL '%s'\n", aclname);
+        A = ACL::Factory(t);
+        xstrncpy(A->name, aclname, ACL_NAME_SZ);
+        A->cfgline = xstrdup(config_input_line);
+        new_acl = 1;
     } else {
-	/* FIXME: strcmp the registry typeString */
-	if (acltype != ACL_NONE && acltype != A->aclType()) {
-	    debug(28, 0) ("aclParseAclLine: ACL '%s' already exists with different type, skipping.\n", A->name);
-	    return;
-	}
-	debug(28, 3) ("aclParseAclLine: Appending to '%s'\n", aclname);
-	new_acl = 0;
+        /* FIXME: strcmp the registry typeString */
+
+        if (acltype != ACL_NONE && acltype != A->aclType()) {
+            debug(28, 0) ("aclParseAclLine: ACL '%s' already exists with different type, skipping.\n", A->name);
+            return;
+        }
+
+        debug(28, 3) ("aclParseAclLine: Appending to '%s'\n", aclname);
+        new_acl = 0;
     }
+
     /*
      * Here we set AclMatchedName in case we need to use it in a
      * warning message in aclDomainCompare().
@@ -417,23 +506,28 @@ ACL::ParseAclLine(acl ** head)
 
     /*split the function here */
     A->parse();
+
     /*
      * Clear AclMatchedName from our temporary hack
      */
     AclMatchedName = NULL;	/* ugly */
+
     if (!new_acl)
-	return;
+        return;
+
     if (!A->valid()) {
-	debug(28, 0) ("aclParseAclLine: IGNORING invalid ACL: %s\n",
-	    A->cfgline);
-	A->deleteSelf();
-	/* Do we need this? */
-	A = NULL;
-	return;
+        debug(28, 0) ("aclParseAclLine: IGNORING invalid ACL: %s\n",
+                      A->cfgline);
+        A->deleteSelf();
+        /* Do we need this? */
+        A = NULL;
+        return;
     }
+
     /* append */
     while (*head)
-	head = &(*head)->next;
+        head = &(*head)->next;
+
     *head = A;
 }
 
@@ -445,54 +539,70 @@ ACL::valid () const
 
 void
 ACL::parse()
-{    
+{
     switch (aclType()) {
+
     case ACL_REP_MIME_TYPE:
-	aclParseRegexList(&data);
-	break;
+        aclParseRegexList(&data);
+        break;
+
     case ACL_SRC_ASN:
+
     case ACL_MAXCONN:
+
     case ACL_DST_ASN:
-	aclParseIntlist(&data);
-	break;
+        aclParseIntlist(&data);
+        break;
+
     case ACL_MAX_USER_IP:
-	aclParseUserMaxIP(&data);
-	break;
+        aclParseUserMaxIP(&data);
+        break;
 #if SRC_RTT_NOT_YET_FINISHED
+
     case ACL_NETDB_SRC_RTT:
-	aclParseIntlist(&data);
-	break;
+        aclParseIntlist(&data);
+        break;
 #endif
+
     case ACL_URL_PORT:
+
     case ACL_MY_PORT:
-	aclParseIntRange(&data);
-	break;
+        aclParseIntRange(&data);
+        break;
+
     case ACL_PROTO:
-	aclParseProtoList(&data);
-	break;
+        aclParseProtoList(&data);
+        break;
+
     case ACL_METHOD:
-	aclParseMethodList(&data);
-	break;
+        aclParseMethodList(&data);
+        break;
+
     case ACL_DERIVED:
-	fatal ("overriden");
-	break;
+        fatal ("overriden");
+        break;
 #if SQUID_SNMP
+
     case ACL_SNMP_COMMUNITY:
-	aclParseWordList(&data);
-	break;
+        aclParseWordList(&data);
+        break;
 #endif
 #if USE_ARP_ACL
+
     case ACL_SRC_ARP:
-	aclParseArpList(&data);
-	break;
+        aclParseArpList(&data);
+        break;
 #endif
+
     case ACL_EXTERNAL:
-	aclParseExternal(&data);
-	break;
+        aclParseExternal(&data);
+        break;
+
     case ACL_NONE:
+
     case ACL_ENUM_MAX:
-	fatal("Bad ACL type");
-	break;
+        fatal("Bad ACL type");
+        break;
     }
 }
 
@@ -504,19 +614,26 @@ aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name)
     acl_name_list *L = NULL;
 
     A = *head;
+
     if (NULL == *head)		/* empty list */
-	return ERR_NONE;
+        return ERR_NONE;
+
     while (A) {
-	L = A->acl_list;
-	if (NULL == L)		/* empty list should never happen, but in case */
-	    continue;
-	while (L) {
-	    if (!strcmp(name, L->name))
-		return A->err_page_id;
-	    L = L->next;
-	}
-	A = A->next;
+        L = A->acl_list;
+
+        if (NULL == L)		/* empty list should never happen, but in case */
+            continue;
+
+        while (L) {
+            if (!strcmp(name, L->name))
+                return A->err_page_id;
+
+            L = L->next;
+        }
+
+        A = A->next;
     }
+
     return ERR_NONE;
 }
 
@@ -525,10 +642,13 @@ int
 aclIsProxyAuth(const char *name)
 {
     if (NULL == name)
-	return false;
+        return false;
+
     acl *a;
+
     if ((a = ACL::FindByName(name)))
-	return a->isProxyAuth();
+        return a->isProxyAuth();
+
     return false;
 }
 
@@ -558,32 +678,39 @@ aclParseDenyInfoLine(acl_deny_info_list ** head)
     acl_name_list **Tail = NULL;
 
     /* first expect a page name */
+
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseDenyInfoLine: missing 'error page' parameter.\n");
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseDenyInfoLine: missing 'error page' parameter.\n");
+        return;
     }
+
     A = (acl_deny_info_list *)memAllocate(MEM_ACL_DENY_INFO_LIST);
     A->err_page_id = errorReservePageId(t);
     A->err_page_name = xstrdup(t);
     A->next = (acl_deny_info_list *) NULL;
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
+
     while ((t = strtok(NULL, w_space))) {
-	L = (acl_name_list *)memAllocate(MEM_ACL_NAME_LIST);
-	xstrncpy(L->name, t, ACL_NAME_SZ);
-	*Tail = L;
-	Tail = &L->next;
+        L = (acl_name_list *)memAllocate(MEM_ACL_NAME_LIST);
+        xstrncpy(L->name, t, ACL_NAME_SZ);
+        *Tail = L;
+        Tail = &L->next;
     }
+
     if (A->acl_list == NULL) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseDenyInfoLine: deny_info line contains no ACL's, skipping\n");
-	memFree(A, MEM_ACL_DENY_INFO_LIST);
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseDenyInfoLine: deny_info line contains no ACL's, skipping\n");
+        memFree(A, MEM_ACL_DENY_INFO_LIST);
+        return;
     }
-    for (B = *head, T = head; B; T = &B->next, B = B->next);	/* find the tail */
+
+    for (B = *head, T = head; B; T = &B->next, B = B->next)
+
+        ;	/* find the tail */
     *T = A;
 }
 
@@ -596,51 +723,59 @@ aclParseAccessLine(acl_access ** head)
     acl_access **T = NULL;
 
     /* first expect either 'allow' or 'deny' */
+
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseAccessLine: missing 'allow' or 'deny'.\n");
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseAccessLine: missing 'allow' or 'deny'.\n");
+        return;
     }
+
     A = new acl_access;
 
     if (!strcmp(t, "allow"))
-	A->allow = ACCESS_ALLOWED;
+        A->allow = ACCESS_ALLOWED;
     else if (!strcmp(t, "deny"))
-	A->allow = ACCESS_DENIED;
+        A->allow = ACCESS_DENIED;
     else {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseAccessLine: expecting 'allow' or 'deny', got '%s'.\n", t);
-	delete A;
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseAccessLine: expecting 'allow' or 'deny', got '%s'.\n", t);
+        delete A;
+        return;
     }
+
     aclParseAclList(&A->aclList);
+
     if (A->aclList == NULL) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseAccessLine: Access line contains no ACL's, skipping\n");
-	delete A;
-	return;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseAccessLine: Access line contains no ACL's, skipping\n");
+        delete A;
+        return;
     }
+
     A->cfgline = xstrdup(config_input_line);
     /* Append to the end of this list */
-    for (B = *head, T = head; B; T = &B->next, B = B->next);
+
+    for (B = *head, T = head; B; T = &B->next, B = B->next)
+
+        ;
     *T = A;
+
     /* We lock _acl_access structures in ACLChecklist::check() */
 }
 
 ACLList::ACLList() : op (1), _acl (NULL), next (NULL)
-{
-}
+{}
 
 void
 ACLList::negated(bool isNegated)
 {
     if (isNegated)
-	op = 0;
+        op = 0;
     else
-	op = 1;
+        op = 1;
 }
 
 void
@@ -652,51 +787,65 @@ aclParseAclList(acl_list ** head)
 
     /* next expect a list of ACL names, possibly preceeded
      * by '!' for negation */
+
     while ((t = strtok(NULL, w_space))) {
-	acl_list *L (new ACLList);
-	if (*t == '!') {
-	    L->negated (true);
-	    t++;
-	}
-	debug(28, 3) ("aclParseAccessLine: looking for ACL name '%s'\n", t);
-	a = ACL::FindByName(t);
-	if (a == NULL) {
-	    debug(28, 0) ("%s line %d: %s\n",
-		cfg_filename, config_lineno, config_input_line);
-	    debug(28, 0) ("aclParseAccessLine: ACL name '%s' not found.\n", t);
-	    L->deleteSelf();
-	    continue;
-	}
-	L->_acl = a;
-	*Tail = L;
-	Tail = &L->next;
+        acl_list *L (new ACLList);
+
+        if (*t == '!') {
+            L->negated (true);
+            t++;
+        }
+
+        debug(28, 3) ("aclParseAccessLine: looking for ACL name '%s'\n", t);
+        a = ACL::FindByName(t);
+
+        if (a == NULL) {
+            debug(28, 0) ("%s line %d: %s\n",
+                          cfg_filename, config_lineno, config_input_line);
+            debug(28, 0) ("aclParseAccessLine: ACL name '%s' not found.\n", t);
+            L->deleteSelf();
+            continue;
+        }
+
+        L->_acl = a;
+        *Tail = L;
+        Tail = &L->next;
     }
 }
 
 int
 aclMatchRegex(relist * data, const char *word)
 {
     relist *first, *prev;
+
     if (word == NULL)
-	return 0;
+        return 0;
+
     debug(28, 3) ("aclMatchRegex: checking '%s'\n", word);
+
     first = data;
+
     prev = NULL;
+
     while (data) {
-	debug(28, 3) ("aclMatchRegex: looking for '%s'\n", data->pattern);
-	if (regexec(&data->regex, word, 0, 0, 0) == 0) {
-	    if (prev != NULL) {
-		/* shift the element just found to the second position
-		 * in the list */
-		prev->next = data->next;
-		data->next = first->next;
-		first->next = data;
-	    }
-	    return 1;
-	}
-	prev = data;
-	data = data->next;
+        debug(28, 3) ("aclMatchRegex: looking for '%s'\n", data->pattern);
+
+        if (regexec(&data->regex, word, 0, 0, 0) == 0) {
+            if (prev != NULL) {
+                /* shift the element just found to the second position
+                 * in the list */
+                prev->next = data->next;
+                data->next = first->next;
+                first->next = data;
+            }
+
+            return 1;
+        }
+
+        prev = data;
+        data = data->next;
     }
+
     return 0;
 }
 
@@ -725,14 +874,18 @@ ACL::cacheMatchAcl(dlink_list * cache, ACLChecklist *checklist)
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link;
     link = cache->head;
+
     while (link) {
-	auth_match = (acl_proxy_auth_match_cache *)link->data;
-	if (auth_match->acl_data == this) {
-	    debug(28, 4) ("ACL::cacheMatchAcl: cache hit on acl '%p'\n", this);
-	    return auth_match->matchrv;
-	}
-	link = link->next;
+        auth_match = (acl_proxy_auth_match_cache *)link->data;
+
+        if (auth_match->acl_data == this) {
+            debug(28, 4) ("ACL::cacheMatchAcl: cache hit on acl '%p'\n", this);
+            return auth_match->matchrv;
+        }
+
+        link = link->next;
     }
+
     auth_match = NULL;
     auth_match = (acl_proxy_auth_match_cache *)memAllocate(MEM_ACL_PROXY_AUTH_MATCH);
     auth_match->matchrv = matchForCache (checklist);
@@ -747,12 +900,13 @@ aclCacheMatchFlush(dlink_list * cache)
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link, *tmplink;
     link = cache->head;
+
     while (link) {
-	auth_match = (acl_proxy_auth_match_cache *)link->data;
-	tmplink = link;
-	link = link->next;
-	dlinkDelete(tmplink, cache);
-	memFree(auth_match, MEM_ACL_PROXY_AUTH_MATCH);
+        auth_match = (acl_proxy_auth_match_cache *)link->data;
+        tmplink = link;
+        link = link->next;
+        dlinkDelete(tmplink, cache);
+        memFree(auth_match, MEM_ACL_PROXY_AUTH_MATCH);
     }
 }
 
@@ -765,35 +919,45 @@ aclParseUserMaxIP(void *data)
     acl_user_ip_data **acldata = (acl_user_ip_data **)data;
     char *t = NULL;
     CBDATA_INIT_TYPE(acl_user_ip_data);
+
     if (*acldata) {
-	debug(28, 1) ("Attempting to alter already set User max IP acl\n");
-	return;
+        debug(28, 1) ("Attempting to alter already set User max IP acl\n");
+        return;
     }
+
     *acldata = cbdataAlloc(acl_user_ip_data);
     t = strtokFile();
+
     if (!t)
-	goto error;
+        goto error;
+
     debug(28, 5) ("aclParseUserMaxIP: First token is %s\n", t);
+
     if (strcmp("-s", t) == 0) {
-	debug(28, 5) ("aclParseUserMaxIP: Going strict\n");
-	(*acldata)->flags.strict = 1;
-	t = strtokFile();
-	if (!t)
-	    goto error;
+        debug(28, 5) ("aclParseUserMaxIP: Going strict\n");
+        (*acldata)->flags.strict = 1;
+        t = strtokFile();
+
+        if (!t)
+            goto error;
     }
+
     (*acldata)->max = atoi(t);
     debug(28, 5) ("aclParseUserMaxIP: Max IP address's %d\n", (int) (*acldata)->max);
     return;
-  error:
+
+error:
     fatal("aclParseUserMaxIP: Malformed ACL %d\n");
 }
 
 void
 aclDestroyUserMaxIP(void *data)
 {
     acl_user_ip_data **acldata = (acl_user_ip_data **)data;
+
     if (*acldata)
-	cbdataFree(*acldata);
+        cbdataFree(*acldata);
+
     *acldata = NULL;
 }
 
@@ -803,21 +967,26 @@ aclDumpUserMaxIP(void *data)
     acl_user_ip_data *acldata = (acl_user_ip_data *)data;
     wordlist *W = NULL;
     char buf[128];
+
     if (acldata->flags.strict)
-	wordlistAdd(&W, "-s");
+        wordlistAdd(&W, "-s");
+
     snprintf(buf, sizeof(buf), "%lu", (unsigned long int) acldata->max);
+
     wordlistAdd(&W, buf);
+
     return W;
 }
 
-/* 
+/*
  * aclMatchUserMaxIP - check for users logging in from multiple IP's 
  * 0 : No match
  * 1 : Match 
  */
 int
 aclMatchUserMaxIP(void *data, auth_user_request_t * auth_user_request,
-    struct in_addr src_addr)
+
+                  struct in_addr src_addr)
 {
     /*
      * the logic for flush the ip list when the limit is hit vs keep
@@ -827,24 +996,26 @@ aclMatchUserMaxIP(void *data, auth_user_request_t * auth_user_request,
     acl_user_ip_data *acldata = (acl_user_ip_data *)data;
 
     if (authenticateAuthUserRequestIPCount(auth_user_request) <= acldata->max)
-	return 0;
+        return 0;
 
     /* this is a match */
-    if (acldata->flags.strict) {
-	/* 
-	 * simply deny access - the user name is already associated with
-	 * the request 
-	 */
-	/* remove _this_ ip, as it is the culprit for going over the limit */
-	authenticateAuthUserRequestRemoveIp(auth_user_request, src_addr);
-	debug(28, 4) ("aclMatchUserMaxIP: Denying access in strict mode\n");
-    } else {
-	/* 
-	 * non-strict - remove some/all of the cached entries 
-	 * ie to allow the user to move machines easily
-	 */
-	authenticateAuthUserRequestClearIp(auth_user_request);
-	debug(28, 4) ("aclMatchUserMaxIP: Denying access in non-strict mode - flushing the user ip cache\n");
+    if (acldata->flags.strict)
+    {
+        /*
+         * simply deny access - the user name is already associated with
+         * the request 
+         */
+        /* remove _this_ ip, as it is the culprit for going over the limit */
+        authenticateAuthUserRequestRemoveIp(auth_user_request, src_addr);
+        debug(28, 4) ("aclMatchUserMaxIP: Denying access in strict mode\n");
+    } else
+    {
+        /*
+         * non-strict - remove some/all of the cached entries 
+         * ie to allow the user to move machines easily
+         */
+        authenticateAuthUserRequestClearIp(auth_user_request);
+        debug(28, 4) ("aclMatchUserMaxIP: Denying access in non-strict mode - flushing the user ip cache\n");
     }
 
     return 1;
@@ -856,20 +1027,24 @@ aclMatchInteger(intlist * data, int i)
     intlist *first, *prev;
     first = data;
     prev = NULL;
+
     while (data) {
-	if (data->i == i) {
-	    if (prev != NULL) {
-		/* shift the element just found to the second position
-		 * in the list */
-		prev->next = data->next;
-		data->next = first->next;
-		first->next = data;
-	    }
-	    return 1;
-	}
-	prev = data;
-	data = data->next;
+        if (data->i == i) {
+            if (prev != NULL) {
+                /* shift the element just found to the second position
+                 * in the list */
+                prev->next = data->next;
+                data->next = first->next;
+                first->next = data;
+            }
+
+            return 1;
+        }
+
+        prev = data;
+        data = data->next;
     }
+
     return 0;
 }
 
@@ -879,25 +1054,30 @@ aclMatchIntegerRange(intrange * data, int i)
     intrange *first, *prev;
     first = data;
     prev = NULL;
+
     while (data) {
-	if (i < data->i) {
-	    (void) 0;
-	} else if (i > data->j) {
-	    (void) 0;
-	} else {
-	    /* matched */
-	    if (prev != NULL) {
-		/* shift the element just found to the second position
-		 * in the list */
-		prev->next = data->next;
-		data->next = first->next;
-		first->next = data;
-	    }
-	    return 1;
-	}
-	prev = data;
-	data = data->next;
+        if (i < data->i) {
+            (void) 0;
+        } else if (i > data->j) {
+            (void) 0;
+        } else {
+            /* matched */
+
+            if (prev != NULL) {
+                /* shift the element just found to the second position
+                 * in the list */
+                prev->next = data->next;
+                data->next = first->next;
+                first->next = data;
+            }
+
+            return 1;
+        }
+
+        prev = data;
+        data = data->next;
     }
+
     return 0;
 }
 
@@ -906,41 +1086,53 @@ static int
 aclMatchWordList(wordlist * w, const char *word)
 {
     debug(28, 3) ("aclMatchWordList: looking for '%s'\n", word);
+
     while (w != NULL) {
-	debug(28, 3) ("aclMatchWordList: checking '%s'\n", w->key);
-	if (!strcmp(w->key, word))
-	    return 1;
-	w = w->next;
+        debug(28, 3) ("aclMatchWordList: checking '%s'\n", w->key);
+
+        if (!strcmp(w->key, word))
+            return 1;
+
+        w = w->next;
     }
+
     return 0;
 }
+
 #endif
 
 
 bool
 ACL::requiresRequest() const
 {
     switch (aclType()) {
+
     case ACL_DST_ASN:
+
     case ACL_MAX_USER_IP:
+
     case ACL_METHOD:
+
     case ACL_PROTO:
+
     case ACL_REP_MIME_TYPE:
+
     case ACL_URL_PORT:
-	/* These ACL types require checklist->request */
-	return true;
+        /* These ACL types require checklist->request */
+        return true;
+
     default:
-	return false;
+        return false;
     }
 }
 
 int
 ACL::checklistMatches(ACLChecklist *checklist)
 {
     if (NULL == checklist->request && requiresRequest()) {
-	debug(28, 1) ("WARNING: '%s' ACL is used but there is no"
-		      " HTTP request -- access denied.\n", name);
-	return 0;
+        debug(28, 1) ("WARNING: '%s' ACL is used but there is no"
+                      " HTTP request -- access denied.\n", name);
+        return 0;
     }
 
     debug(28, 3) ("aclMatchAcl: checking '%s'\n", cfgline);
@@ -956,79 +1148,111 @@ ACL::match(ACLChecklist * checklist)
     int k, ti;
 
     switch (aclType()) {
+
     case ACL_MAXCONN:
-	k = clientdbEstablished(checklist->src_addr, 0);
-	return ((k > ((intlist *) data)->i) ? 1 : 0);
-	/* NOTREACHED */
+        k = clientdbEstablished(checklist->src_addr, 0);
+        return ((k > ((intlist *) data)->i) ? 1 : 0);
+        /* NOTREACHED */
+
     case ACL_URL_PORT:
-	return aclMatchIntegerRange((intrange *)data, (int) r->port);
-	/* NOTREACHED */
+        return aclMatchIntegerRange((intrange *)data, (int) r->port);
+        /* NOTREACHED */
+
     case ACL_MY_PORT:
-	return aclMatchIntegerRange((intrange *)data, (int) checklist->my_port);
-	/* NOTREACHED */
+        return aclMatchIntegerRange((intrange *)data, (int) checklist->my_port);
+        /* NOTREACHED */
+
     case ACL_PROTO:
-	return aclMatchInteger((intlist *)data, r->protocol);
-	/* NOTREACHED */
+        return aclMatchInteger((intlist *)data, r->protocol);
+        /* NOTREACHED */
+
     case ACL_METHOD:
-	return aclMatchInteger((intlist *)data, r->method);
-	/* NOTREACHED */
+        return aclMatchInteger((intlist *)data, r->method);
+        /* NOTREACHED */
+
     case ACL_MAX_USER_IP:
-	if ((ti = checklist->authenticated()) != 1)
-	    return ti;
-	ti = aclMatchUserMaxIP(data, checklist->auth_user_request,
-	    checklist->src_addr);
-	checklist->auth_user_request = NULL;
-	return ti;
-	/* NOTREACHED */
+
+        if ((ti = checklist->authenticated()) != 1)
+            return ti;
+
+        ti = aclMatchUserMaxIP(data, checklist->auth_user_request,
+                               checklist->src_addr);
+
+        checklist->auth_user_request = NULL;
+
+        return ti;
+
+        /* NOTREACHED */
 #if SQUID_SNMP
+
     case ACL_SNMP_COMMUNITY:
-	return aclMatchWordList((wordlist *)data, checklist->snmp_community);
-	/* NOTREACHED */
+        return aclMatchWordList((wordlist *)data, checklist->snmp_community);
+
+        /* NOTREACHED */
 #endif
+
     case ACL_SRC_ASN:
-	return asnMatchIp(data, checklist->src_addr);
-	/* NOTREACHED */
+        return asnMatchIp(data, checklist->src_addr);
+
+        /* NOTREACHED */
+
     case ACL_DST_ASN:
-	ia = ipcache_gethostbyname(r->host, IP_LOOKUP_IF_MISS);
-	if (ia) {
-	    for (k = 0; k < (int) ia->count; k++) {
-		if (asnMatchIp(data, ia->in_addrs[k]))
-		    return 1;
-	    }
-	    return 0;
-	} else if (checklist->state[ACL_DST_ASN] == ACL_LOOKUP_NONE) {
-	    debug(28, 3) ("asnMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
-		name, r->host);
-	    checklist->changeState (DestinationIPLookup::Instance());
-	} else {
-	    return asnMatchIp(data, no_addr);
-	}
-	return 0;
-	/* NOTREACHED */
+        ia = ipcache_gethostbyname(r->host, IP_LOOKUP_IF_MISS);
+
+        if (ia) {
+            for (k = 0; k < (int) ia->count; k++) {
+                if (asnMatchIp(data, ia->in_addrs[k]))
+                    return 1;
+            }
+
+            return 0;
+        } else if (checklist->state[ACL_DST_ASN] == ACL_LOOKUP_NONE) {
+            debug(28, 3) ("asnMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+                          name, r->host);
+            checklist->changeState (DestinationIPLookup::Instance());
+        } else {
+            return asnMatchIp(data, no_addr);
+        }
+
+        return 0;
+        /* NOTREACHED */
 #if USE_ARP_ACL
+
     case ACL_SRC_ARP:
-	return aclMatchArp(&data, checklist->src_addr);
-	/* NOTREACHED */
+        return aclMatchArp(&data, checklist->src_addr);
+        /* NOTREACHED */
 #endif
+
     case ACL_REP_MIME_TYPE:
-	if (!checklist->reply)
-	    return 0;
-	header = httpHeaderGetStr(&checklist->reply->header, HDR_CONTENT_TYPE);
-	if (NULL == header)
-	    header = "";
-	return aclMatchRegex((relist *)data, header);
-	/* NOTREACHED */
+
+        if (!checklist->reply)
+            return 0;
+
+        header = httpHeaderGetStr(&checklist->reply->header, HDR_CONTENT_TYPE);
+
+        if (NULL == header)
+            header = "";
+
+        return aclMatchRegex((relist *)data, header);
+
+        /* NOTREACHED */
+
     case ACL_EXTERNAL:
-	return aclMatchExternal(data, checklist);
-	/* NOTREACHED */
+        return aclMatchExternal(data, checklist);
+
+        /* NOTREACHED */
+
     case ACL_NONE:
+
     case ACL_ENUM_MAX:
-	break;
+        break;
+
     case ACL_DERIVED:
-	fatal ("overridden");
+        fatal ("overridden");
     }
+
     debug(28, 0) ("aclMatchAcl: '%s' has bad type %d\n",
-	name, aclType());
+                  name, aclType());
     return 0;
 }
 
@@ -1038,14 +1262,16 @@ ACLList::matches (ACLChecklist *checklist) const
     assert (_acl);
     AclMatchedName = _acl->name;
     debug(28, 3) ("ACLList::matches: checking %s%s\n",
-		  op ? null_string : "!", _acl->name);
+                  op ? null_string : "!", _acl->name);
+
     if (_acl->checklistMatches(checklist) != op) {
-	return false;
+        return false;
     }
+
     return true;
 }
 
-/* Warning: do not cbdata lock checklist here - it 
+/* Warning: do not cbdata lock checklist here - it
  * may be static or on the stack
  */
 int
@@ -1054,14 +1280,18 @@ aclCheckFast(const acl_access * A, ACLChecklist * checklist)
     allow_t allow = ACCESS_DENIED;
     PROF_start(aclCheckFast);
     debug(28, 5) ("aclCheckFast: list: %p\n", A);
+
     while (A) {
-	allow = A->allow;
-	if (checklist->matchAclList(A->aclList, true)) {
-	    PROF_stop(aclCheckFast);
-	    return allow == ACCESS_ALLOWED;
-	}
-	A = A->next;
+        allow = A->allow;
+
+        if (checklist->matchAclList(A->aclList, true)) {
+            PROF_stop(aclCheckFast);
+            return allow == ACCESS_ALLOWED;
+        }
+
+        A = A->next;
     }
+
     debug(28, 5) ("aclCheckFast: no matches, returning: %d\n", allow == ACCESS_DENIED);
     PROF_stop(aclCheckFast);
     return allow == ACCESS_DENIED;
@@ -1092,19 +1322,26 @@ aclChecklistCreate(const acl_access * A, request_t * request, const char *ident)
     int i;
     ACLChecklist *checklist = new ACLChecklist;
     checklist->accessList = cbdataReference(A);
+
     if (request != NULL) {
-	checklist->request = requestLink(request);
-	checklist->src_addr = request->client_addr;
-	checklist->my_addr = request->my_addr;
-	checklist->my_port = request->my_port;
+        checklist->request = requestLink(request);
+        checklist->src_addr = request->client_addr;
+        checklist->my_addr = request->my_addr;
+        checklist->my_port = request->my_port;
     }
+
     for (i = 0; i < ACL_ENUM_MAX; i++)
-	checklist->state[i] = ACL_LOOKUP_NONE;
+        checklist->state[i] = ACL_LOOKUP_NONE;
+
 #if USE_IDENT
+
     if (ident)
-	xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
+        xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
+
 #endif
+
     checklist->auth_user_request = NULL;
+
     return checklist;
 }
 
@@ -1116,78 +1353,100 @@ void
 aclDestroyRegexList(relist * data)
 {
     relist *next = NULL;
+
     for (; data; data = next) {
-	next = data->next;
-	regfree(&data->regex);
-	safe_free(data->pattern);
-	memFree(data, MEM_RELIST);
+        next = data->next;
+        regfree(&data->regex);
+        safe_free(data->pattern);
+        memFree(data, MEM_RELIST);
     }
 }
 
 void
 aclDestroyAcls(acl ** head)
 {
     ACL *next = NULL;
+
     for (acl *a = *head; a; a = next) {
-	next = a->next;
-	a->deleteSelf();
+        next = a->next;
+        a->deleteSelf();
     }
+
     *head = NULL;
 }
 
 ACL::~ACL()
 {
     debug(28, 3) ("aclDestroyAcls: '%s'\n", cfgline);
+
     switch (aclType()) {
 #if USE_ARP_ACL
-	case ACL_SRC_ARP:
+
+    case ACL_SRC_ARP:
 #endif
 #if SQUID_SNMP
-	case ACL_SNMP_COMMUNITY:
-	    wordlistDestroy((wordlist **) & data);
-	    break;
+
+    case ACL_SNMP_COMMUNITY:
+        wordlistDestroy((wordlist **) & data);
+        break;
 #endif
-	/* Destroyed in the children */
-	case ACL_DERIVED:
-	    break;
-	case ACL_REP_MIME_TYPE:
-	    aclDestroyRegexList((relist *)data);
-	    break;
-	case ACL_PROTO:
-	case ACL_METHOD:
-	case ACL_SRC_ASN:
-	case ACL_DST_ASN:
+        /* Destroyed in the children */
+
+    case ACL_DERIVED:
+        break;
+
+    case ACL_REP_MIME_TYPE:
+        aclDestroyRegexList((relist *)data);
+        break;
+
+    case ACL_PROTO:
+
+    case ACL_METHOD:
+
+    case ACL_SRC_ASN:
+
+    case ACL_DST_ASN:
 #if SRC_RTT_NOT_YET_FINISHED
-	case ACL_NETDB_SRC_RTT:
+
+    case ACL_NETDB_SRC_RTT:
 #endif
-	case ACL_MAXCONN:
-	    intlistDestroy((intlist **) & data);
-	    break;
-	case ACL_MAX_USER_IP:
-	    aclDestroyUserMaxIP(&data);
-	    break;
-	case ACL_URL_PORT:
-	case ACL_MY_PORT:
-	    aclDestroyIntRange((intrange *)data);
-	    break;
-	case ACL_EXTERNAL:
-	    aclDestroyExternal(&data);
-	    break;
-	case ACL_NONE:
-	case ACL_ENUM_MAX:
-	    debug(28, 1) ("aclDestroyAcls: no case for ACL type %d\n", aclType());
-	    break;
-	}
-	safe_free(cfgline);
+
+    case ACL_MAXCONN:
+        intlistDestroy((intlist **) & data);
+        break;
+
+    case ACL_MAX_USER_IP:
+        aclDestroyUserMaxIP(&data);
+        break;
+
+    case ACL_URL_PORT:
+
+    case ACL_MY_PORT:
+        aclDestroyIntRange((intrange *)data);
+        break;
+
+    case ACL_EXTERNAL:
+        aclDestroyExternal(&data);
+        break;
+
+    case ACL_NONE:
+
+    case ACL_ENUM_MAX:
+        debug(28, 1) ("aclDestroyAcls: no case for ACL type %d\n", aclType());
+        break;
+    }
+
+    safe_free(cfgline);
 }
 
 void
 aclDestroyAclList(acl_list ** head)
 {
     acl_list *l;
+
     for (l = *head; l; l = *head) {
-	*head = l->next;
-	l->deleteSelf();
+        *head = l->next;
+        l->deleteSelf();
     }
 }
 
@@ -1196,13 +1455,15 @@ aclDestroyAccessList(acl_access ** list)
 {
     acl_access *l = NULL;
     acl_access *next = NULL;
+
     for (l = *list; l; l = next) {
-	debug(28, 3) ("aclDestroyAccessList: '%s'\n", l->cfgline);
-	next = l->next;
-	aclDestroyAclList(&l->aclList);
-	safe_free(l->cfgline);
-	cbdataFree(l);
+        debug(28, 3) ("aclDestroyAccessList: '%s'\n", l->cfgline);
+        next = l->next;
+        aclDestroyAclList(&l->aclList);
+        safe_free(l->cfgline);
+        cbdataFree(l);
     }
+
     *list = NULL;
 }
 
@@ -1218,14 +1479,16 @@ aclDestroyDenyInfoList(acl_deny_info_list ** list)
     acl_name_list *l_next = NULL;
 
     for (a = *list; a; a = a_next) {
-	for (l = a->acl_list; l; l = l_next) {
-	    l_next = l->next;
-	    safe_free(l);
-	}
-	a_next = a->next;
-	xfree(a->err_page_name);
-	memFree(a, MEM_ACL_DENY_INFO_LIST);
+        for (l = a->acl_list; l; l = l_next) {
+            l_next = l->next;
+            safe_free(l);
+        }
+
+        a_next = a->next;
+        xfree(a->err_page_name);
+        memFree(a, MEM_ACL_DENY_INFO_LIST);
     }
+
     *list = NULL;
 }
 
@@ -1234,20 +1497,23 @@ aclDestroyIntRange(intrange * list)
 {
     intrange *w = NULL;
     intrange *n = NULL;
+
     for (w = list; w; w = n) {
-	n = w->next;
-	safe_free(w);
+        n = w->next;
+        safe_free(w);
     }
 }
 
 wordlist *
 aclDumpRegexList(relist * data)
 {
     wordlist *W = NULL;
+
     while (data != NULL) {
-	wordlistAdd(&W, data->pattern);
-	data = data->next;
+        wordlistAdd(&W, data->pattern);
+        data = data->next;
     }
+
     return W;
 }
 
@@ -1256,11 +1522,13 @@ aclDumpIntlistList(intlist * data)
 {
     wordlist *W = NULL;
     char buf[32];
+
     while (data != NULL) {
-	snprintf(buf, sizeof(buf), "%d", data->i);
-	wordlistAdd(&W, buf);
-	data = data->next;
+        snprintf(buf, sizeof(buf), "%d", data->i);
+        wordlistAdd(&W, buf);
+        data = data->next;
     }
+
     return W;
 }
 
@@ -1269,36 +1537,44 @@ aclDumpIntRangeList(intrange * data)
 {
     wordlist *W = NULL;
     char buf[32];
+
     while (data != NULL) {
-	if (data->i == data->j)
-	    snprintf(buf, sizeof(buf), "%d", data->i);
-	else
-	    snprintf(buf, sizeof(buf), "%d-%d", data->i, data->j);
-	wordlistAdd(&W, buf);
-	data = data->next;
+        if (data->i == data->j)
+            snprintf(buf, sizeof(buf), "%d", data->i);
+        else
+            snprintf(buf, sizeof(buf), "%d-%d", data->i, data->j);
+
+        wordlistAdd(&W, buf);
+
+        data = data->next;
     }
+
     return W;
 }
 
 static wordlist *
 aclDumpProtoList(intlist * data)
 {
     wordlist *W = NULL;
+
     while (data != NULL) {
-	wordlistAdd(&W, ProtocolStr[data->i]);
-	data = data->next;
+        wordlistAdd(&W, ProtocolStr[data->i]);
+        data = data->next;
     }
+
     return W;
 }
 
 static wordlist *
 aclDumpMethodList(intlist * data)
 {
     wordlist *W = NULL;
+
     while (data != NULL) {
-	wordlistAdd(&W, RequestMethodStr[data->i]);
-	data = data->next;
+        wordlistAdd(&W, RequestMethodStr[data->i]);
+        data = data->next;
     }
+
     return W;
 }
 
@@ -1314,36 +1590,52 @@ ACL::dump() const
 {
     switch (aclType()) {
 #if SQUID_SNMP
+
     case ACL_SNMP_COMMUNITY:
-	return wordlistDup((wordlist *)data);
+        return wordlistDup((wordlist *)data);
 #endif
+
     case ACL_DERIVED:
-	fatal ("unused");
+        fatal ("unused");
+
     case ACL_REP_MIME_TYPE:
-	return aclDumpRegexList((relist *)data);
+        return aclDumpRegexList((relist *)data);
+
     case ACL_SRC_ASN:
+
     case ACL_MAXCONN:
+
     case ACL_DST_ASN:
-	return aclDumpIntlistList((intlist *)data);
+        return aclDumpIntlistList((intlist *)data);
+
     case ACL_MAX_USER_IP:
-	return aclDumpUserMaxIP(data);
+        return aclDumpUserMaxIP(data);
+
     case ACL_URL_PORT:
+
     case ACL_MY_PORT:
-	return aclDumpIntRangeList((intrange *)data);
+        return aclDumpIntRangeList((intrange *)data);
+
     case ACL_PROTO:
-	return aclDumpProtoList((intlist *)data);
+        return aclDumpProtoList((intlist *)data);
+
     case ACL_METHOD:
-	return aclDumpMethodList((intlist *)data);
+        return aclDumpMethodList((intlist *)data);
 #if USE_ARP_ACL
+
     case ACL_SRC_ARP:
-	return aclDumpArpList(data);
+        return aclDumpArpList(data);
 #endif
+
     case ACL_EXTERNAL:
-	return aclDumpExternal(data);
+        return aclDumpExternal(data);
+
     case ACL_NONE:
+
     case ACL_ENUM_MAX:
-	break;
+        break;
     }
+
     debug(28, 1) ("ACL::dumpGeneric: no case for ACL type %d\n", aclType());
     return NULL;
 }
@@ -1365,22 +1657,26 @@ acl_access::containsPURGE() const
 {
     acl_access const *a = this;
     acl_list *b;
+
     for (; a; a = a->next) {
-	for (b = a->aclList; b; b = b->next) {
-	    if (ACL_METHOD != b->_acl->aclType())
-		continue;
-	    if (b->_acl->containsPURGE())
-		return true;
-	}
+        for (b = a->aclList; b; b = b->next) {
+            if (ACL_METHOD != b->_acl->aclType())
+                continue;
+
+            if (b->_acl->containsPURGE())
+                return true;
+        }
     }
+
     return false;
 }
 
 bool
 ACL::containsPURGE() const
 {
     if (aclMatchInteger((intlist *)data, METHOD_PURGE))
-	return true;
+        return true;
+
     return false;
 }
 
@@ -1437,10 +1733,12 @@ static int
 decode_eth(const char *asc, char *eth)
 {
     int a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, a6 = 0;
+
     if (sscanf(asc, "%x:%x:%x:%x:%x:%x", &a1, &a2, &a3, &a4, &a5, &a6) != 6) {
-	debug(28, 0) ("decode_eth: Invalid ethernet address '%s'\n", asc);
-	return 0;		/* This is not valid address */
+        debug(28, 0) ("decode_eth: Invalid ethernet address '%s'\n", asc);
+        return 0;		/* This is not valid address */
     }
+
     eth[0] = (u_char) a1;
     eth[1] = (u_char) a2;
     eth[2] = (u_char) a3;
@@ -1456,18 +1754,21 @@ aclParseArpData(const char *t)
     LOCAL_ARRAY(char, eth, 256);
     acl_arp_data *q = (acl_arp_data *)xcalloc(1, sizeof(acl_arp_data));
     debug(28, 5) ("aclParseArpData: %s\n", t);
+
     if (sscanf(t, "%[0-9a-fA-F:]", eth) != 1) {
-	debug(28, 0) ("aclParseArpData: Bad ethernet address: '%s'\n", t);
-	safe_free(q);
-	return NULL;
+        debug(28, 0) ("aclParseArpData: Bad ethernet address: '%s'\n", t);
+        safe_free(q);
+        return NULL;
     }
+
     if (!decode_eth(eth, q->eth)) {
-	debug(28, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0) ("aclParseArpData: Ignoring invalid ARP acl entry: can't parse '%s'\n", eth);
-	safe_free(q);
-	return NULL;
+        debug(28, 0) ("%s line %d: %s\n",
+                      cfg_filename, config_lineno, config_input_line);
+        debug(28, 0) ("aclParseArpData: Ignoring invalid ARP acl entry: can't parse '%s'\n", eth);
+        safe_free(q);
+        return NULL;
     }
+
     return q;
 }
 
@@ -1481,24 +1782,32 @@ aclParseArpList(void *curlist)
     char *t = NULL;
     splayNode **Top = (splayNode **)curlist;
     acl_arp_data *q = NULL;
+
     while ((t = strtokFile())) {
-	if ((q = aclParseArpData(t)) == NULL)
-	    continue;
-	*Top = splay_insert(q, *Top, aclArpCompare);
+        if ((q = aclParseArpData(t)) == NULL)
+            continue;
+
+        *Top = splay_insert(q, *Top, aclArpCompare);
     }
 }
 
 /***************/
 /* aclMatchArp */
 /***************/
 static int
+
 aclMatchArp(void *dataptr, struct in_addr c)
 {
 #if defined(_SQUID_LINUX_)
+
     struct arpreq arpReq;
+
     struct sockaddr_in ipAddr;
+
     unsigned char ifbuffer[sizeof(struct ifreq) * 64];
+
     struct ifconf ifc;
+
     struct ifreq *ifr;
     int offset;
     splayNode **Top = (splayNode **)dataptr;
@@ -1520,140 +1829,197 @@ aclMatchArp(void *dataptr, struct in_addr c)
     ipAddr.sin_port = 0;
     ipAddr.sin_addr = c;
     memset(&arpReq, '\0', sizeof(arpReq));
+
     xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
     /* Query ARP table */
-    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1) {
-	/* Skip non-ethernet interfaces */
-	if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
-	    return 0;
-	}
-	debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
-	    arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
-	    arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
-	    arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
-	/* Do lookup */
-	const void *X = arpReq.arp_ha.sa_data;
-	*Top = splay_splay(&X, *Top, aclArpCompare);
-	debug(28, 3) ("aclMatchArp: '%s' %s\n",
-	    inet_ntoa(c), splayLastResult ? "NOT found" : "found");
-	return (0 == splayLastResult);
+
+    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1)
+    {
+        /* Skip non-ethernet interfaces */
+
+        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
+            return 0;
+        }
+
+        debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
+                      arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
+                      arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
+                      arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
+        /* Do lookup */
+        const void *X = arpReq.arp_ha.sa_data;
+        *Top = splay_splay(&X, *Top, aclArpCompare);
+        debug(28, 3) ("aclMatchArp: '%s' %s\n",
+                      inet_ntoa(c), splayLastResult ? "NOT found" : "found");
+        return (0 == splayLastResult);
     }
+
     /* lookup list of interface names */
     ifc.ifc_len = sizeof(ifbuffer);
+
     ifc.ifc_buf = (char *)ifbuffer;
-    if (ioctl(HttpSockets[0], SIOCGIFCONF, &ifc) < 0) {
-	debug(28, 1) ("Attempt to retrieve interface list failed: %s\n",
-	    xstrerror());
-	return 0;
+
+    if (ioctl(HttpSockets[0], SIOCGIFCONF, &ifc) < 0)
+    {
+        debug(28, 1) ("Attempt to retrieve interface list failed: %s\n",
+                      xstrerror());
+        return 0;
     }
-    if (ifc.ifc_len > (int)sizeof(ifbuffer)) {
-	debug(28, 1) ("Interface list too long - %d\n", ifc.ifc_len);
-	return 0;
+
+    if (ifc.ifc_len > (int)sizeof(ifbuffer))
+    {
+        debug(28, 1) ("Interface list too long - %d\n", ifc.ifc_len);
+        return 0;
     }
+
     /* Attempt ARP lookup on each interface */
     offset = 0;
-    while (offset < ifc.ifc_len) {
-	ifr = (struct ifreq *) (ifbuffer + offset);
-	offset += sizeof(*ifr);
-	/* Skip loopback and aliased interfaces */
-	if (0 == strncmp(ifr->ifr_name, "lo", 2))
-	    continue;
-	if (NULL != strchr(ifr->ifr_name, ':'))
-	    continue;
-	debug(28, 4) ("Looking up ARP address for %s on %s\n", inet_ntoa(c),
-	    ifr->ifr_name);
-	/* Set up structures for ARP lookup */
-	ipAddr.sin_family = AF_INET;
-	ipAddr.sin_port = 0;
-	ipAddr.sin_addr = c;
-	memset(&arpReq, '\0', sizeof(arpReq));
-	xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
-	strncpy(arpReq.arp_dev, ifr->ifr_name, sizeof(arpReq.arp_dev) - 1);
-	arpReq.arp_dev[sizeof(arpReq.arp_dev) - 1] = '\0';
-	/* Query ARP table */
-	if (-1 == ioctl(HttpSockets[0], SIOCGARP, &arpReq)) {
-	    /*
-	     * Query failed.  Do not log failed lookups or "device
-	     * not supported"
-	     */
-	    if (ENXIO == errno)
-		(void) 0;
-	    else if (ENODEV == errno)
-		(void) 0;
-	    else
-		debug(28, 1) ("ARP query failed: %s: %s\n",
-		    ifr->ifr_name, xstrerror());
-	    continue;
-	}
-	/* Skip non-ethernet interfaces */
-	if (arpReq.arp_ha.sa_family != ARPHRD_ETHER)
-	    continue;
-	debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x on %s\n",
-	    arpReq.arp_ha.sa_data[0] & 0xff,
-	    arpReq.arp_ha.sa_data[1] & 0xff,
-	    arpReq.arp_ha.sa_data[2] & 0xff,
-	    arpReq.arp_ha.sa_data[3] & 0xff,
-	    arpReq.arp_ha.sa_data[4] & 0xff,
-	    arpReq.arp_ha.sa_data[5] & 0xff, ifr->ifr_name);
-	/* Do lookup */
-	const void *X = arpReq.arp_ha.sa_data;
-	*Top = splay_splay(&X, *Top, aclArpCompare);
-	/* Return if match, otherwise continue to other interfaces */
-	if (0 == splayLastResult) {
-	    debug(28, 3) ("aclMatchArp: %s found on %s\n",
-		inet_ntoa(c), ifr->ifr_name);
-	    return 1;
-	}
-	/*
-	 * Should we stop looking here? Can the same IP address
-	 * exist on multiple interfaces?
-	 */
+
+    while (offset < ifc.ifc_len)
+    {
+
+        ifr = (struct ifreq *) (ifbuffer + offset);
+        offset += sizeof(*ifr);
+        /* Skip loopback and aliased interfaces */
+
+        if (0 == strncmp(ifr->ifr_name, "lo", 2))
+            continue;
+
+        if (NULL != strchr(ifr->ifr_name, ':'))
+            continue;
+
+        debug(28, 4) ("Looking up ARP address for %s on %s\n", inet_ntoa(c),
+                      ifr->ifr_name);
+
+        /* Set up structures for ARP lookup */
+        ipAddr.sin_family = AF_INET;
+
+        ipAddr.sin_port = 0;
+
+        ipAddr.sin_addr = c;
+
+        memset(&arpReq, '\0', sizeof(arpReq));
+
+        xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
+
+        strncpy(arpReq.arp_dev, ifr->ifr_name, sizeof(arpReq.arp_dev) - 1);
+
+        arpReq.arp_dev[sizeof(arpReq.arp_dev) - 1] = '\0';
+
+        /* Query ARP table */
+        if (-1 == ioctl(HttpSockets[0], SIOCGARP, &arpReq)) {
+            /*
+             * Query failed.  Do not log failed lookups or "device
+             * not supported"
+             */
+
+            if (ENXIO == errno)
+                (void) 0;
+            else if (ENODEV == errno)
+                (void) 0;
+            else
+                debug(28, 1) ("ARP query failed: %s: %s\n",
+                              ifr->ifr_name, xstrerror());
+
+            continue;
+        }
+
+        /* Skip non-ethernet interfaces */
+        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER)
+            continue;
+
+        debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x on %s\n",
+                      arpReq.arp_ha.sa_data[0] & 0xff,
+                      arpReq.arp_ha.sa_data[1] & 0xff,
+                      arpReq.arp_ha.sa_data[2] & 0xff,
+                      arpReq.arp_ha.sa_data[3] & 0xff,
+                      arpReq.arp_ha.sa_data[4] & 0xff,
+                      arpReq.arp_ha.sa_data[5] & 0xff, ifr->ifr_name);
+
+        /* Do lookup */
+        const void *X = arpReq.arp_ha.sa_data;
+
+        *Top = splay_splay(&X, *Top, aclArpCompare);
+
+        /* Return if match, otherwise continue to other interfaces */
+        if (0 == splayLastResult) {
+            debug(28, 3) ("aclMatchArp: %s found on %s\n",
+                          inet_ntoa(c), ifr->ifr_name);
+            return 1;
+        }
+
+        /*
+         * Should we stop looking here? Can the same IP address
+         * exist on multiple interfaces?
+         */
     }
+
 #elif defined(_SQUID_SOLARIS_)
+
     struct arpreq arpReq;
+
     struct sockaddr_in ipAddr;
+
     unsigned char ifbuffer[sizeof(struct ifreq) * 64];
+
     struct ifconf ifc;
+
     struct ifreq *ifr;
+
     int offset;
+
     splayNode **Top = dataptr;
+
     /*
-     * Set up structures for ARP lookup with blank interface name
-     */
+    * Set up structures for ARP lookup with blank interface name
+    */
     ipAddr.sin_family = AF_INET;
+
     ipAddr.sin_port = 0;
+
     ipAddr.sin_addr = c;
+
     memset(&arpReq, '\0', sizeof(arpReq));
+
     xmemcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
+
     /* Query ARP table */
-    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1) {
-	/*
-	 *  Solaris (at least 2.6/x86) does not use arp_ha.sa_family -
-	 * it returns 00:00:00:00:00:00 for non-ethernet media 
-	 */
-	if (arpReq.arp_ha.sa_data[0] == 0 &&
-	    arpReq.arp_ha.sa_data[1] == 0 &&
-	    arpReq.arp_ha.sa_data[2] == 0 &&
-	    arpReq.arp_ha.sa_data[3] == 0 &&
-	    arpReq.arp_ha.sa_data[4] == 0 && arpReq.arp_ha.sa_data[5] == 0)
-	    return 0;
-	debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
-	    arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
-	    arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
-	    arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
-	/* Do lookup */
-	*Top = splay_splay(&arpReq.arp_ha.sa_data, *Top, aclArpCompare);
-	debug(28, 3) ("aclMatchArp: '%s' %s\n",
-	    inet_ntoa(c), splayLastResult ? "NOT found" : "found");
-	return (0 == splayLastResult);
+    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1)
+    {
+        /*
+        *  Solaris (at least 2.6/x86) does not use arp_ha.sa_family -
+        * it returns 00:00:00:00:00:00 for non-ethernet media
+        */
+
+        if (arpReq.arp_ha.sa_data[0] == 0 &&
+                arpReq.arp_ha.sa_data[1] == 0 &&
+                arpReq.arp_ha.sa_data[2] == 0 &&
+                arpReq.arp_ha.sa_data[3] == 0 &&
+                arpReq.arp_ha.sa_data[4] == 0 && arpReq.arp_ha.sa_data[5] == 0)
+            return 0;
+
+        debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
+                      arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
+                      arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
+                      arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
+
+        /* Do lookup */
+        *Top = splay_splay(&arpReq.arp_ha.sa_data, *Top, aclArpCompare);
+
+        debug(28, 3) ("aclMatchArp: '%s' %s\n",
+                      inet_ntoa(c), splayLastResult ? "NOT found" : "found");
+
+        return (0 == splayLastResult);
     }
+
 #else
     WRITE ME;
+
 #endif
     /*
      * Address was not found on any interface
      */
     debug(28, 3) ("aclMatchArp: %s NOT found\n", inet_ntoa(c));
+
     return 0;
 }
 
@@ -1718,8 +2084,8 @@ aclDumpArpListWalkee(void * const &node, void *state)
     acl_arp_data *arp = (acl_arp_data *)node;
     static char buf[24];
     snprintf(buf, sizeof(buf), "%02x:%02x:%02x:%02x:%02x:%02x",
-	arp->eth[0], arp->eth[1], arp->eth[2], arp->eth[3],
-	arp->eth[4], arp->eth[5]);
+             arp->eth[0], arp->eth[1], arp->eth[2], arp->eth[3],
+             arp->eth[4], arp->eth[5]);
     wordlistAdd((wordlist **)state, buf);
 }
 
@@ -1742,8 +2108,10 @@ ACLList::operator new (size_t byteCount)
 {
     /* derived classes with different sizes must implement their own new */
     assert (byteCount == sizeof (ACLList));
+
     if (!Pool)
-	Pool = memPoolCreate("ACLList", sizeof (ACLList));
+        Pool = memPoolCreate("ACLList", sizeof (ACLList));
+
     return memPoolAlloc(Pool);
 }
 
@@ -1785,7 +2153,7 @@ acl_access::deleteSelf () const
 
 ACL::Prototype::Prototype() : prototype (NULL), typeString (NULL) {}
 
-ACL::Prototype::Prototype (ACL const *aPrototype, char const *aType) : prototype (aPrototype), typeString (aType) 
+ACL::Prototype::Prototype (ACL const *aPrototype, char const *aType) : prototype (aPrototype), typeString (aType)
 {
     registerMe ();
 }
@@ -1794,29 +2162,32 @@ Vector<ACL::Prototype const *> * ACL::Prototype::Registry;
 void *ACL::Prototype::Initialized;
 
 bool
-ACL::Prototype::Registered(char const *aType) 
+ACL::Prototype::Registered(char const *aType)
 {
     for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-	if (!strcmp (aType, (*i)->typeString))
-	    return true;
+        if (!strcmp (aType, (*i)->typeString))
+            return true;
+
     return false;
 }
 
 void
 ACL::Prototype::registerMe ()
 {
     if (!Registry || (Initialized != ((char *)Registry - 5))  ) {
-	/* TODO: extract this */
-	/* Not initialised */
-	Registry = new Vector <ACL::Prototype const *>;
-	Initialized = (char *)Registry - 5;
+        /* TODO: extract this */
+        /* Not initialised */
+        Registry = new Vector <ACL::Prototype const *>;
+        Initialized = (char *)Registry - 5;
     }
+
     if (Registered (typeString))
-	fatalf ("Attempt to register %s twice", typeString);
+        fatalf ("Attempt to register %s twice", typeString);
+
     Registry->push_back (this);
 }
 
-ACL::Prototype::~Prototype() 
+ACL::Prototype::~Prototype()
 {
     debug (28,2)("ACL::Prototype::~Prototype: TODO: unregister me\n");
 }
@@ -1825,8 +2196,9 @@ ACL *
 ACL::Prototype::Factory (char const *typeToClone)
 {
     for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-	if (!strcmp (typeToClone, (*i)->typeString)) 
-	    return (*i)->prototype->clone();
+        if (!strcmp (typeToClone, (*i)->typeString))
+            return (*i)->prototype->clone();
+
     return NULL;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: asn.cc,v 1.89 2003/02/12 06:11:00 robertc Exp $
+ * $Id: asn.cc,v 1.90 2003/02/21 22:50:06 robertc Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -55,19 +55,23 @@ typedef u_char m_int[1 + sizeof(unsigned int)];
 /* END of definitions for radix tree entries */
 
 /* Head for ip to asn radix tree */
+
 struct squid_radix_node_head *AS_tree_head;
 
 /*
  * Structure for as number information. it could be simply 
  * an intlist but it's coded as a structure for future
  * enhancements (e.g. expires)
  */
-struct _as_info {
+
+struct _as_info
+{
     intlist *as_number;
     time_t expires;		/* NOTUSED */
 };
 
-struct _ASState {
+struct _ASState
+{
     StoreEntry *entry;
     store_client *sc;
     request_t *request;
@@ -79,10 +83,14 @@ struct _ASState {
 };
 
 typedef struct _ASState ASState;
+
 typedef struct _as_info as_info;
 
 /* entry into the radix tree */
-struct _rtentry {
+
+struct _rtentry
+{
+
     struct squid_radix_node e_nodes[2];
     as_info *e_info;
     m_int e_addr;
@@ -94,7 +102,9 @@ typedef struct _rtentry rtentry_t;
 static int asnAddNet(char *, int);
 static void asnCacheStart(int as);
 static STCB asHandleReply;
+
 static int destroyRadixNode(struct squid_radix_node *rn, void *w);
+
 static int printRadixNode(struct squid_radix_node *rn, void *sentry);
 static void asnAclInitialize(acl * acls);
 static void asStateFree(void *data);
@@ -104,9 +114,11 @@ static OBJH asnStats;
 /* PUBLIC */
 
 int
+
 asnMatchIp(void *data, struct in_addr addr)
 {
     unsigned long lh;
+
     struct squid_radix_node *rn;
     as_info *e;
     m_int m_addr;
@@ -116,26 +128,36 @@ asnMatchIp(void *data, struct in_addr addr)
     debug(53, 3) ("asnMatchIp: Called for %s.\n", inet_ntoa(addr));
 
     if (AS_tree_head == NULL)
-	return 0;
+        return 0;
+
     if (addr.s_addr == no_addr.s_addr)
-	return 0;
+        return 0;
+
     if (addr.s_addr == any_addr.s_addr)
-	return 0;
+        return 0;
+
     store_m_int(lh, m_addr);
+
     rn = squid_rn_match(m_addr, AS_tree_head);
-    if (rn == NULL) {
-	debug(53, 3) ("asnMatchIp: Address not in as db.\n");
-	return 0;
+
+    if (rn == NULL)
+    {
+        debug(53, 3) ("asnMatchIp: Address not in as db.\n");
+        return 0;
     }
+
     debug(53, 3) ("asnMatchIp: Found in db!\n");
     e = ((rtentry_t *) rn)->e_info;
     assert(e);
+
     for (a = (intlist *) data; a; a = a->next)
-	for (b = e->as_number; b; b = b->next)
-	    if (a->i == b->i) {
-		debug(53, 5) ("asnMatchIp: Found a match!\n");
-		return 1;
-	    }
+        for (b = e->as_number; b; b = b->next)
+            if (a->i == b->i)
+            {
+                debug(53, 5) ("asnMatchIp: Found a match!\n");
+                return 1;
+            }
+
     debug(53, 5) ("asnMatchIp: AS not in as db.\n");
     return 0;
 }
@@ -145,19 +167,22 @@ asnAclInitialize(acl * acls)
 {
     acl *a;
     debug(53, 3) ("asnAclInitialize\n");
+
     for (a = acls; a; a = a->next) {
-	if (a->aclType() != ACL_DST_ASN && a->aclType() != ACL_SRC_ASN)
-	    continue;
-	a->startCache();
+        if (a->aclType() != ACL_DST_ASN && a->aclType() != ACL_SRC_ASN)
+            continue;
+
+        a->startCache();
     }
 }
 
 void
 ACL::startCache()
 {
     assert (aclType() == ACL_DST_ASN || aclType() == ACL_SRC_ASN);
+
     for (intlist *i = (intlist *)data; i; i = i->next)
-	asnCacheStart(i->i);
+        asnCacheStart(i->i);
 }
 
 /* initialize the radix tree structure */
@@ -171,17 +196,22 @@ asnInit(void)
     static int inited = 0;
     squid_max_keylen = 40;
     CBDATA_INIT_TYPE(ASState);
+
     if (0 == inited++)
-	squid_rn_init();
+        squid_rn_init();
+
     squid_rn_inithead((void **) &AS_tree_head, 8);
+
     asnAclInitialize(Config.aclList);
+
     cachemgrRegister("asndb", "AS Number Database", asnStats, 0, 1);
 }
 
 void
 asnFreeMemory(void)
 {
     squid_rn_walktree(AS_tree_head, destroyRadixNode, AS_tree_head);
+
     destroyRadixNode((struct squid_radix_node *) 0, (void *) AS_tree_head);
 }
 
@@ -210,23 +240,25 @@ asnCacheStart(int as)
     req = urlParse(METHOD_GET, asres);
     assert(NULL != req);
     asState->request = requestLink(req);
+
     if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
-	e = storeCreateEntry(asres, asres, request_flags(), METHOD_GET);
-	asState->sc = storeClientListAdd(e, asState);
-	fwdStart(-1, e, asState->request);
+        e = storeCreateEntry(asres, asres, request_flags(), METHOD_GET);
+        asState->sc = storeClientListAdd(e, asState);
+        fwdStart(-1, e, asState->request);
     } else {
-	storeLockObject(e);
-	asState->sc = storeClientListAdd(e, asState);
+        storeLockObject(e);
+        asState->sc = storeClientListAdd(e, asState);
     }
+
     asState->entry = e;
     asState->offset = 0;
     asState->reqofs = 0;
     StoreIOBuffer readBuffer (AS_REQBUF_SZ, asState->offset, asState->reqbuf);
     storeClientCopy(asState->sc,
-	e,
-	readBuffer,
-	asHandleReply,
-	asState);
+                    e,
+                    readBuffer,
+                    asHandleReply,
+                    asState);
 }
 
 static void
@@ -243,45 +275,52 @@ asHandleReply(void *data, StoreIOBuffer result)
     debug(53, 3) ("asHandleReply: buffer='%s'\n", buf);
 
     /* First figure out whether we should abort the request */
+
     if (EBIT_TEST(e->flags, ENTRY_ABORTED)) {
-	asStateFree(asState);
-	return;
+        asStateFree(asState);
+        return;
     }
+
     if (result.length == 0 && asState->dataRead) {
-	debug(53, 3) ("asHandleReply: Done: %s\n", storeUrl(e));
-	asStateFree(asState);
-	return;
+        debug(53, 3) ("asHandleReply: Done: %s\n", storeUrl(e));
+        asStateFree(asState);
+        return;
     } else if (result.flags.error) {
-	debug(53, 1) ("asHandleReply: Called with Error set and size=%u\n", (unsigned int) result.length);
-	asStateFree(asState);
-	return;
+        debug(53, 1) ("asHandleReply: Called with Error set and size=%u\n", (unsigned int) result.length);
+        asStateFree(asState);
+        return;
     } else if (HTTP_OK != e->getReply()->sline.status) {
-	debug(53, 1) ("WARNING: AS %d whois request failed\n",
-	    asState->as_number);
-	asStateFree(asState);
-	return;
+        debug(53, 1) ("WARNING: AS %d whois request failed\n",
+                      asState->as_number);
+        asStateFree(asState);
+        return;
     }
+
     /*
      * Next, attempt to parse our request
      * Remembering that the actual buffer size is retsize + reqofs!
      */
     s = buf;
+
     while (s - buf < (off_t)(result.length + asState->reqofs) && *s != '\0') {
-	while (*s && xisspace(*s))
-	    s++;
-	for (t = s; *t; t++) {
-	    if (xisspace(*t))
-		break;
-	}
-	if (*t == '\0') {
-	    /* oof, word should continue on next block */
-	    break;
-	}
-	*t = '\0';
-	debug(53, 3) ("asHandleReply: AS# %s (%d)\n", s, asState->as_number);
-	asnAddNet(s, asState->as_number);
-	s = t + 1;
-	asState->dataRead = 1;
+        while (*s && xisspace(*s))
+            s++;
+
+        for (t = s; *t; t++) {
+            if (xisspace(*t))
+                break;
+        }
+
+        if (*t == '\0') {
+            /* oof, word should continue on next block */
+            break;
+        }
+
+        *t = '\0';
+        debug(53, 3) ("asHandleReply: AS# %s (%d)\n", s, asState->as_number);
+        asnAddNet(s, asState->as_number);
+        s = t + 1;
+        asState->dataRead = 1;
     }
 
     /*
@@ -290,6 +329,7 @@ asHandleReply(void *data, StoreIOBuffer result)
      * around for the next request
      */
     leftoversz = (asState->reqofs + result.length) - (s - buf);
+
     assert(leftoversz >= 0);
 
     /*
@@ -302,29 +342,32 @@ asHandleReply(void *data, StoreIOBuffer result)
      * Next, update our offset and reqofs, and kick off a copy if required
      */
     asState->offset += result.length;
+
     asState->reqofs = leftoversz;
+
     debug(53, 3) ("asState->offset = %ld\n", (long int) asState->offset);
+
     if (e->store_status == STORE_PENDING) {
-	debug(53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", storeUrl(e));
-	StoreIOBuffer tempBuffer (AS_REQBUF_SZ - asState->reqofs,
-				  asState->offset, 
-				  asState->reqbuf + asState->reqofs);
-	storeClientCopy(asState->sc,
-	    e,
-	    tempBuffer,
-	    asHandleReply,
-	    asState);
+        debug(53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", storeUrl(e));
+        StoreIOBuffer tempBuffer (AS_REQBUF_SZ - asState->reqofs,
+                                  asState->offset,
+                                  asState->reqbuf + asState->reqofs);
+        storeClientCopy(asState->sc,
+                        e,
+                        tempBuffer,
+                        asHandleReply,
+                        asState);
     } else {
-	StoreIOBuffer tempBuffer;
-	debug(53, 3) ("asHandleReply: store complete, but data recieved %s\n", storeUrl(e));
-	tempBuffer.offset = asState->offset;
-	tempBuffer.length = AS_REQBUF_SZ - asState->reqofs;
-	tempBuffer.data = asState->reqbuf + asState->reqofs;
-	storeClientCopy(asState->sc,
-	    e,
-	    tempBuffer,
-	    asHandleReply,
-	    asState);
+        StoreIOBuffer tempBuffer;
+        debug(53, 3) ("asHandleReply: store complete, but data recieved %s\n", storeUrl(e));
+        tempBuffer.offset = asState->offset;
+        tempBuffer.length = AS_REQBUF_SZ - asState->reqofs;
+        tempBuffer.data = asState->reqbuf + asState->reqofs;
+        storeClientCopy(asState->sc,
+                        e,
+                        tempBuffer,
+                        asHandleReply,
+                        asState);
     }
 }
 
@@ -347,86 +390,119 @@ static int
 asnAddNet(char *as_string, int as_number)
 {
     rtentry_t *e = (rtentry_t *)xmalloc(sizeof(rtentry_t));
+
     struct squid_radix_node *rn;
     char dbg1[32], dbg2[32];
     intlist **Tail = NULL;
     intlist *q = NULL;
     as_info *asinfo = NULL;
+
     struct in_addr in_a, in_m;
     long mask, addr;
     char *t;
     int bitl;
 
     t = strchr(as_string, '/');
+
     if (t == NULL) {
-	debug(53, 3) ("asnAddNet: failed, invalid response from whois server.\n");
-	return 0;
+        debug(53, 3) ("asnAddNet: failed, invalid response from whois server.\n");
+        return 0;
     }
+
     *t = '\0';
     addr = inet_addr(as_string);
     bitl = atoi(t + 1);
+
     if (bitl < 0)
-	bitl = 0;
+        bitl = 0;
+
     if (bitl > 32)
-	bitl = 32;
+        bitl = 32;
+
     mask = bitl ? 0xfffffffful << (32 - bitl) : 0;
 
     in_a.s_addr = addr;
+
     in_m.s_addr = mask;
+
     xstrncpy(dbg1, inet_ntoa(in_a), 32);
+
     xstrncpy(dbg2, inet_ntoa(in_m), 32);
+
     addr = ntohl(addr);
+
     /*mask = ntohl(mask); */
     debug(53, 3) ("asnAddNet: called for %s/%s\n", dbg1, dbg2);
+
     memset(e, '\0', sizeof(rtentry_t));
+
     store_m_int(addr, e->e_addr);
+
     store_m_int(mask, e->e_mask);
+
     rn = squid_rn_lookup(e->e_addr, e->e_mask, AS_tree_head);
+
     if (rn != NULL) {
-	asinfo = ((rtentry_t *) rn)->e_info;
-	if (intlistFind(asinfo->as_number, as_number)) {
-	    debug(53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
-		dbg1, bitl, as_number);
-	} else {
-	    debug(53, 3) ("asnAddNet: Warning: Found a network with multiple AS numbers!\n");
-	    for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next);
-	    q = (intlist *)xcalloc(1, sizeof(intlist));
-	    q->i = as_number;
-	    *(Tail) = q;
-	    e->e_info = asinfo;
-	}
+        asinfo = ((rtentry_t *) rn)->e_info;
+
+        if (intlistFind(asinfo->as_number, as_number)) {
+            debug(53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
+                          dbg1, bitl, as_number);
+        } else {
+            debug(53, 3) ("asnAddNet: Warning: Found a network with multiple AS numbers!\n");
+
+            for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next)
+
+                ;
+            q = (intlist *)xcalloc(1, sizeof(intlist));
+
+            q->i = as_number;
+
+            *(Tail) = q;
+
+            e->e_info = asinfo;
+        }
     } else {
-	q = (intlist *)xcalloc(1, sizeof(intlist));
-	q->i = as_number;
-	asinfo = (as_info *)xmalloc(sizeof(asinfo));
-	asinfo->as_number = q;
-	rn = squid_rn_addroute(e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
-	rn = squid_rn_match(e->e_addr, AS_tree_head);
-	assert(rn != NULL);
-	e->e_info = asinfo;
+        q = (intlist *)xcalloc(1, sizeof(intlist));
+        q->i = as_number;
+        asinfo = (as_info *)xmalloc(sizeof(asinfo));
+        asinfo->as_number = q;
+        rn = squid_rn_addroute(e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
+        rn = squid_rn_match(e->e_addr, AS_tree_head);
+        assert(rn != NULL);
+        e->e_info = asinfo;
     }
+
     if (rn == 0) {
-	xfree(e);
-	debug(53, 3) ("asnAddNet: Could not add entry.\n");
-	return 0;
+        xfree(e);
+        debug(53, 3) ("asnAddNet: Could not add entry.\n");
+        return 0;
     }
+
     e->e_info = asinfo;
     return 1;
 }
 
 static int
+
 destroyRadixNode(struct squid_radix_node *rn, void *w)
 {
+
     struct squid_radix_node_head *rnh = (struct squid_radix_node_head *) w;
 
-    if (rn && !(rn->rn_flags & RNF_ROOT)) {
-	rtentry_t *e = (rtentry_t *) rn;
-	rn = squid_rn_delete(rn->rn_key, rn->rn_mask, rnh);
-	if (rn == 0)
-	    debug(53, 3) ("destroyRadixNode: internal screwup\n");
-	destroyRadixNodeInfo(e->e_info);
-	xfree(rn);
+    if (rn && !(rn->rn_flags & RNF_ROOT))
+    {
+        rtentry_t *e = (rtentry_t *) rn;
+        rn = squid_rn_delete(rn->rn_key, rn->rn_mask, rnh);
+
+        if (rn == 0)
+            debug(53, 3) ("destroyRadixNode: internal screwup\n");
+
+        destroyRadixNodeInfo(e->e_info);
+
+        xfree(rn);
     }
+
     return 1;
 }
 
@@ -435,46 +511,57 @@ destroyRadixNodeInfo(as_info * e_info)
 {
     intlist *prev = NULL;
     intlist *data = e_info->as_number;
+
     while (data) {
-	prev = data;
-	data = data->next;
-	xfree(prev);
+        prev = data;
+        data = data->next;
+        xfree(prev);
     }
+
     xfree(data);
 }
 
 static int
 mask_len(u_long mask)
 {
     int len = 32;
+
     if (mask == 0)
-	return 0;
+        return 0;
+
     while ((mask & 1) == 0) {
-	len--;
-	mask >>= 1;
+        len--;
+        mask >>= 1;
     }
+
     return len;
 }
 
 static int
+
 printRadixNode(struct squid_radix_node *rn, void *_sentry)
 {
     StoreEntry *sentry = (StoreEntry *)_sentry;
     rtentry_t *e = (rtentry_t *) rn;
     intlist *q;
     as_info *asinfo;
+
     struct in_addr addr;
+
     struct in_addr mask;
     assert(e);
     assert(e->e_info);
     (void) get_m_int(addr.s_addr, e->e_addr);
     (void) get_m_int(mask.s_addr, e->e_mask);
     storeAppendPrintf(sentry, "%15s/%d\t",
-	inet_ntoa(addr), mask_len(ntohl(mask.s_addr)));
+                      inet_ntoa(addr), mask_len(ntohl(mask.s_addr)));
     asinfo = e->e_info;
     assert(asinfo->as_number);
+
     for (q = asinfo->as_number; q; q = q->next)
-	storeAppendPrintf(sentry, " %d", q->i);
+        storeAppendPrintf(sentry, " %d", q->i);
+
     storeAppendPrintf(sentry, "\n");
+
     return 0;
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: auth_basic.cc,v 1.23 2003/02/06 09:57:39 robertc Exp $
+ * $Id: auth_basic.cc,v 1.24 2003/02/21 22:50:26 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -114,18 +114,25 @@ static void
 authBasicDone(void)
 {
     if (basicauthenticators)
-	helperShutdown(basicauthenticators);
+        helperShutdown(basicauthenticators);
+
     authbasic_initialised = 0;
+
     if (!shutting_down)
-	return;
+        return;
+
     if (basicauthenticators)
-	helperFree(basicauthenticators);
+        helperFree(basicauthenticators);
+
     basicauthenticators = NULL;
+
 #if DEBUGSHUTDOWN
+
     if (basic_data_pool) {
-	memPoolDestroy(&basic_data_pool);
-	basic_data_pool = NULL;
+        memPoolDestroy(&basic_data_pool);
+        basic_data_pool = NULL;
     }
+
 #endif
     debug(29, 2) ("authBasicDone: Basic authentication Shutdown.\n");
 }
@@ -140,11 +147,12 @@ static int
 authBasicConfigured()
 {
     if ((basicConfig != NULL) && (basicConfig->authenticate != NULL) &&
-	(basicConfig->authenticateChildren != 0) &&
-	(basicConfig->basicAuthRealm != NULL)) {
-	debug(29, 9) ("authBasicConfigured: returning configured\n");
-	return 1;
+            (basicConfig->authenticateChildren != 0) &&
+            (basicConfig->basicAuthRealm != NULL)) {
+        debug(29, 9) ("authBasicConfigured: returning configured\n");
+        return 1;
     }
+
     debug(29, 9) ("authBasicConfigured: returning unconfigured\n");
     return 0;
 }
@@ -153,9 +161,12 @@ static int
 authenticateBasicAuthenticated(auth_user_request_t * auth_user_request)
 {
     basic_data *basic_auth = static_cast<basic_data *>(auth_user_request->auth_user->scheme_data);
+
     if ((basic_auth->flags.credentials_ok == 1) && (basic_auth->credentials_checkedtime + basicConfig->credentialsTTL > squid_curtime))
-	return 1;
+        return 1;
+
     debug(29, 4) ("User not authenticated or credentials need rechecking.\n");
+
     return 0;
 }
 
@@ -165,6 +176,7 @@ authenticateBasiccmpUsername(basic_data * u1, basic_data * u2)
 {
     return strcmp(u1->username, u2->username);
 }
+
 #endif
 
 /* log a basic user in
@@ -182,51 +194,62 @@ authenticateBasicAuthenticateUser(auth_user_request_t * auth_user_request, reque
     basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
 
     /* if the password is not ok, do an identity */
+
     if (basic_auth->flags.credentials_ok != 1)
-	return;
+        return;
 
     /* are we about to recheck the credentials externally? */
     if ((basic_auth->credentials_checkedtime + basicConfig->credentialsTTL) <= squid_curtime) {
-	debug(29, 4) ("authBasicAuthenticate: credentials expired - rechecking\n");
-	return;
+        debug(29, 4) ("authBasicAuthenticate: credentials expired - rechecking\n");
+        return;
     }
+
     /* we have been through the external helper, and the credentials haven't expired */
     debug(29, 9) ("authenticateBasicAuthenticateuser: user '%s' authenticated\n",
-	basic_auth->username);
+                  basic_auth->username);
 
     /* Decode now takes care of finding the auth_user struct in the cache */
     /* after external auth occurs anyway */
     auth_user->expiretime = current_time.tv_sec;
+
     return;
 }
 
 int
 authenticateBasicDirection(auth_user_request_t * auth_user_request)
 {
-/* null auth_user is checked for by authenticateDirection */
+    /* null auth_user is checked for by authenticateDirection */
     auth_user_t *auth_user = auth_user_request->auth_user;
     basic_data *basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
+
     switch (basic_auth->flags.credentials_ok) {
+
     case 0:			/* not checked */
-	return -1;
+        return -1;
+
     case 1:			/* checked & ok */
-	if (basic_auth->credentials_checkedtime + basicConfig->credentialsTTL <= squid_curtime)
-	    return -1;
-	return 0;
+
+        if (basic_auth->credentials_checkedtime + basicConfig->credentialsTTL <= squid_curtime)
+            return -1;
+
+        return 0;
+
     case 2:			/* paused while waiting for a username:password check on another request */
-	return -1;
+        return -1;
+
     case 3:			/* authentication process failed. */
-	return -2;
+        return -2;
     }
+
     return -2;
 }
 
 void
 authenticateBasicFixErrorHeader(auth_user_request_t * auth_user_request, HttpReply * rep, http_hdr_type type, request_t * request)
 {
     if (basicConfig->authenticate) {
-	debug(29, 9) ("authenticateFixErrorHeader: Sending type:%d header: 'Basic realm=\"%s\"'\n", type, basicConfig->basicAuthRealm);
-	httpHeaderPutStrf(&rep->header, type, "Basic realm=\"%s\"", basicConfig->basicAuthRealm);
+        debug(29, 9) ("authenticateFixErrorHeader: Sending type:%d header: 'Basic realm=\"%s\"'\n", type, basicConfig->basicAuthRealm);
+        httpHeaderPutStrf(&rep->header, type, "Basic realm=\"%s\"", basicConfig->basicAuthRealm);
     }
 }
 
@@ -235,13 +258,18 @@ void
 authBasicFreeConfig(authScheme * scheme)
 {
     if (basicConfig == NULL)
-	return;
+        return;
+
     assert(basicConfig == scheme->scheme_data);
+
     if (basicConfig->authenticate)
-	wordlistDestroy(&basicConfig->authenticate);
+        wordlistDestroy(&basicConfig->authenticate);
+
     if (basicConfig->basicAuthRealm)
-	safe_free(basicConfig->basicAuthRealm);
+        safe_free(basicConfig->basicAuthRealm);
+
     xfree(basicConfig);
+
     basicConfig = NULL;
 }
 
@@ -250,11 +278,15 @@ authenticateBasicFreeUser(auth_user_t * auth_user)
 {
     basic_data *basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
     debug(29, 5) ("authenticateBasicFreeUser: Clearing Basic scheme data\n");
+
     if (basic_auth->username)
-	xfree(basic_auth->username);
+        xfree(basic_auth->username);
+
     if (basic_auth->passwd)
-	xfree(basic_auth->passwd);
+        xfree(basic_auth->passwd);
+
     memPoolFree(basic_data_pool, auth_user->scheme_data);
+
     auth_user->scheme_data = NULL;
 }
 
@@ -268,31 +300,43 @@ authenticateBasicHandleReply(void *data, char *reply)
     char *t = NULL;
     void *cbdata;
     debug(29, 9) ("authenticateBasicHandleReply: {%s}\n", reply ? reply : "<NULL>");
+
     if (reply) {
-	if ((t = strchr(reply, ' ')))
-	    *t = '\0';
-	if (*reply == '\0')
-	    reply = NULL;
+        if ((t = strchr(reply, ' ')))
+            *t = '\0';
+
+        if (*reply == '\0')
+            reply = NULL;
     }
+
     assert(r->auth_user_request != NULL);
     assert(r->auth_user_request->auth_user->auth_type == AUTH_BASIC);
     auth_user = r->auth_user_request->auth_user;
     basic_auth = static_cast<basic_data *>(auth_user->scheme_data);
+
     if (reply && (strncasecmp(reply, "OK", 2) == 0))
-	basic_auth->flags.credentials_ok = 1;
+        basic_auth->flags.credentials_ok = 1;
     else
-	basic_auth->flags.credentials_ok = 3;
+        basic_auth->flags.credentials_ok = 3;
+
     basic_auth->credentials_checkedtime = squid_curtime;
+
     if (cbdataReferenceValidDone(r->data, &cbdata))
-	r->handler(cbdata, NULL);
+        r->handler(cbdata, NULL);
+
     cbdataReferenceDone(r->data);
+
     while (basic_auth->auth_queue) {
-	tmpnode = basic_auth->auth_queue->next;
-	if (cbdataReferenceValidDone(basic_auth->auth_queue->data, &cbdata))
-	    basic_auth->auth_queue->handler(cbdata, NULL);
-	xfree(basic_auth->auth_queue);
-	basic_auth->auth_queue = tmpnode;
+        tmpnode = basic_auth->auth_queue->next;
+
+        if (cbdataReferenceValidDone(basic_auth->auth_queue->data, &cbdata))
+            basic_auth->auth_queue->handler(cbdata, NULL);
+
+        xfree(basic_auth->auth_queue);
+
+        basic_auth->auth_queue = tmpnode;
     }
+
     authenticateStateFree(r);
 }
 
@@ -302,43 +346,49 @@ authBasicCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
     auth_basic_config *config = static_cast<auth_basic_config *>(scheme->scheme_data);
     wordlist *list = config->authenticate;
     storeAppendPrintf(entry, "%s %s", name, "basic");
+
     while (list != NULL) {
-	storeAppendPrintf(entry, " %s", list->key);
-	list = list->next;
+        storeAppendPrintf(entry, " %s", list->key);
+        list = list->next;
     }
+
     storeAppendPrintf(entry, "\n%s %s realm %s\n%s %s children %d\n%s %s credentialsttl %d seconds\n",
-	name, "basic", config->basicAuthRealm,
-	name, "basic", config->authenticateChildren,
-	name, "basic", (int) config->credentialsTTL);
+                      name, "basic", config->basicAuthRealm,
+                      name, "basic", config->authenticateChildren,
+                      name, "basic", (int) config->credentialsTTL);
 
 }
 
 static void
 authBasicParse(authScheme * scheme, int n_configured, char *param_str)
 {
     if (scheme->scheme_data == NULL) {
-	assert(basicConfig == NULL);
-	/* this is the first param to be found */
-	scheme->scheme_data = xmalloc(sizeof(auth_basic_config));
-	memset(scheme->scheme_data, 0, sizeof(auth_basic_config));
-	basicConfig = static_cast<auth_basic_config *>(scheme->scheme_data);
-	basicConfig->authenticateChildren = 5;
-	basicConfig->credentialsTTL = 2 * 60 * 60;	/* two hours */
+        assert(basicConfig == NULL);
+        /* this is the first param to be found */
+        scheme->scheme_data = xmalloc(sizeof(auth_basic_config));
+        memset(scheme->scheme_data, 0, sizeof(auth_basic_config));
+        basicConfig = static_cast<auth_basic_config *>(scheme->scheme_data);
+        basicConfig->authenticateChildren = 5;
+        basicConfig->credentialsTTL = 2 * 60 * 60;	/* two hours */
     }
+
     basicConfig =  static_cast<auth_basic_config *>(scheme->scheme_data);
+
     if (strcasecmp(param_str, "program") == 0) {
-	if (basicConfig->authenticate)
-	    wordlistDestroy(&basicConfig->authenticate);
-	parse_wordlist(&basicConfig->authenticate);
-	requirePathnameExists("authparam basic program", basicConfig->authenticate->key);
+        if (basicConfig->authenticate)
+            wordlistDestroy(&basicConfig->authenticate);
+
+        parse_wordlist(&basicConfig->authenticate);
+
+        requirePathnameExists("authparam basic program", basicConfig->authenticate->key);
     } else if (strcasecmp(param_str, "children") == 0) {
-	parse_int(&basicConfig->authenticateChildren);
+        parse_int(&basicConfig->authenticateChildren);
     } else if (strcasecmp(param_str, "realm") == 0) {
-	parse_eol(&basicConfig->basicAuthRealm);
+        parse_eol(&basicConfig->basicAuthRealm);
     } else if (strcasecmp(param_str, "credentialsttl") == 0) {
-	parse_time_t(&basicConfig->credentialsTTL);
+        parse_time_t(&basicConfig->credentialsTTL);
     } else {
-	debug(28, 0) ("unrecognised basic auth scheme parameter '%s'\n", param_str);
+        debug(28, 0) ("unrecognised basic auth scheme parameter '%s'\n", param_str);
     }
 }
 
@@ -356,8 +406,10 @@ char const *
 authenticateBasicUsername(auth_user_t const * auth_user)
 {
     basic_data *basic_auth =  static_cast<basic_data *>(auth_user->scheme_data);
+
     if (basic_auth)
-	return basic_auth->username;
+        return basic_auth->username;
+
     return NULL;
 }
 
@@ -376,8 +428,7 @@ authBasicDataNew(void)
 #if UNUSED_CODE
 static void
 authBasicDataFree(basic_data * basic_auth)
-{
-}
+{}
 
 #endif
 
@@ -386,14 +437,17 @@ authBasicAuthUserFindUsername(const char *username)
 {
     AuthUserHashPointer *usernamehash;
     debug(29, 9) ("authBasicAuthUserFindUsername: Looking for user '%s'\n", username);
+
     if (username && (usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, username)))) {
-	while (usernamehash) {
-	    if ((authUserHashPointerUser(usernamehash)->auth_type == AUTH_BASIC) &&
-		!strcmp(username, (char const *)usernamehash->key))
-		return authUserHashPointerUser(usernamehash);
-	    usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
-	}
+        while (usernamehash) {
+            if ((authUserHashPointerUser(usernamehash)->auth_type == AUTH_BASIC) &&
+                    !strcmp(username, (char const *)usernamehash->key))
+                return authUserHashPointerUser(usernamehash);
+
+            usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
+        }
     }
+
     return NULL;
 }
 
@@ -417,116 +471,137 @@ authenticateBasicDecodeAuth(auth_user_request_t * auth_user_request, const char
 
     /* decode the username */
     /* trim BASIC from string */
+
     while (!xisspace(*proxy_auth))
-	proxy_auth++;
+        proxy_auth++;
 
     local_basic.passwd = NULL;
 
     /* Trim leading whitespace before decoding */
     while (xisspace(*proxy_auth))
-	proxy_auth++;
+        proxy_auth++;
+
     /* username and password */
     sent_auth = xstrdup(proxy_auth);
+
     /* Trim trailing \n before decoding */
     strtok(sent_auth, "\n");
+
     cleartext = uudecode(sent_auth);
+
     xfree(sent_auth);
+
     /*
      * Don't allow NL or CR in the credentials.
      * Oezguer Kesim <oec@codeblau.de>
      */
     strtok(cleartext, "\r\n");
+
     debug(29, 9) ("authenticateBasicDecodeAuth: cleartext = '%s'\n", cleartext);
+
     local_basic.username = xstrndup(cleartext, USER_IDENT_SZ);
+
     xfree(cleartext);
+
     if ((cleartext = strchr(local_basic.username, ':')) != NULL)
-	*(cleartext)++ = '\0';
+        *(cleartext)++ = '\0';
+
     local_basic.passwd = cleartext;
+
     if (cleartext == NULL) {
-	debug(29, 4) ("authenticateBasicDecodeAuth: no password in proxy authorization header '%s'\n",
-	    proxy_auth);
-	local_basic.passwd = NULL;
-	authenticateSetDenyMessage (auth_user_request, "no password was present in the HTTP [proxy-]authorization header. This is most likely a browser bug");
+        debug(29, 4) ("authenticateBasicDecodeAuth: no password in proxy authorization header '%s'\n",
+                      proxy_auth);
+        local_basic.passwd = NULL;
+        authenticateSetDenyMessage (auth_user_request, "no password was present in the HTTP [proxy-]authorization header. This is most likely a browser bug");
     } else if (*cleartext == '\0') {
-	debug(29, 4) ("authenticateBasicDecodeAuth: Disallowing empty password,"
-	    "user is '%s'\n", local_basic.username);
-	local_basic.passwd = NULL;
-	authenticateSetDenyMessage (auth_user_request, "Request denied because you provided an empty password. Users MUST have a password.");
+        debug(29, 4) ("authenticateBasicDecodeAuth: Disallowing empty password,"
+                      "user is '%s'\n", local_basic.username);
+        local_basic.passwd = NULL;
+        authenticateSetDenyMessage (auth_user_request, "Request denied because you provided an empty password. Users MUST have a password.");
     }
+
     /* special case: we have to free the strings for user and password
      * if we are not returning a filled out structure 
      */
     if (local_basic.passwd == NULL) {
-	if (local_basic.username) {
-	    /* log the username */
-	    debug(29, 9) ("authBasicDecodeAuth: Creating new user for logging '%s'\n", local_basic.username);
-	    /* new auth_user */
-	    auth_user = authenticateAuthUserNew("basic");
-	    /* new scheme data */
-	    basic_auth = authBasicDataNew();
-	    /* save the credentials */
-	    basic_auth->username = local_basic.username;
-	    /* link the scheme data in */
-	    auth_user->scheme_data = basic_auth;
-	    /* set the auth_user type */
-	    auth_user->auth_type = AUTH_BROKEN;
-	    /* link the request to the user */
-	    auth_user_request->auth_user = auth_user;
-	    /* lock for the auth_user_request link */
-	    authenticateAuthUserLock(auth_user);
-	    node = dlinkNodeNew();
-	    dlinkAdd(auth_user_request, node, &auth_user->requests);
-	}
-	return;
+        if (local_basic.username) {
+            /* log the username */
+            debug(29, 9) ("authBasicDecodeAuth: Creating new user for logging '%s'\n", local_basic.username);
+            /* new auth_user */
+            auth_user = authenticateAuthUserNew("basic");
+            /* new scheme data */
+            basic_auth = authBasicDataNew();
+            /* save the credentials */
+            basic_auth->username = local_basic.username;
+            /* link the scheme data in */
+            auth_user->scheme_data = basic_auth;
+            /* set the auth_user type */
+            auth_user->auth_type = AUTH_BROKEN;
+            /* link the request to the user */
+            auth_user_request->auth_user = auth_user;
+            /* lock for the auth_user_request link */
+            authenticateAuthUserLock(auth_user);
+            node = dlinkNodeNew();
+            dlinkAdd(auth_user_request, node, &auth_user->requests);
+        }
+
+        return;
     } else {
-	local_basic.passwd = xstrndup(cleartext, USER_IDENT_SZ);
+        local_basic.passwd = xstrndup(cleartext, USER_IDENT_SZ);
     }
 
     /* now lookup and see if we have a matching auth_user structure in memory. */
 
     if ((auth_user = authBasicAuthUserFindUsername(local_basic.username)) == NULL) {
-	/* the user doesn't exist in the username cache yet */
-	debug(29, 9) ("authBasicDecodeAuth: Creating new user '%s'\n", local_basic.username);
-	/* new auth_user */
-	auth_user = authenticateAuthUserNew("basic");
-	/* new scheme data */
-	basic_auth = authBasicDataNew();
-	/* save the credentials */
-	basic_auth->username = local_basic.username;
-	basic_auth->passwd = local_basic.passwd;
-	/* link the scheme data in */
-	auth_user->scheme_data = basic_auth;
-	/* set the auth_user type */
-	auth_user->auth_type = AUTH_BASIC;
-	/* current time for timeouts */
-	auth_user->expiretime = current_time.tv_sec;
-
-	/* this auth_user struct is the 'lucky one' to get added to the username cache */
-	/* the requests after this link to the auth_user */
-	/* store user in hash */
-	authenticateUserNameCacheAdd(auth_user);
+        /* the user doesn't exist in the username cache yet */
+        debug(29, 9) ("authBasicDecodeAuth: Creating new user '%s'\n", local_basic.username);
+        /* new auth_user */
+        auth_user = authenticateAuthUserNew("basic");
+        /* new scheme data */
+        basic_auth = authBasicDataNew();
+        /* save the credentials */
+        basic_auth->username = local_basic.username;
+        basic_auth->passwd = local_basic.passwd;
+        /* link the scheme data in */
+        auth_user->scheme_data = basic_auth;
+        /* set the auth_user type */
+        auth_user->auth_type = AUTH_BASIC;
+        /* current time for timeouts */
+        auth_user->expiretime = current_time.tv_sec;
+
+        /* this auth_user struct is the 'lucky one' to get added to the username cache */
+        /* the requests after this link to the auth_user */
+        /* store user in hash */
+        authenticateUserNameCacheAdd(auth_user);
     } else {
-	debug(29, 9) ("authBasicDecodeAuth: Found user '%s' in the user cache as '%p'\n", local_basic.username, auth_user);
-	xfree(local_basic.username);
-	basic_auth =  static_cast<basic_data *>(auth_user->scheme_data);
-	if (strcmp(local_basic.passwd, basic_auth->passwd)) {
-	    debug(29, 4) ("authBasicDecodeAuth: new password found. Updating in user master record and resetting auth state to unchecked\n");
-	    basic_auth->flags.credentials_ok = 0;
-	    xfree(basic_auth->passwd);
-	    basic_auth->passwd = local_basic.passwd;
-	} else
-	    xfree(local_basic.passwd);
-	if (basic_auth->flags.credentials_ok == 3) {
-	    debug(29, 4) ("authBasicDecodeAuth: last attempt to authenticate this user failed, resetting auth state to unchecked\n");
-	    basic_auth->flags.credentials_ok = 0;
-	}
+        debug(29, 9) ("authBasicDecodeAuth: Found user '%s' in the user cache as '%p'\n", local_basic.username, auth_user);
+        xfree(local_basic.username);
+        basic_auth =  static_cast<basic_data *>(auth_user->scheme_data);
+
+        if (strcmp(local_basic.passwd, basic_auth->passwd)) {
+            debug(29, 4) ("authBasicDecodeAuth: new password found. Updating in user master record and resetting auth state to unchecked\n");
+            basic_auth->flags.credentials_ok = 0;
+            xfree(basic_auth->passwd);
+            basic_auth->passwd = local_basic.passwd;
+        } else
+            xfree(local_basic.passwd);
+
+        if (basic_auth->flags.credentials_ok == 3) {
+            debug(29, 4) ("authBasicDecodeAuth: last attempt to authenticate this user failed, resetting auth state to unchecked\n");
+            basic_auth->flags.credentials_ok = 0;
+        }
     }
+
     /* link the request to the user */
     auth_user_request->auth_user = auth_user;
+
     /* lock for the auth_user_request link */
     authenticateAuthUserLock(auth_user);
+
     node = dlinkNodeNew();
+
     dlinkAdd(auth_user_request, node, &auth_user->requests);
+
     return;
 }
 
@@ -536,23 +611,32 @@ static void
 authBasicInit(authScheme * scheme)
 {
     static int init = 0;
+
     if (basicConfig->authenticate) {
-	if (!basic_data_pool)
-	    basic_data_pool = memPoolCreate("Basic Scheme User Data", sizeof(basic_data));
-	authbasic_initialised = 1;
-	if (basicauthenticators == NULL)
-	    basicauthenticators = helperCreate("basicauthenticator");
-	basicauthenticators->cmdline = basicConfig->authenticate;
-	basicauthenticators->n_to_start = basicConfig->authenticateChildren;
-	basicauthenticators->ipc_type = IPC_STREAM;
-	helperOpenServers(basicauthenticators);
-	if (!init) {
-	    cachemgrRegister("basicauthenticator",
-		"Basic User Authenticator Stats",
-		authenticateBasicStats, 0, 1);
-	    init++;
-	}
-	CBDATA_INIT_TYPE(AuthenticateStateData);
+        if (!basic_data_pool)
+            basic_data_pool = memPoolCreate("Basic Scheme User Data", sizeof(basic_data));
+
+        authbasic_initialised = 1;
+
+        if (basicauthenticators == NULL)
+            basicauthenticators = helperCreate("basicauthenticator");
+
+        basicauthenticators->cmdline = basicConfig->authenticate;
+
+        basicauthenticators->n_to_start = basicConfig->authenticateChildren;
+
+        basicauthenticators->ipc_type = IPC_STREAM;
+
+        helperOpenServers(basicauthenticators);
+
+        if (!init) {
+            cachemgrRegister("basicauthenticator",
+                             "Basic User Authenticator Stats",
+                             authenticateBasicStats, 0, 1);
+            init++;
+        }
+
+        CBDATA_INIT_TYPE(AuthenticateStateData);
     }
 }
 
@@ -570,34 +654,36 @@ authenticateBasicStart(auth_user_request_t * auth_user_request, RH * handler, vo
     assert(auth_user_request->auth_user->scheme_data != NULL);
     basic_auth = static_cast<basic_data *>(auth_user_request->auth_user->scheme_data);
     debug(29, 9) ("authenticateStart: '%s:%s'\n", basic_auth->username,
-	basic_auth->passwd);
+                  basic_auth->passwd);
+
     if (basicConfig->authenticate == NULL) {
-	handler(data, NULL);
-	return;
+        handler(data, NULL);
+        return;
     }
+
     /* check to see if the auth_user already has a request outstanding */
     if (basic_auth->flags.credentials_ok == 2) {
-	/* there is a request with the same credentials already being verified */
-	BasicAuthQueueNode *node;
-	node = static_cast<BasicAuthQueueNode *>(xmalloc(sizeof(BasicAuthQueueNode)));
-	assert(node);
-	/* save the details */
-	node->next = basic_auth->auth_queue;
-	basic_auth->auth_queue = node;
-	node->auth_user_request = auth_user_request;
-	node->handler = handler;
-	node->data = cbdataReference(data);
-	return;
+        /* there is a request with the same credentials already being verified */
+        BasicAuthQueueNode *node;
+        node = static_cast<BasicAuthQueueNode *>(xmalloc(sizeof(BasicAuthQueueNode)));
+        assert(node);
+        /* save the details */
+        node->next = basic_auth->auth_queue;
+        basic_auth->auth_queue = node;
+        node->auth_user_request = auth_user_request;
+        node->handler = handler;
+        node->data = cbdataReference(data);
+        return;
     } else {
-	r = cbdataAlloc(AuthenticateStateData);
-	r->handler = handler;
-	r->data = cbdataReference(data);
-	r->auth_user_request = auth_user_request;
-	/* mark the user as haveing verification in progress */
-	basic_auth->flags.credentials_ok = 2;
-	xstrncpy(user, rfc1738_escape(basic_auth->username), sizeof(user));
-	xstrncpy(pass, rfc1738_escape(basic_auth->passwd), sizeof(pass));
-	snprintf(buf, sizeof(buf), "%s %s\n", user, pass);
-	helperSubmit(basicauthenticators, buf, authenticateBasicHandleReply, r);
+        r = cbdataAlloc(AuthenticateStateData);
+        r->handler = handler;
+        r->data = cbdataReference(data);
+        r->auth_user_request = auth_user_request;
+        /* mark the user as haveing verification in progress */
+        basic_auth->flags.credentials_ok = 2;
+        xstrncpy(user, rfc1738_escape(basic_auth->username), sizeof(user));
+        xstrncpy(pass, rfc1738_escape(basic_auth->passwd), sizeof(pass));
+        snprintf(buf, sizeof(buf), "%s %s\n", user, pass);
+        helperSubmit(basicauthenticators, buf, authenticateBasicHandleReply, r);
     }
 }
@@ -9,35 +9,52 @@
 #define DefaultAuthenticateChildrenMax  32	/* 32 processes */
 
 /* Generic */
-class AuthenticateStateData {
+
+class AuthenticateStateData
+{
+
 public:
     void *data;
     auth_user_request_t *auth_user_request;
     RH *handler;
 };
 
 /* queue of auth requests waiting for verification to occur */
-class BasicAuthQueueNode {
+
+class BasicAuthQueueNode
+{
+
 public:
     BasicAuthQueueNode *next;
     AuthUserRequest *auth_user_request;
     RH *handler;
     void *data;
 };
 
-class basic_data {
+class basic_data
+{
+
 public:
     char *username;
     char *passwd;
     time_t credentials_checkedtime;
-    struct {
-	unsigned int credentials_ok:2;	/*0=unchecked,1=ok,2=failed */
-    } flags;
+
+    struct
+    {
+
+unsigned int credentials_ok:
+        2;	/*0=unchecked,1=ok,2=failed */
+    }
+
+    flags;
     BasicAuthQueueNode *auth_queue;
 };
 
 /* configuration runtime data */
-class auth_basic_config {
+
+class auth_basic_config
+{
+
 public:
     int authenticateChildren;
     char *basicAuthRealm;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_digest.cc,v 1.20 2003/02/06 09:57:40 robertc Exp $
+ * $Id: auth_digest.cc,v 1.21 2003/02/21 22:50:27 robertc Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Robert Collins
@@ -120,9 +120,11 @@ static void
 authDigestNonceEncode(digest_nonce_h * nonce)
 {
     if (!nonce)
-	return;
+        return;
+
     if (nonce->key)
-	xfree(nonce->key);
+        xfree(nonce->key);
+
     nonce->key = xstrdup(base64_encode_bin((char *) &(nonce->noncedata), sizeof(digest_nonce_data)));
 }
 
@@ -132,44 +134,44 @@ authenticateDigestNonceNew(void)
     digest_nonce_h *newnonce = static_cast < digest_nonce_h * >(memPoolAlloc(digest_nonce_pool));
     digest_nonce_h *temp;
 
-/* NONCE CREATION - NOTES AND REASONING. RBC 20010108
- * === EXCERPT FROM RFC 2617 ===
- * The contents of the nonce are implementation dependent. The quality
- * of the implementation depends on a good choice. A nonce might, for
- * example, be constructed as the base 64 encoding of
- * 
- * time-stamp H(time-stamp ":" ETag ":" private-key)
- * 
- * where time-stamp is a server-generated time or other non-repeating
- * value, ETag is the value of the HTTP ETag header associated with
- * the requested entity, and private-key is data known only to the
- * server.  With a nonce of this form a server would recalculate the
- * hash portion after receiving the client authentication header and
- * reject the request if it did not match the nonce from that header
- * or if the time-stamp value is not recent enough. In this way the
- * server can limit the time of the nonce's validity. The inclusion of
- * the ETag prevents a replay request for an updated version of the
- * resource.  (Note: including the IP address of the client in the
- * nonce would appear to offer the server the ability to limit the
- * reuse of the nonce to the same client that originally got it.
- * However, that would break proxy farms, where requests from a single
- * user often go through different proxies in the farm. Also, IP
- * address spoofing is not that hard.)
- * ====
- * 
- * Now for my reasoning:
- * We will not accept a unrecognised nonce->we have all recognisable
- * nonces stored If we send out unique base64 encodings we guarantee
- * that a given nonce applies to only one user (barring attacks or
- * really bad timing with expiry and creation).  Using a random
- * component in the nonce allows us to loop to find a unique nonce.
- * We use H(nonce_data) so the nonce is meaningless to the reciever.
- * So our nonce looks like base64(H(timestamp,pointertohash,randomdata))
- * And even if our randomness is not very random (probably due to
- * bad coding on my part) we don't really care - the timestamp and
- * memory pointer should provide enough protection for the users
- * authentication.
- */
+    /* NONCE CREATION - NOTES AND REASONING. RBC 20010108
+     * === EXCERPT FROM RFC 2617 ===
+     * The contents of the nonce are implementation dependent. The quality
+     * of the implementation depends on a good choice. A nonce might, for
+     * example, be constructed as the base 64 encoding of
+     * 
+     * time-stamp H(time-stamp ":" ETag ":" private-key)
+     * 
+     * where time-stamp is a server-generated time or other non-repeating
+     * value, ETag is the value of the HTTP ETag header associated with
+     * the requested entity, and private-key is data known only to the
+     * server.  With a nonce of this form a server would recalculate the
+     * hash portion after receiving the client authentication header and
+     * reject the request if it did not match the nonce from that header
+     * or if the time-stamp value is not recent enough. In this way the
+     * server can limit the time of the nonce's validity. The inclusion of
+     * the ETag prevents a replay request for an updated version of the
+     * resource.  (Note: including the IP address of the client in the
+     * nonce would appear to offer the server the ability to limit the
+     * reuse of the nonce to the same client that originally got it.
+     * However, that would break proxy farms, where requests from a single
+     * user often go through different proxies in the farm. Also, IP
+     * address spoofing is not that hard.)
+     * ====
+     * 
+     * Now for my reasoning:
+     * We will not accept a unrecognised nonce->we have all recognisable
+     * nonces stored If we send out unique base64 encodings we guarantee
+     * that a given nonce applies to only one user (barring attacks or
+     * really bad timing with expiry and creation).  Using a random
+     * component in the nonce allows us to loop to find a unique nonce.
+     * We use H(nonce_data) so the nonce is meaningless to the reciever.
+     * So our nonce looks like base64(H(timestamp,pointertohash,randomdata))
+     * And even if our randomness is not very random (probably due to
+     * bad coding on my part) we don't really care - the timestamp and
+     * memory pointer should provide enough protection for the users
+     * authentication.
+     */
 
     /* create a new nonce */
     newnonce->nc = 0;
@@ -183,11 +185,13 @@ authenticateDigestNonceNew(void)
      * loop until we get a unique nonce. The nonce creation must
      * have a random factor
      */
+
     while ((temp = authenticateDigestNonceFindNonce((char const *) (newnonce->key)))) {
-	/* create a new nonce */
-	newnonce->noncedata.randomdata = squid_random();
-	authDigestNonceEncode(newnonce);
+        /* create a new nonce */
+        newnonce->noncedata.randomdata = squid_random();
+        authDigestNonceEncode(newnonce);
     }
+
     hash_join(digest_nonce_cache, newnonce);
     /* the cache's link */
     authDigestNonceLink(newnonce);
@@ -200,56 +204,65 @@ static void
 authenticateDigestNonceDelete(digest_nonce_h * nonce)
 {
     if (nonce) {
-	assert(nonce->references == 0);
+        assert(nonce->references == 0);
 #if UNREACHABLECODE
-	if (nonce->flags.incache)
-	    hash_remove_link(digest_nonce_cache, nonce);
+
+        if (nonce->flags.incache)
+            hash_remove_link(digest_nonce_cache, nonce);
+
 #endif
-	assert(nonce->flags.incache == 0);
-	safe_free(nonce->key);
-	memPoolFree(digest_nonce_pool, nonce);
+
+        assert(nonce->flags.incache == 0);
+
+        safe_free(nonce->key);
+
+        memPoolFree(digest_nonce_pool, nonce);
     }
 }
 
 static void
 authenticateDigestNonceSetup(void)
 {
     if (!digest_nonce_pool)
-	digest_nonce_pool = memPoolCreate("Digest Scheme nonce's", sizeof(digest_nonce_h));
+        digest_nonce_pool = memPoolCreate("Digest Scheme nonce's", sizeof(digest_nonce_h));
+
     if (!digest_nonce_cache) {
-	digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
-	assert(digest_nonce_cache);
-	eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig->nonceGCInterval, 1);
+        digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
+        assert(digest_nonce_cache);
+        eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig->nonceGCInterval, 1);
     }
 }
 
 static void
 authenticateDigestNonceShutdown(void)
 {
-    /* 
+    /*
      * We empty the cache of any nonces left in there.
      */
     digest_nonce_h *nonce;
+
     if (digest_nonce_cache) {
-	debug(29, 2) ("authenticateDigestNonceShutdown: Shutting down nonce cache \n");
-	hash_first(digest_nonce_cache);
-	while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
-	    assert(nonce->flags.incache);
-	    authDigestNoncePurge(nonce);
-	}
+        debug(29, 2) ("authenticateDigestNonceShutdown: Shutting down nonce cache \n");
+        hash_first(digest_nonce_cache);
+
+        while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
+            assert(nonce->flags.incache);
+            authDigestNoncePurge(nonce);
+        }
     }
+
 #if DEBUGSHUTDOWN
     if (digest_nonce_pool) {
-	memPoolDestroy(&digest_nonce_pool);
+        memPoolDestroy(&digest_nonce_pool);
     }
+
 #endif
     debug(29, 2) ("authenticateDigestNonceShutdown: Nonce cache shutdown\n");
 }
 
 static void
 authenticateDigestNonceReconfigure(void)
-{
-}
+{}
 
 static void
 authenticateDigestNonceCacheCleanup(void *data)
@@ -263,24 +276,28 @@ authenticateDigestNonceCacheCleanup(void *data)
     digest_nonce_h *nonce;
     debug(29, 3) ("authenticateDigestNonceCacheCleanup: Cleaning the nonce cache now\n");
     debug(29, 3) ("authenticateDigestNonceCacheCleanup: Current time: %ld\n",
-	(long int) current_time.tv_sec);
+                  (long int) current_time.tv_sec);
     hash_first(digest_nonce_cache);
+
     while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
-	debug(29, 3) ("authenticateDigestNonceCacheCleanup: nonce entry  : %p '%s'\n", nonce, (char *) nonce->key);
-	debug(29, 4) ("authenticateDigestNonceCacheCleanup: Creation time: %ld\n", (long int) nonce->noncedata.creationtime);
-	if (authDigestNonceIsStale(nonce)) {
-	    debug(29, 4) ("authenticateDigestNonceCacheCleanup: Removing nonce %s from cache due to timeout.\n", (char *) nonce->key);
-	    assert(nonce->flags.incache);
-	    /* invalidate nonce so future requests fail */
-	    nonce->flags.valid = 0;
-	    /* if it is tied to a auth_user, remove the tie */
-	    authDigestNonceUserUnlink(nonce);
-	    authDigestNoncePurge(nonce);
-	}
+        debug(29, 3) ("authenticateDigestNonceCacheCleanup: nonce entry  : %p '%s'\n", nonce, (char *) nonce->key);
+        debug(29, 4) ("authenticateDigestNonceCacheCleanup: Creation time: %ld\n", (long int) nonce->noncedata.creationtime);
+
+        if (authDigestNonceIsStale(nonce)) {
+            debug(29, 4) ("authenticateDigestNonceCacheCleanup: Removing nonce %s from cache due to timeout.\n", (char *) nonce->key);
+            assert(nonce->flags.incache);
+            /* invalidate nonce so future requests fail */
+            nonce->flags.valid = 0;
+            /* if it is tied to a auth_user, remove the tie */
+            authDigestNonceUserUnlink(nonce);
+            authDigestNoncePurge(nonce);
+        }
     }
+
     debug(29, 3) ("authenticateDigestNonceCacheCleanup: Finished cleaning the nonce cache.\n");
+
     if (authenticateDigestActive())
-	eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig->nonceGCInterval, 1);
+        eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, digestConfig->nonceGCInterval, 1);
 }
 
 static void
@@ -296,44 +313,56 @@ static int
 authDigestNonceLinks(digest_nonce_h * nonce)
 {
     if (!nonce)
-	return -1;
+        return -1;
+
     return nonce->references;
 }
+
 #endif
 
 static void
 authDigestNonceUnlink(digest_nonce_h * nonce)
 {
     assert(nonce != NULL);
+
     if (nonce->references > 0) {
-	nonce->references--;
+        nonce->references--;
     } else {
-	debug(29, 1) ("authDigestNonceUnlink; Attempt to lower nonce %p refcount below 0!\n", nonce);
+        debug(29, 1) ("authDigestNonceUnlink; Attempt to lower nonce %p refcount below 0!\n", nonce);
     }
+
     debug(29, 9) ("authDigestNonceUnlink: nonce '%p' now at '%d'.\n", nonce, nonce->references);
+
     if (nonce->references == 0)
-	authenticateDigestNonceDelete(nonce);
+        authenticateDigestNonceDelete(nonce);
 }
 
 static const char *
 authenticateDigestNonceNonceb64(digest_nonce_h * nonce)
 {
     if (!nonce)
-	return NULL;
+        return NULL;
+
     return (char const *) nonce->key;
 }
 
 static digest_nonce_h *
 authenticateDigestNonceFindNonce(const char *nonceb64)
 {
     digest_nonce_h *nonce = NULL;
+
     if (nonceb64 == NULL)
-	return NULL;
+        return NULL;
+
     debug(29, 9) ("authDigestNonceFindNonce:looking for nonceb64 '%s' in the nonce cache.\n", nonceb64);
+
     nonce = static_cast < digest_nonce_h * >(hash_lookup(digest_nonce_cache, nonceb64));
+
     if ((nonce == NULL) || (strcmp(authenticateDigestNonceNonceb64(nonce), nonceb64)))
-	return NULL;
+        return NULL;
+
     debug(29, 9) ("authDigestNonceFindNonce: Found nonce '%p'\n", nonce);
+
     return nonce;
 }
 
@@ -342,68 +371,82 @@ authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
 {
     unsigned long intnc;
     /* do we have a nonce ? */
+
     if (!nonce)
-	return 0;
+        return 0;
+
     intnc = strtol(nc, NULL, 16);
+
     if ((digestConfig->NonceStrictness && intnc != nonce->nc + 1) ||
-	intnc < nonce->nc + 1) {
-	debug(29, 4) ("authDigestNonceIsValid: Nonce count doesn't match\n");
-	nonce->flags.valid = 0;
-	return 0;
+            intnc < nonce->nc + 1) {
+        debug(29, 4) ("authDigestNonceIsValid: Nonce count doesn't match\n");
+        nonce->flags.valid = 0;
+        return 0;
     }
+
     /* has it already been invalidated ? */
     if (!nonce->flags.valid) {
-	debug(29, 4) ("authDigestNonceIsValid: Nonce already invalidated\n");
-	return 0;
+        debug(29, 4) ("authDigestNonceIsValid: Nonce already invalidated\n");
+        return 0;
     }
+
     /* seems ok */
     /* increment the nonce count - we've already checked that intnc is a
      *  valid representation for us, so we don't need the test here.
      */
     nonce->nc = intnc;
+
     return -1;
 }
 
 static int
 authDigestNonceIsStale(digest_nonce_h * nonce)
 {
     /* do we have a nonce ? */
+
     if (!nonce)
-	return -1;
+        return -1;
+
     /* has it's max duration expired? */
     if (nonce->noncedata.creationtime + digestConfig->noncemaxduration < current_time.tv_sec) {
-	debug(29, 4) ("authDigestNonceIsStale: Nonce is too old. %ld %d %ld\n", (long int) nonce->noncedata.creationtime, (int) digestConfig->noncemaxduration, (long int) current_time.tv_sec);
-	nonce->flags.valid = 0;
-	return -1;
+        debug(29, 4) ("authDigestNonceIsStale: Nonce is too old. %ld %d %ld\n", (long int) nonce->noncedata.creationtime, (int) digestConfig->noncemaxduration, (long int) current_time.tv_sec);
+        nonce->flags.valid = 0;
+        return -1;
     }
+
     if (nonce->nc > 99999998) {
-	debug(29, 4) ("authDigestNonceIsStale: Nonce count overflow\n");
-	nonce->flags.valid = 0;
-	return -1;
+        debug(29, 4) ("authDigestNonceIsStale: Nonce count overflow\n");
+        nonce->flags.valid = 0;
+        return -1;
     }
+
     if (nonce->nc > digestConfig->noncemaxuses) {
-	debug(29, 4) ("authDigestNoncelastRequest: Nonce count over user limit\n");
-	nonce->flags.valid = 0;
-	return -1;
+        debug(29, 4) ("authDigestNoncelastRequest: Nonce count over user limit\n");
+        nonce->flags.valid = 0;
+        return -1;
     }
+
     /* seems ok */
     return 0;
 }
 
-  /* return -1 if the digest will be stale on the next request */
+/* return -1 if the digest will be stale on the next request */
 static int
 authDigestNonceLastRequest(digest_nonce_h * nonce)
 {
     if (!nonce)
-	return -1;
+        return -1;
+
     if (nonce->nc == 99999997) {
-	debug(29, 4) ("authDigestNoncelastRequest: Nonce count about to overflow\n");
-	return -1;
+        debug(29, 4) ("authDigestNoncelastRequest: Nonce count about to overflow\n");
+        return -1;
     }
+
     if (nonce->nc >= digestConfig->noncemaxuses - 1) {
-	debug(29, 4) ("authDigestNoncelastRequest: Nonce count about to hit user limit\n");
-	return -1;
+        debug(29, 4) ("authDigestNoncelastRequest: Nonce count about to hit user limit\n");
+        return -1;
     }
+
     /* and other tests are possible. */
     return 0;
 }
@@ -412,16 +455,20 @@ static void
 authDigestNoncePurge(digest_nonce_h * nonce)
 {
     if (!nonce)
-	return;
+        return;
+
     if (!nonce->flags.incache)
-	return;
+        return;
+
     hash_remove_link(digest_nonce_cache, nonce);
+
     nonce->flags.incache = 0;
+
     /* the cache's link */
     authDigestNonceUnlink(nonce);
 }
 
-  /* USER related functions */
+/* USER related functions */
 
 
 #if NOT_USED
@@ -430,6 +477,7 @@ authDigestUsercmpname(digest_user_h * u1, digest_user_h * u2)
 {
     return strcmp(u1->username, u2->username);
 }
+
 #endif
 
 static auth_user_t *
@@ -438,16 +486,21 @@ authDigestUserFindUsername(const char *username)
     auth_user_hash_pointer *usernamehash;
     auth_user_t *auth_user;
     debug(29, 9) ("authDigestUserFindUsername: Looking for user '%s'\n", username);
+
     if (username && (usernamehash = static_cast < auth_user_hash_pointer * >(hash_lookup(proxy_auth_username_cache, username)))) {
-	while ((authUserHashPointerUser(usernamehash)->auth_type != AUTH_DIGEST) &&
-	    (usernamehash->next))
-	    usernamehash = static_cast < auth_user_hash_pointer * >(usernamehash->next);
-	auth_user = NULL;
-	if (authUserHashPointerUser(usernamehash)->auth_type == AUTH_DIGEST) {
-	    auth_user = authUserHashPointerUser(usernamehash);
-	}
-	return auth_user;
+        while ((authUserHashPointerUser(usernamehash)->auth_type != AUTH_DIGEST) &&
+                (usernamehash->next))
+            usernamehash = static_cast < auth_user_hash_pointer * >(usernamehash->next);
+
+        auth_user = NULL;
+
+        if (authUserHashPointerUser(usernamehash)->auth_type == AUTH_DIGEST) {
+            auth_user = authUserHashPointerUser(usernamehash);
+        }
+
+        return auth_user;
     }
+
     return NULL;
 }
 
@@ -461,7 +514,7 @@ static void
 authDigestUserSetup(void)
 {
     if (!digest_user_pool)
-	digest_user_pool = memPoolCreate("Digest Scheme User Data", sizeof(digest_user_h));
+        digest_user_pool = memPoolCreate("Digest Scheme User Data", sizeof(digest_user_h));
 }
 
 static void
@@ -473,17 +526,21 @@ authDigestUserShutdown(void)
     auth_user_hash_pointer *usernamehash;
     auth_user_t *auth_user;
     hash_first(proxy_auth_username_cache);
+
     while ((usernamehash = ((auth_user_hash_pointer *) hash_next(proxy_auth_username_cache)))) {
-	auth_user = authUserHashPointerUser(usernamehash);
-	if (authscheme_list[auth_user->auth_module - 1].typestr &&
-	    strcmp(authscheme_list[auth_user->auth_module - 1].typestr, "digest") == 0)
-	    /* it's digest */
-	    authenticateAuthUserUnlock(auth_user);
+        auth_user = authUserHashPointerUser(usernamehash);
+
+        if (authscheme_list[auth_user->auth_module - 1].typestr &&
+                strcmp(authscheme_list[auth_user->auth_module - 1].typestr, "digest") == 0)
+            /* it's digest */
+            authenticateAuthUserUnlock(auth_user);
     }
+
 #if DEBUGSHUTDOWN
     if (digest_user_pool) {
-	memPoolDestroy(&digest_user_pool);
+        memPoolDestroy(&digest_user_pool);
     }
+
 #endif
 }
 
@@ -495,33 +552,43 @@ static void
 authDigestRequestDelete(digest_request_h * digest_request)
 {
     if (digest_request->nonceb64)
-	xfree(digest_request->nonceb64);
+        xfree(digest_request->nonceb64);
+
     if (digest_request->cnonce)
-	xfree(digest_request->cnonce);
+        xfree(digest_request->cnonce);
+
     if (digest_request->realm)
-	xfree(digest_request->realm);
+        xfree(digest_request->realm);
+
     if (digest_request->pszPass)
-	xfree(digest_request->pszPass);
+        xfree(digest_request->pszPass);
+
     if (digest_request->algorithm)
-	xfree(digest_request->algorithm);
+        xfree(digest_request->algorithm);
+
     if (digest_request->pszMethod)
-	xfree(digest_request->pszMethod);
+        xfree(digest_request->pszMethod);
+
     if (digest_request->qop)
-	xfree(digest_request->qop);
+        xfree(digest_request->qop);
+
     if (digest_request->uri)
-	xfree(digest_request->uri);
+        xfree(digest_request->uri);
+
     if (digest_request->response)
-	xfree(digest_request->response);
+        xfree(digest_request->response);
+
     if (digest_request->nonce)
-	authDigestNonceUnlink(digest_request->nonce);
+        authDigestNonceUnlink(digest_request->nonce);
+
     memPoolFree(digest_request_pool, digest_request);
 }
 
 static void
 authDigestAURequestFree(auth_user_request_t * auth_user_request)
 {
     if (auth_user_request->scheme_data != NULL)
-	authDigestRequestDelete(static_cast < digest_request_h * >(auth_user_request->scheme_data));
+        authDigestRequestDelete(static_cast < digest_request_h * >(auth_user_request->scheme_data));
 }
 
 static digest_request_h *
@@ -537,17 +604,19 @@ static void
 authDigestRequestSetup(void)
 {
     if (!digest_request_pool)
-	digest_request_pool = memPoolCreate("Digest Scheme Request Data", sizeof(digest_request_h));
+        digest_request_pool = memPoolCreate("Digest Scheme Request Data", sizeof(digest_request_h));
 }
 
 static void
 authDigestRequestShutdown(void)
 {
     /* No requests should be in progress when we get here */
 #if DEBUGSHUTDOWN
+
     if (digest_request_pool) {
-	memPoolDestroy(&digest_request_pool);
+        memPoolDestroy(&digest_request_pool);
     }
+
 #endif
 }
 
@@ -556,16 +625,20 @@ static void
 authDigestDone(void)
 {
     if (digestauthenticators)
-	helperShutdown(digestauthenticators);
+        helperShutdown(digestauthenticators);
+
     authdigest_initialised = 0;
+
     if (!shutting_down) {
-	authenticateDigestNonceReconfigure();
-	return;
+        authenticateDigestNonceReconfigure();
+        return;
     }
+
     if (digestauthenticators) {
-	helperFree(digestauthenticators);
-	digestauthenticators = NULL;
+        helperFree(digestauthenticators);
+        digestauthenticators = NULL;
     }
+
     authDigestRequestShutdown();
     authDigestUserShutdown();
     authenticateDigestNonceShutdown();
@@ -579,16 +652,18 @@ authDigestCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
     wordlist *list = config->authenticate;
     debug(29, 9) ("authDigestCfgDump: Dumping configuration\n");
     storeAppendPrintf(entry, "%s %s", name, "digest");
+
     while (list != NULL) {
-	storeAppendPrintf(entry, " %s", list->key);
-	list = list->next;
+        storeAppendPrintf(entry, " %s", list->key);
+        list = list->next;
     }
+
     storeAppendPrintf(entry, "\n%s %s realm %s\n%s %s children %d\n%s %s nonce_max_count %d\n%s %s nonce_max_duration %d seconds\n%s %s nonce_garbage_interval %d seconds\n",
-	name, "digest", config->digestAuthRealm,
-	name, "digest", config->authenticateChildren,
-	name, "digest", config->noncemaxuses,
-	name, "digest", (int) config->noncemaxduration,
-	name, "digest", (int) config->nonceGCInterval);
+                      name, "digest", config->digestAuthRealm,
+                      name, "digest", config->authenticateChildren,
+                      name, "digest", config->noncemaxuses,
+                      name, "digest", (int) config->noncemaxduration,
+                      name, "digest", (int) config->nonceGCInterval);
 }
 
 void
@@ -607,8 +682,10 @@ authSchemeSetup_digest(authscheme_entry_t * authscheme)
     authscheme->FreeUser = authenticateDigestUserFree;
     authscheme->AddHeader = authDigestAddHeader;
 #if WAITING_FOR_TE
+
     authscheme->AddTrailer = authDigestAddTrailer;
 #endif
+
     authscheme->authStart = authenticateDigestStart;
     authscheme->authStats = authenticateDigestStats;
     authscheme->authUserUsername = authenticateDigestUsername;
@@ -625,24 +702,27 @@ authenticateDigestActive(void)
 {
     return (authdigest_initialised == 1) ? 1 : 0;
 }
+
 static int
 authDigestConfigured(void)
 {
     if ((digestConfig != NULL) && (digestConfig->authenticate != NULL) &&
-	(digestConfig->authenticateChildren != 0) &&
-	(digestConfig->digestAuthRealm != NULL) && (digestConfig->noncemaxduration > -1))
-	return 1;
+            (digestConfig->authenticateChildren != 0) &&
+            (digestConfig->digestAuthRealm != NULL) && (digestConfig->noncemaxduration > -1))
+        return 1;
+
     return 0;
 }
 
 static int
 authDigestAuthenticated(auth_user_request_t * auth_user_request)
 {
     digest_user_h *digest_user = static_cast < digest_user_h * >(auth_user_request->auth_user->scheme_data);
+
     if (digest_user->flags.credentials_ok == 1)
-	return 1;
+        return 1;
     else
-	return 0;
+        return 0;
 }
 
 /* log a digest user in
@@ -665,49 +745,55 @@ authenticateDigestAuthenticateUser(auth_user_request_t * auth_user_request, requ
     digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
 
     /* if the check has corrupted the user, just return */
+
     if (digest_user->flags.credentials_ok == 3) {
-	return;
+        return;
     }
+
     assert(auth_user_request->scheme_data != NULL);
     digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
 
     /* do we have the HA1 */
+
     if (!digest_user->HA1created) {
-	digest_user->flags.credentials_ok = 2;
-	return;
+        digest_user->flags.credentials_ok = 2;
+        return;
     }
+
     if (digest_request->nonce == NULL) {
-	/* this isn't a nonce we issued */
-	/* TODO: record breaks in authentication at the request level 
-	 * This is probably best done with support changes at the
-	 * auth_rewrite level -RBC
-	 * and can wait for auth_rewrite V2.
-	 * RBC 20010902 further note: flags.credentials ok is now
-	 * a local scheme flag, so we can move this to the request
-	 * level at any time.
-	 */
-	digest_user->flags.credentials_ok = 3;
-	return;
+        /* this isn't a nonce we issued */
+        /* TODO: record breaks in authentication at the request level
+         * This is probably best done with support changes at the
+         * auth_rewrite level -RBC
+         * and can wait for auth_rewrite V2.
+         * RBC 20010902 further note: flags.credentials ok is now
+         * a local scheme flag, so we can move this to the request
+         * level at any time.
+         */
+        digest_user->flags.credentials_ok = 3;
+        return;
     }
+
     DigestCalcHA1(digest_request->algorithm, NULL, NULL, NULL,
-	authenticateDigestNonceNonceb64(digest_request->nonce),
-	digest_request->cnonce,
-	digest_user->HA1, SESSIONKEY);
+                  authenticateDigestNonceNonceb64(digest_request->nonce),
+                  digest_request->cnonce,
+                  digest_user->HA1, SESSIONKEY);
     DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
-	digest_request->nc, digest_request->cnonce, digest_request->qop,
-	RequestMethodStr[request->method], digest_request->uri, HA2, Response);
+                       digest_request->nc, digest_request->cnonce, digest_request->qop,
+                       RequestMethodStr[request->method], digest_request->uri, HA2, Response);
 
     debug(29, 9) ("\nResponse = '%s'\n"
-	"squid is = '%s'\n", digest_request->response, Response);
+                  "squid is = '%s'\n", digest_request->response, Response);
 
     if (strcasecmp(digest_request->response, Response)) {
-	digest_user->flags.credentials_ok = 3;
-	return;
+        digest_user->flags.credentials_ok = 3;
+        return;
     }
+
     digest_user->flags.credentials_ok = 1;
     /* password was checked and did match */
     debug(29, 4) ("authenticateDigestAuthenticateuser: user '%s' validated OK\n",
-	digest_user->username);
+                  digest_user->username);
 
     /* auth_user is now linked, we reset these values
      * after external auth occurs anyway */
@@ -721,20 +807,28 @@ authenticateDigestDirection(auth_user_request_t * auth_user_request)
     digest_request_h *digest_request;
     digest_user_h *digest_user = static_cast < digest_user_h * >(auth_user_request->auth_user->scheme_data);
     /* null auth_user is checked for by authenticateDirection */
+
     switch (digest_user->flags.credentials_ok) {
+
     case 0:			/* not checked */
-	return -1;
+        return -1;
+
     case 1:			/* checked & ok */
-	digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
-	if (authDigestNonceIsStale(digest_request->nonce))
-	    /* send stale response to the client agent */
-	    return -2;
-	return 0;
+        digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
+
+        if (authDigestNonceIsStale(digest_request->nonce))
+            /* send stale response to the client agent */
+            return -2;
+
+        return 0;
+
     case 2:			/* partway through checking. */
-	return -1;
+        return -1;
+
     case 3:			/* authentication process failed. */
-	return -2;
+        return -2;
     }
+
     return -2;
 }
 
@@ -744,25 +838,30 @@ authDigestAddHeader(auth_user_request_t * auth_user_request, HttpReply * rep, in
 {
     enum http_hdr_type type;
     digest_request_h *digest_request;
+
     if (!auth_user_request)
-	return;
+        return;
+
     digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
+
     /* don't add to authentication error pages */
     if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-	|| (accel && rep->sline.status == HTTP_UNAUTHORIZED))
-	return;
+            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+        return;
+
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
 
 #if WAITING_FOR_TE
     /* test for http/1.1 transfer chunked encoding */
     if (chunkedtest)
-	return;
+        return;
+
 #endif
 
     if ((digestConfig->authenticate) && authDigestNonceLastRequest(digest_request->nonce)) {
-	digest_request->flags.authinfo_sent = 1;
-	debug(29, 9) ("authDigestAddHead: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(digest_request->nonce));
-	httpHeaderPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(digest_request->nonce));
+        digest_request->flags.authinfo_sent = 1;
+        debug(29, 9) ("authDigestAddHead: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(digest_request->nonce));
+        httpHeaderPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(digest_request->nonce));
     }
 }
 
@@ -773,23 +872,29 @@ authDigestAddTrailer(auth_user_request_t * auth_user_request, HttpReply * rep, i
 {
     int type;
     digest_request_h *digest_request;
+
     if (!auth_user_request)
-	return;
+        return;
+
     digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
+
     /* has the header already been send? */
     if (digest_request->flags.authinfo_sent)
-	return;
+        return;
+
     /* don't add to authentication error pages */
     if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-	|| (accel && rep->sline.status == HTTP_UNAUTHORIZED))
-	return;
+            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+        return;
+
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
 
     if ((digestConfig->authenticate) && authDigestNonceLastRequest(digest_request->nonce)) {
-	debug(29, 9) ("authDigestAddTrailer: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(digest_request->nonce));
-	httpTrailerPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(digest_request->nonce));
+        debug(29, 9) ("authDigestAddTrailer: Sending type:%d header: 'nextnonce=\"%s\"", type, authenticateDigestNonceNonceb64(digest_request->nonce));
+        httpTrailerPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(digest_request->nonce));
     }
 }
+
 #endif
 
 /* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */
@@ -799,14 +904,16 @@ authenticateDigestFixHeader(auth_user_request_t * auth_user_request, HttpReply *
     digest_request_h *digest_request;
     int stale = 0;
     digest_nonce_h *nonce = authenticateDigestNonceNew();
+
     if (auth_user_request && authDigestAuthenticated(auth_user_request) && auth_user_request->scheme_data) {
-	digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
-	stale = authDigestNonceIsStale(digest_request->nonce);
+        digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
+        stale = authDigestNonceIsStale(digest_request->nonce);
     }
+
     if (digestConfig->authenticate) {
-	debug(29, 9) ("authenticateFixHeader: Sending type:%d header: 'Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s\n", type, digestConfig->digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
-	/* in the future, for WWW auth we may want to support the domain entry */
-	httpHeaderPutStrf(&rep->header, type, "Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s", digestConfig->digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
+        debug(29, 9) ("authenticateFixHeader: Sending type:%d header: 'Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s\n", type, digestConfig->digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
+        /* in the future, for WWW auth we may want to support the domain entry */
+        httpHeaderPutStrf(&rep->header, type, "Digest realm=\"%s\", nonce=\"%s\", qop=\"%s\", stale=%s", digestConfig->digestAuthRealm, authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? "true" : "false");
     }
 }
 
@@ -816,18 +923,21 @@ authenticateDigestUserFree(auth_user_t * auth_user)
     digest_user_h *digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
     dlink_node *link, *tmplink;
     debug(29, 9) ("authenticateDigestFreeUser: Clearing Digest scheme data\n");
+
     if (!digest_user)
-	return;
+        return;
+
     safe_free(digest_user->username);
 
     link = digest_user->nonces.head;
+
     while (link) {
-	tmplink = link;
-	link = link->next;
-	dlinkDelete(tmplink, &digest_user->nonces);
-	authDigestNoncePurge(static_cast < digest_nonce_h * >(tmplink->data));
-	authDigestNonceUnlink(static_cast < digest_nonce_h * >(tmplink->data));
-	dlinkNodeDelete(tmplink);
+        tmplink = link;
+        link = link->next;
+        dlinkDelete(tmplink, &digest_user->nonces);
+        authDigestNoncePurge(static_cast < digest_nonce_h * >(tmplink->data));
+        authDigestNonceUnlink(static_cast < digest_nonce_h * >(tmplink->data));
+        dlinkNodeDelete(tmplink);
     }
 
     memPoolFree(digest_user_pool, auth_user->scheme_data);
@@ -844,25 +954,31 @@ authenticateDigestHandleReply(void *data, char *reply)
     char *t = NULL;
     void *cbdata;
     debug(29, 9) ("authenticateDigestHandleReply: {%s}\n", reply ? reply : "<NULL>");
+
     if (reply) {
-	if ((t = strchr(reply, ' ')))
-	    *t = '\0';
-	if (*reply == '\0')
-	    reply = NULL;
+        if ((t = strchr(reply, ' ')))
+            *t = '\0';
+
+        if (*reply == '\0')
+            reply = NULL;
     }
+
     assert(r->auth_user_request != NULL);
     auth_user_request = r->auth_user_request;
     assert(auth_user_request->scheme_data != NULL);
     digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
     digest_user = static_cast < digest_user_h * >(auth_user_request->auth_user->scheme_data);
+
     if (reply && (strncasecmp(reply, "ERR", 3) == 0))
-	digest_user->flags.credentials_ok = 3;
+        digest_user->flags.credentials_ok = 3;
     else {
-	CvtBin(reply, digest_user->HA1);
-	digest_user->HA1created = 1;
+        CvtBin(reply, digest_user->HA1);
+        digest_user->HA1created = 1;
     }
+
     if (cbdataReferenceValidDone(r->data, &cbdata))
-	r->handler(cbdata, NULL);
+        r->handler(cbdata, NULL);
+
     authenticateStateFree(r);
 }
 
@@ -872,23 +988,31 @@ static void
 authDigestInit(authScheme * scheme)
 {
     static int init = 0;
+
     if (digestConfig->authenticate) {
-	authDigestUserSetup();
-	authDigestRequestSetup();
-	authenticateDigestNonceSetup();
-	authdigest_initialised = 1;
-	if (digestauthenticators == NULL)
-	    digestauthenticators = helperCreate("digestauthenticator");
-	digestauthenticators->cmdline = digestConfig->authenticate;
-	digestauthenticators->n_to_start = digestConfig->authenticateChildren;
-	digestauthenticators->ipc_type = IPC_STREAM;
-	helperOpenServers(digestauthenticators);
-	if (!init) {
-	    cachemgrRegister("digestauthenticator", "Digest User Authenticator Stats",
-		authenticateDigestStats, 0, 1);
-	    init++;
-	}
-	CBDATA_INIT_TYPE(DigestAuthenticateStateData);
+        authDigestUserSetup();
+        authDigestRequestSetup();
+        authenticateDigestNonceSetup();
+        authdigest_initialised = 1;
+
+        if (digestauthenticators == NULL)
+            digestauthenticators = helperCreate("digestauthenticator");
+
+        digestauthenticators->cmdline = digestConfig->authenticate;
+
+        digestauthenticators->n_to_start = digestConfig->authenticateChildren;
+
+        digestauthenticators->ipc_type = IPC_STREAM;
+
+        helperOpenServers(digestauthenticators);
+
+        if (!init) {
+            cachemgrRegister("digestauthenticator", "Digest User Authenticator Stats",
+                             authenticateDigestStats, 0, 1);
+            init++;
+        }
+
+        CBDATA_INIT_TYPE(DigestAuthenticateStateData);
     }
 }
 
@@ -898,54 +1022,63 @@ void
 authDigestFreeConfig(authScheme * scheme)
 {
     if (digestConfig == NULL)
-	return;
+        return;
+
     assert(digestConfig == scheme->scheme_data);
+
     if (digestConfig->authenticate)
-	wordlistDestroy(&digestConfig->authenticate);
+        wordlistDestroy(&digestConfig->authenticate);
+
     safe_free(digestConfig->digestAuthRealm);
+
     xfree(digestConfig);
+
     digestConfig = NULL;
 }
 
 static void
 authDigestParse(authScheme * scheme, int n_configured, char *param_str)
 {
     if (scheme->scheme_data == NULL) {
-	assert(digestConfig == NULL);
-	/* this is the first param to be found */
-	scheme->scheme_data = xmalloc(sizeof(auth_digest_config));
-	memset(scheme->scheme_data, 0, sizeof(auth_digest_config));
-	digestConfig = static_cast < auth_digest_config * >(scheme->scheme_data);
-	digestConfig->authenticateChildren = 5;
-	/* 5 minutes */
-	digestConfig->nonceGCInterval = 5 * 60;
-	/* 30 minutes */
-	digestConfig->noncemaxduration = 30 * 60;
-	/* 50 requests */
-	digestConfig->noncemaxuses = 50;
-	/* strict nonce count behaviour */
-	digestConfig->NonceStrictness = 1;
+        assert(digestConfig == NULL);
+        /* this is the first param to be found */
+        scheme->scheme_data = xmalloc(sizeof(auth_digest_config));
+        memset(scheme->scheme_data, 0, sizeof(auth_digest_config));
+        digestConfig = static_cast < auth_digest_config * >(scheme->scheme_data);
+        digestConfig->authenticateChildren = 5;
+        /* 5 minutes */
+        digestConfig->nonceGCInterval = 5 * 60;
+        /* 30 minutes */
+        digestConfig->noncemaxduration = 30 * 60;
+        /* 50 requests */
+        digestConfig->noncemaxuses = 50;
+        /* strict nonce count behaviour */
+        digestConfig->NonceStrictness = 1;
     }
+
     digestConfig = static_cast < auth_digest_config * >(scheme->scheme_data);
+
     if (strcasecmp(param_str, "program") == 0) {
-	if (digestConfig->authenticate)
-	    wordlistDestroy(&digestConfig->authenticate);
-	parse_wordlist(&digestConfig->authenticate);
-	requirePathnameExists("authparam digest program", digestConfig->authenticate->key);
+        if (digestConfig->authenticate)
+            wordlistDestroy(&digestConfig->authenticate);
+
+        parse_wordlist(&digestConfig->authenticate);
+
+        requirePathnameExists("authparam digest program", digestConfig->authenticate->key);
     } else if (strcasecmp(param_str, "children") == 0) {
-	parse_int(&digestConfig->authenticateChildren);
+        parse_int(&digestConfig->authenticateChildren);
     } else if (strcasecmp(param_str, "realm") == 0) {
-	parse_eol(&digestConfig->digestAuthRealm);
+        parse_eol(&digestConfig->digestAuthRealm);
     } else if (strcasecmp(param_str, "nonce_garbage_interval") == 0) {
-	parse_time_t(&digestConfig->nonceGCInterval);
+        parse_time_t(&digestConfig->nonceGCInterval);
     } else if (strcasecmp(param_str, "nonce_max_duration") == 0) {
-	parse_time_t(&digestConfig->noncemaxduration);
+        parse_time_t(&digestConfig->noncemaxduration);
     } else if (strcasecmp(param_str, "nonce_max_count") == 0) {
-	parse_int((int *) &digestConfig->noncemaxuses);
+        parse_int((int *) &digestConfig->noncemaxuses);
     } else if (strcasecmp(param_str, "nonce_strictness") == 0) {
-	parse_onoff(&digestConfig->NonceStrictness);
+        parse_onoff(&digestConfig->NonceStrictness);
     } else {
-	debug(28, 0) ("unrecognised digest auth scheme parameter '%s'\n", param_str);
+        debug(28, 0) ("unrecognised digest auth scheme parameter '%s'\n", param_str);
     }
 }
 
@@ -964,25 +1097,32 @@ authDigestNonceUserUnlink(digest_nonce_h * nonce)
 {
     digest_user_h *digest_user;
     dlink_node *link, *tmplink;
+
     if (!nonce)
-	return;
+        return;
+
     if (!nonce->auth_user)
-	return;
+        return;
+
     digest_user = static_cast < digest_user_h * >(nonce->auth_user->scheme_data);
-    /* unlink from the user list. Yes we're crossing structures but this is the only 
+
+    /* unlink from the user list. Yes we're crossing structures but this is the only
      * time this code is needed
      */
     link = digest_user->nonces.head;
+
     while (link) {
-	tmplink = link;
-	link = link->next;
-	if (tmplink->data == nonce) {
-	    dlinkDelete(tmplink, &digest_user->nonces);
-	    authDigestNonceUnlink(static_cast < digest_nonce_h * >(tmplink->data));
-	    dlinkNodeDelete(tmplink);
-	    link = NULL;
-	}
+        tmplink = link;
+        link = link->next;
+
+        if (tmplink->data == nonce) {
+            dlinkDelete(tmplink, &digest_user->nonces);
+            authDigestNonceUnlink(static_cast < digest_nonce_h * >(tmplink->data));
+            dlinkNodeDelete(tmplink);
+            link = NULL;
+        }
     }
+
     /* this reference to auth_user was not locked because freeeing the auth_user frees
      * the nonce too. 
      */
@@ -996,22 +1136,33 @@ authDigestUserLinkNonce(auth_user_t * auth_user, digest_nonce_h * nonce)
 {
     dlink_node *node;
     digest_user_h *digest_user;
+
     if (!auth_user || !nonce)
-	return;
+        return;
+
     if (!auth_user->scheme_data)
-	return;
+        return;
+
     digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
+
     node = digest_user->nonces.head;
+
     while (node && (node->data != nonce))
-	node = node->next;
+        node = node->next;
+
     if (node)
-	return;
+        return;
+
     node = dlinkNodeNew();
+
     dlinkAddTail(nonce, node, &digest_user->nonces);
+
     authDigestNonceLink(nonce);
+
     /* ping this nonce to this auth user */
     assert((nonce->auth_user == NULL) || (nonce->auth_user = auth_user));
-    /* we don't lock this reference because removing the auth_user removes the 
+
+    /* we don't lock this reference because removing the auth_user removes the
      * hash too. Of course if that changes we're stuffed so read the code huh?
      */
     nonce->auth_user = auth_user;
@@ -1022,8 +1173,10 @@ static char const *
 authenticateDigestUsername(auth_user_t const *auth_user)
 {
     digest_user_h *digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
+
     if (digest_user)
-	return digest_user->username;
+        return digest_user->username;
+
     return NULL;
 }
 
@@ -1080,91 +1233,130 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
     digest_request = authDigestRequestNew();
 
     /* trim DIGEST from string */
+
     while (!xisspace(*proxy_auth))
-	proxy_auth++;
+        proxy_auth++;
 
     /* Trim leading whitespace before decoding */
     while (xisspace(*proxy_auth))
-	proxy_auth++;
+        proxy_auth++;
 
     String temp(proxy_auth);
+
     while (strListGetItem(&temp, ',', &item, &ilen, &pos)) {
-	if ((p = strchr(item, '=')) && (p - item < ilen))
-	    ilen = p++ - item;
-	if (!strncmp(item, "username", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    /* quote mark */
-	    p++;
-	    username = xstrndup(p, strchr(p, '"') + 1 - p);
-	    debug(29, 9) ("authDigestDecodeAuth: Found Username '%s'\n", username);
-	} else if (!strncmp(item, "realm", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    /* quote mark */
-	    p++;
-	    digest_request->realm = xstrndup(p, strchr(p, '"') + 1 - p);
-	    debug(29, 9) ("authDigestDecodeAuth: Found realm '%s'\n", digest_request->realm);
-	} else if (!strncmp(item, "qop", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    if (*p == '\"')
-		/* quote mark */
-		p++;
-	    digest_request->qop = xstrndup(p, strcspn(p, "\" \t\r\n()<>@,;:\\/[]?={}") + 1);
-	    debug(29, 9) ("authDigestDecodeAuth: Found qop '%s'\n", digest_request->qop);
-	} else if (!strncmp(item, "algorithm", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    if (*p == '\"')
-		/* quote mark */
-		p++;
-	    digest_request->algorithm = xstrndup(p, strcspn(p, "\" \t\r\n()<>@,;:\\/[]?={}") + 1);
-	    debug(29, 9) ("authDigestDecodeAuth: Found algorithm '%s'\n", digest_request->algorithm);
-	} else if (!strncmp(item, "uri", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    /* quote mark */
-	    p++;
-	    digest_request->uri = xstrndup(p, strchr(p, '"') + 1 - p);
-	    debug(29, 9) ("authDigestDecodeAuth: Found uri '%s'\n", digest_request->uri);
-	} else if (!strncmp(item, "nonce", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    /* quote mark */
-	    p++;
-	    digest_request->nonceb64 = xstrndup(p, strchr(p, '"') + 1 - p);
-	    debug(29, 9) ("authDigestDecodeAuth: Found nonce '%s'\n", digest_request->nonceb64);
-	} else if (!strncmp(item, "nc", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    xstrncpy(digest_request->nc, p, 9);
-	    debug(29, 9) ("authDigestDecodeAuth: Found noncecount '%s'\n", digest_request->nc);
-	} else if (!strncmp(item, "cnonce", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    /* quote mark */
-	    p++;
-	    digest_request->cnonce = xstrndup(p, strchr(p, '"') + 1 - p);
-	    debug(29, 9) ("authDigestDecodeAuth: Found cnonce '%s'\n", digest_request->cnonce);
-	} else if (!strncmp(item, "response", ilen)) {
-	    /* white space */
-	    while (xisspace(*p))
-		p++;
-	    /* quote mark */
-	    p++;
-	    digest_request->response = xstrndup(p, strchr(p, '"') + 1 - p);
-	    debug(29, 9) ("authDigestDecodeAuth: Found response '%s'\n", digest_request->response);
-	}
+        if ((p = strchr(item, '=')) && (p - item < ilen))
+            ilen = p++ - item;
+
+        if (!strncmp(item, "username", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            /* quote mark */
+            p++;
+
+            username = xstrndup(p, strchr(p, '"') + 1 - p);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found Username '%s'\n", username);
+        } else if (!strncmp(item, "realm", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            /* quote mark */
+            p++;
+
+            digest_request->realm = xstrndup(p, strchr(p, '"') + 1 - p);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found realm '%s'\n", digest_request->realm);
+        } else if (!strncmp(item, "qop", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            if (*p == '\"')
+                /* quote mark */
+                p++;
+
+            digest_request->qop = xstrndup(p, strcspn(p, "\" \t\r\n()<>@,;:\\/[]?={}") + 1);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found qop '%s'\n", digest_request->qop);
+        } else if (!strncmp(item, "algorithm", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            if (*p == '\"')
+                /* quote mark */
+                p++;
+
+            digest_request->algorithm = xstrndup(p, strcspn(p, "\" \t\r\n()<>@,;:\\/[]?={}") + 1);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found algorithm '%s'\n", digest_request->algorithm);
+        } else if (!strncmp(item, "uri", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            /* quote mark */
+            p++;
+
+            digest_request->uri = xstrndup(p, strchr(p, '"') + 1 - p);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found uri '%s'\n", digest_request->uri);
+        } else if (!strncmp(item, "nonce", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            /* quote mark */
+            p++;
+
+            digest_request->nonceb64 = xstrndup(p, strchr(p, '"') + 1 - p);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found nonce '%s'\n", digest_request->nonceb64);
+        } else if (!strncmp(item, "nc", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            xstrncpy(digest_request->nc, p, 9);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found noncecount '%s'\n", digest_request->nc);
+        } else if (!strncmp(item, "cnonce", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            /* quote mark */
+            p++;
+
+            digest_request->cnonce = xstrndup(p, strchr(p, '"') + 1 - p);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found cnonce '%s'\n", digest_request->cnonce);
+        } else if (!strncmp(item, "response", ilen)) {
+            /* white space */
+
+            while (xisspace(*p))
+                p++;
+
+            /* quote mark */
+            p++;
+
+            digest_request->response = xstrndup(p, strchr(p, '"') + 1 - p);
+
+            debug(29, 9) ("authDigestDecodeAuth: Found response '%s'\n", digest_request->response);
+        }
     }
+
     temp.clean();
 
 
@@ -1180,100 +1372,111 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
      */
 
     /* first the NONCE count */
+
     if (digest_request->cnonce && strlen(digest_request->nc) != 8) {
-	debug(29, 4) ("authenticateDigestDecode: nonce count length invalid\n");
-	authDigestLogUsername(auth_user_request, username);
+        debug(29, 4) ("authenticateDigestDecode: nonce count length invalid\n");
+        authDigestLogUsername(auth_user_request, username);
 
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* now the nonce */
     nonce = authenticateDigestNonceFindNonce(digest_request->nonceb64);
+
     if ((nonce == NULL) || !(authDigestNonceIsValid(nonce, digest_request->nc))) {
-	/* we couldn't find a matching nonce! */
-	debug(29, 4) ("authenticateDigestDecode: Unexpected or invalid nonce recieved\n");
-	authDigestLogUsername(auth_user_request, username);
-
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+        /* we couldn't find a matching nonce! */
+        debug(29, 4) ("authenticateDigestDecode: Unexpected or invalid nonce recieved\n");
+        authDigestLogUsername(auth_user_request, username);
+
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     digest_request->nonce = nonce;
     authDigestNonceLink(nonce);
 
-    /* check the qop is what we expected. Note that for compatability with 
+    /* check the qop is what we expected. Note that for compatability with
      * RFC 2069 we should support a missing qop. Tough. */
+
     if (!digest_request->qop || strcmp(digest_request->qop, QOP_AUTH)) {
-	/* we recieved a qop option we didn't send */
-	debug(29, 4) ("authenticateDigestDecode: Invalid qop option recieved\n");
-	authDigestLogUsername(auth_user_request, username);
-
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+        /* we recieved a qop option we didn't send */
+        debug(29, 4) ("authenticateDigestDecode: Invalid qop option recieved\n");
+        authDigestLogUsername(auth_user_request, username);
+
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* we can't check the URI just yet. We'll check it in the
      * authenticate phase */
 
     /* is the response the correct length? */
 
     if (!digest_request->response || strlen(digest_request->response) != 32) {
-	debug(29, 4) ("authenticateDigestDecode: Response length invalid\n");
-	authDigestLogUsername(auth_user_request, username);
+        debug(29, 4) ("authenticateDigestDecode: Response length invalid\n");
+        authDigestLogUsername(auth_user_request, username);
 
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* do we have a username ? */
     if (!username || username[0] == '\0') {
-	debug(29, 4) ("authenticateDigestDecode: Empty or not present username\n");
-	authDigestLogUsername(auth_user_request, username);
+        debug(29, 4) ("authenticateDigestDecode: Empty or not present username\n");
+        authDigestLogUsername(auth_user_request, username);
 
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* check that we're not being hacked / the username hasn't changed */
     if (nonce->auth_user && strcmp(username, nonce->auth_user->username())) {
-	debug(29, 4) ("authenticateDigestDecode: Username for the nonce does not equal the username for the request\n");
-	authDigestLogUsername(auth_user_request, username);
+        debug(29, 4) ("authenticateDigestDecode: Username for the nonce does not equal the username for the request\n");
+        authDigestLogUsername(auth_user_request, username);
 
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* if we got a qop, did we get a cnonce or did we get a cnonce wihtout a qop? */
     if ((digest_request->qop && !digest_request->cnonce)
-	|| (!digest_request->qop && digest_request->cnonce)) {
-	debug(29, 4) ("authenticateDigestDecode: qop without cnonce, or vice versa!\n");
-	authDigestLogUsername(auth_user_request, username);
-
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+            || (!digest_request->qop && digest_request->cnonce)) {
+        debug(29, 4) ("authenticateDigestDecode: qop without cnonce, or vice versa!\n");
+        authDigestLogUsername(auth_user_request, username);
+
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* check the algorithm is present and supported */
     if (!digest_request->algorithm)
-	digest_request->algorithm = xstrndup("MD5", 4);
+        digest_request->algorithm = xstrndup("MD5", 4);
     else if (strcmp(digest_request->algorithm, "MD5")
-	&& strcmp(digest_request->algorithm, "MD5-sess")) {
-	debug(29, 4) ("authenticateDigestDecode: invalid algorithm specified!\n");
-	authDigestLogUsername(auth_user_request, username);
-
-	/* we don't need the scheme specific data anymore */
-	authDigestRequestDelete(digest_request);
-	auth_user_request->scheme_data = NULL;
-	return;
+             && strcmp(digest_request->algorithm, "MD5-sess")) {
+        debug(29, 4) ("authenticateDigestDecode: invalid algorithm specified!\n");
+        authDigestLogUsername(auth_user_request, username);
+
+        /* we don't need the scheme specific data anymore */
+        authDigestRequestDelete(digest_request);
+        auth_user_request->scheme_data = NULL;
+        return;
     }
+
     /* the method we'll check at the authenticate step as well */
 
 
@@ -1282,46 +1485,51 @@ authenticateDigestDecodeAuth(auth_user_request_t * auth_user_request, const char
     /* find the user */
 
     if ((auth_user = authDigestUserFindUsername(username)) == NULL) {
-	/* the user doesn't exist in the username cache yet */
-	debug(29, 9) ("authDigestDecodeAuth: Creating new digest user '%s'\n", username);
-	/* new auth_user */
-	auth_user = authenticateAuthUserNew("digest");
-	/* new scheme user data */
-	digest_user = authDigestUserNew();
-	/* save the username */
-	digest_user->username = username;
-	/* link the primary struct in */
-	auth_user->scheme_data = digest_user;
-	/* set the user type */
-	auth_user->auth_type = AUTH_DIGEST;
-	/* this auth_user struct is the one to get added to the
-	 * username cache */
-	/* store user in hash's */
-	authenticateUserNameCacheAdd(auth_user);
-	/* 
-	 * Add the digest to the user so we can tell if a hacking
-	 * or spoofing attack is taking place. We do this by assuming
-	 * the user agent won't change user name without warning.
-	 */
-	authDigestUserLinkNonce(auth_user, nonce);
+        /* the user doesn't exist in the username cache yet */
+        debug(29, 9) ("authDigestDecodeAuth: Creating new digest user '%s'\n", username);
+        /* new auth_user */
+        auth_user = authenticateAuthUserNew("digest");
+        /* new scheme user data */
+        digest_user = authDigestUserNew();
+        /* save the username */
+        digest_user->username = username;
+        /* link the primary struct in */
+        auth_user->scheme_data = digest_user;
+        /* set the user type */
+        auth_user->auth_type = AUTH_DIGEST;
+        /* this auth_user struct is the one to get added to the
+         * username cache */
+        /* store user in hash's */
+        authenticateUserNameCacheAdd(auth_user);
+        /*
+         * Add the digest to the user so we can tell if a hacking
+         * or spoofing attack is taking place. We do this by assuming
+         * the user agent won't change user name without warning.
+         */
+        authDigestUserLinkNonce(auth_user, nonce);
     } else {
-	debug(29, 9) ("authDigestDecodeAuth: Found user '%s' in the user cache as '%p'\n", username, auth_user);
-	digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
-	xfree(username);
+        debug(29, 9) ("authDigestDecodeAuth: Found user '%s' in the user cache as '%p'\n", username, auth_user);
+        digest_user = static_cast < digest_user_h * >(auth_user->scheme_data);
+        xfree(username);
     }
+
     /*link the request and the user */
     auth_user_request->auth_user = auth_user;
+
     auth_user_request->scheme_data = digest_request;
+
     /* lock for the request link */
     authenticateAuthUserLock(auth_user);
+
     node = dlinkNodeNew();
+
     dlinkAdd(auth_user_request, node, &auth_user->requests);
 
     debug(29, 9) ("username = '%s'\nrealm = '%s'\nqop = '%s'\nalgorithm = '%s'\nuri = '%s'\nnonce = '%s'\nnc = '%s'\ncnonce = '%s'\nresponse = '%s'\ndigestnonce = '%p'\n",
-	digest_user->username, digest_request->realm,
-	digest_request->qop, digest_request->algorithm,
-	digest_request->uri, digest_request->nonceb64,
-	digest_request->nc, digest_request->cnonce, digest_request->response, nonce);
+                  digest_user->username, digest_request->realm,
+                  digest_request->qop, digest_request->algorithm,
+                  digest_request->uri, digest_request->nonceb64,
+                  digest_request->nc, digest_request->cnonce, digest_request->response, nonce);
 
     return;
 }
@@ -1342,11 +1550,13 @@ authenticateDigestStart(auth_user_request_t * auth_user_request, RH * handler, v
     digest_request = static_cast < digest_request_h * >(auth_user_request->scheme_data);
     digest_user = static_cast < digest_user_h * >(auth_user_request->auth_user->scheme_data);
     debug(29, 9) ("authenticateStart: '\"%s\":\"%s\"'\n", digest_user->username,
-	digest_request->realm);
+                  digest_request->realm);
+
     if (digestConfig->authenticate == NULL) {
-	handler(data, NULL);
-	return;
+        handler(data, NULL);
+        return;
     }
+
     r = cbdataAlloc(DigestAuthenticateStateData);
     r->handler = handler;
     r->data = cbdataReference(data);
@@ -8,32 +8,46 @@
 #include "rfc2617.h"
 
 /* Generic */
-class DigestAuthenticateStateData {
+
+class DigestAuthenticateStateData
+{
+
 public:
     void *data;
     auth_user_request_t *auth_user_request;
     RH *handler;
 };
 
 typedef struct _digest_request_h digest_request_h;
+
 typedef struct _digest_user_h digest_user_h;
+
 typedef struct _digest_nonce_data digest_nonce_data;
 
 typedef struct _digest_nonce_h digest_nonce_h;
 
-struct _digest_user_h {
+struct _digest_user_h
+{
     char *username;
     HASH HA1;
     int HA1created;
-    struct {
-	unsigned int credentials_ok:2;	/*0=unchecked,1=ok,2=failed */
-    } flags;
+
+    struct
+    {
+
+unsigned int credentials_ok:
+        2;	/*0=unchecked,1=ok,2=failed */
+    }
+
+    flags;
     /* what nonces have been allocated to this user */
     dlink_list nonces;
 };
 
 /* the digest_request structure is what follows the http_request around */
-struct _digest_request_h {
+
+struct _digest_request_h
+{
     char *nonceb64;		/* "dcd98b7102dd2f0e8b11d0f600bfb0c093" */
     char *cnonce;		/* "0a4f113b" */
     char *realm;		/* = "testrealm@host.com" */
@@ -44,22 +58,32 @@ struct _digest_request_h {
     char *qop;			/* = "auth" */
     char *uri;			/* = "/dir/index.html" */
     char *response;
-    struct {
-	unsigned int authinfo_sent:1;
-    } flags;
+
+    struct
+    {
+
+unsigned int authinfo_sent:
+        1;
+    }
+
+    flags;
     digest_nonce_h *nonce;
 };
 
 /* data to be encoded into the nonce's b64 representation */
-struct _digest_nonce_data {
+
+struct _digest_nonce_data
+{
     time_t creationtime;
     /* in memory address of the nonce struct (similar purpose to an ETag) */
     digest_nonce_h *self;
     long randomdata;
 };
 
 /* the nonce structure we'll pass around */
-struct _digest_nonce_h : public hash_link {
+
+struct _digest_nonce_h : public hash_link
+{
     digest_nonce_data noncedata;
     /* number of uses we've seen of this nonce */
     unsigned long nc;
@@ -68,14 +92,24 @@ struct _digest_nonce_h : public hash_link {
     /* the auth_user this nonce has been tied to */
     auth_user_t *auth_user;
     /* has this nonce been invalidated ? */
-    struct {
-	unsigned int valid:1;
-	unsigned int incache:1;
-    } flags;
+
+    struct
+    {
+
+unsigned int valid:
+        1;
+
+unsigned int incache:
+        1;
+    }
+
+    flags;
 };
 
 /* configuration runtime data */
-struct _auth_digest_config {
+
+struct _auth_digest_config
+{
     int authenticateChildren;
     char *digestAuthRealm;
     wordlist *authenticate;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: auth_ntlm.cc,v 1.28 2003/02/06 09:57:40 robertc Exp $
+ * $Id: auth_ntlm.cc,v 1.29 2003/02/21 22:50:28 robertc Exp $
  *
  * DEBUG: section 29    NTLM Authenticator
  * AUTHOR: Robert Collins
@@ -103,24 +103,34 @@ static void
 authNTLMDone(void)
 {
     debug(29, 2) ("authNTLMDone: shutting down NTLM authentication.\n");
+
     if (ntlmauthenticators)
-	helperStatefulShutdown(ntlmauthenticators);
+        helperStatefulShutdown(ntlmauthenticators);
+
     authntlm_initialised = 0;
+
     if (!shutting_down)
-	return;
+        return;
+
     if (ntlmauthenticators)
-	helperStatefulFree(ntlmauthenticators);
+        helperStatefulFree(ntlmauthenticators);
+
     ntlmauthenticators = NULL;
+
 #if DEBUGSHUTDOWN
+
     if (ntlm_helper_state_pool) {
-	memPoolDestroy(&ntlm_helper_state_pool);
+        memPoolDestroy(&ntlm_helper_state_pool);
     }
+
     if (ntlm_request_pool) {
-	memPoolDestroy(&ntlm_request_pool);
+        memPoolDestroy(&ntlm_request_pool);
     }
+
     if (ntlm_user_pool) {
-	memPoolDestroy(&ntlm_user_pool);
+        memPoolDestroy(&ntlm_user_pool);
     }
+
 #endif
     debug(29, 2) ("authNTLMDone: NTLM authentication Shutdown.\n");
 }
@@ -130,11 +140,15 @@ static void
 authNTLMFreeConfig(authScheme * scheme)
 {
     if (ntlmConfig == NULL)
-	return;
+        return;
+
     assert(ntlmConfig == scheme->scheme_data);
+
     if (ntlmConfig->authenticate)
-	wordlistDestroy(&ntlmConfig->authenticate);
+        wordlistDestroy(&ntlmConfig->authenticate);
+
     xfree(ntlmConfig);
+
     ntlmConfig = NULL;
 }
 
@@ -144,45 +158,52 @@ authNTLMCfgDump(StoreEntry * entry, const char *name, authScheme * scheme)
     auth_ntlm_config *config = static_cast<auth_ntlm_config *>(scheme->scheme_data);
     wordlist *list = config->authenticate;
     storeAppendPrintf(entry, "%s %s", name, "ntlm");
+
     while (list != NULL) {
-	storeAppendPrintf(entry, " %s", list->key);
-	list = list->next;
+        storeAppendPrintf(entry, " %s", list->key);
+        list = list->next;
     }
+
     storeAppendPrintf(entry, "\n%s %s children %d\n%s %s max_challenge_reuses %d\n%s %s max_challenge_lifetime %d seconds\n",
-	name, "ntlm", config->authenticateChildren,
-	name, "ntlm", config->challengeuses,
-	name, "ntlm", (int) config->challengelifetime);
+                      name, "ntlm", config->authenticateChildren,
+                      name, "ntlm", config->challengeuses,
+                      name, "ntlm", (int) config->challengelifetime);
 
 }
 
 static void
 authNTLMParse(authScheme * scheme, int n_configured, char *param_str)
 {
     if (scheme->scheme_data == NULL) {
-	assert(ntlmConfig == NULL);
-	/* this is the first param to be found */
-	scheme->scheme_data = xmalloc(sizeof(auth_ntlm_config));
-	memset(scheme->scheme_data, 0, sizeof(auth_ntlm_config));
-	ntlmConfig = static_cast<auth_ntlm_config *>(scheme->scheme_data);
-	ntlmConfig->authenticateChildren = 5;
-	ntlmConfig->challengeuses = 0;
-	ntlmConfig->challengelifetime = 60;
+        assert(ntlmConfig == NULL);
+        /* this is the first param to be found */
+        scheme->scheme_data = xmalloc(sizeof(auth_ntlm_config));
+        memset(scheme->scheme_data, 0, sizeof(auth_ntlm_config));
+        ntlmConfig = static_cast<auth_ntlm_config *>(scheme->scheme_data);
+        ntlmConfig->authenticateChildren = 5;
+        ntlmConfig->challengeuses = 0;
+        ntlmConfig->challengelifetime = 60;
     }
+
     ntlmConfig = static_cast<auth_ntlm_config *>(scheme->scheme_data);
+
     if (strcasecmp(param_str, "program") == 0) {
-	if (ntlmConfig->authenticate)
-	    wordlistDestroy(&ntlmConfig->authenticate);
-	parse_wordlist(&ntlmConfig->authenticate);
-	requirePathnameExists("authparam ntlm program", ntlmConfig->authenticate->key);
+        if (ntlmConfig->authenticate)
+            wordlistDestroy(&ntlmConfig->authenticate);
+
+        parse_wordlist(&ntlmConfig->authenticate);
+
+        requirePathnameExists("authparam ntlm program", ntlmConfig->authenticate->key);
     } else if (strcasecmp(param_str, "children") == 0) {
-	parse_int(&ntlmConfig->authenticateChildren);
+        parse_int(&ntlmConfig->authenticateChildren);
     } else if (strcasecmp(param_str, "max_challenge_reuses") == 0) {
-	parse_int(&ntlmConfig->challengeuses);
+        parse_int(&ntlmConfig->challengeuses);
     } else if (strcasecmp(param_str, "max_challenge_lifetime") == 0) {
-	parse_time_t(&ntlmConfig->challengelifetime);
+        parse_time_t(&ntlmConfig->challengelifetime);
     } else {
-	debug(28, 0) ("unrecognised ntlm auth scheme parameter '%s'\n", param_str);
+        debug(28, 0) ("unrecognised ntlm auth scheme parameter '%s'\n", param_str);
     }
+
     /*
      * disable client side request pipelining. There is a race with
      * NTLM when the client sends a second request on an NTLM
@@ -192,7 +213,7 @@ authNTLMParse(authScheme * scheme, int n_configured, char *param_str)
      * test, but that can wait for the modular parser to be integrated.
      */
     if (ntlmConfig->authenticate)
-	Config.onoff.pipeline_prefetch = 0;
+        Config.onoff.pipeline_prefetch = 0;
 }
 
 
@@ -227,43 +248,61 @@ static void
 authNTLMInit(authScheme * scheme)
 {
     static int ntlminit = 0;
+
     if (ntlmConfig->authenticate) {
-	if (!ntlm_helper_state_pool)
-	    ntlm_helper_state_pool = memPoolCreate("NTLM Helper State data", sizeof(ntlm_helper_state_t));
-	if (!ntlm_user_pool)
-	    ntlm_user_pool = memPoolCreate("NTLM Scheme User Data", sizeof(ntlm_user_t));
-	if (!ntlm_request_pool)
-	    ntlm_request_pool = memPoolCreate("NTLM Scheme Request Data", sizeof(ntlm_request_t));
-	if (!ntlm_user_hash_pool)
-	    ntlm_user_hash_pool = memPoolCreate("NTLM Header Hash Data", sizeof(struct ProxyAuthCachePointer));
-	authntlm_initialised = 1;
-	if (ntlmauthenticators == NULL)
-	    ntlmauthenticators = helperStatefulCreate("ntlmauthenticator");
-	if (!proxy_auth_cache)
-	    proxy_auth_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
-	assert(proxy_auth_cache);
-	ntlmauthenticators->cmdline = ntlmConfig->authenticate;
-	ntlmauthenticators->n_to_start = ntlmConfig->authenticateChildren;
-	ntlmauthenticators->ipc_type = IPC_STREAM;
-	ntlmauthenticators->datapool = ntlm_helper_state_pool;
-	ntlmauthenticators->IsAvailable = authenticateNTLMHelperServerAvailable;
-	ntlmauthenticators->OnEmptyQueue = authenticateNTLMHelperServerOnEmpty;
-	helperStatefulOpenServers(ntlmauthenticators);
-	/*
-	 * TODO: In here send the initial YR to preinitialise the
-	 * challenge cache
-	 */
-	/*
-	 * Think about this... currently we ask when the challenge
-	 * is needed. Better?
-	 */
-	if (!ntlminit) {
-	    cachemgrRegister("ntlmauthenticator",
-		"NTLM User Authenticator Stats",
-		authenticateNTLMStats, 0, 1);
-	    ntlminit++;
-	}
-	CBDATA_INIT_TYPE(authenticateStateData);
+        if (!ntlm_helper_state_pool)
+            ntlm_helper_state_pool = memPoolCreate("NTLM Helper State data", sizeof(ntlm_helper_state_t));
+
+        if (!ntlm_user_pool)
+            ntlm_user_pool = memPoolCreate("NTLM Scheme User Data", sizeof(ntlm_user_t));
+
+        if (!ntlm_request_pool)
+            ntlm_request_pool = memPoolCreate("NTLM Scheme Request Data", sizeof(ntlm_request_t));
+
+        if (!ntlm_user_hash_pool)
+
+            ntlm_user_hash_pool = memPoolCreate("NTLM Header Hash Data", sizeof(struct ProxyAuthCachePointer));
+
+        authntlm_initialised = 1;
+
+        if (ntlmauthenticators == NULL)
+            ntlmauthenticators = helperStatefulCreate("ntlmauthenticator");
+
+        if (!proxy_auth_cache)
+            proxy_auth_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
+
+        assert(proxy_auth_cache);
+
+        ntlmauthenticators->cmdline = ntlmConfig->authenticate;
+
+        ntlmauthenticators->n_to_start = ntlmConfig->authenticateChildren;
+
+        ntlmauthenticators->ipc_type = IPC_STREAM;
+
+        ntlmauthenticators->datapool = ntlm_helper_state_pool;
+
+        ntlmauthenticators->IsAvailable = authenticateNTLMHelperServerAvailable;
+
+        ntlmauthenticators->OnEmptyQueue = authenticateNTLMHelperServerOnEmpty;
+
+        helperStatefulOpenServers(ntlmauthenticators);
+
+        /*
+         * TODO: In here send the initial YR to preinitialise the
+         * challenge cache
+         */
+        /*
+         * Think about this... currently we ask when the challenge
+         * is needed. Better?
+         */
+        if (!ntlminit) {
+            cachemgrRegister("ntlmauthenticator",
+                             "NTLM User Authenticator Stats",
+                             authenticateNTLMStats, 0, 1);
+            ntlminit++;
+        }
+
+        CBDATA_INIT_TYPE(authenticateStateData);
     }
 }
 
@@ -278,9 +317,10 @@ static int
 authNTLMConfigured()
 {
     if ((ntlmConfig != NULL) && (ntlmConfig->authenticate != NULL) && (ntlmConfig->authenticateChildren != 0) && (ntlmConfig->challengeuses > -1) && (ntlmConfig->challengelifetime > -1)) {
-	debug(29, 9) ("authNTLMConfigured: returning configured\n");
-	return 1;
+        debug(29, 9) ("authNTLMConfigured: returning configured\n");
+        return 1;
     }
+
     debug(29, 9) ("authNTLMConfigured: returning unconfigured\n");
     return 0;
 }
@@ -292,20 +332,28 @@ authenticateNTLMDirection(auth_user_request_t * auth_user_request)
 {
     ntlm_request_t *ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
     /* null auth_user is checked for by authenticateDirection */
+
     switch (ntlm_request->auth_state) {
+
     case AUTHENTICATE_STATE_NONE:	/* no progress at all. */
-	debug(29, 1) ("authenticateNTLMDirection: called before NTLM Authenticate!. Report a bug to squid-dev. au %p\n", auth_user_request);
-	/* fall thru */
+        debug(29, 1) ("authenticateNTLMDirection: called before NTLM Authenticate!. Report a bug to squid-dev. au %p\n", auth_user_request);
+        /* fall thru */
+
     case AUTHENTICATE_STATE_FAILED:
-	return -2;
+        return -2;
+
     case AUTHENTICATE_STATE_NEGOTIATE:		/* send to helper */
+
     case AUTHENTICATE_STATE_RESPONSE:	/*send to helper */
-	return -1;
+        return -1;
+
     case AUTHENTICATE_STATE_CHALLENGE:		/* send to client */
-	return 1;
+        return 1;
+
     case AUTHENTICATE_STATE_DONE:	/* do nothing.. */
-	return 0;
+        return 0;
     }
+
     return -2;
 }
 
@@ -318,67 +366,79 @@ static void
 authenticateNTLMFixErrorHeader(auth_user_request_t * auth_user_request, HttpReply * rep, http_hdr_type type, request_t * request)
 {
     ntlm_request_t *ntlm_request;
+
     if (ntlmConfig->authenticate) {
-	/* New request, no user details */
-	if (auth_user_request == NULL) {
-	    debug(29, 9) ("authenticateNTLMFixErrorHeader: Sending type:%d header: 'NTLM'\n", type);
-	    httpHeaderPutStrf(&rep->header, type, "NTLM");
-	    /* drop the connection */
-	    httpHeaderDelByName(&rep->header, "keep-alive");
-	    /* NTLM has problems if the initial connection is not dropped
-	     * I haven't checked the RFC compliance of this hack - RBCollins */
-	    request->flags.proxy_keepalive = 0;
-	} else {
-	    ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	    switch (ntlm_request->auth_state) {
-	    case AUTHENTICATE_STATE_NONE:
-	    case AUTHENTICATE_STATE_FAILED:
-		debug(29, 9) ("authenticateNTLMFixErrorHeader: Sending type:%d header: 'NTLM'\n", type);
-		httpHeaderPutStrf(&rep->header, type, "NTLM");
-		/* drop the connection */
-		httpHeaderDelByName(&rep->header, "keep-alive");
-		/* NTLM has problems if the initial connection is not dropped
-		 * I haven't checked the RFC compliance of this hack - RBCollins */
-		request->flags.proxy_keepalive = 0;
-		break;
-	    case AUTHENTICATE_STATE_CHALLENGE:
-		/* we are 'waiting' for a response */
-		/* pass the challenge to the client */
-		debug(29, 9) ("authenticateNTLMFixErrorHeader: Sending type:%d header: 'NTLM %s'\n", type, ntlm_request->authchallenge);
-		httpHeaderPutStrf(&rep->header, type, "NTLM %s", ntlm_request->authchallenge);
-		break;
-	    default:
-		debug(29, 0) ("authenticateNTLMFixErrorHeader: state %d.\n", ntlm_request->auth_state);
-		fatal("unexpected state in AuthenticateNTLMFixErrorHeader.\n");
-	    }
-	}
+        /* New request, no user details */
+
+        if (auth_user_request == NULL) {
+            debug(29, 9) ("authenticateNTLMFixErrorHeader: Sending type:%d header: 'NTLM'\n", type);
+            httpHeaderPutStrf(&rep->header, type, "NTLM");
+            /* drop the connection */
+            httpHeaderDelByName(&rep->header, "keep-alive");
+            /* NTLM has problems if the initial connection is not dropped
+             * I haven't checked the RFC compliance of this hack - RBCollins */
+            request->flags.proxy_keepalive = 0;
+        } else {
+            ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+
+            switch (ntlm_request->auth_state) {
+
+            case AUTHENTICATE_STATE_NONE:
+
+            case AUTHENTICATE_STATE_FAILED:
+                debug(29, 9) ("authenticateNTLMFixErrorHeader: Sending type:%d header: 'NTLM'\n", type);
+                httpHeaderPutStrf(&rep->header, type, "NTLM");
+                /* drop the connection */
+                httpHeaderDelByName(&rep->header, "keep-alive");
+                /* NTLM has problems if the initial connection is not dropped
+                 * I haven't checked the RFC compliance of this hack - RBCollins */
+                request->flags.proxy_keepalive = 0;
+                break;
+
+            case AUTHENTICATE_STATE_CHALLENGE:
+                /* we are 'waiting' for a response */
+                /* pass the challenge to the client */
+                debug(29, 9) ("authenticateNTLMFixErrorHeader: Sending type:%d header: 'NTLM %s'\n", type, ntlm_request->authchallenge);
+                httpHeaderPutStrf(&rep->header, type, "NTLM %s", ntlm_request->authchallenge);
+                break;
+
+            default:
+                debug(29, 0) ("authenticateNTLMFixErrorHeader: state %d.\n", ntlm_request->auth_state);
+                fatal("unexpected state in AuthenticateNTLMFixErrorHeader.\n");
+            }
+        }
     }
 }
 
 static void
 authNTLMRequestFree(ntlm_request_t * ntlm_request)
 {
     if (!ntlm_request)
-	return;
+        return;
+
     if (ntlm_request->ntlmnegotiate)
-	xfree(ntlm_request->ntlmnegotiate);
+        xfree(ntlm_request->ntlmnegotiate);
+
     if (ntlm_request->authchallenge)
-	xfree(ntlm_request->authchallenge);
+        xfree(ntlm_request->authchallenge);
+
     if (ntlm_request->ntlmauthenticate)
-	xfree(ntlm_request->ntlmauthenticate);
+        xfree(ntlm_request->ntlmauthenticate);
+
     if (ntlm_request->authserver != NULL && ntlm_request->authserver_deferred) {
-	debug(29, 9) ("authenticateNTLMRequestFree: releasing server '%p'\n", ntlm_request->authserver);
-	helperStatefulReleaseServer(ntlm_request->authserver);
-	ntlm_request->authserver = NULL;
+        debug(29, 9) ("authenticateNTLMRequestFree: releasing server '%p'\n", ntlm_request->authserver);
+        helperStatefulReleaseServer(ntlm_request->authserver);
+        ntlm_request->authserver = NULL;
     }
+
     memPoolFree(ntlm_request_pool, ntlm_request);
 }
 
 static void
 authNTLMAURequestFree(auth_user_request_t * auth_user_request)
 {
     if (auth_user_request->scheme_data)
-	authNTLMRequestFree(static_cast< ntlm_request_t *>(auth_user_request->scheme_data));
+        authNTLMRequestFree(static_cast< ntlm_request_t *>(auth_user_request->scheme_data));
     auth_user_request->scheme_data = NULL;
 }
 
@@ -390,21 +450,25 @@ authenticateNTLMFreeUser(auth_user_t * auth_user)
     ProxyAuthCachePointer *proxy_auth_hash;
 
     debug(29, 5) ("authenticateNTLMFreeUser: Clearing NTLM scheme data\n");
+
     if (ntlm_user->username)
-	xfree(ntlm_user->username);
+        xfree(ntlm_user->username);
+
     /* were they linked in by one or more proxy-authenticate headers */
     link = ntlm_user->proxy_auth_list.head;
+
     while (link) {
-	debug(29, 9) ("authenticateFreeProxyAuthUser: removing proxy_auth hash entry '%p'\n", link->data);
-	proxy_auth_hash = static_cast<ProxyAuthCachePointer *>(link->data);
-	tmplink = link;
-	link = link->next;
-	dlinkDelete(tmplink, &ntlm_user->proxy_auth_list);
-	hash_remove_link(proxy_auth_cache, (hash_link *) proxy_auth_hash);
-	/* free the key (usually the proxy_auth header) */
-	xfree(proxy_auth_hash->key);
-	memPoolFree(ntlm_user_hash_pool, proxy_auth_hash);
+        debug(29, 9) ("authenticateFreeProxyAuthUser: removing proxy_auth hash entry '%p'\n", link->data);
+        proxy_auth_hash = static_cast<ProxyAuthCachePointer *>(link->data);
+        tmplink = link;
+        link = link->next;
+        dlinkDelete(tmplink, &ntlm_user->proxy_auth_list);
+        hash_remove_link(proxy_auth_cache, (hash_link *) proxy_auth_hash);
+        /* free the key (usually the proxy_auth header) */
+        xfree(proxy_auth_hash->key);
+        memPoolFree(ntlm_user_hash_pool, proxy_auth_hash);
     }
+
     memPoolFree(ntlm_user_pool, ntlm_user);
     auth_user->scheme_data = NULL;
 }
@@ -418,15 +482,21 @@ authenticateNTLMHandleplaceholder(void *data, void *lastserver, char *reply)
     assert(reply == NULL);
     assert(r->auth_user_request);
     /* standard callback stuff */
+
     if (!cbdataReferenceValid(r->data)) {
-	debug(29, 1) ("AuthenticateNTLMHandlePlacheholder: invalid callback data.\n");
-	return result;
+        debug(29, 1) ("AuthenticateNTLMHandlePlacheholder: invalid callback data.\n");
+        return result;
     }
+
     /* call authenticateNTLMStart to retry this request */
     debug(29, 9) ("authenticateNTLMHandleplaceholder: calling authenticateNTLMStart\n");
+
     authenticateNTLMStart(r->auth_user_request, r->handler, r->data);
+
     cbdataReferenceDone(r->data);
+
     authenticateStateFree(r);
+
     return result;
 }
 
@@ -442,172 +512,199 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
     ntlm_user_t *ntlm_user;
     ntlm_request_t *ntlm_request;
     debug(29, 9) ("authenticateNTLMHandleReply: Helper: '%p' {%s}\n", lastserver, reply ? reply : "<NULL>");
+
     if (!cbdataReferenceValid(r->data)) {
-	debug(29, 1) ("AuthenticateNTLMHandleReply: invalid callback data. Releasing helper '%p'.\n", lastserver);
-	cbdataReferenceDone(r->data);
-	authenticateStateFree(r);
-	debug(29, 9) ("NTLM HandleReply, telling stateful helper : %d\n", S_HELPER_RELEASE);
-	return S_HELPER_RELEASE;
+        debug(29, 1) ("AuthenticateNTLMHandleReply: invalid callback data. Releasing helper '%p'.\n", lastserver);
+        cbdataReferenceDone(r->data);
+        authenticateStateFree(r);
+        debug(29, 9) ("NTLM HandleReply, telling stateful helper : %d\n", S_HELPER_RELEASE);
+        return S_HELPER_RELEASE;
     }
+
     if (!reply) {
-	/*
-	 * TODO: this occurs when a helper crashes. We should clean
-	 * up that helpers resources and queued requests.
-	 */
-	fatal("authenticateNTLMHandleReply: called with no result string\n");
+        /*
+         * TODO: this occurs when a helper crashes. We should clean
+         * up that helpers resources and queued requests.
+         */
+        fatal("authenticateNTLMHandleReply: called with no result string\n");
     }
+
     /* seperate out the useful data */
     if (strncasecmp(reply, "TT ", 3) == 0) {
-	reply += 3;
-	/* we have been given a Challenge */
-	/* we should check we weren't given an empty challenge */
-	/* copy the challenge to the state data */
-	helperstate = static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(static_cast<helper_stateful_server *>(lastserver)));
-	if (helperstate == NULL)
-	    fatal("lost NTLM helper state! quitting\n");
-	helperstate->challenge = xstrndup(reply, NTLM_CHALLENGE_SZ + 5);
-	helperstate->challengeuses = 0;
-	helperstate->renewed = squid_curtime;
-	/* and we satisfy the request that happended on the refresh boundary */
-	/* note this code is now in two places FIXME */
-	assert(r->auth_user_request != NULL);
-	assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
-	auth_user_request = r->auth_user_request;
-	ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	assert(ntlm_request != NULL);
-	result = S_HELPER_DEFER;
-	/* reserve the server for future authentication */
-	ntlm_request->authserver_deferred = 1;
-	debug(29, 9) ("authenticateNTLMHandleReply: helper '%p'\n", lastserver);
-	assert(ntlm_request->auth_state == AUTHENTICATE_STATE_NEGOTIATE);
-	ntlm_request->authserver = static_cast<helper_stateful_server *>(lastserver);
-	ntlm_request->authchallenge = xstrndup(reply, NTLM_CHALLENGE_SZ + 5);
+        reply += 3;
+        /* we have been given a Challenge */
+        /* we should check we weren't given an empty challenge */
+        /* copy the challenge to the state data */
+        helperstate = static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(static_cast<helper_stateful_server *>(lastserver)));
+
+        if (helperstate == NULL)
+            fatal("lost NTLM helper state! quitting\n");
+
+        helperstate->challenge = xstrndup(reply, NTLM_CHALLENGE_SZ + 5);
+
+        helperstate->challengeuses = 0;
+
+        helperstate->renewed = squid_curtime;
+
+        /* and we satisfy the request that happended on the refresh boundary */
+        /* note this code is now in two places FIXME */
+        assert(r->auth_user_request != NULL);
+
+        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+
+        auth_user_request = r->auth_user_request;
+
+        ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+
+        assert(ntlm_request != NULL);
+
+        result = S_HELPER_DEFER;
+
+        /* reserve the server for future authentication */
+        ntlm_request->authserver_deferred = 1;
+
+        debug(29, 9) ("authenticateNTLMHandleReply: helper '%p'\n", lastserver);
+
+        assert(ntlm_request->auth_state == AUTHENTICATE_STATE_NEGOTIATE);
+
+        ntlm_request->authserver = static_cast<helper_stateful_server *>(lastserver);
+
+        ntlm_request->authchallenge = xstrndup(reply, NTLM_CHALLENGE_SZ + 5);
     } else if (strncasecmp(reply, "AF ", 3) == 0) {
-	/* we're finished, release the helper */
-	reply += 3;
-	assert(r->auth_user_request != NULL);
-	assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
-	auth_user_request = r->auth_user_request;
-	assert(auth_user_request->scheme_data != NULL);
-	ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	auth_user = auth_user_request->auth_user;
-	ntlm_user = static_cast<ntlm_user_t *>(auth_user_request->auth_user->scheme_data);
-	assert(ntlm_user != NULL);
-	result = S_HELPER_RELEASE;
-	/* we only expect OK when finishing the handshake */
-	assert(ntlm_request->auth_state == AUTHENTICATE_STATE_RESPONSE);
-	ntlm_user->username = xstrndup(reply, MAX_LOGIN_SZ);
-	ntlm_request->authserver = NULL;
+        /* we're finished, release the helper */
+        reply += 3;
+        assert(r->auth_user_request != NULL);
+        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        auth_user_request = r->auth_user_request;
+        assert(auth_user_request->scheme_data != NULL);
+        ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+        auth_user = auth_user_request->auth_user;
+        ntlm_user = static_cast<ntlm_user_t *>(auth_user_request->auth_user->scheme_data);
+        assert(ntlm_user != NULL);
+        result = S_HELPER_RELEASE;
+        /* we only expect OK when finishing the handshake */
+        assert(ntlm_request->auth_state == AUTHENTICATE_STATE_RESPONSE);
+        ntlm_user->username = xstrndup(reply, MAX_LOGIN_SZ);
+        ntlm_request->authserver = NULL;
 #ifdef NTLM_FAIL_OPEN
+
     } else if (strncasecmp(reply, "LD ", 3) == 0) {
-	/* This is a variant of BH, which rather than deny access
-	 * allows the user through. The helper is starved and then refreshed
-	 * via YR, all pending authentications are likely to fail also.
-	 * It is meant for those helpers which occasionally fail for
-	 * no reason at all (casus belli, NTLMSSP helper on NT domain,
-	 * failing about 1 auth out of 1k.
-	 * The code is a merge from the BH case with snippets of the AF
-	 * case */
-	/* AF code: mark user as authenticated */
-	reply += 3;
-	assert(r->auth_user_request != NULL);
-	assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
-	auth_user_request = r->auth_user_request;
-	assert(auth_user_request->scheme_data != NULL);
-	ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	auth_user = auth_user_request->auth_user;
-	ntlm_user = static_cast<ntlm_user_t *>(auth_user_request->auth_user->scheme_data);
-	assert(ntlm_user != NULL);
-	result = S_HELPER_RELEASE;
-	/* we only expect LD when finishing the handshake */
-	assert(ntlm_request->auth_state == AUTHENTICATE_STATE_RESPONSE);
-	ntlm_user->username = xstrndup(reply, MAX_LOGIN_SZ);
-	helperstate = helperStatefulServerGetData(ntlm_request->authserver);
-	ntlm_request->authserver = NULL;
-	/* BH code: mark helper as broken */
-	/* mark it for starving */
-	helperstate->starve = 1;
+        /* This is a variant of BH, which rather than deny access
+         * allows the user through. The helper is starved and then refreshed
+         * via YR, all pending authentications are likely to fail also.
+         * It is meant for those helpers which occasionally fail for
+         * no reason at all (casus belli, NTLMSSP helper on NT domain,
+         * failing about 1 auth out of 1k.
+         * The code is a merge from the BH case with snippets of the AF
+         * case */
+        /* AF code: mark user as authenticated */
+        reply += 3;
+        assert(r->auth_user_request != NULL);
+        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        auth_user_request = r->auth_user_request;
+        assert(auth_user_request->scheme_data != NULL);
+        ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+        auth_user = auth_user_request->auth_user;
+        ntlm_user = static_cast<ntlm_user_t *>(auth_user_request->auth_user->scheme_data);
+        assert(ntlm_user != NULL);
+        result = S_HELPER_RELEASE;
+        /* we only expect LD when finishing the handshake */
+        assert(ntlm_request->auth_state == AUTHENTICATE_STATE_RESPONSE);
+        ntlm_user->username = xstrndup(reply, MAX_LOGIN_SZ);
+        helperstate = helperStatefulServerGetData(ntlm_request->authserver);
+        ntlm_request->authserver = NULL;
+        /* BH code: mark helper as broken */
+        /* mark it for starving */
+        helperstate->starve = 1;
 #endif
+
     } else if (strncasecmp(reply, "NA ", 3) == 0) {
-	/* TODO: only work with auth_user here if it exists */
-	assert(r->auth_user_request != NULL);
-	assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
-	auth_user_request = r->auth_user_request;
-	auth_user = auth_user_request->auth_user;
-	assert(auth_user != NULL);
-	ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-	ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	assert((ntlm_user != NULL) && (ntlm_request != NULL));
-	/* todo: action of Negotiate state on error */
-	result = S_HELPER_RELEASE;	/*some error has occured. no more requests */
-	ntlm_request->authserver = NULL;
-	debug(29, 4) ("authenticateNTLMHandleReply: Error validating user via NTLM. Error returned '%s'\n", reply);
-	ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
-	if ((t = strchr(reply, ' ')))	/* strip after a space */
-	    *t = '\0';
+        /* TODO: only work with auth_user here if it exists */
+        assert(r->auth_user_request != NULL);
+        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        auth_user_request = r->auth_user_request;
+        auth_user = auth_user_request->auth_user;
+        assert(auth_user != NULL);
+        ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
+        ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+        assert((ntlm_user != NULL) && (ntlm_request != NULL));
+        /* todo: action of Negotiate state on error */
+        result = S_HELPER_RELEASE;	/*some error has occured. no more requests */
+        ntlm_request->authserver = NULL;
+        debug(29, 4) ("authenticateNTLMHandleReply: Error validating user via NTLM. Error returned '%s'\n", reply);
+        ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
+
+        if ((t = strchr(reply, ' ')))	/* strip after a space */
+            *t = '\0';
     } else if (strncasecmp(reply, "NA", 2) == 0) {
-	/* NTLM Helper protocol violation! */
-	fatal("NTLM Helper returned invalid response \"NA\" - a error message MUST be attached\n");
+        /* NTLM Helper protocol violation! */
+        fatal("NTLM Helper returned invalid response \"NA\" - a error message MUST be attached\n");
     } else if (strncasecmp(reply, "BH ", 3) == 0) {
-	/* TODO kick off a refresh process. This can occur after a YR or after
-	 * a KK. If after a YR release the helper and resubmit the request via 
-	 * Authenticate NTLM start. 
-	 * If after a KK deny the user's request w/ 407 and mark the helper as 
-	 * Needing YR. */
-	assert(r->auth_user_request != NULL);
-	assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
-	auth_user_request = r->auth_user_request;
-	auth_user = auth_user_request->auth_user;
-	assert(auth_user != NULL);
-	ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-	ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	assert((ntlm_user != NULL) && (ntlm_request != NULL));
-	result = S_HELPER_RELEASE;	/*some error has occured. no more requests for 
-					 * this helper */
-	assert(ntlm_request->authserver ? ntlm_request->authserver == lastserver : 1);
-	helperstate = static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(ntlm_request->authserver));
-	ntlm_request->authserver = NULL;
-	if (ntlm_request->auth_state == AUTHENTICATE_STATE_NEGOTIATE) {
-	    /* The helper broke on YR. It automatically
-	     * resets */
-	    debug(29, 1) ("authenticateNTLMHandleReply: Error obtaining challenge from helper: %p. Error returned '%s'\n", lastserver, reply);
-	    /* mark it for starving */
-	    helperstate->starve = 1;
-	    /* resubmit the request. This helper is currently busy, so we will get
-	     * a different one. Our auth state stays the same */
-	    authenticateNTLMStart(auth_user_request, r->handler, r->data);
-	    /* don't call the callback */
-	    cbdataReferenceDone(r->data);
-	    authenticateStateFree(r);
-	    debug(29, 9) ("NTLM HandleReply, telling stateful helper : %d\n", result);
-	    return result;
-	}
-	/* the helper broke on a KK */
-	/* first the standard KK stuff */
-	debug(29, 4) ("authenticateNTLMHandleReply: Error validating user via NTLM. Error returned '%s'\n", reply);
-	if ((t = strchr(reply, ' ')))	/* strip after a space */
-	    *t = '\0';
-	/* now we mark the helper for resetting. */
-	helperstate->starve = 1;
-	ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
+        /* TODO kick off a refresh process. This can occur after a YR or after
+         * a KK. If after a YR release the helper and resubmit the request via 
+         * Authenticate NTLM start. 
+         * If after a KK deny the user's request w/ 407 and mark the helper as 
+         * Needing YR. */
+        assert(r->auth_user_request != NULL);
+        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        auth_user_request = r->auth_user_request;
+        auth_user = auth_user_request->auth_user;
+        assert(auth_user != NULL);
+        ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
+        ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+        assert((ntlm_user != NULL) && (ntlm_request != NULL));
+        result = S_HELPER_RELEASE;	/*some error has occured. no more requests for
+        				                					 * this helper */
+        assert(ntlm_request->authserver ? ntlm_request->authserver == lastserver : 1);
+        helperstate = static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(ntlm_request->authserver));
+        ntlm_request->authserver = NULL;
+
+        if (ntlm_request->auth_state == AUTHENTICATE_STATE_NEGOTIATE) {
+            /* The helper broke on YR. It automatically
+             * resets */
+            debug(29, 1) ("authenticateNTLMHandleReply: Error obtaining challenge from helper: %p. Error returned '%s'\n", lastserver, reply);
+            /* mark it for starving */
+            helperstate->starve = 1;
+            /* resubmit the request. This helper is currently busy, so we will get
+             * a different one. Our auth state stays the same */
+            authenticateNTLMStart(auth_user_request, r->handler, r->data);
+            /* don't call the callback */
+            cbdataReferenceDone(r->data);
+            authenticateStateFree(r);
+            debug(29, 9) ("NTLM HandleReply, telling stateful helper : %d\n", result);
+            return result;
+        }
+
+        /* the helper broke on a KK */
+        /* first the standard KK stuff */
+        debug(29, 4) ("authenticateNTLMHandleReply: Error validating user via NTLM. Error returned '%s'\n", reply);
+
+        if ((t = strchr(reply, ' ')))	/* strip after a space */
+            *t = '\0';
+
+        /* now we mark the helper for resetting. */
+        helperstate->starve = 1;
+
+        ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
     } else {
-	/* TODO: only work with auth_user here if it exists */
-	/* TODO: take the request state into consideration */
-	assert(r->auth_user_request != NULL);
-	assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
-	auth_user_request = r->auth_user_request;
-	auth_user = auth_user_request->auth_user;
-	assert(auth_user != NULL);
-	ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-	ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
-	assert((ntlm_user != NULL) && (ntlm_request != NULL));
-	debug(29, 1) ("authenticateNTLMHandleReply: *** Unsupported helper response ***, '%s'\n", reply);
-	/* **** NOTE THIS CODE IS EFFECTIVELY UNTESTED **** */
-	/* restart the authentication process */
-	ntlm_request->auth_state = AUTHENTICATE_STATE_NONE;
-	assert(ntlm_request->authserver ? ntlm_request->authserver == lastserver : 1);
-	ntlm_request->authserver = NULL;
+        /* TODO: only work with auth_user here if it exists */
+        /* TODO: take the request state into consideration */
+        assert(r->auth_user_request != NULL);
+        assert(r->auth_user_request->auth_user->auth_type == AUTH_NTLM);
+        auth_user_request = r->auth_user_request;
+        auth_user = auth_user_request->auth_user;
+        assert(auth_user != NULL);
+        ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
+        ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+        assert((ntlm_user != NULL) && (ntlm_request != NULL));
+        debug(29, 1) ("authenticateNTLMHandleReply: *** Unsupported helper response ***, '%s'\n", reply);
+        /* **** NOTE THIS CODE IS EFFECTIVELY UNTESTED **** */
+        /* restart the authentication process */
+        ntlm_request->auth_state = AUTHENTICATE_STATE_NONE;
+        assert(ntlm_request->authserver ? ntlm_request->authserver == lastserver : 1);
+        ntlm_request->authserver = NULL;
     }
+
     r->handler(r->data, NULL);
     cbdataReferenceDone(r->data);
     authenticateStateFree(r);
@@ -627,8 +724,10 @@ static int
 authenticateNTLMValidChallenge(ntlm_helper_state_t * helperstate)
 {
     debug(29, 9) ("authenticateNTLMValidChallenge: Challenge is %s\n", helperstate->challenge ? "Valid" : "Invalid");
+
     if (helperstate->challenge == NULL)
-	return 0;
+        return 0;
+
     return 1;
 }
 
@@ -639,20 +738,24 @@ authenticateNTLMChangeChallenge_p(ntlm_helper_state_t * helperstate)
     /* don't check for invalid challenges just for expiry choices */
     /* this is needed because we have to starve the helper until all old
      * requests have been satisfied */
+
     if (!helperstate->renewed) {
-	/* first use, no challenge has been set. Without this check, it will
-	 * loop forever */
-	debug(29, 5) ("authenticateNTLMChangeChallenge_p: first use\n");
-	return 0;
+        /* first use, no challenge has been set. Without this check, it will
+         * loop forever */
+        debug(29, 5) ("authenticateNTLMChangeChallenge_p: first use\n");
+        return 0;
     }
+
     if (helperstate->challengeuses > ntlmConfig->challengeuses) {
-	debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge uses (%d) exceeded max uses (%d)\n", helperstate->challengeuses, ntlmConfig->challengeuses);
-	return 1;
+        debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge uses (%d) exceeded max uses (%d)\n", helperstate->challengeuses, ntlmConfig->challengeuses);
+        return 1;
     }
+
     if (helperstate->renewed + ntlmConfig->challengelifetime < squid_curtime) {
-	debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge exceeded max lifetime by %d seconds\n", (int) (squid_curtime - (helperstate->renewed + ntlmConfig->challengelifetime)));
-	return 1;
+        debug(29, 4) ("authenticateNTLMChangeChallenge_p: Challenge exceeded max lifetime by %d seconds\n", (int) (squid_curtime - (helperstate->renewed + ntlmConfig->challengelifetime)));
+        return 1;
     }
+
     debug(29, 9) ("Challenge is to be reused\n");
     return 0;
 }
@@ -680,100 +783,115 @@ authenticateNTLMStart(auth_user_request_t * auth_user_request, RH * handler, voi
     assert(data);
     assert(auth_user->auth_type = AUTH_NTLM);
     debug(29, 9) ("authenticateNTLMStart: auth state '%d'\n", ntlm_request->auth_state);
+
     switch (ntlm_request->auth_state) {
+
     case AUTHENTICATE_STATE_NEGOTIATE:
-	sent_string = ntlm_request->ntlmnegotiate;
-	break;
+        sent_string = ntlm_request->ntlmnegotiate;
+        break;
+
     case AUTHENTICATE_STATE_RESPONSE:
-	sent_string = ntlm_request->ntlmauthenticate;
-	assert(ntlm_request->authserver);
-	debug(29, 9) ("authenticateNTLMStart: Asking NTLMauthenticator '%p'.\n", ntlm_request->authserver);
-	break;
+        sent_string = ntlm_request->ntlmauthenticate;
+        assert(ntlm_request->authserver);
+        debug(29, 9) ("authenticateNTLMStart: Asking NTLMauthenticator '%p'.\n", ntlm_request->authserver);
+        break;
+
     default:
-	fatal("Invalid authenticate state for NTLMStart");
+        fatal("Invalid authenticate state for NTLMStart");
     }
 
     while (!xisspace(*sent_string))	/*trim NTLM */
-	sent_string++;
+        sent_string++;
 
     while (xisspace(*sent_string))	/*trim leading spaces */
-	sent_string++;
+        sent_string++;
 
     debug(29, 9) ("authenticateNTLMStart: state '%d'\n", ntlm_request->auth_state);
+
     debug(29, 9) ("authenticateNTLMStart: '%s'\n", sent_string);
+
     if (ntlmConfig->authenticate == NULL) {
-	debug(29, 0) ("authenticateNTLMStart: no NTLM program specified:'%s'\n", sent_string);
-	handler(data, NULL);
-	return;
+        debug(29, 0) ("authenticateNTLMStart: no NTLM program specified:'%s'\n", sent_string);
+        handler(data, NULL);
+        return;
     }
+
     /* this is ugly TODO: move the challenge generation routines to their own function and
      * tidy the logic up to make use of the efficiency we now have */
     switch (ntlm_request->auth_state) {
+
     case AUTHENTICATE_STATE_NEGOTIATE:
-	/*  
-	 * 1: get a helper server
-	 * 2: does it have a challenge?
-	 * 3: tell it to get a challenge, or give ntlmauthdone the challenge
-	 */
-	server = helperStatefulDefer(ntlmauthenticators);
-	helperstate = server ? static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(server)) : NULL;
-	while ((server != NULL) && authenticateNTLMChangeChallenge_p(helperstate)) {
-	    /* flag this helper for challenge changing */
-	    helperstate->starve = 1;
-	    /* and release the deferred request */
-	    helperStatefulReleaseServer(server);
-	    /* Get another deferrable server */
-	    server = helperStatefulDefer(ntlmauthenticators);
-	    helperstate = server ? static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(server)) : NULL;
-	}
-	if (server == NULL)
-	    debug(29, 9) ("unable to get a deferred ntlm helper... all helpers are refreshing challenges. Queuing as a placeholder request.\n");
-
-	ntlm_request->authserver = server;
-	/* tell the log what helper we have been given */
-	debug(29, 9) ("authenticateNTLMStart: helper '%p' assigned\n", server);
-	/* server and valid challenge? */
-	if ((server == NULL) || !authenticateNTLMValidChallenge(helperstate)) {
-	    /* No server, or server with invalid challenge */
-	    r = cbdataAlloc(authenticateStateData);
-	    r->handler = handler;
-	    r->data = cbdataReference(data);
-	    r->auth_user_request = auth_user_request;
-	    if (server == NULL) {
-		helperStatefulSubmit(ntlmauthenticators, NULL, authenticateNTLMHandleplaceholder, r, NULL);
-	    } else {
-		/* Server with invalid challenge */
-		snprintf(buf, 8192, "YR\n");
-		helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, ntlm_request->authserver);
-	    }
-	} else {
-	    /* (server != NULL and we have a valid challenge) */
-	    /* TODO: turn the below into a function and call from here and handlereply */
-	    /* increment the challenge uses */
-	    helperstate->challengeuses++;
-	    /* assign the challenge */
-	    ntlm_request->authchallenge = xstrndup(helperstate->challenge, NTLM_CHALLENGE_SZ + 5);
-	    /* we're not actually submitting a request, so we need to release the helper 
-	     * should the connection close unexpectedly
-	     */
-	    ntlm_request->authserver_deferred = 1;
-	    handler(data, NULL);
-	}
-
-	break;
+        /*
+         * 1: get a helper server
+         * 2: does it have a challenge?
+         * 3: tell it to get a challenge, or give ntlmauthdone the challenge
+         */
+        server = helperStatefulDefer(ntlmauthenticators);
+        helperstate = server ? static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(server)) : NULL;
+
+        while ((server != NULL) && authenticateNTLMChangeChallenge_p(helperstate)) {
+            /* flag this helper for challenge changing */
+            helperstate->starve = 1;
+            /* and release the deferred request */
+            helperStatefulReleaseServer(server);
+            /* Get another deferrable server */
+            server = helperStatefulDefer(ntlmauthenticators);
+            helperstate = server ? static_cast<ntlm_helper_state_t *>(helperStatefulServerGetData(server)) : NULL;
+        }
+
+        if (server == NULL)
+            debug(29, 9) ("unable to get a deferred ntlm helper... all helpers are refreshing challenges. Queuing as a placeholder request.\n");
+
+        ntlm_request->authserver = server;
+
+        /* tell the log what helper we have been given */
+        debug(29, 9) ("authenticateNTLMStart: helper '%p' assigned\n", server);
+
+        /* server and valid challenge? */
+        if ((server == NULL) || !authenticateNTLMValidChallenge(helperstate)) {
+            /* No server, or server with invalid challenge */
+            r = cbdataAlloc(authenticateStateData);
+            r->handler = handler;
+            r->data = cbdataReference(data);
+            r->auth_user_request = auth_user_request;
+
+            if (server == NULL) {
+                helperStatefulSubmit(ntlmauthenticators, NULL, authenticateNTLMHandleplaceholder, r, NULL);
+            } else {
+                /* Server with invalid challenge */
+                snprintf(buf, 8192, "YR\n");
+                helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, ntlm_request->authserver);
+            }
+        } else {
+            /* (server != NULL and we have a valid challenge) */
+            /* TODO: turn the below into a function and call from here and handlereply */
+            /* increment the challenge uses */
+            helperstate->challengeuses++;
+            /* assign the challenge */
+            ntlm_request->authchallenge = xstrndup(helperstate->challenge, NTLM_CHALLENGE_SZ + 5);
+            /* we're not actually submitting a request, so we need to release the helper
+             * should the connection close unexpectedly
+             */
+            ntlm_request->authserver_deferred = 1;
+            handler(data, NULL);
+        }
+
+        break;
+
     case AUTHENTICATE_STATE_RESPONSE:
-	r = cbdataAlloc(authenticateStateData);
-	r->handler = handler;
-	r->data = cbdataReference(data);
-	r->auth_user_request = auth_user_request;
-	snprintf(buf, 8192, "KK %s\n", sent_string);
-	/* getting rid of deferred request status */
-	ntlm_request->authserver_deferred = 0;
-	helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, ntlm_request->authserver);
-	debug(29, 9) ("authenticateNTLMstart: finished\n");
-	break;
+        r = cbdataAlloc(authenticateStateData);
+        r->handler = handler;
+        r->data = cbdataReference(data);
+        r->auth_user_request = auth_user_request;
+        snprintf(buf, 8192, "KK %s\n", sent_string);
+        /* getting rid of deferred request status */
+        ntlm_request->authserver_deferred = 0;
+        helperStatefulSubmit(ntlmauthenticators, buf, authenticateNTLMHandleReply, r, ntlm_request->authserver);
+        debug(29, 9) ("authenticateNTLMstart: finished\n");
+        break;
+
     default:
-	fatal("Invalid authenticate state for NTLMStart");
+        fatal("Invalid authenticate state for NTLMStart");
     }
 }
 
@@ -782,15 +900,17 @@ static int
 authenticateNTLMHelperServerAvailable(void *data)
 {
     ntlm_helper_state_t *statedata = static_cast<ntlm_helper_state_t *>(data);
+
     if (statedata != NULL) {
-	if (statedata->starve) {
-	    debug(29, 4) ("authenticateNTLMHelperServerAvailable: starving - returning 0\n");
-	    return 0;
-	} else {
-	    debug(29, 4) ("authenticateNTLMHelperServerAvailable: not starving - returning 1\n");
-	    return 1;
-	}
+        if (statedata->starve) {
+            debug(29, 4) ("authenticateNTLMHelperServerAvailable: starving - returning 0\n");
+            return 0;
+        } else {
+            debug(29, 4) ("authenticateNTLMHelperServerAvailable: not starving - returning 1\n");
+            return 1;
+        }
     }
+
     debug(29, 4) ("authenticateNTLMHelperServerAvailable: no state data - returning 0\n");
     return 0;
 }
@@ -799,16 +919,18 @@ static void
 authenticateNTLMHelperServerOnEmpty(void *data)
 {
     ntlm_helper_state_t *statedata = static_cast<ntlm_helper_state_t *>(data);
+
     if (statedata == NULL)
-	return;
+        return;
+
     if (statedata->starve) {
-	/* we have been starving the helper */
-	debug(29, 9) ("authenticateNTLMHelperServerOnEmpty: resetting challenge details\n");
-	statedata->starve = 0;
-	statedata->challengeuses = 0;
-	statedata->renewed = 0;
-	xfree(statedata->challenge);
-	statedata->challenge = NULL;
+        /* we have been starving the helper */
+        debug(29, 9) ("authenticateNTLMHelperServerOnEmpty: resetting challenge details\n");
+        statedata->starve = 0;
+        statedata->challengeuses = 0;
+        statedata->renewed = 0;
+        xfree(statedata->challenge);
+        statedata->challenge = NULL;
     }
 }
 
@@ -832,22 +954,28 @@ authenticateNTLMOnCloseConnection(ConnStateData * conn)
 {
     ntlm_request_t *ntlm_request;
     assert(conn != NULL);
+
     if (conn->auth_user_request != NULL) {
-	assert(conn->auth_user_request->scheme_data != NULL);
-	ntlm_request = static_cast< ntlm_request_t *>(conn->auth_user_request->scheme_data);
-	assert(ntlm_request->conn == conn);
-	if (ntlm_request->authserver != NULL && ntlm_request->authserver_deferred)
-	    authenticateNTLMReleaseServer(conn->auth_user_request);
-	/* unlock the connection based lock */
-	debug(29, 9) ("authenticateNTLMOnCloseConnection: Unlocking auth_user from the connection.\n");
-	/* This still breaks the abstraction, but is at least read only now */
-	/* Ensure that the auth user request will be getting closed */
-	/* IFF we start persisting the struct after the conn closes - say for logging
-	 * then this test may become invalid
-	 */
-	assert(authenticateRequestRefCount(conn->auth_user_request) == 1);
-	authenticateAuthUserRequestUnlock(conn->auth_user_request);
-	conn->auth_user_request = NULL;
+        assert(conn->auth_user_request->scheme_data != NULL);
+        ntlm_request = static_cast< ntlm_request_t *>(conn->auth_user_request->scheme_data);
+        assert(ntlm_request->conn == conn);
+
+        if (ntlm_request->authserver != NULL && ntlm_request->authserver_deferred)
+            authenticateNTLMReleaseServer(conn->auth_user_request);
+
+        /* unlock the connection based lock */
+        debug(29, 9) ("authenticateNTLMOnCloseConnection: Unlocking auth_user from the connection.\n");
+
+        /* This still breaks the abstraction, but is at least read only now */
+        /* Ensure that the auth user request will be getting closed */
+        /* IFF we start persisting the struct after the conn closes - say for logging
+         * then this test may become invalid
+         */
+        assert(authenticateRequestRefCount(conn->auth_user_request) == 1);
+
+        authenticateAuthUserRequestUnlock(conn->auth_user_request);
+
+        conn->auth_user_request = NULL;
     }
 }
 
@@ -856,8 +984,10 @@ static const char *
 authenticateNTLMUsername(auth_user_t const * auth_user)
 {
     ntlm_user_t *ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
+
     if (ntlm_user)
-	return ntlm_user->username;
+        return ntlm_user->username;
+
     return NULL;
 }
 
@@ -913,17 +1043,22 @@ authenticateNTLMcmpUsername(ntlm_user_t * u1, ntlm_user_t * u2)
 static void
 authenticateProxyAuthCacheAddLink(const char *key, auth_user_t * auth_user)
 {
+
     struct ProxyAuthCachePointer *proxy_auth_hash;
     dlink_node *node;
     ntlm_user_t *ntlm_user;
     ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
     node = ntlm_user->proxy_auth_list.head;
     /* prevent duplicates */
+
     while (node) {
-	if (!strcmp(key, (char const *)((struct ProxyAuthCachePointer *) node->data)->key))
-	    return;
-	node = node->next;
+
+        if (!strcmp(key, (char const *)((struct ProxyAuthCachePointer *) node->data)->key))
+            return;
+
+        node = node->next;
     }
+
     proxy_auth_hash = static_cast<ProxyAuthCachePointer *>(memPoolAlloc(ntlm_user_hash_pool));
     proxy_auth_hash->key = xstrdup(key);
     proxy_auth_hash->auth_user = auth_user;
@@ -936,16 +1071,20 @@ static int
 authNTLMAuthenticated(auth_user_request_t * auth_user_request)
 {
     ntlm_request_t *ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
+
     if (ntlm_request->auth_state == AUTHENTICATE_STATE_DONE)
-	return 1;
+        return 1;
+
     debug(29, 9) ("User not fully authenticated.\n");
+
     return 0;
 }
 
 static void
 authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, request_t * request, ConnStateData * conn, http_hdr_type type)
 {
     const char *proxy_auth;
+
     struct ProxyAuthCachePointer *proxy_auth_hash = NULL;
     auth_user_hash_pointer *usernamehash;
     auth_user_t *auth_user;
@@ -964,126 +1103,145 @@ authenticateNTLMAuthenticateUser(auth_user_request_t * auth_user_request, reques
     ntlm_request = static_cast< ntlm_request_t *>(auth_user_request->scheme_data);
     /* Check that we are in the client side, where we can generate
      * auth challenges */
+
     if (!conn) {
-	ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
-	debug(29, 1) ("authenticateNTLMAuthenticateUser: attempt to perform authentication without a connection!\n");
-	return;
+        ntlm_request->auth_state = AUTHENTICATE_STATE_FAILED;
+        debug(29, 1) ("authenticateNTLMAuthenticateUser: attempt to perform authentication without a connection!\n");
+        return;
     }
-    
+
     switch (ntlm_request->auth_state) {
+
     case AUTHENTICATE_STATE_NONE:
-	/* we've recieved a negotiate request. pass to a helper */
-	debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state ntlm none. %s\n", proxy_auth);
-	ntlm_request->auth_state = AUTHENTICATE_STATE_NEGOTIATE;
-	ntlm_request->ntlmnegotiate = xstrndup(proxy_auth, NTLM_CHALLENGE_SZ + 5);
-	conn->auth_type = AUTH_NTLM;
-	conn->auth_user_request = auth_user_request;
-	ntlm_request->conn = conn;
-	/* and lock for the connection duration */
-	debug(29, 9) ("authenticateNTLMAuthenticateUser: Locking auth_user from the connection.\n");
-	authenticateAuthUserRequestLock(auth_user_request);
-	return;
-	break;
+        /* we've recieved a negotiate request. pass to a helper */
+        debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state ntlm none. %s\n", proxy_auth);
+        ntlm_request->auth_state = AUTHENTICATE_STATE_NEGOTIATE;
+        ntlm_request->ntlmnegotiate = xstrndup(proxy_auth, NTLM_CHALLENGE_SZ + 5);
+        conn->auth_type = AUTH_NTLM;
+        conn->auth_user_request = auth_user_request;
+        ntlm_request->conn = conn;
+        /* and lock for the connection duration */
+        debug(29, 9) ("authenticateNTLMAuthenticateUser: Locking auth_user from the connection.\n");
+        authenticateAuthUserRequestLock(auth_user_request);
+        return;
+        break;
+
     case AUTHENTICATE_STATE_NEGOTIATE:
-	ntlm_request->auth_state = AUTHENTICATE_STATE_CHALLENGE;
-	/* We _MUST_ have the auth challenge by now */
-	assert(ntlm_request->authchallenge);
-	return;
-	break;
+        ntlm_request->auth_state = AUTHENTICATE_STATE_CHALLENGE;
+        /* We _MUST_ have the auth challenge by now */
+        assert(ntlm_request->authchallenge);
+        return;
+        break;
+
     case AUTHENTICATE_STATE_CHALLENGE:
-	/* we should have recieved a NTLM challenge. pass it to the same 
-	 * helper process */
-	debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state challenge with header %s.\n", proxy_auth);
-	/* do a cache lookup here. If it matches it's a successful ntlm 
-	 * challenge - release the helper and use the existing auth_user 
-	 * details. */
-	if (strncmp("NTLM ", proxy_auth, 5) == 0) {
-	    ntlm_request->ntlmauthenticate = xstrdup(proxy_auth);
-	} else {
-	    fatal("Incorrect scheme in auth header\n");
-	    /* TODO: more fault tolerance.. reset the auth scheme here */
-	}
-	/* cache entries have authenticateauthheaderchallengestring */
-	snprintf(ntlmhash, sizeof(ntlmhash) - 1, "%s%s",
-	    ntlm_request->ntlmauthenticate,
-	    ntlm_request->authchallenge);
-	/* see if we already know this user's authenticate */
-	debug(29, 9) ("aclMatchProxyAuth: cache lookup with key '%s'\n", ntlmhash);
-	assert(proxy_auth_cache != NULL);
-	proxy_auth_hash = static_cast<ProxyAuthCachePointer *>(hash_lookup(proxy_auth_cache, ntlmhash));
-	if (!proxy_auth_hash) {	/* not in the hash table */
-	    debug(29, 4) ("authenticateNTLMAuthenticateUser: proxy-auth cache miss.\n");
-	    ntlm_request->auth_state = AUTHENTICATE_STATE_RESPONSE;
-	    /* verify with the ntlm helper */
-	} else {
-	    debug(29, 4) ("authenticateNTLMAuthenticateUser: ntlm proxy-auth cache hit\n");
-	    /* throw away the temporary entry */
-	    ntlm_request->authserver_deferred = 0;
-	    authenticateNTLMReleaseServer(auth_user_request);
-	    authenticateAuthUserMerge(auth_user, proxy_auth_hash->auth_user);
-	    auth_user = proxy_auth_hash->auth_user;
-	    auth_user_request->auth_user = auth_user;
-	    ntlm_request->auth_state = AUTHENTICATE_STATE_DONE;
-	    /* we found one */
-	    debug(29, 9) ("found matching cache entry\n");
-	    assert(auth_user->auth_type == AUTH_NTLM);
-	    /* get the existing entries details */
-	    ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
-	    debug(29, 9) ("Username to be used is %s\n", ntlm_user->username);
-	    /* on ntlm auth we do not unlock the auth_user until the
-	     * connection is dropped. Thank MS for this quirk */
-	    auth_user->expiretime = current_time.tv_sec;
-	}
-	return;
-	break;
+        /* we should have recieved a NTLM challenge. pass it to the same
+         * helper process */
+        debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state challenge with header %s.\n", proxy_auth);
+        /* do a cache lookup here. If it matches it's a successful ntlm
+         * challenge - release the helper and use the existing auth_user 
+         * details. */
+
+        if (strncmp("NTLM ", proxy_auth, 5) == 0) {
+            ntlm_request->ntlmauthenticate = xstrdup(proxy_auth);
+        } else {
+            fatal("Incorrect scheme in auth header\n");
+            /* TODO: more fault tolerance.. reset the auth scheme here */
+        }
+
+        /* cache entries have authenticateauthheaderchallengestring */
+        snprintf(ntlmhash, sizeof(ntlmhash) - 1, "%s%s",
+                 ntlm_request->ntlmauthenticate,
+                 ntlm_request->authchallenge);
+
+        /* see if we already know this user's authenticate */
+        debug(29, 9) ("aclMatchProxyAuth: cache lookup with key '%s'\n", ntlmhash);
+
+        assert(proxy_auth_cache != NULL);
+
+        proxy_auth_hash = static_cast<ProxyAuthCachePointer *>(hash_lookup(proxy_auth_cache, ntlmhash));
+
+        if (!proxy_auth_hash) {	/* not in the hash table */
+            debug(29, 4) ("authenticateNTLMAuthenticateUser: proxy-auth cache miss.\n");
+            ntlm_request->auth_state = AUTHENTICATE_STATE_RESPONSE;
+            /* verify with the ntlm helper */
+        } else {
+            debug(29, 4) ("authenticateNTLMAuthenticateUser: ntlm proxy-auth cache hit\n");
+            /* throw away the temporary entry */
+            ntlm_request->authserver_deferred = 0;
+            authenticateNTLMReleaseServer(auth_user_request);
+            authenticateAuthUserMerge(auth_user, proxy_auth_hash->auth_user);
+            auth_user = proxy_auth_hash->auth_user;
+            auth_user_request->auth_user = auth_user;
+            ntlm_request->auth_state = AUTHENTICATE_STATE_DONE;
+            /* we found one */
+            debug(29, 9) ("found matching cache entry\n");
+            assert(auth_user->auth_type == AUTH_NTLM);
+            /* get the existing entries details */
+            ntlm_user = static_cast<ntlm_user_t *>(auth_user->scheme_data);
+            debug(29, 9) ("Username to be used is %s\n", ntlm_user->username);
+            /* on ntlm auth we do not unlock the auth_user until the
+             * connection is dropped. Thank MS for this quirk */
+            auth_user->expiretime = current_time.tv_sec;
+        }
+
+        return;
+        break;
+
     case AUTHENTICATE_STATE_RESPONSE:
-	/* auth-challenge pair cache miss. We've just got the response from the helper */
-	/*add to cache and let them through */
-	ntlm_request->auth_state = AUTHENTICATE_STATE_DONE;
-	/* this connection is authenticated */
-	debug(29, 4) ("authenticated\nch    %s\nauth     %s\nauthuser %s\n",
-	    ntlm_request->authchallenge,
-	    ntlm_request->ntlmauthenticate,
-	    ntlm_user->username);
-	/* cache entries have authenticateauthheaderchallengestring */
-	snprintf(ntlmhash, sizeof(ntlmhash) - 1, "%s%s",
-	    ntlm_request->ntlmauthenticate,
-	    ntlm_request->authchallenge);
-	/* see if this is an existing user with a different proxy_auth 
-	 * string */
-	if ((usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, ntlm_user->username)))) {
-	    while ((authUserHashPointerUser(usernamehash)->auth_type != auth_user->auth_type) && (usernamehash->next) && !authenticateNTLMcmpUsername(static_cast<ntlm_user_t *>(authUserHashPointerUser(usernamehash)->scheme_data), ntlm_user))
-		usernamehash = static_cast<AuthUserHashPointer*>(usernamehash->next);
-	    if (authUserHashPointerUser(usernamehash)->auth_type == auth_user->auth_type) {
-		/*
-		 * add another link from the new proxy_auth to the
-		 * auth_user structure and update the information */
-		assert(proxy_auth_hash == NULL);
-		authenticateProxyAuthCacheAddLink(ntlmhash, authUserHashPointerUser(usernamehash));
-		/* we can't seamlessly recheck the username due to the 
-		 * challenge nature of the protocol. Just free the 
-		 * temporary auth_user */
-		authenticateAuthUserMerge(auth_user, authUserHashPointerUser(usernamehash));
-		auth_user = authUserHashPointerUser(usernamehash);
-		auth_user_request->auth_user = auth_user;
-	    }
-	} else {
-	    /* store user in hash's */
-	    authenticateUserNameCacheAdd(auth_user);
-	    authenticateProxyAuthCacheAddLink(ntlmhash, auth_user);
-	}
-	/* set these to now because this is either a new login from an 
-	 * existing user or a new user */
-	auth_user->expiretime = current_time.tv_sec;
-	return;
-	break;
+        /* auth-challenge pair cache miss. We've just got the response from the helper */
+        /*add to cache and let them through */
+        ntlm_request->auth_state = AUTHENTICATE_STATE_DONE;
+        /* this connection is authenticated */
+        debug(29, 4) ("authenticated\nch    %s\nauth     %s\nauthuser %s\n",
+                      ntlm_request->authchallenge,
+                      ntlm_request->ntlmauthenticate,
+                      ntlm_user->username);
+        /* cache entries have authenticateauthheaderchallengestring */
+        snprintf(ntlmhash, sizeof(ntlmhash) - 1, "%s%s",
+                 ntlm_request->ntlmauthenticate,
+                 ntlm_request->authchallenge);
+        /* see if this is an existing user with a different proxy_auth
+         * string */
+
+        if ((usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, ntlm_user->username)))
+           ) {
+            while ((authUserHashPointerUser(usernamehash)->auth_type != auth_user->auth_type) && (usernamehash->next) && !authenticateNTLMcmpUsername(static_cast<ntlm_user_t *>(authUserHashPointerUser(usernamehash)->scheme_data), ntlm_user)
+                  )
+                usernamehash = static_cast<AuthUserHashPointer*>(usernamehash->next);
+            if (authUserHashPointerUser(usernamehash)->auth_type == auth_user->auth_type) {
+                /*
+                 * add another link from the new proxy_auth to the
+                 * auth_user structure and update the information */
+                assert(proxy_auth_hash == NULL);
+                authenticateProxyAuthCacheAddLink(ntlmhash, authUserHashPointerUser(usernamehash));
+                /* we can't seamlessly recheck the username due to the
+                 * challenge nature of the protocol. Just free the 
+                 * temporary auth_user */
+                authenticateAuthUserMerge(auth_user, authUserHashPointerUser(usernamehash));
+                auth_user = authUserHashPointerUser(usernamehash);
+                auth_user_request->auth_user = auth_user;
+            }
+        } else {
+            /* store user in hash's */
+            authenticateUserNameCacheAdd(auth_user);
+            authenticateProxyAuthCacheAddLink(ntlmhash, auth_user);
+        }
+
+        /* set these to now because this is either a new login from an
+         * existing user or a new user */
+        auth_user->expiretime = current_time.tv_sec;
+        return;
+        break;
+
     case AUTHENTICATE_STATE_DONE:
-	fatal("authenticateNTLMAuthenticateUser: unexpect auth state DONE! Report a bug to the squid developers.\n");
-	break;
+        fatal("authenticateNTLMAuthenticateUser: unexpect auth state DONE! Report a bug to the squid developers.\n");
+        break;
+
     case AUTHENTICATE_STATE_FAILED:
-	/* we've failed somewhere in authentication */
-	debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state ntlm failed. %s\n", proxy_auth);
-	return;
+        /* we've failed somewhere in authentication */
+        debug(29, 9) ("authenticateNTLMAuthenticateUser: auth state ntlm failed. %s\n", proxy_auth);
+        return;
     }
+
     return;
 }
@@ -18,19 +18,25 @@ typedef enum {
 } auth_state_t;                 /* connection level auth state */
 
 /* Generic */
-typedef struct {
+
+typedef struct
+{
     void *data;
     auth_user_request_t *auth_user_request;
     RH *handler;
-} authenticateStateData;
+}
+
+authenticateStateData;
 
-struct _ntlm_user {
+struct _ntlm_user
+{
     /* what username did this connection get? */
     char *username;
     dlink_list proxy_auth_list;
 };
 
-struct _ntlm_request {
+struct _ntlm_request
+{
     /* what negotiate string did the client use? */
     char *ntlmnegotiate;
     /* what challenge did we give the client? */
@@ -47,30 +53,37 @@ struct _ntlm_request {
     ConnStateData *conn;
 };
 
-struct _ntlm_helper_state_t {
+struct _ntlm_helper_state_t
+{
     char *challenge;		/* the challenge to use with this helper */
     int starve;			/* 0= normal operation. 1=don't hand out any more challenges */
     int challengeuses;		/* the number of times this challenge has been issued */
     time_t renewed;
 };
 
 /* configuration runtime data */
-struct _auth_ntlm_config {
+
+struct _auth_ntlm_config
+{
     int authenticateChildren;
     wordlist *authenticate;
     int challengeuses;
     time_t challengelifetime;
 };
 
-struct ProxyAuthCachePointer : public hash_link {
+struct ProxyAuthCachePointer : public hash_link
+{
     dlink_node link;
     /* other hash entries that point to the same auth_user */
     auth_user_t *auth_user;
 };
 
 typedef struct _ntlm_user ntlm_user_t;
+
 typedef struct _ntlm_request ntlm_request_t;
+
 typedef struct _ntlm_helper_state_t ntlm_helper_state_t;
+
 typedef struct _auth_ntlm_config auth_ntlm_config;
 
 #endif