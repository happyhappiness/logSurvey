@@ -1787,12 +1787,6 @@ lib/getopt.c:
 
 ==============================================================================
 
-lib/drand48.c:
-
-From Linux libc-5.4.46.
-
-==============================================================================
-
 lib/radix.c:
 
  *  Adapted from HTSUtils.c in CERN httpd 3.0 (http://info.cern.ch/httpd/)
@@ -1,3 +1,37 @@
+Changes to squid-3.5.6 (03 Jul 2015):
+
+	- Bug 4274: ssl_crtd.8 not being installed
+	- Bug 4193: memory leak on FTP listings
+	- Bug 4183: segfault when freeing https_port clientca on reconfigure or exit
+	- Bug 3875: bad mimeLoadIconFile error handling
+	- Bug 3483: assertion failed store.cc:1866: 'isEmpty()'
+	- Bug 3329: pinned server connection is not closed properly
+	- TLS: Disable client-initiated renegotiation
+	- ext_edirectory_userip_acl: fix uninitialized variable
+	- Support custom OIDs in *_cert ACLs
+	- Fix CONNECT failover to IPv4 after trying broken IPv6 servers
+	- Use relative-URL in errorpage.css for SN.png
+	- Do not blindly forward cache peer CONNECT responses
+	- Fix assertion String.cc:221: "str"
+	- Fix assertion comm.cc:759: "Comm::IsConnOpen(conn)" in ConnStateData::getSslContextDone
+	- Translations: add Spanish US dialect alias
+
+Changes to squid-3.5.5 (28 May 2015):
+
+	- Regression Bug 4132: short_icon_urls with global_internal_static on
+	- Bug 4238: assertion Read.cc:205: "params.data == data"
+	- Bug 4236: SSL negotiation error of 'success'
+	- Bug 3930: assertion 'connIsUsable(http->getConn())'
+	- Fix assertion MemBuf.cc:380: "new_cap > (size_t) capacity" in SSL I/O buffer
+	- Fix assertion errorpage.cc:600: "entry->isEmpty()"
+	- Fix comm_connect_addr on failures returns Comm:OK
+	- Fix missing external ACL helper notes
+	- Fix "Not enough space to hold server hello message" error message
+	- Fix segmentation fault inside Adaptation::Icap::Xaction::swanSong
+	- Prevent unused ssl_crtd helpers being run
+	- ... and some code cleanup and portability updates
+	- ... and several documentation updates
+
 Changes to squid-3.5.4 (01 May 2015):
 
 	- Bug 4234: comm_connect_addr uses errno incorrectly
@@ -17,8 +17,8 @@ AC_DEFUN([AX_CXX_TYPE_NULLPTR],[
     AC_MSG_RESULT(yes)], [
     HAVE_NULLPTR=no
     AC_MSG_RESULT(no)])
-  if test "x$HAVE_NULLPTR" = xyes; then
-    AC_DEFINE(HAVE_NULLPTR, 1, [Define to 1 if nullptr is supported])
+  if test "x$HAVE_NULLPTR" = xno; then
+    AC_DEFINE(nullptr, NULL, [Leave undefined if nullptr is supported])
   fi
   AC_MSG_CHECKING([whether nullptr_t is supported])
   AC_TRY_COMPILE([#include <cstddef>],[typedef nullptr_t peng;], [
@@ -42,8 +42,36 @@ AC_DEFUN([AX_CXX_TYPE_UNIQUE_PTR],[
     AC_MSG_RESULT(yes)], [
     HAVE_UNIQUE_PTR=no
     AC_MSG_RESULT(no)])
+  if test "x$HAVE_UNIQUE_PTR" = xno; then
+    AC_DEFINE(unique_ptr, auto_ptr, [Leave undefined if std::unique_ptr<T> is supported])
+  fi
   if test "x$HAVE_UNIQUE_PTR" = xyes; then
     AC_DEFINE(HAVE_UNIQUE_PTR, 1, [Define to 1 if std::unique_ptr<T> is supported])
   fi
   AC_LANG_POP
 ])
+
+## Hand crafted for Squid under GPL version 2
+AC_DEFUN([AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS],[
+  AC_REQUIRE([AC_PROG_CXX])
+  AC_LANG_PUSH([C++])
+  AC_MSG_CHECKING([whether std::uniform_int_distribution<T> is supported])
+  AC_TRY_COMPILE([#include <random>],[std::uniform_int_distribution<int> c;], [
+    HAVE_UNIFORM_INT_DISTRIBUTION=yes
+    AC_MSG_RESULT(yes)], [
+    HAVE_UNIFORM_INT_DISTRIBUTION=no
+    AC_MSG_RESULT(no)])
+  if test "x$HAVE_UNIFORM_INT_DISTRIBUTION" = xno; then
+    AC_DEFINE(uniform_int_distributon, tr1::uniform_int, [Leave undefined if std::uniform_int_distribution<T> is supported])
+  fi
+  AC_MSG_CHECKING([whether std::uniform_real_distribution<T> is supported])
+  AC_TRY_COMPILE([#include <random>],[std::uniform_real_distribution<double> c;], [
+    HAVE_UNIFORM_REAL_DISTRIBUTION=yes
+    AC_MSG_RESULT(yes)], [
+    HAVE_UNIFORM_REAL_DISTRIBUTION=no
+    AC_MSG_RESULT(no)])
+  if test "x$HAVE_UNIFORM_REAL_DISTRIBUTION" = xno; then
+    AC_DEFINE(uniform_real_distributon, tr1::uniform_real, [Leave undefined if std::uniform_real_distribution<T> is supported])
+  fi
+  AC_LANG_POP
+])
@@ -28,7 +28,6 @@ libcompat_squid_la_SOURCES = \
 	cppunit.h \
 	debug.cc \
 	debug.h \
-	drand48.h \
 	eui64_aton.h \
 	eui64_aton.c \
 	fdsetsize.h \
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#include "squid.h"
-
-/* borrowed from libc/misc/drand48.c in Linux libc-5.4.46 this quick
- * hack by Martin Hamilton <martinh@gnu.org> to make Squid build on
- * Win32 with GNU-Win32 - sorry, folks! */
-
-#if !HAVE_DRAND48
-
-#define N   16
-#define MASK    ((unsigned)(1 << (N - 1)) + (1 << (N - 1)) - 1)
-#define LOW(x)  ((unsigned)(x) & MASK)
-#define HIGH(x) LOW((x) >> N)
-#define MUL(x, y, z)    { long l = (long)(x) * (long)(y); \
-        (z)[0] = LOW(l); (z)[1] = HIGH(l); }
-#define CARRY(x, y) ((long)(x) + (long)(y) > MASK)
-#define ADDEQU(x, y, z) (z = CARRY(x, (y)), x = LOW(x + (y)))
-#define X0  0x330E
-#define X1  0xABCD
-#define X2  0x1234
-#define A0  0xE66D
-#define A1  0xDEEC
-#define A2  0x5
-#define C   0xB
-
-static void next(void);
-static unsigned x[3] = {X0, X1, X2}, a[3] = {A0, A1, A2}, c = C;
-
-double drand48(void);
-
-double
-drand48(void)
-{
-    static double two16m = 1.0 / (1L << N);
-    next();
-    return (two16m * (two16m * (two16m * x[0] + x[1]) + x[2]));
-}
-
-static void
-next(void)
-{
-    unsigned p[2], q[2], r[2], carry0, carry1;
-
-    MUL(a[0], x[0], p);
-    ADDEQU(p[0], c, carry0);
-    ADDEQU(p[1], carry0, carry1);
-    MUL(a[0], x[1], q);
-    ADDEQU(p[1], q[0], carry0);
-    MUL(a[1], x[0], r);
-    x[2] = LOW(carry0 + carry1 + CARRY(p[1], r[0]) + q[1] + r[1] +
-               a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
-    x[1] = LOW(p[1] + r[0]);
-    x[0] = LOW(p[0]);
-}
-
-#endif /* HAVE_DRAND48 */
-
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef _SQUID_DRAND48_H
-#define _SQUID_DRAND48_H
-
-#if !HAVE_DRAND48
-#define HAVE_DRAND48 1
-SQUIDCEXTERN double drand48(void);
-#endif
-
-#endif
-
@@ -157,12 +157,8 @@ typedef long mtyp_t;
 #endif
 
 #ifndef NULL
-#if defined(__cplusplus) && HAVE_NULLPTR
-#define NULL nullptr
-#else
 #define NULL 0
 #endif
-#endif
 
 #endif /* SQUID_TYPES_H */
 
@@ -55,7 +55,7 @@ AC_ARG_ENABLE(arch-native,
   SQUID_YESNO([$enableval],
     [Unrecognized argument to --disable-arch-native: $enableval])
 ])
-AC_MSG_NOTICE([CPU -march=native optimization enabled: ${enable_arch_native:=auto}])
+AC_MSG_NOTICE([CPU arch native optimization enabled: ${enable_arch_native:=auto}])
 if test "x${enable_arch_native}" != "xno"; then
   SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
 fi
@@ -93,7 +93,7 @@ if test "x$squid_host_os" = "solaris" -a "x$GCC" != "x" ; then
 fi
 
 # Check for C++11 compiler support
-AX_CXX_COMPILE_STDCXX_11([noext],[optional])
+AX_CXX_COMPILE_STDCXX_11([noext],[mandatory])
 
 # test for programs
 AC_PROG_RANLIB
@@ -419,40 +419,6 @@ SQUID_DEFINE_BOOL(_USE_INLINE_,$enable_inline,
 # to be used by sub-commands
 export enable_inline
 
-# Check for atomic operations support in the compiler
-AC_CACHE_CHECK([for GNU atomic operations support],[squid_cv_gnu_atomics],[
-AC_RUN_IFELSE([AC_LANG_PROGRAM([[
-#include <cstdint>
-    int32_t n_32 = 0;
-    uint64_t n_64 = 0;
-]],[[
-    // 32-bit
-    __sync_add_and_fetch(&n_32, 10); // n becomes 10
-    __sync_fetch_and_add(&n_32, 20); // n becomes 30
-    __sync_sub_and_fetch(&n_32, 15); // n becomes 15
-    __sync_bool_compare_and_swap(&n_32, 15, 201); // n becomes 201
-    __sync_fetch_and_and(&n_32, 200); // n becomes 200
-    if (n_32 != 200) return -1;
-
-    // 64-bit
-    __sync_add_and_fetch(&n_64, 10); // n becomes 10
-    __sync_fetch_and_add(&n_64, 20); // n becomes 30
-    __sync_sub_and_fetch(&n_64, 15); // n becomes 15
-    __sync_bool_compare_and_swap(&n_64, 15, 201); // n becomes 201
-    __sync_fetch_and_and(&n_64, 200); // n becomes 200
-    if (n_64 != 200) return -1;
-
-    // seems to be okay.
-    return 0;
-]])],
-[
-	squid_cv_gnu_atomics=yes
-],[
-	squid_cv_gnu_atomics=no
-])
-])
-SQUID_DEFINE_BOOL(HAVE_ATOMIC_OPS,${squid_cv_gnu_atomics:=yes},[Define to 1 if you have GCC __sync_add_and_fetch() and such])
-
 AC_ARG_ENABLE(debug-cbdata,
   AS_HELP_STRING([--enable-debug-cbdata],
       [Provide some debug information in cbdata]), [ 
@@ -554,18 +520,20 @@ SQUID_DEFINE_BOOL(USE_DISKIO,$squid_opt_enable_diskio,
 dnl Some autoconf.h defines we might enable later...
 AC_ARG_WITH(pthreads,AS_HELP_STRING([--without-pthreads],[Disable POSIX Threads]))
 AC_ARG_WITH(aio, AS_HELP_STRING([--without-aio],[Do not use POSIX AIO. Default: auto-detect]))
-AH_TEMPLATE(USE_DISKIO_AIO, [Whether POSIX AIO support is needed. Automatic])
-AH_TEMPLATE(USE_DISKIO_DISKTHREADS, [Whether pthreads support is needed. Automatic])
 ENABLE_WIN32_AIOPS=0
 squid_opt_use_aio=
 squid_opt_use_diskthreads=
 AIOLIB=
 
 dnl Setup the module paths etc.
 DISK_LIBS=
-DISK_OS_LIBS=
 DISK_MODULES=
 DISK_LINKOBJS=
+AH_TEMPLATE(HAVE_DISKIO_MODULE_AIO, [Whether POSIX AIO Disk I/O module is built])
+AH_TEMPLATE(HAVE_DISKIO_MODULE_BLOCKING, [Whether Blocking Disk I/O module is built])
+AH_TEMPLATE(HAVE_DISKIO_MODULE_DISKDAEMON, [Whether DiskDaemon Disk I/O module is built])
+AH_TEMPLATE(HAVE_DISKIO_MODULE_IPCIO, [Whether IpcIo Disk I/O module is built])
+AH_TEMPLATE(HAVE_DISKIO_MODULE_MMAPPED, [Whether Mmapped Disk I/O module is built])
 for module in $squid_disk_module_candidates none; do
   # maybe not needed
   if test "x$module" = "xnone"; then
@@ -575,20 +543,79 @@ for module in $squid_disk_module_candidates none; do
     AC_MSG_ERROR(disk-io $module does not exist)
   fi
   case "$module" in
+
+    AIO)
+      dnl Check for POSIX AIO availability
+      squid_opt_use_aio="yes"
+      AIOLIB=
+      if test "x$with_aio" != "xno"; then
+        have_aio_header=no
+        AC_CHECK_HEADERS(aio.h,[have_aio_header=yes])
+        dnl On some systems POSIX AIO functions are in librt
+        dnl On some systems POSIX AIO functions are in libaio
+        AC_CHECK_LIB(rt,aio_read,[AIOLIB="-lrt"],AC_CHECK_LIB(aio,aio_read,[AIOLIB="-laio"],[]))
+        dnl Enable AIO if the library and headers are found
+        if test "x$AIOLIB" != "x" && test "x$have_aio_header" = "xyes"; then
+          AC_MSG_NOTICE([Native POSIX AIO support detected.])
+          squid_opt_use_aio="yes"
+        else
+          dnl Windows does things differently. We provide wrappers.
+          dnl TODO: Windows really needs its own DiskIO module or its Overlaped IO
+          case "$squid_host_os" in
+            mingw)
+              squid_opt_use_aio="yes"
+              AC_MSG_NOTICE([Windows being built. Maybe-enable POSIX AIO.])
+              ;;
+            *)
+              AC_MSG_NOTICE([Native POSIX AIO support not detected. AIO automatically disabled.])
+              squid_opt_use_aio="no"
+              ;;
+          esac
+        fi
+      else
+        AC_MSG_NOTICE([POSIX AIO support manually disabled.])
+        squid_opt_use_aio="no"
+      fi
+      dnl Use the POSIX AIO pieces if we actually need them.
+      if test "x$squid_opt_use_aio" = "xyes" ; then
+        DISK_MODULES="$DISK_MODULES AIO"
+        DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/AIO/AIODiskIOModule.o"
+        AC_DEFINE([HAVE_DISKIO_MODULE_AIO],1,[POSIX AIO Disk I/O module is built])
+        case "$squid_host_os" in
+          mingw)
+            ENABLE_WIN32_AIO=1
+            AC_MSG_NOTICE([Replacing AIO DiskIO module with: Windows overlapped I/O support])
+            ;;
+          *)
+            AC_MSG_NOTICE([Enabling AIO DiskIO module])
+            ;;
+        esac
+      else
+        AC_MSG_NOTICE([AIO DiskIO Module disabled. Missing POSIX AIO support.])
+      fi
+      ;;
+
+    Blocking)
+      AC_MSG_NOTICE([Enabling Blocking DiskIO module])
+      DISK_MODULES="$DISK_MODULES Blocking"
+      DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/Blocking/BlockingDiskIOModule.o"
+      AC_DEFINE([HAVE_DISKIO_MODULE_BLOCKING],1,[Blocking Disk I/O module is built])
+      ;;
+
     DiskDaemon)
       case "$squid_host_os" in
         mingw)
           AC_MSG_NOTICE(["DiskDaemon not supported on MinGW"])
           ;;
         *)
           AC_MSG_NOTICE([Enabling DiskDaemon DiskIO module])
-          DISK_LIBS="$DISK_LIBS libDiskDaemon.a"
           DISK_MODULES="$DISK_MODULES DiskDaemon"
-          DISK_PROGRAMS="$DISK_PROGRAMS DiskIO/DiskDaemon/diskd"
           DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/DiskDaemon/DiskDaemonDiskIOModule.o"
+          AC_DEFINE([HAVE_DISKIO_MODULE_DISKDAEMON],1,[DiskDaemon Disk I/O module is built])
           ;;
         esac
       ;;
+
     DiskThreads)
       squid_opt_use_diskthreads="yes"
       LIBPTHREADS=
@@ -658,71 +685,24 @@ for module in $squid_disk_module_candidates none; do
           squid_opt_use_diskthreads="no"
         fi
         if test "x$squid_opt_use_diskthreads" = "xyes" ; then
-          AC_DEFINE(USE_DISKIO_DISKTHREADS, 1, [Whether pthreads support is needed. Automatic])
           AC_MSG_NOTICE([Enabling DiskThreads DiskIO module])
-          DISK_LIBS="$DISK_LIBS libDiskThreads.a"
-          DISK_OS_LIBS="$DISK_OS_LIBS $LIBPTHREADS"
           DISK_MODULES="$DISK_MODULES DiskThreads"
           DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/DiskThreads/DiskThreadsDiskIOModule.o"
+          AC_DEFINE([HAVE_DISKIO_MODULE_DISKTHREADS],1,[DiskThreads Disk I/O module is built])
         else
-          AC_DEFINE(USE_DISKIO_DISKTHREADS, 0, [Whether pthreads support is needed. Automatic])
           AC_MSG_NOTICE([Native pthreads support disabled. DiskThreads module automaticaly disabled.])
           SQUID_STATE_ROLLBACK([diskthreads_state])
         fi
       ;;
 
-    AIO)
-      dnl Check for POSIX AIO availability
-      squid_opt_use_aio="yes"
-      AIOLIB=
-      if test "x$with_aio" != "xno"; then
-        have_aio_header=no
-        AC_CHECK_HEADERS(aio.h,[have_aio_header=yes])
-        dnl On some systems POSIX AIO functions are in librt
-        dnl On some systems POSIX AIO functions are in libaio
-        AC_CHECK_LIB(rt,aio_read,[AIOLIB="-lrt"],AC_CHECK_LIB(aio,aio_read,[AIOLIB="-laio"],[]))
-        dnl Enable AIO if the library and headers are found
-        if test "x$AIOLIB" != "x" && test "x$have_aio_header" = "xyes"; then
-          AC_MSG_NOTICE([Native POSIX AIO support detected.])
-          squid_opt_use_aio="yes"
-        else
-          dnl Windows does things differently. We provide wrappers.
-          dnl TODO: Windows really needs its own DiskIO module or its Overlaped IO
-          case "$squid_host_os" in
-            mingw)
-              squid_opt_use_aio="yes"
-              AC_MSG_NOTICE([Windows being built. Maybe-enable POSIX AIO.])
-              ;;
-            *)
-              AC_MSG_NOTICE([Native POSIX AIO support not detected. AIO automatically disabled.])
-              squid_opt_use_aio="no"
-              ;;
-          esac
-        fi
-      else
-        AC_MSG_NOTICE([POSIX AIO support manually disabled.])
-        squid_opt_use_aio="no"
-      fi
-      dnl Use the POSIX AIO pieces if we actually need them.
-      if test "x$squid_opt_use_aio" = "xyes" ; then
-        AC_DEFINE(USE_DISKIO_AIO, 1, [Whether POSIX AIO support is needed. Automatic])
-        DISK_MODULES="$DISK_MODULES AIO"
-        DISK_LIBS="$DISK_LIBS libAIO.a"
-        DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/AIO/AIODiskIOModule.o"
-        case "$squid_host_os" in
-          mingw)
-            ENABLE_WIN32_AIO=1
-            AC_MSG_NOTICE([Replacing AIO DiskIO module with: Windows overlapped I/O support])
-            ;;
-          *)
-            AC_MSG_NOTICE([Enabling AIO DiskIO module])
-            DISK_OS_LIBS="$DISK_OS_LIBS $AIOLIB"
-            ;;
-        esac
-      else
-        AC_DEFINE(USE_DISKIO_AIO, 0, [Whether POSIX AIO support is needed. Automatic])
-        AC_MSG_NOTICE([AIO DiskIO Module disabled. Missing POSIX AIO support.])
+    IpcIo)
+      AC_MSG_NOTICE([Enabling IpcIo DiskIO module])
+      if test "x$ac_cv_search_shm_open" = "xno" ; then
+        AC_MSG_ERROR([DiskIO IpcIo module requires shared memory support])
       fi
+      DISK_MODULES="$DISK_MODULES IpcIo"
+      DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/IpcIo/IpcIoDiskIOModule.o"
+      AC_DEFINE([HAVE_DISKIO_MODULE_IPCIO],1,[IpcIo Disk I/O module is built])
       ;;
 
     Mmapped)
@@ -732,33 +712,15 @@ for module in $squid_disk_module_candidates none; do
         AC_MSG_NOTICE([Mmapped DiskIO is not available on Mingw])
       else
         AC_MSG_NOTICE([Enabling Mmapped DiskIO module])
-        DISK_LIBS="$DISK_LIBS libMmapped.a"
         DISK_MODULES="$DISK_MODULES Mmapped"
         DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/Mmapped/MmappedDiskIOModule.o"
+        AC_DEFINE([HAVE_DISKIO_MODULE_MMAPPED],1,[Mmapped Disk I/O module is built])
       fi
       ;;
 
-    IpcIo)
-      AC_MSG_NOTICE([Enabling IpcIo DiskIO module])
-      if test "x$ac_cv_search_shm_open" = "xno" ; then
-        AC_MSG_ERROR([DiskIO IpcIo module requires shared memory support])
-      fi
-      DISK_LIBS="$DISK_LIBS libIpcIo.a"
-      DISK_MODULES="$DISK_MODULES IpcIo"
-      DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/IpcIo/IpcIoDiskIOModule.o"
-      AC_DEFINE(USE_DISKIO_IPCIO, 1, [Enable DiskIO IpcIo module.])
-      ;;
-
-    Blocking)
-      AC_MSG_NOTICE([Enabling Blocking DiskIO module])
-      DISK_LIBS="$DISK_LIBS libBlocking.a"
-      DISK_MODULES="$DISK_MODULES Blocking"
-      DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/Blocking/BlockingDiskIOModule.o"
-      ;;
-
     *)
       AC_MSG_NOTICE([Enabling $module DiskIO module])
-      DISK_LIBS="$DISK_LIBS lib${module}.a"
+      DISK_LIBS="$DISK_LIBS lib${module}.la"
       DISK_MODULES="$DISK_MODULES ${module}"
       DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/${module}/${module}DiskIOModule.o"
       ;;
@@ -767,11 +729,17 @@ done
 AC_MSG_NOTICE([IO Modules built: $DISK_MODULES])
 AC_SUBST(DISK_MODULES)
 AC_SUBST(DISK_LIBS)
-AC_SUBST(DISK_PROGRAMS)
 AC_SUBST(DISK_LINKOBJS)
-AC_SUBST(DISK_OS_LIBS)
-AM_CONDITIONAL([ENABLE_WIN32_AIOPS], [test "$ENABLE_WIN32_AIOPS" = "1"])
-AM_CONDITIONAL([ENABLE_WIN32_AIO], [test "$ENABLE_WIN32_AIO" = "1"])
+AM_CONDITIONAL([ENABLE_DISKIO_AIO], [test "x$squid_disk_module_candidates_AIO" = "xyes"])
+AC_SUBST(AIOLIB)
+AM_CONDITIONAL([ENABLE_WIN32_AIO], [test "x$squid_disk_module_candidates_AIO" = "xyes" -a "x$ENABLE_WIN32_AIO" = "x1"])
+AM_CONDITIONAL([ENABLE_DISKIO_BLOCKING], [test "x$squid_disk_module_candidates_Blocking" = "xyes"])
+AM_CONDITIONAL([ENABLE_DISKIO_DISKDAEMON], [test "x$squid_disk_module_candidates_DiskDaemon" = "xyes"])
+AM_CONDITIONAL([ENABLE_DISKIO_DISKTHREADS], [test "x$squid_disk_module_candidates_DiskThreads" = "xyes"])
+AC_SUBST(LIBPTHREADS)
+AM_CONDITIONAL([ENABLE_WIN32_AIOPS], [test "x$squid_disk_module_candidates_DiskThreads" = "xyes" -a "x$ENABLE_WIN32_AIOPS" = "x1"])
+AM_CONDITIONAL([ENABLE_DISKIO_IPCIO], [test "x$squid_disk_module_candidates_IpcIo" = "xyes"])
+AM_CONDITIONAL([ENABLE_DISKIO_MMAPPED], [test "x$squid_disk_module_candidates_Mmapped" = "xyes"])
 
 
 dnl Check what Storage formats are wanted.
@@ -2973,9 +2941,10 @@ AC_CHECK_SIZEOF(size_t)
 AC_CHECK_SIZEOF(off_t)
 AC_CHECK_SIZEOF(size_t)
 
-dnl Some C++0x types we try to use
+dnl Some C++11 types we try to use
 AX_CXX_TYPE_NULLPTR
 AX_CXX_TYPE_UNIQUE_PTR
+AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS
 
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
@@ -3349,7 +3318,6 @@ AC_CHECK_FUNCS(\
 	getspnam \
 	gettimeofday \
 	glob \
-	lrand48 \
 	mallocblksize \
 	mallopt \
 	memcpy \
@@ -3366,7 +3334,6 @@ AC_CHECK_FUNCS(\
 	pthread_setschedparam \
 	pthread_sigmask \
 	putenv \
-	random \
 	regcomp \
 	regexec \
 	regfree \
@@ -3383,16 +3350,13 @@ AC_CHECK_FUNCS(\
 	sigaction \
 	snprintf \
 	socketpair \
-	srand48 \
-	srandom \
 	sysconf \
 	syslog \
 	timegm \
 	vsnprintf \
 )
 dnl ... and some we provide local replacements for
 AC_REPLACE_FUNCS(\
-	drand48 \
 	initgroups \
 	psignal \
 	strerror \
@@ -3885,6 +3849,13 @@ AC_CONFIG_FILES([
 	src/clients/Makefile
 	src/comm/Makefile
 	src/dns/Makefile
+	src/DiskIO/Makefile
+	src/DiskIO/AIO/Makefile
+	src/DiskIO/Blocking/Makefile
+	src/DiskIO/DiskDaemon/Makefile
+	src/DiskIO/DiskThreads/Makefile
+	src/DiskIO/IpcIo/Makefile
+	src/DiskIO/Mmapped/Makefile
 	src/esi/Makefile
 	src/eui/Makefile
 	src/format/Makefile
@@ -107,7 +107,6 @@ section 56    HTTP Message Body
 section 57    HTTP Status-line
 section 58    HTTP Reply (Response)
 section 59    auto-growing Memory Buffer with printf
-section 60    Packer: A uniform interface to store-like modules
 section 61    Redirector
 section 62    Generic Histogram
 section 63    Low Level Memory Pool Management
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.4 release notes</title>
+<title>Squid 3.5.6 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.4.
+The Squid Team are pleased to announce the release of Squid-3.5.6.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -40,7 +40,7 @@ The Squid-4 change history can be <url url="http://www.squid-cache.org/Versions/
 <itemize>
 	<item>Helper concurrency channels changes
 	<item>Configurable helper queue size
-	<item>SSLv2 support removal
+	<item>SSL support removal
 	<item>MSNT-multi-domain helper removal
 </itemize>
 
@@ -66,14 +66,20 @@ to configure the maximum number of queued requests to busy helpers.
     return unexpected results or timeout once crossing the 32-bit wrap
     boundary. Leading to undefined behaviour in the client HTTP traffic.
 
-<sect1>SSLv2 support removal
+<sect1>SSL support removal
 <p>Details in <url url="https://tools.ietf.org/html/rfc6176" name="RFC 6176">
+   and <url url="https://tools.ietf.org/html/rfc7568" name="RFC 7568">
 
 <p>SSLv2 is not fit for purpose. Squid no longer supports being configured with
 any settings regarding this protocol. That includes settings manually disabling
 its use since it is now forced to disable by default. Also settings enabling
 various client/server workarounds specific to SSLv2 are removed.
 
+<p>SSLv3 is not fit for purpose. Squid still accepts configuration, but use
+is deprecated and will be removed entirely in a future version.
+Squid default behavour is to follow the TLS built in negotiation mechanism
+which prefers the latest TLS version.
+
 
 <sect1>MSNT-multi-domain helper removal
 
@@ -117,24 +123,42 @@ This section gives a thorough account of those changes in three categories:
 	   of queued requests.
 
 	<tag>cache_peer</tag>
-	<p>All <em>ssloption=</em> and <em>sslversion=</em> values for
-	   SSLv2 configuration or disabling have been removed.
+	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
+	<p>All <em>ssloptions=</em> values for SSLv2 configuration or disabling
+	   have been removed.
+	<p>Removed <em>sslversion=</em> option. Use <em>tls-options=</em> instead.
 	<p>Manual squid.conf update may be required on upgrade.
 
 	<tag>external_acl_type</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
 
 	<tag>http_port</tag>
-	<p>All <em>version=</em> <em>option=</em> values for SSLv2
-	   configuration or disabling have been removed.
+	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
+	<p>All <em>option=</em> values for SSLv2 configuration or disabling
+	   have been removed.
+	<p>Removed <em>version=</em> option. Use <em>tls-options=</em> instead.
 	<p>Manual squid.conf update may be required on upgrade.
 
 	<tag>https_port</tag>
-	<p>All <em>version=</em> <em>option=</em> values for SSLv2
+	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
+	<p>All <em>options=</em> values for SSLv2
 	   configuration or disabling have been removed.
+	<p>Removed <em>version=</em> option. Use <em>tls-options=</em> instead.
+	<p>New <em>options=SINGLE_ECDH_USE</em> parameter to enable ephemeral
+	   ECDH key exchange.
+	<p>Deprecated <em>dhparams=</em> option. Use <em>tls-dh=</em> instead.
+	   The new option allows to optionally specify an elliptic curve for
+	   ephemeral ECDH by adding <em>curve-name:</em> in front of the
+	   parameter file name.
 	<p>Manual squid.conf update may be required on upgrade.
 
+	<tag>refresh_pattern</tag>
+	<p>Removed <em>ignore-auth</em>. Its commonly desired behaviour is
+	   performed by default with correct HTTP/1.1 revalidation.
+	<p>Removed <em>ignore-must-revalidate</em>. Other more HTTP compliant
+	   directives can be used to prevent objects from caching.
+
 	<tag>sslcrtd_children</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
@@ -143,13 +167,6 @@ This section gives a thorough account of those changes in three categories:
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
 
-	<tag>sslproxy_options</tag>
-	<p>All values for SSLv2 configuration or disabling have been removed.
-	<p>Manual squid.conf update may be required on upgrade.
-
-	<tag>sslproxy_version</tag>
-	<p>Value '2' for SSLv2-only operation is no longer supported.
-
 	<tag>url_rewrite_children</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
@@ -188,9 +205,13 @@ This section gives a thorough account of those changes in three categories:
 
 	<tag>sslproxy_options</tag>
 	<p>Replaced by <em>tls_outgoing_options options=</em>.
+	<p>All values for SSLv2 configuration or disabling have been removed.
+	<p>Manual squid.conf update may be required on upgrade.
 
 	<tag>sslproxy_version</tag>
-	<p>Replaced by <em>tls_outgoing_options version=</em>.
+	<p>Replaced by <em>tls_outgoing_options options=</em>.
+	<p>All values for SSLv2 configuration or disabling have been removed.
+	<p>Manual squid.conf update may be required on upgrade.
 
 </descrip>
 
@@ -13,7 +13,7 @@ da	da-dk
 de	de-at de-ch de-de de-li de-lu
 el	el-gr
 en	en-au en-bz en-ca en-gb en-ie en-in en-jm en-nz en-ph en-sg en-tt en-uk en-us en-za en-zw
-es	es-ar es-bo es-cl es-co es-cr es-do es-ec es-es es-gt es-hn es-mx es-ni es-pa es-pe es-pr es-py es-sv es-uy es-ve
+es	es-ar es-bo es-cl es-co es-cr es-do es-ec es-es es-gt es-hn es-mx es-ni es-pa es-pe es-pr es-py es-sv es-us es-uy es-ve
 et	et-ee
 fa	fa-fa fa-ir
 fi	fi-fi
@@ -31,7 +31,7 @@ html body {
 	margin-left: 15px;
 	padding: 10px;
 	padding-left: 100px;
-	background: url('http://www.squid-cache.org/Artwork/SN.png') no-repeat left;
+	background: url('/squid-internal-static/icons/SN.png') no-repeat left;
 }
 
 /* initial title */
@@ -63,6 +63,7 @@
 #include <cerrno>
 #include <cstring>
 #include <ctime>
+#include <random>
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -205,16 +206,11 @@ result_recv(char *buffer, int length)
 static void
 random_vector(char *aVector)
 {
-    int randno;
-    int i;
-
-    srand((time(0) ^ rand()) + rand());
-    for (i = 0; i < AUTH_VECTOR_LEN;) {
-        randno = rand();
-        memcpy(aVector, &randno, sizeof(int));
-        aVector += sizeof(int);
-        i += sizeof(int);
-    }
+    static std::mt19937 mt(time(0));
+    static std::uniform_int_distribution<uint8_t> dist;
+
+    for (int i = 0; i < AUTH_VECTOR_LEN; ++i)
+        aVector[i] = static_cast<char>(dist(mt) & 0xFF);
 }
 
 /* read the config file
@@ -99,7 +99,7 @@ main(int argc, char *argv[])
 
     process_options(argc, argv);
 
-    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", program_name);
 
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
         char *p;
@@ -115,7 +115,7 @@ main(int argc, char *argv[])
         /* send 'OK' result back to Squid */
         SEND_OK("");
     }
-    debug("%s build " __DATE__ ", " __TIME__ " shutting down...\n", program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " shutting down...\n", program_name);
     exit(0);
 }
 
@@ -155,10 +155,6 @@ static int berEncodeLoginData(
     size_t   putDataLen,
     void     *putData)
 {
-    int err = 0;
-    BerElement *requestBer = NULL;
-
-    unsigned int i;
     unsigned int elemCnt = methodIDLen / sizeof(unsigned int);
 
     char    *utf8ObjPtr=NULL;
@@ -174,45 +170,56 @@ static int berEncodeLoginData(
     utf8TagSize = strlen(utf8TagPtr)+1;
 
     /* Allocate a BerElement for the request parameters. */
-    if ((requestBer = ber_alloc()) == NULL) {
-        err = LDAP_ENCODING_ERROR;
-        return err;
-    }
+    BerElement *requestBer = ber_alloc();
+    if (!requestBer)
+        return LDAP_ENCODING_ERROR;
 
     /* BER encode the NMAS Version and the objectDN */
-    err = (ber_printf(requestBer, "{io", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize) < 0) ? LDAP_ENCODING_ERROR : 0;
+    if (ber_printf(requestBer, "{io", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize) < 0) {
+        ber_free(requestBer, 1);
+        return LDAP_ENCODING_ERROR;
+    }
 
     /* BER encode the MethodID Length and value */
-    if (!err) {
-        err = (ber_printf(requestBer, "{i{", methodIDLen) < 0) ? LDAP_ENCODING_ERROR : 0;
+    if (ber_printf(requestBer, "{i{", methodIDLen) < 0) {
+        ber_free(requestBer, 1);
+        return LDAP_ENCODING_ERROR;
     }
 
-    for (i = 0; !err && i < elemCnt; ++i) {
-        err = (ber_printf(requestBer, "i", methodID[i]) < 0) ? LDAP_ENCODING_ERROR : 0;
+    for (unsigned int i = 0; i < elemCnt; ++i) {
+        if (ber_printf(requestBer, "i", methodID[i]) < 0) {
+            ber_free(requestBer, 1);
+            return LDAP_ENCODING_ERROR;
+        }
     }
 
-    if (!err) {
-        err = (ber_printf(requestBer, "}}", 0) < 0) ? LDAP_ENCODING_ERROR : 0;
+    if (ber_printf(requestBer, "}}", 0) < 0) {
+        ber_free(requestBer, 1);
+        return LDAP_ENCODING_ERROR;
     }
 
     if (putData) {
         /* BER Encode the the tag and data */
-        err = (ber_printf(requestBer, "oio}", utf8TagPtr, utf8TagSize, putDataLen, putData, putDataLen) < 0) ? LDAP_ENCODING_ERROR : 0;
+        if (ber_printf(requestBer, "oio}", utf8TagPtr, utf8TagSize, putDataLen, putData, putDataLen) < 0) {
+            ber_free(requestBer, 1);
+            return LDAP_ENCODING_ERROR;
+        }
     } else {
         /* BER Encode the the tag */
-        err = (ber_printf(requestBer, "o}", utf8TagPtr, utf8TagSize) < 0) ? LDAP_ENCODING_ERROR : 0;
+        if (ber_printf(requestBer, "o}", utf8TagPtr, utf8TagSize) < 0) {
+            ber_free(requestBer, 1);
+            return LDAP_ENCODING_ERROR;
+        }
     }
 
     /* Convert the BER we just built to a berval that we'll send with the extended request. */
-    if (!err && (ber_tag_t)ber_flatten(requestBer, requestBV) == LBER_ERROR) {
-        err = LDAP_ENCODING_ERROR;
-    }
-
-    if (requestBer) {
+    if (static_cast<ber_tag_t>(ber_flatten(requestBer, requestBV)) == LBER_ERROR) {
         ber_free(requestBer, 1);
+        return LDAP_ENCODING_ERROR;
     }
 
-    return err;
+    ber_free(requestBer, 1);
+    return 0; /* no error */
 }
 
 /**********************************************************************
@@ -801,8 +801,7 @@ main(int argc, char *argv[])
         if (!DefaultDomain)
             DefaultDomain = xstrdup(machinedomain);
     }
-    debug("External ACL win32 group helper build " __DATE__ ", " __TIME__
-          " starting up...\n");
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", argv[0]);
     if (use_global)
         debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
     if (use_case_insensitive_compare)
@@ -540,8 +540,7 @@ main(int argc, char *argv[])
         if (!DefaultDomain)
             DefaultDomain = xstrdup(machinedomain);
     }
-    debug("External ACL win32 group helper build " __DATE__ ", " __TIME__
-          " starting up...\n");
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", argv[0]);
     if (use_global) {
         debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
     }
@@ -1500,6 +1500,7 @@ MainSafe(int argc, char **argv)
     memset(bufb, '\0', sizeof(bufb));
     memset(bufc, '\0', sizeof(bufc));
     memset(sfmod, '\0', sizeof(sfmod));
+    memset(&sv, 0, sizeof(sv));
 
     InitConf();
     xstrncpy(edui_conf.program, argv[0], sizeof(edui_conf.program));
@@ -165,7 +165,7 @@ krb5_create_cache(char *domain)
             }
         } else {
             krb5_error_code code2 = 0;
-            creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
+            creds = static_cast<krb5_creds *>(xcalloc(1,sizeof(*creds)));
             while ((krb5_cc_next_cred(kparam.context, kparam.cc[ccindex], &ccursor, creds)) == 0) {
                 code2 = krb5_unparse_name(kparam.context, creds->server, &principal_name);
                 if (code2) {
@@ -174,8 +174,8 @@ krb5_create_cache(char *domain)
                     if (code) {
                         k5_error("Error while destroying ccache",code);
                     }
-                    if (creds)
-                        krb5_free_creds(kparam.context, creds);
+                    assert(creds != NULL);
+                    krb5_free_creds(kparam.context, creds);
                     creds = NULL;
                     safe_free(principal_name);
                     debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
@@ -207,8 +207,8 @@ krb5_create_cache(char *domain)
                         if (code) {
                             k5_error("Error  while destroying ccache",code);
                         }
-                        if (creds)
-                            krb5_free_creds(kparam.context, creds);
+                        assert(creds != NULL);
+                        krb5_free_creds(kparam.context, creds);
                         creds = NULL;
                         safe_free(principal_name);
                         debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
@@ -224,9 +224,9 @@ krb5_create_cache(char *domain)
                     }
                     break;
                 }
-                if (creds)
-                    krb5_free_creds(kparam.context, creds);
-                creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
+                assert(creds != NULL);
+                krb5_free_creds(kparam.context, creds);
+                creds = static_cast<krb5_creds *>(xcalloc(1, sizeof(*creds)));
                 safe_free(principal_name);
             }
             if (creds)
@@ -105,6 +105,9 @@ main(int argc, char *argv[])
         exit(1);
     }
     setbuf(stdout, NULL);
+    /* XXX stderr should not be closed, but in order to support squid must be
+     * able to collect and manage modules's stderr first.
+     */
     close(2);
     t = open(_PATH_DEVNULL, O_RDWR);
     assert(t > -1);
@@ -119,7 +122,7 @@ main(int argc, char *argv[])
                 /* try to detect the 32-bit file too big write error and rotate */
                 int err = ferror(fp);
                 clearerr(fp);
-                if (err < 0) {
+                if (err != 0) {
                     /* file too big - recover by rotating the logs and starting a new one.
                      * out of device space - recover by rotating and hoping that rotation count drops a big one.
                      */
@@ -302,7 +302,7 @@ main(int argc, char *argv[])
 
     process_options(argc, argv);
 
-    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", my_program_name);
 
     if (LoadSecurityDll(SSP_NTLM, NEGOTIATE_PACKAGE_NAME) == NULL) {
         fprintf(stderr, "FATAL: %s: can't initialize SSPI, exiting.\n", argv[0]);
@@ -637,7 +637,7 @@ main(int argc, char *argv[])
 
     process_options(argc, argv);
 
-    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", my_program_name);
 
     if (LoadSecurityDll(SSP_NTLM, NTLM_PACKAGE_NAME) == NULL) {
         fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
@@ -141,7 +141,7 @@ main(int argc, char *argv[])
 
     process_options(argc, argv);
 
-    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", my_program_name);
 
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
         user[0] = '\0';     /*no user code */
@@ -477,7 +477,6 @@ manage_request()
     ntlmhdr *fast_header;
     char buf[NTLM_BLOB_BUFFER_SIZE];
     char decoded[NTLM_BLOB_BUFFER_SIZE];
-    const char *ch;
     char *ch2, *cred = NULL;
 
     if (fgets(buf, NTLM_BLOB_BUFFER_SIZE, stdin) == NULL) {
@@ -489,7 +488,6 @@ manage_request()
     ch2 = (char*)memchr(buf, '\n', NTLM_BLOB_BUFFER_SIZE);  /* safer against overrun than strchr */
     if (ch2) {
         *ch2 = '\0';        /* terminate the string at newline. */
-        ch = ch2;
     }
     debug("ntlm authenticator. Got '%s' from Squid\n", buf);
 
@@ -628,7 +626,7 @@ manage_request()
     }
     if (memcmp(buf, "YR", 2) == 0) {    /* refresh-request */
         dc_disconnect();
-        ch = obtain_challenge();
+        const char *ch = obtain_challenge();
         /* Robert says we can afford to wait forever. I'll trust him on this
          * one */
         while (ch == NULL) {
@@ -647,7 +645,7 @@ manage_request()
 int
 main(int argc, char *argv[])
 {
-    debug("ntlm_auth build " __DATE__ ", " __TIME__ " starting up...\n");
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", argv[0]);
 
     my_program_name = argv[0];
     process_options(argc, argv);
@@ -104,7 +104,7 @@ main(int argc, char *argv[])
 
     process_options(argc, argv);
 
-    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " starting up...\n", my_program_name);
 
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
         char *p;
@@ -127,7 +127,7 @@ main(int argc, char *argv[])
             fprintf(stdout, "%" PRId64 " ERR\n", channelId);
         }
     }
-    debug("%s build " __DATE__ ", " __TIME__ " shutting down...\n", my_program_name);
+    debug("%s " VERSION " " SQUID_BUILD_INFO " shutting down...\n", my_program_name);
     return 0;
 }
 
@@ -66,17 +66,6 @@
 #define SQUID_UDP_SO_RCVBUF SQUID_DETECT_UDP_SO_RCVBUF
 #endif
 
-#if HAVE_RANDOM
-#define squid_random random
-#define squid_srandom srandom
-#elif HAVE_LRAND48
-#define squid_random lrand48
-#define squid_srandom srand48
-#else
-#define squid_random rand
-#define squid_srandom srand
-#endif
-
 /*
  * Determine if this is a leak check build or standard
  */
@@ -343,12 +343,15 @@ main(void)
     }
     printf("done creating hash table: %d\n", hid);
 
+    std::mt19937 mt;
+    std::uniform_int_distribution<> dist(0,16);
+
     while (fgets(buf, BUFSIZ, stdin)) {
         buf[strlen(buf) - 1] = '\0';
         printf("Inserting '%s' for item %p to hash table: %d\n",
                buf, buf, hid);
         hash_insert(hid, xstrdup(buf), (void *) 0x12345678);
-        if (random() % 17 == 0)
+        if (dist(mt) == 0)
             strcpy(todelete, buf);
     }
 
@@ -12,6 +12,7 @@
 #include "squid.h"
 
 #include <cstring>
+#include <random>
 #if HAVE_STRINGS_H
 #include <strings.h>
 #endif
@@ -178,21 +179,16 @@ ntlm_add_to_payload(const ntlmhdr *packet_hdr,
 /* ************************************************************************* */
 
 /*
- * Generates a challenge request nonce. The randomness of the 8 byte
- * challenge strings can be guarenteed to be poor at best.
+ * Generates a challenge request nonce.
  */
 void
 ntlm_make_nonce(char *nonce)
 {
-    static unsigned hash;
-    uint32_t r = static_cast<uint32_t>(rand());
-    r = (hash ^ r) + r;
+    static std::mt19937 mt(time(0));
+    static std::uniform_int_distribution<uint8_t> dist;
 
-    for (int i = 0; i < NTLM_NONCE_LEN; ++i) {
-        nonce[i] = static_cast<char>(r & 0xFF);
-        r = (r >> 2) ^ r;
-    }
-    hash = r;
+    for (int i = 0; i < NTLM_NONCE_LEN; ++i)
+        nonce[i] = static_cast<char>(dist(mt) & 0xFF);
 }
 
 /**
@@ -67,14 +67,20 @@ CvtBin(const HASHHEX Hex, HASH Bin)
         else
             Bin[i / 2] |= n;
     }
-    /* FIXME: Coverity detects the below as dead code.
+
+#if HASHHEXLEN != (2*HASHLEN)
+    /*
       Why? :: right here i == 32
         which means the first step of the for loop makes i==16
         and cannot be < HASHLEN (which is also 16)
+
+      But only guaranteed if HASHHEXLEN == 2*HASHLEN
+      This will ensure correct 0-ing of bins no matter what.
     */
     for (i = i / 2; i < HASHLEN; i++) {
         Bin[i] = '\0';
     }
+#endif
 }
 
 /* calculate H(A1) as per spec */
@@ -204,7 +204,11 @@ int SMB_Figure_Protocol(const char *dialects[], int prot_index)
 {
     int i;
 
-    if (dialects == SMB_Prots) { /* The jobs is easy, just index into table */
+    // prot_index may be a value outside the table SMB_Types[]
+    // which holds data at offsets 0 to 11
+    int ourType = (prot_index < 0 || prot_index > 11);
+
+    if (ourType && dialects == SMB_Prots) { /* The jobs is easy, just index into table */
 
         return(SMB_Types[prot_index]);
     } else { /* Search through SMB_Prots looking for a match */
@@ -63,23 +63,17 @@ class AccessLogEntry: public RefCountable
     {
 
     public:
-        HttpDetails() : method(Http::METHOD_NONE), code(0), content_type(NULL),
-            timedout(false),
-            aborted(false),
+        HttpDetails() :
+            method(Http::METHOD_NONE),
+            code(0),
+            content_type(NULL),
             clientRequestSz(),
             clientReplySz() {}
 
         HttpRequestMethod method;
         int code;
         const char *content_type;
         AnyP::ProtocolVersion version;
-        bool timedout; ///< terminated due to a lifetime or I/O timeout
-        bool aborted; ///< other abnormal termination (e.g., I/O error)
-
-        /// compute suffix for the status access.log field
-        const char *statusSfx() const {
-            return timedout ? "_TIMEDOUT" : (aborted ? "_ABORTED" : "");
-        }
 
         /// counters for the original request received from client
         // TODO calculate header and payload better (by parser)
@@ -140,7 +134,7 @@ class AccessLogEntry: public RefCountable
         CacheDetails() : caddr(),
             highOffset(0),
             objectSize(0),
-            code (LOG_TAG_NONE),
+            code(LOG_TAG_NONE),
             rfc931 (NULL),
             extuser(NULL),
 #if USE_OPENSSL
@@ -444,19 +444,19 @@ const char *BodyPipe::status() const
 
     outputBuffer.append(" [", 2);
 
-    outputBuffer.Printf("%" PRIu64 "<=%" PRIu64, theGetSize, thePutSize);
+    outputBuffer.appendf("%" PRIu64 "<=%" PRIu64, theGetSize, thePutSize);
     if (theBodySize >= 0)
-        outputBuffer.Printf("<=%" PRId64, theBodySize);
+        outputBuffer.appendf("<=%" PRId64, theBodySize);
     else
         outputBuffer.append("<=?", 3);
 
-    outputBuffer.Printf(" %d+%d", (int)theBuf.contentSize(), (int)theBuf.spaceSize());
+    outputBuffer.appendf(" %" PRId64 "+%" PRId64, static_cast<int64_t>(theBuf.contentSize()), static_cast<int64_t>(theBuf.spaceSize()));
 
-    outputBuffer.Printf(" pipe%p", this);
+    outputBuffer.appendf(" pipe%p", this);
     if (theProducer.set())
-        outputBuffer.Printf(" prod%p", theProducer.get());
+        outputBuffer.appendf(" prod%p", theProducer.get());
     if (theConsumer.set())
-        outputBuffer.Printf(" cons%p", theConsumer.get());
+        outputBuffer.appendf(" cons%p", theConsumer.get());
 
     if (mustAutoConsume)
         outputBuffer.append(" A", 2);
@@ -182,9 +182,8 @@ class CachePeer
 
     /// security settings for peer connection
     Security::PeerOptions secure;
-
+    Security::ContextPointer sslContext;
 #if USE_OPENSSL
-    SSL_CTX *sslContext;
     SSL_SESSION *sslSession;
 #endif
 
@@ -1,311 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#include "squid.h"
-#include "base/TextException.h"
-#include "ChunkedCodingParser.h"
-#include "Debug.h"
-#include "MemBuf.h"
-#include "Parsing.h"
-
-ChunkedCodingParser::Step ChunkedCodingParser::psChunkSize = &ChunkedCodingParser::parseChunkSize;
-ChunkedCodingParser::Step ChunkedCodingParser::psUnusedChunkExtension = &ChunkedCodingParser::parseUnusedChunkExtension;
-ChunkedCodingParser::Step ChunkedCodingParser::psLastChunkExtension = &ChunkedCodingParser::parseLastChunkExtension;
-ChunkedCodingParser::Step ChunkedCodingParser::psChunkBody = &ChunkedCodingParser::parseChunkBody;
-ChunkedCodingParser::Step ChunkedCodingParser::psChunkEnd = &ChunkedCodingParser::parseChunkEnd;
-ChunkedCodingParser::Step ChunkedCodingParser::psTrailer = &ChunkedCodingParser::parseTrailer;
-ChunkedCodingParser::Step ChunkedCodingParser::psMessageEnd = &ChunkedCodingParser::parseMessageEnd;
-
-ChunkedCodingParser::ChunkedCodingParser()
-{
-    reset();
-}
-
-void ChunkedCodingParser::reset()
-{
-    theStep = psChunkSize;
-    theChunkSize = theLeftBodySize = 0;
-    doNeedMoreData = false;
-    theIn = theOut = NULL;
-    useOriginBody = -1;
-    inQuoted = inSlashed = false;
-}
-
-bool ChunkedCodingParser::parse(MemBuf *rawData, MemBuf *parsedContent)
-{
-    Must(rawData && parsedContent);
-    theIn = rawData;
-    theOut = parsedContent;
-
-    // we must reset this all the time so that mayContinue() lets us
-    // output more content if we stopped due to needsMoreSpace() before
-    doNeedMoreData = !theIn->hasContent();
-
-    while (mayContinue()) {
-        (this->*theStep)();
-    }
-
-    return theStep == psMessageEnd;
-}
-
-bool ChunkedCodingParser::needsMoreData() const
-{
-    return doNeedMoreData;
-}
-
-bool ChunkedCodingParser::needsMoreSpace() const
-{
-    assert(theOut);
-    return theStep == psChunkBody && !theOut->hasPotentialSpace();
-}
-
-bool ChunkedCodingParser::mayContinue() const
-{
-    return !needsMoreData() && !needsMoreSpace() && theStep != psMessageEnd;
-}
-
-void ChunkedCodingParser::parseChunkSize()
-{
-    Must(theChunkSize <= 0); // Should(), really
-
-    const char *p = theIn->content();
-    while (p < theIn->space() && xisxdigit(*p)) ++p;
-    if (p >= theIn->space()) {
-        doNeedMoreData = true;
-        return;
-    }
-
-    int64_t size = -1;
-    if (StringToInt64(theIn->content(), size, &p, 16)) {
-        if (size < 0)
-            throw TexcHere("negative chunk size");
-
-        theChunkSize = theLeftBodySize = size;
-        debugs(94,7, "found chunk: " << theChunkSize);
-        // parse chunk extensions only in the last-chunk
-        if (theChunkSize)
-            theStep = psUnusedChunkExtension;
-        else {
-            theIn->consume(p - theIn->content());
-            theStep = psLastChunkExtension;
-        }
-    } else
-        throw TexcHere("corrupted chunk size");
-}
-
-void ChunkedCodingParser::parseUnusedChunkExtension()
-{
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-    if (findCrlf(crlfBeg, crlfEnd, inQuoted, inSlashed)) {
-        inQuoted = inSlashed = false;
-        theIn->consume(crlfEnd);
-        theStep = theChunkSize ? psChunkBody : psTrailer;
-    } else {
-        theIn->consume(theIn->contentSize());
-        doNeedMoreData = true;
-    }
-}
-
-void ChunkedCodingParser::parseChunkBody()
-{
-    Must(theLeftBodySize > 0); // Should, really
-
-    const size_t availSize = min(theLeftBodySize, (uint64_t)theIn->contentSize());
-    const size_t safeSize = min(availSize, (size_t)theOut->potentialSpaceSize());
-
-    doNeedMoreData = availSize < theLeftBodySize;
-    // and we may also need more space
-
-    theOut->append(theIn->content(), safeSize);
-    theIn->consume(safeSize);
-    theLeftBodySize -= safeSize;
-
-    if (theLeftBodySize == 0)
-        theStep = psChunkEnd;
-    else
-        Must(needsMoreData() || needsMoreSpace());
-}
-
-void ChunkedCodingParser::parseChunkEnd()
-{
-    Must(theLeftBodySize == 0); // Should(), really
-
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-
-    if (findCrlf(crlfBeg, crlfEnd)) {
-        if (crlfBeg != 0) {
-            throw TexcHere("found data between chunk end and CRLF");
-            return;
-        }
-
-        theIn->consume(crlfEnd);
-        theChunkSize = 0; // done with the current chunk
-        theStep = psChunkSize;
-        return;
-    }
-
-    doNeedMoreData = true;
-}
-
-void ChunkedCodingParser::parseTrailer()
-{
-    Must(theChunkSize == 0); // Should(), really
-
-    while (mayContinue())
-        parseTrailerHeader();
-}
-
-void ChunkedCodingParser::parseTrailerHeader()
-{
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-
-    if (findCrlf(crlfBeg, crlfEnd)) {
-
-#if TRAILERS_ARE_SUPPORTED
-        if (crlfBeg > 0)
-            theTrailer.append(theIn->content(), crlfEnd);
-#endif
-
-        theIn->consume(crlfEnd);
-
-        if (crlfBeg == 0)
-            theStep = psMessageEnd;
-
-        return;
-    }
-
-    doNeedMoreData = true;
-}
-
-void ChunkedCodingParser::parseMessageEnd()
-{
-    // termination step, should not be called
-    Must(false); // Should(), really
-}
-
-/// Finds next CRLF. Does not store parsing state.
-bool ChunkedCodingParser::findCrlf(size_t &crlfBeg, size_t &crlfEnd)
-{
-    bool quoted = false;
-    bool slashed = false;
-    return findCrlf(crlfBeg, crlfEnd, quoted, slashed);
-}
-
-/// Finds next CRLF. Parsing state stored in quoted and slashed
-/// parameters. Incremental: can resume when more data is available.
-bool ChunkedCodingParser::findCrlf(size_t &crlfBeg, size_t &crlfEnd, bool &quoted, bool &slashed)
-{
-    // XXX: This code was copied, with permission, from another software.
-    // There is a similar and probably better code inside httpHeaderParse
-    // but it seems difficult to isolate due to parsing-unrelated bloat.
-    // Such isolation should probably be done before this class is used
-    // for handling of traffic "more external" than ICAP.
-
-    const char *buf = theIn->content();
-    size_t size = theIn->contentSize();
-
-    ssize_t crOff = -1;
-
-    for (size_t i = 0; i < size; ++i) {
-        if (slashed) {
-            slashed = false;
-            continue;
-        }
-
-        const char c = buf[i];
-
-        // handle quoted strings
-        if (quoted) {
-            if (c == '\\')
-                slashed = true;
-            else if (c == '"')
-                quoted = false;
-
-            continue;
-        } else if (c == '"') {
-            quoted = true;
-            crOff = -1;
-            continue;
-        }
-
-        if (crOff < 0) { // looking for the first CR or LF
-
-            if (c == '\n') {
-                crlfBeg = i;
-                crlfEnd = ++i;
-                return true;
-            }
-
-            if (c == '\r')
-                crOff = i;
-        } else { // skipping CRs, looking for the first LF
-
-            if (c == '\n') {
-                crlfBeg = crOff;
-                crlfEnd = ++i;
-                return true;
-            }
-
-            if (c != '\r')
-                crOff = -1;
-        }
-    }
-
-    return false;
-}
-
-// chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
-void ChunkedCodingParser::parseLastChunkExtension()
-{
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-
-    if (!findCrlf(crlfBeg, crlfEnd)) {
-        doNeedMoreData = true;
-        return;
-    }
-
-    const char *const startExt = theIn->content();
-    const char *const endExt = theIn->content() + crlfBeg;
-
-    // chunk-extension starts at startExt and ends with LF at endEx
-    for (const char *p = startExt; p < endExt;) {
-
-        while (*p == ' ' || *p == '\t') ++p; // skip spaces before ';'
-
-        if (*p++ != ';') // each ext name=value pair is preceded with ';'
-            break;
-
-        while (*p == ' ' || *p == '\t') ++p; // skip spaces before name
-
-        if (p >= endExt)
-            break; // malformed extension: ';' without ext name=value pair
-
-        const int extSize = endExt - p;
-        // TODO: we need debugData() stream manipulator to dump data
-        debugs(94,7, "Found chunk extension; size=" << extSize);
-
-        // TODO: support implied *LWS around '='
-        if (extSize > 18 && strncmp(p, "use-original-body=", 18) == 0) {
-            (void)StringToInt64(p+18, useOriginBody, &p, 10);
-            debugs(94, 3, HERE << "use-original-body=" << useOriginBody);
-            break; // remove to support more than just use-original-body
-        } else {
-            debugs(94, 5, HERE << "skipping unknown chunk extension");
-            // TODO: support quoted-string chunk-ext-val
-            while (p < endExt && *p != ';') ++p; // skip until the next ';'
-        }
-    }
-
-    theIn->consume(crlfEnd);
-    theStep = theChunkSize ? psChunkBody : psTrailer;
-}
-
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_CHUNKEDCODINGPARSER_H
-#define SQUID_CHUNKEDCODINGPARSER_H
-
-class MemBuf;
-
-/**
- \ingroup ChunkEncodingAPI Chunked Encoding API
- \par
- * ChunkedCodingParser is an incremental parser for chunked transfer coding
- * used by HTTP and ICAP. The parser shovels content bytes from the raw
- * input buffer into the content output buffer, both caller-supplied.
- * Ignores chunk extensions except for ICAP's ieof.
- * Has a trailer-handling placeholder.
- */
-class ChunkedCodingParser
-{
-
-public:
-    ChunkedCodingParser();
-
-    void reset();
-
-    /**
-     \retval true    complete success
-     \retval false   needs more data
-     \throws ??      error.
-     */
-    bool parse(MemBuf *rawData, MemBuf *parsedContent);
-
-    bool needsMoreData() const;
-    bool needsMoreSpace() const;
-
-private:
-    typedef void (ChunkedCodingParser::*Step)();
-
-private:
-    bool mayContinue() const;
-
-    void parseChunkSize();
-    void parseUnusedChunkExtension();
-    void parseLastChunkExtension();
-    void parseChunkBeg();
-    void parseChunkBody();
-    void parseChunkEnd();
-    void parseTrailer();
-    void parseTrailerHeader();
-    void parseMessageEnd();
-
-    bool findCrlf(size_t &crlfBeg, size_t &crlfEnd);
-    bool findCrlf(size_t &crlfBeg, size_t &crlfEnd, bool &quoted, bool &slashed);
-
-private:
-    static Step psChunkSize;
-    static Step psUnusedChunkExtension;
-    static Step psLastChunkExtension;
-    static Step psChunkBody;
-    static Step psChunkEnd;
-    static Step psTrailer;
-    static Step psMessageEnd;
-
-    MemBuf *theIn;
-    MemBuf *theOut;
-
-    Step theStep;
-    uint64_t theChunkSize;
-    uint64_t theLeftBodySize;
-    bool doNeedMoreData;
-    bool inQuoted; ///< stores parsing state for incremental findCrlf
-    bool inSlashed; ///< stores parsing state for incremental findCrlf
-
-public:
-    int64_t useOriginBody;
-};
-
-#endif /* SQUID_CHUNKEDCODINGPARSER_H */
-
@@ -27,7 +27,7 @@ static const char *const ShmLabel = "cf";
 // TODO: make configurable or compute from squid.conf settings if possible
 static const int QueueCapacity = 1024;
 
-std::auto_ptr<CollapsedForwarding::Queue> CollapsedForwarding::queue;
+std::unique_ptr<CollapsedForwarding::Queue> CollapsedForwarding::queue;
 
 /// IPC queue message
 class CollapsedForwardingMsg
@@ -40,7 +40,7 @@ class CollapsedForwarding
 
 private:
     typedef Ipc::MultiQueue Queue;
-    static std::auto_ptr<Queue> queue; ///< IPC queue
+    static std::unique_ptr<Queue> queue; ///< IPC queue
 };
 
 #endif /* SQUID_COLLAPSED_FORWARDING_H */
@@ -67,9 +67,9 @@ ConfigParser::TokenPutBack(const char *tok)
 char *
 ConfigParser::Undo()
 {
-    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
+    static char undoToken[CONFIG_LINE_LIMIT];
     if (!Undo_.empty()) {
-        strncpy(undoToken, Undo_.front().c_str(), sizeof(undoToken));
+        xstrncpy(undoToken, Undo_.front().c_str(), sizeof(undoToken));
         undoToken[sizeof(undoToken) - 1] = '\0';
         if (!PreviewMode_)
             Undo_.pop();
@@ -88,7 +88,7 @@ ConfigParser::strtokFile()
     static FILE *wordFile = NULL;
 
     char *t;
-    LOCAL_ARRAY(char, buf, CONFIG_LINE_LIMIT);
+    static char buf[CONFIG_LINE_LIMIT];
 
     if ((t = ConfigParser::Undo()))
         return t;
@@ -126,7 +126,7 @@ ConfigParser::strtokFile()
         }
 
         /* fromFile */
-        if (fgets(buf, CONFIG_LINE_LIMIT, wordFile) == NULL) {
+        if (fgets(buf, sizeof(buf), wordFile) == NULL) {
             /* stop reading from file */
             fclose(wordFile);
             wordFile = NULL;
@@ -218,7 +218,7 @@ ConfigParser::UnQuote(const char *token, const char **next)
 
     if (errorStr) {
         if (PreviewMode_)
-            strncpy(UnQuoted, SQUID_ERROR_TOKEN, sizeof(UnQuoted));
+            xstrncpy(UnQuoted, SQUID_ERROR_TOKEN, sizeof(UnQuoted));
         else {
             debugs(3, DBG_CRITICAL, "FATAL: " << errorStr << ": " << errorPos);
             self_destruct();
@@ -21,9 +21,10 @@
  */
 
 #include "squid.h"
-#include "AIODiskFile.h"
-#include "AIODiskIOStrategy.h"
+#include "Debug.h"
 #include "disk.h"
+#include "DiskIO/AIO/AIODiskFile.h"
+#include "DiskIO/AIO/AIODiskIOStrategy.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
@@ -9,10 +9,10 @@
 #ifndef SQUID_AIODISKFILE_H
 #define SQUID_AIODISKFILE_H
 
-#if USE_DISKIO_AIO
+#if HAVE_DISKIO_MODULE_AIO
 
-#include "async_io.h"
 #include "cbdata.h"
+#include "DiskIO/AIO/async_io.h"
 #include "DiskIO/DiskFile.h"
 #include "SquidString.h"
 
@@ -56,6 +56,6 @@ class AIODiskFile : public DiskFile
     bool error_;
 };
 
-#endif /* USE_DISKIO_AIO */
+#endif /* HAVE_DISKIO_MODULE_AIO */
 #endif /* SQUID_AIODISKFILE_H */
 
@@ -7,8 +7,8 @@
  */
 
 #include "squid.h"
-#include "AIODiskIOModule.h"
-#include "AIODiskIOStrategy.h"
+#include "DiskIO/AIO/AIODiskIOModule.h"
+#include "DiskIO/AIO/AIODiskIOStrategy.h"
 #include "Store.h"
 
 AIODiskIOModule::AIODiskIOModule()
@@ -9,7 +9,7 @@
 #ifndef SQUID_AIODISKIOMODULE_H
 #define SQUID_AIODISKIOMODULE_H
 
-#if USE_DISKIO_AIO
+#if HAVE_DISKIO_MODULE_AIO
 
 #include "DiskIO/DiskIOModule.h"
 
@@ -28,6 +28,6 @@ class AIODiskIOModule : public DiskIOModule
     static AIODiskIOModule Instance;
 };
 
-#endif /* USE_DISKIO_AIO */
+#endif /* HAVE_DISKIO_MODULE_AIO */
 #endif /* SQUID_AIODISKIOMODULE_H */
 
@@ -19,8 +19,8 @@
  */
 
 #include "squid.h"
-#include "AIODiskFile.h"
-#include "AIODiskIOStrategy.h"
+#include "DiskIO/AIO/AIODiskFile.h"
+#include "DiskIO/AIO/AIODiskIOStrategy.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
@@ -101,8 +101,8 @@ int
 AIODiskIOStrategy::callback()
 {
     return 0;
+#if 0
     int i;
-    int completed = 0;
     int retval, reterr;
     FREE *freefunc;
     void *cbdata;
@@ -168,7 +168,8 @@ AIODiskIOStrategy::callback()
         }
     }
 
-    return completed;
+    return 0;
+#endif
 }
 
 void
@@ -6,12 +6,12 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_AIODISKIOSTRATEGY_H
-#define SQUID_AIODISKIOSTRATEGY_H
+#ifndef SQUID_SRC_DISKIO_AIO_AIODISKIOSTRATEGY_H
+#define SQUID_SRC_DISKIO_AIO_AIODISKIOSTRATEGY_H
 
-#if USE_DISKIO_AIO
+#if HAVE_DISKIO_MODULE_AIO
 
-#include "async_io.h"
+#include "DiskIO/AIO/async_io.h"
 #include "DiskIO/DiskIOStrategy.h"
 
 class AIODiskIOStrategy : public DiskIOStrategy
@@ -51,6 +51,6 @@ class AIODiskIOStrategy : public DiskIOStrategy
     int findSlot();
 };
 
-#endif /* USE_DISKIO_AIO */
-#endif /* SQUID_AIODISKIOSTRATEGY_H */
+#endif /* HAVE_DISKIO_MODULE_AIO */
+#endif /* SQUID_SRC_DISKIO_AIO_AIODISKIOSTRATEGY_H */
 
@@ -0,0 +1,31 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libAIO.la
+
+libAIO_la_SOURCES = \
+	async_io.h \
+	AIODiskFile.cc \
+	AIODiskFile.h \
+	AIODiskIOModule.cc \
+	AIODiskIOModule.h \
+	AIODiskIOStrategy.cc \
+	AIODiskIOStrategy.h
+
+if ENABLE_WIN32_AIO
+libAIO_la_SOURCES += \
+	aio_win32.cc \
+	aio_win32.h
+else
+EXTRA_DIST = \
+	aio_win32.cc \
+	aio_win32.h
+endif
+
@@ -9,7 +9,7 @@
 #ifndef __WIN32_AIO_H__
 #define __WIN32_AIO_H__
 
-#if USE_DISKIO_AIO
+#if HAVE_DISKIO_MODULE_AIO
 
 #ifndef off64_t
 typedef int64_t off64_t;
@@ -78,6 +78,6 @@ int aio_open(const char *, int);
 void aio_close(int);
 
 #endif /* _SQUID_WINDOWS_ */
-#endif /* USE_DISKIO_AIO */
+#endif /* HAVE_DISKIO_MODULE_AIO */
 #endif /* __WIN32_AIO_H__ */
 
@@ -9,10 +9,10 @@
 #ifndef __ASYNC_IO_H__
 #define __ASYNC_IO_H__
 
-#if USE_DISKIO_AIO
+#if HAVE_DISKIO_MODULE_AIO
 
 #if _SQUID_WINDOWS_
-#include "aio_win32.h"
+#include "DiskIO/AIO/aio_win32.h"
 #else
 #if HAVE_AIO_H
 #include <aio.h>
@@ -73,6 +73,6 @@ struct _async_queue {
     int aq_numpending;      /* Num of pending ops */
 };
 
-#endif /* USE_DISKIO_AIO */
+#endif /* HAVE_DISKIO_MODULE_AIO */
 #endif /* __ASYNC_IO_H_ */
 
@@ -0,0 +1,19 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libBlocking.la
+
+libBlocking_la_SOURCES = \
+	BlockingDiskIOModule.cc \
+	BlockingDiskIOModule.h \
+	BlockingFile.cc \
+	BlockingFile.h \
+	BlockingIOStrategy.cc \
+	BlockingIOStrategy.h
@@ -348,8 +348,11 @@ DiskdFile::readDone(diomsg * M)
     ReadRequest::Pointer readRequest = dynamic_cast<ReadRequest *>(M->requestor);
 
     /* remove the free protection */
-    if (readRequest != NULL)
-        readRequest->unlock();
+    if (readRequest != NULL) {
+        const uint32_t lcount = readRequest->unlock();
+        if (lcount == 0)
+            debugs(79, DBG_IMPORTANT, "invariant check failed: readRequest reference count is 0");
+    }
 
     if (M->status < 0) {
         ++diskd_stats.read.fail;
@@ -372,9 +375,13 @@ DiskdFile::writeDone(diomsg *M)
     debugs(79, 3, "storeDiskdWriteDone: status " << M->status);
     assert (M->requestor);
     WriteRequest::Pointer writeRequest = dynamic_cast<WriteRequest *>(M->requestor);
+
     /* remove the free protection */
-    if (writeRequest != NULL)
-        writeRequest->unlock();
+    if (writeRequest != NULL) {
+        const uint32_t lcount = writeRequest->unlock();
+        if (lcount == 0)
+            debugs(79, DBG_IMPORTANT, "invariant check failed: writeRequest reference count is 0");
+    }
 
     if (M->status < 0) {
         errorOccured = true;
@@ -19,17 +19,13 @@ class SharedMemory
 
 public:
     void put(ssize_t);
-
     void *get(ssize_t *);
-
     void init(int ikey, int magic2);
+    SharedMemory() : nbufs(0), buf(nullptr), inuse_map(nullptr), id(0) {}
 
     int nbufs;
-
     char *buf;
-
     char *inuse_map;
-
     int id;
 };
 
@@ -0,0 +1,37 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libDiskDaemon.la
+libexec_PROGRAMS = diskd
+
+libDiskDaemon_la_SOURCES = \
+	diomsg.h \
+	DiskdAction.cc \
+	DiskdAction.h \
+	DiskdFile.cc \
+	DiskdFile.h \
+	DiskdIOStrategy.cc \
+	DiskdIOStrategy.h \
+	DiskDaemonDiskIOModule.cc \
+	DiskDaemonDiskIOModule.h
+
+diskd_SOURCES = diskd.cc
+nodist_diskd_SOURCES = time.cc
+diskd_LDADD = \
+	$(top_builddir)/lib/libmisccontainers.la \
+	$(top_builddir)/lib/libmiscencoding.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+
+time.cc: $(top_srcdir)/src/time.cc
+	cp $(top_srcdir)/src/time.cc time.cc
+
+CLEANFILES += time.cc
@@ -10,6 +10,24 @@
 
 #include "squid.h"
 #include "DiskIOModule.h"
+#if HAVE_DISKIO_MODULE_AIO
+#include "DiskIO/AIO/AIODiskIOModule.h"
+#endif
+#if HAVE_DISKIO_MODULE_BLOCKING
+#include "DiskIO/Blocking/BlockingDiskIOModule.h"
+#endif
+#if HAVE_DISKIO_MODULE_DISKDAEMON
+#include "DiskIO/DiskDaemon/DiskDaemonDiskIOModule.h"
+#endif
+#if HAVE_DISKIO_MODULE_DISKTHREADS
+#include "DiskIO/DiskThreads/DiskThreadsDiskIOModule.h"
+#endif
+#if HAVE_DISKIO_MODULE_IPCIO
+#include "DiskIO/IpcIo/IpcIoDiskIOModule.h"
+#endif
+#if HAVE_DISKIO_MODULE_DISKTHREADS
+#include "DiskIO/Mmapped/MmappedDiskIOModule.h"
+#endif
 
 std::vector<DiskIOModule*> *DiskIOModule::_Modules = NULL;
 
@@ -19,14 +37,31 @@ DiskIOModule::DiskIOModule()
 {
     /** We cannot call ModuleAdd(*this)
      * here as the virtual methods are not yet available.
-     * We leave that to PokeAllModules() later.
+     * We leave that to SetupAllModules() later.
      */
 }
 
 void
 DiskIOModule::SetupAllModules()
 {
-    DiskIOModule::PokeAllModules();
+#if HAVE_DISKIO_MODULE_AIO
+    AIODiskIOModule::GetInstance();
+#endif
+#if HAVE_DISKIO_MODULE_BLOCKING
+    BlockingDiskIOModule::GetInstance();
+#endif
+#if HAVE_DISKIO_MODULE_DISKDAEMON
+    DiskDaemonDiskIOModule::GetInstance();
+#endif
+#if HAVE_DISKIO_MODULE_DISKTHREADS
+    DiskThreadsDiskIOModule::GetInstance();
+#endif
+#if HAVE_DISKIO_MODULE_IPCIO
+    IpcIoDiskIOModule::GetInstance();
+#endif
+#if HAVE_DISKIO_MODULE_MMAPPED
+    MmappedDiskIOModule::GetInstance();
+#endif
 
     for (iterator i = GetModules().begin(); i != GetModules().end(); ++i)
         /* Call the FS to set up capabilities and initialize the FS driver */
@@ -21,13 +21,11 @@ class DiskIOModule
 {
 
 public:
+    /** Poke all compiled modules for self-setup */
     static void SetupAllModules();
     static void ModuleAdd(DiskIOModule &);
     static void FreeAllModules();
 
-    /** Poke all compiled modules for self-setup */
-    static void PokeAllModules();
-
     static DiskIOModule *Find(char const *type);
 
     /** Find *any* usable disk module. This will look for the 'best'
@@ -0,0 +1,32 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libDiskThreads.la
+
+libDiskThreads_la_SOURCES = \
+	async_io.cc \
+	CommIO.cc \
+	CommIO.h \
+	DiskThreads.h \
+	DiskThreadsDiskFile.cc \
+	DiskThreadsDiskFile.h \
+	DiskThreadsDiskIOModule.cc \
+	DiskThreadsDiskIOModule.h \
+	DiskThreadsIOStrategy.cc \
+	DiskThreadsIOStrategy.h
+
+if ENABLE_WIN32_AIOPS
+libDiskThreads_la_SOURCES += aiops_win32.cc
+EXTRA_DIST = aiops.cc
+else
+libDiskThreads_la_SOURCES += aiops.cc
+EXTRA_DIST = aiops_win32.cc
+endif
+
@@ -506,13 +506,13 @@ squidaio_queue_request(squidaio_request_t * request)
     }
 
     if (request_queue2.head) {
-        static int filter = 0;
-        static int filter_limit = 8;
+        static uint64_t filter = 0;
+        static uint64_t filter_limit = 8192;
 
         if (++filter >= filter_limit) {
             filter_limit += filter;
             filter = 0;
-            debugs(43, DBG_IMPORTANT, "squidaio_queue_request: WARNING - Queue congestion");
+            debugs(43, DBG_IMPORTANT, "squidaio_queue_request: WARNING - Queue congestion (growing to " << filter_limit << ")");
         }
     }
 
@@ -582,13 +582,13 @@ squidaio_queue_request(squidaio_request_t * request)
     }
 
     if (request_queue2.head) {
-        static int filter = 0;
-        static int filter_limit = 8;
+        static uint64_t filter = 0;
+        static uint64_t filter_limit = 8196;
 
         if (++filter >= filter_limit) {
             filter_limit += filter;
             filter = 0;
-            debugs(43, DBG_IMPORTANT, "squidaio_queue_request: WARNING - Queue congestion");
+            debugs(43, DBG_IMPORTANT, "squidaio_queue_request: WARNING - Queue congestion (growing to " << filter_limit << ")");
         }
     }
 
@@ -45,7 +45,7 @@ static const int QueueCapacity = 1024;
 const double IpcIoFile::Timeout = 7; // seconds;  XXX: ALL,9 may require more
 IpcIoFile::IpcIoFileList IpcIoFile::WaitingForOpen;
 IpcIoFile::IpcIoFilesMap IpcIoFile::IpcIoFiles;
-std::auto_ptr<IpcIoFile::Queue> IpcIoFile::queue;
+std::unique_ptr<IpcIoFile::Queue> IpcIoFile::queue;
 
 bool IpcIoFile::DiskerHandleMoreRequestsScheduled = false;
 
@@ -113,8 +113,7 @@ IpcIoFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
             IpcIoFiles.insert(std::make_pair(diskId, this)).second;
         Must(inserted);
 
-        queue->localRateLimit() =
-            static_cast<Ipc::QueueReader::Rate::Value>(config.ioRate);
+        queue->localRateLimit().store(config.ioRate);
 
         Ipc::HereIamMessage ann(Ipc::StrandCoord(KidIdentifier, getpid()));
         ann.strand.tag = dbName;
@@ -396,7 +395,7 @@ IpcIoFile::canWait() const
     const int oldestWait = tvSubMsec(oldestIo.start, current_time);
 
     int rateWait = -1; // time in millisecons
-    const Ipc::QueueReader::Rate::Value ioRate = queue->rateLimit(diskId);
+    const int ioRate = queue->rateLimit(diskId).load();
     if (ioRate > 0) {
         // if there are N requests pending, the new one will wait at
         // least N/max-swap-rate seconds
@@ -750,7 +749,7 @@ IpcIoFile::DiskerHandleMoreRequests(void *source)
 bool
 IpcIoFile::WaitBeforePop()
 {
-    const Ipc::QueueReader::Rate::Value ioRate = queue->localRateLimit();
+    const int ioRate = queue->localRateLimit().load();
     const double maxRate = ioRate/1e3; // req/ms
 
     // do we need to enforce configured I/O rate?
@@ -140,7 +140,7 @@ class IpcIoFile: public DiskFile
     static IpcIoFilesMap IpcIoFiles;
 
     typedef Ipc::FewToFewBiQueue Queue;
-    static std::auto_ptr<Queue> queue; ///< IPC queue
+    static std::unique_ptr<Queue> queue; ///< IPC queue
 
     /// whether we are waiting for an event to handle still queued I/O requests
     static bool DiskerHandleMoreRequestsScheduled;
@@ -0,0 +1,19 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libIpcIo.la
+
+libIpcIo_la_SOURCES = \
+	IpcIoDiskIOModule.cc \
+	IpcIoDiskIOModule.h \
+	IpcIoFile.cc \
+	IpcIoFile.h \
+	IpcIoIOStrategy.cc \
+	IpcIoIOStrategy.h
@@ -0,0 +1,61 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+SUBDIRS=
+DIST_SUBDIRS= AIO Blocking DiskDaemon DiskThreads IpcIo Mmapped
+
+noinst_LTLIBRARIES = libdiskio.la
+
+libdiskio_la_SOURCES = \
+	DiskFile.h \
+	DiskIOModule.cc \
+	DiskIOModule.h \
+	DiskIOStrategy.h \
+	IORequestor.h \
+	ReadRequest.cc \
+	ReadRequest.h \
+	WriteRequest.cc \
+	WriteRequest.h
+
+# Custom DiskIO modules (if any):
+libdiskio_la_LIBADD = $(DISK_LIBS)
+
+# Optional DiskIO modules:
+
+if ENABLE_DISKIO_AIO
+SUBDIRS += AIO
+libdiskio_la_LIBADD += AIO/libAIO.la $(AIOLIB)
+endif
+
+if ENABLE_DISKIO_BLOCKING
+SUBDIRS += Blocking
+libdiskio_la_LIBADD += Blocking/libBlocking.la
+endif
+
+if ENABLE_DISKIO_DISKDAEMON
+SUBDIRS += DiskDaemon
+libdiskio_la_LIBADD += DiskDaemon/libDiskDaemon.la
+endif
+
+if ENABLE_DISKIO_DISKTHREADS
+SUBDIRS += DiskThreads
+libdiskio_la_LIBADD += DiskThreads/libDiskThreads.la $(LIBPTHREADS)
+endif
+
+if ENABLE_DISKIO_IPCIO
+SUBDIRS += IpcIo
+libdiskio_la_LIBADD += IpcIo/libIpcIo.la
+endif
+
+if ENABLE_DISKIO_MMAPPED
+SUBDIRS += Mmapped
+libdiskio_la_LIBADD += Mmapped/libMmapped.la
+endif
+
@@ -0,0 +1,19 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libMmapped.la
+
+libMmapped_la_SOURCES = \
+	MmappedDiskIOModule.cc \
+	MmappedDiskIOModule.h \
+	MmappedFile.cc \
+	MmappedFile.h \
+	MmappedIOStrategy.cc \
+	MmappedIOStrategy.h
@@ -1,25 +0,0 @@
-#!/bin/sh
-#
-## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
-##
-## Squid software is distributed under GPLv2+ license and includes
-## contributions from numerous individuals and organizations.
-## Please see the COPYING and CONTRIBUTORS files for details.
-##
-
-echo "/* automatically generated by $0 $*"
-echo " * do not edit"
-echo " */"
-cat `dirname $0`/../../scripts/boilerplate.h
-echo "#include \"squid.h\""
-echo "#include \"DiskIO/DiskIOModule.h\""
-for module in "$@"; do
-   echo "#include \"DiskIO/${module}/${module}DiskIOModule.h\""
-done
-echo ""
-echo "void DiskIOModule::PokeAllModules(void)"
-echo "{"
-for module in "$@"; do
-   echo "    ${module}DiskIOModule::GetInstance();"
-done
-echo "}"
@@ -400,7 +400,7 @@ FwdState::startConnectionOrFail()
         // Done here before anything else so the errors get logged for
         // this server link regardless of what happens when connecting to it.
         // IF sucessfuly connected this top destination will become the serverConnection().
-        request->hier.note(serverDestinations[0], request->GetHost());
+        request->hier.note(serverDestinations[0], request->url.host());
         request->clearError();
 
         connectStart();
@@ -691,10 +691,14 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, in
 
 #if USE_OPENSSL
     if (!request->flags.pinned) {
-        if ((serverConnection()->getPeer() && serverConnection()->getPeer()->secure.encryptTransport) ||
-                (!serverConnection()->getPeer() && request->url.getScheme() == AnyP::PROTO_HTTPS) ||
-                request->flags.sslPeek) {
-
+        const CachePeer *p = serverConnection()->getPeer();
+        const bool peerWantsTls = p && p->secure.encryptTransport;
+        // userWillSslToPeerForUs assumes CONNECT == HTTPS
+        const bool userWillTlsToPeerForUs = p && p->options.originserver &&
+                                            request->method == Http::METHOD_CONNECT;
+        const bool needTlsToPeer = peerWantsTls && !userWillTlsToPeerForUs;
+        const bool needTlsToOrigin = !p && request->url.getScheme() == AnyP::PROTO_HTTPS;
+        if (needTlsToPeer || needTlsToOrigin || request->flags.sslPeek) {
             HttpRequest::Pointer requestPointer = request;
             AsyncCall::Pointer callback = asyncCall(17,4,
                                                     "FwdState::ConnectedToPeer",
@@ -790,7 +794,9 @@ FwdState::connectStart()
 
     request->hier.startPeerClock();
 
-    if (serverDestinations[0]->getPeer() && request->flags.sslBumped) {
+    // Do not fowrward bumped connections to parent proxy unless it is an
+    // origin server
+    if (serverDestinations[0]->getPeer() && !serverDestinations[0]->getPeer()->options.originserver && request->flags.sslBumped) {
         debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request);
         fail(anErr);
@@ -848,7 +854,7 @@ FwdState::connectStart()
     // Use pconn to avoid opening a new connection.
     const char *host = NULL;
     if (!serverDestinations[0]->getPeer())
-        host = request->GetHost();
+        host = request->url.host();
 
     Comm::ConnectionPointer temp;
     // Avoid pconns after races so that the same client does not suffer twice.
@@ -926,7 +932,7 @@ FwdState::dispatch()
 
     EBIT_SET(entry->flags, ENTRY_DISPATCHED);
 
-    netdbPingSite(request->GetHost());
+    netdbPingSite(request->url.host());
 
     /* Retrieves remote server TOS or MARK value, and stores it as part of the
      * original client request FD object. It is later used to forward
@@ -39,11 +39,11 @@ HttpBody::setMb(MemBuf * mb_)
 }
 
 void
-HttpBody::packInto(Packer * p) const
+HttpBody::packInto(Packable * p) const
 {
     assert(p);
 
     if (mb->contentSize())
-        packerAppend(p, mb->content(), mb->contentSize());
+        p->append(mb->content(), mb->contentSize());
 }
 
@@ -10,7 +10,6 @@
 #define HTTPBODY_H_
 
 #include "MemBuf.h"
-class Packer;
 
 /** Representation of a short predetermined message
  *
@@ -28,11 +27,12 @@ class HttpBody
      * by the HttpBody.
      */
     void setMb(MemBuf *);
-    /** output the HttpBody contents into the supplied packer
+
+    /** output the HttpBody contents into the supplied container
      *
      * \note content is not cleared by the output operation
      */
-    void packInto(Packer *) const;
+    void packInto(Packable *) const;
 
     /// clear the HttpBody content
     void clear();
@@ -251,7 +251,7 @@ HttpHdrCc::parse(const String & str)
 }
 
 void
-HttpHdrCc::packInto(Packer * p) const
+HttpHdrCc::packInto(Packable * p) const
 {
     // optimization: if the mask is empty do nothing
     if (mask==0)
@@ -265,24 +265,24 @@ HttpHdrCc::packInto(Packer * p) const
         if (isSet(flag) && flag != CC_OTHER) {
 
             /* print option name for all options */
-            packerPrintf(p, (pcount ? ", %s": "%s") , CcAttrs[flag].name);
+            p->appendf((pcount ? ", %s": "%s") , CcAttrs[flag].name);
 
             /* for all options having values, "=value" after the name */
             switch (flag) {
             case CC_MAX_AGE:
-                packerPrintf(p, "=%d", (int) maxAge());
+                p->appendf("=%d", maxAge());
                 break;
             case CC_S_MAXAGE:
-                packerPrintf(p, "=%d", (int) sMaxAge());
+                p->appendf("=%d", sMaxAge());
                 break;
             case CC_MAX_STALE:
                 /* max-stale's value is optional.
                   If we didn't receive it, don't send it */
                 if (maxStale()!=MAX_STALE_ANY)
-                    packerPrintf(p, "=%d", (int) maxStale());
+                    p->appendf("=%d", maxStale());
                 break;
             case CC_MIN_FRESH:
-                packerPrintf(p, "=%d", (int) minFresh());
+                p->appendf("=%d", minFresh());
                 break;
             default:
                 /* do nothing, directive was already printed */
@@ -294,8 +294,7 @@ HttpHdrCc::packInto(Packer * p) const
     }
 
     if (other.size() != 0)
-        packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                     SQUIDSTRINGPRINT(other));
+        p->appendf((pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH), SQUIDSTRINGPRINT(other));
 }
 
 void
@@ -13,7 +13,7 @@
 #include "mem/forward.h"
 #include "SquidString.h"
 
-class Packer;
+class Packable;
 
 /** Http Cache-Control header representation
  *
@@ -144,7 +144,7 @@ class HttpHdrCc
     /// check whether the attribute value supplied by id is set
     _SQUID_INLINE_ bool isSet(http_hdr_cc_type id) const;
 
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
 
     /** bit-mask representing what header values are set among those
      * recognized by squid.
@@ -9,6 +9,7 @@
 /* DEBUG: section 68    HTTP Content-Range Header */
 
 #include "squid.h"
+#include "base/Packable.h"
 #include "Debug.h"
 #include "enums.h"
 #include "HttpHdrContRange.h"
@@ -98,16 +99,15 @@ httpHdrRangeRespSpecParseInit(HttpHdrRangeSpec * spec, const char *field, int fl
 }
 
 static void
-httpHdrRangeRespSpecPackInto(const HttpHdrRangeSpec * spec, Packer * p)
+httpHdrRangeRespSpecPackInto(const HttpHdrRangeSpec * spec, Packable * p)
 {
     /* Ensure typecast is safe */
     assert (spec->length >= 0);
 
     if (!known_spec(spec->offset) || !known_spec(spec->length))
-        packerPrintf(p, "*");
+        p->append("*", 1);
     else
-        packerPrintf(p, "bytes %" PRId64 "-%" PRId64,
-                     spec->offset, spec->offset + spec->length - 1);
+        p->appendf("bytes %" PRId64 "-%" PRId64, spec->offset, spec->offset + spec->length - 1);
 }
 
 /*
@@ -200,17 +200,17 @@ httpHdrContRangeDup(const HttpHdrContRange * range)
 }
 
 void
-httpHdrContRangePackInto(const HttpHdrContRange * range, Packer * p)
+httpHdrContRangePackInto(const HttpHdrContRange * range, Packable * p)
 {
     assert(range && p);
     httpHdrRangeRespSpecPackInto(&range->spec, p);
     /* Ensure typecast is safe */
     assert (range->elength >= 0);
 
     if (!known_spec(range->elength))
-        packerPrintf(p, "/*");
+        p->append("/*", 2);
     else
-        packerPrintf(p, "/%" PRId64, range->elength);
+        p->appendf("/%" PRId64, range->elength);
 }
 
 void
@@ -31,7 +31,7 @@ HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
 int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
 void httpHdrContRangeDestroy(HttpHdrContRange * crange);
 HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
-void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
+void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packable * p);
 /** inits with given spec */
 void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
 void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
@@ -105,15 +105,14 @@ HttpHdrRangeSpec::parseInit(const char *field, int flen)
 }
 
 void
-HttpHdrRangeSpec::packInto(Packer * packer) const
+HttpHdrRangeSpec::packInto(Packable * p) const
 {
     if (!known_spec(offset))    /* suffix */
-        packerPrintf(packer, "-%" PRId64,  length);
+        p->appendf("-%" PRId64, length);
     else if (!known_spec(length))       /* trailer */
-        packerPrintf(packer, "%" PRId64 "-", offset);
+        p->appendf("%" PRId64 "-", offset);
     else            /* range */
-        packerPrintf(packer, "%" PRId64 "-%" PRId64,
-                     offset, offset + length - 1);
+        p->appendf("%" PRId64 "-%" PRId64, offset, offset + length - 1);
 }
 
 void
@@ -303,13 +302,13 @@ HttpHdrRange::end() const
 }
 
 void
-HttpHdrRange::packInto(Packer * packer) const
+HttpHdrRange::packInto(Packable * packer) const
 {
     const_iterator pos = begin();
 
     while (pos != end()) {
         if (pos != begin())
-            packerAppend(packer, ",", 1);
+            packer->append(",", 1);
 
         (*pos)->packInto(packer);
 
@@ -235,7 +235,7 @@ HttpHdrSc::HttpHdrSc(const HttpHdrSc &sc)
 }
 
 void
-HttpHdrScTarget::packInto(Packer * p) const
+HttpHdrScTarget::packInto(Packable * p) const
 {
     http_hdr_sc_type flag;
     int pcount = 0;
@@ -245,27 +245,27 @@ HttpHdrScTarget::packInto(Packer * p) const
         if (isSet(flag) && flag != SC_OTHER) {
 
             /* print option name */
-            packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                         SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
+            p->appendf((pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
+                       SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
 
             /* handle options with values */
 
             if (flag == SC_MAX_AGE)
-                packerPrintf(p, "=%d", (int) max_age);
+                p->appendf("=%d", (int) max_age);
 
             if (flag == SC_CONTENT)
-                packerPrintf(p, "=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(content_));
+                p->appendf("=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(content_));
 
             ++pcount;
         }
     }
 
     if (hasTarget())
-        packerPrintf (p, ";" SQUIDSTRINGPH, SQUIDSTRINGPRINT(target));
+        p->appendf(";" SQUIDSTRINGPH, SQUIDSTRINGPRINT(target));
 }
 
 void
-HttpHdrSc::packInto(Packer * p) const
+HttpHdrSc::packInto(Packable * p) const
 {
     dlink_node *node;
     assert(p);
@@ -25,7 +25,7 @@ class HttpHdrSc
     ~HttpHdrSc();
 
     bool parse(const String *str);
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
     void updateStats(StatHist *) const;
     HttpHdrScTarget * getMergedTarget (const char *ourtarget); //todo: make const?
     void setMaxAge(char const *target, int max_age);
@@ -15,8 +15,8 @@
 #include "SquidString.h"
 #include "typedefs.h"
 
+class Packable;
 class StatHist;
-class Packer;
 class StoreEntry;
 
 /** Representation of HTTP Surogate-Control header field targeted directive
@@ -82,7 +82,7 @@ class HttpHdrScTarget
     String Target() const { return target; }
 
     void mergeWith(const HttpHdrScTarget * new_sc);
-    void packInto (Packer *p) const;
+    void packInto(Packable *p) const;
     void updateStats(StatHist *) const;
 
 private:
@@ -735,7 +735,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
 
 /* packs all the entries using supplied packer */
 void
-HttpHeader::packInto(Packer * p, bool mask_sensitive_info) const
+HttpHeader::packInto(Packable * p, bool mask_sensitive_info) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     const HttpHeaderEntry *e;
@@ -765,8 +765,8 @@ HttpHeader::packInto(Packer * p, bool mask_sensitive_info) const
             break;
         }
         if (maskThisEntry) {
-            packerAppend(p, e->name.rawBuf(), e->name.size());
-            packerAppend(p, ": ** NOT DISPLAYED **\r\n", 23);
+            p->append(e->name.rawBuf(), e->name.size());
+            p->append(": ** NOT DISPLAYED **\r\n", 23);
         } else {
             e->packInto(p);
         }
@@ -1230,76 +1230,64 @@ HttpHeader::putAuth(const char *auth_scheme, const char *realm)
 void
 HttpHeader::putCc(const HttpHdrCc * cc)
 {
-    MemBuf mb;
-    Packer p;
     assert(cc);
     /* remove old directives if any */
     delById(HDR_CACHE_CONTROL);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    cc->packInto(&p);
+    cc->packInto(&mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_CACHE_CONTROL, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
 void
 HttpHeader::putContRange(const HttpHdrContRange * cr)
 {
-    MemBuf mb;
-    Packer p;
     assert(cr);
     /* remove old directives if any */
     delById(HDR_CONTENT_RANGE);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    httpHdrContRangePackInto(cr, &p);
+    httpHdrContRangePackInto(cr, &mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_CONTENT_RANGE, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
 void
 HttpHeader::putRange(const HttpHdrRange * range)
 {
-    MemBuf mb;
-    Packer p;
     assert(range);
     /* remove old directives if any */
     delById(HDR_RANGE);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    range->packInto(&p);
+    range->packInto(&mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_RANGE, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
 void
 HttpHeader::putSc(HttpHdrSc *sc)
 {
-    MemBuf mb;
-    Packer p;
     assert(sc);
     /* remove old directives if any */
     delById(HDR_SURROGATE_CONTROL);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    sc->packInto(&p);
+    sc->packInto(&mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_SURROGATE_CONTROL, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
@@ -1686,13 +1674,13 @@ HttpHeaderEntry::clone() const
 }
 
 void
-HttpHeaderEntry::packInto(Packer * p) const
+HttpHeaderEntry::packInto(Packable * p) const
 {
     assert(p);
-    packerAppend(p, name.rawBuf(), name.size());
-    packerAppend(p, ": ", 2);
-    packerAppend(p, value.rawBuf(), value.size());
-    packerAppend(p, "\r\n", 2);
+    p->append(name.rawBuf(), name.size());
+    p->append(": ", 2);
+    p->append(value.rawBuf(), value.size());
+    p->append("\r\n", 2);
 }
 
 int
@@ -22,7 +22,7 @@ class HttpHdrCc;
 class HttpHdrContRange;
 class HttpHdrRange;
 class HttpHdrSc;
-class Packer;
+class Packable;
 class StoreEntry;
 class SBuf;
 
@@ -87,7 +87,7 @@ class HttpHeaderEntry
     ~HttpHeaderEntry();
     static HttpHeaderEntry *parse(const char *field_start, const char *field_end);
     HttpHeaderEntry *clone() const;
-    void packInto(Packer *p) const;
+    void packInto(Packable *p) const;
     int getInt() const;
     int64_t getInt64() const;
 
@@ -117,7 +117,7 @@ class HttpHeader
     void compact();
     int reset();
     int parse(const char *header_start, size_t len);
-    void packInto(Packer * p, bool mask_sensitive_info=false) const;
+    void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
     HttpHeaderEntry *findEntry(http_hdr_type id) const;
     int delByName(const char *name);
@@ -10,13 +10,14 @@
 #define SQUID_HTTPHEADERRANGE_H
 
 #include "mem/forward.h"
-#include "Packer.h"
 #include "Range.h"
 #include "SquidString.h"
 
 #include <vector>
 
 class HttpReply;
+class Packable;
+
 /* http byte-range-spec */
 
 class HttpHdrRangeSpec
@@ -33,7 +34,7 @@ class HttpHdrRangeSpec
     bool parseInit(const char *field, int flen);
     int canonize(int64_t clen);
     void outputInfo( char const *note) const;
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
     bool mergeWith(const HttpHdrRangeSpec * donor);
     int64_t offset;
     int64_t length;
@@ -70,7 +71,7 @@ class HttpHdrRange
     int canonize(HttpReply *rep);
     /* returns true if ranges are valid; inits HttpHdrRange */
     bool parseInit(const String * range_spec);
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
     /* other */
     bool isComplex() const;
     bool willBeComplex() const;
@@ -114,7 +114,7 @@ httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list
 {
     MemBuf mb;
     mb.init();
-    mb.vPrintf(fmt, vargs);
+    mb.vappendf(fmt, vargs);
     hdr->putStr(id, mb.buf);
     mb.clean();
 }
@@ -312,11 +312,11 @@ HttpMsg::persistent() const
     }
 }
 
-void HttpMsg::packInto(Packer *p, bool full_uri) const
+void HttpMsg::packInto(Packable *p, bool full_uri) const
 {
     packFirstLineInto(p, full_uri);
     header.packInto(p);
-    packerAppend(p, "\r\n", 2);
+    p->append("\r\n", 2);
 }
 
 void HttpMsg::hdrCacheInit()
@@ -331,9 +331,6 @@ void HttpMsg::hdrCacheInit()
  */
 void HttpMsg::firstLineBuf(MemBuf& mb)
 {
-    Packer p;
-    packerToMemInit(&p, &mb);
-    packFirstLineInto(&p, true);
-    packerClean(&p);
+    packFirstLineInto(&mb, true);
 }
 
@@ -28,7 +28,7 @@ class HttpMsg : public RefCountable
 
     virtual void reset() = 0; // will have body when http*Clean()s are gone
 
-    void packInto(Packer * p, bool full_uri) const;
+    void packInto(Packable * p, bool full_uri) const;
 
     ///< produce a message copy, except for a few connection-specific settings
     virtual HttpMsg *clone() const = 0; ///< \todo rename: not a true copy?
@@ -91,7 +91,7 @@ class HttpMsg : public RefCountable
      */
     virtual bool sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error) = 0;
 
-    virtual void packFirstLineInto(Packer * p, bool full_uri) const = 0;
+    virtual void packFirstLineInto(Packable * p, bool full_uri) const = 0;
 
     virtual bool parseFirstLine(const char *blk_start, const char *blk_end) = 0;
 
@@ -108,15 +108,15 @@ HttpReply::clean()
 }
 
 void
-HttpReply::packHeadersInto(Packer * p) const
+HttpReply::packHeadersInto(Packable * p) const
 {
     sline.packInto(p);
     header.packInto(p);
-    packerAppend(p, "\r\n", 2);
+    p->append("\r\n", 2);
 }
 
 void
-HttpReply::packInto(Packer * p)
+HttpReply::packInto(Packable * p)
 {
     packHeadersInto(p);
     body.packInto(p);
@@ -127,12 +127,8 @@ MemBuf *
 HttpReply::pack()
 {
     MemBuf *mb = new MemBuf;
-    Packer p;
-
     mb->init();
-    packerToMemInit(&p, mb);
-    packInto(&p);
-    packerClean(&p);
+    packInto(mb);
     return mb;
 }
 
@@ -100,7 +100,7 @@ class HttpReply: public HttpMsg
 
     int validatorsMatch (HttpReply const *other) const;
 
-    void packHeadersInto(Packer * p) const;
+    void packHeadersInto(Packable * p) const;
 
     /** Clone this reply.
      *  Could be done as a copy-contructor but we do not want to accidently copy a HttpReply..
@@ -120,7 +120,7 @@ class HttpReply: public HttpMsg
 
     void hdrCacheClean();
 
-    void packInto(Packer * p);
+    void packInto(Packable * p);
 
     /* ez-routines */
     /** \return construct 304 reply and pack it into a MemBuf */
@@ -139,7 +139,7 @@ class HttpReply: public HttpMsg
     mutable int64_t bodySizeMax; /**< cached result of calcMaxBodySize */
 
 protected:
-    virtual void packFirstLineInto(Packer * p, bool) const { sline.packInto(p); }
+    virtual void packFirstLineInto(Packable * p, bool) const { sline.packInto(p); }
 
     virtual bool parseFirstLine(const char *start, const char *end);
 };
@@ -61,22 +61,17 @@ HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProt
 {
     method = aMethod;
     url.setScheme(aProtocol);
-    urlpath = aUrlpath;
+    url.path(aUrlpath);
 }
 
 void
 HttpRequest::init()
 {
     method = Http::METHOD_NONE;
     url.clear();
-    urlpath = NULL;
-    host[0] = '\0';
-    host_is_numeric = -1;
 #if USE_AUTH
     auth_user_request = NULL;
 #endif
-    port = 0;
-    canonical = NULL;
     memset(&flags, '\0', sizeof(flags));
     range = NULL;
     ims = -1;
@@ -124,12 +119,9 @@ HttpRequest::clean()
 #if USE_AUTH
     auth_user_request = NULL;
 #endif
-    safe_free(canonical);
-
     safe_free(vary_headers);
 
     url.clear();
-    urlpath.clean();
 
     header.clean();
 
@@ -176,7 +168,8 @@ HttpRequest::reset()
 HttpRequest *
 HttpRequest::clone() const
 {
-    HttpRequest *copy = new HttpRequest(method, url.getScheme(), urlpath.termedBuf());
+    HttpRequest *copy = new HttpRequest();
+    copy->method = method;
     // TODO: move common cloning clone to Msg::copyTo() or copy ctor
     copy->header.append(&header);
     copy->hdrCacheInit();
@@ -185,13 +178,11 @@ HttpRequest::clone() const
     copy->pstate = pstate; // TODO: should we assert a specific state here?
     copy->body_pipe = body_pipe;
 
+    copy->url.setScheme(url.getScheme());
     copy->url.userInfo(url.userInfo());
-    strncpy(copy->host, host, sizeof(host)); // SQUIDHOSTNAMELEN
-    copy->host_addr = host_addr;
-
-    copy->port = port;
-    // urlPath handled in ctor
-    copy->canonical = canonical ? xstrdup(canonical) : NULL;
+    copy->url.host(url.host());
+    copy->url.port(url.port());
+    copy->url.path(url.path());
 
     // range handled in hdrCacheInit()
     copy->ims = ims;
@@ -365,44 +356,42 @@ HttpRequest::parseHeader(Http1::RequestParser &hp)
 void
 HttpRequest::swapOut(StoreEntry * e)
 {
-    Packer p;
     assert(e);
-    packerToStoreInit(&p, e);
-    pack(&p);
-    packerClean(&p);
+    e->buffer();
+    pack(e);
 }
 
 /* packs request-line and headers, appends <crlf> terminator */
 void
-HttpRequest::pack(Packer * p)
+HttpRequest::pack(Packable * p)
 {
     assert(p);
     /* pack request-line */
-    packerPrintf(p, SQUIDSBUFPH " " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
-                 SQUIDSBUFPRINT(method.image()), SQUIDSTRINGPRINT(urlpath),
-                 http_ver.major, http_ver.minor);
+    p->appendf(SQUIDSBUFPH " " SQUIDSBUFPH " HTTP/%d.%d\r\n",
+               SQUIDSBUFPRINT(method.image()), SQUIDSBUFPRINT(url.path()),
+               http_ver.major, http_ver.minor);
     /* headers */
     header.packInto(p);
     /* trailer */
-    packerAppend(p, "\r\n", 2);
+    p->append("\r\n", 2);
 }
 
 /*
  * A wrapper for debugObj()
  */
 void
-httpRequestPack(void *obj, Packer *p)
+httpRequestPack(void *obj, Packable *p)
 {
     HttpRequest *request = static_cast<HttpRequest*>(obj);
     request->pack(p);
 }
 
 /* returns the length of request line + headers + crlf */
 int
-HttpRequest::prefixLen()
+HttpRequest::prefixLen() const
 {
     return method.image().length() + 1 +
-           urlpath.size() + 1 +
+           url.path().length() + 1 +
            4 + 1 + 3 + 2 +
            header.len + 2;
 }
@@ -497,24 +486,16 @@ HttpRequest::clearError()
     errDetail = ERR_DETAIL_NONE;
 }
 
-const char *HttpRequest::packableURI(bool full_uri) const
+void
+HttpRequest::packFirstLineInto(Packable * p, bool full_uri) const
 {
-    if (full_uri)
-        return urlCanonical((HttpRequest*)this);
-
-    if (urlpath.size())
-        return urlpath.termedBuf();
-
-    return "/";
-}
+    const SBuf tmp(full_uri ? effectiveRequestUri() : url.path());
 
-void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const
-{
     // form HTTP request-line
-    packerPrintf(p, SQUIDSBUFPH " %s HTTP/%d.%d\r\n",
-                 SQUIDSBUFPRINT(method.image()),
-                 packableURI(full_uri),
-                 http_ver.major, http_ver.minor);
+    p->appendf(SQUIDSBUFPH " " SQUIDSBUFPH " HTTP/%d.%d\r\n",
+               SQUIDSBUFPRINT(method.image()),
+               SQUIDSBUFPRINT(tmp),
+               http_ver.major, http_ver.minor);
 }
 
 /*
@@ -687,16 +668,22 @@ HttpRequest::pinnedConnection()
     return NULL;
 }
 
-const char *
+const SBuf
 HttpRequest::storeId()
 {
     if (store_id.size() != 0) {
-        debugs(73, 3, "sent back store_id:" << store_id);
-
-        return store_id.termedBuf();
+        debugs(73, 3, "sent back store_id: " << store_id);
+        return SBuf(store_id);
     }
-    debugs(73, 3, "sent back canonicalUrl:" << urlCanonical(this) );
+    debugs(73, 3, "sent back effectiveRequestUrl: " << effectiveRequestUri());
+    return effectiveRequestUri();
+}
 
-    return urlCanonical(this);
+const SBuf &
+HttpRequest::effectiveRequestUri() const
+{
+    if (method.id() == Http::METHOD_CONNECT)
+        return url.authority(true); // host:port
+    return url.absolute();
 }
 
@@ -10,7 +10,6 @@
 #define SQUID_HTTPREQUEST_H
 
 #include "base/CbcPointer.h"
-#include "Debug.h"
 #include "dns/forward.h"
 #include "err_type.h"
 #include "HierarchyLogEntry.h"
@@ -37,7 +36,7 @@
 class ConnStateData;
 
 /*  Http Request */
-void httpRequestPack(void *obj, Packer *p);
+void httpRequestPack(void *obj, Packable *p);
 
 class HttpHdrRange;
 
@@ -67,26 +66,6 @@ class HttpRequest: public HttpMsg
     /// whether the client is likely to be able to handle a 1xx reply
     bool canHandle1xx() const;
 
-    /* Now that we care what host contains it is better off being protected. */
-    /* HACK: These two methods are only inline to get around Makefile dependancies */
-    /*      caused by HttpRequest being used in places it really shouldn't.        */
-    /*      ideally they would be methods of URL instead. */
-    inline void SetHost(const char *src) {
-        host_addr.setEmpty();
-        host_addr = src;
-        if (host_addr.isAnyAddr()) {
-            xstrncpy(host, src, SQUIDHOSTNAMELEN);
-            host_is_numeric = 0;
-        } else {
-            host_addr.toHostStr(host, SQUIDHOSTNAMELEN);
-            debugs(23, 3, "HttpRequest::SetHost() given IP: " << host_addr);
-            host_is_numeric = 1;
-        }
-        safe_free(canonical); // force its re-build
-    };
-    inline const char* GetHost(void) const { return host; };
-    inline int GetHostIsNumeric(void) const { return host_is_numeric; };
-
 #if USE_ADAPTATION
     /// Returns possibly nil history, creating it if adapt. logging is enabled
     Adaptation::History::Pointer adaptLogHistory() const;
@@ -114,14 +93,9 @@ class HttpRequest: public HttpMsg
 
 public:
     HttpRequestMethod method;
-
-    // TODO expand to include all URI parts
-    URL url; ///< the request URI (scheme and userinfo only)
+    URL url; ///< the request URI
 
 private:
-    char host[SQUIDHOSTNAMELEN];
-    int host_is_numeric;
-
 #if USE_ADAPTATION
     mutable Adaptation::History::Pointer adaptHistory_; ///< per-HTTP transaction info
 #endif
@@ -130,15 +104,12 @@ class HttpRequest: public HttpMsg
 #endif
 
 public:
-    Ip::Address host_addr;
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
-    unsigned short port;
 
-    String urlpath;
-
-    char *canonical;
+    /// RFC 7230 section 5.5 - Effective Request URI
+    const SBuf &effectiveRequestUri() const;
 
     /**
      * If defined, store_id_program mapped the request URL to this ID.
@@ -216,13 +187,13 @@ class HttpRequest: public HttpMsg
 
     bool bodyNibbled() const; // the request has a [partially] consumed body
 
-    int prefixLen();
+    int prefixLen() const;
 
     void swapOut(StoreEntry * e);
 
-    void pack(Packer * p);
+    void pack(Packable * p);
 
-    static void httpRequestPack(void *obj, Packer *p);
+    static void httpRequestPack(void *obj, Packable *p);
 
     static HttpRequest * CreateFromUrlAndMethod(char * url, const HttpRequestMethod& method);
 
@@ -233,10 +204,9 @@ class HttpRequest: public HttpMsg
     /**
      * Returns the current StoreID for the request as a nul-terminated char*.
      * Always returns the current id for the request
-     * (either the request canonical url or modified ID by the helper).
-     * Does not return NULL.
+     * (either the effective request URI or modified ID by the helper).
      */
-    const char *storeId();
+    const SBuf storeId();
 
     /**
      * The client connection manager, if known;
@@ -250,12 +220,10 @@ class HttpRequest: public HttpMsg
     int64_t getRangeOffsetLimit(); /* the result of this function gets cached in rangeOffsetLimit */
 
 private:
-    const char *packableURI(bool full_uri) const;
-
     mutable int64_t rangeOffsetLimit;  /* caches the result of getRangeOffsetLimit */
 
 protected:
-    virtual void packFirstLineInto(Packer * p, bool full_uri) const;
+    virtual void packFirstLineInto(Packable * p, bool full_uri) const;
 
     virtual bool sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error);
 
@@ -123,7 +123,7 @@ void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pa
 icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-int icpUdpSend(int, const Ip::Address &, icp_common_t *, LogTags, int);
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, const LogTags &, int);
 
 /// \ingroup ServerProtocolICPAPI
 LogTags icpLogFromICPCode(icp_opcode opcode);
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "LogTags.h"
+
+// old deprecated tag strings
+const char * LogTags::Str_[] = {
+    "TAG_NONE",
+    "TCP_HIT",
+    "TCP_MISS",
+    "TCP_REFRESH_UNMODIFIED",
+    "TCP_REFRESH_FAIL_OLD",
+    "TCP_REFRESH_FAIL_ERR",
+    "TCP_REFRESH_MODIFIED",
+    "TCP_CLIENT_REFRESH_MISS",
+    "TCP_IMS_HIT",
+    "TCP_SWAPFAIL_MISS",
+    "TCP_NEGATIVE_HIT",
+    "TCP_MEM_HIT",
+    "TCP_DENIED",
+    "TCP_DENIED_REPLY",
+    "TCP_OFFLINE_HIT",
+    "TCP_REDIRECT",
+    "TCP_TUNNEL",
+    "UDP_HIT",
+    "UDP_MISS",
+    "UDP_DENIED",
+    "UDP_INVALID",
+    "UDP_MISS_NOFETCH",
+    "ICP_QUERY",
+    "TYPE_MAX"
+};
+
+/*
+ * This method is documented in http://wiki.squid-cache.org/SquidFaq/SquidLogs#Squid_result_codes
+ * Please keep the wiki up to date
+ */
+const char *
+LogTags::c_str() const
+{
+    static char buf[1024];
+    *buf = 0;
+    int pos = 0;
+
+    // source tags
+    if (oldType && oldType < LOG_TYPE_MAX)
+        pos += snprintf(buf, sizeof(buf), "%s",Str_[oldType]);
+    else
+        pos += snprintf(buf, sizeof(buf), "NONE");
+
+    // error tags
+    if (err.timedout)
+        pos += snprintf(buf+pos,sizeof(buf)-pos, "_TIMEDOUT");
+    if (err.aborted)
+        pos += snprintf(buf+pos,sizeof(buf)-pos, "_ABORTED");
+
+    return buf;
+}
+
+bool
+LogTags::isTcpHit() const
+{
+    return
+        (oldType == LOG_TCP_HIT) ||
+        (oldType == LOG_TCP_IMS_HIT) ||
+        (oldType == LOG_TCP_REFRESH_FAIL_OLD) ||
+        (oldType == LOG_TCP_REFRESH_UNMODIFIED) ||
+        (oldType == LOG_TCP_NEGATIVE_HIT) ||
+        (oldType == LOG_TCP_MEM_HIT) ||
+        (oldType == LOG_TCP_OFFLINE_HIT);
+}
+
@@ -42,29 +42,43 @@ typedef enum {
     LOG_UDP_MISS_NOFETCH,
     LOG_ICP_QUERY,
     LOG_TYPE_MAX
-} LogTags;
+} LogTags_ot;
 
-/// list of string representations for LogTags
-extern const char *LogTags_str[];
-
-/// determine if the log tag code indicates a cache HIT
-inline bool logTypeIsATcpHit(LogTags code)
+class LogTags
 {
-    return
-        (code == LOG_TCP_HIT) ||
-        (code == LOG_TCP_IMS_HIT) ||
-        (code == LOG_TCP_REFRESH_FAIL_OLD) ||
-        (code == LOG_TCP_REFRESH_UNMODIFIED) ||
-        (code == LOG_TCP_NEGATIVE_HIT) ||
-        (code == LOG_TCP_MEM_HIT) ||
-        (code == LOG_TCP_OFFLINE_HIT);
-}
+public:
+    LogTags(LogTags_ot t) : oldType(t) {assert(oldType < LOG_TYPE_MAX);}
+    LogTags &operator =(const LogTags_ot &t) {assert(t < LOG_TYPE_MAX); oldType = t; return *this;}
+
+    /// compute the status access.log field
+    const char *c_str() const;
+
+    /// determine if the log tag code indicates a cache HIT
+    bool isTcpHit() const;
+
+    /// error states terminating the transaction
+    struct Errors {
+        Errors() : timedout(false), aborted(false) {}
+
+        bool timedout; ///< tag: TIMEDOUT - terminated due to a lifetime or I/O timeout
+        bool aborted;  ///< tag: ABORTED  - other abnormal termination (e.g., I/O error)
+    } err;
+
+private:
+    /// list of string representations for LogTags_ot
+    static const char *Str_[];
+
+public: // XXX: only until client_db.cc stats are redesigned.
+
+    // deprecated LogTag enum value
+    LogTags_ot oldType;
+};
 
-/// iterator for LogTags enumeration
-inline LogTags &operator++ (LogTags &aLogType)
+/// iterator for LogTags_ot enumeration
+inline LogTags_ot &operator++ (LogTags_ot &aLogType)
 {
     int tmp = (int)aLogType;
-    aLogType = (LogTags)(++tmp);
+    aLogType = (LogTags_ot)(++tmp);
     return aLogType;
 }
 
@@ -44,8 +44,8 @@ LOADABLE_MODULES_SOURCES = \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS	= mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl
-DIST_SUBDIRS = mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl
+SUBDIRS	= mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl DiskIO
+DIST_SUBDIRS = mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl DiskIO
 
 if ENABLE_AUTH
 SUBDIRS += auth
@@ -89,14 +89,13 @@ DIST_SUBDIRS += adaptation
 
 if USE_ESI
 SUBDIRS += esi
-ESI_LOCAL_LIBS = \
+ESI_LIBS = \
 	esi/libesi.la \
-	$(top_builddir)/lib/libTrie/libTrie.a
-ESI_LIBS = $(ESI_LOCAL_LIBS) \
+	$(top_builddir)/lib/libTrie/libTrie.a \
 	$(XMLLIB) \
 	$(EXPATLIB)
 else
-ESI_LIBS = 
+ESI_LIBS =
 endif
 DIST_SUBDIRS += esi
 
@@ -176,32 +175,9 @@ else
 IPC_SOURCE = SquidIpc.h ipc.cc
 endif
 
-AIO_WIN32_ALL_SOURCES = \
-	DiskIO/AIO/aio_win32.cc \
-	DiskIO/AIO/aio_win32.h
-if ENABLE_WIN32_AIO
-AIO_WIN32_SOURCES = $(AIO_WIN32_ALL_SOURCES)
-else
-AIO_WIN32_SOURCES =
-endif
-
-if ENABLE_WIN32_AIOPS
-AIOPS_SOURCE = DiskIO/DiskThreads/aiops_win32.cc \
-	DiskIO/DiskThreads/CommIO.cc \
-	DiskIO/DiskThreads/CommIO.h
-else
-AIOPS_SOURCE = DiskIO/DiskThreads/aiops.cc \
-	DiskIO/DiskThreads/CommIO.cc \
-	DiskIO/DiskThreads/CommIO.h
-endif
-
-EXTRA_LIBRARIES = libAIO.a libBlocking.a libDiskDaemon.a libDiskThreads.a \
-	libMmapped.a libIpcIo.a
-noinst_LIBRARIES = $(DISK_LIBS)
 noinst_LTLIBRARIES = libsquid.la
 
 EXTRA_PROGRAMS = \
-	DiskIO/DiskDaemon/diskd \
 	unlinkd \
 	recv-announce \
 	tests/testUfs \
@@ -221,7 +197,6 @@ bin_PROGRAMS =
 
 
 libexec_PROGRAMS = \
-	$(DISK_PROGRAMS) \
 	$(UNLINKD)
 
 cf_gen_SOURCES = cf_gen.cc
@@ -236,25 +211,6 @@ AM_CPPFLAGS += -I$(top_builddir)/src
 
 ACL_REGISTRATION_SOURCES = AclRegs.cc AuthReg.cc
 
-DISKIO_SOURCE = \
-	DiskIO/DiskIOModule.cc \
-	DiskIO/ReadRequest.cc \
-	DiskIO/ReadRequest.h \
-	DiskIO/WriteRequest.cc \
-	DiskIO/WriteRequest.h \
-	DiskIO/DiskFile.h \
-	DiskIO/DiskIOStrategy.h \
-	DiskIO/IORequestor.h \
-	DiskIO/DiskIOModule.h \
-	DiskIO/ReadRequest.h
-
-DISKIO_GEN_SOURCE = \
-	DiskIO/DiskIOModules_gen.cc
-
-DiskIO/DiskIOModules_gen.cc: Makefile
-	$(SHELL) $(srcdir)/DiskIO/modules.sh $(DISK_MODULES) > DiskIO/DiskIOModules_gen.cc
-
-
 # common library for all the binaries and tests. This is kindof a catch all
 # and smaller libraries split from this are encouraged. Using lt convenience
 # libraries, dependencies should not be a problem either.
@@ -291,8 +247,6 @@ squid_SOURCES = \
 	carp.cc \
 	cbdata.cc \
 	cbdata.h \
-	ChunkedCodingParser.cc \
-	ChunkedCodingParser.h \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -330,7 +284,6 @@ squid_SOURCES = \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
-	$(DISKIO_SOURCE) \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
@@ -419,6 +372,7 @@ squid_SOURCES = \
 	$(LEAKFINDERSOURCE) \
 	SquidList.h \
 	SquidList.cc \
+	LogTags.cc \
 	LogTags.h \
 	lookup_t.h \
 	main.cc \
@@ -440,8 +394,6 @@ squid_SOURCES = \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
-	Packer.h \
 	Parsing.cc \
 	Parsing.h \
 	$(XPROF_STATS_SOURCE) \
@@ -553,7 +505,6 @@ squid_SOURCES = \
 	$(WINSVC_SOURCE)
 
 EXTRA_squid_SOURCES = \
-	$(AIO_WIN32_ALL_SOURCES) \
 	$(all_AUTHMODULES) \
 	ConfigOption.h \
 	$(DELAY_POOL_ALL_SOURCE) \
@@ -585,15 +536,13 @@ BUILT_SOURCES = \
 	globals.cc \
 	hier_code.cc \
 	icp_opcode.cc \
-	LogTags.cc \
 	lookup_t.cc \
 	repl_modules.cc \
 	swap_log_op.cc
 
 CLEANFILES += $(BUILT_SOURCES)
 
 nodist_squid_SOURCES = \
-	$(DISKIO_GEN_SOURCE) \
 	$(BUILT_SOURCES)
 
 squid_LDADD = \
@@ -602,7 +551,6 @@ squid_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
-	$(DISK_LIBS) \
 	acl/libapi.la \
 	clients/libclients.la \
 	servers/libservers.la \
@@ -611,15 +559,16 @@ squid_LDADD = \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	dns/libdns.la \
-	security/libsecurity.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
+	DiskIO/libdiskio.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
+	security/libsecurity.la \
 	comm/libcomm.la \
 	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
@@ -628,7 +577,6 @@ squid_LDADD = \
 	$(XTRA_OBJS) \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS) \
-	$(DISK_OS_LIBS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(REGEXLIB) \
@@ -645,30 +593,6 @@ squid_LDADD = \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
-squid_DEPENDENCIES = \
-	$(DISK_LIBS) \
-	$(DISK_LINKOBJS) \
-	$(REPL_OBJS) \
-	$(ADAPTATION_LIBS) \
-	$(ESI_LOCAL_LIBS) \
-	$(SSL_LIBS) \
-	$(AUTH_ACL_LIBS) \
-	ident/libident.la \
-	acl/libacls.la \
-	eui/libeui.la \
-	acl/libstate.la \
-	$(AUTH_LIBS) \
-	acl/libapi.la \
-	base/libbase.la \
-	clients/libclients.la \
-	ftp/libftp.la \
-	libsquid.la \
-	ip/libip.la \
-	fs/libfs.la \
-	format/libformat.la \
-	ipc/libipc.la \
-	mgr/libmgr.la \
-	servers/libservers.la
 
 if ENABLE_LOADABLE_MODULES
 squid_SOURCES += $(LOADABLE_MODULES_SOURCES)
@@ -771,7 +695,7 @@ ufsdump_DEPENDENCIES = \
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
-	$(DISK_LIBS) \
+	DiskIO/libdiskio.la \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS)
 
@@ -811,7 +735,6 @@ EXTRA_DIST = \
 	cf_gen_defines \
 	cf.data.pre \
 	cf.data.depend \
-	DiskIO/modules.sh \
 	mk-globals-c.pl \
 	mk-globals-c.awk \
 	mk-string-arrays.pl \
@@ -821,78 +744,6 @@ EXTRA_DIST = \
 	mib.txt \
 	mime.conf.default
 
-libAIO_a_SOURCES = \
-		$(AIO_WIN32_SOURCES) \
-		DiskIO/AIO/async_io.h \
-		DiskIO/AIO/AIODiskFile.cc \
-		DiskIO/AIO/AIODiskFile.h \
-		DiskIO/AIO/AIODiskIOStrategy.cc \
-		DiskIO/AIO/AIODiskIOStrategy.h \
-		DiskIO/AIO/AIODiskIOModule.cc \
-		DiskIO/AIO/AIODiskIOModule.h
-
-libBlocking_a_SOURCES = \
-		DiskIO/Blocking/BlockingFile.cc \
-		DiskIO/Blocking/BlockingFile.h \
-		DiskIO/Blocking/BlockingIOStrategy.cc \
-		DiskIO/Blocking/BlockingIOStrategy.h \
-		DiskIO/Blocking/BlockingDiskIOModule.cc \
-		DiskIO/Blocking/BlockingDiskIOModule.h 
-
-libMmapped_a_SOURCES = \
-		DiskIO/Mmapped/MmappedFile.cc \
-		DiskIO/Mmapped/MmappedFile.h \
-		DiskIO/Mmapped/MmappedIOStrategy.cc \
-		DiskIO/Mmapped/MmappedIOStrategy.h \
-		DiskIO/Mmapped/MmappedDiskIOModule.cc \
-		DiskIO/Mmapped/MmappedDiskIOModule.h 
-
-libIpcIo_a_SOURCES = \
-		DiskIO/IpcIo/IpcIoFile.cc \
-		DiskIO/IpcIo/IpcIoFile.h \
-		DiskIO/IpcIo/IpcIoIOStrategy.cc \
-		DiskIO/IpcIo/IpcIoIOStrategy.h \
-		DiskIO/IpcIo/IpcIoDiskIOModule.cc \
-		DiskIO/IpcIo/IpcIoDiskIOModule.h 
-
-libDiskDaemon_a_SOURCES = \
-		DiskIO/DiskDaemon/DiskdFile.cc \
-		DiskIO/DiskDaemon/DiskdFile.h \
-		DiskIO/DiskDaemon/DiskdIOStrategy.cc \
-		DiskIO/DiskDaemon/DiskdIOStrategy.h \
-		DiskIO/DiskDaemon/diomsg.h \
-		DiskIO/DiskDaemon/DiskDaemonDiskIOModule.cc \
-		DiskIO/DiskDaemon/DiskDaemonDiskIOModule.h \
-		DiskIO/DiskDaemon/DiskdAction.cc \
-		DiskIO/DiskDaemon/DiskdAction.h
-
-libDiskThreads_a_SOURCES = \
-		$(AIOPS_SOURCE) \
-		DiskIO/DiskThreads/async_io.cc \
-		DiskIO/DiskThreads/DiskThreads.h \
-		DiskIO/DiskThreads/DiskThreadsDiskFile.cc \
-		DiskIO/DiskThreads/DiskThreadsDiskFile.h \
-		DiskIO/DiskThreads/DiskThreadsDiskIOModule.cc \
-		DiskIO/DiskThreads/DiskThreadsDiskIOModule.h \
-		DiskIO/DiskThreads/DiskThreadsIOStrategy.cc \
-		DiskIO/DiskThreads/DiskThreadsIOStrategy.h
-
-EXTRA_libDiskThreads_a_SOURCES = \
-	DiskIO/DiskThreads/aiops.cc \
-	DiskIO/DiskThreads/aiops_win32.cc \
-	DiskIO/DiskThreads/CommIO.cc \
-	DiskIO/DiskThreads/CommIO.h
-
-DiskIO_DiskDaemon_diskd_SOURCES = DiskIO/DiskDaemon/diskd.cc
-nodist_DiskIO_DiskDaemon_diskd_SOURCES = time.cc
-DiskIO_DiskDaemon_diskd_LDADD = \
-	$(top_builddir)/lib/libmisccontainers.la \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-
-
 DEFAULT_HTTP_PORT	= 3128
 DEFAULT_ICP_PORT	= 3130
 DEFAULT_PREFIX		= $(prefix)
@@ -931,9 +782,6 @@ err_type.cc: err_type.h mk-string-arrays.awk
 err_detail_type.cc: err_detail_type.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/err_detail_type.h | sed 's/ERR_DETAIL_//' > $@ || ($(RM) -f $@ && exit 1)
 
-LogTags.cc: LogTags.h mk-string-arrays.awk
-	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/LogTags.h | sed 's/LOG_//' > $@ || ($(RM) -f $@ && exit 1)
-
 lookup_t.cc: lookup_t.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/lookup_t.h > $@ || ($(RM) -f $@ && exit 1)
 
@@ -1038,7 +886,6 @@ uninstall-local: squid.conf.default
 	@$(SHELL) $(top_srcdir)/scripts/remove-cfg.sh "$(RM)" $(DESTDIR)$(DEFAULT_CONFIG_FILE) squid.conf.default
 
 CLEANFILES += cf.data squid.conf.default squid.conf.documented \
-	DiskIO/DiskIOModules_gen.cc \
 	test_tools.cc *.a
 
 test_tools.cc: $(top_srcdir)/test-suite/test_tools.cc
@@ -1146,8 +993,6 @@ tests_testHttpReply_SOURCES=\
 	mime_header.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
-	Packer.h \
 	SquidString.h \
 	SquidTime.h \
 	$(SBUF_SOURCE) \
@@ -1172,6 +1017,7 @@ tests_testHttpReply_SOURCES=\
 	tests/stub_libauth.cc \
 	tests/stub_libcomm.cc \
 	tests/stub_libmgr.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_libsslsquid.cc \
 	StatCounters.h \
 	StatCounters.cc \
@@ -1221,8 +1067,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
-	DiskIO/ReadRequest.cc \
-	DiskIO/WriteRequest.cc \
 	tests/stub_ETag.cc \
 	event.cc \
 	fatal.h \
@@ -1253,8 +1097,8 @@ tests_testACLMaxUserIP_SOURCES= \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
-	Packer.cc \
 	Parsing.cc \
+	tests/stub_libsecurity.cc \
 	SquidMath.cc \
 	StatCounters.cc \
 	StatCounters.h \
@@ -1287,7 +1131,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_client_side.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
-	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
 	fd.h \
 	tests/stub_fd.cc \
@@ -1296,6 +1139,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_ipc_TypedMsgHdr.cc \
 	tests/stub_libauth.cc \
 	tests/stub_libcomm.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libsslsquid.cc \
 	tests/stub_MemObject.cc \
@@ -1345,7 +1189,6 @@ tests_testACLMaxUserIP_LDADD= \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(DISK_OS_LIBS) \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
@@ -1407,7 +1250,6 @@ tests_testCacheManager_SOURCES = \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -1424,7 +1266,6 @@ tests_testCacheManager_SOURCES = \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
-	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
@@ -1478,6 +1319,7 @@ tests_testCacheManager_SOURCES = \
 	int.cc \
 	internal.h \
 	internal.cc \
+	LogTags.cc \
 	tests/stub_libsecurity.cc \
 	SquidList.h \
 	SquidList.cc \
@@ -1496,7 +1338,6 @@ tests_testCacheManager_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -1530,6 +1371,7 @@ tests_testCacheManager_SOURCES = \
 	StrList.cc \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	repl_modules.h \
@@ -1573,8 +1415,7 @@ tests_testCacheManager_SOURCES = \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testCacheManager_SOURCES = \
-	$(BUILT_SOURCES) \
-	$(DISKIO_GEN_SOURCE)
+	$(BUILT_SOURCES)
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
 	libsquid.la \
@@ -1598,8 +1439,6 @@ tests_testCacheManager_LDADD = \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
@@ -1634,7 +1473,6 @@ tests_testDiskIO_SOURCES = \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
-	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
 	tests/stub_ETag.cc \
@@ -1676,13 +1514,13 @@ tests_testDiskIO_SOURCES = \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
+	tests/stub_libsecurity.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -1761,7 +1599,6 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_tools.cc
 nodist_tests_testDiskIO_SOURCES= \
 	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
@@ -1779,8 +1616,7 @@ tests_testDiskIO_LDADD = \
 	fs/libfs.la \
 	ipc/libipc.la \
 	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
+	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	mgr/libmgr.la \
@@ -1801,7 +1637,7 @@ tests_testDiskIO_LDADD = \
 
 tests_testDiskIO_LDFLAGS = $(LIBADD_DL)
 tests_testDiskIO_DEPENDENCIES = \
-	$(DISK_LIBS) \
+	DiskIO/libdiskio.la \
 	$(SWAP_TEST_DS) \
 	$(SQUID_CPPUNIT_LA)
 
@@ -1839,7 +1675,6 @@ tests_testEvent_SOURCES = \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -1857,7 +1692,6 @@ tests_testEvent_SOURCES = \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
-	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
@@ -1918,6 +1752,7 @@ tests_testEvent_SOURCES = \
 	int.cc \
 	internal.h \
 	internal.cc \
+	LogTags.cc \
 	tests/stub_libsecurity.cc \
 	SquidList.h \
 	SquidList.cc \
@@ -1937,7 +1772,6 @@ tests_testEvent_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -2000,6 +1834,7 @@ tests_testEvent_SOURCES = \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
@@ -2020,8 +1855,7 @@ tests_testEvent_SOURCES = \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testEvent_SOURCES = \
-	$(BUILT_SOURCES) \
-	$(DISKIO_GEN_SOURCE)
+	$(BUILT_SOURCES)
 tests_testEvent_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
@@ -2050,8 +1884,6 @@ tests_testEvent_LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -2086,7 +1918,6 @@ tests_testEventLoop_SOURCES = \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -2104,7 +1935,6 @@ tests_testEventLoop_SOURCES = \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
-	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
@@ -2165,7 +1995,7 @@ tests_testEventLoop_SOURCES = \
 	int.cc \
 	internal.h \
 	internal.cc \
-	tests/stub_libsecurity.cc \
+	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
@@ -2184,7 +2014,6 @@ tests_testEventLoop_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -2246,7 +2075,9 @@ tests_testEventLoop_SOURCES = \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libeui.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2266,8 +2097,7 @@ tests_testEventLoop_SOURCES = \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testEventLoop_SOURCES = \
-	$(BUILT_SOURCES) \
-	$(DISKIO_GEN_SOURCE)
+	$(BUILT_SOURCES)
 tests_testEventLoop_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
@@ -2296,8 +2126,6 @@ tests_testEventLoop_LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -2331,7 +2159,6 @@ tests_test_http_range_SOURCES = \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -2349,7 +2176,6 @@ tests_test_http_range_SOURCES = \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
-	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
@@ -2407,7 +2233,7 @@ tests_test_http_range_SOURCES = \
 	internal.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
-	tests/stub_libsecurity.cc \
+	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
@@ -2426,7 +2252,6 @@ tests_test_http_range_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
@@ -2486,7 +2311,9 @@ tests_test_http_range_SOURCES = \
 	tests/test_http_range.cc \
 	tests/stub_external_acl.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libeui.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
@@ -2507,8 +2334,7 @@ tests_test_http_range_SOURCES = \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_test_http_range_SOURCES = \
-	$(BUILT_SOURCES) \
-	$(DISKIO_GEN_SOURCE)
+	$(BUILT_SOURCES)
 tests_test_http_range_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
@@ -2530,8 +2356,6 @@ tests_test_http_range_LDADD = \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
@@ -2575,6 +2399,7 @@ tests_testHttp1Parser_SOURCES = \
 	tests/stub_debug.cc \
 	tests/stub_event.cc \
 	tests/stub_HelperChildConfig.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_stmem.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
@@ -2614,10 +2439,10 @@ tests_testHttpRequest_SOURCES = \
 	tests/testHttpRequest.cc \
 	tests/testHttpRequestMethod.h \
 	tests/testHttpRequestMethod.cc \
-	tests/stub_DiskIOModule.cc \
 	tests/stub_libauth.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_EventLoop.cc \
@@ -2638,7 +2463,6 @@ tests_testHttpRequest_SOURCES = \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -2704,6 +2528,7 @@ tests_testHttpRequest_SOURCES = \
 	int.cc \
 	internal.h \
 	internal.cc \
+	LogTags.cc \
 	tests/stub_libsecurity.cc \
 	SquidList.h \
 	SquidList.cc \
@@ -2722,7 +2547,6 @@ tests_testHttpRequest_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -2831,7 +2655,6 @@ tests_testHttpRequest_LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(DISK_OS_LIBS) \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
@@ -2858,8 +2681,6 @@ tests_testStore_SOURCES= \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
-	DiskIO/ReadRequest.cc \
-	DiskIO/WriteRequest.cc \
 	ETag.cc \
 	event.cc \
 	EventLoop.cc \
@@ -2894,7 +2715,6 @@ tests_testStore_SOURCES= \
 	MemObject.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	refresh.h \
@@ -2933,7 +2753,6 @@ tests_testStore_SOURCES= \
 	tests/stub_client_side_request.cc \
 	tests/stub_comm.cc \
 	tests/stub_debug.cc \
-	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
 	fd.h \
 	fde.h \
@@ -2943,7 +2762,9 @@ tests_testStore_SOURCES= \
 	tests/stub_http.cc \
 	tests/stub_libauth.cc \
 	tests/stub_libeui.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libformat.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_libsslsquid.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -3003,6 +2824,7 @@ tests_testStore_LDADD= \
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	mem/libmem.la \
+	DiskIO/libdiskio.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -3034,6 +2856,7 @@ tests_testString_SOURCES = \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
@@ -3059,7 +2882,6 @@ tests_testString_DEPENDENCIES = \
 
 SWAP_TEST_DS =\
 	repl_modules.o \
-	$(DISK_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
@@ -3068,6 +2890,7 @@ SWAP_TEST_DS =\
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
+	DiskIO/libdiskio.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(REPL_OBJS) \
@@ -3093,6 +2916,7 @@ tests_testUfs_SOURCES = \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_libformat.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_stat.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
@@ -3175,7 +2999,6 @@ tests_testUfs_SOURCES = \
 	ClientInfo.h \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
-	Packer.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
@@ -3204,12 +3027,10 @@ tests_testUfs_SOURCES = \
 	tests/testStoreSupport.h \
 	time.cc \
 	wordlist.h \
-	wordlist.cc \
-	$(DISKIO_SOURCE)
+	wordlist.cc
 
 nodist_tests_testUfs_SOURCES = \
 	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
@@ -3227,8 +3048,7 @@ tests_testUfs_LDADD = \
 	mgr/libmgr.la \
 	$(REPL_OBJS) \
 	acl/libacls.la \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
+	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
@@ -3312,7 +3132,6 @@ tests_testRock_SOURCES = \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	RequestFlags.cc \
@@ -3371,6 +3190,7 @@ tests_testRock_SOURCES = \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
@@ -3388,10 +3208,8 @@ tests_testRock_SOURCES = \
 	wordlist.h \
 	wordlist.cc \
 	$(DELAY_POOL_SOURCE) \
-	$(DISKIO_SOURCE) \
 	$(UNLINKDSOURCE)
 nodist_tests_testRock_SOURCES = \
-	$(DISKIO_GEN_SOURCE) \
 	swap_log_op.cc \
 	SquidMath.cc \
 	SquidMath.h \
@@ -3405,8 +3223,7 @@ tests_testRock_LDADD = \
 	fs/libfs.la \
 	$(COMMON_LIBS) \
 	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
+	DiskIO/libdiskio.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
@@ -3448,7 +3265,6 @@ tests_testURL_SOURCES = \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
@@ -3467,8 +3283,6 @@ tests_testURL_SOURCES = \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
-	DiskIO/ReadRequest.cc \
-	DiskIO/WriteRequest.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
@@ -3525,7 +3339,7 @@ tests_testURL_SOURCES = \
 	internal.h \
 	internal.cc \
 	tests/stub_libeui.cc \
-	tests/stub_libsecurity.cc \
+	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
@@ -3544,7 +3358,6 @@ tests_testURL_SOURCES = \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -3603,9 +3416,10 @@ tests_testURL_SOURCES = \
 	tests/stub_SwapDir.cc \
 	MemStore.cc \
 	tests/stub_debug.cc \
-	tests/stub_DiskIOModule.cc \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
+	tests/stub_libdiskio.cc \
+	tests/stub_libsecurity.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
@@ -3656,7 +3470,6 @@ tests_testURL_LDADD = \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
-	$(DISK_OS_LIBS) \
 	format/libformat.la \
 	$(REGEXLIB) \
 	$(REPL_OBJS) \
@@ -3694,6 +3507,7 @@ tests_testSBuf_SOURCES= \
 	tests/stub_libmem.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_tools.cc \
@@ -3777,6 +3591,7 @@ tests_testConfigParser_SOURCES = \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
@@ -222,7 +222,7 @@ void MemBuf::truncate(mb_size_t tailSize)
  * calls memcpy, appends exactly size bytes,
  * extends buffer or creates buffer if needed.
  */
-void MemBuf::append(const char *newContent, mb_size_t sz)
+void MemBuf::append(const char *newContent, int sz)
 {
     assert(sz >= 0);
     assert(buf || (0==capacity && 0==size));
@@ -262,21 +262,11 @@ void MemBuf::terminate()
     *space() = '\0';
 }
 
-/* calls memBufVPrintf */
-void
-MemBuf::Printf(const char *fmt,...)
-{
-    va_list args;
-    va_start(args, fmt);
-    vPrintf(fmt, args);
-    va_end(args);
-}
-
 /**
- * vPrintf for other printf()'s to use; calls vsnprintf, extends buf if needed
+ * vappendf for other printf()'s to use; calls vsnprintf, extends buf if needed
  */
 void
-MemBuf::vPrintf(const char *fmt, va_list vargs)
+MemBuf::vappendf(const char *fmt, va_list vargs)
 {
 #ifdef VA_COPY
     va_list ap;
@@ -397,6 +387,6 @@ void
 memBufReport(MemBuf * mb)
 {
     assert(mb);
-    mb->Printf("memBufReport is not yet implemented @?@\n");
+    mb->appendf("memBufReport is not yet implemented @?@\n");
 }
 
@@ -9,14 +9,14 @@
 #ifndef SQUID_MEMBUF_H
 #define SQUID_MEMBUF_H
 
+#include "base/Packable.h"
 #include "cbdata.h"
-#include "Packer.h"
 
 /**
- * Auto-growing memory-resident buffer with printf interface
+ * Auto-growing memory-resident buffer with Packable interface
  * \deprecated Use SBuf instead.
  */
-class MemBuf
+class MemBuf : public Packable
 {
     CBDATA_CLASS(MemBuf);
 
@@ -28,7 +28,7 @@ class MemBuf
         capacity(0),
         stolen(0)
     {}
-    ~MemBuf() {
+    virtual ~MemBuf() {
         if (!stolen && buf)
             clean();
     }
@@ -75,7 +75,6 @@ class MemBuf
     void consume(mb_size_t sz);  // removes sz bytes, moving content left
     void consumeWhitespacePrefix();    ///< removes all prefix whitespace, moving content left
 
-    void append(const char *c, mb_size_t sz); // grows if needed and possible
     void appended(mb_size_t sz); // updates content size after external append
     void truncate(mb_size_t sz);  // removes sz last bytes
 
@@ -98,23 +97,17 @@ class MemBuf
     /** unfirtunate hack to test if the buffer has been Init()ialized */
     int isNull();
 
-    /**
-     * calls snprintf, extends buffer if needed
-     \note  we use Printf instead of printf so the compiler won't
-     *      think we're calling the libc printf()
-     */
-    void Printf(const char *fmt,...) PRINTF_FORMAT_ARG2;
-
-    /** vPrintf for other printf()'s to use */
-    void vPrintf(const char *fmt, va_list ap);
-
     /**
      * freezes the object! and returns function to clear it up.
      *
      \retval free() function to be used.
      */
     FREE *freeFunc();
 
+    /* Packable API */
+    virtual void append(const char *c, int sz);
+    virtual void vappendf(const char *fmt, va_list ap);
+
 private:
     /**
      * private copy constructor and assignment operator generates
@@ -161,8 +154,6 @@ class MemBuf
 
 /** returns free() function to be used, _freezes_ the object! */
 void memBufReport(MemBuf * mb);
-/** pack content into a mem buf. */
-void packerToMemInit(Packer * p, MemBuf * mb);
 
 #endif /* SQUID_MEMBUF_H */
 
@@ -229,28 +229,24 @@ struct StoreClientStats : public unary_function<store_client, void> {
 void
 MemObject::stat(MemBuf * mb) const
 {
-    mb->Printf("\t" SQUIDSBUFPH " %s\n", SQUIDSBUFPRINT(method.image()), logUri());
+    mb->appendf("\t" SQUIDSBUFPH " %s\n", SQUIDSBUFPRINT(method.image()), logUri());
     if (vary_headers)
-        mb->Printf("\tvary_headers: %s\n", vary_headers);
-    mb->Printf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
-    mb->Printf("\tinmem_hi: %" PRId64 "\n", data_hdr.endOffset());
-    mb->Printf("\tswapout: %" PRId64 " bytes queued\n",
-               swapout.queue_offset);
+        mb->appendf("\tvary_headers: %s\n", vary_headers);
+    mb->appendf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
+    mb->appendf("\tinmem_hi: %" PRId64 "\n", data_hdr.endOffset());
+    mb->appendf("\tswapout: %" PRId64 " bytes queued\n", swapout.queue_offset);
 
     if (swapout.sio.getRaw())
-        mb->Printf("\tswapout: %" PRId64 " bytes written\n",
-                   (int64_t) swapout.sio->offset());
+        mb->appendf("\tswapout: %" PRId64 " bytes written\n", (int64_t) swapout.sio->offset());
 
     if (xitTable.index >= 0)
-        mb->Printf("\ttransient index: %d state: %d\n",
-                   xitTable.index, xitTable.io);
+        mb->appendf("\ttransient index: %d state: %d\n", xitTable.index, xitTable.io);
     if (memCache.index >= 0)
-        mb->Printf("\tmem-cache index: %d state: %d offset: %" PRId64 "\n",
-                   memCache.index, memCache.io, memCache.offset);
+        mb->appendf("\tmem-cache index: %d state: %d offset: %" PRId64 "\n", memCache.index, memCache.io, memCache.offset);
     if (object_sz >= 0)
-        mb->Printf("\tobject_sz: %" PRId64 "\n", object_sz);
+        mb->appendf("\tobject_sz: %" PRId64 "\n", object_sz);
     if (smpCollapsed)
-        mb->Printf("\tsmp-collapsed\n");
+        mb->appendf("\tsmp-collapsed\n");
 
     StoreClientStats statsVisitor(mb);
 
@@ -96,7 +96,6 @@ class MemObject
     int64_t inmem_lo;
     dlink_list clients;
 
-    /** \todo move into .cc or .cci */
     size_t clientCount() const {return nclients;}
 
     bool clientIsFirst(void *sc) const {return (clients.head && sc == clients.head->data);}
@@ -801,12 +801,8 @@ MemStoreRr::finalizeConfig()
 {
     // decide whether to use a shared memory cache if the user did not specify
     if (!Config.memShared.configured()) {
-        Config.memShared.configure(Ipc::Atomic::Enabled() &&
-                                   Ipc::Mem::Segment::Enabled() && UsingSmp() &&
+        Config.memShared.configure(Ipc::Mem::Segment::Enabled() && UsingSmp() &&
                                    Config.memMaxSize > 0);
-    } else if (Config.memShared && !Ipc::Atomic::Enabled()) {
-        // bail if the user wants shared memory cache but we cannot support it
-        fatal("memory_cache_shared is on, but no support for atomic operations detected");
     } else if (Config.memShared && !Ipc::Mem::Segment::Enabled()) {
         fatal("memory_cache_shared is on, but no support for shared memory detected");
     } else if (Config.memShared && !UsingSmp()) {
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 60    Packer: A uniform interface to store-like modules */
-
-/*
- * Rationale:
- * ----------
- *
- * OK, we have two major interfaces comm.c and store.c.
- *
- * Store.c has a nice storeAppend[Printf] capability which makes "storing"
- * things easy and painless.
- *
- * Comm.c lacks commAppend[Printf] because comm does not handle its own
- * buffers (no mem_obj equivalent for comm.c).
- *
- * Thus, if one wants to be able to store _and_ Comm::Write an object, s/he
- * has to implement two almost identical functions.
- *
- * Packer
- * ------
- *
- * Packer provides for a more uniform interface to store and comm modules.
- * Packer has its own append and printf routines that "know" where to send
- * incoming data. In case of store interface, Packer sends data to
- * storeAppend.  Otherwise, Packer uses a MemBuf that can be flushed later to
- * Comm::Write.
- *
- * Thus, one can write just one function that will either "pack" things for
- * Comm::Write or "append" things to store, depending on actual packer
- * supplied.
- *
- * It is amazing how much work a tiny object can save. :)
- */
-
-#include "squid.h"
-#include "MemBuf.h"
-#include "Store.h"
-
-/*
- * We do have one potential problem here. Both append_f and vprintf_f types
- * cannot match real functions precisely (at least because of the difference in
- * the type of the first parameter). Thus, we have to use type cast. If somebody
- * changes the prototypes of real functions, Packer will not notice that because
- * of the type cast.
- *
- * Solution: we use the constants below to *hard code* current prototypes of
- * real functions. If real prototypes change, these constants will produce a
- * warning (e.g., "warning: assignment from incompatible pointer type").
- */
-
-static void
-memBufAppend(MemBuf *mb, const char *buf, mb_size_t len)
-{
-    mb->append(buf, len);
-}
-
-static void
-memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs)
-{
-    mb->vPrintf(fmt, vargs);
-}
-
-static void
-storeEntryAppend(StoreEntry *e, const char *buf, int len)
-{
-    e->append(buf, len);
-}
-
-/* append()'s */
-static void (*const store_append) (StoreEntry *, const char *, int) = &storeEntryAppend;
-static void (*const memBuf_append) (MemBuf *, const char *, mb_size_t) = &memBufAppend;
-
-/* vprintf()'s */
-static void (*const store_vprintf) (StoreEntry *, const char *, va_list ap) = &storeAppendVPrintf;
-static void (*const memBuf_vprintf) (MemBuf *, const char *, va_list ap) = &memBufVPrintf;
-
-/* init/clean */
-
-/* init with this to forward data to StoreEntry */
-void
-packerToStoreInit(Packer * p, StoreEntry * e)
-{
-    assert(p && e);
-    p->append = (append_f) store_append;
-    p->packer_vprintf = (vprintf_f) store_vprintf;
-    p->real_handler = e;
-    e->buffer();
-}
-
-/* init with this to accumulate data in MemBuf */
-void
-packerToMemInit(Packer * p, MemBuf * mb)
-{
-    assert(p && mb);
-    p->append = (append_f) memBuf_append;
-    p->packer_vprintf = (vprintf_f) memBuf_vprintf;
-    p->real_handler = mb;
-}
-
-/* call this when you are done */
-void
-packerClean(Packer * p)
-{
-    assert(p);
-
-    if (p->append == (append_f) store_append && p->real_handler)
-        static_cast<StoreEntry*>(p->real_handler)->flush();
-
-    /* it is not really necessary to do this, but, just in case... */
-    p->append = NULL;
-    p->packer_vprintf = NULL;
-    p->real_handler = NULL;
-}
-
-void
-packerAppend(Packer * p, const char *buf, int sz)
-{
-    assert(p);
-    assert(p->real_handler && p->append);
-    p->append(p->real_handler, buf, sz);
-}
-
-void
-packerPrintf(Packer * p, const char *fmt,...)
-{
-    va_list args;
-    va_start(args, fmt);
-
-    assert(p);
-    assert(p->real_handler && p->packer_vprintf);
-    p->packer_vprintf(p->real_handler, fmt, args);
-    va_end(args);
-}
-
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_PACKER_H
-#define SQUID_PACKER_H
-
-/* see Packer.cc for description */
-class Packer;
-
-/* a common objPackInto interface; used by debugObj */
-typedef void (*ObjPackMethod) (void *obj, Packer * p);
-
-/* append/vprintf's for Packer */
-typedef void (*append_f) (void *, const char *buf, int size);
-typedef void (*vprintf_f) (void *, const char *fmt, va_list args);
-
-class Packer
-{
-
-public:
-    /* protected, use interface functions instead */
-    append_f append;
-    vprintf_f packer_vprintf;
-    void *real_handler;     /* first parameter to real append and vprintf */
-};
-
-void packerClean(Packer * p);
-void packerAppend(Packer * p, const char *buf, int size);
-void packerPrintf(Packer * p, const char *fmt,...) PRINTF_FORMAT_ARG2;
-
-#endif /* SQUID_PACKER_H */
-
@@ -67,7 +67,7 @@ PeerPoolMgr::start()
     // ErrorState, getOutgoingAddress(), and other APIs may require a request.
     // We fake one. TODO: Optionally send this request to peers?
     request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, "*");
-    request->SetHost(peer->host);
+    request->url.host(peer->host);
 
     checkpoint("peer initialized");
 }
@@ -53,7 +53,7 @@ class ps_state
 
     // Produce a URL for display identifying the transaction we are
     // trying to locate a peer for.
-    const char * url() const;
+    const SBuf url() const;
 
     HttpRequest *request;
     AccessLogEntry::Pointer al; ///< info for the future access.log entry
@@ -32,7 +32,6 @@ class RefreshPattern
         bool reload_into_ims;
         bool ignore_reload;
         bool ignore_no_store;
-        bool ignore_must_revalidate;
         bool ignore_private;
 #endif
     } flags;
@@ -565,12 +565,18 @@ SBuf::c_str()
 SBuf&
 SBuf::chop(size_type pos, size_type n)
 {
-    if (pos == npos || pos > length() || n == 0) {
+    if (pos == npos || pos > length())
+        pos = length();
+
+    if (n == npos || (pos+n) > length())
+        n = length() - pos;
+
+    // if there will be nothing left, reset the buffer while we can
+    if (pos == length() || n == 0) {
         clear();
         return *this;
     }
-    if (n == npos || (pos+n) > length())
-        n = length()-pos;
+
     ++stats.chop;
     off_ += pos;
     len_ = n;
@@ -17,13 +17,10 @@
 #include "HttpHeaderTools.h"
 #include "ip/Address.h"
 #include "Notes.h"
+#include "security/forward.h"
 #include "YesNoNone.h"
 
 #if USE_OPENSSL
-#if HAVE_OPENSSL_SSL_H
-#include <openssl/ssl.h>
-#endif
-
 class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
@@ -492,14 +489,14 @@ class SquidConfig
     time_t minimum_expiry_time; /* seconds */
     external_acl *externalAclHelperList;
 
-#if USE_OPENSSL
     struct {
+        Security::ContextPointer sslContext;
+#if USE_OPENSSL
         acl_access *cert_error;
-        SSL_CTX *sslContext;
         sslproxy_cert_sign *cert_sign;
         sslproxy_cert_adapt *cert_adapt;
-    } ssl_client;
 #endif
+    } ssl_client;
 
     char *accept_filter;
     int umask;
@@ -9,11 +9,7 @@
 #ifndef SQUID_STORE_H
 #define SQUID_STORE_H
 
-/**
- \defgroup StoreAPI  Store API
- \ingroup FileSystems
- */
-
+#include "base/Packable.h"
 #include "base/RefCount.h"
 #include "comm/forward.h"
 #include "CommRead.h"
@@ -35,7 +31,6 @@
 
 class AsyncCall;
 class HttpRequest;
-class Packer;
 class RequestFlags;
 class StoreClient;
 class StoreSearch;
@@ -46,10 +41,7 @@ extern StoreIoStats store_io_stats;
 /// maximum number of entries per cache_dir
 enum { SwapFilenMax = 0xFFFFFF }; // keep in sync with StoreEntry::swap_filen
 
-/**
- \ingroup StoreAPI
- */
-class StoreEntry : public hash_link
+class StoreEntry : public hash_link, public Packable
 {
 
 public:
@@ -190,8 +182,6 @@ class StoreEntry : public hash_link
 
     ESIElement::Pointer cachedESITree;
 #endif
-    /** append bytes to the buffer */
-    virtual void append(char const *, int len);
     /** disable sending content to the clients */
     virtual void buffer();
     /** flush any buffered content */
@@ -222,6 +212,10 @@ class StoreEntry : public hash_link
     void kickProducer();
 #endif
 
+    /* Packable API */
+    virtual void append(char const *, int);
+    virtual void vappendf(const char *, va_list);
+
 protected:
     void transientsAbandonmentCheck();
 
@@ -502,12 +496,6 @@ void storeReplAdd(const char *, REMOVALPOLICYCREATE *);
 /// \ingroup StoreAPI
 extern FREE destroyStoreEntry;
 
-/**
- \ingroup StoreAPI
- \todo should be a subclass of Packer perhaps ?
- */
-void packerToStoreInit(Packer * p, StoreEntry * e);
-
 /// \ingroup StoreAPI
 void storeGetMemSpace(int size);
 
@@ -81,7 +81,7 @@ class store_client
     void scheduleMemRead();
     void scheduleRead();
     bool startSwapin();
-    void unpackHeader(char const *buf, ssize_t len);
+    bool unpackHeader(char const *buf, ssize_t len);
 
     int type;
     bool object_ok;
@@ -9,7 +9,6 @@
 #ifndef SQUID_STOREIOBUFFER_H
 #define SQUID_STOREIOBUFFER_H
 
-/* TODO: move this and the range() method into a .cci */
 #include "MemBuf.h"
 #include "Range.h"
 
@@ -10,34 +10,82 @@
 #define SQUID_SRC_URL_H
 
 #include "anyp/UriScheme.h"
+#include "ip/Address.h"
+#include "rfc2181.h"
 #include "SBuf.h"
 
+#include <iosfwd>
+
 /**
  * The URL class represents a Uniform Resource Location
+ *
+ * Governed by RFC 3986
  */
 class URL
 {
     MEMPROXY_CLASS(URL);
 
 public:
-    URL() : scheme_() {}
-    URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme) {}
+    URL() : scheme_(), hostIsNumeric_(false), port_(0) {*host_=0;}
+    URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme), hostIsNumeric_(false), port_(0) {*host_=0;}
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
+        hostIsNumeric_ = false;
+        *host_ = 0;
+        hostAddr_.setEmpty();
+        port_ = 0;
+        touch();
     }
+    void touch(); ///< clear the cached URI display forms
 
     AnyP::UriScheme const & getScheme() const {return scheme_;}
 
     /// convert the URL scheme to that given
-    void setScheme(const AnyP::ProtocolType &p) {scheme_=p;}
+    void setScheme(const AnyP::ProtocolType &p) {scheme_=p; touch();}
 
-    void userInfo(const SBuf &s) {userInfo_=s;}
+    void userInfo(const SBuf &s) {userInfo_=s; touch();}
     const SBuf &userInfo() const {return userInfo_;}
 
+    void host(const char *src);
+    const char *host(void) const {return host_;}
+    int hostIsNumeric(void) const {return hostIsNumeric_;}
+    Ip::Address const & hostIP(void) const {return hostAddr_;}
+
+    void port(unsigned short p) {port_=p; touch();}
+    unsigned short port() const {return port_;}
+
+    void path(const char *p) {path_=p; touch();}
+    void path(const SBuf &p) {path_=p; touch();}
+    const SBuf &path() const;
+
+    /// the static '/' default URL-path
+    static const SBuf &SlashPath();
+
     /// the static '*' pseudo-URL
     static const SBuf &Asterisk();
 
+    /**
+     * The authority-form URI for currently stored values.
+     *
+     * As defined by RFC 7230 section 5.3.3 this form omits the
+     * userinfo@ field from RFC 3986 defined authority segment.
+     *
+     * \param requirePort when true the port will be included, otherwise
+     *                    port will be elided when it is the default for
+     *                    the current scheme.
+     */
+    SBuf &authority(bool requirePort = false) const;
+
+    /**
+     * The absolute-form URI for currently stored values.
+     *
+     * As defined by RFC 7230 section 5.3.3 this form omits the
+     * userinfo@ field from RFC 3986 defined authority segments
+     * when the protocol scheme is http: or https:.
+     */
+    SBuf &absolute() const;
+
 private:
     /**
      \par
@@ -62,15 +110,39 @@ class URL
     AnyP::UriScheme scheme_;
 
     SBuf userInfo_; // aka 'URL-login'
+
+    // XXX: uses char[] instead of SBUf to reduce performance regressions
+    //      from c_str() since most code using this is not yet using SBuf
+    char host_[SQUIDHOSTNAMELEN];   ///< string representation of the URI authority name or IP
+    bool hostIsNumeric_;            ///< whether the authority 'host' is a raw-IP
+    Ip::Address hostAddr_;          ///< binary representation of the URI authority if it is a raw-IP
+
+    unsigned short port_;   ///< URL port
+
+    // XXX: for now includes query-string.
+    SBuf path_;     ///< URL path segment
+
+    // pre-assembled URL forms
+    mutable SBuf authorityHttp_;     ///< RFC 7230 section 5.3.3 authority, maybe without default-port
+    mutable SBuf authorityWithPort_; ///< RFC 7230 section 5.3.3 authority with explicit port
+    mutable SBuf absolute_;          ///< RFC 7230 section 5.3.2 absolute-URI
 };
 
+inline std::ostream &
+operator <<(std::ostream &os, const URL &url)
+{
+    if (const char *sc = url.getScheme().c_str())
+        os << sc << ":";
+    os << "//" << url.authority() << url.path();
+    return os;
+}
+
 class HttpRequest;
 class HttpRequestMethod;
 
 AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
 void urlInitialize(void);
 HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
-const char *urlCanonical(HttpRequest *);
 char *urlCanonicalClean(const HttpRequest *);
 const char *urlCanonicalFakeHttps(const HttpRequest * request);
 bool urlIsRelative(const char *);
@@ -110,7 +182,6 @@ char *urlInternal(const char *dir, const char *name);
  */
 int matchDomainName(const char *host, const char *domain, bool honorWildcards = false);
 int urlCheckRequest(const HttpRequest *);
-int urlDefaultPort(AnyP::ProtocolType p);
 char *urlHostname(const char *url);
 void urlExtMethodConfigure(void);
 
@@ -62,7 +62,7 @@ Acl::AllOf::parse()
 
         MemBuf wholeCtx;
         wholeCtx.init();
-        wholeCtx.Printf("(%s lines)", name);
+        wholeCtx.appendf("(%s lines)", name);
         wholeCtx.terminate();
 
         Acl::OrNode *newWhole = new Acl::OrNode;
@@ -79,7 +79,7 @@ Acl::AllOf::parse()
 
     MemBuf lineCtx;
     lineCtx.init();
-    lineCtx.Printf("(%s line #%d)", name, lineId);
+    lineCtx.appendf("(%s line #%d)", name, lineId);
     lineCtx.terminate();
 
     Acl::AndNode *line = new AndNode;
@@ -602,7 +602,7 @@ ACLSourceASNStrategy ACLSourceASNStrategy::Instance_;
 int
 ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
+    const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->url.host(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
         for (int k = 0; k < (int) ia->count; ++k) {
@@ -614,7 +614,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
 
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
-        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
+        debugs(28, 3, "can't yet compare '" << AclMatchedName << "' ACL for " << checklist->request->url.host());
         if (checklist->goAsync(DestinationIPLookup::Instance()))
             return -1;
         // else fall through to noaddr match, hiding the lookup failure (XXX)
@@ -28,7 +28,7 @@ ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *c
 {
     const int fd = checklist->fd();
     const bool goodDescriptor = 0 <= fd && fd <= Biggest_FD;
-    SSL *ssl = goodDescriptor ? fd_table[fd].ssl : 0;
+    auto ssl = goodDescriptor ? fd_table[fd].ssl : nullptr;
     X509 *cert = SSL_get_peer_certificate(ssl);
     const bool res = data->match (cert);
     X509_free(cert);
@@ -127,8 +127,29 @@ ACLCertificateData::parse()
                     debugs(28, DBG_CRITICAL, "FATAL: An acl must use consistent attributes in all config lines (" << newAttribute << "!=" << attribute << ").");
                     self_destruct();
                 }
-            } else
+            } else {
+                if (strcasecmp(newAttribute, "DN") != 0) {
+                    int nid = OBJ_txt2nid(newAttribute);
+                    if (nid == 0) {
+                        const size_t span = strspn(newAttribute, "0123456789.");
+                        if(newAttribute[span] == '\0') { // looks like a numerical OID
+                            // create a new object based on this attribute
+
+                            // NOTE: Not a [bad] leak: If the same attribute
+                            // has been added before, the OBJ_txt2nid call
+                            // would return a valid nid value.
+                            // TODO: call OBJ_cleanup() on reconfigure?
+                            nid = OBJ_create(newAttribute, newAttribute,  newAttribute);
+                            debugs(28, 7, "New SSL certificate attribute created with name: " << newAttribute << " and nid: " << nid);
+                        }
+                    }
+                    if (nid == 0) {
+                        debugs(28, DBG_CRITICAL, "FATAL: Not valid SSL certificate attribute name or numerical OID: " << newAttribute);
+                        self_destruct();
+                    }
+                }
                 attribute = xstrdup(newAttribute);
+            }
         }
     }
 
@@ -46,28 +46,28 @@ ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledCheckl
 {
     assert(checklist != NULL && checklist->request != NULL);
 
-    if (data->match(checklist->request->GetHost())) {
+    if (data->match(checklist->request->url.host())) {
         return 1;
     }
 
     if (flags.isSet(ACL_F_NO_LOOKUP)) {
-        debugs(28, 3, "aclMatchAcl:  No-lookup DNS ACL '" << AclMatchedName << "' for '" << checklist->request->GetHost() << "'");
+        debugs(28, 3, "No-lookup DNS ACL '" << AclMatchedName << "' for " << checklist->request->url.host());
         return 0;
     }
 
     /* numeric IPA? no, trust the above result. */
-    if (checklist->request->GetHostIsNumeric() == 0) {
+    if (!checklist->request->url.hostIsNumeric()) {
         return 0;
     }
 
     /* do we already have the rDNS? match on it if we do. */
     if (checklist->dst_rdns) {
-        debugs(28, 3, "aclMatchAcl: '" << AclMatchedName << "' match with stored rDNS '" << checklist->dst_rdns << "' for '" << checklist->request->GetHost() << "'");
+        debugs(28, 3, "'" << AclMatchedName << "' match with stored rDNS '" << checklist->dst_rdns << "' for " << checklist->request->url.host());
         return data->match(checklist->dst_rdns);
     }
 
     /* raw IP without rDNS? look it up and wait for the result */
-    const ipcache_addrs *ia = ipcacheCheckNumeric(checklist->request->GetHost());
+    const ipcache_addrs *ia = ipcacheCheckNumeric(checklist->request->url.host());
     if (!ia) {
         /* not a valid IPA */
         checklist->dst_rdns = xstrdup("invalid");
@@ -82,7 +82,7 @@ ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledCheckl
         return data->match(fqdn);
     } else if (!checklist->destinationDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
-        debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
+        debugs(28, 3, "Can't yet compare '" << AclMatchedName << "' ACL for " << checklist->request->url.host());
         if (checklist->goAsync(DestinationDomainLookup::Instance()))
             return -1;
         // else fall through to "none" match, hiding the lookup failure (XXX)
@@ -43,17 +43,17 @@ ACLDestinationIP::match(ACLChecklist *cl)
     }
 
     if (flags.isSet(ACL_F_NO_LOOKUP)) {
-        if (!checklist->request->GetHostIsNumeric()) {
-            debugs(28, 3, "aclMatchAcl:  No-lookup DNS ACL '" << AclMatchedName << "' for '" << checklist->request->GetHost() << "'");
+        if (!checklist->request->url.hostIsNumeric()) {
+            debugs(28, 3, "No-lookup DNS ACL '" << AclMatchedName << "' for " << checklist->request->url.host());
             return 0;
         }
 
-        if (ACLIP::match(checklist->request->host_addr))
+        if (ACLIP::match(checklist->request->url.hostIP()))
             return 1;
         return 0;
     }
 
-    const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
+    const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->url.host(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
         /* Entry in cache found */
@@ -66,7 +66,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
         return 0;
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
-        debugs(28, 3, "aclMatchAcl: Can't yet compare '" << name << "' ACL for '" << checklist->request->GetHost() << "'");
+        debugs(28, 3, "can't yet compare '" << name << "' ACL for " << checklist->request->url.host());
         if (checklist->goAsync(DestinationIPLookup::Instance()))
             return -1;
         // else fall through to mismatch, hiding the lookup failure (XXX)
@@ -87,7 +87,7 @@ void
 DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    ipcache_nbgethostbyname(checklist->request->GetHost(), LookupDone, checklist);
+    ipcache_nbgethostbyname(checklist->request->url.host(), LookupDone, checklist);
 }
 
 void
@@ -172,7 +172,7 @@ aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
     const int ruleId = ((treep && *treep) ? (*treep)->childrenCount() : 0) + 1;
     MemBuf ctxBuf;
     ctxBuf.init();
-    ctxBuf.Printf("%s#%d", directive, ruleId);
+    ctxBuf.appendf("%s#%d", directive, ruleId);
     ctxBuf.terminate();
 
     Acl::AndNode *rule = new Acl::AndNode;
@@ -208,7 +208,7 @@ aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 
     MemBuf ctxLine;
     ctxLine.init();
-    ctxLine.Printf("(%s %s line)", cfg_directive, label);
+    ctxLine.appendf("(%s %s line)", cfg_directive, label);
     ctxLine.terminate();
 
     Acl::AndNode *rule = new Acl::AndNode;
@@ -217,7 +217,7 @@ aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 
     MemBuf ctxTree;
     ctxTree.init();
-    ctxTree.Printf("%s %s", cfg_directive, label);
+    ctxTree.appendf("%s %s", cfg_directive, label);
     ctxTree.terminate();
 
     // We want a cbdata-protected Tree (despite giving it only one child node).
@@ -523,7 +523,7 @@ ACLIP::empty() const
 }
 
 int
-ACLIP::match(Ip::Address &clientip)
+ACLIP::match(const Ip::Address &clientip)
 {
     static acl_ip_data ClientAddress;
     /*
@@ -63,7 +63,7 @@ class ACLIP : public ACL
 
 protected:
 
-    int match(Ip::Address &);
+    int match(const Ip::Address &);
     IPSplay *data;
 
 };
@@ -15,6 +15,8 @@
 #include "Parsing.h"
 #include "wordlist.h"
 
+#include <random>
+
 ACL *
 ACLRandom::clone() const
 {
@@ -82,7 +84,7 @@ ACLRandom::parse()
     } else if (sscanf(t, "%[0-9]/%[0-9]", bufa, bufb) == 2) {
         int a = xatoi(bufa);
         int b = xatoi(bufb);
-        if (a <= 0 || b <= 0) {
+        if (a <= 0 || b <= 0 || a > b) {
             debugs(28, DBG_CRITICAL, "ERROR: ACL random with bad pattern: '" << t << "'");
             return;
         } else
@@ -101,8 +103,14 @@ ACLRandom::parse()
 int
 ACLRandom::match(ACLChecklist *)
 {
-    // make up the random value
-    double random = ((double)rand() / (double)RAND_MAX);
+    // make up the random value.
+    // The fixed-value default seed is fine because we are
+    // actually matching whether the random value is above
+    // or below the configured threshold ratio.
+    static std::mt19937 mt;
+    static std::uniform_real_distribution<> dist(0, 1);
+
+    const double random = dist(mt);
 
     debugs(28, 3, "ACL Random: " << name << " " << pattern << " test: " << data << " > " << random << " = " << ((data > random)?"MATCH":"NO MATCH") );
     return (data > random)?1:0;
@@ -104,7 +104,7 @@ ACLServerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *ch
     }
 
     if (serverName == NULL)
-        serverName = checklist->request->GetHost();
+        serverName = checklist->request->url.host();
 
     if (serverName && data->match(serverName)) {
         return 1;
@@ -12,16 +12,18 @@
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
 #include "acl/Url.h"
+#include "HttpRequest.h"
 #include "rfc1738.h"
 #include "src/URL.h"
 
 int
 ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char *esc_buf = xstrdup(urlCanonical(checklist->request));
+    const SBuf &tmp = checklist->request->effectiveRequestUri();
+    char *esc_buf = xstrndup(tmp.rawContent(), tmp.length()+1);
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
-    safe_free(esc_buf);
+    xfree(esc_buf);
     return result;
 }
 
@@ -18,13 +18,14 @@
 int
 ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    if (!checklist->request->urlpath.size())
+    if (checklist->request->url.path().isEmpty())
         return -1;
 
-    char *esc_buf = xstrdup(checklist->request->urlpath.termedBuf());
+    SBuf tmp = checklist->request->url.path();
+    char *esc_buf = xstrndup(tmp.rawContent(), tmp.length());
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
-    safe_free(esc_buf);
+    xfree(esc_buf);
     return result;
 }
 
@@ -13,9 +13,9 @@
 #include "HttpRequest.h"
 
 int
-ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLUrlPortStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    return data->match (checklist->request->port);
+    return data->match(checklist->request->url.port());
 }
 
 ACLUrlPortStrategy *
@@ -49,7 +49,7 @@ Adaptation::Service::wants(const ServiceFilter &filter) const
         // Sending a message to a service that does not want it is useless.
         // note that we cannot check wantsUrl for service that is not "up"
         // note that even essential services are skipped on unwanted URLs!
-        return wantsUrl(filter.request->urlpath);
+        return wantsUrl(filter.request->url.path());
     }
 
     // The service is down and is either not bypassable or not probed due
@@ -45,7 +45,7 @@ class Service: public RefCountable
     bool wants(const ServiceFilter &filter) const;
 
     // the methods below can only be called on an up() service
-    virtual bool wantsUrl(const String &urlPath) const = 0;
+    virtual bool wantsUrl(const SBuf &urlPath) const = 0;
 
     // called by transactions to report service failure
     virtual void noteFailure() = 0;
@@ -91,11 +91,7 @@ Adaptation::Ecap::HeaderRep::image() const
 {
     MemBuf mb;
     mb.init();
-
-    Packer p;
-    packerToMemInit(&p, &mb);
-    theMessage.packInto(&p, true);
-    packerClean(&p);
+    theMessage.packInto(&mb, true);
     return Area::FromTempBuffer(mb.content(), mb.contentSize());
 }
 
@@ -216,10 +212,11 @@ Adaptation::Ecap::RequestLineRep::uri(const Area &aUri)
 Adaptation::Ecap::RequestLineRep::Area
 Adaptation::Ecap::RequestLineRep::uri() const
 {
-    const char *fullUrl = urlCanonical(&theMessage);
-    Must(fullUrl);
+    const SBuf &fullUrl = theMessage.effectiveRequestUri();
+    // XXX: effectiveRequestUri() cannot return NULL or even empty string, some other problem?
+    Must(!fullUrl.isEmpty());
     // optimize: avoid copying by having an Area::Detail that locks theMessage
-    return Area::FromTempBuffer(fullUrl, strlen(fullUrl));
+    return Area::FromTempBuffer(fullUrl.rawContent(), fullUrl.length());
 }
 
 void
@@ -237,10 +237,12 @@ bool Adaptation::Ecap::ServiceRep::up() const
     return theService != NULL;
 }
 
-bool Adaptation::Ecap::ServiceRep::wantsUrl(const String &urlPath) const
+bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &urlPath) const
 {
     Must(up());
-    return theService->wantsUrl(urlPath.termedBuf());
+    SBuf nonConstUrlPath = urlPath;
+    // c_str() reallocates and terminates for libecap API
+    return theService->wantsUrl(nonConstUrlPath.c_str());
 }
 
 Adaptation::Initiate *
@@ -38,7 +38,7 @@ class ServiceRep : public Adaptation::Service
     virtual bool probed() const;
     virtual bool up() const;
     virtual Adaptation::Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp);
-    virtual bool wantsUrl(const String &urlPath) const;
+    virtual bool wantsUrl(const SBuf &urlPath) const;
     virtual void noteFailure();
     virtual const char *status() const;
     virtual void detach();
@@ -699,7 +699,7 @@ Adaptation::Ecap::XactionRep::status() const
     buf.append(" [", 2);
 
     if (makingVb)
-        buf.Printf("M%d", static_cast<int>(makingVb));
+        buf.appendf("M%d", static_cast<int>(makingVb));
 
     const BodyPipePointer &vp = theVirginRep.raw().body_pipe;
     if (!vp)
@@ -712,7 +712,7 @@ Adaptation::Ecap::XactionRep::status() const
     if (vbProductionFinished)
         buf.append(".", 1);
 
-    buf.Printf(" A%d", static_cast<int>(proxyingAb));
+    buf.appendf(" A%d", static_cast<int>(proxyingAb));
 
     if (proxyingAb == opOn) {
         MessageRep *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
@@ -726,7 +726,7 @@ Adaptation::Ecap::XactionRep::status() const
             buf.append(" A?", 3);
     }
 
-    buf.Printf(" %s%u]", id.Prefix, id.value);
+    buf.appendf(" %s%u]", id.Prefix, id.value);
 
     buf.terminate();
 
@@ -22,10 +22,10 @@
 #include "auth/UserRequest.h"
 #include "base/TextException.h"
 #include "base64.h"
-#include "ChunkedCodingParser.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "err_detail_type.h"
+#include "http/one/TeChunkedParser.h"
 #include "HttpHeaderTools.h"
 #include "HttpMsg.h"
 #include "HttpReply.h"
@@ -375,7 +375,7 @@ void Adaptation::Icap::ModXact::addLastRequestChunk(MemBuf &buf)
 
 void Adaptation::Icap::ModXact::openChunk(MemBuf &buf, size_t chunkSize, bool ieof)
 {
-    buf.Printf((ieof ? "%x; ieof\r\n" : "%x\r\n"), (int) chunkSize);
+    buf.appendf((ieof ? "%x; ieof\r\n" : "%x\r\n"), (int) chunkSize);
 }
 
 void Adaptation::Icap::ModXact::closeChunk(MemBuf &buf)
@@ -557,10 +557,10 @@ void Adaptation::Icap::ModXact::readMore()
         return;
     }
 
-    if (readBuf.spaceSize())
+    if (readBuf.length() < SQUID_TCP_SO_RCVBUF)
         scheduleRead();
     else
-        debugs(93,3,HERE << "nothing to do because !readBuf.spaceSize()");
+        debugs(93,3,HERE << "cannot read with a full buffer");
 }
 
 // comm module read a portion of the ICAP response for us
@@ -968,10 +968,6 @@ void Adaptation::Icap::ModXact::prepEchoing()
 
     httpBuf.terminate(); // HttpMsg::parse requires nil-terminated buffer
     Must(adapted.header->parse(httpBuf.content(), httpBuf.contentSize(), true, &error));
-
-    if (HttpRequest *r = dynamic_cast<HttpRequest*>(adapted.header))
-        urlCanonical(r); // parse does not set HttpRequest::canonical
-
     Must(adapted.header->hdr_sz == httpBuf.contentSize()); // no leftovers
 
     httpBuf.clean();
@@ -1090,9 +1086,6 @@ bool Adaptation::Icap::ModXact::parseHead(HttpMsg *head)
         return false;
     }
 
-    if (HttpRequest *r = dynamic_cast<HttpRequest*>(head))
-        urlCanonical(r); // parse does not set HttpRequest::canonical
-
     debugs(93, 5, HERE << "parse success, consume " << head->hdr_sz << " bytes, return true");
     readBuf.consume(head->hdr_sz);
     return true;
@@ -1104,7 +1097,7 @@ void Adaptation::Icap::ModXact::decideOnParsingBody()
         debugs(93, 5, HERE << "expecting a body");
         state.parsing = State::psBody;
         replyHttpBodySize = 0;
-        bodyParser = new ChunkedCodingParser;
+        bodyParser = new Http1::TeChunkedParser;
         makeAdaptedBodyPipe("adapted response from the ICAP server");
         Must(state.sending == State::sendingAdapted);
     } else {
@@ -1123,15 +1116,9 @@ void Adaptation::Icap::ModXact::parseBody()
 
     // the parser will throw on errors
     BodyPipeCheckout bpc(*adapted.body_pipe);
-    // XXX: performance regression. SBuf-convert (or Parser-convert?) the chunked decoder.
-    MemBuf encodedData;
-    encodedData.init();
-    // NP: we must do this instead of pointing encodedData at the SBuf::rawContent
-    // because chunked decoder uses MemBuf::consume, which shuffles buffer bytes around.
-    encodedData.append(readBuf.rawContent(), readBuf.length());
-    const bool parsed = bodyParser->parse(&encodedData, &bpc.buf);
-    // XXX: httpChunkDecoder has consumed from MemBuf.
-    readBuf.consume(readBuf.length() - encodedData.contentSize());
+    bodyParser->setPayloadBuffer(&bpc.buf);
+    const bool parsed = bodyParser->parse(readBuf);
+    readBuf = bodyParser->remaining(); // sync buffers after parse
     bpc.checkIn();
 
     debugs(93, 5, "have " << readBuf.length() << " body bytes after parsed all: " << parsed);
@@ -1326,16 +1313,10 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         }
         //don't set al.cache.objectSize because it hasn't exist yet
 
-        Packer p;
         MemBuf mb;
-
         mb.init();
-        packerToMemInit(&p, &mb);
-
-        reply_->header.packInto(&p);
+        reply_->header.packInto(&mb);
         al.headers.reply = xstrdup(mb.buf);
-
-        packerClean(&p);
         mb.clean();
     }
     prepareLogWithRequestDetails(adapted_request_, alep);
@@ -1349,25 +1330,25 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
      * XXX These should use HttpHdr interfaces instead of Printfs
      */
     const Adaptation::ServiceConfig &s = service().cfg();
-    buf.Printf("%s " SQUIDSTRINGPH " ICAP/1.0\r\n", s.methodStr(), SQUIDSTRINGPRINT(s.uri));
-    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
-    buf.Printf("Date: %s\r\n", mkrfc1123(squid_curtime));
+    buf.appendf("%s " SQUIDSTRINGPH " ICAP/1.0\r\n", s.methodStr(), SQUIDSTRINGPRINT(s.uri));
+    buf.appendf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
+    buf.appendf("Date: %s\r\n", mkrfc1123(squid_curtime));
 
     if (!TheConfig.reuse_connections)
-        buf.Printf("Connection: close\r\n");
+        buf.appendf("Connection: close\r\n");
 
     const HttpRequest *request = &virginRequest();
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getByName("Proxy-Authenticate");
-        buf.Printf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
+        buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
     if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
-        buf.Printf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
+        buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
         struct base64_encode_ctx ctx;
         base64_encode_init(&ctx);
@@ -1376,7 +1357,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         resultLen += base64_encode_update(&ctx, base64buf+resultLen, 1, reinterpret_cast<const uint8_t*>(":"));
         resultLen += base64_encode_update(&ctx, base64buf+resultLen, request->extacl_passwd.size(), reinterpret_cast<const uint8_t*>(request->extacl_passwd.rawBuf()));
         resultLen += base64_encode_final(&ctx, base64buf+resultLen);
-        buf.Printf("Proxy-Authorization: Basic %.*s\r\n", (int)resultLen, base64buf);
+        buf.appendf("Proxy-Authorization: Basic %.*s\r\n", (int)resultLen, base64buf);
     }
 
     // share the cross-transactional database records if needed
@@ -1385,13 +1366,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         if (ah != NULL) {
             String name, value;
             if (ah->getXxRecord(name, value)) {
-                buf.Printf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n",
-                           SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
+                buf.appendf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
             }
         }
     }
 
-    buf.Printf("Encapsulated: ");
+    buf.append("Encapsulated: ", 14);
 
     MemBuf httpBuf;
 
@@ -1402,9 +1382,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 
     // to simplify, we could assume that request is always available
 
-    String urlPath;
     if (request) {
-        urlPath = request->urlpath;
         if (ICAP::methodRespmod == m)
             encapsulateHead(buf, "req-hdr", httpBuf, request);
         else if (ICAP::methodReqmod == m)
@@ -1416,16 +1394,16 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
             encapsulateHead(buf, "res-hdr", httpBuf, prime);
 
     if (!virginBody.expected())
-        buf.Printf("null-body=%d", (int) httpBuf.contentSize());
+        buf.appendf("null-body=%d", (int) httpBuf.contentSize());
     else if (ICAP::methodReqmod == m)
-        buf.Printf("req-body=%d", (int) httpBuf.contentSize());
+        buf.appendf("req-body=%d", (int) httpBuf.contentSize());
     else
-        buf.Printf("res-body=%d", (int) httpBuf.contentSize());
+        buf.appendf("res-body=%d", (int) httpBuf.contentSize());
 
     buf.append(ICAP::crlf, 2); // terminate Encapsulated line
 
     if (preview.enabled()) {
-        buf.Printf("Preview: %d\r\n", (int)preview.ad());
+        buf.appendf("Preview: %d\r\n", (int)preview.ad());
         if (!virginBody.expected()) // there is no body to preview
             finishNullOrEmptyBodyPreview(httpBuf);
     }
@@ -1441,7 +1419,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 #endif
             client_addr = request->client_addr;
         if (!client_addr.isAnyAddr() && !client_addr.isNoAddr())
-            buf.Printf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
+            buf.appendf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
     }
 
     if (TheConfig.send_username && request)
@@ -1457,7 +1435,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         HttpReply *reply = dynamic_cast<HttpReply*>(virgin.header);
 
         if (const char *value = (*i)->match(r, reply, alMaster)) {
-            buf.Printf("%s: %s\r\n", (*i)->key.termedBuf(), value);
+            buf.appendf("%s: %s\r\n", (*i)->key.termedBuf(), value);
             Adaptation::History::Pointer ah = request->adaptHistory(false);
             if (ah != NULL) {
                 if (ah->metaHeaders == NULL)
@@ -1537,25 +1515,26 @@ void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, M
             uint8_t base64buf[base64_encode_len(MAX_LOGIN_SZ)];
             size_t resultLen = base64_encode_update(&ctx, base64buf, strlen(value), reinterpret_cast<const uint8_t*>(value));
             resultLen += base64_encode_final(&ctx, base64buf+resultLen);
-            buf.Printf("%s: %.*s\r\n", TheConfig.client_username_header, (int)resultLen, base64buf);
+            buf.appendf("%s: %.*s\r\n", TheConfig.client_username_header, (int)resultLen, base64buf);
         } else
-            buf.Printf("%s: %s\r\n", TheConfig.client_username_header, value);
+            buf.appendf("%s: %s\r\n", TheConfig.client_username_header, value);
     }
 #endif
 }
 
 void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head)
 {
     // update ICAP header
-    icapBuf.Printf("%s=%d, ", section, (int) httpBuf.contentSize());
+    icapBuf.appendf("%s=%d, ", section, (int) httpBuf.contentSize());
 
     // begin cloning
     HttpMsg::Pointer headClone;
 
     if (const HttpRequest* old_request = dynamic_cast<const HttpRequest*>(head)) {
         HttpRequest::Pointer new_request(new HttpRequest);
-        Must(old_request->canonical);
-        urlParse(old_request->method, old_request->canonical, new_request.getRaw());
+        // copy the requst-line details
+        new_request->method = old_request->method;
+        new_request->url = old_request->url;
         new_request->http_ver = old_request->http_ver;
         headClone = new_request.getRaw();
     } else if (const HttpReply *old_reply = dynamic_cast<const HttpReply*>(head)) {
@@ -1585,10 +1564,7 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
 
 void Adaptation::Icap::ModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
 {
-    Packer p;
-    packerToMemInit(&p, &httpBuf);
-    head->packInto(&p, true);
-    packerClean(&p);
+    head->packInto(&httpBuf, true);
 }
 
 // decides whether to offer a preview and calculates its size
@@ -1599,10 +1575,10 @@ void Adaptation::Icap::ModXact::decideOnPreview()
         return;
     }
 
-    const String urlPath = virginRequest().urlpath;
+    const SBuf urlPath(virginRequest().url.path());
     size_t wantedSize;
     if (!service().wantsPreview(urlPath, wantedSize)) {
-        debugs(93, 5, HERE << "should not offer preview for " << urlPath);
+        debugs(93, 5, "should not offer preview for " << urlPath);
         return;
     }
 
@@ -1717,21 +1693,21 @@ void Adaptation::Icap::ModXact::fillPendingStatus(MemBuf &buf) const
         buf.append("r", 1);
 
     if (!state.doneWriting() && state.writing != State::writingInit)
-        buf.Printf("w(%d)", state.writing);
+        buf.appendf("w(%d)", state.writing);
 
     if (preview.enabled()) {
         if (!preview.done())
-            buf.Printf("P(%d)", (int) preview.debt());
+            buf.appendf("P(%d)", (int) preview.debt());
     }
 
     if (virginBodySending.active())
         buf.append("B", 1);
 
     if (!state.doneParsing() && state.parsing != State::psIcapHeader)
-        buf.Printf("p(%d)", state.parsing);
+        buf.appendf("p(%d)", state.parsing);
 
     if (!doneSending() && state.sending != State::sendingUndecided)
-        buf.Printf("S(%d)", state.sending);
+        buf.appendf("S(%d)", state.sending);
 
     if (state.readyForUob)
         buf.append("6", 1);
@@ -1755,7 +1731,7 @@ void Adaptation::Icap::ModXact::fillDoneStatus(MemBuf &buf) const
 
     if (preview.enabled()) {
         if (preview.done())
-            buf.Printf("P%s", preview.ieof() ? "(ieof)" : "");
+            buf.appendf("P%s", preview.ieof() ? "(ieof)" : "");
     }
 
     if (doneReading())
@@ -14,6 +14,7 @@
 #include "adaptation/icap/Launcher.h"
 #include "adaptation/icap/Xaction.h"
 #include "BodyPipe.h"
+#include "http/one/forward.h"
 
 /*
  * ICAPModXact implements ICAP REQMOD and RESPMOD transaction using
@@ -25,8 +26,6 @@
  * receive the HTTP body.
  */
 
-class ChunkedCodingParser;
-
 namespace Adaptation
 {
 namespace Icap
@@ -250,7 +249,7 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
     uint64_t virginConsumed;        // virgin data consumed so far
     Preview preview; // use for creating (writing) the preview
 
-    ChunkedCodingParser *bodyParser; // ICAP response body parser
+    Http1::TeChunkedParser *bodyParser; // ICAP response body parser
 
     bool canStartBypass; // enables bypass of transaction failures
     bool protectGroupBypass; // protects ServiceGroup-wide bypass of failures
@@ -54,15 +54,15 @@ void Adaptation::Icap::OptXact::makeRequest(MemBuf &buf)
 {
     const Adaptation::Service &s = service();
     const String uri = s.cfg().uri;
-    buf.Printf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
+    buf.appendf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
     const String host = s.cfg().host;
-    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
+    buf.appendf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
 
     if (!TheConfig.reuse_connections)
-        buf.Printf("Connection: close\r\n");
+        buf.append("Connection: close\r\n", 19);
 
     if (TheConfig.allow206_enable)
-        buf.Printf("Allow: 206\r\n");
+        buf.append("Allow: 206\r\n", 12);
     buf.append(ICAP::crlf, 2);
 
     // XXX: HttpRequest cannot fully parse ICAP Request-Line
@@ -43,7 +43,8 @@ Adaptation::Icap::Options::~Options()
 // future optimization note: this method is called by ICAP ACL code at least
 // twice for each HTTP message to see if the message should be ignored. For any
 // non-ignored HTTP message, ICAP calls to check whether a preview is needed.
-Adaptation::Icap::Options::TransferKind Adaptation::Icap::Options::transferKind(const String &urlPath) const
+Adaptation::Icap::Options::TransferKind
+Adaptation::Icap::Options::transferKind(const SBuf &urlPath) const
 {
     if (theTransfers.preview.matches(urlPath))
         return xferPreview;
@@ -54,7 +55,7 @@ Adaptation::Icap::Options::TransferKind Adaptation::Icap::Options::transferKind(
     if (theTransfers.ignore.matches(urlPath))
         return xferIgnore;
 
-    debugs(93,7, HERE << "url " << urlPath << " matches no extensions; " <<
+    debugs(93,7, "url " << urlPath << " matches no extensions; " <<
            "using default: " << theTransfers.byDefault->name);
     return theTransfers.byDefault->kind;
 }
@@ -184,26 +185,24 @@ void Adaptation::Icap::Options::TransferList::add(const char *extension)
     wordlistAdd(&extensions, extension);
 };
 
-bool Adaptation::Icap::Options::TransferList::matches(const String &urlPath) const
+bool Adaptation::Icap::Options::TransferList::matches(const SBuf &urlPath) const
 {
-    const int urlLen = urlPath.size();
+    const SBuf::size_type urlLen = urlPath.length();
     for (wordlist *e = extensions; e; e = e->next) {
         // optimize: store extension lengths
-        const int eLen = strlen(e->key);
+        const size_t eLen = strlen(e->key);
 
         // assume URL contains at least '/' before the extension
         if (eLen < urlLen) {
-            const int eOff = urlLen - eLen;
+            const size_t eOff = urlLen - eLen;
             // RFC 3507 examples imply that extensions come without leading '.'
-            if (urlPath[eOff-1] == '.' &&
-                    strcmp(urlPath.termedBuf() + eOff, e->key) == 0) {
-                debugs(93,7, HERE << "url " << urlPath << " matches " <<
-                       name << " extension " << e->key);
+            if (urlPath[eOff-1] == '.' && urlPath.substr(eOff).cmp(e->key, eLen) == 0) {
+                debugs(93,7, "url " << urlPath << " matches " << name << " extension " << e->key);
                 return true;
             }
         }
     }
-    debugs(93,8, HERE << "url " << urlPath << " matches no " << name << " extensions");
+    debugs(93,8, "url " << urlPath << " matches no " << name << " extensions");
     return false;
 }
 
@@ -42,7 +42,7 @@ class Options
     time_t timestamp() const { return theTimestamp; };
 
     typedef enum { xferNone, xferPreview, xferIgnore, xferComplete } TransferKind;
-    TransferKind transferKind(const String &urlPath) const;
+    TransferKind transferKind(const SBuf &urlPath) const;
 
 public:
     const char *error; // human-readable information; set iff !valid()
@@ -68,7 +68,7 @@ class Options
         TransferList();
         ~TransferList();
 
-        bool matches(const String &urlPath) const;
+        bool matches(const SBuf &urlPath) const;
 
         void parse(const String &buf, bool &foundStar);
         void add(const char *extension);
@@ -84,7 +84,7 @@ Adaptation::Icap::ServiceRep::finalize()
 
     if (cfg().secure.encryptTransport) {
         debugs(3, DBG_IMPORTANT, "Initializing service " << cfg().resource << " SSL context");
-        sslContext = writeableCfg().secure.createContext(true);
+        sslContext = writeableCfg().secure.createClientContext(true);
     }
 
     theSessionFailures.configure(TheConfig.oldest_service_failure > 0 ?
@@ -321,13 +321,13 @@ bool Adaptation::Icap::ServiceRep::availableForOld() const
     return (available != 0); // it is -1 (no limit) or has available slots
 }
 
-bool Adaptation::Icap::ServiceRep::wantsUrl(const String &urlPath) const
+bool Adaptation::Icap::ServiceRep::wantsUrl(const SBuf &urlPath) const
 {
     Must(hasOptions());
     return theOptions->transferKind(urlPath) != Adaptation::Icap::Options::xferIgnore;
 }
 
-bool Adaptation::Icap::ServiceRep::wantsPreview(const String &urlPath, size_t &wantedSize) const
+bool Adaptation::Icap::ServiceRep::wantsPreview(const SBuf &urlPath, size_t &wantedSize) const
 {
     Must(hasOptions());
 
@@ -717,7 +717,7 @@ const char *Adaptation::Icap::ServiceRep::status() const
         buf.append(",notif", 6);
 
     if (const int failures = theSessionFailures.remembered())
-        buf.Printf(",fail%d", failures);
+        buf.appendf(",fail%d", failures);
 
     buf.append("]", 1);
     buf.terminate();
@@ -81,8 +81,8 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     void callWhenReady(AsyncCall::Pointer &cb);
 
     // the methods below can only be called on an up() service
-    bool wantsUrl(const String &urlPath) const;
-    bool wantsPreview(const String &urlPath, size_t &wantedSize) const;
+    bool wantsUrl(const SBuf &urlPath) const;
+    bool wantsPreview(const SBuf &urlPath, size_t &wantedSize) const;
     bool allows204() const;
     bool allows206() const;
     Comm::ConnectionPointer getConnection(bool isRetriable, bool &isReused);
@@ -60,9 +60,9 @@ class IcapPeerConnector: public PeerConnector {
         PeerConnector(aServerConn, aCallback, timeout), icapService(service) {}
 
     /* PeerConnector API */
-    virtual SSL *initializeSsl();
+    virtual Security::SessionPointer initializeSsl();
     virtual void noteNegotiationDone(ErrorState *error);
-    virtual SSL_CTX *getSslContext() {return icapService->sslContext; }
+    virtual Security::ContextPointer getSslContext() {return icapService->sslContext;}
 
 private:
     Adaptation::Icap::ServiceRep::Pointer icapService;
@@ -217,7 +217,7 @@ Adaptation::Icap::Xaction::dnsLookupDone(const ipcache_addrs *ia)
     connector = JobCallback(93,3, ConnectDialer, this, Adaptation::Icap::Xaction::noteCommConnected);
     cs = new Comm::ConnOpener(connection, connector, TheConfig.connect_timeout(service().cfg().bypass));
     cs->setHost(s.cfg().host.termedBuf());
-    AsyncJob::Start(cs);
+    AsyncJob::Start(cs.get());
 }
 
 /*
@@ -296,7 +296,7 @@ void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
 #if USE_OPENSSL
     // If it is a reused connection and the SSL object is build
     // we should not negotiate new SSL session
-    SSL *ssl = fd_table[io.conn->fd].ssl;
+    auto ssl = fd_table[io.conn->fd].ssl;
     if (!ssl && service().cfg().secure.encryptTransport) {
         CbcPointer<Adaptation::Icap::Xaction> me(this);
         securer = asyncCall(93, 4, "Adaptation::Icap::Xaction::handleSecuredPeer",
@@ -456,6 +456,11 @@ void Adaptation::Icap::Xaction::noteCommRead(const CommIoCbParams &io)
 
     // TODO: tune this better to expected message sizes
     readBuf.reserveCapacity(SQUID_TCP_SO_RCVBUF);
+    // we are not asked to grow beyond the allowed maximum
+    Must(readBuf.length() < SQUID_TCP_SO_RCVBUF);
+    // now we can ensure that there is space to read new data,
+    // even if readBuf.spaceSize() currently returns zero.
+    readBuf.rawSpace(1);
 
     CommIoCbParams rd(this); // will be expanded with ReadNow results
     rd.conn = io.conn;
@@ -534,7 +539,7 @@ bool Adaptation::Icap::Xaction::parseHttpMsg(HttpMsg *msg)
 bool Adaptation::Icap::Xaction::mayReadMore() const
 {
     return !doneReading() && // will read more data
-           readBuf.spaceSize();  // have space for more data
+           readBuf.length() < SQUID_TCP_SO_RCVBUF;  // have space for more data
 }
 
 bool Adaptation::Icap::Xaction::doneReading() const
@@ -590,7 +595,7 @@ void Adaptation::Icap::Xaction::setOutcome(const Adaptation::Icap::XactOutcome &
 void Adaptation::Icap::Xaction::swanSong()
 {
     // kids should sing first and then call the parent method.
-    if (cs) {
+    if (cs.valid()) {
         debugs(93,6, HERE << id << " about to notify ConnOpener!");
         CallJobHere(93, 3, cs, Comm::ConnOpener, noteAbort);
         cs = NULL;
@@ -656,15 +661,11 @@ const char *Adaptation::Icap::Xaction::status() const
 {
     static MemBuf buf;
     buf.reset();
-
     buf.append(" [", 2);
-
     fillPendingStatus(buf);
     buf.append("/", 1);
     fillDoneStatus(buf);
-
-    buf.Printf(" %s%u]", id.Prefix, id.value);
-
+    buf.appendf(" %s%u]", id.Prefix, id.value);
     buf.terminate();
 
     return buf.content();
@@ -673,7 +674,7 @@ const char *Adaptation::Icap::Xaction::status() const
 void Adaptation::Icap::Xaction::fillPendingStatus(MemBuf &buf) const
 {
     if (haveConnection()) {
-        buf.Printf("FD %d", connection->fd);
+        buf.appendf("FD %d", connection->fd);
 
         if (writer != NULL)
             buf.append("w", 1);
@@ -688,10 +689,10 @@ void Adaptation::Icap::Xaction::fillPendingStatus(MemBuf &buf) const
 void Adaptation::Icap::Xaction::fillDoneStatus(MemBuf &buf) const
 {
     if (haveConnection() && commEof)
-        buf.Printf("Comm(%d)", connection->fd);
+        buf.appendf("Comm(%d)", connection->fd);
 
     if (stopReason != NULL)
-        buf.Printf("Stopped");
+        buf.append("Stopped", 7);
 }
 
 bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &) const
@@ -700,12 +701,12 @@ bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &) const
 }
 
 #if USE_OPENSSL
-SSL *
+Security::SessionPointer
 Ssl::IcapPeerConnector::initializeSsl()
 {
-    SSL *ssl = Ssl::PeerConnector::initializeSsl();
+    auto ssl = Ssl::PeerConnector::initializeSsl();
     if (!ssl)
-        return NULL;
+        return nullptr;
 
     assert(!icapService->cfg().secure.sslDomain.isEmpty());
     SBuf *host = new SBuf(icapService->cfg().secure.sslDomain);
@@ -728,7 +729,7 @@ Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
 
     const int fd = serverConnection()->fd;
-    SSL *ssl = fd_table[fd].ssl;
+    auto ssl = fd_table[fd].ssl;
     assert(ssl);
     if (!SSL_session_reused(ssl)) {
         if (icapService->sslSession)
@@ -12,8 +12,7 @@
 #include "AccessLogEntry.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "adaptation/Initiate.h"
-#include "comm/forward.h"
-#include "CommCalls.h"
+#include "comm/ConnOpener.h"
 #include "HttpReply.h"
 #include "ipcache.h"
 #include "SBuf.h"
@@ -156,7 +155,7 @@ class Xaction: public Adaptation::Initiate
     timeval icap_tio_finish;   /*time when the last byte of the ICAP responsewas received*/
 
 private:
-    Comm::ConnOpener *cs;
+    Comm::ConnOpener::Pointer cs;
     AsyncCall::Pointer securer; ///< whether we are securing a connection
 };
 
@@ -10,6 +10,7 @@
 #include "anyp/PortCfg.h"
 #include "comm.h"
 #include "fatal.h"
+#include "security/PeerOptions.h"
 #if USE_OPENSSL
 #include "ssl/support.h"
 #endif
@@ -43,17 +44,10 @@ AnyP::PortCfg::PortCfg() :
     disable_pmtu_discovery(0),
     listenConn()
 #if USE_OPENSSL
-    ,cert(NULL),
-    key(NULL),
-    version(0),
-    cipher(NULL),
-    options(NULL),
+    ,
     clientca(NULL),
-    cafile(NULL),
-    capath(NULL),
-    crlfile(NULL),
     dhfile(NULL),
-    sslflags(NULL),
+    tls_dh(NULL),
     sslContextSessionId(NULL),
     generateHostCertificates(false),
     dynamicCertMemCacheSize(std::numeric_limits<size_t>::max()),
@@ -66,9 +60,7 @@ AnyP::PortCfg::PortCfg() :
     clientVerifyCrls(),
     clientCA(),
     dhParams(),
-    contextMethod(),
-    sslContextFlags(0),
-    sslOptions(0)
+    eecdhCurve(NULL)
 #endif
 {
     memset(&tcp_keepalive, 0, sizeof(tcp_keepalive));
@@ -85,17 +77,11 @@ AnyP::PortCfg::~PortCfg()
     safe_free(defaultsite);
 
 #if USE_OPENSSL
-    safe_free(cert);
-    safe_free(key);
-    safe_free(cipher);
-    safe_free(options);
     safe_free(clientca);
-    safe_free(cafile);
-    safe_free(capath);
-    safe_free(crlfile);
     safe_free(dhfile);
-    safe_free(sslflags);
+    safe_free(tls_dh);
     safe_free(sslContextSessionId);
+    safe_free(eecdhCurve);
 #endif
 }
 
@@ -118,36 +104,22 @@ AnyP::PortCfg::clone() const
     b->ftp_track_dirs = ftp_track_dirs;
     b->disable_pmtu_discovery = disable_pmtu_discovery;
     b->tcp_keepalive = tcp_keepalive;
+    b->secure = secure;
 
 #if USE_OPENSSL
-    if (cert)
-        b->cert = xstrdup(cert);
-    if (key)
-        b->key = xstrdup(key);
-    b->version = version;
-    if (cipher)
-        b->cipher = xstrdup(cipher);
-    if (options)
-        b->options = xstrdup(options);
     if (clientca)
         b->clientca = xstrdup(clientca);
-    if (cafile)
-        b->cafile = xstrdup(cafile);
-    if (capath)
-        b->capath = xstrdup(capath);
-    if (crlfile)
-        b->crlfile = xstrdup(crlfile);
     if (dhfile)
         b->dhfile = xstrdup(dhfile);
-    if (sslflags)
-        b->sslflags = xstrdup(sslflags);
+    if (tls_dh)
+        b->tls_dh = xstrdup(tls_dh);
     if (sslContextSessionId)
         b->sslContextSessionId = xstrdup(sslContextSessionId);
 
 #if 0
     // TODO: AYJ: 2015-01-15: for now SSL does not clone the context object.
     // cloning should only be done before the PortCfg is post-configure initialized and opened
-    SSL_CTX *sslContext;
+    Security::ContextPointer sslContext;
 #endif
 
 #endif /*0*/
@@ -159,8 +131,8 @@ AnyP::PortCfg::clone() const
 void
 AnyP::PortCfg::configureSslServerContext()
 {
-    if (cert)
-        Ssl::readCertChainAndPrivateKeyFromFiles(signingCert, signPkey, certsToChain, cert, key);
+    if (!secure.certFile.isEmpty())
+        Ssl::readCertChainAndPrivateKeyFromFiles(signingCert, signPkey, certsToChain, secure.certFile.c_str(), secure.privateKeyFile.c_str());
 
     if (!signingCert) {
         char buf[128];
@@ -178,8 +150,8 @@ AnyP::PortCfg::configureSslServerContext()
         fatalf("Unable to generate signing SSL certificate for untrusted sites for %s_port %s", AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
     }
 
-    if (crlfile)
-        clientVerifyCrls.reset(Ssl::loadCrl(crlfile, sslContextFlags));
+    if (!secure.crlFile.isEmpty())
+        clientVerifyCrls.reset(Ssl::loadCrl(secure.crlFile.c_str(), secure.parsedFlags));
 
     if (clientca) {
         clientCA.reset(SSL_load_client_CA_file(clientca));
@@ -188,17 +160,25 @@ AnyP::PortCfg::configureSslServerContext()
         }
     }
 
-    contextMethod = Ssl::contextMethod(version);
-    if (!contextMethod)
-        fatalf("Unable to compute context method to use");
-
-    if (dhfile)
-        dhParams.reset(Ssl::readDHParams(dhfile));
-
-    if (sslflags)
-        sslContextFlags = Ssl::parse_flags(sslflags);
+    secure.updateTlsVersionLimits();
+
+    const char *dhParamsFile = dhfile; // backward compatibility for dhparams= configuration
+    safe_free(eecdhCurve); // clear any previous EECDH configuration
+    if (tls_dh && *tls_dh) {
+        eecdhCurve = xstrdup(tls_dh);
+        char *p = strchr(eecdhCurve, ':');
+        if (p) {  // tls-dh=eecdhCurve:dhParamsFile
+            *p = '\0';
+            dhParamsFile = p+1;
+        } else {  // tls-dh=dhParamsFile
+            dhParamsFile = tls_dh;
+            // a NULL eecdhCurve means "do not use EECDH"
+            safe_free(eecdhCurve);
+        }
+    }
 
-    sslOptions = Ssl::parse_options(options);
+    if (dhParamsFile && *dhParamsFile)
+        dhParams.reset(Ssl::readDHParams(dhParamsFile));
 
     staticSslContext.reset(sslCreateServerContext(*this));
 
@@ -13,6 +13,8 @@
 #include "anyp/ProtocolVersion.h"
 #include "anyp/TrafficMode.h"
 #include "comm/Connection.h"
+#include "SBuf.h"
+#include "security/PeerOptions.h"
 
 #if USE_OPENSSL
 #include "ssl/gadgets.h"
@@ -67,18 +69,13 @@ class PortCfg : public RefCountable
      */
     Comm::ConnectionPointer listenConn;
 
+    /// TLS configuration options for this listening port
+    Security::PeerOptions secure;
+
 #if USE_OPENSSL
-    char *cert;
-    char *key;
-    int version;
-    char *cipher;
-    char *options;
     char *clientca;
-    char *cafile;
-    char *capath;
-    char *crlfile;
     char *dhfile;
-    char *sslflags;
+    char *tls_dh;
     char *sslContextSessionId; ///< "session id context" for staticSslContext
     bool generateHostCertificates; ///< dynamically make host cert for sslBump
     size_t dynamicCertMemCacheSize; ///< max size of generated certificates memory cache
@@ -93,9 +90,7 @@ class PortCfg : public RefCountable
     Ssl::X509_CRL_STACK_Pointer clientVerifyCrls; ///< additional CRL lists to use when verifying the client certificate
     Ssl::X509_NAME_STACK_Pointer clientCA; ///< CA certificates to use when verifying client certificates
     Ssl::DH_Pointer dhParams; ///< DH parameters for temporary/ephemeral DH key exchanges
-    Ssl::ContextMethod contextMethod; ///< The context method (SSL_METHOD) to use when creating certificates
-    long sslContextFlags; ///< flags modifying the use of SSL
-    long sslOptions; ///< SSL engine options
+    char *eecdhCurve; ///< Elliptic curve for ephemeral EC-based DH key exchanges
 #endif
 };
 
@@ -29,3 +29,40 @@ AnyP::UriScheme::c_str() const
     return out;
 }
 
+unsigned short
+AnyP::UriScheme::defaultPort() const
+{
+    switch (theScheme_) {
+
+    case AnyP::PROTO_HTTP:
+        return 80;
+
+    case AnyP::PROTO_HTTPS:
+        return 443;
+
+    case AnyP::PROTO_FTP:
+        return 21;
+
+    case AnyP::PROTO_COAP:
+    case AnyP::PROTO_COAPS:
+        // coaps:// default is TBA as of draft-ietf-core-coap-08.
+        // Assuming IANA policy of allocating same port for base and TLS protocol versions will occur.
+        return 5683;
+
+    case AnyP::PROTO_GOPHER:
+        return 70;
+
+    case AnyP::PROTO_WAIS:
+        return 210;
+
+    case AnyP::PROTO_CACHE_OBJECT:
+        return CACHE_HTTP_PORT;
+
+    case AnyP::PROTO_WHOIS:
+        return 43;
+
+    default:
+        return 0;
+    }
+}
+
@@ -39,6 +39,8 @@ class UriScheme
      */
     char const *c_str() const;
 
+    unsigned short defaultPort() const;
+
 private:
     /// This is a typecode pointer into the enum/registry of protocols handled.
     AnyP::ProtocolType theScheme_;
@@ -147,7 +147,8 @@ Auth::Basic::Config::parse(Auth::Config * scheme, int n_configured, char *param_
 static void
 authenticateBasicStats(StoreEntry * sentry)
 {
-    helperStats(sentry, basicauthenticators, "Basic Authenticator Statistics");
+    if (basicauthenticators)
+        basicauthenticators->packStatsInto(sentry, "Basic Authenticator Statistics");
 }
 
 char *
@@ -39,6 +39,8 @@
  */
 #include "mem/Pool.h"
 
+#include <random>
+
 static AUTHSSTATS authenticateDigestStats;
 
 helper *digestauthenticators = NULL;
@@ -147,30 +149,28 @@ authenticateDigestNonceNew(void)
      * component in the nonce allows us to loop to find a unique nonce.
      * We use H(nonce_data) so the nonce is meaningless to the reciever.
      * So our nonce looks like base64(H(timestamp,pointertohash,randomdata))
-     * And even if our randomness is not very random (probably due to
-     * bad coding on my part) we don't really care - the timestamp and
-     * memory pointer also guarantee local uniqueness in the input to the hash
-     * function.
+     * And even if our randomness is not very random we don't really care
+     * - the timestamp and memory pointer also guarantee local uniqueness
+     * in the input to the hash function.
      */
+    // NP: this will likely produce the same randomness sequences for each worker
+    // since they should all start within the 1-second resolution of seed value.
+    static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
+    static std::uniform_int_distribution<uint32_t> newRandomData;
 
     /* create a new nonce */
     newnonce->nc = 0;
     newnonce->flags.valid = true;
     newnonce->noncedata.self = newnonce;
     newnonce->noncedata.creationtime = current_time.tv_sec;
-    newnonce->noncedata.randomdata = squid_random();
+    newnonce->noncedata.randomdata = newRandomData(mt);
 
     authDigestNonceEncode(newnonce);
-    /*
-     * loop until we get a unique nonce. The nonce creation must
-     * have a random factor
-     */
 
+    // ensure temporal uniqueness by checking for existing nonce
     while (authenticateDigestNonceFindNonce((char const *) (newnonce->key))) {
         /* create a new nonce */
-        newnonce->noncedata.randomdata = squid_random();
-        /* Bug 3526 high performance fix: add 1 second to creationtime to avoid duplication */
-        ++newnonce->noncedata.creationtime;
+        newnonce->noncedata.randomdata = newRandomData(mt);
         authDigestNonceEncode(newnonce);
     }
 
@@ -643,7 +643,8 @@ Auth::Digest::Config::type() const
 static void
 authenticateDigestStats(StoreEntry * sentry)
 {
-    helperStats(sentry, digestauthenticators, "Digest Authenticator Statistics");
+    if (digestauthenticators)
+        digestauthenticators->packStatsInto(sentry, "Digest Authenticator Statistics");
 }
 
 /* NonceUserUnlink: remove the reference to auth_user and unlink the node from the list */
@@ -32,7 +32,7 @@ struct _digest_nonce_data {
     time_t creationtime;
     /* in memory address of the nonce struct (similar purpose to an ETag) */
     digest_nonce_h *self;
-    long randomdata;
+    uint32_t randomdata;
 };
 
 /* the nonce structure we'll pass around */
@@ -244,7 +244,8 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
 static void
 authenticateNegotiateStats(StoreEntry * sentry)
 {
-    helperStatefulStats(sentry, negotiateauthenticators, "Negotiate Authenticator Statistics");
+    if (negotiateauthenticators)
+        negotiateauthenticators->packStatsInto(sentry, "Negotiate Authenticator Statistics");
 }
 
 /*
@@ -224,7 +224,8 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
 static void
 authenticateNTLMStats(StoreEntry * sentry)
 {
-    helperStatefulStats(sentry, ntlmauthenticators, "NTLM Authenticator Statistics");
+    if (ntlmauthenticators)
+        ntlmauthenticators->packStatsInto(sentry, "NTLM Authenticator Statistics");
 }
 
 /*
@@ -162,10 +162,9 @@ const char *AsyncJob::status() const
 
     buf.append(" [", 2);
     if (stopReason != NULL) {
-        buf.Printf("Stopped, reason:");
-        buf.Printf("%s",stopReason);
+        buf.appendf("Stopped, reason:%s", stopReason);
     }
-    buf.Printf(" %s%u]", id.Prefix, id.value);
+    buf.appendf(" %s%u]", id.Prefix, id.value);
     buf.terminate();
 
     return buf.content();
@@ -37,7 +37,7 @@ If you want to do something before starting the job, do it in the constructor
 or some custom method that the job creator will call _before_ calling
 AsyncJob::Start():
 
-    std::auto_ptr<MyJob> job(new MyJob(...)); // sync/blocking
+    std::unique_ptr<MyJob> job(new MyJob(...)); // sync/blocking
     job->prepare(...); // sync/blocking
     job->prepareSomethingElse(...); // sync/blocking
     AsyncStart(job.release()); // non-blocking
@@ -26,6 +26,7 @@ libbase_la_SOURCES = \
 	InstanceId.h \
 	Lock.h \
 	LruMap.h \
+	Packable.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_BASE_PACKABLE_H
+#define SQUID_SRC_BASE_PACKABLE_H
+
+/**
+ * A uniform interface to store-like modules
+ *
+ * Rationale:
+ * ----------
+ *
+ * We have two major interfaces Comm and Store, which take a variety of
+ * different data buffering objects and have different output actions
+ * to be performed on data.
+ *
+ * Store has a nice storeAppend[Printf] capability which makes "storing"
+ * things easy and painless.
+ *
+ * Comm lacks commAppend[Printf] because Comm does not handle its own
+ * buffers (no mem_obj equivalent for Comm).
+ *
+ * Thus, if one wants to be able to Store _and_ Comm::Write an object, 'e
+ * has to implement almost identical functions for using all the data
+ * storage objects and their associated actions. Doing this for all the
+ * available data storage types is a tedious nightmare of almost-duplicated
+ * code.
+ *
+ * Packer
+ * ------
+ *
+ * Objects inheriting from Packable provide a uniform interface for code to
+ * assemble data before passing to Store and Comm modules.
+ *
+ * Packable objects have their own append and printf routines that "know"
+ * where to send incoming data. In case of Store interface, sending data to
+ * storeAppend. Packable buffer objects retain the data such that it can be
+ * flushed later to Comm::Write.
+ *
+ * Thus, one can write just one function that will take a Packable object
+ * and either "pack" things for Comm::Write or "append" things to Store,
+ * depending on actual Packable object supplied.
+ */
+class Packable
+{
+public:
+    /// Appends a c-string to existing packed data.
+    virtual void append(const char *buf, int size) = 0;
+
+    /// Append operation with printf-style arguments.
+    void appendf(const char *fmt,...) PRINTF_FORMAT_ARG2
+    {
+        va_list args;
+        va_start(args, fmt);
+        vappendf(fmt, args);
+        va_end(args);
+    }
+
+    /** Append operation, with vsprintf(3)-style arguments.
+     *
+     * \note arguments may be evaluated more than once, be careful
+     *       of side-effects
+     */
+    virtual void vappendf(const char *fmt, va_list ap) = 0;
+};
+
+#endif /* SQUID_SRC_BASE_PACKABLE_H */
+
@@ -32,6 +32,14 @@ RegisterRunner(RegisteredRunner *rr)
     return runners.size();
 }
 
+int
+DeregisterRunner(RegisteredRunner *rr)
+{
+    Runners &runners = GetRunners();
+    runners.erase(rr);
+    return runners.size();
+}
+
 void
 RunRegistered(const RegisteredRunner::Method &m)
 {
@@ -68,6 +68,12 @@ class RegisteredRunner
     /// Meant for cleanup and state saving that may require other modules.
     virtual void startShutdown() {}
 
+    /// Called after shutdown_lifetime grace period ends and before stopping
+    /// the main loop. At least one main loop iteration is guaranteed after
+    /// this call.
+    /// Meant for cleanup and state saving that may require other modules.
+    virtual void endingShutdown() {}
+
     /// Called after stopping the main loop and before releasing memory.
     /// Meant for quick/basic cleanup that does not require any other modules.
     virtual ~RegisteredRunner() {}
@@ -82,6 +88,9 @@ class RegisteredRunner
 /// registers a given runner with the given registry and returns registry count
 int RegisterRunner(RegisteredRunner *rr);
 
+/// de-registers a given runner with the given registry and returns registry count
+int DeregisterRunner(RegisteredRunner *rr);
+
 /// Calls a given method of all runners.
 /// All runners are destroyed after the finishShutdown() call.
 void RunRegistered(const RegisteredRunner::Method &m);
@@ -11,7 +11,7 @@
 
 /**
  * A pointer that deletes the object it points to when the pointer's owner or
- * context is gone. Similar to std::auto_ptr but without confusing assignment
+ * context is gone. Similar to std::unique_ptr but without confusing assignment
  * and with a customizable cleanup method. Prevents memory leaks in
  * the presence of exceptions and processing short cuts.
 */
@@ -784,13 +784,6 @@ configDoConfigure(void)
             break;
         }
 
-        for (R = Config.Refresh; R; R = R->next) {
-            if (!R->flags.ignore_must_revalidate)
-                continue;
-            debugs(22, DBG_IMPORTANT, "WARNING: use of 'ignore-must-revalidate' in 'refresh_pattern' violates HTTP");
-            break;
-        }
-
         for (R = Config.Refresh; R; R = R->next) {
             if (!R->flags.ignore_private)
                 continue;
@@ -872,11 +865,14 @@ configDoConfigure(void)
         Config2.effectiveGroupID = grp->gr_gid;
     }
 
-#if USE_OPENSSL
-
-    debugs(3, DBG_IMPORTANT, "Initializing https proxy context");
-
-    Config.ssl_client.sslContext = Security::ProxyOutgoingConfig.createContext(false);
+    if (Security::ProxyOutgoingConfig.encryptTransport) {
+        debugs(3, DBG_IMPORTANT, "Initializing https:// proxy context");
+        Config.ssl_client.sslContext = Security::ProxyOutgoingConfig.createClientContext(false);
+        if (!Config.ssl_client.sslContext) {
+            debugs(3, DBG_CRITICAL, "ERROR: Could not initialize https:// proxy context");
+            self_destruct();
+        }
+    }
 
     for (CachePeer *p = Config.peers; p != NULL; p = p->next) {
 
@@ -885,11 +881,16 @@ configDoConfigure(void)
             p->secure.sslDomain = p->host;
 
         if (p->secure.encryptTransport) {
-            debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " SSL context");
-            p->sslContext = p->secure.createContext(true);
+            debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " TLS context");
+            p->sslContext = p->secure.createClientContext(true);
+            if (!p->sslContext) {
+                debugs(3, DBG_CRITICAL, "ERROR: Could not initialize cache_peer " << p->name << " TLS context");
+                self_destruct();
+            }
         }
     }
 
+#if USE_OPENSSL
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (!s->flags.tunnelSslBumping)
             continue;
@@ -2195,7 +2196,9 @@ parse_peer(CachePeer ** head)
             p->secure.encryptTransport = true;
             p->secure.parse(token+3);
 #endif
-
+        } else if (strncmp(token, "tls-", 4) == 0) {
+            p->secure.encryptTransport = true;
+            p->secure.parse(token+4);
         } else if (strcmp(token, "front-end-https") == 0) {
             p->front_end_https = 1;
         } else if (strcmp(token, "front-end-https=on") == 0) {
@@ -2586,9 +2589,6 @@ dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
         if (head->flags.ignore_no_store)
             storeAppendPrintf(entry, " ignore-no-store");
 
-        if (head->flags.ignore_must_revalidate)
-            storeAppendPrintf(entry, " ignore-must-revalidate");
-
         if (head->flags.ignore_private)
             storeAppendPrintf(entry, " ignore-private");
 #endif
@@ -2618,7 +2618,6 @@ parse_refreshpattern(RefreshPattern ** head)
     int reload_into_ims = 0;
     int ignore_reload = 0;
     int ignore_no_store = 0;
-    int ignore_must_revalidate = 0;
     int ignore_private = 0;
 #endif
 
@@ -2688,6 +2687,7 @@ parse_refreshpattern(RefreshPattern ** head)
             store_stale = 1;
         } else if (!strncmp(token, "max-stale=", 10)) {
             max_stale = xatoi(token + 10);
+
 #if USE_HTTP_VIOLATIONS
 
         } else if (!strcmp(token, "override-expire"))
@@ -2696,12 +2696,8 @@ parse_refreshpattern(RefreshPattern ** head)
             override_lastmod = 1;
         else if (!strcmp(token, "ignore-no-store"))
             ignore_no_store = 1;
-        else if (!strcmp(token, "ignore-must-revalidate"))
-            ignore_must_revalidate = 1;
         else if (!strcmp(token, "ignore-private"))
             ignore_private = 1;
-        else if (!strcmp(token, "ignore-auth"))
-            debugs(22, DBG_PARSE_NOTE(2), "UPGRADE: refresh_pattern option 'ignore-auth' is obsolete. Remove it.");
         else if (!strcmp(token, "reload-into-ims")) {
             reload_into_ims = 1;
             refresh_nocache_hack = 1;
@@ -2712,8 +2708,11 @@ parse_refreshpattern(RefreshPattern ** head)
             /* tell client_side.c that this is used */
 #endif
 
-        } else if (!strcmp(token, "ignore-no-cache")) {
-            debugs(22, DBG_PARSE_NOTE(2), "UPGRADE: refresh_pattern option 'ignore-no-cache' is obsolete. Remove it.");
+        } else if (!strcmp(token, "ignore-no-cache") ||
+                   !strcmp(token, "ignore-must-revalidate") ||
+                   !strcmp(token, "ignore-auth")
+                  ) {
+            debugs(22, DBG_PARSE_NOTE(2), "UPGRADE: refresh_pattern option '" << token << "' is obsolete. Remove it.");
         } else
             debugs(22, DBG_CRITICAL, "refreshAddToList: Unknown option '" << pattern << "': " << token);
     }
@@ -2764,9 +2763,6 @@ parse_refreshpattern(RefreshPattern ** head)
     if (ignore_no_store)
         t->flags.ignore_no_store = true;
 
-    if (ignore_must_revalidate)
-        t->flags.ignore_must_revalidate = true;
-
     if (ignore_private)
         t->flags.ignore_private = true;
 #endif
@@ -3570,45 +3566,42 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
         }
 #if USE_OPENSSL
     } else if (strcmp(token, "sslBump") == 0) {
-        debugs(3, DBG_CRITICAL, "WARNING: '" << token << "' is deprecated " <<
+        debugs(3, DBG_PARSE_NOTE(1), "WARNING: '" << token << "' is deprecated " <<
                "in " << cfg_directive << ". Use 'ssl-bump' instead.");
         s->flags.tunnelSslBumping = true;
     } else if (strcmp(token, "ssl-bump") == 0) {
         s->flags.tunnelSslBumping = true;
     } else if (strncmp(token, "cert=", 5) == 0) {
-        safe_free(s->cert);
-        s->cert = xstrdup(token + 5);
+        s->secure.parse(token);
     } else if (strncmp(token, "key=", 4) == 0) {
-        safe_free(s->key);
-        s->key = xstrdup(token + 4);
+        s->secure.parse(token);
     } else if (strncmp(token, "version=", 8) == 0) {
-        s->version = xatoi(token + 8);
-        if (s->version < 1 || s->version > 4)
-            self_destruct();
+        debugs(3, DBG_PARSE_NOTE(1), "UPGRADE WARNING: '" << token << "' is deprecated " <<
+               "in " << cfg_directive << ". Use 'options=' instead.");
+        s->secure.parse(token);
     } else if (strncmp(token, "options=", 8) == 0) {
-        safe_free(s->options);
-        s->options = xstrdup(token + 8);
+        s->secure.parse(token);
     } else if (strncmp(token, "cipher=", 7) == 0) {
-        safe_free(s->cipher);
-        s->cipher = xstrdup(token + 7);
+        s->secure.parse(token);
     } else if (strncmp(token, "clientca=", 9) == 0) {
         safe_free(s->clientca);
         s->clientca = xstrdup(token + 9);
     } else if (strncmp(token, "cafile=", 7) == 0) {
-        safe_free(s->cafile);
-        s->cafile = xstrdup(token + 7);
+        s->secure.parse(token);
     } else if (strncmp(token, "capath=", 7) == 0) {
-        safe_free(s->capath);
-        s->capath = xstrdup(token + 7);
+        s->secure.parse(token);
     } else if (strncmp(token, "crlfile=", 8) == 0) {
-        safe_free(s->crlfile);
-        s->crlfile = xstrdup(token + 8);
+        s->secure.parse(token);
     } else if (strncmp(token, "dhparams=", 9) == 0) {
+        debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: '" << token << "' is deprecated " <<
+               "in " << cfg_directive << ". Use 'tls-dh=' instead.");
         safe_free(s->dhfile);
         s->dhfile = xstrdup(token + 9);
+    } else if (strncmp(token, "tls-dh=", 7) == 0) {
+        safe_free(s->tls_dh);
+        s->tls_dh = xstrdup(token + 7);
     } else if (strncmp(token, "sslflags=", 9) == 0) {
-        safe_free(s->sslflags);
-        s->sslflags = xstrdup(token + 9);
+        s->secure.parse(token+3);
     } else if (strncmp(token, "sslcontext=", 11) == 0) {
         safe_free(s->sslContextSessionId);
         s->sslContextSessionId = xstrdup(token + 11);
@@ -3621,6 +3614,8 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
     } else if (strncmp(token, "dynamic_cert_mem_cache_size=", 28) == 0) {
         parseBytesOptionValue(&s->dynamicCertMemCacheSize, B_BYTES_STR, token + 28);
 #endif
+    } else if (strncmp(token, "tls-", 4) == 0) {
+        s->secure.parse(token+4);
     } else if (strcmp(token, "ftp-track-dirs") == 0) {
         s->ftp_track_dirs = true;
     } else {
@@ -3674,6 +3669,7 @@ parsePortCfg(AnyP::PortCfgPointer *head, const char *optionName)
     }
 
     if (s->transport.protocol == AnyP::PROTO_HTTPS) {
+        s->secure.encryptTransport = true;
 #if USE_OPENSSL
         /* ssl-bump on https_port configuration requires either tproxy or intercept, and vice versa */
         const bool hijacked = s->flags.isIntercepted();
@@ -3801,36 +3797,16 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfgPointer &s)
 #if USE_OPENSSL
     if (s->flags.tunnelSslBumping)
         storeAppendPrintf(e, " ssl-bump");
+#endif
 
-    if (s->cert)
-        storeAppendPrintf(e, " cert=%s", s->cert);
-
-    if (s->key)
-        storeAppendPrintf(e, " key=%s", s->key);
-
-    if (s->version)
-        storeAppendPrintf(e, " version=%d", s->version);
-
-    if (s->options)
-        storeAppendPrintf(e, " options=%s", s->options);
-
-    if (s->cipher)
-        storeAppendPrintf(e, " cipher=%s", s->cipher);
-
-    if (s->cafile)
-        storeAppendPrintf(e, " cafile=%s", s->cafile);
-
-    if (s->capath)
-        storeAppendPrintf(e, " capath=%s", s->capath);
-
-    if (s->crlfile)
-        storeAppendPrintf(e, " crlfile=%s", s->crlfile);
+    s->secure.dumpCfg(e, "tls-");
 
+#if USE_OPENSSL
     if (s->dhfile)
         storeAppendPrintf(e, " dhparams=%s", s->dhfile);
 
-    if (s->sslflags)
-        storeAppendPrintf(e, " sslflags=%s", s->sslflags);
+    if (s->tls_dh)
+        storeAppendPrintf(e, " tls-dh=%s", s->tls_dh);
 
     if (s->sslContextSessionId)
         storeAppendPrintf(e, " sslcontext=%s", s->sslContextSessionId);
@@ -157,45 +157,43 @@ carpSelectParent(HttpRequest * request)
         return NULL;
 
     /* calculate hash key */
-    debugs(39, 2, "carpSelectParent: Calculating hash for " << urlCanonical(request));
+    debugs(39, 2, "carpSelectParent: Calculating hash for " << request->effectiveRequestUri());
 
     /* select CachePeer */
     for (k = 0; k < n_carp_peers; ++k) {
         SBuf key;
         tp = carp_peers[k];
         if (tp->options.carp_key.set) {
-            //this code follows urlCanonical's pattern.
-            //   corner cases should use the canonical URL
+            // this code follows URI syntax pattern.
+            // corner cases should use the full effective request URI
             if (tp->options.carp_key.scheme) {
                 key.append(request->url.getScheme().c_str());
                 if (key.length()) //if the scheme is not empty
                     key.append("://");
             }
             if (tp->options.carp_key.host) {
-                key.append(request->GetHost());
+                key.append(request->url.host());
             }
             if (tp->options.carp_key.port) {
-                key.appendf(":%d", request->port);
+                key.appendf(":%u", request->url.port());
             }
             if (tp->options.carp_key.path) {
-                String::size_type pos;
-                if ((pos=request->urlpath.find('?'))!=String::npos)
-                    key.append(SBuf(request->urlpath.substr(0,pos)));
-                else
-                    key.append(SBuf(request->urlpath));
+                // XXX: fix when path and query are separate
+                key.append(request->url.path().substr(0,request->url.path().find('?'))); // 0..N
             }
             if (tp->options.carp_key.params) {
-                String::size_type pos;
-                if ((pos=request->urlpath.find('?'))!=String::npos)
-                    key.append(SBuf(request->urlpath.substr(pos,request->urlpath.size())));
+                // XXX: fix when path and query are separate
+                SBuf::size_type pos;
+                if ((pos=request->url.path().find('?')) != SBuf::npos)
+                    key.append(request->url.path().substr(pos)); // N..npos
             }
         }
         // if the url-based key is empty, e.g. because the user is
         // asking to balance on the path but the request doesn't supply any,
-        // then fall back to canonical URL
+        // then fall back to the effective request URI
 
         if (key.isEmpty())
-            key=SBuf(urlCanonical(request));
+            key=request->effectiveRequestUri();
 
         for (const char *c = key.rawContent(), *e=key.rawContent()+key.length(); c < e; ++c)
             user_hash += ROTATE_LEFT(user_hash, 19) + *c;
@@ -200,7 +200,7 @@ DOC_END
 NAME: sslproxy_version
 TYPE: obsolete
 DOC_START
-	Remove this line. Use tls_outgoing_options version= instead.
+	Remove this line. Use tls_outgoing_options options= instead.
 DOC_END
 
 # Options removed in 3.5
@@ -764,6 +764,12 @@ DOC_START
 	FORMAT specifications
 
 	  %LOGIN	Authenticated user login name
+	  %un		A user name. Expands to the first available name
+	  		from the following list of information sources:
+			- authenticated user name, like %ul or %LOGIN
+			- user name sent by an external ACL, like %EXT_USER
+			- SSL client name, like %us in logformat
+			- ident user name, like %ui in logformat
 	  %EXT_USER	Username from previous external acl
 	  %EXT_LOG	Log details from previous external acl
 	  %EXT_TAG	Tag from previous external acl
@@ -1128,11 +1134,11 @@ DOC_START
 
 	acl aclname user_cert attribute values...
 	  # match against attributes in a user SSL certificate
-	  # attribute is one of DN/C/O/CN/L/ST [fast]
+	  # attribute is one of DN/C/O/CN/L/ST or a numerical OID [fast]
 
 	acl aclname ca_cert attribute values...
 	  # match against attributes a users issuing CA SSL certificate
-	  # attribute is one of DN/C/O/CN/L/ST [fast]
+	  # attribute is one of DN/C/O/CN/L/ST or a numerical OID  [fast]
 
 	acl aclname ext_user username ...
 	acl aclname ext_user_regex [-i] pattern ...
@@ -1914,13 +1920,6 @@ DOC_START
 			assumed to be a combined certificate and
 			key file.
 
-	   version=	The version of SSL/TLS supported
-			    1	automatic (default)
-			    3	SSLv3 only
-			    4	TLSv1.0 only
-			    5	TLSv1.1 only
-			    6	TLSv1.2 only
-
 	   cipher=	Colon separated list of supported ciphers.
 			NOTE: some ciphers such as EDH ciphers depend on
 			      additional settings. If those settings are
@@ -1942,6 +1941,11 @@ DOC_START
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
+			    SINGLE_ECDH_USE
+				      Enable ephemeral ECDH key exchange.
+				      The adopted curve should be specified
+				      using the tls-dh option.
+
 			    NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
@@ -1970,11 +1974,15 @@ DOC_START
 			the client certificate, in addition to CRLs stored in
 			the capath. Implies VERIFY_CRL flag below.
 
-	   dhparams=	File containing DH parameters for temporary/ephemeral
-			DH key exchanges. See OpenSSL documentation for details
-			on how to create this file.
-			WARNING: EDH ciphers will be silently disabled if this
-				 option is not set.
+	   tls-dh=[curve:]file
+			File containing DH parameters for temporary/ephemeral DH key
+			exchanges, optionally prefixed by a curve for ephemeral ECDH
+			key exchanges.
+			See OpenSSL documentation for details on how to create the
+			DH parameter file. Supported curves for ECDH can be listed
+			using the "openssl ecparam -list_curves" command.
+			WARNING: EDH and EECDH ciphers will be silently disabled if
+				 this option is not set.
 
 	   sslflags=	Various flags modifying the use of SSL:
 			    DELAYED_AUTH
@@ -2100,11 +2108,6 @@ DOC_START
 			assumed to be a combined certificate and
 			key file.
 
-	   version=	The version of SSL/TLS supported
-			    1	automatic (default)
-			    3	SSLv3 only
-			    4	TLSv1 only
-
 	   cipher=	Colon separated list of supported ciphers.
 
 	   options=	Various SSL engine options. The most important
@@ -2122,6 +2125,11 @@ DOC_START
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
+			    SINGLE_ECDH_USE
+				      Enable ephemeral ECDH key exchange.
+				      The adopted curve should be specified
+				      using the tls-dh option.
+
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
@@ -2150,8 +2158,10 @@ DOC_START
 			the client certificate, in addition to CRLs stored in
 			the capath. Implies VERIFY_CRL flag below.
 
-	   dhparams=	File containing DH parameters for temporary/ephemeral
-			DH key exchanges.
+	   tls-dh=[curve:]file
+			File containing DH parameters for temporary/ephemeral DH key
+			exchanges, optionally prefixed by a curve for ephemeral ECDH
+			key exchanges.
 
 	   sslflags=	Various flags modifying the use of SSL:
 			    DELAYED_AUTH
@@ -2587,7 +2597,7 @@ COMMENT_END
 NAME: tls_outgoing_options
 IFDEF: USE_GNUTLS||USE_OPENSSL
 TYPE: securePeerOptions
-DEFAULT: disable
+DEFAULT: min-version=1.0
 LOC: Security::ProxyOutgoingConfig
 DOC_START
 	disable		Do not support https:// URLs.
@@ -2600,16 +2610,13 @@ DOC_START
 			If key= is not specified cert= is assumed to reference
 			a PEM file containing both the certificate and the key.
 	
-	version=1|3|4|5|6
-			The TLS/SSL version to use when connecting
-				1 = automatic (default)
-				3 = SSL v3 only
-				4 = TLS v1.0 only
-				5 = TLS v1.1 only
-				6 = TLS v1.2 only
-	
 	cipher=...	The list of valid TLS ciphers to use.
-	
+
+	min-version=1.N
+			The minimum TLS protocol version to permit.
+			To control SSLv3 use the options= parameter.
+			Supported Values: 1.0 (default), 1.1, 1.2
+
 	options=... 	Specify various TLS/SSL implementation options:
 
 			    NO_SSLv3    Disallow the use of SSLv3
@@ -3339,17 +3346,14 @@ DOC_START
 			reference a combined file containing both the
 			certificate and the key.
 	
-	sslversion=1|3|4|5|6
-			The SSL version to use when connecting to this peer
-				1 = automatic (default)
-				3 = SSL v3 only
-				4 = TLS v1.0 only
-				5 = TLS v1.1 only
-				6 = TLS v1.2 only
-	
 	sslcipher=...	The list of valid SSL ciphers to use when connecting
 			to this peer.
-	
+
+	tls-min-version=1.N
+			The minimum TLS protocol version to permit. To control
+			SSLv3 use the ssloptions= parameter.
+			Supported Values: 1.0 (default), 1.1, 1.2
+
 	ssloptions=... 	Specify various SSL implementation options:
 
 			    NO_SSLv3    Disallow the use of SSLv3
@@ -4152,6 +4156,12 @@ DOC_START
 		ue	User name from external acl helper
 		ui	User name from ident
 		us	User name from SSL
+		un	A user name. Expands to the first available name
+			from the following list of information sources:
+			- authenticated user name, like %ul
+			- user name supplied by an external ACL, like %ue
+			- SSL client name, like %us
+			- ident user name, like %ui
 		credentials Client credentials. The exact meaning depends on
 			the authentication scheme: For Basic authentication,
 			it is the password; for Digest, the realm sent by the
@@ -5454,9 +5464,7 @@ DOC_START
 		 reload-into-ims
 		 ignore-reload
 		 ignore-no-store
-		 ignore-must-revalidate
 		 ignore-private
-		 ignore-auth
 		 max-stale=NN
 		 refresh-ims
 		 store-stale
@@ -5492,22 +5500,11 @@ DOC_START
 		the HTTP standard. Enabling this feature could make you
 		liable for problems which it causes.
 
-		ignore-must-revalidate ignores any ``Cache-Control: must-revalidate``
-		headers received from a server. Doing this VIOLATES
-		the HTTP standard. Enabling this feature could make you
-		liable for problems which it causes.
-
 		ignore-private ignores any ``Cache-control: private''
 		headers received from a server. Doing this VIOLATES
 		the HTTP standard. Enabling this feature could make you
 		liable for problems which it causes.
 
-		ignore-auth caches responses to requests with authorization,
-		as if the originserver had sent ``Cache-control: public''
-		in the response header. Doing this VIOLATES the HTTP standard.
-		Enabling this feature could make you liable for problems which
-		it causes.
-
 		refresh-ims causes squid to contact the origin server
 		when a client issues an If-Modified-Since request. This
 		ensures that the client will receive an updated version
@@ -8499,18 +8496,14 @@ DOC_START
 			reference a combined file containing both the
 			certificate and the key.
 
-	sslversion=1|3|4|5|6
-			The SSL version to use when connecting to this icap
-			server
-				1 = automatic (default)
-				3 = SSL v3 only
-				4 = TLS v1.0 only
-				5 = TLS v1.1 only
-				6 = TLS v1.2 only
-
 	sslcipher=...	The list of valid SSL ciphers to use when connecting
 			to this icap server.
 
+	tls-min-version=1.N
+			The minimum TLS protocol version to permit. To control
+			SSLv3 use the ssloptions= parameter.
+			Supported Values: 1.0 (default), 1.1, 1.2
+
 	ssloptions=...	Specify various SSL implementation options:
 
 			    NO_SSLv3    Disallow the use of SSLv3
@@ -391,10 +391,11 @@ main(int argc, char *argv[])
                     entries.back().nocomment.push_back(buff);
                 }
                 break;
-
+#if 0
             case sEXIT:
                 assert(0);      /* should never get here */
                 break;
+#endif
             }
 
     }
@@ -137,7 +137,7 @@ ClientInfo * clientdbGetInfo(const Ip::Address &addr)
 }
 #endif
 void
-clientdbUpdate(const Ip::Address &addr, LogTags ltype, AnyP::ProtocolType p, size_t size)
+clientdbUpdate(const Ip::Address &addr, const LogTags &ltype, AnyP::ProtocolType p, size_t size)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
@@ -157,17 +157,17 @@ clientdbUpdate(const Ip::Address &addr, LogTags ltype, AnyP::ProtocolType p, siz
 
     if (p == AnyP::PROTO_HTTP) {
         ++ c->Http.n_requests;
-        ++ c->Http.result_hist[ltype];
+        ++ c->Http.result_hist[ltype.oldType];
         kb_incr(&c->Http.kbytes_out, size);
 
-        if (logTypeIsATcpHit(ltype))
+        if (ltype.isTcpHit())
             kb_incr(&c->Http.hit_kbytes_out, size);
     } else if (p == AnyP::PROTO_ICP) {
         ++ c->Icp.n_requests;
-        ++ c->Icp.result_hist[ltype];
+        ++ c->Icp.result_hist[ltype.oldType];
         kb_incr(&c->Icp.kbytes_out, size);
 
-        if (LOG_UDP_HIT == ltype)
+        if (LOG_UDP_HIT == ltype.oldType)
             kb_incr(&c->Icp.hit_kbytes_out, size);
     }
 
@@ -287,7 +287,7 @@ clientdbDump(StoreEntry * sentry)
         storeAppendPrintf(sentry, "    ICP  Requests %d\n",
                           c->Icp.n_requests);
 
-        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags_ot l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (c->Icp.result_hist[l] == 0)
                 continue;
 
@@ -296,23 +296,23 @@ clientdbDump(StoreEntry * sentry)
             if (LOG_UDP_HIT == l)
                 icp_hits += c->Icp.result_hist[l];
 
-            storeAppendPrintf(sentry, "        %-20.20s %7d %3d%%\n",LogTags_str[l], c->Icp.result_hist[l], Math::intPercent(c->Icp.result_hist[l], c->Icp.n_requests));
+            storeAppendPrintf(sentry, "        %-20.20s %7d %3d%%\n", LogTags(l).c_str(), c->Icp.result_hist[l], Math::intPercent(c->Icp.result_hist[l], c->Icp.n_requests));
         }
 
         storeAppendPrintf(sentry, "    HTTP Requests %d\n", c->Http.n_requests);
 
-        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags_ot l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (c->Http.result_hist[l] == 0)
                 continue;
 
             http_total += c->Http.result_hist[l];
 
-            if (logTypeIsATcpHit(l))
+            if (LogTags(l).isTcpHit())
                 http_hits += c->Http.result_hist[l];
 
             storeAppendPrintf(sentry,
                               "        %-20.20s %7d %3d%%\n",
-                              LogTags_str[l],
+                              LogTags(l).c_str(),
                               c->Http.result_hist[l],
                               Math::intPercent(c->Http.result_hist[l], c->Http.n_requests));
         }
@@ -521,8 +521,8 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
     case MESH_CTBL_HTHITS:
         aggr = 0;
 
-        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
-            if (logTypeIsATcpHit(l))
+        for (LogTags_ot l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+            if (LogTags(l).isTcpHit())
                 aggr += c->Http.result_hist[l];
         }
 
@@ -24,7 +24,7 @@ class Address;
 class StoreEntry;
 class ClientInfo;
 
-void clientdbUpdate(const Ip::Address &, LogTags, AnyP::ProtocolType, size_t);
+void clientdbUpdate(const Ip::Address &, const LogTags &, AnyP::ProtocolType, size_t);
 int clientdbCutoffDenied(const Ip::Address &);
 void clientdbDump(StoreEntry *);
 void clientdbFreeMemory(void);
@@ -63,7 +63,6 @@
 #include "base/Subscription.h"
 #include "base/TextException.h"
 #include "CachePeer.h"
-#include "ChunkedCodingParser.h"
 #include "client_db.h"
 #include "client_side.h"
 #include "client_side_reply.h"
@@ -87,6 +86,7 @@
 #include "helper/Reply.h"
 #include "http.h"
 #include "http/one/RequestParser.h"
+#include "http/one/TeChunkedParser.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -189,13 +189,13 @@ static IDCB clientIdentDone;
 static int clientIsContentLengthValid(HttpRequest * r);
 static int clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength);
 
-static void clientUpdateStatHistCounters(LogTags logType, int svc_time);
-static void clientUpdateStatCounters(LogTags logType);
+static void clientUpdateStatHistCounters(const LogTags &logType, int svc_time);
+static void clientUpdateStatCounters(const LogTags &logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
-static void clientUpdateSocketStats(LogTags logType, size_t size);
+static void clientUpdateSocketStats(const LogTags &logType, size_t size);
 
 char *skipLeadingSpace(char *aString);
 
@@ -387,21 +387,21 @@ clientIdentDone(const char *ident, void *data)
 #endif
 
 void
-clientUpdateStatCounters(LogTags logType)
+clientUpdateStatCounters(const LogTags &logType)
 {
     ++statCounter.client_http.requests;
 
-    if (logTypeIsATcpHit(logType))
+    if (logType.isTcpHit())
         ++statCounter.client_http.hits;
 
-    if (logType == LOG_TCP_HIT)
+    if (logType.oldType == LOG_TCP_HIT)
         ++statCounter.client_http.disk_hits;
-    else if (logType == LOG_TCP_MEM_HIT)
+    else if (logType.oldType == LOG_TCP_MEM_HIT)
         ++statCounter.client_http.mem_hits;
 }
 
 void
-clientUpdateStatHistCounters(LogTags logType, int svc_time)
+clientUpdateStatHistCounters(const LogTags &logType, int svc_time)
 {
     statCounter.client_http.allSvcTime.count(svc_time);
     /**
@@ -411,7 +411,7 @@ clientUpdateStatHistCounters(LogTags logType, int svc_time)
      * (we *tried* to validate it, but failed).
      */
 
-    switch (logType) {
+    switch (logType.oldType) {
 
     case LOG_TCP_REFRESH_UNMODIFIED:
         statCounter.client_http.nearHitSvcTime.count(svc_time);
@@ -516,35 +516,28 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
     assert(aLogEntry != NULL);
 
     if (Config.onoff.log_mime_hdrs) {
-        Packer p;
         MemBuf mb;
         mb.init();
-        packerToMemInit(&p, &mb);
-        request->header.packInto(&p);
+        request->header.packInto(&mb);
         //This is the request after adaptation or redirection
         aLogEntry->headers.adapted_request = xstrdup(mb.buf);
 
         // the virgin request is saved to aLogEntry->request
         if (aLogEntry->request) {
-            packerClean(&p);
             mb.reset();
-            packerToMemInit(&p, &mb);
-            aLogEntry->request->header.packInto(&p);
+            aLogEntry->request->header.packInto(&mb);
             aLogEntry->headers.request = xstrdup(mb.buf);
         }
 
 #if USE_ADAPTATION
         const Adaptation::History::Pointer ah = request->adaptLogHistory();
         if (ah != NULL) {
-            packerClean(&p);
             mb.reset();
-            packerToMemInit(&p, &mb);
-            ah->lastMeta.packInto(&p);
+            ah->lastMeta.packInto(&mb);
             aLogEntry->adapt.last_meta = xstrdup(mb.buf);
         }
 #endif
 
-        packerClean(&p);
         mb.clean();
     }
 
@@ -574,8 +567,8 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
 void
 ClientHttpRequest::logRequest()
 {
-    if (!out.size && !logType)
-        debugs(33, 5, HERE << "logging half-baked transaction: " << log_uri);
+    if (!out.size && logType.oldType == LOG_TAG_NONE)
+        debugs(33, 5, "logging half-baked transaction: " << log_uri);
 
     al->icp.opcode = ICP_INVALID;
     al->url = log_uri;
@@ -816,6 +809,7 @@ ConnStateData::swanSong()
 {
     debugs(33, 2, HERE << clientConnection);
     flags.readMore = false;
+    DeregisterRunner(this);
     clientdbEstablished(clientConnection->remote, -1);  /* decrement */
     assert(areAllContextsForThisConnection());
     freeAllContexts();
@@ -1025,16 +1019,16 @@ ClientSocketContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
         static_cast<uint64_t>(lengthToSend(bodyData.range()));
     noteSentBodyBytes(length);
 
-    mb.Printf("%" PRIX64 "\r\n", length);
+    mb.appendf("%" PRIX64 "\r\n", length);
     mb.append(bodyData.data, length);
-    mb.Printf("\r\n");
+    mb.append("\r\n", 2);
 }
 
 /** put terminating boundary for multiparts */
 static void
 clientPackTermBound(String boundary, MemBuf * mb)
 {
-    mb->Printf("\r\n--" SQUIDSTRINGPH "--\r\n", SQUIDSTRINGPRINT(boundary));
+    mb->appendf("\r\n--" SQUIDSTRINGPH "--\r\n", SQUIDSTRINGPRINT(boundary));
     debugs(33, 6, "clientPackTermBound: buf offset: " << mb->size);
 }
 
@@ -1043,14 +1037,13 @@ static void
 clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String boundary, MemBuf * mb)
 {
     HttpHeader hdr(hoReply);
-    Packer p;
     assert(rep);
     assert(spec);
 
     /* put boundary */
     debugs(33, 5, "clientPackRangeHdr: appending boundary: " << boundary);
     /* rfc2046 requires to _prepend_ boundary with <crlf>! */
-    mb->Printf("\r\n--" SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(boundary));
+    mb->appendf("\r\n--" SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(boundary));
 
     /* stuff the header with required entries and pack it */
 
@@ -1059,16 +1052,11 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
 
     httpHeaderAddContRange(&hdr, *spec, rep->content_length);
 
-    packerToMemInit(&p, mb);
-
-    hdr.packInto(&p);
-
-    packerClean(&p);
-
+    hdr.packInto(mb);
     hdr.clean();
 
     /* append <crlf> (we packed a header, not a reply) */
-    mb->Printf("\r\n");
+    mb->append("\r\n", 2);
 }
 
 /**
@@ -1275,13 +1263,13 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates
      */
-    else if (logTypeIsATcpHit(http->logType) && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
+    else if (http->logType.isTcpHit() && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
         range_err = "If-Range match failed";
     else if (!http->request->range->canonize(rep))
         range_err = "canonization failed";
     else if (http->request->range->isComplex())
         range_err = "too complex range header";
-    else if (!logTypeIsATcpHit(http->logType) && http->request->range->offsetLimitExceeded(roffLimit))
+    else if (!http->logType.isTcpHit() && http->request->range->offsetLimitExceeded(roffLimit))
         range_err = "range outside range_offset_limit";
 
     /* get rid of our range specs on error */
@@ -1610,14 +1598,14 @@ ClientSocketContext::keepaliveNextRequest()
 }
 
 void
-clientUpdateSocketStats(LogTags logType, size_t size)
+clientUpdateSocketStats(const LogTags &logType, size_t size)
 {
     if (size == 0)
         return;
 
     kb_incr(&statCounter.client_http.kbytes_out, size);
 
-    if (logTypeIsATcpHit(logType))
+    if (logType.isTcpHit())
         kb_incr(&statCounter.client_http.hit_kbytes_out, size);
 }
 
@@ -1784,10 +1772,9 @@ void
 ClientSocketContext::noteIoError(const int xerrno)
 {
     if (http) {
-        if (xerrno == ETIMEDOUT)
-            http->al->http.timedout = true;
-        else // even if xerrno is zero (which means read abort/eof)
-            http->al->http.aborted = true;
+        http->logType.err.timedout = (xerrno == ETIMEDOUT);
+        // aborted even if xerrno is zero (which means read abort/eof)
+        http->logType.err.aborted = (xerrno != ETIMEDOUT);
     }
 }
 
@@ -1893,6 +1880,32 @@ ConnStateData::abortRequestParsing(const char *const uri)
     return context;
 }
 
+void
+ConnStateData::startShutdown()
+{
+    // RegisteredRunner API callback - Squid has been shut down
+
+    // if connection is idle terminate it now,
+    // otherwise wait for grace period to end
+    if (getConcurrentRequestCount() == 0)
+        endingShutdown();
+}
+
+void
+ConnStateData::endingShutdown()
+{
+    // RegisteredRunner API callback - Squid shutdown grace period is over
+
+    // force the client connection to close immediately
+    // swanSong() in the close handler will cleanup.
+    if (Comm::IsConnOpen(clientConnection))
+        clientConnection->close();
+
+    // deregister now to ensure finalShutdown() does not kill us prematurely.
+    // fd_table purge will cleanup if close handler was not fast enough.
+    DeregisterRunner(this);
+}
+
 char *
 skipLeadingSpace(char *aString)
 {
@@ -2216,11 +2229,6 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
                      clientSocketDetach, newClient, tempBuffer);
 
     /* set url */
-    // XXX: c_str() does re-allocate but here replaces explicit malloc/free.
-    // when internalCheck() accepts SBuf removing this will be a net gain for performance.
-    SBuf tmp(hp->requestUri());
-    const char *url = tmp.c_str();
-
     debugs(33,5, "Prepare absolute URL from " <<
            (csd->transparent()?"intercept":(csd->port->flags.accelSurrogate ? "accel":"")));
     /* Rewrite the URL in transparent or accelerator mode */
@@ -2231,7 +2239,7 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
      *  - intercept mode (NAT)
      *  - intercept mode with failures
      *  - accelerator mode (reverse proxy)
-     *  - internal URL
+     *  - internal relative-URL
      *  - mixed combos of the above with internal URL
      *  - remote interception with PROXY protocol
      *  - remote reverse-proxy with PROXY protocol
@@ -2240,10 +2248,10 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
         /* intercept or transparent mode, properly working with no failures */
         prepareTransparentURL(csd, http, hp);
 
-    } else if (internalCheck(url)) {
+    } else if (internalCheck(hp->requestUri())) { // NP: only matches relative-URI
         /* internal URL mode */
         /* prepend our name & port */
-        http->uri = xstrdup(internalLocalUri(NULL, url));
+        http->uri = xstrdup(internalLocalUri(NULL, hp->requestUri()));
         // We just re-wrote the URL. Must replace the Host: header.
         //  But have not parsed there yet!! flag for local-only handling.
         http->flags.internal = true;
@@ -2258,7 +2266,7 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
          * requested url. may be rewritten later, so make extra room */
         int url_sz = hp->requestUri().length() + Config.appendDomainLen + 5;
         http->uri = (char *)xcalloc(url_sz, 1);
-        strcpy(http->uri, url);
+        xstrncpy(http->uri, hp->requestUri().rawContent(), hp->requestUri().length()+1);
     }
 
     result->flags.parsed_ok = 1;
@@ -2401,9 +2409,9 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
     // when we can extract the intended name from the bumped HTTP request.
     if (X509 *srvCert = sslServerBump->serverCert.get()) {
         HttpRequest *request = http->request;
-        if (!Ssl::checkX509ServerValidity(srvCert, request->GetHost())) {
+        if (!Ssl::checkX509ServerValidity(srvCert, request->url.host())) {
             debugs(33, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " <<
-                   "does not match domainname " << request->GetHost());
+                   "does not match domainname " << request->url.host());
 
             bool allowDomainMismatch = false;
             if (Config.ssl_client.cert_error) {
@@ -2423,7 +2431,7 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
 
                 // Fill the server IP and hostname for error page generation.
                 HttpRequest::Pointer const & peekerRequest = sslServerBump->request;
-                request->hier.note(peekerRequest->hier.tcpServer, request->GetHost());
+                request->hier.note(peekerRequest->hier.tcpServer, request->url.host());
 
                 // Create an error object and fill it
                 ErrorState *err = new ErrorState(ERR_SECURE_CONNECT_FAIL, Http::scServiceUnavailable, request);
@@ -2576,21 +2584,18 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
             request->flags.spoofClientIp = false;
     }
 
-    if (internalCheck(request->urlpath.termedBuf())) {
-        if (internalHostnameIs(request->GetHost()) && request->port == getMyPort()) {
-            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
-                   ':' << request->port);
+    if (internalCheck(request->url.path())) {
+        if (internalHostnameIs(request->url.host()) && request->url.port() == getMyPort()) {
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->url.authority(true));
             http->flags.internal = true;
-        } else if (Config.onoff.global_internal_static && internalStaticCheck(request->urlpath.termedBuf())) {
-            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
-                   ':' << request->port << " (global_internal_static on)");
+        } else if (Config.onoff.global_internal_static && internalStaticCheck(request->url.path())) {
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->url.authority(true) << " (global_internal_static on)");
             request->url.setScheme(AnyP::PROTO_HTTP);
-            request->SetHost(internalHostname());
-            request->port = getMyPort();
+            request->url.host(internalHostname());
+            request->url.port(getMyPort());
             http->flags.internal = true;
         } else
-            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
-                   ':' << request->port << " (not this proxy)");
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->url.authority(true) << " (not this proxy)");
     }
 
     request->flags.internal = http->flags.internal;
@@ -3218,25 +3223,23 @@ ConnStateData::handleRequestBodyData()
 {
     assert(bodyPipe != NULL);
 
-    size_t putSize = 0;
-
     if (in.bodyParser) { // chunked encoding
-        if (const err_type error = handleChunkedRequestBody(putSize)) {
+        if (const err_type error = handleChunkedRequestBody()) {
             abortChunkedRequestBody(error);
             return false;
         }
     } else { // identity encoding
         debugs(33,5, HERE << "handling plain request body for " << clientConnection);
-        putSize = bodyPipe->putMoreData(in.buf.c_str(), in.buf.length());
+        const size_t putSize = bodyPipe->putMoreData(in.buf.c_str(), in.buf.length());
+        if (putSize > 0)
+            consumeInput(putSize);
+
         if (!bodyPipe->mayNeedMoreData()) {
             // BodyPipe will clear us automagically when we produced everything
             bodyPipe = NULL;
         }
     }
 
-    if (putSize > 0)
-        consumeInput(putSize);
-
     if (!bodyPipe) {
         debugs(33,5, HERE << "produced entire request body for " << clientConnection);
 
@@ -3255,7 +3258,7 @@ ConnStateData::handleRequestBodyData()
 
 /// parses available chunked encoded body bytes, checks size, returns errors
 err_type
-ConnStateData::handleChunkedRequestBody(size_t &putSize)
+ConnStateData::handleChunkedRequestBody()
 {
     debugs(33, 7, "chunked from " << clientConnection << ": " << in.buf.length());
 
@@ -3264,16 +3267,11 @@ ConnStateData::handleChunkedRequestBody(size_t &putSize)
         if (in.buf.isEmpty()) // nothing to do
             return ERR_NONE;
 
-        MemBuf raw; // ChunkedCodingParser only works with MemBufs
-        // add one because MemBuf will assert if it cannot 0-terminate
-        raw.init(in.buf.length(), in.buf.length()+1);
-        raw.append(in.buf.c_str(), in.buf.length());
-
-        const mb_size_t wasContentSize = raw.contentSize();
         BodyPipeCheckout bpc(*bodyPipe);
-        const bool parsed = in.bodyParser->parse(&raw, &bpc.buf);
+        in.bodyParser->setPayloadBuffer(&bpc.buf);
+        const bool parsed = in.bodyParser->parse(in.buf);
+        in.buf = in.bodyParser->remaining(); // sync buffers
         bpc.checkIn();
-        putSize = wasContentSize - raw.contentSize();
 
         // dechunk then check: the size limit applies to _dechunked_ content
         if (clientIsRequestBodyTooLargeForPolicy(bodyPipe->producedSize()))
@@ -3384,7 +3382,7 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
     ClientHttpRequest *http = static_cast<ClientHttpRequest *>(io.data);
     debugs(33, DBG_IMPORTANT, "WARNING: Closing client connection due to lifetime timeout");
     debugs(33, DBG_IMPORTANT, "\t" << http->uri);
-    http->al->http.timedout = true;
+    http->logType.err.timedout = true;
     if (Comm::IsConnOpen(io.conn))
         io.conn->close();
 }
@@ -3421,6 +3419,10 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
     transferProtocol = port->transport; // default to the *_port protocol= setting. may change later.
     log_addr = xact->tcpClient->remote;
     log_addr.applyMask(Config.Addrs.client_netmask);
+
+    // register to receive notice of Squid signal events
+    // which may affect long persisting client connections
+    RegisterRunner(this);
 }
 
 void
@@ -3548,16 +3550,16 @@ httpAccept(const CommAcceptCbParams &params)
 #if USE_OPENSSL
 
 /** Create SSL connection structure and update fd_table */
-static SSL *
-httpsCreate(const Comm::ConnectionPointer &conn, SSL_CTX *sslContext)
+static Security::SessionPointer
+httpsCreate(const Comm::ConnectionPointer &conn, Security::ContextPointer sslContext)
 {
-    if (SSL *ssl = Ssl::CreateServer(sslContext, conn->fd, "client https start")) {
+    if (auto ssl = Ssl::CreateServer(sslContext, conn->fd, "client https start")) {
         debugs(33, 5, "will negotate SSL on " << conn);
         return ssl;
     }
 
     conn->close();
-    return NULL;
+    return nullptr;
 }
 
 /**
@@ -3570,13 +3572,13 @@ static int
 Squid_SSL_accept(ConnStateData *conn, PF *callback)
 {
     int fd = conn->clientConnection->fd;
-    SSL *ssl = fd_table[fd].ssl;
+    auto ssl = fd_table[fd].ssl;
     int ret;
 
     errno = 0;
     if ((ret = SSL_accept(ssl)) <= 0) {
-        int xerrno = errno;
-        int ssl_error = SSL_get_error(ssl, ret);
+        const int xerrno = errno;
+        const int ssl_error = SSL_get_error(ssl, ret);
 
         switch (ssl_error) {
 
@@ -3619,12 +3621,12 @@ clientNegotiateSSL(int fd, void *data)
 {
     ConnStateData *conn = (ConnStateData *)data;
     X509 *client_cert;
-    SSL *ssl = fd_table[fd].ssl;
+    auto ssl = fd_table[fd].ssl;
 
     int ret;
     if ((ret = Squid_SSL_accept(conn, clientNegotiateSSL)) <= 0) {
         if (ret < 0) // An error
-            comm_close(fd);
+            conn->clientConnection->close();
         return;
     }
 
@@ -3697,13 +3699,13 @@ clientNegotiateSSL(int fd, void *data)
 }
 
 /**
- * If SSL_CTX is given, starts reading the SSL handshake.
- * Otherwise, calls switchToHttps to generate a dynamic SSL_CTX.
+ * If Security::ContextPointer is given, starts reading the TLS handshake.
+ * Otherwise, calls switchToHttps to generate a dynamic Security::ContextPointer.
  */
 static void
-httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext)
+httpsEstablish(ConnStateData *connState, Security::ContextPointer sslContext)
 {
-    SSL *ssl = NULL;
+    Security::SessionPointer ssl = nullptr;
     assert(connState);
     const Comm::ConnectionPointer &details = connState->clientConnection;
 
@@ -3804,8 +3806,8 @@ ConnStateData::postHttpsAccept()
         HttpRequest *request = new HttpRequest();
         static char ip[MAX_IPSTRLEN];
         assert(clientConnection->flags & (COMM_TRANSPARENT | COMM_INTERCEPTION));
-        request->SetHost(clientConnection->local.toStr(ip, sizeof(ip)));
-        request->port = clientConnection->local.port();
+        request->url.host(clientConnection->local.toStr(ip, sizeof(ip)));
+        request->url.port(clientConnection->local.port());
         request->myportname = port->name;
 
         ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(Config.accessList.ssl_bump, request, NULL);
@@ -3814,7 +3816,7 @@ ConnStateData::postHttpsAccept()
         acl_checklist->nonBlockingCheck(httpsSslBumpAccessCheckDone, this);
         return;
     } else {
-        SSL_CTX *sslContext = port->staticSslContext.get();
+        Security::ContextPointer sslContext = port->staticSslContext.get();
         httpsEstablish(this, sslContext);
     }
 }
@@ -3829,6 +3831,11 @@ ConnStateData::sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply)
 void
 ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply)
 {
+    if (!isOpen()) {
+        debugs(33, 3, "Connection gone while waiting for ssl_crtd helper reply; helper reply:" << reply);
+        return;
+    }
+
     if (reply.result == Helper::BrokenHelper) {
         debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply);
     } else if (!reply.other().hasContent()) {
@@ -3844,12 +3851,12 @@ ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply)
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " was successfully recieved from ssl_crtd");
                 if (sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare)) {
                     doPeekAndSpliceStep();
-                    SSL *ssl = fd_table[clientConnection->fd].ssl;
+                    auto ssl = fd_table[clientConnection->fd].ssl;
                     bool ret = Ssl::configureSSLUsingPkeyAndCertFromMemory(ssl, reply_message.getBody().c_str(), *port);
                     if (!ret)
                         debugs(33, 5, "Failed to set certificates to ssl object for PeekAndSplice mode");
                 } else {
-                    SSL_CTX *ctx = Ssl::generateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str(), *port);
+                    auto ctx = Ssl::generateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str(), *port);
                     getSslContextDone(ctx, true);
                 }
                 return;
@@ -3964,7 +3971,7 @@ ConnStateData::getSslContextStart()
         if (!(sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare))) {
             debugs(33, 5, "Finding SSL certificate for " << sslBumpCertKey << " in cache");
             Ssl::LocalContextStorage * ssl_ctx_cache = Ssl::TheGlobalContextStorage.getLocalStorage(port->s);
-            SSL_CTX * dynCtx = NULL;
+            Security::ContextPointer dynCtx = nullptr;
             Ssl::SSL_CTX_Pointer *cachedCtx = ssl_ctx_cache ? ssl_ctx_cache->get(sslBumpCertKey.termedBuf()) : NULL;
             if (cachedCtx && (dynCtx = cachedCtx->get())) {
                 debugs(33, 5, "SSL certificate for " << sslBumpCertKey << " found in cache");
@@ -4003,11 +4010,11 @@ ConnStateData::getSslContextStart()
         debugs(33, 5, HERE << "Generating SSL certificate for " << certProperties.commonName);
         if (sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare)) {
             doPeekAndSpliceStep();
-            SSL *ssl = fd_table[clientConnection->fd].ssl;
+            auto ssl = fd_table[clientConnection->fd].ssl;
             if (!Ssl::configureSSL(ssl, certProperties, *port))
                 debugs(33, 5, "Failed to set certificates to ssl object for PeekAndSplice mode");
         } else {
-            SSL_CTX *dynCtx = Ssl::generateSslContext(certProperties, *port);
+            auto dynCtx = Ssl::generateSslContext(certProperties, *port);
             getSslContextDone(dynCtx, true);
         }
         return;
@@ -4016,7 +4023,7 @@ ConnStateData::getSslContextStart()
 }
 
 void
-ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew)
+ConnStateData::getSslContextDone(Security::ContextPointer sslContext, bool isNew)
 {
     // Try to add generated ssl context to storage.
     if (port->generateHostCertificates && isNew) {
@@ -4081,8 +4088,8 @@ ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode)
 {
     assert(!switchedToHttps_);
 
-    sslConnectHostOrIp = request->GetHost();
-    resetSslCommonName(request->GetHost());
+    sslConnectHostOrIp = request->url.host();
+    resetSslCommonName(request->url.host());
 
     // We are going to read new request
     flags.readMore = true;
@@ -4135,7 +4142,7 @@ static void
 clientPeekAndSpliceSSL(int fd, void *data)
 {
     ConnStateData *conn = (ConnStateData *)data;
-    SSL *ssl = fd_table[fd].ssl;
+    auto ssl = fd_table[fd].ssl;
 
     debugs(83, 5, "Start peek and splice on FD " << fd);
 
@@ -4176,7 +4183,7 @@ clientPeekAndSpliceSSL(int fd, void *data)
 void ConnStateData::startPeekAndSplice()
 {
     // will call httpsPeeked() with certificate and connection, eventually
-    SSL_CTX *unConfiguredCTX = Ssl::createSSLContext(port->signingCert, port->signPkey, *port);
+    auto unConfiguredCTX = Ssl::createSSLContext(port->signingCert, port->signPkey, *port);
     fd_table[clientConnection->fd].dynamicSslContext = unConfiguredCTX;
 
     if (!httpsCreate(clientConnection, unConfiguredCTX))
@@ -4197,7 +4204,7 @@ void ConnStateData::startPeekAndSplice()
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, clientPeekAndSpliceSSL, this, 0);
     switchedToHttps_ = true;
 
-    SSL *ssl = fd_table[clientConnection->fd].ssl;
+    auto ssl = fd_table[clientConnection->fd].ssl;
     BIO *b = SSL_get_rbio(ssl);
     Ssl::ClientBio *bio = static_cast<Ssl::ClientBio *>(b->ptr);
     bio->hold(true);
@@ -4228,7 +4235,7 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
     connState->sslBumpMode = bumpAction;
 
     if (bumpAction == Ssl::bumpTerminate) {
-        comm_close(connState->clientConnection->fd);
+        connState->clientConnection->close();
     } else if (bumpAction != Ssl::bumpSplice) {
         connState->startPeekAndSpliceDone();
     } else
@@ -4239,7 +4246,7 @@ void
 ConnStateData::splice()
 {
     //Normally we can splice here, because we just got client hello message
-    SSL *ssl = fd_table[clientConnection->fd].ssl;
+    auto ssl = fd_table[clientConnection->fd].ssl;
     BIO *b = SSL_get_rbio(ssl);
     Ssl::ClientBio *bio = static_cast<Ssl::ClientBio *>(b->ptr);
     MemBuf const &rbuf = bio->rBufData();
@@ -4299,7 +4306,7 @@ ConnStateData::startPeekAndSpliceDone()
 void
 ConnStateData::doPeekAndSpliceStep()
 {
-    SSL *ssl = fd_table[clientConnection->fd].ssl;
+    auto ssl = fd_table[clientConnection->fd].ssl;
     BIO *b = SSL_get_rbio(ssl);
     assert(b);
     Ssl::ClientBio *bio = static_cast<Ssl::ClientBio *>(b->ptr);
@@ -4722,7 +4729,7 @@ ConnStateData::startDechunkingRequest()
     Must(bodyPipe != NULL);
     debugs(33, 5, HERE << "start dechunking" << bodyPipe->status());
     assert(!in.bodyParser);
-    in.bodyParser = new ChunkedCodingParser;
+    in.bodyParser = new Http1::TeChunkedParser;
 }
 
 /// put parsed content into input buffer and clean up
@@ -4785,6 +4792,7 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
     assert(pinning.serverConnection == io.conn);
     pinning.closeHandler = NULL; // Comm unregisters handlers before calling
     const bool sawZeroReply = pinning.zeroReply; // reset when unpinning
+    pinning.serverConnection->noteClosure();
     unpinConnection(false);
 
     if (sawZeroReply && clientConnection != NULL) {
@@ -4819,8 +4827,8 @@ ConnStateData::pinNewConnection(const Comm::ConnectionPointer &pinServer, HttpRe
     // when pinning an SSL bumped connection, the request may be NULL
     const char *pinnedHost = "[unknown]";
     if (request) {
-        pinning.host = xstrdup(request->GetHost());
-        pinning.port = request->port;
+        pinning.host = xstrdup(request->url.host());
+        pinning.port = request->url.port();
         pinnedHost = pinning.host;
     } else {
         pinning.port = pinServer->remote.port();
@@ -4904,9 +4912,9 @@ ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *a
     bool valid = true;
     if (!Comm::IsConnOpen(pinning.serverConnection))
         valid = false;
-    else if (pinning.auth && pinning.host && request && strcasecmp(pinning.host, request->GetHost()) != 0)
+    else if (pinning.auth && pinning.host && request && strcasecmp(pinning.host, request->url.host()) != 0)
         valid = false;
-    else if (request && pinning.port != request->port)
+    else if (request && pinning.port != request->url.port())
         valid = false;
     else if (pinning.peer && !cbdataReferenceValid(pinning.peer))
         valid = false;
@@ -11,6 +11,7 @@
 #ifndef SQUID_CLIENTSIDE_H
 #define SQUID_CLIENTSIDE_H
 
+#include "base/RunnersRegistry.h"
 #include "clientStreamForward.h"
 #include "comm.h"
 #include "helper/forward.h"
@@ -28,7 +29,6 @@
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
-class ChunkedCodingParser;
 namespace AnyP
 {
 class PortCfg;
@@ -168,7 +168,7 @@ class ServerBump;
  *
  * If the above can be confirmed accurate we can call this object PipelineManager or similar
  */
-class ConnStateData : public BodyProducer, public HttpControlMsgSink
+class ConnStateData : public BodyProducer, public HttpControlMsgSink, public RegisteredRunner
 {
 
 public:
@@ -208,7 +208,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         ~In();
         bool maybeMakeSpaceAvailable();
 
-        ChunkedCodingParser *bodyParser; ///< parses chunked request body
+        Http1::TeChunkedParser *bodyParser; ///< parses chunked request body
         SBuf buf;
     } in;
 
@@ -365,7 +365,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
      *
      * \param[in] isNew if generated certificate is new, so we need to add this certificate to storage.
      */
-    void getSslContextDone(SSL_CTX * sslContext, bool isNew = false);
+    void getSslContextDone(Security::ContextPointer sslContext, bool isNew = false);
     /// Callback function. It is called when squid receive message from ssl_crtd.
     static void sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply);
     /// Proccess response from ssl_crtd.
@@ -419,11 +419,16 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /// client data which may need to forward as-is to server after an
     /// on_unsupported_protocol tunnel decision.
     SBuf preservedClientData;
+
+    /* Registered Runner API */
+    virtual void startShutdown();
+    virtual void endingShutdown();
+
 protected:
     void startDechunkingRequest();
     void finishDechunkingRequest(bool withSuccess);
     void abortChunkedRequestBody(const err_type error);
-    err_type handleChunkedRequestBody(size_t &putSize);
+    err_type handleChunkedRequestBody();
 
     void startPinnedConnectionMonitoring();
     void clientPinnedConnectionRead(const CommIoCbParams &io);
@@ -77,7 +77,7 @@ clientReplyContext::clientReplyContext(ClientHttpRequest *clientContext) :
     purgeStatus(Http::scNone),
     lookingforstore(0),
     http(cbdataReference(clientContext)),
-    headers_sz(-1),
+    headers_sz(0),
     sc(NULL),
     old_reqsize(0),
     reqsize(0),
@@ -510,9 +510,9 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
     /*
      * Got the headers, now grok them
      */
-    assert(http->logType == LOG_TCP_HIT);
+    assert(http->logType.oldType == LOG_TCP_HIT);
 
-    if (strcmp(e->mem_obj->storeId(), http->request->storeId()) != 0) {
+    if (http->request->storeId().cmp(e->mem_obj->storeId()) != 0) {
         debugs(33, DBG_IMPORTANT, "clientProcessHit: URL mismatch, '" << e->mem_obj->storeId() << "' != '" << http->request->storeId() << "'");
         http->logType = LOG_TCP_MISS; // we lack a more precise LOG_*_MISS code
         processMiss();
@@ -655,7 +655,7 @@ clientReplyContext::processMiss()
     if (http->storeEntry()) {
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             debugs(88, DBG_CRITICAL, "clientProcessMiss: miss on a special object (" << url << ").");
-            debugs(88, DBG_CRITICAL, "\tlog_type = " << LogTags_str[http->logType]);
+            debugs(88, DBG_CRITICAL, "\tlog_type = " << http->logType.c_str());
             http->storeEntry()->dump(1);
         }
 
@@ -804,7 +804,7 @@ clientReplyContext::blockedHit() const
         return false; // internal content "hits" cannot be blocked
 
     if (const HttpReply *rep = http->storeEntry()->getReply()) {
-        std::auto_ptr<ACLFilledChecklist> chl(clientAclChecklistCreate(Config.accessList.sendHit, http));
+        std::unique_ptr<ACLFilledChecklist> chl(clientAclChecklistCreate(Config.accessList.sendHit, http));
         chl->reply = const_cast<HttpReply*>(rep); // ACLChecklist API bug
         HTTPMSGLOCK(chl->reply);
         return chl->fastCheck() != ACCESS_ALLOWED; // when in doubt, block
@@ -867,8 +867,9 @@ purgeEntriesByUrl(HttpRequest * req, const char *url)
 void
 clientReplyContext::purgeAllCached()
 {
-    const char *url = urlCanonical(http->request);
-    purgeEntriesByUrl(http->request, url);
+    // XXX: performance regression, c_str() reallocates
+    SBuf url(http->request->effectiveRequestUri());
+    purgeEntriesByUrl(http->request, url.c_str());
 }
 
 void
@@ -956,7 +957,7 @@ clientReplyContext::purgeRequest()
     }
 
     /* Release both IP cache */
-    ipcacheInvalidate(http->request->GetHost());
+    ipcacheInvalidate(http->request->url.host());
 
     if (!http->flags.purging)
         purgeRequestFindObjectToPurge();
@@ -997,7 +998,7 @@ void
 clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
 {
     if (newEntry && !newEntry->isNull()) {
-        debugs(88, 4, "clientPurgeRequest: HEAD '" << newEntry->url() << "'" );
+        debugs(88, 4, "HEAD " << newEntry->url());
 #if USE_HTCP
         neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_PURGE);
 #endif
@@ -1009,21 +1010,23 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
 
     if (http->request->vary_headers
             && !strstr(http->request->vary_headers, "=")) {
-        StoreEntry *entry = storeGetPublic(urlCanonical(http->request), Http::METHOD_GET);
+        // XXX: performance regression, c_str() reallocates
+        SBuf tmp(http->request->effectiveRequestUri());
+        StoreEntry *entry = storeGetPublic(tmp.c_str(), Http::METHOD_GET);
 
         if (entry) {
-            debugs(88, 4, "clientPurgeRequest: Vary GET '" << entry->url() << "'" );
+            debugs(88, 4, "Vary GET " << entry->url());
 #if USE_HTCP
             neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(Http::METHOD_GET), HTCP_CLR_PURGE);
 #endif
             entry->release();
             purgeStatus = Http::scOkay;
         }
 
-        entry = storeGetPublic(urlCanonical(http->request), Http::METHOD_HEAD);
+        entry = storeGetPublic(tmp.c_str(), Http::METHOD_HEAD);
 
         if (entry) {
-            debugs(88, 4, "clientPurgeRequest: Vary HEAD '" << entry->url() << "'" );
+            debugs(88, 4, "Vary HEAD " << entry->url());
 #if USE_HTCP
             neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_PURGE);
 #endif
@@ -1306,7 +1309,7 @@ void
 clientReplyContext::buildReplyHeader()
 {
     HttpHeader *hdr = &reply->header;
-    int is_hit = logTypeIsATcpHit(http->logType);
+    const bool is_hit = http->logType.isTcpHit();
     HttpRequest *request = http->request;
 #if DONT_FILTER_THESE
     /* but you might want to if you run Squid as an HTTP accelerator */
@@ -1407,14 +1410,14 @@ clientReplyContext::buildReplyHeader()
     }
 
     // add Warnings required by RFC 2616 if serving a stale hit
-    if (http->request->flags.staleIfHit && logTypeIsATcpHit(http->logType)) {
+    if (http->request->flags.staleIfHit && http->logType.isTcpHit()) {
         hdr->putWarning(110, "Response is stale");
         if (http->request->flags.needValidation)
             hdr->putWarning(111, "Revalidation failed");
     }
 
     /* Filter unproxyable authentication types */
-    if (http->logType != LOG_TCP_DENIED &&
+    if (http->logType.oldType != LOG_TCP_DENIED &&
             hdr->has(HDR_WWW_AUTHENTICATE)) {
         HttpHeaderPos pos = HttpHeaderInitPos;
         HttpHeaderEntry *e;
@@ -1458,7 +1461,7 @@ clientReplyContext::buildReplyHeader()
 
 #if USE_AUTH
     /* Handle authentication headers */
-    if (http->logType == LOG_TCP_DENIED &&
+    if (http->logType.oldType == LOG_TCP_DENIED &&
             ( reply->sline.status() == Http::scProxyAuthenticationRequired ||
               reply->sline.status() == Http::scUnauthorized)
        ) {
@@ -1644,7 +1647,7 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
       * 'invalidate' the cached IP entries for this request ???
       */
     if (r->flags.noCache || r->flags.noCacheHack())
-        ipcacheInvalidateNegative(r->GetHost());
+        ipcacheInvalidateNegative(r->url.host());
 
 #if USE_CACHE_DIGESTS
     lookup_type = http->storeEntry() ? "HIT" : "MISS";
@@ -1795,7 +1798,7 @@ clientReplyContext::doGetMoreData()
         sc->setDelayId(DelayId::DelayClient(http));
 #endif
 
-        assert(http->logType == LOG_TCP_HIT);
+        assert(http->logType.oldType == LOG_TCP_HIT);
         reqofs = 0;
         /* guarantee nothing has been sent yet! */
         assert(http->out.size == 0);
@@ -1972,8 +1975,8 @@ clientReplyContext::processReplyAccess ()
     assert(reply);
 
     /** Don't block our own responses or HTTP status messages */
-    if (http->logType == LOG_TCP_DENIED ||
-            http->logType == LOG_TCP_DENIED_REPLY ||
+    if (http->logType.oldType == LOG_TCP_DENIED ||
+            http->logType.oldType == LOG_TCP_DENIED_REPLY ||
             alwaysAllowResponse(reply->sline.status())) {
         headers_sz = reply->hdr_sz;
         processReplyAccessResult(ACCESS_ALLOWED);
@@ -2141,7 +2144,7 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
         memcpy(buf, result.data, result.length);
     }
 
-    if (reqofs==0 && !logTypeIsATcpHit(http->logType) && Comm::IsConnOpen(conn->clientConnection)) {
+    if (reqofs==0 && !http->logType.isTcpHit() && Comm::IsConnOpen(conn->clientConnection)) {
         if (Ip::Qos::TheConfig.isHitTosActive()) {
             Ip::Qos::doTosLocalMiss(conn->clientConnection, http->request->hier.code);
         }
@@ -174,7 +174,7 @@ ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
 
 #if USE_OPENSSL
     if (aConn->clientConnection != NULL && aConn->clientConnection->isOpen()) {
-        if (SSL *ssl = fd_table[aConn->clientConnection->fd].ssl)
+        if (auto ssl = fd_table[aConn->clientConnection->fd].ssl)
             al->cache.sslClientCert.reset(SSL_get_peer_certificate(ssl));
     }
 #endif
@@ -274,7 +274,6 @@ ClientHttpRequest::~ClientHttpRequest()
     /* the ICP check here was erroneous
      * - StoreEntry::releaseRequest was always called if entry was valid
      */
-    assert(logType < LOG_TYPE_MAX);
 
     logRequest();
 
@@ -560,7 +559,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
     // NP: we do not yet handle CONNECT tunnels well, so ignore for them
     if (!Config.onoff.hostStrictVerify && http->request->method != Http::METHOD_CONNECT) {
         debugs(85, 3, "SECURITY ALERT: Host header forgery detected on " << http->getConn()->clientConnection <<
-               " (" << A << " does not match " << B << ") on URL: " << urlCanonical(http->request));
+               " (" << A << " does not match " << B << ") on URL: " << http->request->effectiveRequestUri());
 
         // NP: it is tempting to use 'flags.noCache' but that is all about READing cache data.
         // The problems here are about WRITE for new cache content, which means flags.cachable
@@ -575,7 +574,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: Host header forgery detected on " <<
            http->getConn()->clientConnection << " (" << A << " does not match " << B << ")");
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(HDR_USER_AGENT));
-    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: on URL: " << urlCanonical(http->request));
+    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: on URL: " << http->request->effectiveRequestUri());
 
     // IP address validation for Host: failed. reject the connection.
     clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
@@ -648,11 +647,11 @@ ClientRequestContext::hostHeaderVerify()
         }
     }
 
-    debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
+    debugs(85, 3, "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
     if (http->request->flags.intercepted || http->request->flags.interceptTproxy) {
         // verify the Host: port (if any) matches the apparent destination
         if (portStr && port != http->getConn()->clientConnection->local.port()) {
-            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.port() <<
+            debugs(85, 3, "FAIL on validate port " << http->getConn()->clientConnection->local.port() <<
                    " matches Host: port " << port << " (" << portStr << ")");
             hostHeaderVerifyFailed("intercepted port", portStr);
         } else {
@@ -662,28 +661,28 @@ ClientRequestContext::hostHeaderVerify()
             ipcache_nbgethostbyname(host, hostHeaderIpVerifyWrapper, this);
         }
     } else if (!Config.onoff.hostStrictVerify) {
-        debugs(85, 3, HERE << "validate skipped.");
+        debugs(85, 3, "validate skipped.");
         http->doCallouts();
-    } else if (strlen(host) != strlen(http->request->GetHost())) {
+    } else if (strlen(host) != strlen(http->request->url.host())) {
         // Verify forward-proxy requested URL domain matches the Host: header
-        debugs(85, 3, HERE << "FAIL on validate URL domain length " << http->request->GetHost() << " matches Host: " << host);
-        hostHeaderVerifyFailed(host, http->request->GetHost());
-    } else if (matchDomainName(host, http->request->GetHost()) != 0) {
+        debugs(85, 3, "FAIL on validate URL domain length " << http->request->url.host() << " matches Host: " << host);
+        hostHeaderVerifyFailed(host, http->request->url.host());
+    } else if (matchDomainName(host, http->request->url.host()) != 0) {
         // Verify forward-proxy requested URL domain matches the Host: header
-        debugs(85, 3, HERE << "FAIL on validate URL domain " << http->request->GetHost() << " matches Host: " << host);
-        hostHeaderVerifyFailed(host, http->request->GetHost());
-    } else if (portStr && port != http->request->port) {
+        debugs(85, 3, "FAIL on validate URL domain " << http->request->url.host() << " matches Host: " << host);
+        hostHeaderVerifyFailed(host, http->request->url.host());
+    } else if (portStr && port != http->request->url.port()) {
         // Verify forward-proxy requested URL domain matches the Host: header
-        debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: port " << portStr);
+        debugs(85, 3, "FAIL on validate URL port " << http->request->url.port() << " matches Host: port " << portStr);
         hostHeaderVerifyFailed("URL port", portStr);
-    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->url.getScheme())) {
+    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->url.port() != http->request->url.getScheme().defaultPort()) {
         // Verify forward-proxy requested URL domain matches the Host: header
         // Special case: we don't have a default-port to check for CONNECT. Assume URL is correct.
-        debugs(85, 3, "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->url.getScheme()));
+        debugs(85, 3, "FAIL on validate URL port " << http->request->url.port() << " matches Host: default port " << http->request->url.getScheme().defaultPort());
         hostHeaderVerifyFailed("URL port", "default port");
     } else {
         // Okay no problem.
-        debugs(85, 3, HERE << "validate passed.");
+        debugs(85, 3, "validate passed.");
         http->request->flags.hostVerified = true;
         http->doCallouts();
     }
@@ -835,9 +834,8 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 
     /* ACCESS_ALLOWED continues here ... */
     safe_free(http->uri);
-
-    http->uri = xstrdup(urlCanonical(http->request));
-
+    const SBuf tmp(http->request->effectiveRequestUri());
+    http->uri = xstrndup(tmp.rawContent(), tmp.length()+1);
     http->doCallouts();
 }
 
@@ -1301,7 +1299,7 @@ ClientRequestContext::clientRedirectDone(const Helper::Reply &reply)
                 // XXX: the clone() should be done only AFTER we know the new URL is valid.
                 HttpRequest *new_request = old_request->clone();
                 if (urlParse(old_request->method, const_cast<char*>(urlNote), new_request)) {
-                    debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
+                    debugs(61, 2, "URL-rewriter diverts URL from " << old_request->effectiveRequestUri() << " to " << new_request->effectiveRequestUri());
 
                     // update the new request to flag the re-writing was done on it
                     new_request->flags.redirected = true;
@@ -1315,7 +1313,8 @@ ClientRequestContext::clientRedirectDone(const Helper::Reply &reply)
 
                     // update the current working ClientHttpRequest fields
                     safe_free(http->uri);
-                    http->uri = xstrdup(urlCanonical(new_request));
+                    const SBuf tmp(new_request->effectiveRequestUri());
+                    http->uri = xstrndup(tmp.rawContent(), tmp.length()+1);
                     HTTPMSGUNLOCK(old_request);
                     http->request = new_request;
                     HTTPMSGLOCK(http->request);
@@ -1529,7 +1528,7 @@ ClientHttpRequest::httpStart()
 {
     PROF_start(httpStart);
     logType = LOG_TAG_NONE;
-    debugs(85, 4, LogTags_str[logType] << " for '" << uri << "'");
+    debugs(85, 4, logType.c_str() << " for '" << uri << "'");
 
     /* no one should have touched this */
     assert(out.offset == 0);
@@ -1807,8 +1806,9 @@ ClientHttpRequest::doCallouts()
 #endif
 
     if (calloutContext->error) {
-        const char *storeUri = request->storeId();
-        StoreEntry *e= storeCreateEntry(storeUri, storeUri, request->flags, request->method);
+        // XXX: prformance regression. c_str() reallocates
+        SBuf storeUri(request->storeId());
+        StoreEntry *e = storeCreateEntry(storeUri.c_str(), storeUri.c_str(), request->flags, request->method);
 #if USE_OPENSSL
         if (sslBumpNeeded()) {
             // We have to serve an error, so bump the client first.
@@ -1912,14 +1912,15 @@ ClientHttpRequest::handleAdaptedHeader(HttpMsg *msg)
         HTTPMSGLOCK(request);
 
         // update the new message to flag whether URL re-writing was done on it
-        if (strcmp(urlCanonical(request),uri) != 0)
+        if (request->effectiveRequestUri().cmp(uri) != 0)
             request->flags.redirected = 1;
 
         /*
          * Store the new URI for logging
          */
         xfree(uri);
-        uri = xstrdup(urlCanonical(request));
+        const SBuf tmp(request->effectiveRequestUri());
+        uri = xstrndup(tmp.rawContent(), tmp.length());
         setLogUri(this, urlCanonicalClean(request));
         assert(request->method.id());
     } else if (HttpReply *new_rep = dynamic_cast<HttpReply*>(msg)) {
@@ -493,8 +493,9 @@ Client::maybePurgeOthers()
         return;
 
     // XXX: should we use originalRequest() here?
-    const char *reqUrl = urlCanonical(request);
-    debugs(88, 5, "maybe purging due to " << request->method << ' ' << reqUrl);
+    SBuf tmp(request->effectiveRequestUri());
+    const char *reqUrl = tmp.c_str();
+    debugs(88, 5, "maybe purging due to " << request->method << ' ' << tmp);
     purgeEntriesByUrl(request, reqUrl);
     purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
     purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
@@ -509,6 +509,8 @@ Ftp::Client::handleEpsvReply(Ip::Address &remoteAddr)
             debugs(9, DBG_IMPORTANT, "WARNING: Server at " << ctrl.conn->remote << " sent unknown protocol negotiation hint: " << buf);
             return sendPassive();
         }
+        /* coverity[unreachable] */
+        /* safeguard against possible future bugs in above conditions */
         failed(ERR_FTP_FAILURE, 0);
         return false;
     }
@@ -587,10 +589,10 @@ Ftp::Client::sendEprt()
     /* RFC 2428 defines EPRT as IPv6 equivalent to IPv4 PORT command. */
     /* Which can be used by EITHER protocol. */
     debugs(9, 3, "Listening for FTP data connection on port" << comm_local_port(data.conn->fd) << " or port?" << data.conn->local.port());
-    mb.Printf("EPRT |%d|%s|%d|%s",
-              ( data.conn->local.isIPv6() ? 2 : 1 ),
-              data.conn->local.toStr(buf,MAX_IPSTRLEN),
-              comm_local_port(data.conn->fd), Ftp::crlf );
+    mb.appendf("EPRT |%d|%s|%d|%s",
+               ( data.conn->local.isIPv6() ? 2 : 1 ),
+               data.conn->local.toStr(buf,MAX_IPSTRLEN),
+               comm_local_port(data.conn->fd), Ftp::crlf );
 
     state = SENT_EPRT;
     writeCommand(mb.content());
@@ -647,7 +649,7 @@ Ftp::Client::sendPassive()
     case SENT_EPSV_ALL: /* EPSV ALL resulted in a bad response. Try ther EPSV methods. */
         if (ctrl.conn->local.isIPv6()) {
             debugs(9, 5, "FTP Channel is IPv6 (" << ctrl.conn->remote << ") attempting EPSV 2 after EPSV ALL has failed.");
-            mb.Printf("EPSV 2%s", Ftp::crlf);
+            mb.appendf("EPSV 2%s", Ftp::crlf);
             state = SENT_EPSV_2;
             break;
         }
@@ -656,7 +658,7 @@ Ftp::Client::sendPassive()
     case SENT_EPSV_2: /* EPSV IPv6 failed. Try EPSV IPv4 */
         if (ctrl.conn->local.isIPv4()) {
             debugs(9, 5, "FTP Channel is IPv4 (" << ctrl.conn->remote << ") attempting EPSV 1 after EPSV ALL has failed.");
-            mb.Printf("EPSV 1%s", Ftp::crlf);
+            mb.appendf("EPSV 1%s", Ftp::crlf);
             state = SENT_EPSV_1;
             break;
         } else if (Config.Ftp.epsv_all) {
@@ -668,7 +670,7 @@ Ftp::Client::sendPassive()
 
     case SENT_EPSV_1: /* EPSV options exhausted. Try PASV now. */
         debugs(9, 5, "FTP Channel (" << ctrl.conn->remote << ") rejects EPSV connection attempts. Trying PASV instead.");
-        mb.Printf("PASV%s", Ftp::crlf);
+        mb.appendf("PASV%s", Ftp::crlf);
         state = SENT_PASV;
         break;
 
@@ -680,21 +682,21 @@ Ftp::Client::sendPassive()
         }
         if (!doEpsv) {
             debugs(9, 5, "EPSV support manually disabled. Sending PASV for FTP Channel (" << ctrl.conn->remote <<")");
-            mb.Printf("PASV%s", Ftp::crlf);
+            mb.appendf("PASV%s", Ftp::crlf);
             state = SENT_PASV;
         } else if (Config.Ftp.epsv_all) {
             debugs(9, 5, "EPSV ALL manually enabled. Attempting with FTP Channel (" << ctrl.conn->remote <<")");
-            mb.Printf("EPSV ALL%s", Ftp::crlf);
+            mb.appendf("EPSV ALL%s", Ftp::crlf);
             state = SENT_EPSV_ALL;
         } else {
             if (ctrl.conn->local.isIPv6()) {
                 debugs(9, 5, "FTP Channel (" << ctrl.conn->remote << "). Sending default EPSV 2");
-                mb.Printf("EPSV 2%s", Ftp::crlf);
+                mb.appendf("EPSV 2%s", Ftp::crlf);
                 state = SENT_EPSV_2;
             }
             if (ctrl.conn->local.isIPv4()) {
                 debugs(9, 5, "Channel (" << ctrl.conn->remote <<"). Sending default EPSV 1");
-                mb.Printf("EPSV 1%s", Ftp::crlf);
+                mb.appendf("EPSV 1%s", Ftp::crlf);
                 state = SENT_EPSV_1;
             }
         }
@@ -771,7 +771,7 @@ Ftp::Gateway::htmlifyListEntry(const char *line)
     if (strlen(line) > 1024) {
         html = new MemBuf();
         html->init();
-        html->Printf("<tr><td colspan=\"5\">%s</td></tr>\n", line);
+        html->appendf("<tr><td colspan=\"5\">%s</td></tr>\n", line);
         return html;
     }
 
@@ -785,7 +785,7 @@ Ftp::Gateway::htmlifyListEntry(const char *line)
 
         html = new MemBuf();
         html->init();
-        html->Printf("<tr class=\"entry\"><td colspan=\"5\">%s</td></tr>\n", line);
+        html->appendf("<tr class=\"entry\"><td colspan=\"5\">%s</td></tr>\n", line);
 
         for (p = line; *p && xisspace(*p); ++p);
         if (*p && !xisspace(*p))
@@ -870,18 +870,18 @@ Ftp::Gateway::htmlifyListEntry(const char *line)
     /* construct the table row from parts. */
     html = new MemBuf();
     html->init();
-    html->Printf("<tr class=\"entry\">"
-                 "<td class=\"icon\"><a href=\"%s%s\">%s</a></td>"
-                 "<td class=\"filename\"><a href=\"%s%s\">%s</a></td>"
-                 "<td class=\"date\">%s</td>"
-                 "<td class=\"size\">%s</td>"
-                 "<td class=\"actions\">%s%s%s%s</td>"
-                 "</tr>\n",
-                 prefix, href, icon,
-                 prefix, href, html_quote(text),
-                 parts->date,
-                 size,
-                 chdir, view, download, link);
+    html->appendf("<tr class=\"entry\">"
+                  "<td class=\"icon\"><a href=\"%s%s\">%s</a></td>"
+                  "<td class=\"filename\"><a href=\"%s%s\">%s</a></td>"
+                  "<td class=\"date\">%s</td>"
+                  "<td class=\"size\">%s</td>"
+                  "<td class=\"actions\">%s%s%s%s</td>"
+                  "</tr>\n",
+                  prefix, href, icon,
+                  prefix, href, html_quote(text),
+                  parts->date,
+                  size,
+                  chdir, view, download, link);
 
     ftpListPartsFree(&parts);
     return html;
@@ -960,7 +960,7 @@ Ftp::Gateway::parseListing()
         if ( t != NULL) {
             debugs(9, 7, HERE << "listing append: t = {" << t->contentSize() << ", '" << t->content() << "'}");
             listing.append(t->content(), t->contentSize());
-//leak?            delete t;
+            delete t;
         }
     }
 
@@ -1081,35 +1081,33 @@ Ftp::Gateway::checkAuth(const HttpHeader * req_hdr)
     return 0;           /* different username */
 }
 
-static String str_type_eq;
 void
 Ftp::Gateway::checkUrlpath()
 {
-    int l;
-    size_t t;
+    static SBuf str_type_eq("type=");
+    auto t = request->url.path().rfind(';');
 
-    if (str_type_eq.size()==0) //hack. String doesn't support global-static
-        str_type_eq="type=";
-
-    if ((t = request->urlpath.rfind(';')) != String::npos) {
-        if (request->urlpath.substr(t+1,t+1+str_type_eq.size())==str_type_eq) {
-            typecode = (char)xtoupper(request->urlpath[t+str_type_eq.size()+1]);
-            request->urlpath.cut(t);
+    if (t != SBuf::npos) {
+        auto filenameEnd = t-1;
+        if (request->url.path().substr(++t).cmp(str_type_eq, str_type_eq.length()) == 0) {
+            t += str_type_eq.length();
+            typecode = (char)xtoupper(request->url.path()[t]);
+            request->url.path(request->url.path().substr(0,filenameEnd));
         }
     }
 
-    l = request->urlpath.size();
+    int l = request->url.path().length();
     /* check for null path */
 
     if (!l) {
         flags.isdir = 1;
         flags.root_dir = 1;
         flags.need_base_href = 1;   /* Work around broken browsers */
-    } else if (!request->urlpath.cmp("/%2f/")) {
+    } else if (!request->url.path().cmp("/%2f/")) {
         /* UNIX root directory */
         flags.isdir = 1;
         flags.root_dir = 1;
-    } else if ((l >= 1) && (request->urlpath[l - 1] == '/')) {
+    } else if ((l >= 1) && (request->url.path()[l-1] == '/')) {
         /* Directory URL, ending in / */
         flags.isdir = 1;
 
@@ -1130,36 +1128,26 @@ Ftp::Gateway::buildTitleUrl()
         title_url.append("@");
     }
 
-    title_url.append(request->GetHost());
-
-    if (request->port != urlDefaultPort(AnyP::PROTO_FTP)) {
-        title_url.append(":");
-        title_url.append(xitoa(request->port));
-    }
+    SBuf authority = request->url.authority(request->url.getScheme() != AnyP::PROTO_FTP);
 
-    title_url.append (request->urlpath);
+    title_url.append(authority.rawContent(), authority.length());
+    title_url.append(request->url.path().rawContent(), request->url.path().length());
 
     base_href = "ftp://";
 
     if (strcmp(user, "anonymous") != 0) {
         base_href.append(rfc1738_escape_part(user));
 
         if (password_url) {
-            base_href.append (":");
+            base_href.append(":");
             base_href.append(rfc1738_escape_part(password));
         }
 
         base_href.append("@");
     }
 
-    base_href.append(request->GetHost());
-
-    if (request->port != urlDefaultPort(AnyP::PROTO_FTP)) {
-        base_href.append(":");
-        base_href.append(xitoa(request->port));
-    }
-
-    base_href.append(request->urlpath);
+    base_href.append(authority.rawContent(), authority.length());
+    base_href.append(request->url.path().rawContent(), request->url.path().length());
     base_href.append("/");
 }
 
@@ -1176,8 +1164,8 @@ Ftp::Gateway::start()
 
     checkUrlpath();
     buildTitleUrl();
-    debugs(9, 5, HERE << "FD " << ctrl.conn->fd << " : host=" << request->GetHost() <<
-           ", path=" << request->urlpath << ", user=" << user << ", passwd=" << password);
+    debugs(9, 5, "FD " << ctrl.conn->fd << " : host=" << request->url.host() <<
+           ", path=" << request->url.path() << ", user=" << user << ", passwd=" << password);
     state = BEGIN;
     Ftp::Client::start();
 }
@@ -1307,10 +1295,10 @@ Ftp::Gateway::ftpRealm()
     /* This request is not fully authenticated */
     if (!request) {
         snprintf(realm, 8192, "FTP %s unknown", user);
-    } else if (request->port == 21) {
-        snprintf(realm, 8192, "FTP %s %s", user, request->GetHost());
+    } else if (request->url.port() == 21) {
+        snprintf(realm, 8192, "FTP %s %s", user, request->url.host());
     } else {
-        snprintf(realm, 8192, "FTP %s %s port %d", user, request->GetHost(), request->port);
+        snprintf(realm, 8192, "FTP %s %s port %d", user, request->url.host(), request->url.port());
     }
     return realm;
 }
@@ -1323,9 +1311,7 @@ ftpSendUser(Ftp::Gateway * ftpState)
         return;
 
     if (ftpState->proxy_host != NULL)
-        snprintf(cbuf, CTRL_BUFLEN, "USER %s@%s\r\n",
-                 ftpState->user,
-                 ftpState->request->GetHost());
+        snprintf(cbuf, CTRL_BUFLEN, "USER %s@%s\r\n", ftpState->user, ftpState->request->url.host());
     else
         snprintf(cbuf, CTRL_BUFLEN, "USER %s\r\n", ftpState->user);
 
@@ -1377,18 +1363,14 @@ ftpReadPass(Ftp::Gateway * ftpState)
 static void
 ftpSendType(Ftp::Gateway * ftpState)
 {
-    const char *t;
-    const char *filename;
-    char mode;
-
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendType"))
         return;
 
     /*
      * Ref section 3.2.2 of RFC 1738
      */
-    mode = ftpState->typecode;
+    char mode = ftpState->typecode;
 
     switch (mode) {
 
@@ -1406,9 +1388,10 @@ ftpSendType(Ftp::Gateway * ftpState)
         if (ftpState->flags.isdir) {
             mode = 'A';
         } else {
-            t = ftpState->request->urlpath.rpos('/');
-            filename = t ? t + 1 : ftpState->request->urlpath.termedBuf();
-            mode = mimeGetTransferMode(filename);
+            auto t = ftpState->request->url.path().rfind('/');
+            // XXX: performance regression, c_str() may reallocate
+            SBuf filename = ftpState->request->url.path().substr(t != SBuf::npos ? t + 1 : 0);
+            mode = mimeGetTransferMode(filename.c_str());
         }
 
         break;
@@ -1435,7 +1418,8 @@ ftpReadType(Ftp::Gateway * ftpState)
     debugs(9, 3, HERE << "code=" << code);
 
     if (code == 200) {
-        p = path = xstrdup(ftpState->request->urlpath.termedBuf());
+        const SBuf tmp = ftpState->request->url.path();
+        p = path = xstrndup(tmp.rawContent(),tmp.length());
 
         if (*p == '/')
             ++p;
@@ -1818,7 +1802,12 @@ ftpOpenListenSocket(Ftp::Gateway * ftpState, int fallback)
      */
     if (fallback) {
         int on = 1;
-        setsockopt(ftpState->ctrl.conn->fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));
+        errno = 0;
+        if (setsockopt(ftpState->ctrl.conn->fd, SOL_SOCKET, SO_REUSEADDR,
+                       (char *) &on, sizeof(on)) == -1) {
+            // SO_REUSEADDR is only an optimization, no need to be verbose about error
+            debugs(9, 4, "setsockopt failed: " << xstrerror());
+        }
         ftpState->ctrl.conn->flags |= COMM_REUSEADDR;
         temp->flags |= COMM_REUSEADDR;
     } else {
@@ -2380,7 +2369,9 @@ ftpTrySlashHack(Ftp::Gateway * ftpState)
     safe_free(ftpState->filepath);
 
     /* Build the new path (urlpath begins with /) */
-    path = xstrdup(ftpState->request->urlpath.termedBuf());
+    const SBuf tmp = ftpState->request->url.path();
+    path = xstrndup(tmp.rawContent(), tmp.length());
+    path[tmp.length()] = '\0';
 
     rfc1738_unescape(path);
 
@@ -2431,17 +2422,17 @@ Ftp::Gateway::hackShortcut(FTPSM * nextState)
 static void
 ftpFail(Ftp::Gateway *ftpState)
 {
-    debugs(9, 6, HERE << "flags(" <<
+    const bool slashHack = ftpState->request->url.path().caseCmp("/%2f", 4)==0;
+    debugs(9, 6, "flags(" <<
            (ftpState->flags.isdir?"IS_DIR,":"") <<
            (ftpState->flags.try_slash_hack?"TRY_SLASH_HACK":"") << "), " <<
            "mdtm=" << ftpState->mdtm << ", size=" << ftpState->theSize <<
-           "slashhack=" << (ftpState->request->urlpath.caseCmp("/%2f", 4)==0? "T":"F") );
+           "slashhack=" << (slashHack? "T":"F"));
 
     /* Try the / hack to support "Netscape" FTP URL's for retreiving files */
     if (!ftpState->flags.isdir &&   /* Not a directory */
-            !ftpState->flags.try_slash_hack &&  /* Not in slash hack */
-            ftpState->mdtm <= 0 && ftpState->theSize < 0 && /* Not known as a file */
-            ftpState->request->urlpath.caseCmp("/%2f", 4) != 0) {   /* No slash encoded */
+            !ftpState->flags.try_slash_hack && !slashHack && /* Not doing slash hack */
+            ftpState->mdtm <= 0 && ftpState->theSize < 0) { /* Not known as a file */
 
         switch (ftpState->state) {
 
@@ -2544,12 +2535,6 @@ ftpSendReply(Ftp::Gateway * ftpState)
 void
 Ftp::Gateway::appendSuccessHeader()
 {
-    const char *mime_type = NULL;
-    const char *mime_enc = NULL;
-    String urlpath = request->urlpath;
-    const char *filename = NULL;
-    const char *t = NULL;
-
     debugs(9, 3, HERE);
 
     if (flags.http_header_sent)
@@ -2565,7 +2550,12 @@ Ftp::Gateway::appendSuccessHeader()
 
     entry->buffer();    /* released when done processing current data payload */
 
-    filename = (t = urlpath.rpos('/')) ? t + 1 : urlpath.termedBuf();
+    SBuf urlPath = request->url.path();
+    auto t = urlPath.rfind('/');
+    SBuf filename = urlPath.substr(t != SBuf::npos ? t : 0);
+
+    const char *mime_type = NULL;
+    const char *mime_enc = NULL;
 
     if (flags.isdir) {
         mime_type = "text/html";
@@ -2574,16 +2564,18 @@ Ftp::Gateway::appendSuccessHeader()
 
         case 'I':
             mime_type = "application/octet-stream";
-            mime_enc = mimeGetContentEncoding(filename);
+            // XXX: performance regression, c_str() may reallocate
+            mime_enc = mimeGetContentEncoding(filename.c_str());
             break;
 
         case 'A':
             mime_type = "text/plain";
             break;
 
         default:
-            mime_type = mimeGetContentType(filename);
-            mime_enc = mimeGetContentEncoding(filename);
+            // XXX: performance regression, c_str() may reallocate
+            mime_type = mimeGetContentType(filename.c_str());
+            mime_enc = mimeGetContentEncoding(filename.c_str());
             break;
         }
     }
@@ -2655,25 +2647,25 @@ Ftp::Gateway::ftpAuthRequired(HttpRequest * request, const char *realm)
     return newrep;
 }
 
-const char *
+const SBuf &
 Ftp::UrlWith2f(HttpRequest * request)
 {
-    String newbuf = "%2f";
+    SBuf newbuf("%2f");
 
-    if (request->url.getScheme() != AnyP::PROTO_FTP)
-        return NULL;
+    if (request->url.getScheme() != AnyP::PROTO_FTP) {
+        static const SBuf nil;
+        return nil;
+    }
 
-    if ( request->urlpath[0]=='/' ) {
-        newbuf.append(request->urlpath);
-        request->urlpath.absorb(newbuf);
-        safe_free(request->canonical);
-    } else if ( !strncmp(request->urlpath.termedBuf(), "%2f", 3) ) {
-        newbuf.append(request->urlpath.substr(1,request->urlpath.size()));
-        request->urlpath.absorb(newbuf);
-        safe_free(request->canonical);
+    if (request->url.path()[0] == '/') {
+        newbuf.append(request->url.path());
+        request->url.path(newbuf);
+    } else if (!request->url.path().startsWith(newbuf)) {
+        newbuf.append(request->url.path().substr(1));
+        request->url.path(newbuf);
     }
 
-    return urlCanonical(request);
+    return request->effectiveRequestUri();
 }
 
 void
@@ -11,6 +11,7 @@
 
 class FwdState;
 class HttpRequest;
+class SBuf;
 
 class AsyncJob;
 template <class Cbc> class CbcPointer;
@@ -35,7 +36,7 @@ AsyncJobPointer StartRelay(FwdState *const fwdState);
  *
  * \todo Should be a URL class API call.
  */
-const char *UrlWith2f(HttpRequest *);
+const SBuf &UrlWith2f(HttpRequest *);
 
 } // namespace Ftp
 
@@ -75,6 +75,14 @@ Comm::Connection::close()
 {
     if (isOpen()) {
         comm_close(fd);
+        noteClosure();
+    }
+}
+
+void
+Comm::Connection::noteClosure()
+{
+    if (isOpen()) {
         fd = -1;
         if (CachePeer *p=getPeer())
             peerConnClosed(p);
@@ -75,6 +75,9 @@ class Connection : public RefCountable
     /** Close any open socket. */
     void close();
 
+    /** Synchronize with Comm: Somebody closed our connection. */
+    void noteClosure();
+
     /** determine whether this object describes an active connection or not. */
     bool isOpen() const { return (fd >= 0); }
 
@@ -132,7 +132,7 @@ Comm::TcpAcceptor::status() const
 
     static MemBuf buf;
     buf.reset();
-    buf.Printf(" FD %d, %s",conn->fd, ipbuf);
+    buf.appendf(" FD %d, %s",conn->fd, ipbuf);
 
     const char *jobStatus = AsyncJob::status();
     buf.append(jobStatus, strlen(jobStatus));
@@ -366,6 +366,7 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
         if (clientdbEstablished(details->remote, 0) > Config.client_ip_max_connections) {
             debugs(50, DBG_IMPORTANT, "WARNING: " << details->remote << " attempting more than " << Config.client_ip_max_connections << " connections.");
             Ip::Address::FreeAddr(gai);
+            PROF_stop(comm_accept);
             return Comm::COMM_ERROR;
         }
     }
@@ -376,6 +377,7 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
         Ip::Address::FreeAddr(gai);
+        PROF_stop(comm_accept);
         return Comm::COMM_ERROR;
     }
     details->local = *gai;
@@ -404,7 +406,9 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
 
     // Perform NAT or TPROXY operations to retrieve the real client/dest IP addresses
     if (conn->flags&(COMM_TRANSPARENT|COMM_INTERCEPTION) && !Ip::Interceptor.Lookup(details, conn)) {
+        debugs(50, DBG_IMPORTANT, "ERROR: NAT/TPROXY lookup failed to locate original IPs on " << details);
         // Failed.
+        PROF_stop(comm_accept);
         return Comm::COMM_ERROR;
     }
 
@@ -468,7 +468,11 @@ _db_rotate_log(void)
         remove
         (to);
 #endif
-        rename(from, to);
+        errno = 0;
+        if (rename(from, to) == -1) {
+            const auto saved_errno = errno;
+            debugs(0, DBG_IMPORTANT, "log rotation failed: " << xstrerr(saved_errno));
+        }
     }
 
     /*
@@ -483,10 +487,18 @@ _db_rotate_log(void)
     if (Debug::rotateNumber > 0) {
         snprintf(to, MAXPATHLEN, "%s.%d", debug_log_file, 0);
 #if _SQUID_WINDOWS_
-        remove
-        (to);
+        errno = 0;
+        if (remove(to) == -1) {
+            const auto saved_errno = errno;
+            debugs(0, DBG_IMPORTANT, "removal of log file " << to << " failed: " << xstrerr(saved_errno));
+        }
 #endif
-        rename(debug_log_file, to);
+        errno = 0;
+        if (rename(debug_log_file, to) == -1) {
+            const auto saved_errno = errno;
+            debugs(0, DBG_IMPORTANT, "renaming file " << debug_log_file << " to "
+                   << to << "failed: " << xstrerr(saved_errno));
+        }
     }
 
     /* Close and reopen the log.  It may have been renamed "manually"
@@ -219,8 +219,13 @@ diskHandleWrite(int fd, void *)
 
     errno = 0;
 
-    if (fdd->write_q->file_offset != -1)
-        lseek(fd, fdd->write_q->file_offset, SEEK_SET); /* XXX ignore return? */
+    if (fdd->write_q->file_offset != -1) {
+        errno = 0;
+        if (lseek(fd, fdd->write_q->file_offset, SEEK_SET) == -1) {
+            debugs(50, DBG_IMPORTANT, "error in seek for fd " << fd << ": " << xstrerror());
+            // XXX: handle error?
+        }
+    }
 
     len = FD_WRITE_METHOD(fd,
                           fdd->write_q->buf + fdd->write_q->buf_offset,
@@ -421,7 +426,12 @@ diskHandleRead(int fd, void *data)
     {
 #endif
         debugs(6, 3, "diskHandleRead: FD " << fd << " seeking to offset " << ctrl_dat->offset);
-        lseek(fd, ctrl_dat->offset, SEEK_SET);  /* XXX ignore return? */
+        errno = 0;
+        if (lseek(fd, ctrl_dat->offset, SEEK_SET) == -1) {
+            // shouldn't happen, let's detect that
+            debugs(50, DBG_IMPORTANT, "error in seek for fd " << fd << ": " << xstrerror());
+            // XXX handle failures?
+        }
         ++ statCounter.syscalls.disk.seeks;
         F->disk.offset = ctrl_dat->offset;
     }
@@ -40,6 +40,7 @@
 #include <arpa/nameser.h>
 #endif
 #include <cerrno>
+#include <random>
 #if HAVE_RESOLV_H
 #include <resolv.h>
 #endif
@@ -1054,11 +1055,14 @@ idnsFindQuery(unsigned short id)
 }
 
 static unsigned short
-idnsQueryID(void)
+idnsQueryID()
 {
-    unsigned short id = squid_random() & 0xFFFF;
+    // NP: apparently ranlux are faster, but not quite as "proven"
+    static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
+    unsigned short id = mt() & 0xFFFF;
     unsigned short first_id = id;
 
+    // ensure temporal uniqueness by looking for an existing use
     while (idnsFindQuery(id)) {
         ++id;
 
@@ -204,7 +204,7 @@ errorInitialize(void)
     if (Config.errorStylesheet) {
         ErrorPageFile tmpl("StylesSheet", ERR_MAX);
         tmpl.loadFromFile(Config.errorStylesheet);
-        error_stylesheet.Printf("%s",tmpl.text());
+        error_stylesheet.appendf("%s",tmpl.text());
     }
 
 #if USE_OPENSSL
@@ -702,72 +702,61 @@ ErrorState::Dump(MemBuf * mb)
 
     str.reset();
     /* email subject line */
-    str.Printf("CacheErrorInfo - %s", errorPageName(type));
-    mb->Printf("?subject=%s", rfc1738_escape_part(str.buf));
+    str.appendf("CacheErrorInfo - %s", errorPageName(type));
+    mb->appendf("?subject=%s", rfc1738_escape_part(str.buf));
     str.reset();
     /* email body */
-    str.Printf("CacheHost: %s\r\n", getMyHostname());
+    str.appendf("CacheHost: %s\r\n", getMyHostname());
     /* - Err Msgs */
-    str.Printf("ErrPage: %s\r\n", errorPageName(type));
+    str.appendf("ErrPage: %s\r\n", errorPageName(type));
 
     if (xerrno) {
-        str.Printf("Err: (%d) %s\r\n", xerrno, strerror(xerrno));
+        str.appendf("Err: (%d) %s\r\n", xerrno, strerror(xerrno));
     } else {
-        str.Printf("Err: [none]\r\n");
+        str.append("Err: [none]\r\n", 13);
     }
 #if USE_AUTH
     if (auth_user_request.getRaw() && auth_user_request->denyMessage())
-        str.Printf("Auth ErrMsg: %s\r\n", auth_user_request->denyMessage());
+        str.appendf("Auth ErrMsg: %s\r\n", auth_user_request->denyMessage());
 #endif
     if (dnsError.size() > 0)
-        str.Printf("DNS ErrMsg: %s\r\n", dnsError.termedBuf());
+        str.appendf("DNS ErrMsg: %s\r\n", dnsError.termedBuf());
 
     /* - TimeStamp */
-    str.Printf("TimeStamp: %s\r\n\r\n", mkrfc1123(squid_curtime));
+    str.appendf("TimeStamp: %s\r\n\r\n", mkrfc1123(squid_curtime));
 
     /* - IP stuff */
-    str.Printf("ClientIP: %s\r\n", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
+    str.appendf("ClientIP: %s\r\n", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
 
     if (request && request->hier.host[0] != '\0') {
-        str.Printf("ServerIP: %s\r\n", request->hier.host);
+        str.appendf("ServerIP: %s\r\n", request->hier.host);
     }
 
-    str.Printf("\r\n");
+    str.append("\r\n", 2);
     /* - HTTP stuff */
-    str.Printf("HTTP Request:\r\n");
-
-    if (NULL != request) {
-        Packer pck;
-        String urlpath_or_slash;
-
-        if (request->urlpath.size() != 0)
-            urlpath_or_slash = request->urlpath;
-        else
-            urlpath_or_slash = "/";
-
-        str.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
-                   SQUIDSBUFPRINT(request->method.image()),
-                   SQUIDSTRINGPRINT(urlpath_or_slash),
-                   AnyP::ProtocolType_str[request->http_ver.protocol],
-                   request->http_ver.major, request->http_ver.minor);
-        packerToMemInit(&pck, &str);
-        request->header.packInto(&pck);
-        packerClean(&pck);
+    str.append("HTTP Request:\r\n", 15);
+    if (request) {
+        str.appendf(SQUIDSBUFPH " " SQUIDSBUFPH " %s/%d.%d\n",
+                    SQUIDSBUFPRINT(request->method.image()),
+                    SQUIDSBUFPRINT(request->url.path()),
+                    AnyP::ProtocolType_str[request->http_ver.protocol],
+                    request->http_ver.major, request->http_ver.minor);
+        request->header.packInto(&str);
     }
 
-    str.Printf("\r\n");
+    str.append("\r\n", 2);
     /* - FTP stuff */
 
     if (ftp.request) {
-        str.Printf("FTP Request: %s\r\n", ftp.request);
-        str.Printf("FTP Reply: %s\r\n", (ftp.reply? ftp.reply:"[none]"));
-        str.Printf("FTP Msg: ");
+        str.appendf("FTP Request: %s\r\n", ftp.request);
+        str.appendf("FTP Reply: %s\r\n", (ftp.reply? ftp.reply:"[none]"));
+        str.append("FTP Msg: ", 9);
         wordlistCat(ftp.server_msg, &str);
-        str.Printf("\r\n");
+        str.append("\r\n", 2);
     }
 
-    str.Printf("\r\n");
-    mb->Printf("&body=%s", rfc1738_escape_part(str.buf));
+    str.append("\r\n", 2);
+    mb->appendf("&body=%s", rfc1738_escape_part(str.buf));
     str.clean();
     return 0;
 }
@@ -798,12 +787,16 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'b':
-        mb.Printf("%d", getMyPort());
+        mb.appendf("%u", getMyPort());
         break;
 
     case 'B':
         if (building_deny_info_url) break;
-        p = request ? Ftp::UrlWith2f(request) : "[no URL]";
+        if (request) {
+            const SBuf &tmp = Ftp::UrlWith2f(request);
+            mb.append(tmp.rawContent(), tmp.length());
+        } else
+            p = "[no URL]";
         break;
 
     case 'c':
@@ -828,18 +821,18 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         }
 #endif
         if (!mb.contentSize())
-            mb.Printf("[No Error Detail]");
+            mb.append("[No Error Detail]", 17);
         break;
 
     case 'e':
-        mb.Printf("%d", xerrno);
+        mb.appendf("%d", xerrno);
         break;
 
     case 'E':
         if (xerrno)
-            mb.Printf("(%d) %s", xerrno, strerror(xerrno));
+            mb.appendf("(%d) %s", xerrno, strerror(xerrno));
         else
-            mb.Printf("[No Error]");
+            mb.append("[No Error]", 10);
         break;
 
     case 'f':
@@ -872,21 +865,21 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'h':
-        mb.Printf("%s", getMyHostname());
+        mb.appendf("%s", getMyHostname());
         break;
 
     case 'H':
         if (request) {
             if (request->hier.host[0] != '\0') // if non-empty string.
                 p = request->hier.host;
             else
-                p = request->GetHost();
+                p = request->url.host();
         } else if (!building_deny_info_url)
             p = "[unknown host]";
         break;
 
     case 'i':
-        mb.Printf("%s", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
+        mb.appendf("%s", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
         break;
 
     case 'I':
@@ -905,7 +898,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'L':
         if (building_deny_info_url) break;
         if (Config.errHtmlText) {
-            mb.Printf("%s", Config.errHtmlText);
+            mb.appendf("%s", Config.errHtmlText);
             do_quote = 0;
         } else
             p = "[not available]";
@@ -939,7 +932,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'p':
         if (request) {
-            mb.Printf("%d", (int) request->port);
+            mb.appendf("%u", request->url.port());
         } else if (!building_deny_info_url) {
             p = "[unknown port]";
         }
@@ -956,29 +949,20 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'R':
         if (building_deny_info_url) {
             if (request != NULL) {
-                p = (request->urlpath.size() != 0 ? request->urlpath.termedBuf() : "/");
+                SBuf tmp = request->url.path();
+                p = tmp.c_str();
                 no_urlescape = 1;
             } else
                 p = "[no request]";
             break;
         }
-        if (NULL != request) {
-            Packer pck;
-            String urlpath_or_slash;
-
-            if (request->urlpath.size() != 0)
-                urlpath_or_slash = request->urlpath;
-            else
-                urlpath_or_slash = "/";
-
-            mb.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
-                      SQUIDSBUFPRINT(request->method.image()),
-                      SQUIDSTRINGPRINT(urlpath_or_slash),
-                      AnyP::ProtocolType_str[request->http_ver.protocol],
-                      request->http_ver.major, request->http_ver.minor);
-            packerToMemInit(&pck, &mb);
-            request->header.packInto(&pck, true); //hide authorization data
-            packerClean(&pck);
+        if (request != NULL) {
+            mb.appendf(SQUIDSBUFPH " " SQUIDSBUFPH " %s/%d.%d\n",
+                       SQUIDSBUFPRINT(request->method.image()),
+                       SQUIDSBUFPRINT(request->url.path()),
+                       AnyP::ProtocolType_str[request->http_ver.protocol],
+                       request->http_ver.major, request->http_ver.minor);
+            request->header.packInto(&mb, true); //hide authorization data
         } else if (request_hdrs) {
             p = request_hdrs;
         } else {
@@ -989,7 +973,11 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 's':
         /* for backward compat we make %s show the full URL. Drop this in some future release. */
         if (building_deny_info_url) {
-            p = request ? urlCanonical(request) : url;
+            if (request) {
+                const SBuf &tmp = request->effectiveRequestUri();
+                mb.append(tmp.rawContent(), tmp.length());
+            } else
+                p = url;
             debugs(0, DBG_CRITICAL, "WARNING: deny_info now accepts coded tags. Use %u to get the full URL instead of %s");
         } else
             p = visible_appname_string;
@@ -1005,7 +993,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
             const int saved_id = page_id;
             page_id = ERR_SQUID_SIGNATURE;
             MemBuf *sign_mb = BuildContent();
-            mb.Printf("%s", sign_mb->content());
+            mb.append(sign_mb->content(), sign_mb->contentSize());
             sign_mb->clean();
             delete sign_mb;
             page_id = saved_id;
@@ -1017,15 +1005,15 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 't':
-        mb.Printf("%s", Time::FormatHttpd(squid_curtime));
+        mb.appendf("%s", Time::FormatHttpd(squid_curtime));
         break;
 
     case 'T':
-        mb.Printf("%s", mkrfc1123(squid_curtime));
+        mb.appendf("%s", mkrfc1123(squid_curtime));
         break;
 
     case 'U':
-        /* Using the fake-https version of canonical so error pages see https:// */
+        /* Using the fake-https version of absolute-URI so error pages see https:// */
         /* even when the url-path cannot be shown as more than '*' */
         if (request)
             p = urlCanonicalFakeHttps(request);
@@ -1036,17 +1024,18 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'u':
-        if (request)
-            p = urlCanonical(request);
-        else if (url)
+        if (request) {
+            const SBuf &tmp = request->effectiveRequestUri();
+            mb.append(tmp.rawContent(), tmp.length());
+        } else if (url)
             p = url;
         else if (!building_deny_info_url)
             p = "[no URL]";
         break;
 
     case 'w':
         if (Config.adminEmail)
-            mb.Printf("%s", Config.adminEmail);
+            mb.appendf("%s", Config.adminEmail);
         else if (!building_deny_info_url)
             p = "[unknown]";
         break;
@@ -1061,7 +1050,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'x':
 #if USE_OPENSSL
         if (detail)
-            mb.Printf("%s", detail->errorName());
+            mb.appendf("%s", detail->errorName());
         else
 #endif
             if (!building_deny_info_url)
@@ -1091,7 +1080,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     default:
-        mb.Printf("%%%c", token);
+        mb.appendf("%%%c", token);
         do_quote = 0;
         break;
     }
@@ -1125,12 +1114,12 @@ ErrorState::DenyInfoLocation(const char *name, HttpRequest *, MemBuf &result)
     while ((p = strchr(m, '%'))) {
         result.append(m, p - m);       /* copy */
         t = Convert(*++p, true, true);       /* convert */
-        result.Printf("%s", t);        /* copy */
+        result.appendf("%s", t);        /* copy */
         m = p + 1;                     /* advance */
     }
 
     if (*m)
-        result.Printf("%s", m);        /* copy tail */
+        result.appendf("%s", m);        /* copy tail */
 
     assert((size_t)result.contentSize() == strlen(result.content()));
 }
@@ -1284,12 +1273,12 @@ MemBuf *ErrorState::ConvertText(const char *text, bool allowRecursion)
     while ((p = strchr(m, '%'))) {
         content->append(m, p - m);  /* copy */
         const char *t = Convert(*++p, false, allowRecursion);   /* convert */
-        content->Printf("%s", t);   /* copy */
+        content->appendf("%s", t);   /* copy */
         m = p + 1;          /* advance */
     }
 
     if (*m)
-        content->Printf("%s", m);   /* copy tail */
+        content->appendf("%s", m);   /* copy tail */
 
     content->terminate();
 
@@ -9,7 +9,6 @@
 /* DEBUG: section 41    Event Processing */
 
 #include "squid.h"
-#include "compat/drand48.h"
 #include "event.h"
 #include "mgr/Registration.h"
 #include "profiler/Profiler.h"
@@ -18,6 +17,7 @@
 #include "tools.h"
 
 #include <cmath>
+#include <random>
 
 /* The list of event processes */
 
@@ -116,12 +116,12 @@ void
 eventAddIsh(const char *name, EVH * func, void *arg, double delta_ish, int weight)
 {
     if (delta_ish >= 3.0) {
-        const double two_third = (2.0 * delta_ish) / 3.0;
-        delta_ish = two_third + (drand48() * two_third);
-        /*
-         * I'm sure drand48() isn't portable.  Tell me what function
-         * you have that returns a random double value in the range 0,1.
-         */
+        // Default seed is fine. We just need values random enough
+        // relative to each other to prevent waves of synchronised activity.
+        static std::mt19937 rng;
+        auto third = (delta_ish/3.0);
+        std::uniform_real_distribution<> thirdIsh(delta_ish - third, delta_ish + third);
+        delta_ish = thirdIsh(rng);
     }
 
     eventAdd(name, func, arg, delta_ish, weight);
@@ -1000,9 +1000,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
 
         MemBuf buf;
         buf.init();
-
-        buf.Printf("%s\n", key);
-
+        buf.appendf("%s\n", key);
         debugs(82, 4, "externalAclLookup: looking up for '" << key << "' in '" << def->name << "'.");
 
         if (!def->theHelper->trySubmit(buf.buf, externalAclHandleReply, state)) {
@@ -1027,7 +1025,8 @@ externalAclStats(StoreEntry * sentry)
     for (external_acl *p = Config.externalAclHelperList; p; p = p->next) {
         storeAppendPrintf(sentry, "External ACL Statistics: %s\n", p->name);
         storeAppendPrintf(sentry, "Cache size: %d\n", p->cache->count);
-        helperStats(sentry, p->theHelper);
+        assert(p->theHelper);
+        p->theHelper->packStatsInto(sentry);
         storeAppendPrintf(sentry, "\n");
     }
 }
@@ -12,10 +12,7 @@
 #include "comm.h"
 #include "defines.h"
 #include "ip/Address.h"
-
-#if HAVE_OPENSSL_SSL_H
-#include <openssl/ssl.h>
-#endif
+#include "security/forward.h"
 
 #if USE_DELAY_POOLS
 class ClientInfo;
@@ -109,10 +106,8 @@ class fde
     CommWriteStateData *wstate;         /* State data for comm_write */
     READ_HANDLER *read_method;
     WRITE_HANDLER *write_method;
-#if USE_OPENSSL
-    SSL *ssl;
-    SSL_CTX *dynamicSslContext; ///< cached and then freed when fd is closed
-#endif
+    Security::SessionPointer ssl;
+    Security::ContextPointer dynamicSslContext; ///< cached and then freed when fd is closed
 #if _SQUID_WINDOWS_
     struct {
         long handle;
@@ -161,10 +156,8 @@ class fde
         wstate = NULL;
         read_method = NULL;
         write_method = NULL;
-#if USE_OPENSSL
         ssl = NULL;
         dynamicSslContext = NULL;
-#endif
 #if _SQUID_WINDOWS_
         win32.handle = (long)NULL;
 #endif
@@ -901,14 +901,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_SQUID_STATUS:
-            if (al->http.timedout || al->http.aborted) {
-                snprintf(tmp, sizeof(tmp), "%s%s", LogTags_str[al->cache.code],
-                         al->http.statusSfx());
-                out = tmp;
-            } else {
-                out = LogTags_str[al->cache.code];
-            }
-
+            out = al->cache.code.c_str();
             break;
 
         case LFT_SQUID_ERROR:
@@ -965,7 +958,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_CLIENT_REQ_URI:
             // original client URI
             if (al->request) {
-                out = urlCanonical(al->request);
+                const SBuf &s = al->request->effectiveRequestUri();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -979,22 +974,23 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_CLIENT_REQ_URLDOMAIN:
             if (al->request) {
-                out = al->request->GetHost();
+                out = al->request->url.host();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_URLPORT:
             if (al->request) {
-                outint = al->request->port;
+                outint = al->request->url.port();
                 doint = 1;
             }
             break;
 
         case LFT_REQUEST_URLPATH_OLD_31:
         case LFT_CLIENT_REQ_URLPATH:
             if (al->request) {
-                out = al->request->urlpath.termedBuf();
+                SBuf s = al->request->url.path();
+                out = s.c_str();
                 quote = 1;
             }
             break;
@@ -1039,7 +1035,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_SERVER_REQ_URI:
             // adapted request URI sent to server/peer
             if (al->adapted_request) {
-                out = urlCanonical(al->adapted_request);
+                const SBuf &s = al->adapted_request->effectiveRequestUri();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -1053,21 +1051,22 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_SERVER_REQ_URLDOMAIN:
             if (al->adapted_request) {
-                out = al->adapted_request->GetHost();
+                out = al->adapted_request->url.host();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLPORT:
             if (al->adapted_request) {
-                outint = al->adapted_request->port;
+                outint = al->adapted_request->url.port();
                 doint = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLPATH:
             if (al->adapted_request) {
-                out = al->adapted_request->urlpath.termedBuf();
+                SBuf s = al->adapted_request->url.path();
+                out = s.c_str();
                 quote = 1;
             }
             break;
@@ -1365,9 +1364,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                                      fmt->widthMax : strlen(out);
 
                 if (fmt->left)
-                    mb.Printf("%-*.*s", minWidth, maxWidth, out);
+                    mb.appendf("%-*.*s", minWidth, maxWidth, out);
                 else
-                    mb.Printf("%*.*s", minWidth, maxWidth, out);
+                    mb.appendf("%*.*s", minWidth, maxWidth, out);
             } else
                 mb.append(out, strlen(out));
         } else {
@@ -281,7 +281,7 @@ Rock::Rebuild::importEntry(Ipc::StoreMapAnchor &anchor, const sfileno fileno, co
     cache_key key[SQUID_MD5_DIGEST_LENGTH];
     StoreEntry loadedE;
     const uint64_t knownSize = header.entrySize > 0 ?
-                               header.entrySize : anchor.basics.swap_file_sz.get();
+                               header.entrySize : anchor.basics.swap_file_sz.load();
     if (!storeRebuildParseEntry(buf, loadedE, key, counts, knownSize))
         return false;
 
@@ -405,12 +405,20 @@ Rock::SwapDir::parseSize(const bool reconfig)
 ConfigOption *
 Rock::SwapDir::getOptionTree() const
 {
-    ConfigOptionVector *vector = dynamic_cast<ConfigOptionVector*>(::SwapDir::getOptionTree());
-    assert(vector);
-    vector->options.push_back(new ConfigOptionAdapter<SwapDir>(*const_cast<SwapDir *>(this), &SwapDir::parseSizeOption, &SwapDir::dumpSizeOption));
-    vector->options.push_back(new ConfigOptionAdapter<SwapDir>(*const_cast<SwapDir *>(this), &SwapDir::parseTimeOption, &SwapDir::dumpTimeOption));
-    vector->options.push_back(new ConfigOptionAdapter<SwapDir>(*const_cast<SwapDir *>(this), &SwapDir::parseRateOption, &SwapDir::dumpRateOption));
-    return vector;
+    ConfigOption *copt = ::SwapDir::getOptionTree();
+    ConfigOptionVector *vector = dynamic_cast<ConfigOptionVector*>(copt);
+    if (vector) {
+        // if copt is actually a ConfigOptionVector
+        vector->options.push_back(new ConfigOptionAdapter<SwapDir>(*const_cast<SwapDir *>(this), &SwapDir::parseSizeOption, &SwapDir::dumpSizeOption));
+        vector->options.push_back(new ConfigOptionAdapter<SwapDir>(*const_cast<SwapDir *>(this), &SwapDir::parseTimeOption, &SwapDir::dumpTimeOption));
+        vector->options.push_back(new ConfigOptionAdapter<SwapDir>(*const_cast<SwapDir *>(this), &SwapDir::parseRateOption, &SwapDir::dumpRateOption));
+    } else {
+        // we don't know how to handle copt, as it's not a ConfigOptionVector.
+        // free it (and return nullptr)
+        delete copt;
+        copt = nullptr;
+    }
+    return copt;
 }
 
 bool
@@ -33,6 +33,7 @@
 
 #include <cerrno>
 #include <cmath>
+#include <random>
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
@@ -1042,7 +1043,9 @@ Fs::Ufs::UFSSwapDir::CleanEvent(void *)
          * value.  j equals the total number of UFS level 2
          * swap directories
          */
-        swap_index = (int) (squid_random() % j);
+        std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
+        std::uniform_int_distribution<> dist(0, j);
+        swap_index = dist(mt);
     }
 
     /* if the rebuild is finished, start cleaning directories. */
@@ -21,6 +21,7 @@
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "mime.h"
+#include "parser/Tokenizer.h"
 #include "rfc1738.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
@@ -253,23 +254,27 @@ gopherMimeCreate(GopherStateData * gopherState)
 static void
 gopher_request_parse(const HttpRequest * req, char *type_id, char *request)
 {
-    const char *path = req->urlpath.termedBuf();
+    ::Parser::Tokenizer tok(req->url.path());
 
     if (request)
-        request[0] = '\0';
+        *request = 0;
 
-    if (path && (*path == '/'))
-        ++path;
+    tok.skip('/'); // ignore failures? path could be ab-empty
 
-    if (!path || !*path) {
+    if (tok.atEnd()) {
         *type_id = GOPHER_DIRECTORY;
         return;
     }
 
-    *type_id = path[0];
+    static const CharacterSet anyByte("UTF-8",0x00, 0xFF);
+
+    SBuf typeId;
+    (void)tok.prefix(typeId, anyByte, 1); // never fails since !atEnd()
+    *type_id = typeId[0];
 
     if (request) {
-        xstrncpy(request, path + 1, MAX_URL);
+        SBuf path = tok.remaining().substr(0, MAX_URL-1);
+        xstrncpy(request, path.rawContent(), path.length()+1);
         /* convert %xx to char */
         rfc1738_unescape(request);
     }
@@ -830,7 +835,7 @@ gopherSendComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size,
         ErrorState *err;
         err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request);
         err->xerrno = xerrno;
-        err->port = gopherState->fwd->request->port;
+        err->port = gopherState->fwd->request->url.port();
         err->url = xstrdup(entry->url());
         gopherState->fwd->fail(err);
         gopherState->serverConn->close();
@@ -10,6 +10,7 @@
 
 #include "squid.h"
 #include "base/AsyncCbdataCalls.h"
+#include "base/Packable.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Read.h"
@@ -63,7 +64,6 @@ static void helperKickQueue(helper * hlp);
 static void helperStatefulKickQueue(statefulhelper * hlp);
 static void helperStatefulServerDone(helper_stateful_server * srv);
 static void StatefulEnqueue(statefulhelper * hlp, Helper::Request * r);
-static bool helperStartStats(StoreEntry *sentry, void *hlp, const char *label);
 
 CBDATA_CLASS_INIT(helper);
 CBDATA_CLASS_INIT(helper_server);
@@ -471,7 +471,7 @@ void statefulhelper::submit(const char *buf, HLPCB * callback, void *data, helpe
     if ((buf != NULL) && lastserver) {
         debugs(84, 5, "StatefulSubmit with lastserver " << lastserver);
         assert(lastserver->flags.reserved);
-        assert(!(lastserver->request));
+        assert(!lastserver->requests.size());
 
         debugs(84, 5, "StatefulSubmit dispatching");
         helperStatefulDispatch(lastserver, r);
@@ -523,124 +523,62 @@ helperStatefulServerGetData(helper_stateful_server * srv)
     return srv->data;
 }
 
-/**
- * Dump some stats about the helper states to a StoreEntry
- */
 void
-helperStats(StoreEntry * sentry, helper * hlp, const char *label)
+helper::packStatsInto(Packable *p, const char *label) const
 {
-    if (!helperStartStats(sentry, hlp, label))
-        return;
-
-    storeAppendPrintf(sentry, "program: %s\n",
-                      hlp->cmdline->key);
-    storeAppendPrintf(sentry, "number active: %d of %d (%d shutting down)\n",
-                      hlp->childs.n_active, hlp->childs.n_max, (hlp->childs.n_running - hlp->childs.n_active) );
-    storeAppendPrintf(sentry, "requests sent: %d\n",
-                      hlp->stats.requests);
-    storeAppendPrintf(sentry, "replies received: %d\n",
-                      hlp->stats.replies);
-    storeAppendPrintf(sentry, "requests timedout: %d\n",
-                      hlp->stats.timedout);
-    storeAppendPrintf(sentry, "queue length: %d\n",
-                      hlp->stats.queue_size);
-    storeAppendPrintf(sentry, "avg service time: %d msec\n",
-                      hlp->stats.avg_svc_time);
-    storeAppendPrintf(sentry, "\n");
-    storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%11s\t%11s\t%s\t%7s\t%7s\t%7s\n",
-                      "ID #",
-                      "FD",
-                      "PID",
-                      "# Requests",
-                      "# Replies",
-                      "# Timed-out",
-                      "Flags",
-                      "Time",
-                      "Offset",
-                      "Request");
-
-    for (dlink_node *link = hlp->servers.head; link; link = link->next) {
-        helper_server *srv = (helper_server*)link->data;
+    if (label)
+        p->appendf("%s:\n", label);
+
+    p->appendf("  program: %s\n", cmdline->key);
+    p->appendf("  number active: %d of %d (%d shutting down)\n", childs.n_active, childs.n_max, (childs.n_running - childs.n_active));
+    p->appendf("  requests sent: %d\n", stats.requests);
+    p->appendf("  replies received: %d\n", stats.replies);
+    p->appendf("  requests timedout: %d\n", stats.timedout);
+    p->appendf("  queue length: %d\n", stats.queue_size);
+    p->appendf("  avg service time: %d msec\n", stats.avg_svc_time);
+    p->append("\n",1);
+    p->appendf("%7s\t%7s\t%7s\t%11s\t%11s\t%11s\t%6s\t%7s\t%7s\t%7s\n",
+               "ID #",
+               "FD",
+               "PID",
+               "# Requests",
+               "# Replies",
+               "# Timed-out",
+               "Flags",
+               "Time",
+               "Offset",
+               "Request");
+
+    for (dlink_node *link = servers.head; link; link = link->next) {
+        HelperServerBase *srv = static_cast<HelperServerBase *>(link->data);
+        assert(srv);
         Helper::Request *request = srv->requests.empty() ? NULL : srv->requests.front();
         double tt = 0.001 * (request ? tvSubMsec(request->dispatch_time, current_time) : tvSubMsec(srv->dispatch_time, srv->answer_time));
-        storeAppendPrintf(sentry, "%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c\t%7.3f\t%7d\t%s\n",
-                          srv->index.value,
-                          srv->readPipe->fd,
-                          srv->pid,
-                          srv->stats.uses,
-                          srv->stats.replies,
-                          srv->stats.timedout,
-                          srv->stats.pending ? 'B' : ' ',
-                          srv->flags.writing ? 'W' : ' ',
-                          srv->flags.closing ? 'C' : ' ',
-                          srv->flags.shutdown ? 'S' : ' ',
-                          tt < 0.0 ? 0.0 : tt,
-                          (int) srv->roffset,
-                          request ? Format::QuoteMimeBlob(request->buf) : "(none)");
-    }
-
-    storeAppendPrintf(sentry, "\nFlags key:\n\n");
-    storeAppendPrintf(sentry, "   B = BUSY\n");
-    storeAppendPrintf(sentry, "   W = WRITING\n");
-    storeAppendPrintf(sentry, "   C = CLOSING\n");
-    storeAppendPrintf(sentry, "   S = SHUTDOWN PENDING\n");
-}
-
-void
-helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label)
-{
-    if (!helperStartStats(sentry, hlp, label))
-        return;
-
-    storeAppendPrintf(sentry, "program: %s\n",
-                      hlp->cmdline->key);
-    storeAppendPrintf(sentry, "number active: %d of %d (%d shutting down)\n",
-                      hlp->childs.n_active, hlp->childs.n_max, (hlp->childs.n_running - hlp->childs.n_active) );
-    storeAppendPrintf(sentry, "requests sent: %d\n",
-                      hlp->stats.requests);
-    storeAppendPrintf(sentry, "replies received: %d\n",
-                      hlp->stats.replies);
-    storeAppendPrintf(sentry, "queue length: %d\n",
-                      hlp->stats.queue_size);
-    storeAppendPrintf(sentry, "avg service time: %d msec\n",
-                      hlp->stats.avg_svc_time);
-    storeAppendPrintf(sentry, "\n");
-    storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%11s\t%6s\t%7s\t%7s\t%7s\n",
-                      "ID #",
-                      "FD",
-                      "PID",
-                      "# Requests",
-                      "# Replies",
-                      "Flags",
-                      "Time",
-                      "Offset",
-                      "Request");
-
-    for (dlink_node *link = hlp->servers.head; link; link = link->next) {
-        helper_stateful_server *srv = (helper_stateful_server *)link->data;
-        double tt = 0.001 * tvSubMsec(srv->dispatch_time, srv->stats.pending ? current_time : srv->answer_time);
-        storeAppendPrintf(sentry, "%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
-                          srv->index.value,
-                          srv->readPipe->fd,
-                          srv->pid,
-                          srv->stats.uses,
-                          srv->stats.replies,
-                          srv->stats.pending ? 'B' : ' ',
-                          srv->flags.closing ? 'C' : ' ',
-                          srv->flags.reserved ? 'R' : ' ',
-                          srv->flags.shutdown ? 'S' : ' ',
-                          srv->request ? (srv->request->placeholder ? 'P' : ' ') : ' ',
-                          tt < 0.0 ? 0.0 : tt,
-                          (int) srv->roffset,
-                          srv->request ? Format::QuoteMimeBlob(srv->request->buf) : "(none)");
+        p->appendf("%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
+                   srv->index.value,
+                   srv->readPipe->fd,
+                   srv->pid,
+                   srv->stats.uses,
+                   srv->stats.replies,
+                   srv->stats.timedout,
+                   srv->stats.pending ? 'B' : ' ',
+                   srv->flags.writing ? 'W' : ' ',
+                   srv->flags.closing ? 'C' : ' ',
+                   srv->flags.reserved ? 'R' : ' ',
+                   srv->flags.shutdown ? 'S' : ' ',
+                   request && request->placeholder ? 'P' : ' ',
+                   tt < 0.0 ? 0.0 : tt,
+                   (int) srv->roffset,
+                   request ? Format::QuoteMimeBlob(request->buf) : "(none)");
     }
 
-    storeAppendPrintf(sentry, "\nFlags key:\n\n");
-    storeAppendPrintf(sentry, "   B = BUSY\n");
-    storeAppendPrintf(sentry, "   C = CLOSING\n");
-    storeAppendPrintf(sentry, "   R = RESERVED\n");
-    storeAppendPrintf(sentry, "   S = SHUTDOWN PENDING\n");
-    storeAppendPrintf(sentry, "   P = PLACEHOLDER\n");
+    p->append("\nFlags key:\n"
+              "   B\tBUSY\n"
+              "   W\tWRITING\n"
+              "   C\tCLOSING\n"
+              "   R\tRESERVED\n"
+              "   S\tSHUTDOWN PENDING\n"
+              "   P\tPLACEHOLDER\n", 101);
 }
 
 void
@@ -743,7 +681,6 @@ static void
 helperServerFree(helper_server *srv)
 {
     helper *hlp = srv->parent;
-    Helper::Request *r;
     int concurrency = hlp->childs.concurrency;
 
     if (!concurrency)
@@ -793,7 +730,7 @@ helperServerFree(helper_server *srv)
 
     while (!srv->requests.empty()) {
         // XXX: re-schedule these on another helper?
-        r = srv->requests.front();
+        Helper::Request *r = srv->requests.front();
         srv->requests.pop_front();
         void *cbdata;
 
@@ -814,7 +751,6 @@ static void
 helperStatefulServerFree(helper_stateful_server *srv)
 {
     statefulhelper *hlp = srv->parent;
-    Helper::Request *r;
 
     if (srv->rbuf) {
         memFreeBuf(srv->rbuf_sz, srv->rbuf);
@@ -857,18 +793,18 @@ helperStatefulServerFree(helper_stateful_server *srv)
         }
     }
 
-    if ((r = srv->request)) {
+    while (!srv->requests.empty()) {
+        // XXX: re-schedule these on another helper?
+        Helper::Request *r = srv->requests.front();
+        srv->requests.pop_front();
         void *cbdata;
 
         if (cbdataReferenceValidDone(r->data, &cbdata)) {
             Helper::Reply nilReply;
-            nilReply.whichServer = srv;
             r->callback(cbdata, nilReply);
         }
 
         delete r;
-
-        srv->request = NULL;
     }
 
     if (srv->data != NULL)
@@ -1051,7 +987,6 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
 {
     char *t = NULL;
     helper_stateful_server *srv = (helper_stateful_server *)data;
-    Helper::Request *r;
     statefulhelper *hlp = srv->parent;
     assert(cbdataReferenceValid(data));
 
@@ -1073,7 +1008,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
 
     srv->roffset += len;
     srv->rbuf[srv->roffset] = '\0';
-    r = srv->request;
+    Helper::Request *r = srv->requests.front();
     debugs(84, DBG_DATA, Raw("accumulated", srv->rbuf, srv->roffset));
 
     if (r == NULL) {
@@ -1087,6 +1022,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
 
     if ((t = strchr(srv->rbuf, hlp->eom))) {
         /* end of reply found */
+        srv->requests.pop_front(); // we already have it in 'r'
         int called = 1;
         int skip = 1;
         debugs(84, 3, "helperStatefulHandleRead: end of reply found");
@@ -1120,7 +1056,6 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
          */
         srv->roffset = 0;
         delete r;
-        srv->request = NULL;
 
         -- srv->stats.pending;
         ++ srv->stats.replies;
@@ -1386,7 +1321,7 @@ helperDispatch(helper_server * srv, Helper::Request * r)
     if (hlp->childs.concurrency) {
         srv->requestsIndex.insert(helper_server::RequestIndex::value_type(reqId, it));
         assert(srv->requestsIndex.size() == srv->requests.size());
-        srv->wqueue->Printf("%" PRIu64 " %s", reqId, r->buf);
+        srv->wqueue->appendf("%" PRIu64 " %s", reqId, r->buf);
     } else
         srv->wqueue->append(r->buf, strlen(r->buf));
 
@@ -1437,14 +1372,14 @@ helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
         /* and push the queue. Note that the callback may have submitted a new
          * request to the helper which is why we test for the request */
 
-        if (srv->request == NULL)
+        if (!srv->requests.size())
             helperStatefulServerDone(srv);
 
         return;
     }
 
     srv->flags.reserved = true;
-    srv->request = r;
+    srv->requests.push_back(r);
     srv->dispatch_time = current_time;
     AsyncCall::Pointer call = commCbCall(5,5, "helperStatefulDispatchWriteDone",
                                          CommIoCbPtrFun(helperStatefulDispatchWriteDone, hlp));
@@ -1489,22 +1424,6 @@ helperStatefulServerDone(helper_stateful_server * srv)
     }
 }
 
-// TODO: should helper_ and helper_stateful_ have a common parent?
-static bool
-helperStartStats(StoreEntry *sentry, void *hlp, const char *label)
-{
-    if (!hlp) {
-        if (label)
-            storeAppendPrintf(sentry, "%s: unavailable\n", label);
-        return false;
-    }
-
-    if (label)
-        storeAppendPrintf(sentry, "%s:\n", label);
-
-    return true;
-}
-
 void
 helper_server::checkForTimedOutRequests(bool const retry)
 {
@@ -24,6 +24,8 @@
 #include <list>
 #include <map>
 
+class Packable;
+
 /**
  * Managers a set of individual helper processes with a common queue of requests.
  *
@@ -68,6 +70,10 @@ class helper
     /// Submits a request to the helper or add it to the queue if none of
     /// the servers is available.
     void submitRequest(Helper::Request *r);
+
+    /// Dump some stats about the helper state to a Packable object
+    void packStatsInto(Packable *p, const char *label = NULL) const;
+
 public:
     wordlist *cmdline;
     dlink_list servers;
@@ -164,6 +170,9 @@ class HelperServerBase
         bool reserved;
     } flags;
 
+    typedef std::list<Helper::Request *> Requests;
+    Requests requests; ///< requests in order of submission/expiration
+
     struct {
         uint64_t uses;     //< requests sent to this helper
         uint64_t replies;  //< replies received from this helper
@@ -189,9 +198,6 @@ class helper_server : public HelperServerBase
 
     helper *parent;
 
-    typedef std::list<Helper::Request *> Requests;
-    Requests requests; ///< requests in order of submission/expiration
-
     // STL says storing std::list iterators is safe when changing the list
     typedef std::map<uint64_t, Requests::iterator> RequestIndex;
     RequestIndex requestsIndex; ///< maps request IDs to requests
@@ -213,7 +219,6 @@ class helper_stateful_server : public HelperServerBase
     /* MemBuf writebuf; */
 
     statefulhelper *parent;
-    Helper::Request *request;
 
     void *data;         /* State data used by the calling routines */
 };
@@ -223,8 +228,6 @@ void helperOpenServers(helper * hlp);
 void helperStatefulOpenServers(statefulhelper * hlp);
 void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data);
 void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver);
-void helperStats(StoreEntry * sentry, helper * hlp, const char *label = NULL);
-void helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label = NULL);
 void helperShutdown(helper * hlp);
 void helperStatefulShutdown(statefulhelper * hlp);
 void helperStatefulReleaseServer(helper_stateful_server * srv);
@@ -93,31 +93,21 @@ struct _htcpDataHeader {
     uint16_t length;
 
 #if WORDS_BIGENDIAN
-uint8_t opcode:
-    4;
-uint8_t response:
-    4;
+    uint8_t opcode:4;
+    uint8_t response:4;
 #else
-uint8_t response:
-    4;
-uint8_t opcode:
-    4;
+    uint8_t response:4;
+    uint8_t opcode:4;
 #endif
 
 #if WORDS_BIGENDIAN
-uint8_t reserved:
-    6;
-uint8_t F1:
-    1;
-uint8_t RR:
-    1;
+    uint8_t reserved:6;
+    uint8_t F1:1;
+    uint8_t RR:1;
 #else
-uint8_t RR:
-    1;
-uint8_t F1:
-    1;
-uint8_t reserved:
-    6;
+    uint8_t RR:1;
+    uint8_t F1:1;
+    uint8_t reserved:6;
 #endif
 
     uint32_t msg_id;
@@ -499,7 +489,6 @@ htcpBuildData(char *buf, size_t buflen, htcpStuff * stuff)
     ssize_t off = 0;
     ssize_t op_data_sz;
     size_t hdr_sz = sizeof(htcpDataHeader);
-    htcpDataHeader hdr;
 
     if (buflen < hdr_sz)
         return -1;
@@ -515,33 +504,25 @@ htcpBuildData(char *buf, size_t buflen, htcpStuff * stuff)
 
     debugs(31, 3, "htcpBuildData: hdr.length = " << off);
 
-    hdr.length = (uint16_t) off;
-
-    hdr.opcode = stuff->op;
-
-    hdr.response = stuff->response;
-
-    hdr.RR = stuff->rr;
-
-    hdr.F1 = stuff->f1;
-
-    hdr.msg_id = stuff->msg_id;
-
-    /* convert multi-byte fields */
-    hdr.length = htons(hdr.length);
-
-    hdr.msg_id = htonl(hdr.msg_id);
-
     if (!old_squid_format) {
+        htcpDataHeader hdr;
+        memset(&hdr, 0, sizeof(hdr));
+        /* convert multi-byte fields */
+        hdr.msg_id = htonl(stuff->msg_id);
+        hdr.length = htons(static_cast<uint16_t>(off));
+        hdr.opcode = stuff->op;
+        hdr.response = stuff->response;
+        hdr.RR = stuff->rr;
+        hdr.F1 = stuff->f1;
         memcpy(buf, &hdr, hdr_sz);
     } else {
         htcpDataHeaderSquid hdrSquid;
         memset(&hdrSquid, 0, sizeof(hdrSquid));
-        hdrSquid.length = hdr.length;
-        hdrSquid.opcode = hdr.opcode;
-        hdrSquid.response = hdr.response;
-        hdrSquid.F1 = hdr.F1;
-        hdrSquid.RR = hdr.RR;
+        hdrSquid.length = htons(static_cast<uint16_t>(off));
+        hdrSquid.opcode = stuff->op;
+        hdrSquid.response = stuff->response;
+        hdrSquid.F1 = stuff->f1;
+        hdrSquid.RR = stuff->rr;
         memcpy(buf, &hdrSquid, hdr_sz);
     }
 
@@ -849,17 +830,13 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
 {
     static char pkt[8192];
     HttpHeader hdr(hoHtcpReply);
-    MemBuf mb;
-    Packer p;
     ssize_t pktlen;
 
     htcpStuff stuff(dhdr->msg_id, HTCP_TST, RR_RESPONSE, 0);
     stuff.response = e ? 0 : 1;
     debugs(31, 3, "htcpTstReply: response = " << stuff.response);
 
     if (spec) {
-        mb.init();
-        packerToMemInit(&p, &mb);
         stuff.S.method = spec->method;
         stuff.S.uri = spec->uri;
         stuff.S.version = spec->version;
@@ -869,7 +846,9 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
             hdr.putInt(HDR_AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
         else
             hdr.putInt(HDR_AGE, 0);
-        hdr.packInto(&p);
+        MemBuf mb;
+        mb.init();
+        hdr.packInto(&mb);
         stuff.D.resp_hdrs = xstrdup(mb.buf);
         stuff.D.respHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: resp_hdrs = {" << stuff.D.resp_hdrs << "}");
@@ -882,7 +861,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         if (e && e->lastmod > -1)
             hdr.putTime(HDR_LAST_MODIFIED, e->lastmod);
 
-        hdr.packInto(&p);
+        hdr.packInto(&mb);
 
         stuff.D.entity_hdrs = xstrdup(mb.buf);
         stuff.D.entityHdrsSz = mb.contentSize();
@@ -909,13 +888,12 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         }
 #endif /* USE_ICMP */
 
-        hdr.packInto(&p);
+        hdr.packInto(&mb);
         stuff.D.cache_hdrs = xstrdup(mb.buf);
         stuff.D.cacheHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: cache_hdrs = {" << stuff.D.cache_hdrs << "}");
         mb.clean();
         hdr.clean();
-        packerClean(&p);
     }
 
     pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
@@ -1519,8 +1497,6 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
     ssize_t pktlen;
     char vbuf[32];
     HttpHeader hdr(hoRequest);
-    Packer pa;
-    MemBuf mb;
     HttpStateFlags flags;
 
     if (!Comm::IsConnOpen(htcpIncomingConn))
@@ -1537,11 +1513,10 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
     stuff.S.uri = (char *) e->url();
     stuff.S.version = vbuf;
     HttpStateData::httpBuildRequestHeader(req, e, NULL, &hdr, flags);
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&pa, &mb);
-    hdr.packInto(&pa);
+    hdr.packInto(&mb);
     hdr.clean();
-    packerClean(&pa);
     stuff.S.req_hdrs = mb.buf;
     pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
     mb.clean();
@@ -1571,7 +1546,6 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
     ssize_t pktlen;
     char vbuf[32];
     HttpHeader hdr(hoRequest);
-    Packer pa;
     MemBuf mb;
     HttpStateFlags flags;
 
@@ -1601,10 +1575,8 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
     if (reason != HTCP_CLR_INVALIDATION) {
         HttpStateData::httpBuildRequestHeader(req, e, NULL, &hdr, flags);
         mb.init();
-        packerToMemInit(&pa, &mb);
-        hdr.packInto(&pa);
+        hdr.packInto(&mb);
         hdr.clean();
-        packerClean(&pa);
         stuff.S.req_hdrs = mb.buf;
     } else {
         stuff.S.req_hdrs = NULL;
@@ -1672,7 +1644,7 @@ static void
 htcpLogHtcp(Ip::Address &caddr, int opcode, LogTags logcode, const char *url)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry;
-    if (LOG_TAG_NONE == logcode)
+    if (LOG_TAG_NONE == logcode.oldType)
         return;
     if (!Config.onoff.log_udp)
         return;
@@ -19,7 +19,6 @@
 #include "base/TextException.h"
 #include "base64.h"
 #include "CachePeer.h"
-#include "ChunkedCodingParser.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "comm/Read.h"
@@ -32,6 +31,7 @@
 #include "globals.h"
 #include "http.h"
 #include "http/one/ResponseParser.h"
+#include "http/one/TeChunkedParser.h"
 #include "HttpControlMsg.h"
 #include "HttpHdrCc.h"
 #include "HttpHdrContRange.h"
@@ -406,7 +406,7 @@ HttpStateData::cacheableReply()
             mayStore = true;
 
             // HTTPbis pt6 section 3.2: a response CC:must-revalidate is present
-        } else if (rep->cache_control->mustRevalidate() && !REFRESH_OVERRIDE(ignore_must_revalidate)) {
+        } else if (rep->cache_control->mustRevalidate()) {
             debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:must-revalidate");
             mayStore = true;
 
@@ -415,7 +415,7 @@ HttpStateData::cacheableReply()
             // HTTPbis WG verdict on this is that it is omitted from the spec due to being 'unexpected' by
             // some. The caching+revalidate is not exactly unsafe though with Squids interpretation of no-cache
             // (without parameters) as equivalent to must-revalidate in the reply.
-        } else if (rep->cache_control->hasNoCache() && rep->cache_control->noCache().size() == 0 && !REFRESH_OVERRIDE(ignore_must_revalidate)) {
+        } else if (rep->cache_control->hasNoCache() && rep->cache_control->noCache().size() == 0) {
             debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:no-cache (equivalent to must-revalidate)");
             mayStore = true;
 #endif
@@ -674,7 +674,7 @@ HttpStateData::checkDateSkew(HttpReply *reply)
         int skew = abs((int)(reply->date - squid_curtime));
 
         if (skew > 86400)
-            debugs(11, 3, "" << request->GetHost() << "'s clock is skewed by " << skew << " seconds!");
+            debugs(11, 3, "" << request->url.host() << "'s clock is skewed by " << skew << " seconds!");
     }
 }
 
@@ -788,7 +788,7 @@ HttpStateData::processReplyHeader()
     flags.chunked = false;
     if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->header.chunked()) {
         flags.chunked = true;
-        httpChunkDecoder = new ChunkedCodingParser;
+        httpChunkDecoder = new Http1::TeChunkedParser;
     }
 
     if (!peerSupportsConnectionPinning())
@@ -1309,7 +1309,7 @@ HttpStateData::continueAfterParsingHeader()
             const Http::StatusCode s = vrep->sline.status();
             const AnyP::ProtocolVersion &v = vrep->sline.version;
             if (s == Http::scInvalidHeader && v != Http::ProtocolVersion(0,9)) {
-                debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Bad header encountered from " << entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
+                debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Bad header encountered from " << entry->url() << " AKA " << request->url);
                 error = ERR_INVALID_RESP;
             } else if (s == Http::scHeaderTooLarge) {
                 fwd->dontRetry(true);
@@ -1319,18 +1319,17 @@ HttpStateData::continueAfterParsingHeader()
             }
         } else {
             // parsed headers but got no reply
-            debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: No reply at all for " << entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
+            debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: No reply at all for " << entry->url() << " AKA " << request->url);
             error = ERR_INVALID_RESP;
         }
     } else {
         assert(eof);
         if (inBuf.length()) {
             error = ERR_INVALID_RESP;
-            debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Headers did not parse at all for " << entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
+            debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Headers did not parse at all for " << entry->url() << " AKA " << request->url);
         } else {
             error = ERR_ZERO_SIZE_OBJECT;
-            debugs(11, (request->flags.accelerated?DBG_IMPORTANT:2), "WARNING: HTTP: Invalid Response: No object data received for " <<
-                   entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
+            debugs(11, (request->flags.accelerated?DBG_IMPORTANT:2), "WARNING: HTTP: Invalid Response: No object data received for " << entry->url() << " AKA " << request->url);
         }
     }
 
@@ -1393,15 +1392,9 @@ HttpStateData::decodeAndWriteReplyBody()
     SQUID_ENTER_THROWING_CODE();
     MemBuf decodedData;
     decodedData.init();
-    // XXX: performance regression. SBuf-convert (or Parser-convert?) the chunked decoder.
-    MemBuf encodedData;
-    encodedData.init();
-    // NP: we must do this instead of pointing encodedData at the SBuf::rawContent
-    // because chunked decoder uses MemBuf::consume, which shuffles buffer bytes around.
-    encodedData.append(inBuf.rawContent(), inBuf.length());
-    const bool doneParsing = httpChunkDecoder->parse(&encodedData,&decodedData);
-    // XXX: httpChunkDecoder has consumed from MemBuf.
-    inBuf.consume(inBuf.length() - encodedData.contentSize());
+    httpChunkDecoder->setPayloadBuffer(&decodedData);
+    const bool doneParsing = httpChunkDecoder->parse(inBuf);
+    inBuf = httpChunkDecoder->remaining(); // sync buffers after parse
     len = decodedData.contentSize();
     data=decodedData.content();
     addVirginReplyBody(data, len);
@@ -1498,7 +1491,7 @@ HttpStateData::processReplyBody()
                 request->clientConnectionManager->pinConnection(serverConnection, request, _peer,
                         (request->flags.connectionAuth));
             } else {
-                fwd->pconnPush(serverConnection, request->GetHost());
+                fwd->pconnPush(serverConnection, request->url.host());
             }
 
             serverConnection = NULL;
@@ -1838,7 +1831,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
             static int warnedCount = 0;
             if (warnedCount++ < 100) {
-                const char *url = entry ? entry->url() : urlCanonical(request);
+                const SBuf url(entry ? SBuf(entry->url()) : request->effectiveRequestUri());
                 debugs(11, DBG_IMPORTANT, "Warning: likely forwarding loop with " << url);
             }
         }
@@ -1870,13 +1863,9 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     if (!hdr_out->has(HDR_HOST)) {
         if (request->peer_domain) {
             hdr_out->putStr(HDR_HOST, request->peer_domain);
-        } else if (request->port == urlDefaultPort(request->url.getScheme())) {
-            /* use port# only if not default */
-            hdr_out->putStr(HDR_HOST, request->GetHost());
         } else {
-            httpHeaderPutStrf(hdr_out, HDR_HOST, "%s:%d",
-                              request->GetHost(),
-                              (int) request->port);
+            SBuf authority = request->url.authority();
+            hdr_out->putStr(HDR_HOST, authority.c_str());
         }
     }
 
@@ -1912,10 +1901,9 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
         /* Add max-age only without no-cache */
         if (!cc->hasMaxAge() && !cc->hasNoCache()) {
-            const char *url =
-                entry ? entry->url() : urlCanonical(request);
-            cc->maxAge(getMaxAge(url));
-
+            // XXX: performance regression. c_str() reallocates
+            SBuf tmp(request->effectiveRequestUri());
+            cc->maxAge(getMaxAge(entry ? entry->url() : tmp.c_str()));
         }
 
         /* Enforce sibling relations */
@@ -2025,15 +2013,8 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
         else if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
             hdr_out->addEntry(e->clone());
         else {
-            /* use port# only if not default */
-
-            if (request->port == urlDefaultPort(request->url.getScheme())) {
-                hdr_out->putStr(HDR_HOST, request->GetHost());
-            } else {
-                httpHeaderPutStrf(hdr_out, HDR_HOST, "%s:%d",
-                                  request->GetHost(),
-                                  (int) request->port);
-            }
+            SBuf authority = request->url.authority();
+            hdr_out->putStr(HDR_HOST, authority.c_str());
         }
 
         break;
@@ -2181,31 +2162,24 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
      * not the one we are sending. Needs checking.
      */
     const AnyP::ProtocolVersion httpver = Http::ProtocolVersion();
-    const char * url;
-    if (_peer && !_peer->options.originserver)
-        url = urlCanonical(request);
-    else
-        url = request->urlpath.termedBuf();
-    mb->Printf(SQUIDSBUFPH " %s %s/%d.%d\r\n",
-               SQUIDSBUFPRINT(request->method.image()),
-               url && *url ? url : "/",
-               AnyP::ProtocolType_str[httpver.protocol],
-               httpver.major,httpver.minor);
+    const SBuf url(_peer && !_peer->options.originserver ? request->effectiveRequestUri() : request->url.path());
+    mb->appendf(SQUIDSBUFPH " " SQUIDSBUFPH " %s/%d.%d\r\n",
+                SQUIDSBUFPRINT(request->method.image()),
+                SQUIDSBUFPRINT(url),
+                AnyP::ProtocolType_str[httpver.protocol],
+                httpver.major,httpver.minor);
     /* build and pack headers */
     {
         HttpHeader hdr(hoRequest);
-        Packer p;
         httpBuildRequestHeader(request, entry, fwd->al, &hdr, flags);
 
         if (request->flags.pinned && request->flags.connectionAuth)
             request->flags.authSent = true;
         else if (hdr.has(HDR_AUTHORIZATION))
             request->flags.authSent = true;
 
-        packerToMemInit(&p, mb);
-        hdr.packInto(&p);
+        hdr.packInto(mb);
         hdr.clean();
-        packerClean(&p);
     }
     /* append header terminator */
     mb->append(crlf, 2);
@@ -2273,18 +2247,17 @@ HttpStateData::sendRequest()
 
     if (_peer) {
         /*The old code here was
-          if (neighborType(_peer, request) == PEER_SIBLING && ...
+          if (neighborType(_peer, request->url) == PEER_SIBLING && ...
           which is equivalent to:
-          if (neighborType(_peer, NULL) == PEER_SIBLING && ...
+          if (neighborType(_peer, URL()) == PEER_SIBLING && ...
           or better:
           if (((_peer->type == PEER_MULTICAST && p->options.mcast_siblings) ||
                  _peer->type == PEER_SIBLINGS ) && _peer->options.allow_miss)
                flags.only_if_cached = 1;
 
            But I suppose it was a bug
          */
-        if (neighborType(_peer, request) == PEER_SIBLING &&
-                !_peer->options.allow_miss)
+        if (neighborType(_peer, request->url) == PEER_SIBLING && !_peer->options.allow_miss)
             flags.only_if_cached = true;
 
         flags.front_end_https = _peer->front_end_https;
@@ -2319,9 +2292,9 @@ HttpStateData::getMoreRequestBody(MemBuf &buf)
     // we may need to send: hex-chunk-size CRLF raw-data CRLF last-chunk
     buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);
 
-    buf.Printf("%x\r\n", static_cast<unsigned int>(rawDataSize));
+    buf.appendf("%x\r\n", static_cast<unsigned int>(rawDataSize));
     buf.append(raw.content(), rawDataSize);
-    buf.Printf("\r\n");
+    buf.append("\r\n", 2);
 
     Must(rawDataSize > 0); // we did not accidently created last-chunk above
 
@@ -11,9 +11,9 @@
 
 #include "clients/Client.h"
 #include "comm.h"
+#include "http/forward.h"
 #include "HttpStateFlags.h"
 
-class ChunkedCodingParser;
 class FwdState;
 class HttpHeader;
 
@@ -120,7 +120,7 @@ class HttpStateData : public Client
 
     /// Parser being used at present to parse the HTTP/ICY server response.
     Http1::ResponseParserPointer hp;
-    ChunkedCodingParser *httpChunkDecoder;
+    Http1::TeChunkedParser *httpChunkDecoder;
 
     /// amount of message payload/body received so far.
     int64_t payloadSeen;
@@ -9,9 +9,9 @@
 /* DEBUG: section 57    HTTP Status-line */
 
 #include "squid.h"
+#include "base/Packable.h"
 #include "Debug.h"
 #include "http/StatusLine.h"
-#include "Packer.h"
 
 void
 Http::StatusLine::init()
@@ -43,7 +43,7 @@ Http::StatusLine::reason() const
 }
 
 void
-Http::StatusLine::packInto(Packer * p) const
+Http::StatusLine::packInto(Packable * p) const
 {
     assert(p);
 
@@ -57,14 +57,14 @@ Http::StatusLine::packInto(Packer * p) const
         debugs(57, 9, "packing sline " << this << " using " << p << ":");
         debugs(57, 9, "FORMAT=" << IcyStatusLineFormat );
         debugs(57, 9, "ICY " << status() << " " << reason());
-        packerPrintf(p, IcyStatusLineFormat, status(), reason());
+        p->appendf(IcyStatusLineFormat, status(), reason());
         return;
     }
 
     debugs(57, 9, "packing sline " << this << " using " << p << ":");
     debugs(57, 9, "FORMAT=" << Http1StatusLineFormat );
     debugs(57, 9, "HTTP/" << version.major << "." << version.minor << " " << status() << " " << reason());
-    packerPrintf(p, Http1StatusLineFormat, version.major, version.minor, status(), reason());
+    p->appendf(Http1StatusLineFormat, version.major, version.minor, status(), reason());
 }
 
 /*
@@ -13,7 +13,7 @@
 #include "http/StatusCode.h"
 #include "SquidString.h"
 
-class Packer;
+class Packable;
 class String;
 
 namespace Http
@@ -43,8 +43,8 @@ class StatusLine
     /// retrieve the reason string for this status line
     const char *reason() const;
 
-    /// pack fields using Packer
-    void packInto(Packer * p) const;
+    /// pack fields into a Packable object
+    void packInto(Packable *) const;
 
     /**
      * Parse a buffer and fill internal structures;
@@ -17,4 +17,8 @@ libhttp1_la_SOURCES = \
 	RequestParser.cc \
 	RequestParser.h \
 	ResponseParser.cc \
-	ResponseParser.h
+	ResponseParser.h \
+	TeChunkedParser.cc \
+	TeChunkedParser.h \
+	Tokenizer.cc \
+	Tokenizer.h
@@ -9,8 +9,8 @@
 #include "squid.h"
 #include "Debug.h"
 #include "http/one/Parser.h"
+#include "http/one/Tokenizer.h"
 #include "mime_header.h"
-#include "parser/Tokenizer.h"
 #include "SquidConfig.h"
 
 /// RFC 7230 section 2.6 - 7 magic octets
@@ -26,7 +26,7 @@ Http::One::Parser::clear()
 }
 
 bool
-Http::One::Parser::skipLineTerminator(::Parser::Tokenizer &tok) const
+Http::One::Parser::skipLineTerminator(Http1::Tokenizer &tok) const
 {
     static const SBuf crlf("\r\n");
     if (tok.skip(crlf))
@@ -43,7 +43,8 @@ Http::One::Parser::grabMimeBlock(const char *which, const size_t limit)
 {
     // MIME headers block exist in (only) HTTP/1.x and ICY
     const bool expectMime = (msgProtocol_.protocol == AnyP::PROTO_HTTP && msgProtocol_.major == 1) ||
-                            msgProtocol_.protocol == AnyP::PROTO_ICY;
+                            msgProtocol_.protocol == AnyP::PROTO_ICY ||
+                            hackExpectsMime_;
 
     if (expectMime) {
         /* NOTE: HTTP/0.9 messages do not have a mime header block.
@@ -102,7 +103,7 @@ Http::One::Parser::getHeaderField(const char *name)
 
     // while we can find more LF in the SBuf
     static CharacterSet iso8859Line = CharacterSet("non-LF",'\0','\n'-1) + CharacterSet(NULL, '\n'+1, (unsigned char)0xFF);
-    ::Parser::Tokenizer tok(mimeHeaderBlock_);
+    Http1::Tokenizer tok(mimeHeaderBlock_);
     SBuf p;
     static const SBuf crlf("\r\n");
 
@@ -125,7 +126,7 @@ Http::One::Parser::getHeaderField(const char *name)
         p.consume(namelen + 1);
 
         // TODO: optimize SBuf::trim to take CharacterSet directly
-        ::Parser::Tokenizer t(p);
+        Http1::Tokenizer t(p);
         t.skipAll(CharacterSet::WSP);
         p = t.remaining();
 
@@ -14,19 +14,18 @@
 #include "http/StatusCode.h"
 #include "SBuf.h"
 
-namespace Parser {
-class Tokenizer;
-}
-
 namespace Http {
 namespace One {
 
 // Parser states
 enum ParseState {
-    HTTP_PARSE_NONE,     ///< initialized, but nothing usefully parsed yet
-    HTTP_PARSE_FIRST,    ///< HTTP/1 message first-line
-    HTTP_PARSE_MIME,     ///< HTTP/1 mime-header block
-    HTTP_PARSE_DONE      ///< parsed a message header, or reached a terminal syntax error
+    HTTP_PARSE_NONE,      ///< initialized, but nothing usefully parsed yet
+    HTTP_PARSE_FIRST,     ///< HTTP/1 message first-line
+    HTTP_PARSE_CHUNK_SZ,  ///< HTTP/1.1 chunked encoding chunk-size
+    HTTP_PARSE_CHUNK_EXT, ///< HTTP/1.1 chunked encoding chunk-ext
+    HTTP_PARSE_CHUNK,     ///< HTTP/1.1 chunked encoding chunk-data
+    HTTP_PARSE_MIME,      ///< HTTP/1 mime-header block
+    HTTP_PARSE_DONE       ///< parsed a message header, or reached a terminal syntax error
 };
 
 /** HTTP/1.x protocol parser
@@ -42,7 +41,7 @@ class Parser : public RefCountable
 public:
     typedef SBuf::size_type size_type;
 
-    Parser() : parseStatusCode(Http::scNone), parsingStage_(HTTP_PARSE_NONE) {}
+    Parser() : parseStatusCode(Http::scNone), parsingStage_(HTTP_PARSE_NONE), hackExpectsMime_(false) {}
     virtual ~Parser() {}
 
     /// Set this parser back to a default state.
@@ -105,7 +104,7 @@ class Parser : public RefCountable
 protected:
     /// detect and skip the CRLF or (if tolerant) LF line terminator
     /// consume from the tokenizer and return true only if found
-    bool skipLineTerminator(::Parser::Tokenizer &tok) const;
+    bool skipLineTerminator(Http1::Tokenizer &tok) const;
 
     /**
      * Scan to find the mime headers block for current message.
@@ -132,6 +131,9 @@ class Parser : public RefCountable
 
     /// buffer holding the mime headers (if any)
     SBuf mimeHeaderBlock_;
+
+    /// Whether the invalid HTTP as HTTP/0.9 hack expects a mime header block
+    bool hackExpectsMime_;
 };
 
 } // namespace One
@@ -9,8 +9,8 @@
 #include "squid.h"
 #include "Debug.h"
 #include "http/one/RequestParser.h"
+#include "http/one/Tokenizer.h"
 #include "http/ProtocolVersion.h"
-#include "parser/Tokenizer.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
@@ -72,7 +72,7 @@ Http::One::RequestParser::skipGarbageLines()
  * \retval  0  more data is needed to complete the parse
  */
 int
-Http::One::RequestParser::parseMethodField(::Parser::Tokenizer &tok, const CharacterSet &WspDelim)
+Http::One::RequestParser::parseMethodField(Http1::Tokenizer &tok, const CharacterSet &WspDelim)
 {
     // scan for up to 16 valid method characters.
     static const size_t maxMethodLength = 16; // TODO: make this configurable?
@@ -132,7 +132,7 @@ uriValidCharacters()
 }
 
 int
-Http::One::RequestParser::parseUriField(::Parser::Tokenizer &tok)
+Http::One::RequestParser::parseUriField(Http1::Tokenizer &tok)
 {
     // URI field is a sequence of ... what? segments all have different valid charset
     // go with non-whitespace non-binary characters for now
@@ -187,7 +187,7 @@ Http::One::RequestParser::parseUriField(::Parser::Tokenizer &tok)
 }
 
 int
-Http::One::RequestParser::parseHttpVersionField(::Parser::Tokenizer &tok)
+Http::One::RequestParser::parseHttpVersionField(Http1::Tokenizer &tok)
 {
     // partial match of HTTP/1 magic prefix
     if (tok.remaining().length() < Http1magic.length() && Http1magic.startsWith(tok.remaining())) {
@@ -246,7 +246,7 @@ Http::One::RequestParser::parseHttpVersionField(::Parser::Tokenizer &tok)
 int
 Http::One::RequestParser::parseRequestFirstLine()
 {
-    ::Parser::Tokenizer tok(buf_);
+    Http1::Tokenizer tok(buf_);
 
     debugs(74, 5, "parsing possible request: buf.length=" << buf_.length());
     debugs(74, DBG_DATA, buf_);
@@ -261,6 +261,7 @@ Http::One::RequestParser::parseRequestFirstLine()
         WspDelim += CharacterSet::HTAB
                     + CharacterSet("VT,FF","\x0B\x0C")
                     + CharacterSet::CR;
+        debugs(74, 5, "using Parser relaxed WSP characters");
     }
 
     // only search for method if we have not yet found one
@@ -288,6 +289,8 @@ Http::One::RequestParser::parseRequestFirstLine()
     if (Config.onoff.relaxed_header_parser) {
         // whitespace tolerant
 
+        int warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
+
         // NOTES:
         // * this would be static, except WspDelim changes with reconfigure
         // * HTTP-version charset is included by uriValidCharacters()
@@ -297,15 +300,15 @@ Http::One::RequestParser::parseRequestFirstLine()
         // seek the LF character, then tokenize the line in reverse
         SBuf line;
         if (tok.prefix(line, LfDelim) && tok.skip('\n')) {
-            ::Parser::Tokenizer rTok(line);
+            Http1::Tokenizer rTok(line);
             SBuf nil;
             (void)rTok.suffix(nil,CharacterSet::CR); // optional CR in terminator
             SBuf digit;
             if (rTok.suffix(digit,CharacterSet::DIGIT) && rTok.skipSuffix(Http1magic) && rTok.suffix(nil,WspDelim)) {
                 uri_ = rTok.remaining();
                 msgProtocol_ = Http::ProtocolVersion(1, (*digit.rawContent() - '0'));
                 if (uri_.isEmpty()) {
-                    debugs(33, 5, "invalid request-line. missing URL");
+                    debugs(33, warnOnError, "invalid request-line. missing URL");
                     parseStatusCode = Http::scBadRequest;
                     return -1;
                 }
@@ -325,11 +328,77 @@ Http::One::RequestParser::parseRequestFirstLine()
                 return 1;
             }
 
-            debugs(33, 5, "invalid request-line. not HTTP");
+            debugs(33, warnOnError, "invalid request-line. not HTTP");
             parseStatusCode = Http::scBadRequest;
             return -1;
         }
 
+        if (!tok.atEnd()) {
+
+#if USE_HTTP_VIOLATIONS
+            /*
+             * RFC 3986 explicitly lists the characters permitted in URI.
+             * A non-permitted character was found somewhere in the request-line.
+             * However, as long as we can find the LF, accept the characters
+             * which we know are invalid in any URI but actively used.
+             */
+            LfDelim.add('\0'); // Java
+            LfDelim.add(' ');  // IIS
+            LfDelim.add('\"'); // Bing
+            LfDelim.add('\\'); // MSIE, Firefox
+            LfDelim.add('|');  // Amazon
+            LfDelim.add('^');  // Microsoft News
+
+            // other ASCII characters for which RFC 2396 has explicitly disallowed use
+            // since 1998 and which were not later permitted by RFC 3986 in 2005.
+            LfDelim.add('<');  // HTML embedded in URL
+            LfDelim.add('>');  // HTML embedded in URL
+            LfDelim.add('`');  // Shell Script embedded in URL
+            LfDelim.add('{');  // JSON or Javascript embedded in URL
+            LfDelim.add('}');  // JSON or Javascript embedded in URL
+
+            // reset the tokenizer from anything the above did, then seek the LF character.
+            tok.reset(buf_);
+
+            if (tok.prefix(line, LfDelim) && tok.skip('\n')) {
+
+                Http1::Tokenizer rTok(line);
+
+                // strip terminating CR (if any)
+                SBuf nil;
+                (void)rTok.suffix(nil,CharacterSet::CR); // optional CR in terminator
+                line = rTok.remaining();
+
+                // strip terminating 'WSP HTTP-version' (if any)
+                if (rTok.suffix(nil,CharacterSet::DIGIT) && rTok.skipSuffix(Http1magic) && rTok.suffix(nil,WspDelim)) {
+                    hackExpectsMime_ = true; // client thinks its speaking HTTP, probably sent a mime block.
+                    uri_ = rTok.remaining();
+                } else
+                    uri_ = line; // no HTTP/1.x label found. Use the whole line.
+
+                if (uri_.isEmpty()) {
+                    debugs(33, warnOnError, "invalid request-line. missing URL");
+                    parseStatusCode = Http::scBadRequest;
+                    return -1;
+                }
+
+                debugs(33, warnOnError, "invalid request-line. treating as HTTP/0.9" << (hackExpectsMime_?" (with mime)":""));
+                msgProtocol_ = Http::ProtocolVersion(0,9);
+                parseStatusCode = Http::scOkay;
+                buf_ = tok.remaining(); // incremental parse checkpoint
+                return 1;
+
+            } else if (tok.atEnd()) {
+                debugs(74, 5, "Parser needs more data");
+                return 0;
+            }
+            // else, drop back to invalid request-line handling
+#endif
+            const SBuf t = tok.remaining();
+            debugs(33, warnOnError, "invalid request-line characters." << Raw("data", t.rawContent(), t.length()));
+            parseStatusCode = Http::scBadRequest;
+            return -1;
+        }
         debugs(74, 5, "Parser needs more data");
         return 0;
     }
@@ -47,9 +47,9 @@ class RequestParser : public Http1::Parser
 private:
     void skipGarbageLines();
     int parseRequestFirstLine();
-    int parseMethodField(::Parser::Tokenizer &, const CharacterSet &);
-    int parseUriField(::Parser::Tokenizer &);
-    int parseHttpVersionField(::Parser::Tokenizer &);
+    int parseMethodField(Http1::Tokenizer &, const CharacterSet &);
+    int parseUriField(Http1::Tokenizer &);
+    int parseHttpVersionField(Http1::Tokenizer &);
 
     /// what request method has been found on the first line
     HttpRequestMethod method_;
@@ -9,8 +9,8 @@
 #include "squid.h"
 #include "Debug.h"
 #include "http/one/ResponseParser.h"
+#include "http/one/Tokenizer.h"
 #include "http/ProtocolVersion.h"
-#include "parser/Tokenizer.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
@@ -47,7 +47,7 @@ Http::One::ResponseParser::firstLineSize() const
 // NP: we found the protocol version and consumed it already.
 // just need the status code and reason phrase
 int
-Http::One::ResponseParser::parseResponseStatusAndReason(::Parser::Tokenizer &tok, const CharacterSet &WspDelim)
+Http::One::ResponseParser::parseResponseStatusAndReason(Http1::Tokenizer &tok, const CharacterSet &WspDelim)
 {
     if (!completedStatus_) {
         debugs(74, 9, "seek status-code in: " << tok.remaining().substr(0,10) << "...");
@@ -121,7 +121,7 @@ Http::One::ResponseParser::parseResponseStatusAndReason(::Parser::Tokenizer &tok
 int
 Http::One::ResponseParser::parseResponseFirstLine()
 {
-    ::Parser::Tokenizer tok(buf_);
+    Http1::Tokenizer tok(buf_);
 
     CharacterSet WspDelim = CharacterSet::SP; // strict parse only accepts SP
 
@@ -43,7 +43,7 @@ class ResponseParser : public Http1::Parser
 
 private:
     int parseResponseFirstLine();
-    int parseResponseStatusAndReason(::Parser::Tokenizer&, const CharacterSet &);
+    int parseResponseStatusAndReason(Http1::Tokenizer&, const CharacterSet &);
 
     /// magic prefix for identifying ICY response messages
     static const SBuf IcyMagic;
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "base/TextException.h"
+#include "Debug.h"
+#include "http/one/TeChunkedParser.h"
+#include "http/one/Tokenizer.h"
+#include "http/ProtocolVersion.h"
+#include "MemBuf.h"
+#include "Parsing.h"
+
+Http::One::TeChunkedParser::TeChunkedParser()
+{
+    // chunked encoding only exists in HTTP/1.1
+    Http1::Parser::msgProtocol_ = Http::ProtocolVersion(1,1);
+
+    clear();
+}
+
+void
+Http::One::TeChunkedParser::clear()
+{
+    parsingStage_ = Http1::HTTP_PARSE_NONE;
+    buf_.clear();
+    theChunkSize = theLeftBodySize = 0;
+    theOut = NULL;
+    useOriginBody = -1;
+}
+
+bool
+Http::One::TeChunkedParser::parse(const SBuf &aBuf)
+{
+    buf_ = aBuf; // sync buffers first so calls to remaining() work properly if nothing done.
+
+    if (buf_.isEmpty()) // nothing to do (yet)
+        return false;
+
+    debugs(74, DBG_DATA, "Parse buf={length=" << aBuf.length() << ", data='" << aBuf << "'}");
+
+    Must(!buf_.isEmpty() && theOut);
+
+    if (parsingStage_ == Http1::HTTP_PARSE_NONE)
+        parsingStage_ = Http1::HTTP_PARSE_CHUNK_SZ;
+
+    Http1::Tokenizer tok(buf_);
+
+    // loop for as many chunks as we can
+    // use do-while instead of while so that we can incrementally
+    // restart in the middle of a chunk/frame
+    do {
+
+        if (parsingStage_ == Http1::HTTP_PARSE_CHUNK_EXT && !parseChunkExtension(tok, theChunkSize))
+            return false;
+
+        if (parsingStage_ == Http1::HTTP_PARSE_CHUNK && !parseChunkBody(tok))
+            return false;
+
+        if (parsingStage_ == Http1::HTTP_PARSE_MIME && !grabMimeBlock("Trailers", 64*1024 /* 64KB max */))
+            return false;
+
+        // loop for as many chunks as we can
+    } while (parsingStage_ == Http1::HTTP_PARSE_CHUNK_SZ && parseChunkSize(tok));
+
+    return !needsMoreData() && !needsMoreSpace();
+}
+
+bool
+Http::One::TeChunkedParser::needsMoreSpace() const
+{
+    assert(theOut);
+    return parsingStage_ == Http1::HTTP_PARSE_CHUNK && !theOut->hasPotentialSpace();
+}
+
+/// RFC 7230 section 4.1 chunk-size
+bool
+Http::One::TeChunkedParser::parseChunkSize(Http1::Tokenizer &tok)
+{
+    Must(theChunkSize <= 0); // Should(), really
+
+    int64_t size = -1;
+    if (tok.int64(size, 16, false) && !tok.atEnd()) {
+        if (size < 0)
+            throw TexcHere("negative chunk size");
+
+        theChunkSize = theLeftBodySize = size;
+        debugs(94,7, "found chunk: " << theChunkSize);
+        buf_ = tok.remaining(); // parse checkpoint
+        parsingStage_ = Http1::HTTP_PARSE_CHUNK_EXT;
+        return true;
+
+    } else if (tok.atEnd()) {
+        return false; // need more data
+    }
+
+    // else error
+    throw TexcHere("corrupted chunk size");
+    return false; // should not be reachable
+}
+
+/**
+ * Parses a set of RFC 7230 section 4.1.1 chunk-ext
+ * http://tools.ietf.org/html/rfc7230#section-4.1.1
+ *
+ *   chunk-ext      = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
+ *   chunk-ext-name = token
+ *   chunk-ext-val  = token / quoted-string
+ *
+ * ICAP 'use-original-body=N' extension is supported.
+ */
+bool
+Http::One::TeChunkedParser::parseChunkExtension(Http1::Tokenizer &tok, bool skipKnown)
+{
+    SBuf ext;
+    SBuf value;
+    while (tok.skip(';') && tok.prefix(ext, CharacterSet::TCHAR)) {
+
+        // whole value part is optional. if no '=' expect next chunk-ext
+        if (tok.skip('=')) {
+
+            if (!skipKnown) {
+                if (ext.cmp("use-original-body",17) == 0 && tok.int64(useOriginBody, 10)) {
+                    debugs(94, 3, "Found chunk extension " << ext << "=" << useOriginBody);
+                    buf_ = tok.remaining(); // parse checkpoint
+                    continue;
+                }
+            }
+
+            debugs(94, 5, "skipping unknown chunk extension " << ext);
+
+            // unknown might have a value token or quoted-string
+            if (tok.quotedStringOrToken(value) && !tok.atEnd()) {
+                buf_ = tok.remaining(); // parse checkpoint
+                continue;
+            }
+
+            // otherwise need more data OR corrupt syntax
+            break;
+        }
+
+        if (!tok.atEnd())
+            buf_ = tok.remaining(); // parse checkpoint (unless there might be more token name)
+    }
+
+    if (tok.atEnd())
+        return false;
+
+    if (skipLineTerminator(tok)) {
+        buf_ = tok.remaining(); // checkpoint
+        // non-0 chunk means data, 0-size means optional Trailer follows
+        parsingStage_ = theChunkSize ? Http1::HTTP_PARSE_CHUNK : Http1::HTTP_PARSE_MIME;
+        return true;
+    }
+
+    throw TexcHere("corrupted chunk extension value");
+    return false;
+}
+
+bool
+Http::One::TeChunkedParser::parseChunkBody(Http1::Tokenizer &tok)
+{
+    Must(theLeftBodySize > 0); // Should, really
+
+    buf_ = tok.remaining(); // sync buffers before buf_ use
+
+    // TODO fix type mismatches and casting for these
+    const size_t availSize = min(theLeftBodySize, (uint64_t)buf_.length());
+    const size_t safeSize = min(availSize, (size_t)theOut->potentialSpaceSize());
+
+    theOut->append(buf_.rawContent(), safeSize);
+    buf_.consume(safeSize);
+    theLeftBodySize -= safeSize;
+
+    tok.reset(buf_); // sync buffers after consume()
+
+    if (theLeftBodySize == 0)
+        return parseChunkEnd(tok);
+    else
+        Must(needsMoreData() || needsMoreSpace());
+
+    return true;
+}
+
+bool
+Http::One::TeChunkedParser::parseChunkEnd(Http1::Tokenizer &tok)
+{
+    Must(theLeftBodySize == 0); // Should(), really
+
+    if (skipLineTerminator(tok)) {
+        buf_ = tok.remaining(); // parse checkpoint
+        theChunkSize = 0; // done with the current chunk
+        parsingStage_ = Http1::HTTP_PARSE_CHUNK_SZ;
+        return true;
+
+    } else if (!tok.atEnd()) {
+        throw TexcHere("found data between chunk end and CRLF");
+    }
+
+    return false;
+}
+
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_HTTP_ONE_TeChunkedParser_H
+#define SQUID_SRC_HTTP_ONE_TeChunkedParser_H
+
+#include "http/one/Parser.h"
+
+class MemBuf;
+
+namespace Http
+{
+namespace One
+{
+
+/**
+ * An incremental parser for chunked transfer coding
+ * defined in RFC 7230 section 4.1.
+ * http://tools.ietf.org/html/rfc7230#section-4.1
+ *
+ * The parser shovels content bytes from the raw
+ * input buffer into the content output buffer, both caller-supplied.
+ * Ignores chunk extensions except for ICAP's ieof.
+ * Trailers are available via mimeHeader() if wanted.
+ */
+class TeChunkedParser : public Http1::Parser
+{
+public:
+    TeChunkedParser();
+    virtual ~TeChunkedParser() {theOut=NULL;/* we dont own this object */}
+
+    /// set the buffer to be used to store decoded chunk data
+    void setPayloadBuffer(MemBuf *parsedContent) {theOut = parsedContent;}
+
+    bool needsMoreSpace() const;
+
+    /* Http1::Parser API */
+    virtual void clear();
+    virtual bool parse(const SBuf &);
+    virtual Parser::size_type firstLineSize() const {return 0;} // has no meaning with multiple chunks
+
+private:
+    bool parseChunkSize(Http1::Tokenizer &tok);
+    bool parseChunkExtension(Http1::Tokenizer &tok, bool skipKnown);
+    bool parseChunkBody(Http1::Tokenizer &tok);
+    bool parseChunkEnd(Http1::Tokenizer &tok);
+
+    MemBuf *theOut;
+    uint64_t theChunkSize;
+    uint64_t theLeftBodySize;
+
+public:
+    int64_t useOriginBody;
+};
+
+} // namespace One
+} // namespace Http
+
+#endif /* SQUID_SRC_HTTP_ONE_TeChunkedParser_H */
+
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "Debug.h"
+#include "http/one/Tokenizer.h"
+
+bool
+Http::One::Tokenizer::quotedString(SBuf &returnedToken, const bool http1p0)
+{
+    checkpoint();
+
+    if (!skip('"'))
+        return false;
+
+    return qdText(returnedToken, http1p0);
+}
+
+bool
+Http::One::Tokenizer::quotedStringOrToken(SBuf &returnedToken, const bool http1p0)
+{
+    checkpoint();
+
+    if (!skip('"'))
+        return prefix(returnedToken, CharacterSet::TCHAR);
+
+    return qdText(returnedToken, http1p0);
+}
+
+bool
+Http::One::Tokenizer::qdText(SBuf &returnedToken, const bool http1p0)
+{
+    // the initial DQUOTE has been skipped by the caller
+
+    /*
+     * RFC 1945 - defines qdtext:
+     *   inclusive of LWS (which includes CR and LF)
+     *   exclusive of 0x80-0xFF
+     *   includes 0x5C ('\') as just a regular character
+     */
+    static const CharacterSet qdtext1p0 = CharacterSet("qdtext (HTTP/1.0)", 0x23, 0x7E) +
+                                          CharacterSet("", "!") +
+                                          CharacterSet::CR + CharacterSet::LF + CharacterSet::HTAB + CharacterSet::SP;
+    /*
+     * RFC 7230 - defines qdtext:
+     *   exclusive of CR and LF
+     *   inclusive of 0x80-0xFF
+     *   includes 0x5C ('\') but only when part of quoted-pair
+     */
+    static const CharacterSet qdtext1p1 = CharacterSet("qdtext (HTTP/1.1)", 0x23, 0x5B) +
+                                          CharacterSet("", "!") +
+                                          CharacterSet("", 0x5D, 0x7E) +
+                                          CharacterSet::HTAB + CharacterSet::SP +
+                                          CharacterSet::OBSTEXT;
+
+    // best we can do is a conditional reference since http1p0 value may change per-client
+    const CharacterSet &tokenChars = (http1p0 ? qdtext1p0 : qdtext1p1);
+
+    for (;;) {
+        SBuf::size_type prefixLen = buf().findFirstNotOf(tokenChars);
+        returnedToken.append(consume(prefixLen));
+
+        // HTTP/1.1 allows quoted-pair, HTTP/1.0 does not
+        if (!http1p0 && skip('\\')) {
+            /* RFC 7230 section 3.2.6
+             *
+             * The backslash octet ("\") can be used as a single-octet quoting
+             * mechanism within quoted-string and comment constructs.  Recipients
+             * that process the value of a quoted-string MUST handle a quoted-pair
+             * as if it were replaced by the octet following the backslash.
+             *
+             *   quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
+             */
+            static const CharacterSet qPairChars = CharacterSet::HTAB + CharacterSet::SP + CharacterSet::VCHAR + CharacterSet::OBSTEXT;
+            SBuf escaped;
+            if (!prefix(escaped, qPairChars, 1)) {
+                returnedToken.clear();
+                restoreLastCheckpoint();
+                return false;
+            }
+            returnedToken.append(escaped);
+            continue;
+
+        } else if (skip('"')) {
+            break; // done
+
+        } else if (atEnd()) {
+            // need more data
+            returnedToken.clear();
+            restoreLastCheckpoint();
+            return false;
+        }
+
+        // else, we have an error
+        debugs(24, 8, "invalid bytes for set " << tokenChars.name);
+        returnedToken.clear();
+        restoreLastCheckpoint();
+        return false;
+    }
+
+    // found the whole string
+    return true;
+}
+
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_HTTP_ONE_TOKENIZER_H
+#define SQUID_SRC_HTTP_ONE_TOKENIZER_H
+
+#include "parser/Tokenizer.h"
+
+namespace Http {
+namespace One {
+
+/**
+ * Lexical processor extended to tokenize HTTP/1.x syntax.
+ *
+ * \see ::Parser::Tokenizer for more detail
+ */
+class Tokenizer : public ::Parser::Tokenizer
+{
+public:
+    Tokenizer(SBuf &s) : ::Parser::Tokenizer(s), savedStats_(0) {}
+
+    /**
+     * Attempt to parse a quoted-string lexical construct.
+     *
+     * Governed by:
+     *  - RFC 1945 section 2.1
+     *  "
+     *    A string of text is parsed as a single word if it is quoted using
+     *    double-quote marks.
+     *
+     *        quoted-string  = ( <"> *(qdtext) <"> )
+     *
+     *        qdtext         = <any CHAR except <"> and CTLs,
+     *                         but including LWS>
+     *
+     *    Single-character quoting using the backslash ("\") character is not
+     *    permitted in HTTP/1.0.
+     *  "
+     *
+     *  - RFC 7230 section 3.2.6
+     *  "
+     *    A string of text is parsed as a single value if it is quoted using
+     *    double-quote marks.
+     *
+     *    quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
+     *    qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
+     *    obs-text       = %x80-FF
+     *  "
+     *
+     * \param escaped HTTP/1.0 does not permit \-escaped characters
+     */
+    bool quotedString(SBuf &value, const bool http1p0 = false);
+
+    /**
+     * Attempt to parse a (token / quoted-string ) lexical construct.
+     */
+    bool quotedStringOrToken(SBuf &value, const bool http1p0 = false);
+
+private:
+    /// parse the internal component of a quote-string, and terminal DQUOTE
+    bool qdText(SBuf &value, const bool http1p0);
+
+    void checkpoint() { savedCheckpoint_ = buf(); savedStats_ = parsedSize(); }
+    void restoreLastCheckpoint() { undoParse(savedCheckpoint_, savedStats_); }
+
+    SBuf savedCheckpoint_;
+    SBuf::size_type savedStats_;
+};
+
+} // namespace One
+} // namespace Http
+
+#endif /* SQUID_SRC_HTTP_ONE_TOKENIZER_H */
+
@@ -14,9 +14,13 @@
 namespace Http {
 namespace One {
 
+class Tokenizer;
+
 class Parser;
 typedef RefCount<Http::One::Parser> ParserPointer;
 
+class TeChunkedParser;
+
 class RequestParser;
 typedef RefCount<Http::One::RequestParser> RequestParserPointer;
 
@@ -1102,18 +1102,18 @@ netdbHostData(const char *host, int *samp, int *rtt, int *hops)
 }
 
 void
-netdbUpdatePeer(HttpRequest * r, CachePeer * e, int irtt, int ihops)
+netdbUpdatePeer(const URL &url, CachePeer * e, int irtt, int ihops)
 {
 #if USE_ICMP
     netdbEntry *n;
     double rtt = (double) irtt;
     double hops = (double) ihops;
     net_db_peer *p;
-    debugs(38, 3, "netdbUpdatePeer: '" << r->GetHost() << "', " << ihops << " hops, " << irtt << " rtt");
-    n = netdbLookupHost(r->GetHost());
+    debugs(38, 3, url.host() << ", " << ihops << " hops, " << irtt << " rtt");
+    n = netdbLookupHost(url.host());
 
     if (n == NULL) {
-        debugs(38, 3, "netdbUpdatePeer: host '" << r->GetHost() << "' not found");
+        debugs(38, 3, "host " << url.host() << " not found");
         return;
     }
 
@@ -1289,7 +1289,8 @@ netdbExchangeStart(void *data)
 {
 #if USE_ICMP
     CachePeer *p = (CachePeer *)data;
-    char *uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", "netdb");
+    static const SBuf netDB("netdb");
+    char *uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", netDB);
     debugs(38, 3, "netdbExchangeStart: Requesting '" << uri << "'");
     assert(NULL != uri);
     HttpRequest *req = HttpRequest::CreateFromUrl(uri);
@@ -1317,8 +1318,6 @@ netdbExchangeStart(void *data)
     if (p->login)
         ex->r->url.userInfo(SBuf(p->login));
 
-    urlCanonical(ex->r);
-
     FwdState::fwdStart(Comm::ConnectionPointer(), ex->e, ex->r);
 
 #endif
@@ -1333,11 +1332,11 @@ netdbClosestParent(HttpRequest * request)
     const ipcache_addrs *ia;
     net_db_peer *h;
     int i;
-    n = netdbLookupHost(request->GetHost());
+    n = netdbLookupHost(request->url.host());
 
     if (NULL == n) {
         /* try IP addr */
-        ia = ipcache_gethostbyname(request->GetHost(), 0);
+        ia = ipcache_gethostbyname(request->url.host(), 0);
 
         if (NULL != ia)
             n = netdbLookupAddr(ia->in_addrs[ia->cur]);
@@ -1368,7 +1367,7 @@ netdbClosestParent(HttpRequest * request)
         if (NULL == p)      /* not found */
             continue;
 
-        if (neighborType(p, request) != PEER_PARENT)
+        if (neighborType(p, request->url) != PEER_PARENT)
             continue;
 
         if (!peerHTTPOkay(p, request))  /* not allowed */
@@ -10,15 +10,13 @@
 #define ICMP_NET_DB_H
 
 #include "hash.h"
+#include "ip/forward.h"
 
 class CachePeer;
 class HttpRequest;
 class netdbEntry;
 class StoreEntry;
-namespace Ip
-{
-class Address;
-};
+class URL;
 
 // POD
 class net_db_name
@@ -67,7 +65,7 @@ void netdbDump(StoreEntry *);
 void netdbFreeMemory(void);
 int netdbHostHops(const char *host);
 int netdbHostRtt(const char *host);
-void netdbUpdatePeer(HttpRequest *, CachePeer * e, int rtt, int hops);
+void netdbUpdatePeer(const URL &, CachePeer * e, int rtt, int hops);
 
 void netdbDeleteAddrNetwork(Ip::Address &addr);
 void netdbBinaryExchange(StoreEntry *);
@@ -51,7 +51,7 @@
 static void icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo);
 
 /// \ingroup ServerProtocolICPInternal2
-static void icpLogIcp(const Ip::Address &, LogTags, int, const char *, int);
+static void icpLogIcp(const Ip::Address &, const LogTags &, int, const char *, int);
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpHandleIcpV2(int, Ip::Address &, char *, int);
@@ -159,8 +159,8 @@ ICP2State::created(StoreEntry *newEntry)
     } else {
 #if USE_ICMP
         if (Config.onoff.test_reachability && rtt == 0) {
-            if ((rtt = netdbHostRtt(request->GetHost())) == 0)
-                netdbPingSite(request->GetHost());
+            if ((rtt = netdbHostRtt(request->url.host())) == 0)
+                netdbPingSite(request->url.host());
         }
 #endif /* USE_ICMP */
 
@@ -180,14 +180,14 @@ ICP2State::created(StoreEntry *newEntry)
 
 /// \ingroup ServerProtocolICPInternal2
 static void
-icpLogIcp(const Ip::Address &caddr, LogTags logcode, int len, const char *url, int delay)
+icpLogIcp(const Ip::Address &caddr, const LogTags &logcode, int len, const char *url, int delay)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry();
 
-    if (LOG_TAG_NONE == logcode)
+    if (LOG_TAG_NONE == logcode.oldType)
         return;
 
-    if (LOG_ICP_QUERY == logcode)
+    if (LOG_ICP_QUERY == logcode.oldType)
         return;
 
     clientdbUpdate(caddr, logcode, AnyP::PROTO_ICP, len);
@@ -278,7 +278,7 @@ int
 icpUdpSend(int fd,
            const Ip::Address &to,
            icp_common_t * msg,
-           LogTags logcode,
+           const LogTags &logcode,
            int delay)
 {
     icpUdpData *queue;
@@ -470,8 +470,8 @@ doV2Query(int fd, Ip::Address &from, char *buf, icp_common_t header)
     }
 #if USE_ICMP
     if (header.flags & ICP_FLAG_SRC_RTT) {
-        rtt = netdbHostRtt(icp_request->GetHost());
-        int hops = netdbHostHops(icp_request->GetHost());
+        rtt = netdbHostRtt(icp_request->url.host());
+        int hops = netdbHostHops(icp_request->url.host());
         src_rtt = ((hops & 0xFFFF) << 16) | (rtt & 0xFFFF);
 
         if (rtt)
@@ -264,7 +264,7 @@ Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
 
     // build our query from the original connection details
     state->queryMsg.init();
-    state->queryMsg.Printf("%d, %d\r\n", conn->remote.port(), conn->local.port());
+    state->queryMsg.appendf("%d, %d\r\n", conn->remote.port(), conn->local.port());
 
     ClientAdd(state, callback, data);
     hash_join(ident_hash, &state->hash);
@@ -32,12 +32,16 @@ void
 internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request, StoreEntry * entry)
 {
     ErrorState *err;
-    const char *upath = request->urlpath.termedBuf();
-    debugs(76, 3, HERE << clientConn << " requesting '" << upath << "'");
+    const SBuf upath = request->url.path();
+    debugs(76, 3, clientConn << " requesting '" << upath << "'");
 
-    if (0 == strcmp(upath, "/squid-internal-dynamic/netdb")) {
+    static const SBuf netdbUri("/squid-internal-dynamic/netdb");
+    static const SBuf storeDigestUri("/squid-internal-periodic/store_digest");
+    static const SBuf mgrPfx("/squid-internal-mgr/");
+
+    if (upath == netdbUri) {
         netdbBinaryExchange(entry);
-    } else if (0 == strcmp(upath, "/squid-internal-periodic/store_digest")) {
+    } else if (upath == storeDigestUri) {
 #if USE_CACHE_DIGESTS
         const char *msgbuf = "This cache is currently building its digest.\n";
 #else
@@ -50,8 +54,8 @@ internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request,
         entry->replaceHttpReply(reply);
         entry->append(msgbuf, strlen(msgbuf));
         entry->complete();
-    } else if (0 == strncmp(upath, "/squid-internal-mgr/", 20)) {
-        debugs(17, 2, "calling CacheManager due to URL-path /squid-internal-mgr/");
+    } else if (upath.startsWith(mgrPfx)) {
+        debugs(17, 2, "calling CacheManager due to URL-path " << mgrPfx);
         CacheManager::GetInstance()->Start(clientConn, request, entry);
     } else {
         debugObj(76, 1, "internalStart: unknown request:\n",
@@ -61,26 +65,28 @@ internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request,
     }
 }
 
-int
-internalCheck(const char *urlpath)
+bool
+internalCheck(const SBuf &urlPath)
 {
-    return (0 == strncmp(urlpath, "/squid-internal-", 16));
+    static const SBuf InternalPfx("/squid-internal-");
+    return urlPath.startsWith(InternalPfx);
 }
 
-int
-internalStaticCheck(const char *urlpath)
+bool
+internalStaticCheck(const SBuf &urlPath)
 {
-    return (0 == strncmp(urlpath, "/squid-internal-static", 22));
+    static const SBuf InternalStaticPfx("/squid-internal-static");
+    return urlPath.startsWith(InternalStaticPfx);
 }
 
 /*
  * makes internal url with a given host and port (remote internal url)
  */
 char *
-internalRemoteUri(const char *host, unsigned short port, const char *dir, const char *name)
+internalRemoteUri(const char *host, unsigned short port, const char *dir, const SBuf &name)
 {
     static char lc_host[SQUIDHOSTNAMELEN];
-    assert(host && name);
+    assert(host && !name.isEmpty());
     /* convert host name to lower case */
     xstrncpy(lc_host, host, SQUIDHOSTNAMELEN);
     Tolower(lc_host);
@@ -101,21 +107,21 @@ internalRemoteUri(const char *host, unsigned short port, const char *dir, const
         strncat(lc_host, Config.appendDomain, SQUIDHOSTNAMELEN -
                 strlen(lc_host) - 1);
 
-    /* build uri in mb */
+    /* build URI */
+    URL tmp(AnyP::PROTO_HTTP);
+    tmp.host(lc_host);
+    if (port)
+        tmp.port(port);
+
     static MemBuf mb;
 
     mb.reset();
-
-    mb.Printf("http://%s", lc_host);
-
-    /* append port if not default */
-    if (port && port != urlDefaultPort(AnyP::PROTO_HTTP))
-        mb.Printf(":%d", port);
+    mb.appendf("http://" SQUIDSBUFPH, SQUIDSBUFPRINT(tmp.authority()));
 
     if (dir)
-        mb.Printf("%s", dir);
+        mb.append(dir, strlen(dir));
 
-    mb.Printf("%s", name);
+    mb.append(name.rawContent(), name.length());
 
     /* return a pointer to a local static buffer */
     return mb.buf;
@@ -125,7 +131,7 @@ internalRemoteUri(const char *host, unsigned short port, const char *dir, const
  * makes internal url with local host and port
  */
 char *
-internalLocalUri(const char *dir, const char *name)
+internalLocalUri(const char *dir, const SBuf &name)
 {
     return internalRemoteUri(getMyHostname(),
                              getMyPort(), dir, name);
@@ -15,14 +15,16 @@
 #define SQUID_INTERNAL_H_
 
 #include "comm/forward.h"
+
 class HttpRequest;
+class SBuf;
 class StoreEntry;
 
 void internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest *, StoreEntry *);
-int internalCheck(const char *urlpath);
-int internalStaticCheck(const char *urlpath);
-char *internalLocalUri(const char *dir, const char *name);
-char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
+bool internalCheck(const SBuf &urlPath);
+bool internalStaticCheck(const SBuf &urlPath);
+char *internalLocalUri(const char *dir, const SBuf &name);
+char *internalRemoteUri(const char *, unsigned short, const char *, const SBuf &);
 const char *internalHostname(void);
 int internalHostnameIs(const char *);
 
@@ -30,7 +30,6 @@ int Ip::EnableIpv6 = IPV6_OFF;
 void
 Ip::ProbeTransport()
 {
-#if USE_IPV6
     // check for usable IPv6 sockets
     int s = socket(PF_INET6, SOCK_STREAM, 0);
     if (s < 0) {
@@ -56,12 +55,18 @@ Ip::ProbeTransport()
     debugs(3, 2, "Missing RFC 3493 compliance - attempting split IPv4 and IPv6 stacks ...");
     EnableIpv6 |= IPV6_SPECIAL_SPLITSTACK;
 #endif
+    // TODO: attempt to use the socket to connect somewhere ?
+    //  needs to be safe to contact and with guaranteed working IPv6 at the other end.
     close(s);
 
+#if USE_IPV6
     debugs(3, 2, "IPv6 transport " << (EnableIpv6?"Enabled":"Disabled"));
 #else
-    debugs(3, 2, "IPv6 transport forced OFF by build parameters.");
-    EnableIpv6 = IPV6_OFF;
+    debugs(3, 2, "IPv6 transport " << (EnableIpv6?"Available":"Disabled"));
+    if (EnableIpv6 != IPV6_OFF) {
+        debugs(3, DBG_CRITICAL, "WARNING: BCP 177 violation. IPv6 transport forced OFF by build parameters.");
+        EnableIpv6 = IPV6_OFF;
+    }
 #endif
 }
 
@@ -151,10 +151,23 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
             return -1;
         }
 
-        setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen));
-        setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen));
-        setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen));
-        setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen));
+        errno = 0;
+        if (setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1)  {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
+        if (setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
+        if (setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1) {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
+        if (setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
         fd_open(prfd = pwfd = fds[0], FD_PIPE, "IPC UNIX STREAM Parent");
         fd_open(crfd = cwfd = fds[1], FD_PIPE, "IPC UNIX STREAM Parent");
         IPC_CHECK_FAIL(crfd, "child read", "UDS socket");
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 54    Interprocess Communication */
-
-#include "squid.h"
-#include "ipc/AtomicWord.h"
-#include "tools.h"
-
-bool Ipc::Atomic::Enabled()
-{
-#if HAVE_ATOMIC_OPS
-    return true;
-#else
-    return !UsingSmp();
-#endif
-}
-
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_IPC_ATOMIC_WORD_H
-#define SQUID_IPC_ATOMIC_WORD_H
-
-namespace Ipc
-{
-
-namespace Atomic
-{
-
-/// Whether atomic operations support is available
-bool Enabled();
-
-#if HAVE_ATOMIC_OPS
-
-/// Supplies atomic operations for an integral Value in memory shared by kids.
-/// Used to implement non-blocking shared locks, queues, tables, and pools.
-template <class ValueType>
-class WordT
-{
-public:
-    typedef ValueType Value;
-
-    WordT() {} // leave value unchanged
-    WordT(Value aValue): value(aValue) {} // XXX: unsafe
-
-    Value operator +=(int delta) { return __sync_add_and_fetch(&value, delta); }
-    Value operator -=(int delta) { return __sync_sub_and_fetch(&value, delta); }
-    Value operator ++() { return *this += 1; }
-    Value operator --() { return *this -= 1; }
-    Value operator ++(int) { return __sync_fetch_and_add(&value, 1); }
-    Value operator --(int) { return __sync_fetch_and_sub(&value, 1); }
-
-    bool swap_if(const Value comparand, const Value replacement) { return __sync_bool_compare_and_swap(&value, comparand, replacement); }
-
-    /// v1 = value; value &= v2; return v1;
-    Value fetchAndAnd(const Value v2) { return __sync_fetch_and_and(&value, v2); }
-
-    // TODO: no need for __sync_bool_compare_and_swap here?
-    bool operator ==(const Value v2) { return __sync_bool_compare_and_swap(&value, v2, value); }
-
-    // TODO: no need for __sync_fetch_and_add here?
-    Value get() const { return __sync_fetch_and_add(const_cast<Value*>(&value), 0); }
-    operator Value () const { return get(); }
-
-private:
-
-    Value value;
-};
-
-#else
-
-/// A wrapper to provide AtomicWordT API (and implementation asserting in SMP mode)
-/// where we do not support atomic operations. This avoids ifdefs in core code.
-template <class ValueType>
-class WordT
-{
-public:
-    typedef ValueType Value;
-
-    WordT() {} // leave value unchanged
-    WordT(Value aValue): value(aValue) {} // XXX: unsafe
-
-    Value operator +=(int delta) { assert(Enabled()); return value += delta; }
-    Value operator ++() { return *this += 1; }
-    Value operator --() { return *this += -1; }
-    Value operator ++(int) { assert(Enabled()); return value++; }
-    Value operator --(int) { assert(Enabled()); return value--; }
-
-    bool swap_if(const Value comparand, const Value replacement)
-    { assert(Enabled()); return value == comparand ? value = replacement, true : false; }
-
-    /// v1 = value; value &= v2; return v1;
-    Value fetchAndAnd(const Value v2)
-    { assert(Enabled()); const Value v1 = value; value &= v2; return v1; }
-
-    // TODO: no need for __sync_bool_compare_and_swap here?
-    bool operator ==(const Value v2) { assert(Enabled()); return value == v2; }
-
-    // TODO: no need for __sync_fetch_and_add here?
-    Value get() const { assert(Enabled()); return value; }
-    operator Value () const { return get(); }
-
-private:
-
-    Value value;
-};
-
-#endif /* HAVE_ATOMIC_OPS */
-
-typedef WordT<int> Word;
-
-} // namespace Atomic
-
-} // namespace Ipc
-
-#endif // SQUID_IPC_ATOMIC_WORD_H
-
@@ -203,7 +203,7 @@ Ipc::Inquirer::status() const
 {
     static MemBuf buf;
     buf.reset();
-    buf.Printf(" [request->requestId %u]", request->requestId);
+    buf.appendf(" [request->requestId %u]", request->requestId);
     buf.terminate();
     return buf.content();
 }
@@ -13,8 +13,6 @@ AUTOMAKE_OPTIONS = subdir-objects
 noinst_LTLIBRARIES = libipc.la
 
 libipc_la_SOURCES = \
-	AtomicWord.cc \
-	AtomicWord.h \
 	FdNotes.cc \
 	FdNotes.h \
 	Kid.cc \
@@ -17,6 +17,8 @@
 #include "tools.h"
 #include "typedefs.h"
 
+#include <atomic>
+
 namespace Ipc
 {
 
@@ -39,7 +41,7 @@ class MemMapSlot
     bool reading() const { return lock.readers; }
     bool writing() const { return lock.writing; }
 
-    Atomic::WordT<uint8_t> waitingToBeFreed; ///< may be accessed w/o a lock
+    std::atomic<uint8_t> waitingToBeFreed; ///< may be accessed w/o a lock
     mutable ReadWriteLock lock; ///< protects slot data below
     unsigned char key[MEMMAP_SLOT_KEY_SIZE]; ///< The entry key
     unsigned char p[MEMMAP_SLOT_DATA_SIZE]; ///< The memory block;
@@ -66,7 +68,7 @@ class MemMap
 
         const int limit; ///< maximum number of map slots
         const size_t extrasSize; ///< size of slot extra data
-        Atomic::Word count; ///< current number of map slots
+        std::atomic<int> count; ///< current number of map slots
         Ipc::Mem::FlexibleArray<Slot> slots; ///< storage
     };
 
@@ -44,7 +44,7 @@ ReadersId(String id)
 
 InstanceIdDefinitions(Ipc::QueueReader, "ipcQR");
 
-Ipc::QueueReader::QueueReader(): popBlocked(1), popSignal(0),
+Ipc::QueueReader::QueueReader(): popBlocked(true), popSignal(false),
     rateLimit(0), balance(0)
 {
     debugs(54, 7, HERE << "constructed " << id);
@@ -11,11 +11,12 @@
 
 #include "base/InstanceId.h"
 #include "Debug.h"
-#include "ipc/AtomicWord.h"
 #include "ipc/mem/FlexibleArray.h"
 #include "ipc/mem/Pointer.h"
 #include "util.h"
 
+#include <atomic>
+
 class String;
 
 namespace Ipc
@@ -29,31 +30,31 @@ class QueueReader
     QueueReader(); // the initial state is "blocked without a signal"
 
     /// whether the reader is waiting for a notification signal
-    bool blocked() const { return popBlocked == 1; }
+    bool blocked() const { return popBlocked.load(); }
 
     /// marks the reader as blocked, waiting for a notification signal
-    void block() { popBlocked.swap_if(0, 1); }
+    void block() { popBlocked.store(true); }
 
     /// removes the block() effects
-    void unblock() { popBlocked.swap_if(1, 0); }
+    void unblock() { popBlocked.store(false); }
 
     /// if reader is blocked and not notified, marks the notification signal
     /// as sent and not received, returning true; otherwise, returns false
-    bool raiseSignal() { return blocked() && popSignal.swap_if(0,1); }
+    bool raiseSignal() { return blocked() && !popSignal.exchange(true); }
 
     /// marks sent reader notification as received (also removes pop blocking)
-    void clearSignal() { unblock(); popSignal.swap_if(1,0); }
+    void clearSignal() { unblock(); popSignal.store(false); }
 
 private:
-    Atomic::Word popBlocked; ///< whether the reader is blocked on pop()
-    Atomic::Word popSignal; ///< whether writer has sent and reader has not received notification
+    std::atomic<bool> popBlocked; ///< whether the reader is blocked on pop()
+    std::atomic<bool> popSignal; ///< whether writer has sent and reader has not received notification
 
 public:
-    typedef Atomic::Word Rate; ///< pop()s per second
+    typedef std::atomic<int> Rate; ///< pop()s per second
     Rate rateLimit; ///< pop()s per second limit if positive
 
     // we need a signed atomic type because balance may get negative
-    typedef Atomic::WordT<int> AtomicSignedMsec;
+    typedef std::atomic<int> AtomicSignedMsec;
     typedef AtomicSignedMsec Balance;
     /// how far ahead the reader is compared to a perfect read/sec event rate
     Balance balance;
@@ -118,9 +119,9 @@ class OneToOneUniQueue
     unsigned int theIn; ///< input index, used only in push()
     unsigned int theOut; ///< output index, used only in pop()
 
-    Atomic::Word theSize; ///< number of items in the queue
+    std::atomic<uint32_t> theSize; ///< number of items in the queue
     const unsigned int theMaxItemSize; ///< maximum item size
-    const int theCapacity; ///< maximum number of items, i.e. theBuffer size
+    const uint32_t theCapacity; ///< maximum number of items, i.e. theBuffer size
 
     char theBuffer[];
 };
@@ -9,7 +9,7 @@
 #ifndef SQUID_IPC_READ_WRITE_LOCK_H
 #define SQUID_IPC_READ_WRITE_LOCK_H
 
-#include "ipc/AtomicWord.h"
+#include <atomic>
 
 class StoreEntry;
 
@@ -25,7 +25,8 @@ class ReadWriteLockStats;
 class ReadWriteLock
 {
 public:
-    // default constructor is OK because of shared memory zero-initialization
+    ReadWriteLock() : readers(0), writing(false), appending(false), readLevel(0), writeLevel(0)
+    {}
 
     bool lockShared(); ///< lock for reading or return false
     bool lockExclusive(); ///< lock for modification or return false
@@ -39,13 +40,13 @@ class ReadWriteLock
     void updateStats(ReadWriteLockStats &stats) const;
 
 public:
-    mutable Atomic::Word readers; ///< number of reading users
-    Atomic::Word writing; ///< there is a writing user (there can be at most 1)
-    Atomic::Word appending; ///< the writer has promissed to only append
+    mutable std::atomic<uint32_t> readers; ///< number of reading users
+    std::atomic<bool> writing; ///< there is a writing user (there can be at most 1)
+    std::atomic<bool> appending; ///< the writer has promissed to only append
 
 private:
-    mutable Atomic::Word readLevel; ///< number of users reading (or trying to)
-    Atomic::Word writeLevel; ///< number of users writing (or trying to write)
+    mutable std::atomic<uint32_t> readLevel; ///< number of users reading (or trying to)
+    std::atomic<uint32_t> writeLevel; ///< number of users writing (or trying to write)
 };
 
 /// approximate stats of a set of ReadWriteLocks
@@ -28,9 +28,19 @@ class StoreMapSlice
     typedef uint32_t Size;
 
     StoreMapSlice(): size(0), next(-1) {}
-
-    Atomic::WordT<Size> size; ///< slice contents size
-    Atomic::WordT<StoreMapSliceId> next; ///< ID of the next entry slice
+    StoreMapSlice(const StoreMapSlice &o) {
+        size.exchange(o.size);
+        next.exchange(o.next);
+    }
+
+    StoreMapSlice &operator =(const StoreMapSlice &o) {
+        size.store(o.size);
+        next.store(o.next);
+        return *this;
+    }
+
+    std::atomic<Size> size; ///< slice contents size
+    std::atomic<StoreMapSliceId> next; ///< ID of the next entry slice
 };
 
 /// Maintains shareable information about a StoreEntry as a whole.
@@ -60,7 +70,7 @@ class StoreMapAnchor
 
 public:
     mutable ReadWriteLock lock; ///< protects slot data below
-    Atomic::WordT<uint8_t> waitingToBeFreed; ///< may be accessed w/o a lock
+    std::atomic<uint8_t> waitingToBeFreed; ///< may be accessed w/o a lock
 
     // fields marked with [app] can be modified when appending-while-reading
 
@@ -72,13 +82,13 @@ class StoreMapAnchor
         time_t lastref;
         time_t expires;
         time_t lastmod;
-        Atomic::WordT<uint64_t> swap_file_sz; // [app]
+        std::atomic<uint64_t> swap_file_sz; // [app]
         uint16_t refcount;
         uint16_t flags;
     } basics;
 
     /// where the chain of StoreEntry slices begins [app]
-    Atomic::WordT<StoreMapSliceId> start;
+    std::atomic<StoreMapSliceId> start;
 };
 
 /// an array of shareable Items
@@ -114,8 +124,8 @@ class StoreMapAnchors
     size_t sharedMemorySize() const;
     static size_t SharedMemorySize(const int anAnchorLimit);
 
-    Atomic::Word count; ///< current number of entries
-    Atomic::WordT<uint32_t> victim; ///< starting point for purge search
+    std::atomic<int32_t> count; ///< current number of entries
+    std::atomic<uint32_t> victim; ///< starting point for purge search
     const int capacity; ///< total number of anchors
     Ipc::Mem::FlexibleArray<StoreMapAnchor> items; ///< anchors storage
 };
@@ -25,7 +25,7 @@
 #include "mgr/Request.h"
 #include "mgr/Response.h"
 #include "SwapDir.h" /* XXX: scope boundary violation */
-#if USE_DISKIO_IPCIO
+#if HAVE_DISKIO_MODULE_IPCIO
 #include "DiskIO/IpcIo/IpcIoFile.h" /* XXX: scope boundary violation */
 #endif
 #if SQUID_SNMP
@@ -73,15 +73,15 @@ void Ipc::Strand::receive(const TypedMsgHdr &message)
         SharedListenJoined(SharedListenResponse(message));
         break;
 
-#if USE_DISKIO_IPCIO
+#if HAVE_DISKIO_MODULE_IPCIO
     case mtStrandSearchResponse:
         IpcIoFile::HandleOpenResponse(StrandSearchResponse(message));
         break;
 
     case mtIpcIoNotification:
         IpcIoFile::HandleNotification(message);
         break;
-#endif /* USE_DISKIO_IPCIO */
+#endif /* HAVE_DISKIO_MODULE_IPCIO */
 
     case mtCacheMgrRequest: {
         const Mgr::Request req(message);
@@ -26,7 +26,7 @@ Ipc::Mem::PagePool::Init(const char *const id, const unsigned int capacity, cons
 
 Ipc::Mem::PagePool::PagePool(const char *const id):
     pageIndex(shm_old(PageStack)(id)),
-    theLevels(reinterpret_cast<Atomic::Word *>(
+    theLevels(reinterpret_cast<Levels_t *>(
                   reinterpret_cast<char *>(pageIndex.getRaw()) +
                   pageIndex->stackSize())),
     theBuf(reinterpret_cast<char *>(theLevels + PageId::maxPurpose))
@@ -49,8 +49,9 @@ class PagePool
 
 private:
     Ipc::Mem::Pointer<PageStack> pageIndex; ///< free pages index
+    typedef std::atomic<size_t> Levels_t;
     /// number of shared memory pages used now for each purpose
-    Atomic::Word *const theLevels;
+    Levels_t * const theLevels;
     char *const theBuf; ///< pages storage
 };
 
@@ -46,16 +46,16 @@ Ipc::Mem::PageStack::pop(PageId &page)
 
     // find a Readable slot, starting with theLastReadable and going left
     while (theSize >= 0) {
-        const Offset idx = theLastReadable;
+        Offset idx = theLastReadable;
         // mark the slot at ids Writable while extracting its current value
-        const Value value = theItems[idx].fetchAndAnd(0); // works if Writable is 0
+        const Value value = theItems[idx].fetch_and(0); // works if Writable is 0
         const bool popped = value != Writable;
         // theItems[idx] is probably not Readable [any more]
 
         // Whether we popped a Readable value or not, we should try going left
         // to maintain the index (and make progress).
         // We may fail if others already updated the index, but that is OK.
-        theLastReadable.swap_if(idx, prev(idx)); // may fail or lie
+        theLastReadable.compare_exchange_weak(idx, prev(idx)); // may fail or lie
 
         if (popped) {
             // the slot we emptied may already be filled, but that is OK
@@ -83,14 +83,15 @@ Ipc::Mem::PageStack::push(PageId &page)
     Must(pageIdIsValid(page));
     // find a Writable slot, starting with theFirstWritable and going right
     while (theSize < theCapacity) {
-        const Offset idx = theFirstWritable;
-        const bool pushed = theItems[idx].swap_if(Writable, page.number);
+        Offset idx = theFirstWritable;
+        auto isWritable = Writable;
+        const bool pushed = theItems[idx].compare_exchange_strong(isWritable, page.number);
         // theItems[idx] is probably not Writable [any more];
 
         // Whether we pushed the page number or not, we should try going right
         // to maintain the index (and make progress).
         // We may fail if others already updated the index, but that is OK.
-        theFirstWritable.swap_if(idx, next(idx)); // may fail or lie
+        theFirstWritable.compare_exchange_weak(idx, next(idx)); // may fail or lie
 
         if (pushed) {
             // the enqueued value may already by gone, but that is OK
@@ -121,7 +122,7 @@ Ipc::Mem::PageStack::sharedMemorySize() const
 size_t
 Ipc::Mem::PageStack::SharedMemorySize(const uint32_t, const unsigned int capacity, const size_t pageSize)
 {
-    const size_t levelsSize = PageId::maxPurpose * sizeof(Atomic::Word);
+    const size_t levelsSize = PageId::maxPurpose * sizeof(std::atomic<Ipc::Mem::PageStack::Value>);
     const size_t pagesDataSize = capacity * pageSize;
     return StackSize(capacity) + pagesDataSize + levelsSize;
 }
@@ -9,9 +9,10 @@
 #ifndef SQUID_IPC_MEM_PAGE_STACK_H
 #define SQUID_IPC_MEM_PAGE_STACK_H
 
-#include "ipc/AtomicWord.h"
 #include "ipc/mem/FlexibleArray.h"
 
+#include <atomic>
+
 namespace Ipc
 {
 
@@ -33,7 +34,7 @@ class PageStack
     unsigned int capacity() const { return theCapacity; }
     size_t pageSize() const { return thePageSize; }
     /// lower bound for the number of free pages
-    unsigned int size() const { return max(0, theSize.get()); }
+    unsigned int size() const { return max(0, theSize.load()); }
 
     /// sets value and returns true unless no free page numbers are found
     bool pop(PageId &page);
@@ -63,14 +64,14 @@ class PageStack
     const Offset theCapacity; ///< stack capacity, i.e. theItems size
     const size_t thePageSize; ///< page size, used to calculate shared memory size
     /// lower bound for the number of free pages (may get negative!)
-    Atomic::WordT<Offset> theSize;
+    std::atomic<Offset> theSize;
 
     /// last readable item index; just a hint, not a guarantee
-    Atomic::WordT<Offset> theLastReadable;
+    std::atomic<Offset> theLastReadable;
     /// first writable item index; just a hint, not a guarantee
-    Atomic::WordT<Offset> theFirstWritable;
+    std::atomic<Offset> theFirstWritable;
 
-    typedef Atomic::WordT<Value> Item;
+    typedef std::atomic<Value> Item;
     Ipc::Mem::FlexibleArray<Item> theItems; ///< page number storage
 };
 
@@ -213,8 +213,11 @@ Ipc::Mem::Segment::GenerateName(const char *id)
         name.append(BasePath);
         if (name[name.size()-1] != '/')
             name.append('/');
-    } else
-        name.append("/squid-");
+    } else {
+        name.append('/');
+        name.append(service_name.c_str());
+        name.append('-');
+    }
 
     // append id, replacing slashes with dots
     for (const char *slash = strchr(id, '/'); slash; slash = strchr(id, '/')) {
@@ -51,7 +51,7 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
     else
         method = al->http.method.image();
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s%s:%s%s",
+    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
@@ -64,8 +64,7 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   al->http.clientReplySz.messageTotal(),
                   referer,
                   agent,
-                  LogTags_str[al->cache.code],
-                  al->http.statusSfx(),
+                  al->cache.code.c_str(),
                   hier_code_str[al->hier.code],
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
@@ -38,7 +38,7 @@ Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
     else
         method = al->http.method.image();
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " %s%s:%s%s",
+    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " %s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
@@ -49,8 +49,7 @@ Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   al->http.version.major, al->http.version.minor,
                   al->http.code,
                   al->http.clientReplySz.messageTotal(),
-                  LogTags_str[al->cache.code],
-                  al->http.statusSfx(),
+                  al->cache.code.c_str(),
                   hier_code_str[al->hier.code],
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
@@ -54,13 +54,12 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
     else
         method = al->http.method.image();
 
-    logfilePrintf(logfile, "%9ld.%03d %6ld %s %s%s/%03d %" PRId64 " " SQUIDSBUFPH " %s %s %s%s/%s %s%s",
+    logfilePrintf(logfile, "%9ld.%03d %6ld %s %s/%03d %" PRId64 " " SQUIDSBUFPH " %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   tvToMsec(al->cache.trTime),
                   clientip,
-                  LogTags_str[al->cache.code],
-                  al->http.statusSfx(),
+                  al->cache.code.c_str(),
                   al->http.code,
                   al->http.clientReplySz.messageTotal(),
                   SQUIDSBUFPRINT(method),
@@ -211,6 +211,18 @@ class SignalEngine: public AsyncEngine
             EventLoop::Running->stop();
     }
 
+    static void FinalShutdownRunners(void *) {
+        RunRegisteredHere(RegisteredRunner::endingShutdown);
+
+        // XXX: this should be a Runner.
+#if USE_AUTH
+        /* detach the auth components (only do this on full shutdown) */
+        Auth::Scheme::FreeAll();
+#endif
+
+        eventAdd("SquidTerminate", &StopEventLoop, NULL, 0, 1, false);
+    }
+
     void doShutdown(time_t wait);
     void handleStoppedChild();
 
@@ -269,10 +281,6 @@ SignalEngine::doShutdown(time_t wait)
 
         /* run the closure code which can be shared with reconfigure */
         serverConnectionsClose();
-#if USE_AUTH
-        /* detach the auth components (only do this on full shutdown) */
-        Auth::Scheme::FreeAll();
-#endif
 
         RunRegisteredHere(RegisteredRunner::startShutdown);
     }
@@ -281,7 +289,7 @@ SignalEngine::doShutdown(time_t wait)
     WIN32_svcstatusupdate(SERVICE_STOP_PENDING, (wait + 1) * 1000);
 #endif
 
-    eventAdd("SquidShutdown", &StopEventLoop, this, (double) (wait + 1), 1, false);
+    eventAdd("SquidShutdown", &FinalShutdownRunners, this, (double) (wait + 1), 1, false);
 }
 
 void
@@ -1387,8 +1395,6 @@ SquidMain(int argc, char **argv)
 #endif
 #endif /* HAVE_MALLOPT */
 
-    squid_srandom(time(NULL));
-
     getCurrentTime();
 
     squid_start = current_time;
@@ -72,28 +72,16 @@ Mgr::Inquirer::start()
     Must(Comm::IsConnOpen(conn));
     Must(aggrAction != NULL);
 
-#if HAVE_UNIQUE_PTR
     std::unique_ptr<MemBuf> replyBuf;
-#else
-    std::auto_ptr<MemBuf> replyBuf;
-#endif
     if (strands.empty()) {
         LOCAL_ARRAY(char, url, MAX_URL);
         snprintf(url, MAX_URL, "%s", aggrAction->command().params.httpUri.termedBuf());
         HttpRequest *req = HttpRequest::CreateFromUrl(url);
         ErrorState err(ERR_INVALID_URL, Http::scNotFound, req);
-#if HAVE_UNIQUE_PTR
         std::unique_ptr<HttpReply> reply(err.BuildHttpReply());
-#else
-        std::auto_ptr<HttpReply> reply(err.BuildHttpReply());
-#endif
         replyBuf.reset(reply->pack());
     } else {
-#if HAVE_UNIQUE_PTR
         std::unique_ptr<HttpReply> reply(new HttpReply);
-#else
-        std::auto_ptr<HttpReply> reply(new HttpReply);
-#endif
         reply->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
         reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
         replyBuf.reset(reply->pack());
@@ -30,7 +30,7 @@
 
 /* forward declarations */
 static void mimeFreeMemory(void);
-static char const *mimeGetIcon(const char *fn);
+static const SBuf mimeGetIcon(const char *fn);
 
 class MimeIcon : public StoreClient
 {
@@ -40,12 +40,14 @@ class MimeIcon : public StoreClient
     explicit MimeIcon(const char *aName);
     ~MimeIcon();
     void setName(char const *);
-    char const * getName() const;
+    SBuf getName() const;
     void load();
-    void created(StoreEntry *newEntry);
+
+    /* StoreClient API */
+    virtual void created(StoreEntry *);
 
 private:
-    const char *icon_;
+    SBuf icon_;
     char *url_;
 };
 
@@ -114,59 +116,55 @@ mimeGetEntry(const char *fn, int skip_encodings)
 }
 
 MimeIcon::MimeIcon(const char *aName) :
-    icon_(xstrdup(aName))
+    icon_(aName)
 {
     url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
 }
 
 MimeIcon::~MimeIcon()
 {
-    xfree(icon_);
     xfree(url_);
 }
 
 void
 MimeIcon::setName(char const *aString)
 {
-    xfree(icon_);
     xfree(url_);
-    icon_ = xstrdup(aString);
+    icon_ = aString;
     url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
 }
 
-char const *
+SBuf
 MimeIcon::getName() const
 {
     return icon_;
 }
 
-char const *
+const SBuf
 mimeGetIcon(const char *fn)
 {
     MimeEntry *m = mimeGetEntry(fn, 1);
 
-    if (m == NULL)
-        return NULL;
-
-    if (!strcmp(m->theIcon.getName(), dash_str))
-        return NULL;
+    if (!m || !m->theIcon.getName().cmp(dash_str))
+        return SBuf();
 
     return m->theIcon.getName();
 }
 
 const char *
 mimeGetIconURL(const char *fn)
 {
-    char const *icon = mimeGetIcon(fn);
+    SBuf icon(mimeGetIcon(fn));
 
-    if (icon == NULL)
+    if (icon.isEmpty())
         return null_string;
 
     if (Config.icons.use_short_names) {
-        static MemBuf mb;
-        mb.reset();
-        mb.Printf("/squid-internal-static/icons/%s", icon);
-        return mb.content();
+        static SBuf mb;
+        mb.clear();
+        mb.append("/squid-internal-static/icons/");
+        mb.append(icon);
+        return mb.c_str();
     } else {
         return internalLocalUri("/squid-internal-static/icons/", icon);
     }
@@ -349,7 +347,7 @@ mimeFreeMemory(void)
 void
 MimeIcon::load()
 {
-    const char *type = mimeGetContentType(icon_);
+    const char *type = mimeGetContentType(icon_.c_str());
 
     if (type == NULL)
         fatal("Unknown icon format while reading mime.conf\n");
@@ -358,32 +356,43 @@ MimeIcon::load()
 }
 
 void
-MimeIcon::created (StoreEntry *newEntry)
+MimeIcon::created(StoreEntry *newEntry)
 {
     /* if the icon is already in the store, do nothing */
     if (!newEntry->isNull())
         return;
+    // XXX: if a 204 is cached due to earlier load 'failure' we should try to reload.
 
-    int fd;
-    int n;
-    RequestFlags flags;
-    struct stat sb;
-    LOCAL_ARRAY(char, path, MAXPATHLEN);
-    char *buf;
+    // default is a 200 object with image data.
+    // set to the backup value of 204 on image loading errors
+    Http::StatusCode status = Http::scOkay;
 
-    snprintf(path, MAXPATHLEN, "%s/%s", Config.icons.directory, icon_);
+    static char path[MAXPATHLEN];
+    *path = 0;
+    if (snprintf(path, sizeof(path)-1, "%s/" SQUIDSBUFPH, Config.icons.directory, SQUIDSBUFPRINT(icon_)) < 0) {
+        debugs(25, DBG_CRITICAL, "ERROR: icon file '" << Config.icons.directory << "/" << icon_ << "' path is longer than " << MAXPATHLEN << " bytes");
+        status = Http::scNoContent;
+    }
 
-    fd = file_open(path, O_RDONLY | O_BINARY);
-    if (fd < 0) {
-        debugs(25, DBG_CRITICAL, "Problem opening icon file " << path << ": " << xstrerror());
-        return;
+    int fd = -1;
+    errno = 0;
+    if (status == Http::scOkay && (fd = file_open(path, O_RDONLY | O_BINARY)) < 0) {
+        int xerrno = errno;
+        debugs(25, DBG_CRITICAL, "ERROR: opening icon file " << path << ": " << xstrerr(xerrno));
+        status = Http::scNoContent;
     }
-    if (fstat(fd, &sb) < 0) {
-        debugs(25, DBG_CRITICAL, "Problem opening icon file. Fd: " << fd << ", fstat error " << xstrerror());
+
+    struct stat sb;
+    errno = 0;
+    if (status == Http::scOkay && fstat(fd, &sb) < 0) {
+        int xerrno = errno;
+        debugs(25, DBG_CRITICAL, "ERROR: opening icon file " << path << " FD " << fd << ", fstat error " << xstrerr(xerrno));
         file_close(fd);
-        return;
+        status = Http::scNoContent;
     }
 
+    // fill newEntry with a canned 2xx response object
+    RequestFlags flags;
     flags.cachable = true;
     StoreEntry *e = storeCreateEntry(url_,url_,flags,Http::METHOD_GET);
     assert(e != NULL);
@@ -393,30 +402,37 @@ MimeIcon::created (StoreEntry *newEntry)
     HttpRequest *r = HttpRequest::CreateFromUrl(url_);
 
     if (NULL == r)
-        fatal("mimeLoadIcon: cannot parse internal URL");
+        fatalf("mimeLoadIcon: cannot parse internal URL: %s", url_);
 
     e->mem_obj->request = r;
     HTTPMSGLOCK(e->mem_obj->request);
 
     HttpReply *reply = new HttpReply;
 
-    reply->setHeaders(Http::scOkay, NULL, mimeGetContentType(icon_), sb.st_size, sb.st_mtime, -1);
+    if (status == Http::scNoContent)
+        reply->setHeaders(status, NULL, NULL, 0, -1, -1);
+    else
+        reply->setHeaders(status, NULL, mimeGetContentType(icon_.c_str()), sb.st_size, sb.st_mtime, -1);
     reply->cache_control = new HttpHdrCc();
     reply->cache_control->maxAge(86400);
     reply->header.putCc(reply->cache_control);
     e->replaceHttpReply(reply);
 
-    /* read the file into the buffer and append it to store */
-    buf = (char *)memAllocate(MEM_4K_BUF);
-    while ((n = FD_READ_METHOD(fd, buf, 4096)) > 0)
-        e->append(buf, n);
+    if (status == Http::scOkay) {
+        /* read the file into the buffer and append it to store */
+        int n;
+        char *buf = (char *)memAllocate(MEM_4K_BUF);
+        while ((n = FD_READ_METHOD(fd, buf, sizeof(*buf))) > 0)
+            e->append(buf, n);
+
+        file_close(fd);
+        memFree(buf, MEM_4K_BUF);
+    }
 
-    file_close(fd);
     e->flush();
     e->complete();
     e->timestampsSet();
     e->unlock("MimeIcon::created");
-    memFree(buf, MEM_4K_BUF);
     debugs(25, 3, "Loaded icon " << url_);
 }
 
@@ -110,13 +110,13 @@ whichPeer(const Ip::Address &from)
 }
 
 peer_t
-neighborType(const CachePeer * p, const HttpRequest * request)
+neighborType(const CachePeer * p, const URL &url)
 {
 
     const NeighborTypeDomainList *d = NULL;
 
     for (d = p->typelist; d; d = d->next) {
-        if (0 == matchDomainName(request->GetHost(), d->domain))
+        if (0 == matchDomainName(url.host(), d->domain))
             if (d->type != PEER_NONE)
                 return d->type;
     }
@@ -138,11 +138,11 @@ peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 
     assert(request != NULL);
 
-    if (neighborType(p, request) == PEER_SIBLING) {
+    if (neighborType(p, request->url) == PEER_SIBLING) {
 #if PEER_MULTICAST_SIBLINGS
         if (p->type == PEER_MULTICAST && p->options.mcast_siblings &&
                 (request->flags.noCache || request->flags.refresh || request->flags.loopDetected || request->flags.needValidation))
-            debugs(15, 2, "peerAllowedToUse(" << p->name << ", " << request->GetHost() << ") : multicast-siblings optimization match");
+            debugs(15, 2, "peerAllowedToUse(" << p->name << ", " << request->url.authority() << ") : multicast-siblings optimization match");
 #endif
         if (request->flags.noCache)
             return false;
@@ -159,7 +159,7 @@ peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 
     // CONNECT requests are proxy requests. Not to be forwarded to origin servers.
     // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this CachePeer.
-    if (p->options.originserver && request->method == Http::METHOD_CONNECT && request->port != p->in_addr.port())
+    if (p->options.originserver && request->method == Http::METHOD_CONNECT && request->url.port() != p->http_port)
         return false;
 
     if (p->access == NULL)
@@ -282,7 +282,7 @@ getFirstUpParent(HttpRequest * request)
         if (!neighborUp(p))
             continue;
 
-        if (neighborType(p, request) != PEER_PARENT)
+        if (neighborType(p, request->url) != PEER_PARENT)
             continue;
 
         if (!peerHTTPOkay(p, request))
@@ -305,7 +305,7 @@ getRoundRobinParent(HttpRequest * request)
         if (!p->options.roundrobin)
             continue;
 
-        if (neighborType(p, request) != PEER_PARENT)
+        if (neighborType(p, request->url) != PEER_PARENT)
             continue;
 
         if (!peerHTTPOkay(p, request))
@@ -345,7 +345,7 @@ getWeightedRoundRobinParent(HttpRequest * request)
         if (!p->options.weighted_roundrobin)
             continue;
 
-        if (neighborType(p, request) != PEER_PARENT)
+        if (neighborType(p, request->url) != PEER_PARENT)
             continue;
 
         if (!peerHTTPOkay(p, request))
@@ -362,7 +362,7 @@ getWeightedRoundRobinParent(HttpRequest * request)
             if (!p->options.weighted_roundrobin)
                 continue;
 
-            if (neighborType(p, request) != PEER_PARENT)
+            if (neighborType(p, request->url) != PEER_PARENT)
                 continue;
 
             p->rr_count = 0;
@@ -455,7 +455,7 @@ getDefaultParent(HttpRequest * request)
     CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
-        if (neighborType(p, request) != PEER_PARENT)
+        if (neighborType(p, request->url) != PEER_PARENT)
             continue;
 
         if (!p->options.default_parent)
@@ -668,7 +668,7 @@ neighborsUdpPing(HttpRequest * request,
         } else if (neighborUp(p)) {
             /* its alive, expect a reply from it */
 
-            if (neighborType(p, request) == PEER_PARENT) {
+            if (neighborType(p, request->url) == PEER_PARENT) {
                 ++parent_exprep;
                 parent_timeout += p->stats.rtt;
             } else {
@@ -1033,7 +1033,7 @@ neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address
     debugs(15, 3, "neighborsUdpAck: " << opcode_d << " for '" << storeKeyText(key) << "' from " << (p ? p->host : "source") << " ");
 
     if (p) {
-        ntype = neighborType(p, mem->request);
+        ntype = neighborType(p, mem->request->url);
     }
 
     if (ignoreMulticastReply(p, mem)) {
@@ -1492,15 +1492,23 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
     if (p->options.htcp) {
         storeAppendPrintf(sentry, " htcp");
         if (p->options.htcp_oldsquid || p->options.htcp_no_clr || p->options.htcp_no_purge_clr || p->options.htcp_only_clr) {
-            int doneopts=0;
-            if (p->options.htcp_oldsquid)
-                storeAppendPrintf(sentry, "%soldsquid",(doneopts++>0?",":"="));
-            if (p->options.htcp_no_clr)
-                storeAppendPrintf(sentry, "%sno-clr",(doneopts++>0?",":"="));
-            if (p->options.htcp_no_purge_clr)
-                storeAppendPrintf(sentry, "%sno-purge-clr",(doneopts++>0?",":"="));
-            if (p->options.htcp_only_clr)
-                storeAppendPrintf(sentry, "%sonly-clr",(doneopts++>0?",":"="));
+            bool doneopts = false;
+            if (p->options.htcp_oldsquid) {
+                storeAppendPrintf(sentry, "oldsquid");
+                doneopts = true;
+            }
+            if (p->options.htcp_no_clr) {
+                storeAppendPrintf(sentry, "%sno-clr",(doneopts?",":"="));
+                doneopts = true;
+            }
+            if (p->options.htcp_no_purge_clr) {
+                storeAppendPrintf(sentry, "%sno-purge-clr",(doneopts?",":"="));
+                doneopts = true;
+            }
+            if (p->options.htcp_only_clr) {
+                storeAppendPrintf(sentry, "%sonly-clr",(doneopts?",":"="));
+                //doneopts = true; // uncomment if more opts are added
+            }
         }
     }
 #endif
@@ -1556,6 +1564,7 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
     else if (p->connection_auth == 2)
         storeAppendPrintf(sentry, " connection-auth=auto");
 
+    p->secure.dumpCfg(sentry,"tls-");
     storeAppendPrintf(sentry, "\n");
 }
 
@@ -1704,7 +1713,7 @@ neighborsHtcpReply(const cache_key * key, HtcpReplyData * htcp, const Ip::Addres
     }
 
     if (p) {
-        ntype = neighborType(p, mem->request);
+        ntype = neighborType(p, mem->request->url);
         neighborUpdateRtt(p, mem);
     }
 
@@ -19,6 +19,7 @@ class HttpRequest;
 class HttpRequestMethod;
 class CachePeer;
 class StoreEntry;
+class URL;
 
 CachePeer *getFirstPeer(void);
 CachePeer *getFirstUpParent(HttpRequest *);
@@ -52,7 +53,7 @@ void peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup)
 void peerNoteDigestGone(CachePeer * p);
 int neighborUp(const CachePeer * e);
 const char *neighborTypeStr(const CachePeer * e);
-peer_t neighborType(const CachePeer *, const HttpRequest *);
+peer_t neighborType(const CachePeer *, const URL &);
 void peerConnectFailed(CachePeer *);
 void peerConnectSucceded(CachePeer *);
 void dump_peer_options(StoreEntry *, CachePeer *);
@@ -44,7 +44,7 @@ class Tokenizer
     const SBuf& remaining() const { return buf_; }
 
     /// reinitialize processing for a new buffer
-    void reset(const SBuf &newBuf) { buf_ = newBuf; parsed_ = 0; }
+    void reset(const SBuf &newBuf) { undoParse(newBuf, 0); }
 
     /** Basic strtok(3):
      *  Skips all leading delimiters (if any),
@@ -135,6 +135,9 @@ class Tokenizer
     SBuf consume(const SBuf::size_type n);
     SBuf::size_type success(const SBuf::size_type n);
 
+    /// reset the buffer and parsed stats to a saved checkpoint
+    void undoParse(const SBuf &newBuf, SBuf::size_type cParsed) { buf_ = newBuf; parsed_ = cParsed; }
+
 private:
     SBuf buf_; ///< yet unparsed input
     SBuf::size_type parsed_; ///< bytes successfully parsed, including skipped
@@ -330,7 +330,7 @@ peerDigestRequest(PeerDigest * pd)
     if (p->digest_url)
         url = xstrdup(p->digest_url);
     else
-        url = xstrdup(internalRemoteUri(p->host, p->http_port, "/squid-internal-periodic/", StoreDigestFileName));
+        url = xstrdup(internalRemoteUri(p->host, p->http_port, "/squid-internal-periodic/", SBuf(StoreDigestFileName)));
 
     req = HttpRequest::CreateFromUrl(url);
 
@@ -633,19 +633,15 @@ peerDigestSwapInHeaders(void *data, char *buf, ssize_t size)
 
         fetch->state = DIGEST_READ_CBLOCK;
         return hdr_size;    /* Say how much data we read */
-    } else {
-        /* need more data, do we have space? */
+    }
 
-        if (size >= SM_PAGE_SIZE) {
-            peerDigestFetchAbort(fetch, buf, "stored header too big");
-            return -1;
-        } else {
-            return 0;       /* We need to read more to parse .. */
-        }
+    /* need more data, do we have space? */
+    if (size >= SM_PAGE_SIZE) {
+        peerDigestFetchAbort(fetch, buf, "stored header too big");
+        return -1;
     }
 
-    fatal("peerDigestSwapInHeaders() - shouldn't get here!\n");
-    return 0; /* keep gcc happy */
+    return 0;       /* We need to read more to parse .. */
 }
 
 int
@@ -674,19 +670,15 @@ peerDigestSwapInCBlock(void *data, char *buf, ssize_t size)
             peerDigestFetchAbort(fetch, buf, "invalid digest cblock");
             return -1;
         }
-    } else {
-        /* need more data, do we have space? */
+    }
 
-        if (size >= SM_PAGE_SIZE) {
-            peerDigestFetchAbort(fetch, buf, "digest cblock too big");
-            return -1;
-        } else {
-            return 0;       /* We need more data */
-        }
+    /* need more data, do we have space? */
+    if (size >= SM_PAGE_SIZE) {
+        peerDigestFetchAbort(fetch, buf, "digest cblock too big");
+        return -1;
     }
 
-    fatal("peerDigestSwapInCBlock(): shouldn't get here!\n");
-    return 0; /* keep gcc happy */
+    return 0;       /* We need more data */
 }
 
 int
@@ -717,13 +709,10 @@ peerDigestSwapInMask(void *data, char *buf, ssize_t size)
         assert(fetch->mask_offset == pd->cd->mask_size);
         assert(peerDigestFetchedEnough(fetch, NULL, 0, "peerDigestSwapInMask"));
         return -1;      /* XXX! */
-    } else {
-        /* We always read everything, so return so */
-        return size;
     }
 
-    fatal("peerDigestSwapInMask(): shouldn't get here!\n");
-    return 0; /* keep gcc happy */
+    /* We always read everything, so return size */
+    return size;
 }
 
 static int
@@ -253,7 +253,7 @@ peerSelectDnsPaths(ps_state *psstate)
     // convert the list of FwdServer destinations into destinations IP addresses
     if (fs && psstate->paths->size() < (unsigned int)Config.forward_max_tries) {
         // send the next one off for DNS lookup.
-        const char *host = fs->_peer ? fs->_peer->host : psstate->request->GetHost();
+        const char *host = fs->_peer ? fs->_peer->host : psstate->request->url.host();
         debugs(44, 2, "Find IP destination for: " << psstate->url() << "' via " << host);
         ipcache_nbgethostbyname(host, peerSelectDnsResults, psstate);
         return;
@@ -347,15 +347,12 @@ peerSelectDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &details,
 
             // when IPv6 is disabled we cannot use it
             if (!Ip::EnableIpv6 && p->remote.isIPv6()) {
-                const char *host = (fs->_peer ? fs->_peer->host : psstate->request->GetHost());
+                const char *host = (fs->_peer ? fs->_peer->host : psstate->request->url.host());
                 ipcacheMarkBadAddr(host, p->remote);
                 continue;
             }
 
-            if (fs->_peer)
-                p->remote.port(fs->_peer->http_port);
-            else
-                p->remote.port(psstate->request->port);
+            p->remote.port(fs->_peer ? fs->_peer->http_port : psstate->request->url.port());
             p->peerType = fs->code;
             p->setPeer(fs->_peer);
 
@@ -364,7 +361,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &details,
             psstate->paths->push_back(p);
         }
     } else {
-        debugs(44, 3, HERE << "Unknown host: " << (fs->_peer ? fs->_peer->host : psstate->request->GetHost()));
+        debugs(44, 3, "Unknown host: " << (fs->_peer ? fs->_peer->host : psstate->request->url.host()));
         // discard any previous error.
         delete psstate->lastError;
         psstate->lastError = NULL;
@@ -395,15 +392,14 @@ peerCheckNetdbDirect(ps_state * psstate)
 
     /* base lookup on RTT and Hops if ICMP NetDB is enabled. */
 
-    myrtt = netdbHostRtt(psstate->request->GetHost());
-
-    debugs(44, 3, "peerCheckNetdbDirect: MY RTT = " << myrtt << " msec");
-    debugs(44, 3, "peerCheckNetdbDirect: minimum_direct_rtt = " << Config.minDirectRtt << " msec");
+    myrtt = netdbHostRtt(psstate->request->url.host());
+    debugs(44, 3, "MY RTT = " << myrtt << " msec");
+    debugs(44, 3, "minimum_direct_rtt = " << Config.minDirectRtt << " msec");
 
     if (myrtt && myrtt <= Config.minDirectRtt)
         return 1;
 
-    myhops = netdbHostHops(psstate->request->GetHost());
+    myhops = netdbHostHops(psstate->request->url.host());
 
     debugs(44, 3, "peerCheckNetdbDirect: MY hops = " << myhops);
     debugs(44, 3, "peerCheckNetdbDirect: minimum_direct_hops = " << Config.minDirectHops);
@@ -437,7 +433,7 @@ peerSelectFoo(ps_state * ps)
 
     StoreEntry *entry = ps->entry;
     HttpRequest *request = ps->request;
-    debugs(44, 3, request->method << ' ' << request->GetHost());
+    debugs(44, 3, request->method << ' ' << request->url.host());
 
     /** If we don't know whether DIRECT is permitted ... */
     if (ps->direct == DIRECT_UNKNOWN) {
@@ -574,7 +570,7 @@ peerGetSomeNeighbor(ps_state * ps)
 
 #if USE_CACHE_DIGESTS
     if ((p = neighborsDigestSelect(request))) {
-        if (neighborType(p, request) == PEER_PARENT)
+        if (neighborType(p, request->url) == PEER_PARENT)
             code = CD_PARENT_HIT;
         else
             code = CD_SIBLING_HIT;
@@ -634,7 +630,7 @@ peerGetSomeNeighborReplies(ps_state * ps)
 
     if (peerCheckNetdbDirect(ps)) {
         code = CLOSEST_DIRECT;
-        debugs(44, 3, "peerSelect: " << hier_code_str[code] << "/" << request->GetHost());
+        debugs(44, 3, hier_code_str[code] << "/" << request->url.host());
         peerAddFwdServer(&ps->servers, NULL, code);
         return;
     }
@@ -651,7 +647,7 @@ peerGetSomeNeighborReplies(ps_state * ps)
         }
     }
     if (p && code != HIER_NONE) {
-        debugs(44, 3, "peerSelect: " << hier_code_str[code] << "/" << p->host);
+        debugs(44, 3, hier_code_str[code] << "/" << p->host);
         peerAddFwdServer(&ps->servers, p, code);
     }
 }
@@ -681,7 +677,7 @@ peerGetSomeParent(ps_state * ps)
     CachePeer *p;
     HttpRequest *request = ps->request;
     hier_code code = HIER_NONE;
-    debugs(44, 3, request->method << ' ' << request->GetHost());
+    debugs(44, 3, request->method << ' ' << request->url.host());
 
     if (ps->direct == DIRECT_YES)
         return;
@@ -724,7 +720,7 @@ peerGetAllParents(ps_state * ps)
          * parents to a request so we have to dig some here..
          */
 
-        if (neighborType(p, request) != PEER_PARENT)
+        if (neighborType(p, request->url) != PEER_PARENT)
             continue;
 
         if (!peerHTTPOkay(p, request))
@@ -752,11 +748,12 @@ peerPingTimeout(void *data)
     StoreEntry *entry = psstate->entry;
 
     if (entry)
-        debugs(44, 3, "peerPingTimeout: '" << psstate->url() << "'" );
+        debugs(44, 3, psstate->url());
 
     if (!cbdataReferenceValid(psstate->callback_data)) {
         /* request aborted */
-        entry->ping_status = PING_DONE;
+        if (entry)
+            entry->ping_status = PING_DONE;
         cbdataReferenceDone(psstate->callback_data);
         delete psstate;
         return;
@@ -786,7 +783,7 @@ peerIcpParentMiss(CachePeer * p, icp_common_t * header, ps_state * ps)
             int hops = (header->pad >> 16) & 0xFFFF;
 
             if (rtt > 0 && rtt < 0xFFFF)
-                netdbUpdatePeer(ps->request, p, rtt, hops);
+                netdbUpdatePeer(ps->request->url, p, rtt, hops);
 
             if (rtt && (ps->ping.p_rtt == 0 || rtt < ps->ping.p_rtt)) {
                 ps->closest_parent_miss = p->in_addr;
@@ -882,7 +879,7 @@ peerHtcpParentMiss(CachePeer * p, HtcpReplyData * htcp, ps_state * ps)
         if (htcp->cto.rtt > 0) {
             rtt = (int) htcp->cto.rtt * 1000;
             int hops = (int) htcp->cto.hops * 1000;
-            netdbUpdatePeer(ps->request, p, rtt, hops);
+            netdbUpdatePeer(ps->request->url, p, rtt, hops);
 
             if (rtt && (ps->ping.p_rtt == 0 || rtt < ps->ping.p_rtt)) {
                 ps->closest_parent_miss = p->in_addr;
@@ -965,16 +962,17 @@ ps_state::ps_state() : request (NULL),
     ; // no local defaults.
 }
 
-const char *
+const SBuf
 ps_state::url() const
 {
     if (entry)
-        return entry->url();
+        return SBuf(entry->url());
 
     if (request)
-        return urlCanonical(request);
+        return request->effectiveRequestUri();
 
-    return "[no URL]";
+    static const SBuf noUrl("[no URL]");
+    return noUrl;
 }
 
 ping_data::ping_data() :
@@ -200,7 +200,7 @@ redirectStats(StoreEntry * sentry)
         return;
     }
 
-    helperStats(sentry, redirectors, "Redirector Statistics");
+    redirectors->packStatsInto(sentry, "Redirector Statistics");
 
     if (Config.onoff.redirector_bypass)
         storeAppendPrintf(sentry, "\nNumber of requests bypassed "
@@ -215,7 +215,7 @@ storeIdStats(StoreEntry * sentry)
         return;
     }
 
-    helperStats(sentry, storeIds, "StoreId helper Statistics");
+    storeIds->packStatsInto(sentry, "StoreId helper Statistics");
 
     if (Config.onoff.store_id_bypass)
         storeAppendPrintf(sentry, "\nNumber of requests bypassed "
@@ -285,19 +285,20 @@ refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age,
 static int
 refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 {
-    const char *uri = NULL;
     time_t age = 0;
     time_t check_time = squid_curtime + delta;
     int staleness;
     stale_flags sf;
 
     // get the URL of this entry, if there is one
+    static const SBuf nilUri("<none>");
+    SBuf uri = nilUri;
     if (entry->mem_obj)
         uri = entry->mem_obj->storeId();
     else if (request)
-        uri = urlCanonical(request);
+        uri = request->effectiveRequestUri();
 
-    debugs(22, 3, "checking freshness of '" << (uri ? uri : "<none>") << "'");
+    debugs(22, 3, "checking freshness of URI: " << uri);
 
     // age is not necessarily the age now, but the age at the given check_time
     if (check_time > entry->timestamp)
@@ -312,7 +313,8 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
      *   2. the "." rule from the config file
      *   3. the default "." rule
      */
-    const RefreshPattern *R = uri ? refreshLimits(uri) : refreshUncompiledPattern(".");
+    // XXX: performance regression. c_str() reallocates
+    const RefreshPattern *R = (uri != nilUri) ? refreshLimits(uri.c_str()) : refreshUncompiledPattern(".");
     if (NULL == R)
         R = &DefaultRefresh;
 
@@ -360,12 +362,8 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
      *   Cache-Control: proxy-revalidate
      * the spec says the response must always be revalidated if stale.
      */
-    if (EBIT_TEST(entry->flags, ENTRY_REVALIDATE) && staleness > -1
-#if USE_HTTP_VIOLATIONS
-            && !R->flags.ignore_must_revalidate
-#endif
-       ) {
-        debugs(22, 3, "YES: Must revalidate stale object (origin set must-revalidate or proxy-revalidate)");
+    if (EBIT_TEST(entry->flags, ENTRY_REVALIDATE) && staleness > -1) {
+        debugs(22, 3, "YES: Must revalidate stale object (origin set must-revalidate, proxy-revalidate, no-cache, s-maxage, or private)");
         if (request)
             request->flags.failOnValidationError = true;
         return STALE_MUST_REVALIDATE;
@@ -10,15 +10,25 @@
 #define SQUID_SRC_SECURITY_CONTEXT_H
 
 #if USE_OPENSSL
-#include "ssl/gadgets.h"
+#if HAVE_OPENSSL_SSL_H
+#include <openssl/ssl.h>
+#endif
+#endif
+
+#if USE_GNUTLS
+#if HAVE_GNUTLS_GNUTLS_H
+#include <gnutls/gnutls.h>
+#endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
-// XXX: make this a SSL_CTX_Pointer
 typedef SSL_CTX* ContextPointer;
 
+#elif USE_GNUTLS
+typedef gnutls_certificate_credentials_t* ContextPointer;
+
 #else
 // use void* so we can check against NULL
 typedef void* ContextPointer;
@@ -16,4 +16,5 @@ libsecurity_la_SOURCES= \
 	EncryptorAnswer.h \
 	forward.h \
 	PeerOptions.cc \
-	PeerOptions.h
+	PeerOptions.h \
+	Session.h
@@ -7,8 +7,12 @@
  */
 
 #include "squid.h"
+#include "base/Packable.h"
 #include "Debug.h"
+#include "fatal.h"
 #include "globals.h"
+#include "parser/Tokenizer.h"
+#include "parser/Tokenizer.h"
 #include "Parsing.h"
 #include "security/PeerOptions.h"
 
@@ -18,29 +22,46 @@
 
 Security::PeerOptions Security::ProxyOutgoingConfig;
 
+Security::PeerOptions::PeerOptions(const Security::PeerOptions &p) :
+    certFile(p.certFile),
+    privateKeyFile(p.privateKeyFile),
+    sslOptions(p.sslOptions),
+    caFile(p.caFile),
+    caDir(p.caDir),
+    crlFile(p.crlFile),
+    sslCipher(p.sslCipher),
+    sslFlags(p.sslFlags),
+    sslDomain(p.sslDomain),
+    parsedOptions(p.parsedOptions),
+    parsedFlags(p.parsedFlags),
+    sslVersion(p.sslVersion),
+    encryptTransport(p.encryptTransport)
+{
+}
+
 void
 Security::PeerOptions::parse(const char *token)
 {
-    if (strncmp(token, "cert=", 5) == 0) {
+    if (strncmp(token, "disable", 7) == 0) {
+        clear();
+    } else if (strncmp(token, "cert=", 5) == 0) {
         certFile = SBuf(token + 5);
         if (privateKeyFile.isEmpty())
             privateKeyFile = certFile;
     } else if (strncmp(token, "key=", 4) == 0) {
         privateKeyFile = SBuf(token + 4);
         if (certFile.isEmpty()) {
-            debugs(0, DBG_PARSE_NOTE(1), "WARNING: cert= option needs to be set before key= is used.");
+            debugs(3, DBG_PARSE_NOTE(1), "WARNING: cert= option needs to be set before key= is used.");
             certFile = privateKeyFile;
         }
     } else if (strncmp(token, "version=", 8) == 0) {
+        debugs(0, DBG_PARSE_NOTE(1), "UPGRADE WARNING: SSL version= is deprecated. Use options= to limit protocols instead.");
         sslVersion = xatoi(token + 8);
+    } else if (strncmp(token, "min-version=", 12) == 0) {
+        tlsMinVersion = SBuf(token + 12);
     } else if (strncmp(token, "options=", 8) == 0) {
         sslOptions = SBuf(token + 8);
-#if USE_OPENSSL
-        // Pre-parse SSL client options to be applied when the client SSL objects created.
-        // Options must not used in the case of peek or stare bump mode.
-        // XXX: performance regression. c_str() can reallocate
-        parsedOptions = Ssl::parse_options(sslOptions.c_str());
-#endif
+        parsedOptions = parseOptions();
     } else if (strncmp(token, "cipher=", 7) == 0) {
         sslCipher = SBuf(token + 7);
     } else if (strncmp(token, "cafile=", 7) == 0) {
@@ -50,27 +71,371 @@ Security::PeerOptions::parse(const char *token)
     } else if (strncmp(token, "crlfile=", 8) == 0) {
         crlFile = SBuf(token + 8);
     } else if (strncmp(token, "flags=", 6) == 0) {
+        if (parsedFlags != 0) {
+            debugs(3, DBG_PARSE_NOTE(1), "WARNING: Overwriting flags=" << sslFlags << " with " << SBuf(token + 6));
+        }
         sslFlags = SBuf(token + 6);
+        parsedFlags = parseFlags();
     } else if (strncmp(token, "domain=", 7) == 0) {
         sslDomain = SBuf(token + 7);
+    } else {
+        debugs(3, DBG_CRITICAL, "ERROR: Unknown TLS option '" << token << "'");
+    }
+}
+
+void
+Security::PeerOptions::dumpCfg(Packable *p, const char *pfx) const
+{
+    if (!encryptTransport) {
+        p->appendf(" %sdisable", pfx);
+        return; // no other settings are relevant
+    }
+
+    if (!certFile.isEmpty())
+        p->appendf(" %scert=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(certFile));
+
+    if (!privateKeyFile.isEmpty() && privateKeyFile != certFile)
+        p->appendf(" %skey=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(privateKeyFile));
+
+    if (!sslOptions.isEmpty())
+        p->appendf(" %soptions=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslOptions));
+
+    if (!sslCipher.isEmpty())
+        p->appendf(" %scipher=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslCipher));
+
+    if (!caFile.isEmpty())
+        p->appendf(" %scafile=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(caFile));
+
+    if (!caDir.isEmpty())
+        p->appendf(" %scapath=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(caDir));
+
+    if (!crlFile.isEmpty())
+        p->appendf(" %scrlfile=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(crlFile));
+
+    if (!sslFlags.isEmpty())
+        p->appendf(" %sflags=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslFlags));
+}
+
+void
+Security::PeerOptions::updateTlsVersionLimits()
+{
+    if (!tlsMinVersion.isEmpty()) {
+        ::Parser::Tokenizer tok(tlsMinVersion);
+        int64_t v = 0;
+        if (tok.skip('1') && tok.skip('.') && tok.int64(v, 10, false, 1) && v <= 3) {
+            // only account for TLS here - SSL versions are handled by options= parameter
+            // avoid affecting options= parameter in cachemgr config report
+#if SSL_OP_NO_TLSv1
+            if (v > 0)
+                parsedOptions |= SSL_OP_NO_TLSv1;
+#endif
+#if SSL_OP_NO_TLSv1_1
+            if (v > 1)
+                parsedOptions |= SSL_OP_NO_TLSv1_1;
+#endif
+#if SSL_OP_NO_TLSv1_2
+            if (v > 2)
+                parsedOptions |= SSL_OP_NO_TLSv1_2;
+#endif
+
+        } else {
+            debugs(0, DBG_PARSE_NOTE(1), "WARNING: Unknown TLS minimum version: " << tlsMinVersion);
+        }
+
+    } else if (sslVersion > 2) {
+        // backward compatibility hack for sslversion= configuration
+        // only use if tls-min-version=N.N is not present
+        // values 0-2 for auto and SSLv2 are not supported any longer.
+        // Do it this way so we DO cause changes to options= in cachemgr config report
+        const char *add = NULL;
+        switch (sslVersion) {
+        case 3:
+            add = "NO_TLSv1,NO_TLSv1_1,NO_TLSv1_2";
+            break;
+        case 4:
+            add = "NO_SSLv3,NO_TLSv1_1,NO_TLSv1_2";
+            break;
+        case 5:
+            add = "NO_SSLv3,NO_TLSv1,NO_TLSv1_2";
+            break;
+        case 6:
+            add = "NO_SSLv3,NO_TLSv1,NO_TLSv1_1";
+            break;
+        default: // nothing
+            break;
+        }
+        if (add) {
+            if (!sslOptions.isEmpty())
+                sslOptions.append(",",1);
+            sslOptions.append(add, strlen(add));
+        }
+        sslVersion = 0; // prevent sslOptions being repeatedly appended
     }
 }
 
 // XXX: make a GnuTLS variant
 Security::ContextPointer
-Security::PeerOptions::createContext(bool setOptions)
+Security::PeerOptions::createClientContext(bool setOptions)
 {
     Security::ContextPointer t = NULL;
 
+    updateTlsVersionLimits();
 #if USE_OPENSSL
     // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
-    t = sslCreateClientContext(certFile.c_str(), privateKeyFile.c_str(), sslVersion, sslCipher.c_str(),
-                               (setOptions ? sslOptions.c_str() : NULL), sslFlags.c_str(), caFile.c_str(), caDir.c_str(), crlFile.c_str());
+    t = sslCreateClientContext(certFile.c_str(), privateKeyFile.c_str(), sslCipher.c_str(),
+                               (setOptions ? parsedOptions : 0), parsedFlags,
+                               caFile.c_str(), caDir.c_str(), crlFile.c_str());
 #endif
 
     return t;
 }
 
+/// set of options we can parse and what they map to
+static struct ssl_option {
+    const char *name;
+    long value;
+
+} ssl_options[] = {
+
+#if SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
+    {
+        "NETSCAPE_REUSE_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
+    },
+#endif
+#if SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
+    {
+        "SSLREF2_REUSE_CERT_TYPE_BUG", SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
+    },
+#endif
+#if SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
+    {
+        "MICROSOFT_BIG_SSLV3_BUFFER", SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
+    },
+#endif
+#if SSL_OP_SSLEAY_080_CLIENT_DH_BUG
+    {
+        "SSLEAY_080_CLIENT_DH_BUG", SSL_OP_SSLEAY_080_CLIENT_DH_BUG
+    },
+#endif
+#if SSL_OP_TLS_D5_BUG
+    {
+        "TLS_D5_BUG", SSL_OP_TLS_D5_BUG
+    },
+#endif
+#if SSL_OP_TLS_BLOCK_PADDING_BUG
+    {
+        "TLS_BLOCK_PADDING_BUG", SSL_OP_TLS_BLOCK_PADDING_BUG
+    },
+#endif
+#if SSL_OP_TLS_ROLLBACK_BUG
+    {
+        "TLS_ROLLBACK_BUG", SSL_OP_TLS_ROLLBACK_BUG
+    },
+#endif
+#if SSL_OP_ALL
+    {
+        "ALL", (long)SSL_OP_ALL
+    },
+#endif
+#if SSL_OP_SINGLE_DH_USE
+    {
+        "SINGLE_DH_USE", SSL_OP_SINGLE_DH_USE
+    },
+#endif
+#if SSL_OP_EPHEMERAL_RSA
+    {
+        "EPHEMERAL_RSA", SSL_OP_EPHEMERAL_RSA
+    },
+#endif
+#if SSL_OP_PKCS1_CHECK_1
+    {
+        "PKCS1_CHECK_1", SSL_OP_PKCS1_CHECK_1
+    },
+#endif
+#if SSL_OP_PKCS1_CHECK_2
+    {
+        "PKCS1_CHECK_2", SSL_OP_PKCS1_CHECK_2
+    },
+#endif
+#if SSL_OP_NETSCAPE_CA_DN_BUG
+    {
+        "NETSCAPE_CA_DN_BUG", SSL_OP_NETSCAPE_CA_DN_BUG
+    },
+#endif
+#if SSL_OP_NON_EXPORT_FIRST
+    {
+        "NON_EXPORT_FIRST", SSL_OP_NON_EXPORT_FIRST
+    },
+#endif
+#if SSL_OP_CIPHER_SERVER_PREFERENCE
+    {
+        "CIPHER_SERVER_PREFERENCE", SSL_OP_CIPHER_SERVER_PREFERENCE
+    },
+#endif
+#if SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
+    {
+        "NETSCAPE_DEMO_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
+    },
+#endif
+#if SSL_OP_NO_SSLv3
+    {
+        "NO_SSLv3", SSL_OP_NO_SSLv3
+    },
+#endif
+#if SSL_OP_NO_TLSv1
+    {
+        "NO_TLSv1", SSL_OP_NO_TLSv1
+    },
+#endif
+#if SSL_OP_NO_TLSv1_1
+    {
+        "NO_TLSv1_1", SSL_OP_NO_TLSv1_1
+    },
+#endif
+#if SSL_OP_NO_TLSv1_2
+    {
+        "NO_TLSv1_2", SSL_OP_NO_TLSv1_2
+    },
+#endif
+#if SSL_OP_NO_COMPRESSION
+    {
+        "No_Compression", SSL_OP_NO_COMPRESSION
+    },
+#endif
+#if SSL_OP_NO_TICKET
+    {
+        "NO_TICKET", SSL_OP_NO_TICKET
+    },
+#endif
+#if SSL_OP_SINGLE_ECDH_USE
+    {
+        "SINGLE_ECDH_USE", SSL_OP_SINGLE_ECDH_USE
+    },
+#endif
+    {
+        "", 0
+    },
+    {
+        NULL, 0
+    }
+};
+
+/**
+ * Pre-parse TLS options= parameter to be applied when the TLS objects created.
+ * Options must not used in the case of peek or stare bump mode.
+ */
+long
+Security::PeerOptions::parseOptions()
+{
+    long op = 0;
+    ::Parser::Tokenizer tok(sslOptions);
+
+    do {
+        enum {
+            MODE_ADD, MODE_REMOVE
+        } mode;
+
+        if (tok.skip('-') || tok.skip('!'))
+            mode = MODE_REMOVE;
+        else {
+            (void)tok.skip('+'); // default action is add. ignore if missing operator
+            mode = MODE_ADD;
+        }
+
+        static const CharacterSet optChars = CharacterSet("TLS-option", "_") + CharacterSet::ALPHA + CharacterSet::DIGIT;
+        int64_t hex = 0;
+        SBuf option;
+        long value = 0;
+
+        if (tok.int64(hex, 16, false)) {
+            /* Special case.. hex specification */
+            value = hex;
+        }
+
+        else if (tok.prefix(option, optChars)) {
+            // find the named option in our supported set
+            for (struct ssl_option *opttmp = ssl_options; opttmp->name; ++opttmp) {
+                if (option.cmp(opttmp->name) == 0) {
+                    value = opttmp->value;
+                    break;
+                }
+            }
+        }
+
+        if (!value) {
+            fatalf("Unknown TLS option '" SQUIDSBUFPH "'", SQUIDSBUFPRINT(option));
+        }
+
+        switch (mode) {
+
+        case MODE_ADD:
+            op |= value;
+            break;
+
+        case MODE_REMOVE:
+            op &= ~value;
+            break;
+        }
+
+        static const CharacterSet delims("TLS-option-delim",":,");
+        if (!tok.skipAll(delims) && !tok.atEnd()) {
+            fatalf("Unknown TLS option '" SQUIDSBUFPH "'", SQUIDSBUFPRINT(tok.remaining()));
+        }
+
+    } while (!tok.atEnd());
+
+#if SSL_OP_NO_SSLv2
+    // compliance with RFC 6176: Prohibiting Secure Sockets Layer (SSL) Version 2.0
+    op = op | SSL_OP_NO_SSLv2;
+#endif
+    return op;
+}
+
+/**
+ * Parses the TLS flags squid.conf parameter
+ */
+long
+Security::PeerOptions::parseFlags()
+{
+    if (sslFlags.isEmpty())
+        return 0;
+
+    static struct {
+        SBuf label;
+        long mask;
+    } flagTokens[] = {
+        { SBuf("NO_DEFAULT_CA"), SSL_FLAG_NO_DEFAULT_CA },
+        { SBuf("DELAYED_AUTH"), SSL_FLAG_DELAYED_AUTH },
+        { SBuf("DONT_VERIFY_PEER"), SSL_FLAG_DONT_VERIFY_PEER },
+        { SBuf("DONT_VERIFY_DOMAIN"), SSL_FLAG_DONT_VERIFY_DOMAIN },
+        { SBuf("NO_SESSION_REUSE"), SSL_FLAG_NO_SESSION_REUSE },
+#if X509_V_FLAG_CRL_CHECK
+        { SBuf("VERIFY_CRL"), SSL_FLAG_VERIFY_CRL },
+        { SBuf("VERIFY_CRL_ALL"), SSL_FLAG_VERIFY_CRL_ALL },
+#endif
+        { SBuf(), 0 }
+    };
+
+    ::Parser::Tokenizer tok(sslFlags);
+    static const CharacterSet delims("Flag-delimiter", ":,");
+
+    long fl = 0;
+    do {
+        long found = 0;
+        for (size_t i = 0; flagTokens[i].mask; ++i) {
+            if (tok.skip(flagTokens[i].label) == 0) {
+                found = flagTokens[i].mask;
+                break;
+            }
+        }
+        if (!found)
+            fatalf("Unknown TLS flag '" SQUIDSBUFPH "'", SQUIDSBUFPRINT(tok.remaining()));
+        fl |= found;
+    } while (tok.skipOne(delims));
+
+    return fl;
+}
+
 void
 parse_securePeerOptions(Security::PeerOptions *opt)
 {
@@ -13,24 +13,38 @@
 #include "SBuf.h"
 #include "security/forward.h"
 
+class Packable;
+
 namespace Security
 {
 
 /// TLS squid.conf settings for a remote server peer
 class PeerOptions
 {
 public:
-    PeerOptions() : parsedOptions(0), sslVersion(0), encryptTransport(false) {}
+    PeerOptions() : parsedOptions(0), parsedFlags(0), sslVersion(0), encryptTransport(false) {}
+    PeerOptions(const PeerOptions &);
 
     /// parse a TLS squid.conf option
     void parse(const char *);
 
     /// reset the configuration details to default
     void clear() {*this = PeerOptions();}
 
-    /// generate a security context from these configured options
-    Security::ContextPointer createContext(bool setOptions);
+    /// generate a security client-context from these configured options
+    Security::ContextPointer createClientContext(bool setOptions);
+
+    /// sync the context options with tls-min-version=N configuration
+    void updateTlsVersionLimits();
+
+    /// output squid.conf syntax with 'pfx' prefix on parameters for the stored settings
+    void dumpCfg(Packable *, const char *pfx) const;
+
+private:
+    long parseOptions();
+    long parseFlags();
 
+public:
     SBuf certFile;       ///< path of file containing PEM format X509 certificate
     SBuf privateKeyFile; ///< path of file containing private key in PEM format
     SBuf sslOptions;     ///< library-specific options string
@@ -39,13 +53,18 @@ class PeerOptions
     SBuf crlFile;        ///< path of file containing Certificate Revoke List
 
     SBuf sslCipher;
-    SBuf sslFlags;
+    SBuf sslFlags;       ///< flags defining what TLS operations Squid performs
     SBuf sslDomain;
 
+    SBuf tlsMinVersion;  ///< version label for minimum TLS version to permit
+
     long parsedOptions; ///< parsed value of sslOptions
+    long parsedFlags;   ///< parsed value of sslFlags
 
+private:
     int sslVersion;
 
+public:
     /// whether transport encryption (TLS/SSL) is to be used on connections to the peer
     bool encryptTransport;
 };
@@ -58,7 +77,7 @@ extern PeerOptions ProxyOutgoingConfig;
 // parse the tls_outgoing_options directive
 void parse_securePeerOptions(Security::PeerOptions *);
 #define free_securePeerOptions(x) Security::ProxyOutgoingConfig.clear()
-#define dump_securePeerOptions(e,n,x) // not supported yet
+#define dump_securePeerOptions(e,n,x) do { (e)->appendf(n); (x).dumpCfg((e),""); (e)->append("\n",1); } while(false)
 
 #endif /* SQUID_SRC_SECURITY_PEEROPTIONS_H */
 
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_SECURITY_SESSION_H
+#define SQUID_SRC_SECURITY_SESSION_H
+
+#if USE_OPENSSL
+#if HAVE_OPENSSL_SSL_H
+#include <openssl/ssl.h>
+#endif
+#endif
+
+#if USE_GNUTLS
+#if HAVE_GNUTLS_GNUTLS_H
+#include <gnutls/gnutls.h>
+#endif
+#endif
+
+namespace Security {
+
+#if USE_OPENSSL
+typedef SSL* SessionPointer;
+
+#elif USE_GNUTLS
+typedef gnutls_session_t SessionPointer;
+
+#else
+// use void* so we can check against NULL
+typedef void* SessionPointer;
+#endif
+
+} // namespace Security
+
+#endif /* SQUID_SRC_SECURITY_SESSION_H */
+
@@ -10,6 +10,16 @@
 #define SQUID_SRC_SECURITY_FORWARD_H
 
 #include "security/Context.h"
+#include "security/Session.h"
+
+/* flags a SSL connection can be configured with */
+#define SSL_FLAG_NO_DEFAULT_CA      (1<<0)
+#define SSL_FLAG_DELAYED_AUTH       (1<<1)
+#define SSL_FLAG_DONT_VERIFY_PEER   (1<<2)
+#define SSL_FLAG_DONT_VERIFY_DOMAIN (1<<3)
+#define SSL_FLAG_NO_SESSION_REUSE   (1<<4)
+#define SSL_FLAG_VERIFY_CRL         (1<<5)
+#define SSL_FLAG_VERIFY_CRL_ALL     (1<<6)
 
 /// Network/connection security abstraction layer
 namespace Security
@@ -417,7 +417,7 @@ Ftp::Server::acceptDataConnection(const CommAcceptCbParams &params)
                 Must(master->serverState == fssHandleDataRequest);
             MemBuf mb;
             mb.init();
-            mb.Printf("150 Data connection opened.\r\n");
+            mb.appendf("150 Data connection opened.\r\n");
             Comm::Write(clientConnection, &mb, call);
         }
     }
@@ -462,7 +462,7 @@ Ftp::Server::writeEarlyReply(const int code, const char *msg)
 
     MemBuf mb;
     mb.init();
-    mb.Printf("%i %s\r\n", code, msg);
+    mb.appendf("%i %s\r\n", code, msg);
 
     typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
     AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteEarlyReply);
@@ -497,12 +497,12 @@ Ftp::Server::writeCustomReply(const int code, const char *msg, const HttpReply *
     MemBuf mb;
     mb.init();
     if (sendDetails) {
-        mb.Printf("%i-%s\r\n", code, msg);
-        mb.Printf(" Server reply:\r\n");
+        mb.appendf("%i-%s\r\n", code, msg);
+        mb.appendf(" Server reply:\r\n");
         Ftp::PrintReply(mb, reply, " ");
-        mb.Printf("%i \r\n", code);
+        mb.appendf("%i \r\n", code);
     } else
-        mb.Printf("%i %s\r\n", code, msg);
+        mb.appendf("%i %s\r\n", code, msg);
 
     writeReply(mb);
 }
@@ -892,10 +892,10 @@ Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
     // versions block responses that use those alternative syntax rules!
     MemBuf mb;
     mb.init();
-    mb.Printf("227 Entering Passive Mode (%s,%i,%i).\r\n",
-              addr,
-              static_cast<int>(localPort / 256),
-              static_cast<int>(localPort % 256));
+    mb.appendf("227 Entering Passive Mode (%s,%i,%i).\r\n",
+               addr,
+               static_cast<int>(localPort / 256),
+               static_cast<int>(localPort % 256));
     debugs(9, 3, Raw("writing", mb.buf, mb.size));
     writeReply(mb);
 }
@@ -1063,7 +1063,7 @@ Ftp::Server::handleEpsvReply(const HttpReply *reply, StoreIOBuffer)
     // traffic will be redirected to us.
     MemBuf mb;
     mb.init();
-    mb.Printf("229 Entering Extended Passive Mode (|||%u|)\r\n", localPort);
+    mb.appendf("229 Entering Extended Passive Mode (|||%u|)\r\n", localPort);
 
     debugs(9, 3, Raw("writing", mb.buf, mb.size));
     writeReply(mb);
@@ -1080,13 +1080,13 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
     mb.init();
 
     if (request->errType != ERR_NONE)
-        mb.Printf("%i-%s\r\n", scode, errorPageName(request->errType));
+        mb.appendf("%i-%s\r\n", scode, errorPageName(request->errType));
 
     if (request->errDetail > 0) {
         // XXX: > 0 may not always mean that this is an errno
-        mb.Printf("%i-Error: (%d) %s\r\n", scode,
-                  request->errDetail,
-                  strerror(request->errDetail));
+        mb.appendf("%i-Error: (%d) %s\r\n", scode,
+                   request->errDetail,
+                   strerror(request->errDetail));
     }
 
 #if USE_ADAPTATION
@@ -1096,9 +1096,9 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
         const String info = ah->allMeta.getByName("X-Response-Info");
         const String desc = ah->allMeta.getByName("X-Response-Desc");
         if (info.size())
-            mb.Printf("%i-Information: %s\r\n", scode, info.termedBuf());
+            mb.appendf("%i-Information: %s\r\n", scode, info.termedBuf());
         if (desc.size())
-            mb.Printf("%i-Description: %s\r\n", scode, desc.termedBuf());
+            mb.appendf("%i-Description: %s\r\n", scode, desc.termedBuf());
     }
 #endif
 
@@ -1107,7 +1107,7 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
                          reply->header.getStr(HDR_FTP_REASON):
                          reply->sline.reason();
 
-    mb.Printf("%i %s\r\n", scode, reason); // error terminating line
+    mb.appendf("%i %s\r\n", scode, reason); // error terminating line
 
     // TODO: errorpage.cc should detect FTP client and use
     // configurable FTP-friendly error templates which we should
@@ -1197,14 +1197,14 @@ Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const)
         if (e->id == HDR_FTP_PRE) {
             String raw;
             if (httpHeaderParseQuotedString(e->value.rawBuf(), e->value.size(), &raw))
-                mb.Printf("%s\r\n", raw.termedBuf());
+                mb.appendf("%s\r\n", raw.termedBuf());
         }
     }
 
     if (header.has(HDR_FTP_STATUS)) {
         const char *reason = header.getStr(HDR_FTP_REASON);
-        mb.Printf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
-                  (reason ? reason : 0));
+        mb.appendf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
+                   (reason ? reason : 0));
     }
 }
 
@@ -1286,11 +1286,8 @@ Ftp::Server::handleRequest(HttpRequest *request)
 
     if (do_debug(9, 2)) {
         MemBuf mb;
-        Packer p;
         mb.init();
-        packerToMemInit(&p, &mb);
-        request->pack(&p);
-        packerClean(&p);
+        request->pack(&mb);
 
         debugs(9, 2, "FTP Client " << clientConnection);
         debugs(9, 2, "FTP Client REQUEST:\n---------\n" << mb.buf <<
@@ -431,13 +431,12 @@ Ssl::ErrorDetail::err_frm_code Ssl::ErrorDetail::ErrorFormatingCodes[] = {
  */
 const char  *Ssl::ErrorDetail::subject() const
 {
-    if (!broken_cert)
-        return "[Not available]";
-
-    static char tmpBuffer[256]; // A temporary buffer
-    X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer,
-                      sizeof(tmpBuffer));
-    return tmpBuffer;
+    if (broken_cert.get()) {
+        static char tmpBuffer[256]; // A temporary buffer
+        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))
+            return tmpBuffer;
+    }
+    return "[Not available]";
 }
 
 // helper function to be used with Ssl::matchX509CommonNames
@@ -446,9 +445,11 @@ static int copy_cn(void *check_data,  ASN1_STRING *cn_data)
     String *str = (String *)check_data;
     if (!str) // no data? abort
         return 0;
-    if (str->size() > 0)
-        str->append(", ");
-    str->append((const char *)cn_data->data, cn_data->length);
+    if (cn_data && cn_data->length) {
+        if (str->size() > 0)
+            str->append(", ");
+        str->append((const char *)cn_data->data, cn_data->length);
+    }
     return 1;
 }
 
@@ -457,54 +458,57 @@ static int copy_cn(void *check_data,  ASN1_STRING *cn_data)
  */
 const char *Ssl::ErrorDetail::cn() const
 {
-    if (!broken_cert)
-        return "[Not available]";
-
-    static String tmpStr;  ///< A temporary string buffer
-    tmpStr.clean();
-    Ssl::matchX509CommonNames(broken_cert.get(), &tmpStr, copy_cn);
-    return tmpStr.termedBuf();
+    if (broken_cert.get()) {
+        static String tmpStr;  ///< A temporary string buffer
+        tmpStr.clean();
+        Ssl::matchX509CommonNames(broken_cert.get(), &tmpStr, copy_cn);
+        if (tmpStr.size())
+            return tmpStr.termedBuf();
+    }
+    return "[Not available]";
 }
 
 /**
  * The issuer name
  */
 const char *Ssl::ErrorDetail::ca_name() const
 {
-    if (!broken_cert)
-        return "[Not available]";
-
-    static char tmpBuffer[256]; // A temporary buffer
-    X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer));
-    return tmpBuffer;
+    if (broken_cert.get()) {
+        static char tmpBuffer[256]; // A temporary buffer
+        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))
+            return tmpBuffer;
+    }
+    return "[Not available]";
 }
 
 /**
  * The certificate "not before" field
  */
 const char *Ssl::ErrorDetail::notbefore() const
 {
-    if (!broken_cert)
-        return "[Not available]";
-
-    static char tmpBuffer[256]; // A temporary buffer
-    ASN1_UTCTIME * tm = X509_get_notBefore(broken_cert.get());
-    Ssl::asn1timeToString(tm, tmpBuffer, sizeof(tmpBuffer));
-    return tmpBuffer;
+    if (broken_cert.get()) {
+        if (ASN1_UTCTIME * tm = X509_get_notBefore(broken_cert.get())) {
+            static char tmpBuffer[256]; // A temporary buffer
+            Ssl::asn1timeToString(tm, tmpBuffer, sizeof(tmpBuffer));
+            return tmpBuffer;
+        }
+    }
+    return "[Not available]";
 }
 
 /**
  * The certificate "not after" field
  */
 const char *Ssl::ErrorDetail::notafter() const
 {
-    if (!broken_cert)
-        return "[Not available]";
-
-    static char tmpBuffer[256]; // A temporary buffer
-    ASN1_UTCTIME * tm = X509_get_notAfter(broken_cert.get());
-    Ssl::asn1timeToString(tm, tmpBuffer, sizeof(tmpBuffer));
-    return tmpBuffer;
+    if (broken_cert.get()) {
+        if (ASN1_UTCTIME * tm = X509_get_notAfter(broken_cert.get())) {
+            static char tmpBuffer[256]; // A temporary buffer
+            Ssl::asn1timeToString(tm, tmpBuffer, sizeof(tmpBuffer));
+            return tmpBuffer;
+        }
+    }
+    return "[Not available]";
 }
 
 /**
@@ -18,6 +18,7 @@ EXTRA_DIST = \
 
 if USE_SSL_CRTD
 SSL_CRTD = ssl_crtd
+man_MANS = ssl_crtd.8
 else
 SSL_CRTD =
 endif
@@ -178,7 +178,7 @@ Ssl::PeerConnector::sslFinalized()
         // Ssl::CertValidationRequest object used only to pass data to
         // Ssl::CertValidationHelper::submit method.
         validationRequest.ssl = ssl;
-        validationRequest.domainName = request->GetHost();
+        validationRequest.domainName = request->url.host();
         if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
             // validationRequest disappears on return so no need to cbdataReference
             validationRequest.errors = errs;
@@ -259,8 +259,8 @@ Ssl::PeekingPeerConnector::checkForPeekAndSpliceDone(Ssl::BumpMode const action)
     }
 
     if (finalAction == Ssl::bumpTerminate) {
-        comm_close(serverConn->fd);
-        comm_close(clientConn->fd);
+        serverConn->close();
+        clientConn->close();
     } else if (finalAction != Ssl::bumpSplice) {
         //Allow write, proceed with the connection
         srvBio->holdWrite(false);
@@ -294,7 +294,7 @@ Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse const &valid
         return;
     }
 
-    debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
+    debugs(83,5, request->url.host() << " cert validation result: " << validationResponse.resultCode);
 
     if (validationResponse.resultCode == ::Helper::Error)
         errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
@@ -398,7 +398,7 @@ Ssl::PeerConnector::handleNegotiateError(const int ret)
     const int fd = serverConnection()->fd;
     unsigned long ssl_lib_error = SSL_ERROR_NONE;
     SSL *ssl = fd_table[fd].ssl;
-    int ssl_error = SSL_get_error(ssl, ret);
+    const int ssl_error = SSL_get_error(ssl, ret);
 
     switch (ssl_error) {
     case SSL_ERROR_WANT_READ:
@@ -541,12 +541,12 @@ Ssl::PeerConnector::status() const
     // id and stop reason reporting duplication.
     buf.append(" [", 2);
     if (stopReason != NULL) {
-        buf.Printf("Stopped, reason:");
-        buf.Printf("%s",stopReason);
+        buf.append("Stopped, reason:", 16);
+        buf.appendf("%s",stopReason);
     }
     if (serverConn != NULL)
-        buf.Printf(" FD %d", serverConn->fd);
-    buf.Printf(" %s%u]", id.Prefix, id.value);
+        buf.appendf(" FD %d", serverConn->fd);
+    buf.appendf(" %s%u]", id.Prefix, id.value);
     buf.terminate();
 
     return buf.content();
@@ -650,7 +650,7 @@ Ssl::PeekingPeerConnector::initializeSsl()
             // unless it was the CONNECT request with a user-typed address.
             const bool isConnectRequest = !csd->port->flags.isIntercepted();
             if (!request->flags.sslPeek || isConnectRequest)
-                hostName = new SBuf(request->GetHost());
+                hostName = new SBuf(request->url.host());
         }
 
         if (hostName)
@@ -679,7 +679,7 @@ Ssl::PeekingPeerConnector::initializeSsl()
             // Use SNI TLS extension only when we connect directly
             // to the origin server and we know the server host name.
             const char *sniServer = hostName ? hostName->c_str() :
-                                    (!request->GetHostIsNumeric() ? request->GetHost() : NULL);
+                                    (!request->url.hostIsNumeric() ? request->url.host() : NULL);
             if (sniServer)
                 Ssl::setClientSNI(ssl, sniServer);
         }
@@ -731,16 +731,19 @@ Ssl::PeekingPeerConnector::noteNegotiationDone(ErrorState *error)
             if (request->flags.sslPeek && !isConnectRequest) {
                 if (X509 *srvX509 = serverBump->serverCert.get()) {
                     if (const char *name = Ssl::CommonHostName(srvX509)) {
-                        request->SetHost(name);
+                        request->url.host(name);
                         debugs(83, 3, "reset request host: " << name);
                     }
                 }
             }
         }
     }
 
-    if (!error && splice)
-        switchToTunnel(request.getRaw(), clientConn, serverConn);
+    if (!error) {
+        serverCertificateVerified();
+        if (splice)
+            switchToTunnel(request.getRaw(), clientConn, serverConn);
+    }
 }
 
 void
@@ -820,14 +823,30 @@ Ssl::PeekingPeerConnector::handleServerCertificate()
 
         serverCertificateHandled = true;
 
-        csd->resetSslCommonName(Ssl::CommonHostName(serverCert.get()));
-        debugs(83, 5, "HTTPS server CN: " << csd->sslCommonName() <<
-               " bumped: " << *serverConnection());
-
         // remember the server certificate for later use
         if (Ssl::ServerBump *serverBump = csd->serverBump()) {
             serverBump->serverCert.reset(serverCert.release());
         }
     }
 }
 
+void
+Ssl::PeekingPeerConnector::serverCertificateVerified()
+{
+    if (ConnStateData *csd = request->clientConnectionManager.valid()) {
+        Ssl::X509_Pointer serverCert;
+        if(Ssl::ServerBump *serverBump = csd->serverBump())
+            serverCert.resetAndLock(serverBump->serverCert.get());
+        else {
+            const int fd = serverConnection()->fd;
+            SSL *ssl = fd_table[fd].ssl;
+            serverCert.reset(SSL_get_peer_certificate(ssl));
+        }
+        if (serverCert.get()) {
+            csd->resetSslCommonName(Ssl::CommonHostName(serverCert.get()));
+            debugs(83, 5, "HTTPS server CN: " << csd->sslCommonName() <<
+                   " bumped: " << *serverConnection());
+        }
+    }
+}
+
@@ -241,6 +241,10 @@ class PeekingPeerConnector: public PeerConnector {
     /// Handles the final bumping decision.
     void checkForPeekAndSpliceDone(Ssl::BumpMode const);
 
+    /// Runs after the server certificate verified to update client
+    /// connection manager members
+    void serverCertificateVerified();
+
     /// A wrapper function for checkForPeekAndSpliceDone for use with acl
     static void cbCheckForPeekAndSpliceDone(allow_t answer, void *data);
 
@@ -24,16 +24,18 @@ Ssl::ServerBump::ServerBump(HttpRequest *fakeRequest, StoreEntry *e, Ssl::BumpMo
     sslErrors(NULL),
     step(bumpStep1)
 {
-    debugs(33, 4, HERE << "will peek at " << request->GetHost() << ':' << request->port);
+    debugs(33, 4, "will peek at " << request->url.authority(true));
     act.step1 = md;
     act.step2 = act.step3 = Ssl::bumpNone;
 
-    const char *uri = urlCanonical(request.getRaw());
     if (e) {
         entry = e;
         entry->lock("Ssl::ServerBump");
-    } else
-        entry = storeCreateEntry(uri, uri, request->flags, request->method);
+    } else {
+        // XXX: Performance regression. c_str() reallocates
+        SBuf uri(request->effectiveRequestUri());
+        entry = storeCreateEntry(uri.c_str(), uri.c_str(), request->flags, request->method);
+    }
     // We do not need to be a client because the error contents will be used
     // later, but an entry without any client will trim all its contents away.
     sc = storeClientListAdd(entry, this);
@@ -1144,7 +1144,6 @@ Ssl::Bio::sslFeatures::applyToSSL(SSL *ssl, Ssl::BumpMode bumpMode) const
     // SSL version which can be used to the SSL version used for client hello message.
     // For example will prevent comunnicating with a tls1.0 server if the
     // client sent and tlsv1.2 Hello message.
-    //SSL_set_ssl_method(ssl, Ssl::clientMethod(features.toSquidSSLVersion()));
 #if defined(TLSEXT_NAMETYPE_host_name)
     if (!serverName.isEmpty()) {
         SSL_set_tlsext_host_name(ssl, serverName.c_str());
@@ -320,18 +320,25 @@ bool Ssl::CertificateDb::addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP
     }
 
     // check db size while trying to minimize calls to size()
-    while (size() > max_db_size) {
-        if (deleteInvalidCertificate())
-            continue; // try to find another invalid certificate if needed
-
-        // there are no more invalid ones, but there must be valid certificates
-        do {
-            if (!deleteOldestCertificate()) {
-                save(); // Some entries may have been removed. Update the index file.
-                return false; // errors prevented us from freeing enough space
-            }
-        } while (size() > max_db_size);
-        break;
+    size_t dbSize = size();
+    if ((dbSize == 0 && hasRows()) ||
+            (dbSize > 0 && !hasRows()) ||
+            (dbSize >  10 * max_db_size)) {
+        // Invalid database size, rebuild
+        dbSize = rebuildSize();
+    }
+    while (dbSize > max_db_size && deleteInvalidCertificate()) {
+        dbSize = size(); // get the current database size
+        // and try to find another invalid certificate if needed
+    }
+    // there are no more invalid ones, but there must be valid certificates
+    while (dbSize > max_db_size) {
+        if (!deleteOldestCertificate()) {
+            rebuildSize(); // No certificates in database.Update the size file.
+            save(); // Some entries may have been removed. Update the index file.
+            return false; // errors prevented us from freeing enough space
+        }
+        dbSize = size(); // get the current database size
     }
 
     row.setValue(cnlType, "V");
@@ -456,7 +463,8 @@ void Ssl::CertificateDb::addSize(std::string const & filename) {
 void Ssl::CertificateDb::subSize(std::string const & filename) {
     // readSize will rebuild 'size' file if missing or it is corrupted
     size_t dbSize = readSize();
-    dbSize -= getFileSize(filename);
+    const size_t fileSize = getFileSize(filename);
+    dbSize = dbSize > fileSize ? dbSize - fileSize : 0;
     writeSize(dbSize);
 }
 
@@ -480,8 +488,10 @@ size_t Ssl::CertificateDb::getFileSize(std::string const & filename) {
     if (!file)
         return 0;
     file.seekg(0, std::ios_base::end);
-    size_t file_size = file.tellg();
-    return ((file_size + fs_block_size - 1) / fs_block_size) * fs_block_size;
+    const std::streampos file_size = file.tellg();
+    if (file_size < 0)
+        return 0;
+    return ((static_cast<size_t>(file_size) + fs_block_size - 1) / fs_block_size) * fs_block_size;
 }
 
 void Ssl::CertificateDb::load() {
@@ -561,15 +571,9 @@ bool Ssl::CertificateDb::deleteInvalidCertificate() {
     return true;
 }
 
-bool Ssl::CertificateDb::deleteOldestCertificate() {
-    if (!db)
-        return false;
-
-#if SQUID_SSLTXTDB_PSTRINGDATA
-    if (sk_OPENSSL_PSTRING_num(db.get()->data) == 0)
-#else
-    if (sk_num(db.get()->data) == 0)
-#endif
+bool Ssl::CertificateDb::deleteOldestCertificate()
+{
+    if (!hasRows())
         return false;
 
 #if SQUID_SSLTXTDB_PSTRINGDATA
@@ -610,6 +614,20 @@ bool Ssl::CertificateDb::deleteByHostname(std::string const & host) {
     return false;
 }
 
+bool Ssl::CertificateDb::hasRows() const
+{
+    if (!db)
+        return false;
+
+#if SQUID_SSLTXTDB_PSTRINGDATA
+    if (sk_OPENSSL_PSTRING_num(db.get()->data) == 0)
+#else
+    if (sk_num(db.get()->data) == 0)
+#endif
+        return false;
+    return true;
+}
+
 bool Ssl::CertificateDb::IsEnabledDiskStore() const {
     return enabled_disk_store;
 }
@@ -127,6 +127,7 @@ class CertificateDb
     bool deleteInvalidCertificate(); ///< Delete invalid certificate.
     bool deleteOldestCertificate(); ///< Delete oldest certificate.
     bool deleteByHostname(std::string const & host); ///< Delete using host name.
+    bool hasRows() const; ///< Whether the TXT_DB has stored items.
 
     /// Removes the first matching row from TXT_DB. Ignores failures.
     static void sq_TXT_DB_delete(TXT_DB *db, const char **row);
@@ -205,7 +205,13 @@ static bool proccessNewRequest(Ssl::CrtdMessage & request_message, std::string c
     Ssl::EVP_PKEY_Pointer pkey;
     std::string &cert_subject = certProperties.dbKey();
 
-    db.find(cert_subject, cert, pkey);
+    bool dbFailed = false;
+    try {
+        db.find(cert_subject, cert, pkey);
+    } catch (std::runtime_error &err) {
+        dbFailed = true;
+        error = err.what();
+    }
 
     if (cert.get()) {
         if (!Ssl::certificateMatchesProperties(cert.get(), certProperties)) {
@@ -221,10 +227,22 @@ static bool proccessNewRequest(Ssl::CrtdMessage & request_message, std::string c
         if (!Ssl::generateSslCertificate(cert, pkey, certProperties))
             throw std::runtime_error("Cannot create ssl certificate or private key.");
 
-        if (!db.addCertAndPrivateKey(cert, pkey, cert_subject) && db.IsEnabledDiskStore())
-            throw std::runtime_error("Cannot add certificate to db.");
+        if (!dbFailed && db.IsEnabledDiskStore()) {
+            try {
+                if (!db.addCertAndPrivateKey(cert, pkey, cert_subject)) {
+                    dbFailed = true;
+                    error = "Cannot add certificate to db.";
+                }
+            } catch (const std::runtime_error &err) {
+                dbFailed = true;
+                error = err.what();
+            }
+        }
     }
 
+    if (dbFailed)
+        std::cerr << "ssl_crtd helper database '" << db_path  << "' failed: " << error << std::endl;
+
     std::string bufferToWrite;
     if (!Ssl::writeCertAndPrivateKeyToMemory(cert, pkey, bufferToWrite))
         throw std::runtime_error("Cannot write ssl certificate or/and private key to memory.");
@@ -354,276 +354,6 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
     return ok;
 }
 
-/// \ingroup ServerProtocolSSLInternal
-static struct ssl_option {
-    const char *name;
-    long value;
-}
-
-ssl_options[] = {
-
-#if SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
-    {
-        "NETSCAPE_REUSE_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
-    },
-#endif
-#if SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
-    {
-        "SSLREF2_REUSE_CERT_TYPE_BUG", SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
-    },
-#endif
-#if SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
-    {
-        "MICROSOFT_BIG_SSLV3_BUFFER", SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
-    },
-#endif
-#if SSL_OP_SSLEAY_080_CLIENT_DH_BUG
-    {
-        "SSLEAY_080_CLIENT_DH_BUG", SSL_OP_SSLEAY_080_CLIENT_DH_BUG
-    },
-#endif
-#if SSL_OP_TLS_D5_BUG
-    {
-        "TLS_D5_BUG", SSL_OP_TLS_D5_BUG
-    },
-#endif
-#if SSL_OP_TLS_BLOCK_PADDING_BUG
-    {
-        "TLS_BLOCK_PADDING_BUG", SSL_OP_TLS_BLOCK_PADDING_BUG
-    },
-#endif
-#if SSL_OP_TLS_ROLLBACK_BUG
-    {
-        "TLS_ROLLBACK_BUG", SSL_OP_TLS_ROLLBACK_BUG
-    },
-#endif
-#if SSL_OP_ALL
-    {
-        "ALL", (long)SSL_OP_ALL
-    },
-#endif
-#if SSL_OP_SINGLE_DH_USE
-    {
-        "SINGLE_DH_USE", SSL_OP_SINGLE_DH_USE
-    },
-#endif
-#if SSL_OP_EPHEMERAL_RSA
-    {
-        "EPHEMERAL_RSA", SSL_OP_EPHEMERAL_RSA
-    },
-#endif
-#if SSL_OP_PKCS1_CHECK_1
-    {
-        "PKCS1_CHECK_1", SSL_OP_PKCS1_CHECK_1
-    },
-#endif
-#if SSL_OP_PKCS1_CHECK_2
-    {
-        "PKCS1_CHECK_2", SSL_OP_PKCS1_CHECK_2
-    },
-#endif
-#if SSL_OP_NETSCAPE_CA_DN_BUG
-    {
-        "NETSCAPE_CA_DN_BUG", SSL_OP_NETSCAPE_CA_DN_BUG
-    },
-#endif
-#if SSL_OP_NON_EXPORT_FIRST
-    {
-        "NON_EXPORT_FIRST", SSL_OP_NON_EXPORT_FIRST
-    },
-#endif
-#if SSL_OP_CIPHER_SERVER_PREFERENCE
-    {
-        "CIPHER_SERVER_PREFERENCE", SSL_OP_CIPHER_SERVER_PREFERENCE
-    },
-#endif
-#if SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
-    {
-        "NETSCAPE_DEMO_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
-    },
-#endif
-#if SSL_OP_NO_SSLv3
-    {
-        "NO_SSLv3", SSL_OP_NO_SSLv3
-    },
-#endif
-#if SSL_OP_NO_TLSv1
-    {
-        "NO_TLSv1", SSL_OP_NO_TLSv1
-    },
-#endif
-#if SSL_OP_NO_TLSv1_1
-    {
-        "NO_TLSv1_1", SSL_OP_NO_TLSv1_1
-    },
-#endif
-#if SSL_OP_NO_TLSv1_2
-    {
-        "NO_TLSv1_2", SSL_OP_NO_TLSv1_2
-    },
-#endif
-#if SSL_OP_NO_COMPRESSION
-    {
-        "No_Compression", SSL_OP_NO_COMPRESSION
-    },
-#endif
-#if SSL_OP_NO_TICKET
-    {
-        "NO_TICKET", SSL_OP_NO_TICKET
-    },
-#endif
-    {
-        "", 0
-    },
-    {
-        NULL, 0
-    }
-};
-
-/// \ingroup ServerProtocolSSLInternal
-long
-Ssl::parse_options(const char *options)
-{
-    long op = 0;
-    char *tmp;
-    char *option;
-
-    if (!options)
-        goto no_options;
-
-    tmp = xstrdup(options);
-
-    option = strtok(tmp, ":,");
-
-    while (option) {
-
-        struct ssl_option *opt = NULL, *opttmp;
-        long value = 0;
-        enum {
-            MODE_ADD, MODE_REMOVE
-        } mode;
-
-        switch (*option) {
-
-        case '!':
-
-        case '-':
-            mode = MODE_REMOVE;
-            ++option;
-            break;
-
-        case '+':
-            mode = MODE_ADD;
-            ++option;
-            break;
-
-        default:
-            mode = MODE_ADD;
-            break;
-        }
-
-        for (opttmp = ssl_options; opttmp->name; ++opttmp) {
-            if (strcmp(opttmp->name, option) == 0) {
-                opt = opttmp;
-                break;
-            }
-        }
-
-        if (opt)
-            value = opt->value;
-        else if (strncmp(option, "0x", 2) == 0) {
-            /* Special case.. hex specification */
-            value = strtol(option + 2, NULL, 16);
-        } else {
-            fatalf("Unknown SSL option '%s'", option);
-            value = 0;      /* Keep GCC happy */
-        }
-
-        switch (mode) {
-
-        case MODE_ADD:
-            op |= value;
-            break;
-
-        case MODE_REMOVE:
-            op &= ~value;
-            break;
-        }
-
-        option = strtok(NULL, ":,");
-    }
-
-    safe_free(tmp);
-
-no_options:
-#if SSL_OP_NO_SSLv2
-    // compliance with RFC 6176: Prohibiting Secure Sockets Layer (SSL) Version 2.0
-    op = op | SSL_OP_NO_SSLv2;
-#endif
-    return op;
-}
-
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_NO_DEFAULT_CA      (1<<0)
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_DELAYED_AUTH       (1<<1)
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_DONT_VERIFY_PEER   (1<<2)
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_DONT_VERIFY_DOMAIN (1<<3)
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_NO_SESSION_REUSE   (1<<4)
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_VERIFY_CRL     (1<<5)
-/// \ingroup ServerProtocolSSLInternal
-#define SSL_FLAG_VERIFY_CRL_ALL     (1<<6)
-
-/// \ingroup ServerProtocolSSLInternal
-long
-Ssl::parse_flags(const char *flags)
-{
-    long fl = 0;
-    char *tmp;
-    char *flag;
-
-    if (!flags)
-        return 0;
-
-    tmp = xstrdup(flags);
-
-    flag = strtok(tmp, ":,");
-
-    while (flag) {
-        if (strcmp(flag, "NO_DEFAULT_CA") == 0)
-            fl |= SSL_FLAG_NO_DEFAULT_CA;
-        else if (strcmp(flag, "DELAYED_AUTH") == 0)
-            fl |= SSL_FLAG_DELAYED_AUTH;
-        else if (strcmp(flag, "DONT_VERIFY_PEER") == 0)
-            fl |= SSL_FLAG_DONT_VERIFY_PEER;
-        else if (strcmp(flag, "DONT_VERIFY_DOMAIN") == 0)
-            fl |= SSL_FLAG_DONT_VERIFY_DOMAIN;
-        else if (strcmp(flag, "NO_SESSION_REUSE") == 0)
-            fl |= SSL_FLAG_NO_SESSION_REUSE;
-
-#if X509_V_FLAG_CRL_CHECK
-
-        else if (strcmp(flag, "VERIFY_CRL") == 0)
-            fl |= SSL_FLAG_VERIFY_CRL;
-        else if (strcmp(flag, "VERIFY_CRL_ALL") == 0)
-            fl |= SSL_FLAG_VERIFY_CRL_ALL;
-
-#endif
-
-        else
-            fatalf("Unknown ssl flag '%s'", flag);
-
-        flag = strtok(NULL, ":,");
-    }
-
-    safe_free(tmp);
-    return fl;
-}
-
 // "dup" function for SSL_get_ex_new_index("cert_err_check")
 static int
 ssl_dupAclChecklist(CRYPTO_EX_DATA *, CRYPTO_EX_DATA *, void *,
@@ -717,7 +447,7 @@ ssl_initialize(void)
             fatalf("Unable to find SSL engine '%s'\n", Config.SSL.ssl_engine);
 
         if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
-            int ssl_error = ERR_get_error();
+            const int ssl_error = ERR_get_error();
             fatalf("Failed to initialise SSL engine: %s\n", ERR_error_string(ssl_error, NULL));
         }
     }
@@ -823,16 +553,55 @@ Ssl::readDHParams(const char *dhfile)
     return dh;
 }
 
+#if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
+static void
+ssl_info_cb(const SSL *ssl, int where, int ret)
+{
+    (void)ret;
+    if ((where & SSL_CB_HANDSHAKE_DONE) != 0) {
+        // disable renegotiation (CVE-2009-3555)
+        ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;
+    }
+}
+#endif
+
+static bool
+configureSslEECDH(SSL_CTX *sslContext, const char *curve)
+{
+#if OPENSSL_VERSION_NUMBER >= 0x0090800fL && !defined(OPENSSL_NO_ECDH)
+    int nid = OBJ_sn2nid(curve);
+    if (!nid) {
+        debugs(83, DBG_CRITICAL, "ERROR: Unknown EECDH curve '" << curve << "'");
+        return false;
+    }
+
+    EC_KEY *ecdh = EC_KEY_new_by_curve_name(nid);
+    if (ecdh == NULL)
+        return false;
+
+    const bool ok = SSL_CTX_set_tmp_ecdh(sslContext, ecdh) != 0;
+    EC_KEY_free(ecdh);
+    return ok;
+#else
+    debugs(83, DBG_CRITICAL, "ERROR: EECDH is not available in this build. Please link against OpenSSL>=0.9.8 and ensure OPENSSL_NO_ECDH is not set.");
+    return false;
+#endif
+}
+
 static bool
 configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
 {
     int ssl_error;
-    SSL_CTX_set_options(sslContext, port.sslOptions);
+    SSL_CTX_set_options(sslContext, port.secure.parsedOptions);
+
+#if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
+    SSL_CTX_set_info_callback(sslContext, ssl_info_cb);
+#endif
 
     if (port.sslContextSessionId)
         SSL_CTX_set_session_id_context(sslContext, (const unsigned char *)port.sslContextSessionId, strlen(port.sslContextSessionId));
 
-    if (port.sslContextFlags & SSL_FLAG_NO_SESSION_REUSE) {
+    if (port.secure.parsedFlags & SSL_FLAG_NO_SESSION_REUSE) {
         SSL_CTX_set_session_cache_mode(sslContext, SSL_SESS_CACHE_OFF);
     }
 
@@ -842,38 +611,54 @@ configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
         SSL_CTX_set_quiet_shutdown(sslContext, 1);
     }
 
-    if (port.cipher) {
-        debugs(83, 5, "Using chiper suite " << port.cipher << ".");
+    if (!port.secure.sslCipher.isEmpty()) {
+        debugs(83, 5, "Using chiper suite " << port.secure.sslCipher << ".");
 
-        if (!SSL_CTX_set_cipher_list(sslContext, port.cipher)) {
+        if (!SSL_CTX_set_cipher_list(sslContext, port.secure.sslCipher.c_str())) {
             ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" << port.cipher << "': " << ERR_error_string(ssl_error, NULL));
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" << port.secure.sslCipher << "': " << ERR_error_string(ssl_error, NULL));
             return false;
         }
     }
 
     debugs(83, 9, "Setting RSA key generation callback.");
     SSL_CTX_set_tmp_rsa_callback(sslContext, ssl_temp_rsa_cb);
 
+    if (port.eecdhCurve) {
+        debugs(83, 9, "Setting Ephemeral ECDH curve to " << port.eecdhCurve << ".");
+
+        if (!configureSslEECDH(sslContext, port.eecdhCurve)) {
+            ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Unable to configure Ephemeral ECDH: " << ERR_error_string(ssl_error, NULL));
+            return false;
+        }
+    }
+
     debugs(83, 9, "Setting CA certificate locations.");
 
-    const char *cafile = port.cafile ? port.cafile : port.clientca;
-    if ((cafile || port.capath) && !SSL_CTX_load_verify_locations(sslContext, cafile, port.capath)) {
+    const char *cafile = port.secure.caFile.isEmpty() ? port.clientca : port.secure.caFile.c_str();
+    if ((cafile || !port.secure.caDir.isEmpty()) && !SSL_CTX_load_verify_locations(sslContext, cafile, port.secure.caDir.c_str())) {
         ssl_error = ERR_get_error();
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
     }
 
-    if (!(port.sslContextFlags & SSL_FLAG_NO_DEFAULT_CA) &&
+    if (!(port.secure.parsedFlags & SSL_FLAG_NO_DEFAULT_CA) &&
             !SSL_CTX_set_default_verify_paths(sslContext)) {
         ssl_error = ERR_get_error();
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default CA certificate location: " << ERR_error_string(ssl_error, NULL));
     }
 
     if (port.clientCA.get()) {
         ERR_clear_error();
-        SSL_CTX_set_client_CA_list(sslContext, port.clientCA.get());
+        if (STACK_OF(X509_NAME) *clientca = SSL_dup_CA_list(port.clientCA.get())) {
+            SSL_CTX_set_client_CA_list(sslContext, clientca);
+        } else {
+            ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to dupe the client CA list: " << ERR_error_string(ssl_error, NULL));
+            return false;
+        }
 
-        if (port.sslContextFlags & SSL_FLAG_DELAYED_AUTH) {
+        if (port.secure.parsedFlags & SSL_FLAG_DELAYED_AUTH) {
             debugs(83, 9, "Not requesting client certificates until acl processing requires one");
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
         } else {
@@ -891,9 +676,9 @@ configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
         }
 
 #if X509_V_FLAG_CRL_CHECK
-        if (port.sslContextFlags & SSL_FLAG_VERIFY_CRL_ALL)
+        if (port.secure.parsedFlags & SSL_FLAG_VERIFY_CRL_ALL)
             X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
-        else if (port.sslContextFlags & SSL_FLAG_VERIFY_CRL)
+        else if (port.secure.parsedFlags & SSL_FLAG_VERIFY_CRL)
             X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK);
 #endif
 
@@ -906,7 +691,7 @@ configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
         SSL_CTX_set_tmp_dh(sslContext, port.dhParams.get());
     }
 
-    if (port.sslContextFlags & SSL_FLAG_DONT_VERIFY_DOMAIN)
+    if (port.secure.parsedFlags & SSL_FLAG_DONT_VERIFY_DOMAIN)
         SSL_CTX_set_ex_data(sslContext, ssl_ctx_ex_index_dont_verify_domain, (void *) -1);
 
     setSessionCallbacks(sslContext);
@@ -917,38 +702,30 @@ configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
 SSL_CTX *
 sslCreateServerContext(AnyP::PortCfg &port)
 {
-    int ssl_error;
-    SSL_CTX *sslContext;
-    const char *keyfile, *certfile;
-    certfile = port.cert;
-    keyfile = port.key;
-
     ssl_initialize();
 
-    if (!keyfile)
-        keyfile = certfile;
-
-    if (!certfile)
-        certfile = keyfile;
-
-    sslContext = SSL_CTX_new(port.contextMethod);
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    SSL_CTX *sslContext = SSL_CTX_new(TLS_server_method());
+#else
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv23_server_method());
+#endif
 
     if (sslContext == NULL) {
-        ssl_error = ERR_get_error();
+        const int ssl_error = ERR_get_error();
         debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate SSL context: " << ERR_error_string(ssl_error, NULL));
         return NULL;
     }
 
     if (!SSL_CTX_use_certificate(sslContext, port.signingCert.get())) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << certfile << "': " << ERR_error_string(ssl_error, NULL));
+        const int ssl_error = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << port.secure.certFile << "': " << ERR_error_string(ssl_error, NULL));
         SSL_CTX_free(sslContext);
         return NULL;
     }
 
     if (!SSL_CTX_use_PrivateKey(sslContext, port.signPkey.get())) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << keyfile << "': " << ERR_error_string(ssl_error, NULL));
+        const int ssl_error = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << port.secure.privateKeyFile << "': " << ERR_error_string(ssl_error, NULL));
         SSL_CTX_free(sslContext);
         return NULL;
     }
@@ -995,132 +772,6 @@ sslCreateServerContext(AnyP::PortCfg &port)
     return sslContext;
 }
 
-int Ssl::OpenSSLtoSquidSSLVersion(int sslVersion)
-{
-    if (sslVersion == SSL2_VERSION)
-        return 2;
-    else if (sslVersion == SSL3_VERSION)
-        return 3;
-    else if (sslVersion == TLS1_VERSION)
-        return 4;
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L
-    else if (sslVersion == TLS1_1_VERSION)
-        return 5;
-    else if (sslVersion == TLS1_2_VERSION)
-        return 6;
-#endif
-    else
-        return 1;
-}
-
-#if OPENSSL_VERSION_NUMBER < 0x00909000L
-SSL_METHOD *
-#else
-const SSL_METHOD *
-#endif
-Ssl::clientMethod(int version)
-{
-    switch (version) {
-
-    case 2:
-        debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
-        return NULL;
-        break;
-
-    case 3:
-        debugs(83, 5, "Using SSLv3.");
-        return SSLv3_client_method();
-        break;
-
-    case 4:
-        debugs(83, 5, "Using TLSv1.");
-        return TLSv1_client_method();
-        break;
-
-    case 5:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.1.");
-        return TLSv1_1_client_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
-
-    case 6:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.2");
-        return TLSv1_2_client_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
-
-    case 1:
-
-    default:
-        debugs(83, 5, "Using SSLv2/SSLv3.");
-        return SSLv23_client_method();
-        break;
-    }
-
-    //Not reached
-    return NULL;
-}
-
-const SSL_METHOD *
-Ssl::serverMethod(int version)
-{
-    switch (version) {
-
-    case 2:
-        debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
-        return NULL;
-        break;
-
-    case 3:
-        debugs(83, 5, "Using SSLv3.");
-        return SSLv3_server_method();
-        break;
-
-    case 4:
-        debugs(83, 5, "Using TLSv1.");
-        return TLSv1_server_method();
-        break;
-
-    case 5:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.1.");
-        return TLSv1_1_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
-
-    case 6:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.2");
-        return TLSv1_2_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
-
-    case 1:
-
-    default:
-        debugs(83, 5, "Using SSLv2/SSLv3.");
-        return SSLv23_server_method();
-        break;
-    }
-
-    //Not reached
-    return NULL;
-}
-
 #if defined(TLSEXT_TYPE_next_proto_neg)
 //Dummy next_proto_neg callback
 static int
@@ -1133,33 +784,33 @@ ssl_next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsi
 #endif
 
 SSL_CTX *
-sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile)
+sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl, const char *CAfile, const char *CApath, const char *CRLfile)
 {
-    int ssl_error;
-    Ssl::ContextMethod method;
-    SSL_CTX * sslContext;
-    long fl = Ssl::parse_flags(flags);
-
     ssl_initialize();
 
-    if (!(method = Ssl::clientMethod(version)))
-        return NULL;
-
-    sslContext = SSL_CTX_new(method);
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    SSL_CTX *sslContext = SSL_CTX_new(TLS_client_method());
+#else
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv23_client_method());
+#endif
 
     if (sslContext == NULL) {
-        ssl_error = ERR_get_error();
+        const int ssl_error = ERR_get_error();
         fatalf("Failed to allocate SSL context: %s\n",
                ERR_error_string(ssl_error, NULL));
     }
 
-    SSL_CTX_set_options(sslContext, Ssl::parse_options(options));
+    SSL_CTX_set_options(sslContext, options);
+
+#if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
+    SSL_CTX_set_info_callback(sslContext, ssl_info_cb);
+#endif
 
     if (*cipher) {
         debugs(83, 5, "Using chiper suite " << cipher << ".");
 
         if (!SSL_CTX_set_cipher_list(sslContext, cipher)) {
-            ssl_error = ERR_get_error();
+            const int ssl_error = ERR_get_error();
             fatalf("Failed to set SSL cipher suite '%s': %s\n",
                    cipher, ERR_error_string(ssl_error, NULL));
         }
@@ -1169,7 +820,7 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
         debugs(83, DBG_IMPORTANT, "Using certificate in " << certfile);
 
         if (!SSL_CTX_use_certificate_chain_file(sslContext, certfile)) {
-            ssl_error = ERR_get_error();
+            const int ssl_error = ERR_get_error();
             fatalf("Failed to acquire SSL certificate '%s': %s\n",
                    certfile, ERR_error_string(ssl_error, NULL));
         }
@@ -1178,15 +829,15 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
         ssl_ask_password(sslContext, keyfile);
 
         if (!SSL_CTX_use_PrivateKey_file(sslContext, keyfile, SSL_FILETYPE_PEM)) {
-            ssl_error = ERR_get_error();
+            const int ssl_error = ERR_get_error();
             fatalf("Failed to acquire SSL private key '%s': %s\n",
                    keyfile, ERR_error_string(ssl_error, NULL));
         }
 
         debugs(83, 5, "Comparing private and public SSL keys.");
 
         if (!SSL_CTX_check_private_key(sslContext)) {
-            ssl_error = ERR_get_error();
+            const int ssl_error = ERR_get_error();
             fatalf("SSL private key '%s' does not match public key '%s': %s\n",
                    certfile, keyfile, ERR_error_string(ssl_error, NULL));
         }
@@ -1206,7 +857,7 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
     debugs(83, 9, "Setting CA certificate locations.");
 
     if ((*CAfile || *CApath) && !SSL_CTX_load_verify_locations(sslContext, CAfile, CApath)) {
-        ssl_error = ERR_get_error();
+        const int ssl_error = ERR_get_error();
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
     }
 
@@ -1225,7 +876,7 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
 
     if (!(fl & SSL_FLAG_NO_DEFAULT_CA) &&
             !SSL_CTX_set_default_verify_paths(sslContext)) {
-        ssl_error = ERR_get_error();
+        const int ssl_error = ERR_get_error();
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default CA certificate location: " << ERR_error_string(ssl_error, NULL));
     }
 
@@ -1478,64 +1129,16 @@ sslGetUserCertificateChainPEM(SSL *ssl)
     return str;
 }
 
-Ssl::ContextMethod
-Ssl::contextMethod(int version)
-{
-    Ssl::ContextMethod method;
-
-    switch (version) {
-
-    case 2:
-        debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
-        return NULL;
-        break;
-
-    case 3:
-        debugs(83, 5, "Using SSLv3.");
-        method = SSLv3_server_method();
-        break;
-
-    case 4:
-        debugs(83, 5, "Using TLSv1.");
-        method = TLSv1_server_method();
-        break;
-
-    case 5:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.1.");
-        method = TLSv1_1_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
-
-    case 6:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.2");
-        method = TLSv1_2_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
-
-    case 1:
-
-    default:
-        debugs(83, 5, "Using SSLv2/SSLv3.");
-        method = SSLv23_server_method();
-        break;
-    }
-    return method;
-}
-
 /// \ingroup ServerProtocolSSLInternal
 /// Create SSL context and apply ssl certificate and private key to it.
 SSL_CTX *
 Ssl::createSSLContext(Ssl::X509_Pointer & x509, Ssl::EVP_PKEY_Pointer & pkey, AnyP::PortCfg &port)
 {
-    Ssl::SSL_CTX_Pointer sslContext(SSL_CTX_new(port.contextMethod));
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+    Ssl::SSL_CTX_Pointer sslContext(SSL_CTX_new(TLS_server_method()));
+#else
+    Ssl::SSL_CTX_Pointer sslContext(SSL_CTX_new(SSLv23_server_method()));
+#endif
 
     if (!SSL_CTX_use_certificate(sslContext.get(), x509.get()))
         return NULL;
@@ -1768,6 +1371,11 @@ bool Ssl::generateUntrustedCert(X509_Pointer &untrustedCert, EVP_PKEY_Pointer &u
 SSL *
 SslCreate(SSL_CTX *sslContext, const int fd, Ssl::Bio::Type type, const char *squidCtx)
 {
+    if (fd < 0) {
+        debugs(83, DBG_IMPORTANT, "Gone connection");
+        return NULL;
+    }
+
     const char *errAction = NULL;
     int errCode = 0;
     if (SSL *ssl = SSL_new(sslContext)) {
@@ -92,7 +92,7 @@ typedef CbDataList<Ssl::CertError> CertErrors;
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port);
 
 /// \ingroup ServerProtocolSSLAPI
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile);
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags, const char *CAfile, const char *CApath, const char *CRLfile);
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_read_method(int, char *, int);
@@ -157,18 +157,6 @@ inline const char *bumpMode(int bm)
     return (0 <= bm && bm < Ssl::bumpEnd) ? Ssl::BumpModeStr[bm] : NULL;
 }
 
-/**
- \ingroup ServerProtocolSSLAPI
- * Parses the SSL flags.
- */
-long parse_flags(const char *flags);
-
-/**
- \ingroup ServerProtocolSSLAPI
- * Parses the SSL options.
- */
-long parse_options(const char *options);
-
 /**
  \ingroup ServerProtocolSSLAPI
  * Load a CRLs list stored in a file
@@ -181,12 +169,6 @@ STACK_OF(X509_CRL) *loadCrl(const char *CRLFile, long &flags);
  */
 DH *readDHParams(const char *dhfile);
 
-/**
- \ingroup ServerProtocolSSLAPI
- * Compute the Ssl::ContextMethod (SSL_METHOD) from SSL version
- */
-ContextMethod contextMethod(int version);
-
 /**
   \ingroup ServerProtocolSSLAPI
   * Generate a certificate to be used as untrusted signing certificate, based on a trusted CA
@@ -288,15 +270,6 @@ int asn1timeToString(ASN1_TIME *tm, char *buf, int len);
 */
 bool setClientSNI(SSL *ssl, const char *fqdn);
 
-int OpenSSLtoSquidSSLVersion(int sslVersion);
-
-#if OPENSSL_VERSION_NUMBER >= 0x00909000L
-const
-#endif
-SSL_METHOD *clientMethod(int version);
-
-const SSL_METHOD *serverMethod(int version);
-
 /**
    \ingroup ServerProtocolSSLAPI
    * Initializes the shared session cache if configured
@@ -342,21 +342,17 @@ static void
 statStoreEntry(MemBuf * mb, StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
-    mb->Printf("KEY %s\n", e->getMD5Text());
-    mb->Printf("\t%s\n", describeStatuses(e));
-    mb->Printf("\t%s\n", storeEntryFlags(e));
-    mb->Printf("\t%s\n", describeTimestamps(e));
-    mb->Printf("\t%d locks, %d clients, %d refs\n",
-               (int) e->locks(),
-               storePendingNClients(e),
-               (int) e->refcount);
-    mb->Printf("\tSwap Dir %d, File %#08X\n",
-               e->swap_dirn, e->swap_filen);
+    mb->appendf("KEY %s\n", e->getMD5Text());
+    mb->appendf("\t%s\n", describeStatuses(e));
+    mb->appendf("\t%s\n", storeEntryFlags(e));
+    mb->appendf("\t%s\n", describeTimestamps(e));
+    mb->appendf("\t%d locks, %d clients, %d refs\n", (int) e->locks(), storePendingNClients(e), (int) e->refcount);
+    mb->appendf("\tSwap Dir %d, File %#08X\n", e->swap_dirn, e->swap_filen);
 
     if (mem != NULL)
         mem->stat (mb);
 
-    mb->Printf("\n");
+    mb->append("\n", 1);
 }
 
 /* process objects list */
@@ -1871,7 +1867,7 @@ statClientRequests(StoreEntry * s)
         }
 
         storeAppendPrintf(s, "uri %s\n", http->uri);
-        storeAppendPrintf(s, "logType %s\n", LogTags_str[http->logType]);
+        storeAppendPrintf(s, "logType %s\n", http->logType.c_str());
         storeAppendPrintf(s, "out.offset %ld, out.size %lu\n",
                           (long int) http->out.offset, (unsigned long int) http->out.size);
         storeAppendPrintf(s, "req_sz %ld\n", (long int) http->req_sz);
@@ -865,24 +865,62 @@ StoreEntry::append(char const *buf, int len)
     write(tempBuffer);
 }
 
+void
+StoreEntry::vappendf(const char *fmt, va_list vargs)
+{
+    LOCAL_ARRAY(char, buf, 4096);
+    *buf = 0;
+    int x;
+
+#ifdef VA_COPY
+    va_args ap;
+    /* Fix of bug 753r. The value of vargs is undefined
+     * after vsnprintf() returns. Make a copy of vargs
+     * incase we loop around and call vsnprintf() again.
+     */
+    VA_COPY(ap,vargs);
+    errno = 0;
+    if ((x = vsnprintf(buf, sizeof(buf), fmt, ap)) < 0) {
+        fatal(xstrerr(errno));
+        return;
+    }
+    va_end(ap);
+#else /* VA_COPY */
+    errno = 0;
+    if ((x = vsnprintf(buf, sizeof(buf), fmt, vargs)) < 0) {
+        fatal(xstrerr(errno));
+        return;
+    }
+#endif /*VA_COPY*/
+
+    if (x < static_cast<int>(sizeof(buf))) {
+        append(buf, x);
+        return;
+    }
+
+    // okay, do it the slow way.
+    char *buf2 = new char[x+1];
+    int y = vsnprintf(buf2, x+1, fmt, vargs);
+    assert(y >= 0 && y == x);
+    append(buf2, y);
+    delete[] buf2;
+}
+
+// deprecated. use StoreEntry::appendf() instead.
 void
 storeAppendPrintf(StoreEntry * e, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
-
-    storeAppendVPrintf(e, fmt, args);
+    e->vappendf(fmt, args);
     va_end(args);
 }
 
-/* used be storeAppendPrintf and Packer */
+// deprecated. use StoreEntry::appendf() instead.
 void
 storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
 {
-    LOCAL_ARRAY(char, buf, 4096);
-    buf[0] = '\0';
-    vsnprintf(buf, 4096, fmt, vargs);
-    e->append(buf, strlen(buf));
+    e->vappendf(fmt, vargs);
 }
 
 struct _store_check_cachable_hist {
@@ -1880,26 +1918,22 @@ StoreEntry::replaceHttpReply(HttpReply *rep, bool andStartWriting)
 void
 StoreEntry::startWriting()
 {
-    Packer p;
-
     /* TODO: when we store headers serparately remove the header portion */
     /* TODO: mark the length of the headers ? */
     /* We ONLY want the headers */
-    packerToStoreInit(&p, this);
 
     assert (isEmpty());
     assert(mem_obj);
 
     const HttpReply *rep = getReply();
     assert(rep);
 
-    rep->packHeadersInto(&p);
+    buffer();
+    rep->packHeadersInto(this);
     mem_obj->markEndOfReplyHeaders();
     EBIT_CLR(flags, ENTRY_FWD_HDR_WAIT);
 
-    rep->body.packInto(&p);
-
-    packerClean(&p);
+    rep->body.packInto(this);
 }
 
 char const *
@@ -522,15 +522,14 @@ storeClientReadBody(void *data, const char *buf, ssize_t len, StoreIOState::Poin
     sc->readBody(buf, len);
 }
 
-void
+bool
 store_client::unpackHeader(char const *buf, ssize_t len)
 {
     debugs(90, 3, "store_client::unpackHeader: len " << len << "");
 
     if (len < 0) {
-        debugs(90, 3, "store_client::unpackHeader: " << xstrerror() << "");
-        fail();
-        return;
+        debugs(90, 3, "WARNING: unpack error: " << xstrerror());
+        return false;
     }
 
     int swap_hdr_sz = 0;
@@ -539,16 +538,14 @@ store_client::unpackHeader(char const *buf, ssize_t len)
     if (!aBuilder.isBufferSane()) {
         /* oops, bad disk file? */
         debugs(90, DBG_IMPORTANT, "WARNING: swapfile header inconsistent with available data");
-        fail();
-        return;
+        return false;
     }
 
     tlv *tlv_list = aBuilder.createStoreMeta ();
 
     if (tlv_list == NULL) {
         debugs(90, DBG_IMPORTANT, "WARNING: failed to unpack meta data");
-        fail();
-        return;
+        return false;
     }
 
     /*
@@ -557,8 +554,7 @@ store_client::unpackHeader(char const *buf, ssize_t len)
     for (tlv *t = tlv_list; t; t = t->next) {
         if (!t->checkConsistency(entry)) {
             storeSwapTLVFree(tlv_list);
-            fail();
-            return;
+            return false;
         }
     }
 
@@ -573,6 +569,7 @@ store_client::unpackHeader(char const *buf, ssize_t len)
     debugs(90, 5, "store_client::unpackHeader: swap_file_sz=" <<
            entry->swap_file_sz << "( " << swap_hdr_sz << " + " <<
            entry->mem_obj->object_sz << ")");
+    return true;
 }
 
 void
@@ -584,11 +581,15 @@ store_client::readHeader(char const *buf, ssize_t len)
     flags.disk_io_pending = false;
     assert(_callback.pending());
 
-    unpackHeader (buf, len);
-
+    // abort if we fail()'d earlier
     if (!object_ok)
         return;
 
+    if (!unpackHeader(buf, len)) {
+        fail();
+        return;
+    }
+
     /*
      * If our last read got some data the client wants, then give
      * it to them, otherwise schedule another read.
@@ -853,26 +854,21 @@ store_client::dumpStats(MemBuf * output, int clientNumber) const
     if (_callback.pending())
         return;
 
-    output->Printf("\tClient #%d, %p\n", clientNumber, _callback.callback_data);
-
-    output->Printf("\t\tcopy_offset: %" PRId64 "\n",
-                   copyInto.offset);
-
-    output->Printf("\t\tcopy_size: %d\n",
-                   (int) copyInto.length);
-
-    output->Printf("\t\tflags:");
+    output->appendf("\tClient #%d, %p\n", clientNumber, _callback.callback_data);
+    output->appendf("\t\tcopy_offset: %" PRId64 "\n", copyInto.offset);
+    output->appendf("\t\tcopy_size: %" PRIuSIZE "\n", copyInto.length);
+    output->append("\t\tflags:", 8);
 
     if (flags.disk_io_pending)
-        output->Printf(" disk_io_pending");
+        output->append(" disk_io_pending", 16);
 
     if (flags.store_copying)
-        output->Printf(" store_copying");
+        output->append(" store_copying", 14);
 
     if (flags.copy_event_pending)
-        output->Printf(" copy_event_pending");
+        output->append(" copy_event_pending", 19);
 
-    output->Printf("\n");
+    output->append("\n",1);
 }
 
 bool
@@ -363,7 +363,7 @@ storeDigestRewriteStart(void *datanotused)
 
     debugs(71, 2, "storeDigestRewrite: start rewrite #" << sd_state.rewrite_count + 1);
     /* make new store entry */
-    url = internalLocalUri("/squid-internal-periodic/", StoreDigestFileName);
+    url = internalLocalUri("/squid-internal-periodic/", SBuf(StoreDigestFileName));
     flags.cachable = true;
     e = storeCreateEntry(url, url, flags, Http::METHOD_GET);
     assert(e);
@@ -118,11 +118,11 @@ storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& me
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     unsigned char m = (unsigned char) method.id();
-    const char *url = request->storeId(); /* storeId returns the right storeID\canonical URL for the md5 calc */
+    const SBuf url = request->storeId(); /* returns the right storeID\URL for the MD5 calc */
     SquidMD5_CTX M;
     SquidMD5Init(&M);
     SquidMD5Update(&M, &m, sizeof(m));
-    SquidMD5Update(&M, (unsigned char *) url, strlen(url));
+    SquidMD5Update(&M, (unsigned char *) url.rawContent(), url.length());
 
     if (request->vary_headers) {
         SquidMD5Update(&M, (unsigned char *) request->vary_headers, strlen(request->vary_headers));
@@ -11,10 +11,15 @@
 #ifndef SQUID_STORE_REBUILD_H_
 #define SQUID_STORE_REBUILD_H_
 
-// currently a POD
 class StoreRebuildData
 {
 public:
+    StoreRebuildData() :
+        objcount(0), expcount(0), scancount(0), clashcount(0),
+        dupcount(0), cancelcount(0), invalid(0), badflags(0),
+        bad_log_op(0), zero_object_sz(0)
+    {}
+
     int objcount;       /* # objects successfully reloaded */
     int expcount;       /* # objects expired */
     int scancount;      /* # entries scanned or read from state file */
@@ -39,13 +39,13 @@ storeSwapMetaBuild(StoreEntry * e)
 {
     tlv *TLV = NULL;        /* we'll return this */
     tlv **T = &TLV;
-    const char *url;
     const char *vary;
     assert(e->mem_obj != NULL);
     const int64_t objsize = e->mem_obj->expectedReplySize();
     assert(e->swap_status == SWAPOUT_WRITING);
 
     // e->mem_obj->request may be nil in this context
+    SBuf url;
     if (e->mem_obj->request)
         url = e->mem_obj->request->storeId();
     else
@@ -68,8 +68,9 @@ storeSwapMetaBuild(StoreEntry * e)
         return NULL;
     }
 
+    // XXX: do TLV without the c_str() termination. check readers first though
     T = StoreMeta::Add(T, t);
-    t = StoreMeta::Factory(STORE_META_URL, strlen(url) + 1, url);
+    t = StoreMeta::Factory(STORE_META_URL, url.length()+1, url.c_str());
 
     if (!t) {
         storeSwapTLVFree(TLV);
@@ -9,9 +9,11 @@
 #include "squid.h"
 #include "base/CharacterSet.h"
 #include "SBufFindTest.h"
+
 #include <cppunit/extensions/HelperMacros.h>
 #include <cppunit/Message.h>
 #include <limits>
+#include <random>
 
 /* TODO: The whole SBufFindTest class is currently implemented as a single
    CppUnit test case (because we do not want to register and report every one
@@ -22,7 +24,6 @@
 SBufFindTest::SBufFindTest():
     caseLimit(std::numeric_limits<int>::max()),
     errorLimit(std::numeric_limits<int>::max()),
-    randomSeed(1),
     hushSimilar(true),
     maxHayLength(40),
     thePos(0),
@@ -44,8 +45,6 @@ SBufFindTest::SBufFindTest():
 void
 SBufFindTest::run()
 {
-    srandom(randomSeed);
-
     for (SBuf::size_type hayLen = 0U; hayLen <= maxHayLength; nextLen(hayLen, maxHayLength)) {
         const SBuf cleanHay = RandomSBuf(hayLen);
 
@@ -380,19 +379,19 @@ SBufFindTest::RandomSBuf(const int length)
         "0123456789"
         "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
         "abcdefghijklomnpqrstuvwxyz";
+
+    static std::mt19937 mt(time(0));
+
     // sizeof() counts the terminating zero at the end of characters
+    // and the distribution is an 'inclusive' value range, so -2
     // TODO: add \0 character (needs reporting adjustments to print it as \0)
-    static const size_t charCount = sizeof(characters)-1;
-
-    char buf[length];
-    for (int i = 0; i < length; ++i) {
-        const unsigned int pos = random() % charCount;
-        assert(pos < sizeof(characters));
-        assert(characters[pos] > 32);
-        buf[i] = characters[random() % charCount];
-    }
+    static std::uniform_int_distribution<uint8_t> dist(0, sizeof(characters)-2);
 
-    return SBuf(buf, length);
+    SBuf buf;
+    buf.reserveCapacity(length);
+    for (int i = 0; i < length; ++i)
+        buf.append(characters[dist(mt)]);
+    return buf;
 }
 
 /// increments len to quickly cover [0, max] range, slowing down in risky areas
@@ -26,7 +26,6 @@ class SBufFindTest
     /* test configuration parameters; can be optionally set before run() */
     int caseLimit; ///< approximate caseCount limit
     int errorLimit; ///< errorCount limit
-    unsigned int randomSeed; ///< pseudo-random sequence choice
     /// whether to report only one failed test case per "category"
     bool hushSimilar;
     /// approximate maximum generated hay string length
@@ -22,7 +22,6 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_CommIO.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
-	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
 	tests/stub_ETag.cc \
 	tests/stub_event.cc \
@@ -44,6 +43,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
 	tests/stub_libcomm.cc \
+	tests/stub_libdiskio.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
@@ -18,9 +18,9 @@ HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
     STUB_NOP
     HttpReply::~HttpReply() STUB
     void HttpReply::setHeaders(Http::StatusCode status, const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires_) STUB
-    void HttpReply::packHeadersInto(Packer * p) const STUB
+    void HttpReply::packHeadersInto(Packable *) const STUB
     void HttpReply::reset() STUB
-    void httpBodyPackInto(const HttpBody * body, Packer * p) STUB
+    void httpBodyPackInto(const HttpBody *, Packable *) STUB
     bool HttpReply::sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
     int HttpReply::httpMsgParseError() STUB_RETVAL(0)
     bool HttpReply::expectingBody(const HttpRequestMethod&, int64_t&) const STUB_RETVAL(false)
@@ -13,18 +13,49 @@
 #define STUB_API "HttpRequest.cc"
 #include "tests/STUB.h"
 
-HttpRequest::HttpRequest() : HttpMsg(hoRequest) STUB
-    HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) : HttpMsg(hoRequest) STUB
-    HttpRequest::~HttpRequest() STUB
-    void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const STUB
-    bool HttpRequest::sanityCheckStartLine(const char*buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
-    void HttpRequest::hdrCacheInit() STUB
-    void HttpRequest::reset() STUB
-    bool HttpRequest::expectingBody(const HttpRequestMethod& unused, int64_t&) const STUB_RETVAL(false)
-    void HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) STUB
-    bool HttpRequest::parseFirstLine(const char *start, const char *end) STUB_RETVAL(false)
-    HttpRequest * HttpRequest::clone() const STUB_RETVAL(NULL)
-    bool HttpRequest::inheritProperties(const HttpMsg *aMsg) STUB_RETVAL(false)
-    int64_t HttpRequest::getRangeOffsetLimit() STUB_RETVAL(0)
-    const char *HttpRequest::storeId() STUB_RETVAL(".")
+// void httpRequestPack(void *obj, Packable *p);
+
+HttpRequest::HttpRequest() : HttpMsg(hoRequest) {STUB}
+HttpRequest::HttpRequest(const HttpRequestMethod &, AnyP::ProtocolType, const char *) : HttpMsg(hoRequest) {STUB}
+HttpRequest::~HttpRequest() STUB
+void HttpRequest::reset() STUB
+void HttpRequest::initHTTP(const HttpRequestMethod &, AnyP::ProtocolType, const char *) STUB
+HttpRequest * HttpRequest::clone() const STUB_RETVAL(NULL)
+bool HttpRequest::maybeCacheable() STUB_RETVAL(false)
+bool HttpRequest::conditional() const STUB_RETVAL(false)
+bool HttpRequest::canHandle1xx() const STUB_RETVAL(false)
+#if USE_ADAPTATION
+Adaptation::History::Pointer HttpRequest::adaptLogHistory() const STUB_RETVAL(Adaptation::History::Pointer())
+Adaptation::History::Pointer HttpRequest::adaptHistory(bool) const STUB_RETVAL(Adaptation::History::Pointer())
+void HttpRequest::adaptHistoryImport(const HttpRequest &) STUB
+#endif
+#if ICAP_CLIENT
+Adaptation::Icap::History::Pointer HttpRequest::icapHistory() const STUB_RETVAL(Adaptation::Icap::History::Pointer())
+#endif
+void HttpRequest::recordLookup(const Dns::LookupDetails &) STUB
+void HttpRequest::detailError(err_type, int) STUB
+void HttpRequest::clearError() STUB
+void HttpRequest::clean() STUB
+void HttpRequest::init() STUB
+static const SBuf nilSBuf;
+const SBuf &HttpRequest::effectiveRequestUri() const STUB_RETVAL(nilSBuf)
+bool HttpRequest::multipartRangeRequest() const STUB_RETVAL(false)
+bool HttpRequest::parseFirstLine(const char *, const char *) STUB_RETVAL(false)
+bool HttpRequest::parseHeader(Http1::RequestParser &) STUB_RETVAL(false)
+bool HttpRequest::expectingBody(const HttpRequestMethod &, int64_t &) const STUB_RETVAL(false)
+bool HttpRequest::bodyNibbled() const STUB_RETVAL(false)
+int HttpRequest::prefixLen() const STUB_RETVAL(0)
+void HttpRequest::swapOut(StoreEntry *) STUB
+void HttpRequest::pack(Packable *) STUB
+void HttpRequest::httpRequestPack(void *, Packable *) STUB
+HttpRequest * HttpRequest::CreateFromUrlAndMethod(char *, const HttpRequestMethod &) STUB_RETVAL(NULL)
+HttpRequest * HttpRequest::CreateFromUrl(char *) STUB_RETVAL(NULL)
+ConnStateData *HttpRequest::pinnedConnection() STUB_RETVAL(NULL)
+const SBuf HttpRequest::storeId() STUB_RETVAL(SBuf("."))
+void HttpRequest::ignoreRange(const char *) STUB
+int64_t HttpRequest::getRangeOffsetLimit() STUB_RETVAL(0)
+void HttpRequest::packFirstLineInto(Packable *, bool) const STUB
+bool HttpRequest::sanityCheckStartLine(const char *, const size_t, Http::StatusCode *) STUB_RETVAL(false)
+void HttpRequest::hdrCacheInit() STUB
+bool HttpRequest::inheritProperties(const HttpMsg *) STUB_RETVAL(false)
 
@@ -15,7 +15,6 @@
 mb_size_t MemBuf::spaceSize() const STUB_RETVAL(0)
 mb_size_t MemBuf::potentialSpaceSize() const STUB_RETVAL(0)
 void MemBuf::consume(mb_size_t sz) STUB
-void MemBuf::append(const char *c, mb_size_t sz) STUB
 void MemBuf::appended(mb_size_t sz) STUB
 void MemBuf::truncate(mb_size_t sz) STUB
 void MemBuf::terminate() STUB
@@ -24,10 +23,9 @@ void MemBuf::init() STUB
 void MemBuf::clean() STUB
 void MemBuf::reset() STUB
 int MemBuf::isNull() STUB_RETVAL(1)
-void MemBuf::Printf(const char *fmt,...) STUB
-void MemBuf::vPrintf(const char *fmt, va_list ap) STUB
 FREE *MemBuf::freeFunc() STUB_RETVAL(NULL)
+void MemBuf::append(const char *, int) STUB
+void MemBuf::vappendf(const char *fmt, va_list ap) STUB
 
 void memBufReport(MemBuf * mb) STUB
-void packerToMemInit(Packer * p, MemBuf * mb) STUB
 
@@ -15,7 +15,7 @@
 class ClientInfo;
 
 void clientdbInit(void) STUB
-void clientdbUpdate(const Ip::Address &, LogTags, AnyP::ProtocolType, size_t) STUB
+void clientdbUpdate(const Ip::Address &, const LogTags &, AnyP::ProtocolType, size_t) STUB
 int clientdbCutoffDenied(const Ip::Address &) STUB_RETVAL(-1)
 void clientdbDump(StoreEntry *) STUB
 void clientdbFreeMemory(void) STUB
@@ -72,7 +72,7 @@ void ConnStateData::quitAfterError(HttpRequest *request) STUB
 #if USE_OPENSSL
 void ConnStateData::httpsPeeked(Comm::ConnectionPointer serverConnection) STUB
 void ConnStateData::getSslContextStart() STUB
-void ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew) STUB
+void ConnStateData::getSslContextDone(Security::ContextPointer, bool) STUB
 void ConnStateData::sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply) STUB
 void ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply) STUB
 void ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode) STUB
@@ -16,9 +16,8 @@ void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data) S
 void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver) STUB
 helper::~helper() STUB
 CBDATA_CLASS_INIT(helper);
+void helper::packStatsInto(Packable *p, const char *label) const STUB
 
-void helperStats(StoreEntry * sentry, helper * hlp, const char *label) STUB
-void helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label) STUB
 void helperShutdown(helper * hlp) STUB
 void helperStatefulShutdown(statefulhelper * hlp) STUB
 void helperOpenServers(helper * hlp) STUB
@@ -8,18 +8,29 @@
 
 #include "squid.h"
 
-#define STUB_API "DiskIOModule.cc"
+#define STUB_API "DiskIO/libdiskio.la"
 #include "tests/STUB.h"
 
-#include "DiskIO/DiskIOModule.h"
-
 #include <vector>
 
+// #include "DiskIO/DiskFile.h"
+#include "DiskIO/DiskIOModule.h"
 void DiskIOModule::SetupAllModules() STUB
 void DiskIOModule::ModuleAdd(DiskIOModule &) STUB
 void DiskIOModule::FreeAllModules() STUB
-void DiskIOModule::PokeAllModules() STUB
 DiskIOModule *DiskIOModule::Find(char const *) STUB_RETVAL(NULL)
 DiskIOModule *DiskIOModule::FindDefault() STUB_RETVAL(NULL)
 std::vector<DiskIOModule*> const &DiskIOModule::Modules() STUB_RETSTATREF(std::vector<DiskIOModule*>)
+DiskIOModule::DiskIOModule() {STUB}
+DiskIOModule::DiskIOModule(DiskIOModule const &) {STUB}
+DiskIOModule &DiskIOModule::operator=(DiskIOModule const&) STUB
+void DiskIOModule::RegisterAllModulesWithCacheManager() STUB
+
+// #include "DiskIO/DiskIOStrategy.h"
+// #include "DiskIO/DiskIORequestor.h"
+#include "DiskIO/ReadRequest.h"
+ReadRequest::ReadRequest(char *, off_t, size_t) {STUB}
+
+#include "DiskIO/WriteRequest.h"
+WriteRequest::WriteRequest(char const *, off_t, size_t, FREE *) {STUB}
 
@@ -30,7 +30,7 @@ void netdbDump(StoreEntry *) STUB
 void netdbFreeMemory(void) STUB
 int netdbHostHops(const char *host) STUB_RETVAL(-1)
 int netdbHostRtt(const char *host) STUB_RETVAL(-1)
-void netdbUpdatePeer(HttpRequest *, CachePeer * e, int rtt, int hops) STUB
+void netdbUpdatePeer(const URL &, CachePeer * e, int rtt, int hops) STUB
 void netdbDeleteAddrNetwork(Ip::Address &addr) STUB
 void netdbBinaryExchange(StoreEntry *) STUB
 void netdbExchangeStart(void *) STUB
@@ -19,6 +19,10 @@ std::ostream &Security::operator <<(std::ostream &os, const Security::EncryptorA
 #include "security/PeerOptions.h"
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
-Security::ContextPointer Security::PeerOptions::createContext(bool) STUB_RETVAL(NULL)
+Security::ContextPointer Security::PeerOptions::createClientContext(bool) STUB_RETVAL(NULL)
+void Security::PeerOptions::updateTlsVersionLimits() STUB
+void Security::PeerOptions::dumpCfg(Packable*, char const*) const STUB
+long Security::PeerOptions::parseOptions() STUB_RETVAL(0)
+long Security::PeerOptions::parseFlags() STUB_RETVAL(0)
 void parse_securePeerOptions(Security::PeerOptions *) STUB
 
@@ -57,7 +57,7 @@ bool CertError::operator == (const CertError &ce) const STUB_RETVAL(false)
 bool CertError::operator != (const CertError &ce) const STUB_RETVAL(false)
 } // namespace Ssl
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port) STUB_RETVAL(NULL)
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile) STUB_RETVAL(NULL)
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
 void ssl_shutdown_method(SSL *ssl) STUB
@@ -72,11 +72,8 @@ namespace Ssl
 //GETX509ATTRIBUTE GetX509CAAttribute;
 //GETX509ATTRIBUTE GetX509Fingerprint;
 const char *BumpModeStr[] = {""};
-long parse_flags(const char *flags) STUB_RETVAL(0)
-long parse_options(const char *options) STUB_RETVAL(0)
 STACK_OF(X509_CRL) *loadCrl(const char *CRLFile, long &flags) STUB_RETVAL(NULL)
 DH *readDHParams(const char *dhfile) STUB_RETVAL(NULL)
-ContextMethod contextMethod(int version) STUB_RETVAL(ContextMethod())
 bool generateUntrustedCert(X509_Pointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey) STUB_RETVAL(false)
 SSL_CTX * generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port) STUB_RETVAL(NULL)
 bool verifySslCertificate(SSL_CTX * sslContext,  CertificateProperties const &properties) STUB_RETVAL(false)
@@ -91,7 +91,6 @@ void StoreEntry::setReleaseFlag() STUB
 //#if USE_SQUID_ESI
 //ESIElement::Pointer StoreEntry::cachedESITree STUB_RETVAL(NULL)
 //#endif
-void StoreEntry::append(char const *, int len) STUB
 void StoreEntry::buffer() STUB
 void StoreEntry::flush() STUB
 int StoreEntry::unlock(const char *) STUB_RETVAL(0)
@@ -100,6 +99,8 @@ int64_t StoreEntry::contentLen() const STUB_RETVAL(0)
 void StoreEntry::lock(const char *) STUB
 void StoreEntry::touch() STUB
 void StoreEntry::release() STUB
+void StoreEntry::append(char const *, int) STUB
+void StoreEntry::vappendf(const char *, va_list) STUB
 
 NullStoreEntry *NullStoreEntry::getInstance() STUB_RETVAL(NULL)
 const char *NullStoreEntry::getMD5Text() const STUB_RETVAL(NULL)
@@ -142,6 +143,5 @@ void storeFsInit(void) STUB
 void storeFsDone(void) STUB
 void storeReplAdd(const char *, REMOVALPOLICYCREATE *) STUB
 void destroyStoreEntry(void *) STUB
-// in Packer.cc !? void packerToStoreInit(Packer * p, StoreEntry * e) STUB
 void storeGetMemSpace(int size) STUB
 
@@ -46,10 +46,10 @@ testHttpRequest::testCreateFromUrlAndMethod()
     HttpRequest *aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 90;
     HttpRequest *nullRequest = NULL;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
-    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("/bar"), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
@@ -58,10 +58,10 @@ testHttpRequest::testCreateFromUrlAndMethod()
     url = xstrdup("http://foo/bar");
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_PUT);
     expected_port = 80;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_PUT);
-    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("/bar"), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo/bar"), String(url));
     xfree(url);
@@ -76,10 +76,10 @@ testHttpRequest::testCreateFromUrlAndMethod()
     url = xstrdup("foo:45");
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_CONNECT);
     expected_port = 45;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_CONNECT);
-    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String(""), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf(), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("foo:45"), String(url));
     xfree(url);
@@ -96,10 +96,10 @@ testHttpRequest::testCreateFromUrl()
     char * url = xstrdup("http://foo:90/bar");
     HttpRequest *aRequest = HttpRequest::CreateFromUrl(url);
     expected_port = 90;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
-    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("/bar"), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
@@ -119,10 +119,10 @@ testHttpRequest::testIPv6HostColonBug()
     url = xstrdup("http://[2000:800::45]/foo");
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 80;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
-    CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("/foo"), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]/foo"), String(url));
     xfree(url);
@@ -131,10 +131,10 @@ testHttpRequest::testIPv6HostColonBug()
     url = xstrdup("http://[2000:800::45]:90/foo");
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 90;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
-    CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("/foo"), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]:90/foo"), String(url));
     xfree(url);
@@ -143,10 +143,10 @@ testHttpRequest::testIPv6HostColonBug()
     url = xstrdup("http://2000:800::45/foo");
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 80;
-    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
+    CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->url.port());
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
-    CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
-    CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
+    CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->url.host()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("/foo"), aRequest->url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://2000:800::45/foo"), String(url));
     xfree(url);
@@ -201,14 +201,7 @@ testRock::addEntry(const int i)
     StoreEntry *const pe = createEntry(i);
 
     pe->buffer();
-    /* TODO: remove this when the metadata is separated */
-    {
-        Packer p;
-        packerToStoreInit(&p, pe);
-        pe->getReply()->packHeadersInto(&p);
-        packerClean(&p);
-    }
-
+    pe->getReply()->packHeadersInto(pe);
     pe->flush();
     pe->timestampsSet();
     pe->complete();
@@ -10,6 +10,7 @@
 
 #include <cppunit/TestAssert.h>
 
+#include "Debug.h"
 #include "testURL.h"
 #include "unitTestMain.h"
 #include "URL.h"
@@ -152,14 +152,7 @@ testUfs::testUfsSearch()
         pe->setPublicKey();
 
         pe->buffer();
-        /* TODO: remove this when the metadata is separated */
-        {
-            Packer p;
-            packerToStoreInit(&p, pe);
-            pe->getReply()->packHeadersInto(&p);
-            packerClean(&p);
-        }
-
+        pe->getReply()->packHeadersInto(pe);
         pe->flush();
         pe->timestampsSet();
         pe->complete();
@@ -971,14 +971,11 @@ kb_incr(kb_t * k, size_t v)
 void
 debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm)
 {
-    MemBuf mb;
-    Packer p;
     assert(label && obj && pm);
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    (*pm) (obj, &p);
+    (*pm) (obj, &mb);
     debugs(section, level, "" << label << "" << mb.buf << "");
-    packerClean(&p);
     mb.clean();
 }
 
@@ -11,7 +11,6 @@
 #ifndef SQUID_TOOLS_H_
 #define SQUID_TOOLS_H_
 
-#include "Packer.h"
 #include "SBuf.h"
 #include "SquidString.h"
 #include "typedefs.h"
@@ -30,6 +29,11 @@ int getMyPort(void);
 void setUmask(mode_t mask);
 void strwordquote(MemBuf * mb, const char *str);
 
+class Packable;
+
+/* a common objPackInto interface; used by debugObj */
+typedef void (*ObjPackMethod) (void *obj, Packable * p);
+
 /* packs, then prints an object using debugs() */
 void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm);
 
@@ -93,7 +93,7 @@ class TunnelStateData
     Comm::ConnectionList serverDestinations;
 
     const char * getHost() const {
-        return (server.conn != NULL && server.conn->getPeer() ? server.conn->getPeer()->host : request->GetHost());
+        return (server.conn != NULL && server.conn->getPeer() ? server.conn->getPeer()->host : request->url.host());
     };
 
     /// Whether we are writing a CONNECT request to a peer.
@@ -114,6 +114,10 @@ class TunnelStateData
                  (request->flags.interceptTproxy || request->flags.intercepted));
     }
 
+    /// Sends "502 Bad Gateway" error response to the client,
+    /// if it is waiting for Squid CONNECT response, closing connections.
+    void informUserOfPeerError(const char *errMsg);
+
     class Connection
     {
 
@@ -132,12 +136,13 @@ class TunnelStateData
 
         void error(int const xerrno);
         int debugLevelForError(int const xerrno) const;
-        /// handles a non-I/O error associated with this Connection
-        void logicError(const char *errMsg);
         void closeIfOpen();
         void dataSent (size_t amount);
+        /// writes 'b' buffer, setting the 'writer' member to 'callback'.
+        void write(const char *b, int size, AsyncCall::Pointer &callback, FREE * free_func);
         int len;
         char *buf;
+        AsyncCall::Pointer writer; ///< pending Comm::Write callback
         int64_t *size_ptr;      /* pointer to size in an ConnStateData for logging */
 
         Comm::ConnectionPointer conn;    ///< The currently connected connection.
@@ -160,6 +165,7 @@ class TunnelStateData
     MemBuf *connectRespBuf; ///< accumulates peer CONNECT response when we need it
     bool connectReqWriting; ///< whether we are writing a CONNECT request to a peer
     SBuf preReadClientData;
+    time_t started;         ///< when this tunnel was initiated.
 
     void copyRead(Connection &from, IOCB *completion);
 
@@ -230,6 +236,7 @@ tunnelServerClosed(const CommCloseCbParams &params)
     TunnelStateData *tunnelState = (TunnelStateData *)params.data;
     debugs(26, 3, HERE << tunnelState->server.conn);
     tunnelState->server.conn = NULL;
+    tunnelState->server.writer = NULL;
 
     if (tunnelState->request != NULL)
         tunnelState->request->hier.stopPeerClock(false);
@@ -239,7 +246,7 @@ tunnelServerClosed(const CommCloseCbParams &params)
         return;
     }
 
-    if (!tunnelState->server.len) {
+    if (!tunnelState->client.writer) {
         tunnelState->client.conn->close();
         return;
     }
@@ -251,13 +258,14 @@ tunnelClientClosed(const CommCloseCbParams &params)
     TunnelStateData *tunnelState = (TunnelStateData *)params.data;
     debugs(26, 3, HERE << tunnelState->client.conn);
     tunnelState->client.conn = NULL;
+    tunnelState->client.writer = NULL;
 
     if (tunnelState->noConnections()) {
         delete tunnelState;
         return;
     }
 
-    if (!tunnelState->client.len) {
+    if (!tunnelState->server.writer) {
         tunnelState->server.conn->close();
         return;
     }
@@ -270,7 +278,8 @@ TunnelStateData::TunnelStateData() :
     status_ptr(NULL),
     logTag_ptr(NULL),
     connectRespBuf(NULL),
-    connectReqWriting(false)
+    connectReqWriting(false),
+    started(squid_curtime)
 {
     debugs(26, 3, "TunnelStateData constructed this=" << this);
     client.readPendingFunc = &tunnelDelayedClientRead;
@@ -388,6 +397,23 @@ TunnelStateData::readConnectResponseDone(char *, size_t len, Comm::Flag errcode,
         handleConnectResponse(len);
 }
 
+void
+TunnelStateData::informUserOfPeerError(const char *errMsg)
+{
+    server.len = 0;
+    if (!clientExpectsConnectResponse()) {
+        // closing the connection is the best we can do here
+        debugs(50, 3, server.conn << " closing on error: " << errMsg);
+        server.conn->close();
+        return;
+    }
+    ErrorState *err  = new ErrorState(ERR_CONNECT_FAIL, Http::scBadGateway, request.getRaw());
+    err->callback = tunnelErrorComplete;
+    err->callback_data = this;
+    *status_ptr = Http::scBadGateway;
+    errorSend(http->getConn()->clientConnection, err);
+}
+
 /* Read from client side and queue it for writing to the server */
 void
 TunnelStateData::ReadConnectResponseDone(const Comm::ConnectionPointer &, char *buf, size_t len, Comm::Flag errcode, int xerrno, void *data)
@@ -420,7 +446,7 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
     const bool parsed = rep.parse(connectRespBuf->content(), connectRespBuf->contentSize(), eof, &parseErr);
     if (!parsed) {
         if (parseErr > 0) { // unrecoverable parsing error
-            server.logicError("malformed CONNECT response from peer");
+            informUserOfPeerError("malformed CONNECT response from peer");
             return;
         }
 
@@ -429,7 +455,7 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
         assert(!parseErr);
 
         if (!connectRespBuf->hasSpace()) {
-            server.logicError("huge CONNECT response from peer");
+            informUserOfPeerError("huge CONNECT response from peer");
             return;
         }
 
@@ -443,7 +469,8 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
 
     // bail if we did not get an HTTP 200 (Connection Established) response
     if (rep.sline.status() != Http::scOkay) {
-        server.logicError("unsupported CONNECT response status code");
+        // if we ever decide to reuse the peer connection, we must extract the error response first
+        informUserOfPeerError("unsupported CONNECT response status code");
         return;
     }
 
@@ -461,13 +488,6 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
     connectExchangeCheckpoint();
 }
 
-void
-TunnelStateData::Connection::logicError(const char *errMsg)
-{
-    debugs(50, 3, conn << " closing on error: " << errMsg);
-    conn->close();
-}
-
 void
 TunnelStateData::Connection::error(int const xerrno)
 {
@@ -564,7 +584,7 @@ TunnelStateData::copy(size_t len, Connection &from, Connection &to, IOCB *comple
     debugs(26, 3, HERE << "Schedule Write");
     AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
                                          CommIoCbPtrFun(completion, this));
-    Comm::Write(to.conn, from.buf, len, call, NULL);
+    to.write(from.buf, len, call, NULL);
 }
 
 /* Writes data from the client buffer to the server side */
@@ -573,6 +593,7 @@ TunnelStateData::WriteServerDone(const Comm::ConnectionPointer &, char *buf, siz
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     assert (cbdataReferenceValid (tunnelState));
+    tunnelState->server.writer = NULL;
 
     tunnelState->writeServerDone(buf, len, flag, xerrno);
 }
@@ -622,6 +643,7 @@ TunnelStateData::WriteClientDone(const Comm::ConnectionPointer &, char *buf, siz
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     assert (cbdataReferenceValid (tunnelState));
+    tunnelState->client.writer = NULL;
 
     tunnelState->writeClientDone(buf, len, flag, xerrno);
 }
@@ -638,6 +660,13 @@ TunnelStateData::Connection::dataSent(size_t amount)
         *size_ptr += amount;
 }
 
+void
+TunnelStateData::Connection::write(const char *b, int size, AsyncCall::Pointer &callback, FREE * free_func)
+{
+    writer = callback;
+    Comm::Write(conn, b, size, callback, free_func);
+}
+
 void
 TunnelStateData::writeClientDone(char *, size_t len, Comm::Flag flag, int xerrno)
 {
@@ -806,6 +835,7 @@ tunnelConnectedWriteDone(const Comm::ConnectionPointer &conn, char *, size_t, Co
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << conn << ", flag=" << flag);
+    tunnelState->client.writer = NULL;
 
     if (flag != Comm::OK) {
         *tunnelState->status_ptr = Http::scInternalServerError;
@@ -822,6 +852,7 @@ tunnelConnectReqWriteDone(const Comm::ConnectionPointer &conn, char *, size_t, C
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, conn << ", flag=" << flag);
+    tunnelState->server.writer = NULL;
     assert(tunnelState->waitingForConnectRequest());
 
     if (flag != Comm::OK) {
@@ -862,7 +893,7 @@ tunnelConnected(const Comm::ConnectionPointer &server, void *data)
     else {
         AsyncCall::Pointer call = commCbCall(5,5, "tunnelConnectedWriteDone",
                                              CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
-        Comm::Write(tunnelState->client.conn, conn_established, strlen(conn_established), call, NULL);
+        tunnelState->client.write(conn_established, strlen(conn_established), call, NULL);
     }
 }
 
@@ -892,13 +923,20 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int xe
         /* At this point only the TCP handshake has failed. no data has been passed.
          * we are allowed to re-try the TCP-level connection to alternate IPs for CONNECT.
          */
+        debugs(26, 4, "removing server 1 of " << tunnelState->serverDestinations.size() <<
+               " from destinations (" << tunnelState->serverDestinations[0] << ")");
         tunnelState->serverDestinations.erase(tunnelState->serverDestinations.begin());
-        if (status != Comm::TIMEOUT && tunnelState->serverDestinations.size() > 0) {
+        time_t fwdTimeout = tunnelState->started + Config.Timeout.forward;
+        if (fwdTimeout > squid_curtime && tunnelState->serverDestinations.size() > 0) {
+            // find remaining forward_timeout available for this attempt
+            fwdTimeout -= squid_curtime;
+            if (fwdTimeout > Config.Timeout.connect)
+                fwdTimeout = Config.Timeout.connect;
             /* Try another IP of this destination host */
             GetMarkingsToServer(tunnelState->request.getRaw(), *tunnelState->serverDestinations[0]);
             debugs(26, 4, HERE << "retry with : " << tunnelState->serverDestinations[0]);
             AsyncCall::Pointer call = commCbCall(26,3, "tunnelConnectDone", CommConnectCbPtrFun(tunnelConnectDone, tunnelState));
-            Comm::ConnOpener *cs = new Comm::ConnOpener(tunnelState->serverDestinations[0], call, Config.Timeout.connect);
+            Comm::ConnOpener *cs = new Comm::ConnOpener(tunnelState->serverDestinations[0], call, fwdTimeout);
             cs->setHost(tunnelState->url);
             AsyncJob::Start(cs);
         } else {
@@ -998,6 +1036,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
     tunnelState->client.conn = http->getConn()->clientConnection;
     tunnelState->http = http;
     tunnelState->al = al;
+    //tunnelState->started is set in TunnelStateData ctor
 
     comm_add_close_handler(tunnelState->client.conn->fd,
                            tunnelClientClosed,
@@ -1055,51 +1094,40 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     assert(!tunnelState->waitingForConnectExchange());
     HttpHeader hdr_out(hoRequest);
-    Packer p;
     HttpStateFlags flags;
     debugs(26, 3, HERE << srv << ", tunnelState=" << tunnelState);
     memset(&flags, '\0', sizeof(flags));
     flags.proxying = tunnelState->request->flags.proxying;
     MemBuf mb;
     mb.init();
-    mb.Printf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
+    mb.appendf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
     HttpStateData::httpBuildRequestHeader(tunnelState->request.getRaw(),
                                           NULL,         /* StoreEntry */
                                           tunnelState->al,          /* AccessLogEntry */
                                           &hdr_out,
                                           flags);           /* flags */
-    packerToMemInit(&p, &mb);
-    hdr_out.packInto(&p);
+    hdr_out.packInto(&mb);
     hdr_out.clean();
-    packerClean(&p);
     mb.append("\r\n", 2);
 
     debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn << ":\n----------\n" <<
            Raw("tunnelRelayConnectRequest", mb.content(), mb.contentSize()) << "\n----------");
 
-    if (tunnelState->clientExpectsConnectResponse()) {
-        // hack: blindly tunnel peer response (to our CONNECT request) to the client as ours.
-        AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
-                                       CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
-        Comm::Write(srv, &mb, writeCall);
-    } else {
-        // we have to eat the connect response from the peer (so that the client
-        // does not see it) and only then start shoveling data to the client
-        AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectReqWriteDone",
-                                       CommIoCbPtrFun(tunnelConnectReqWriteDone,
-                                               tunnelState));
-        Comm::Write(srv, &mb, writeCall);
-        tunnelState->connectReqWriting = true;
-
-        tunnelState->connectRespBuf = new MemBuf;
-        // SQUID_TCP_SO_RCVBUF: we should not accumulate more than regular I/O buffer
-        // can hold since any CONNECT response leftovers have to fit into server.buf.
-        // 2*SQUID_TCP_SO_RCVBUF: HttpMsg::parse() zero-terminates, which uses space.
-        tunnelState->connectRespBuf->init(SQUID_TCP_SO_RCVBUF, 2*SQUID_TCP_SO_RCVBUF);
-        tunnelState->readConnectResponse();
-
-        assert(tunnelState->waitingForConnectExchange());
-    }
+    AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectReqWriteDone",
+                                   CommIoCbPtrFun(tunnelConnectReqWriteDone,
+                                           tunnelState));
+
+    tunnelState->server.write(mb.buf, mb.size, writeCall, mb.freeFunc());
+    tunnelState->connectReqWriting = true;
+
+    tunnelState->connectRespBuf = new MemBuf;
+    // SQUID_TCP_SO_RCVBUF: we should not accumulate more than regular I/O buffer
+    // can hold since any CONNECT response leftovers have to fit into server.buf.
+    // 2*SQUID_TCP_SO_RCVBUF: HttpMsg::parse() zero-terminates, which uses space.
+    tunnelState->connectRespBuf->init(SQUID_TCP_SO_RCVBUF, 2*SQUID_TCP_SO_RCVBUF);
+    tunnelState->readConnectResponse();
+
+    assert(tunnelState->waitingForConnectExchange());
 
     AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "tunnelTimeout",
                                      CommTimeoutCbPtrFun(tunnelTimeout, tunnelState));
@@ -1162,14 +1190,14 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     debugs(26,5, "Revert to tunnel FD " << clientConn->fd << " with FD " << srvConn->fd);
     /* Create state structure. */
     TunnelStateData *tunnelState = NULL;
-    const char *url = urlCanonical(request);
+    const SBuf url(request->effectiveRequestUri());
 
     debugs(26, 3, request->method << " " << url << " " << request->http_ver);
     ++statCounter.server.all.requests;
     ++statCounter.server.other.requests;
 
     tunnelState = new TunnelStateData;
-    tunnelState->url = xstrdup(url);
+    tunnelState->url = xstrndup(url.rawContent(), url.length()+1);
     tunnelState->request = request;
     tunnelState->server.size_ptr = NULL; //Set later if ClientSocketContext is available
 
@@ -1224,15 +1252,15 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     fd_table[srvConn->fd].read_method = &default_read_method;
     fd_table[srvConn->fd].write_method = &default_write_method;
 
-    SSL *ssl = fd_table[srvConn->fd].ssl;
+    auto ssl = fd_table[srvConn->fd].ssl;
     assert(ssl);
     BIO *b = SSL_get_rbio(ssl);
     Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
     const MemBuf &buf = srvBio->rBufData();
 
     AsyncCall::Pointer call = commCbCall(5,5, "tunnelConnectedWriteDone",
                                          CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
-    Comm::Write(tunnelState->client.conn, buf.content(), buf.contentSize(), call, NULL);
+    tunnelState->client.write(buf.content(), buf.contentSize(), call, NULL);
 }
 #endif //USE_OPENSSL
 
@@ -12,6 +12,8 @@
 
 #include "squid.h"
 
+#include <iostream>
+#include <cstdio>
 #if HAVE_PATHS_H
 #include <paths.h>
 #endif
@@ -49,24 +51,18 @@
 int
 main(int, char *[])
 {
-    char buf[UNLINK_BUF_LEN];
-    char *t;
-    int x;
-    setbuf(stdin, NULL);
-    setbuf(stdout, NULL);
+    std::string sbuf;
     close(2);
     if (open(_PATH_DEVNULL, O_RDWR) < 0) {
         ; // the irony of having to close(2) earlier is that we cannot report this failure.
     }
-
-    while (fgets(buf, sizeof(buf), stdin)) {
-        if ((t = strchr(buf, '\n')))
-            *t = '\0';
-        x = unlink(buf);
-        if (x < 0)
-            printf("ERR\n");
+    while (getline(std::cin, sbuf)) {
+        // tailing newline is removed by getline
+        const int rv = remove(sbuf.c_str());
+        if (rv < 0)
+            std::cout << "ERR" << std::endl; // endl flushes
         else
-            printf("OK\n");
+            std::cout << "OK" << std::endl;
     }
 
     return 0;
@@ -44,6 +44,41 @@ URL::Asterisk()
     return star;
 }
 
+const SBuf &
+URL::SlashPath()
+{
+    static SBuf slash("/");
+    return slash;
+}
+
+void
+URL::host(const char *src)
+{
+    hostAddr_.setEmpty();
+    hostAddr_ = src;
+    if (hostAddr_.isAnyAddr()) {
+        xstrncpy(host_, src, sizeof(host_));
+        hostIsNumeric_ = false;
+    } else {
+        hostAddr_.toHostStr(host_, sizeof(host_));
+        debugs(23, 3, "given IP: " << hostAddr_);
+        hostIsNumeric_ = 1;
+    }
+    touch();
+}
+
+const SBuf &
+URL::path() const
+{
+    // RFC 3986 section 3.3 says path can be empty (path-abempty).
+    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to "/"
+    // at least when sending and using. We must still accept path-abempty as input.
+    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))
+        return SlashPath();
+
+    return path_;
+}
+
 void
 urlInitialize(void)
 {
@@ -133,43 +168,6 @@ urlParseProtocol(const char *b, const char *e)
     return AnyP::PROTO_NONE;
 }
 
-int
-urlDefaultPort(AnyP::ProtocolType p)
-{
-    switch (p) {
-
-    case AnyP::PROTO_HTTP:
-        return 80;
-
-    case AnyP::PROTO_HTTPS:
-        return 443;
-
-    case AnyP::PROTO_FTP:
-        return 21;
-
-    case AnyP::PROTO_COAP:
-    case AnyP::PROTO_COAPS:
-        // coaps:// default is TBA as of draft-ietf-core-coap-08.
-        // Assuming IANA policy of allocating same port for base and TLS protocol versions will occur.
-        return 5683;
-
-    case AnyP::PROTO_GOPHER:
-        return 70;
-
-    case AnyP::PROTO_WAIS:
-        return 210;
-
-    case AnyP::PROTO_CACHE_OBJECT:
-        return CACHE_HTTP_PORT;
-
-    case AnyP::PROTO_WHOIS:
-        return 43;
-
-    default:
-        return 0;
-    }
-}
-
 /*
  * Parse a URI/URL.
  *
@@ -224,7 +222,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
     } else if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &&
                URL::Asterisk().cmp(url) == 0) {
         protocol = AnyP::PROTO_HTTP;
-        port = urlDefaultPort(protocol);
+        port = AnyP::UriScheme(protocol).defaultPort();
         return urlParseFinish(method, protocol, url, host, SBuf(), port, request);
     } else if (!strncmp(url, "urn:", 4)) {
         return urnParse(method, url, request);
@@ -286,7 +284,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         *dst = '\0';
 
         protocol = urlParseProtocol(proto);
-        port = urlDefaultPort(protocol);
+        port = AnyP::UriScheme(protocol).defaultPort();
 
         /* Is there any login information? (we should eventually parse it above) */
         t = strrchr(host, '@');
@@ -451,12 +449,11 @@ urlParseFinish(const HttpRequestMethod& method,
         request = new HttpRequest(method, protocol, urlpath);
     else {
         request->initHTTP(method, protocol, urlpath);
-        safe_free(request->canonical);
     }
 
-    request->SetHost(host);
+    request->url.host(host);
     request->url.userInfo(login);
-    request->port = (unsigned short) port;
+    request->url.port(port);
     return request;
 }
 
@@ -466,93 +463,82 @@ urnParse(const HttpRequestMethod& method, char *urn, HttpRequest *request)
     debugs(50, 5, "urnParse: " << urn);
     if (request) {
         request->initHTTP(method, AnyP::PROTO_URN, urn + 4);
-        safe_free(request->canonical);
         return request;
     }
 
     return new HttpRequest(method, AnyP::PROTO_URN, urn + 4);
 }
 
-const char *
-urlCanonical(HttpRequest * request)
+void
+URL::touch()
 {
-    LOCAL_ARRAY(char, portbuf, 32);
-    LOCAL_ARRAY(char, urlbuf, MAX_URL);
-
-    if (request->canonical)
-        return request->canonical;
+    absolute_.clear();
+    authorityHttp_.clear();
+    authorityWithPort_.clear();
+}
 
-    if (request->url.getScheme() == AnyP::PROTO_URN) {
-        snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
-                 SQUIDSTRINGPRINT(request->urlpath));
-    } else {
-        switch (request->method.id()) {
+SBuf &
+URL::authority(bool requirePort) const
+{
+    if (authorityHttp_.isEmpty()) {
 
-        case Http::METHOD_CONNECT:
-            snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
-            break;
+        // both formats contain Host/IP
+        authorityWithPort_.append(host());
+        authorityHttp_ = authorityWithPort_;
 
-        default: {
-            portbuf[0] = '\0';
+        // authorityForm_ only has :port if it is non-default
+        authorityWithPort_.appendf(":%u",port());
+        if (port() != getScheme().defaultPort())
+            authorityHttp_ = authorityWithPort_;
+    }
 
-            if (request->port != urlDefaultPort(request->url.getScheme()))
-                snprintf(portbuf, 32, ":%d", request->port);
+    return requirePort ? authorityWithPort_ : authorityHttp_;
+}
 
-            snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s%s" SQUIDSTRINGPH,
-                     request->url.getScheme().c_str(),
-                     SQUIDSBUFPRINT(request->url.userInfo()),
-                     !request->url.userInfo().isEmpty() ? "@" : "",
-                     request->GetHost(),
-                     portbuf,
-                     SQUIDSTRINGPRINT(request->urlpath));
-        }
+SBuf &
+URL::absolute() const
+{
+    if (absolute_.isEmpty()) {
+        // TODO: most URL will be much shorter, avoid allocating this much
+        absolute_.reserveCapacity(MAX_URL);
+
+        absolute_.appendf("%s:", getScheme().c_str());
+        if (getScheme() != AnyP::PROTO_URN) {
+            absolute_.append("//", 2);
+            const bool omitUserInfo = getScheme() == AnyP::PROTO_HTTP ||
+                                      getScheme() != AnyP::PROTO_HTTPS ||
+                                      userInfo().isEmpty();
+            if (!omitUserInfo) {
+                absolute_.append(userInfo());
+                absolute_.append("@", 1);
+            }
+            absolute_.append(authority());
         }
+        absolute_.append(path());
     }
 
-    return (request->canonical = xstrdup(urlbuf));
+    return absolute_;
 }
 
-/** \todo AYJ: Performance: This is an *almost* duplicate of urlCanonical. But elides the query-string.
+/** \todo AYJ: Performance: This is an *almost* duplicate of HttpRequest::effectiveRequestUri(). But elides the query-string.
  *        After copying it on in the first place! Would be less code to merge the two with a flag parameter.
  *        and never copy the query-string part in the first place
  */
 char *
 urlCanonicalClean(const HttpRequest * request)
 {
     LOCAL_ARRAY(char, buf, MAX_URL);
-    LOCAL_ARRAY(char, portbuf, 32);
-    char *t;
-
-    if (request->url.getScheme() == AnyP::PROTO_URN) {
-        snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
-                 SQUIDSTRINGPRINT(request->urlpath));
-    } else {
-        switch (request->method.id()) {
 
-        case Http::METHOD_CONNECT:
-            snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
-            break;
+    snprintf(buf, sizeof(buf), SQUIDSBUFPH, SQUIDSBUFPRINT(request->effectiveRequestUri()));
+    buf[sizeof(buf)-1] = '\0';
 
-        default: {
-            portbuf[0] = '\0';
-
-            if (request->port != urlDefaultPort(request->url.getScheme()))
-                snprintf(portbuf, 32, ":%d", request->port);
-
-            snprintf(buf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s%s" SQUIDSTRINGPH,
-                     request->url.getScheme().c_str(),
-                     SQUIDSBUFPRINT(request->url.userInfo()),
-                     (request->url.userInfo().isEmpty() ? "" : "@"),
-                     request->GetHost(),
-                     portbuf,
-                     SQUIDSTRINGPRINT(request->urlpath));
-
-            // strip arguments AFTER a question-mark
-            if (Config.onoff.strip_query_terms)
-                if ((t = strchr(buf, '?')))
-                    *(++t) = '\0';
+    // URN, CONNECT method, and non-stripped URIs can go straight out
+    if (Config.onoff.strip_query_terms && !(request->method == Http::METHOD_CONNECT || request->url.getScheme() == AnyP::PROTO_URN)) {
+        // strip anything AFTER a question-mark
+        // leaving the '?' in place
+        if (auto t = strchr(buf, '?')) {
+            *(++t) = '\0';
         }
-        } // switch
     }
 
     if (stringHasCntl(buf))
@@ -573,8 +559,8 @@ urlCanonicalFakeHttps(const HttpRequest * request)
     LOCAL_ARRAY(char, buf, MAX_URL);
 
     // method CONNECT and port HTTPS
-    if (request->method == Http::METHOD_CONNECT && request->port == 443) {
-        snprintf(buf, MAX_URL, "https://%s/*", request->GetHost());
+    if (request->method == Http::METHOD_CONNECT && request->url.port() == 443) {
+        snprintf(buf, MAX_URL, "https://%s/*", request->url.host());
         return buf;
     }
 
@@ -632,50 +618,46 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
     if (req->url.getScheme() == AnyP::PROTO_URN) {
-        snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
-                 SQUIDSTRINGPRINT(req->urlpath));
+        // XXX: this is what the original code did, but it seems to break the
+        // intended behaviour of this function. It returns the stored URN path,
+        // not converting the given one into a URN...
+        snprintf(urlbuf, MAX_URL, SQUIDSBUFPH, SQUIDSBUFPRINT(req->url.absolute()));
         return (urlbuf);
     }
 
-    size_t urllen;
-
-    if (req->port != urlDefaultPort(req->url.getScheme())) {
-        urllen = snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s:%d",
-                          req->url.getScheme().c_str(),
-                          SQUIDSBUFPRINT(req->url.userInfo()),
-                          !req->url.userInfo().isEmpty() ? "@" : "",
-                          req->GetHost(),
-                          req->port
-                         );
-    } else {
-        urllen = snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s",
-                          req->url.getScheme().c_str(),
-                          SQUIDSBUFPRINT(req->url.userInfo()),
-                          !req->url.userInfo().isEmpty() ? "@" : "",
-                          req->GetHost()
-                         );
-    }
-
+    SBuf authorityForm = req->url.authority(); // host[:port]
+    size_t urllen = snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s" SQUIDSBUFPH,
+                             req->url.getScheme().c_str(),
+                             SQUIDSBUFPRINT(req->url.userInfo()),
+                             !req->url.userInfo().isEmpty() ? "@" : "",
+                             SQUIDSBUFPRINT(authorityForm));
+
+    // if the first char is '/' assume its a relative path
+    // XXX: this breaks on scheme-relative URLs,
+    // but we should not see those outside ESI, and rarely there.
+    // XXX: also breaks on any URL containing a '/' in the query-string portion
     if (relUrl[0] == '/') {
-        strncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
+        xstrncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
     } else {
-        const char *path = req->urlpath.termedBuf();
-        const char *last_slash = strrchr(path, '/');
+        SBuf path = req->url.path();
+        SBuf::size_type lastSlashPos = path.rfind('/');
 
-        if (last_slash == NULL) {
+        if (lastSlashPos == SBuf::npos) {
+            // replace the whole path with the given bit(s)
             urlbuf[urllen] = '/';
             ++urllen;
-            strncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
+            xstrncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
         } else {
-            ++last_slash;
-            size_t pathlen = last_slash - path;
-            if (pathlen > MAX_URL - urllen - 1) {
-                pathlen = MAX_URL - urllen - 1;
+            // replace only the last (file?) segment with the given bit(s)
+            ++lastSlashPos;
+            if (lastSlashPos > MAX_URL - urllen - 1) {
+                // XXX: crops bits in the middle of the combined URL.
+                lastSlashPos = MAX_URL - urllen - 1;
             }
-            strncpy(&urlbuf[urllen], path, pathlen);
-            urllen += pathlen;
+            xstrncpy(&urlbuf[urllen], path.rawContent(), lastSlashPos);
+            urllen += lastSlashPos;
             if (urllen + 1 < MAX_URL) {
-                strncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
+                xstrncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
             }
         }
     }
@@ -786,7 +768,7 @@ urlCheckRequest(const HttpRequest * r)
     // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)
     // we also support forwarding OPTIONS and TRACE, except for the *-URI ones
     if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)
-        return (r->header.getInt64(HDR_MAX_FORWARDS) == 0 || URL::Asterisk().cmp(r->urlpath.rawBuf(), r->urlpath.size()) != 0);
+        return (r->header.getInt64(HDR_MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
 
     if (r->method == Http::METHOD_PURGE)
         return 1;
@@ -35,11 +35,8 @@ class UrnState : public StoreClient
 public:
     void created (StoreEntry *newEntry);
     void start (HttpRequest *, StoreEntry *);
-    char *getHost (String &urlpath);
+    char *getHost(const SBuf &urlpath);
     void setUriResFromRequest(HttpRequest *);
-    bool RequestNeedsMenu(HttpRequest *r);
-    void updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len);
-    void createUriResRequest (String &uri);
 
     virtual ~UrnState();
 
@@ -128,60 +125,38 @@ urnFindMinRtt(url_entry * urls, const HttpRequestMethod &, int *rtt_ret)
 }
 
 char *
-UrnState::getHost (String &urlpath)
+UrnState::getHost(const SBuf &urlpath)
 {
     char * result;
     size_t p;
 
     /** FIXME: this appears to be parsing the URL. *very* badly. */
     /*   a proper encapsulated URI/URL type needs to clear this up. */
-    if ((p=urlpath.find(':')) != String::npos) {
-        result=xstrndup(urlpath.rawBuf(),p-1);
+    if ((p = urlpath.find(':')) != SBuf::npos) {
+        result = xstrndup(urlpath.rawContent(), p-1);
     } else {
-        result = xstrndup(urlpath.rawBuf(),urlpath.size());
+        result = xstrndup(urlpath.rawContent(), urlpath.length());
     }
     return result;
 }
 
-bool
-UrnState::RequestNeedsMenu(HttpRequest *r)
-{
-    if (r->urlpath.size() < 5)
-        return false;
-    //now we're sure it's long enough
-    return strncasecmp(r->urlpath.rawBuf(), "menu.", 5) == 0;
-}
-
 void
-UrnState::updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len)
+UrnState::setUriResFromRequest(HttpRequest *r)
 {
-    char *new_path = xstrndup (newPath, newPath_len);
-    r->urlpath = new_path;
-    xfree(new_path);
-}
+    static const SBuf menu(".menu");
+    if (r->url.path().startsWith(menu)) {
+        r->url.path(r->url.path().substr(5)); // strip prefix "menu."
+        flags.force_menu = true;
+    }
 
-void
-UrnState::createUriResRequest (String &uri)
-{
+    SBuf uri = r->url.path();
     LOCAL_ARRAY(char, local_urlres, 4096);
-    char *host = getHost (uri);
-    snprintf(local_urlres, 4096, "http://%s/uri-res/N2L?urn:" SQUIDSTRINGPH,
-             host, SQUIDSTRINGPRINT(uri));
+    char *host = getHost(uri);
+    snprintf(local_urlres, 4096, "http://%s/uri-res/N2L?urn:" SQUIDSBUFPH, host, SQUIDSBUFPRINT(uri));
     safe_free(host);
     safe_free(urlres);
     urlres = xstrdup(local_urlres);
     urlres_r = HttpRequest::CreateFromUrl(urlres);
-}
-
-void
-UrnState::setUriResFromRequest(HttpRequest *r)
-{
-    if (RequestNeedsMenu(r)) {
-        updateRequestURL(r, r->urlpath.rawBuf() + 5, r->urlpath.size() - 5 );
-        flags.force_menu = true;
-    }
-
-    createUriResRequest (r->urlpath);
 
     if (urlres_r == NULL) {
         debugs(52, 3, "urnStart: Bad uri-res URL " << urlres);
@@ -367,28 +342,27 @@ urnHandleReply(void *data, StoreIOBuffer result)
     e->buffer();
     mb = new MemBuf;
     mb->init();
-    mb->Printf( "<TITLE>Select URL for %s</TITLE>\n"
-                "<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n"
-                "<H2>Select URL for %s</H2>\n"
-                "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", e->url(), e->url());
+    mb->appendf( "<TITLE>Select URL for %s</TITLE>\n"
+                 "<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n"
+                 "<H2>Select URL for %s</H2>\n"
+                 "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", e->url(), e->url());
 
     for (i = 0; i < urlcnt; ++i) {
         u = &urls[i];
         debugs(52, 3, "URL {" << u->url << "}");
-        mb->Printf(
+        mb->appendf(
             "<TR><TD><A HREF=\"%s\">%s</A></TD>", u->url, u->url);
 
         if (urls[i].rtt > 0)
-            mb->Printf(
+            mb->appendf(
                 "<TD align=\"right\">%4d <it>ms</it></TD>", u->rtt);
         else
-            mb->Printf("<TD align=\"right\">Unknown</TD>");
+            mb->appendf("<TD align=\"right\">Unknown</TD>");
 
-        mb->Printf(
-            "<TD>%s</TD></TR>\n", u->flags.cached ? "    [cached]" : " ");
+        mb->appendf("<TD>%s</TD></TR>\n", u->flags.cached ? "    [cached]" : " ");
     }
 
-    mb->Printf(
+    mb->appendf(
         "</TABLE>"
         "<HR noshade size=\"1px\">\n"
         "<ADDRESS>\n"
@@ -2335,8 +2335,6 @@ parse_wccp2_service_info(void *)
 void
 dump_wccp2_service_info(StoreEntry * e, const char *label, void *)
 {
-    char comma;
-
     struct wccp2_service_list_t *srv;
     int flags;
     srv = wccp2_service_list_head;
@@ -2362,102 +2360,102 @@ dump_wccp2_service_info(StoreEntry * e, const char *label, void *)
         /* flags */
         flags = ntohl(srv->info.service_flags);
 
+        bool comma = false;
         if (flags != 0) {
-            comma = 0;
             storeAppendPrintf(e, " flags=");
 
             if (flags & WCCP2_SERVICE_SRC_IP_HASH) {
-                storeAppendPrintf(e, "%ssrc_ip_hash", comma ? "," : "");
-                comma = 1;
+                storeAppendPrintf(e, "src_ip_hash");
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_DST_IP_HASH) {
                 storeAppendPrintf(e, "%sdst_ip_hash", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_SRC_PORT_HASH) {
                 storeAppendPrintf(e, "%ssource_port_hash", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_DST_PORT_HASH) {
                 storeAppendPrintf(e, "%sdst_port_hash", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_PORTS_DEFINED) {
                 storeAppendPrintf(e, "%sports_defined", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_PORTS_SOURCE) {
                 storeAppendPrintf(e, "%sports_source", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_SRC_IP_ALT_HASH) {
                 storeAppendPrintf(e, "%ssrc_ip_alt_hash", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_DST_IP_ALT_HASH) {
                 storeAppendPrintf(e, "%ssrc_ip_alt_hash", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_SRC_PORT_ALT_HASH) {
                 storeAppendPrintf(e, "%ssrc_port_alt_hash", comma ? "," : "");
-                comma = 1;
+                comma = true;
             }
 
             if (flags & WCCP2_SERVICE_DST_PORT_ALT_HASH) {
                 storeAppendPrintf(e, "%sdst_port_alt_hash", comma ? "," : "");
-                comma = 1;
+                //comma = true; // uncomment if more options added
             }
         }
 
         /* ports */
-        comma = 0;
+        comma = false;
 
         if (srv->info.port0 != 0) {
-            storeAppendPrintf(e, "%s%d", comma ? "," : " ports=", ntohs(srv->info.port0));
-            comma = 1;
+            storeAppendPrintf(e, " ports=%d", ntohs(srv->info.port0));
+            comma = true;
         }
 
         if (srv->info.port1 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port1));
-            comma = 1;
+            comma = true;
         }
 
         if (srv->info.port2 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port2));
-            comma = 1;
+            comma = true;
         }
 
         if (srv->info.port3 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port3));
-            comma = 1;
+            comma = true;
         }
 
         if (srv->info.port4 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port4));
-            comma = 1;
+            comma = true;
         }
 
         if (srv->info.port5 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port5));
-            comma = 1;
+            comma = true;
         }
 
         if (srv->info.port6 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port6));
-            comma = 1;
+            comma = true;
         }
 
         if (srv->info.port7 != 0) {
             storeAppendPrintf(e, "%s%d", comma ? "," : "ports=", ntohs(srv->info.port7));
-            comma = 1;
+            // comma = true; // uncomment if more options are added
         }
 
         /* protocol */
@@ -56,8 +56,6 @@ whoisWriteComplete(const Comm::ConnectionPointer &, char *buf, size_t, Comm::Fla
 void
 whoisStart(FwdState * fwd)
 {
-    char *buf;
-    size_t l;
     WhoisState *p = new WhoisState;
     p->request = fwd->request;
     p->entry = fwd->entry;
@@ -67,12 +65,11 @@ whoisStart(FwdState * fwd)
     p->entry->lock("whoisStart");
     comm_add_close_handler(fwd->serverConnection()->fd, whoisClose, p);
 
-    l = p->request->urlpath.size() + 3;
+    size_t l = p->request->url.path().length() + 3;
+    char *buf = (char *)xmalloc(l);
 
-    buf = (char *)xmalloc(l);
-
-    String str_print=p->request->urlpath.substr(1,p->request->urlpath.size());
-    snprintf(buf, l, SQUIDSTRINGPH"\r\n", SQUIDSTRINGPRINT(str_print));
+    const SBuf str_print = p->request->url.path().substr(1);
+    snprintf(buf, l, SQUIDSBUFPH "\r\n", SQUIDSBUFPRINT(str_print));
 
     AsyncCall::Pointer writeCall = commCbCall(5,5, "whoisWriteComplete",
                                    CommIoCbPtrFun(whoisWriteComplete, p));
@@ -69,7 +69,7 @@ void
 wordlistCat(const wordlist * w, MemBuf * mb)
 {
     while (NULL != w) {
-        mb->Printf("%s\n", w->key);
+        mb->appendf("%s\n", w->key);
         w = w->next;
     }
 }
@@ -354,12 +354,15 @@ main(void)
     }
     printf("done creating hash table: %d\n", hid);
 
+    std::mt19937 mt;
+    std::uniform_int_distribution<> dist(0,16);
+
     while (fgets(buf, BUFSIZ, stdin)) {
         buf[strlen(buf) - 1] = '\0';
         printf("Inserting '%s' for item %p to hash table: %d\n",
                buf, buf, hid);
         hash_insert(hid, xstrdup(buf), (void *) 0x12345678);
-        if (random() % 17 == 0)
+        if (dist(mt) == 0)
             strcpy(todelete, buf);
     }
 
@@ -12,14 +12,14 @@
  */
 
 #include "squid.h"
+#include "splay.h"
+#include "util.h"
 
 #include <cstdlib>
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-
-#include "splay.h"
-#include "util.h"
+#include <random>
 
 class intnode
 {
@@ -129,16 +129,17 @@ destintref (intnode &)
 int
 main(int argc, char *argv[])
 {
+    std::mt19937 generator;
+    std::uniform_int_distribution<int> distribution;
+    auto nextRandom = std::bind (distribution, generator);
+
     {
-        int i;
-        intnode *I;
         /* test void * splay containers */
         splayNode *top = NULL;
-        squid_srandom(time(NULL));
 
-        for (i = 0; i < 100; ++i) {
-            I = (intnode *)xcalloc(sizeof(intnode), 1);
-            I->i = squid_random();
+        for (int i = 0; i < 100; ++i) {
+            intnode *I = (intnode *)xcalloc(sizeof(intnode), 1);
+            I->i = nextRandom();
             if (top)
                 top = top->insert(I, compareintvoid);
             else
@@ -161,7 +162,7 @@ main(int argc, char *argv[])
         for ( int i = 0; i < 100; ++i) {
             intnode *I;
             I = new intnode;
-            I->i = squid_random();
+            I->i = nextRandom();
             safeTop = safeTop->insert(I, compareint);
         }
 
@@ -176,7 +177,7 @@ main(int argc, char *argv[])
 
         for (int i = 0; i < 100; ++i) {
             intnode I;
-            I.i = squid_random();
+            I.i = nextRandom();
             safeTop = safeTop->insert(I, compareintref);
         }
 
@@ -210,7 +211,7 @@ main(int argc, char *argv[])
 
         for (int i = 0; i < 100; ++i) {
             intnode I;
-            I.i = squid_random();
+            I.i = nextRandom();
 
             if (I.i > 50 && I.i < 10000000)
                 safeTop->insert(I, compareintref);