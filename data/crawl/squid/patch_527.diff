@@ -405,6 +405,24 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.21 (23 Sep 2012):
+
+	- Bug 3622: peerClearRRStart scheduling multiple events
+	- Bug 3615: configure check for default max number of FDs is broken
+	- Bug 3607: --enable-auth documented default action incorrect
+	- Bug 3593: socket failure: Address family not supported by protocol
+	- Bug 3584: Detection of setresuid() is broken
+	- Bug 3568: Consolidate external_acl_type config dumping and add missing %%
+	- Bug 3564: eCAP not supporting CoAP URI schemes
+	- Bug 3484: Docs: sslproxy_cert_error example flawed
+	- Bug 3462: Delay Pools and ICAP
+	- Bug 3133: better fix: Memory leak handling requests for sites that don't exist
+	- Bug 2976: ERR_INVALID_URL for transparently captured requests when reconfiguring
+	- Silence IOS 15.1 unknown capabilities messages.
+	- Account for Store disk client quota when bandwidth-limiting the server.
+	- ... and several documentation fixes
+	- ... and several compile fixes
+
 Changes to squid-3.1.20 (08 Jun 2012):
 
 	- Regression Bug 3545: FreeBSD dnsserver segfaults
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.20 release notes</title>
+<title>Squid 3.1.21 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.20
+The Squid Team are pleased to announce the release of Squid-3.1.21
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -19,9 +19,10 @@
 # NAME: <name>
 # IFDEF: <the ifdef bit>
 # TYPE: <the config type>
-# DEFAULT: <the default value>
-# DEFAULT_IF_NONE: <alternative default value>
 # LOC: <location in the Config struct>
+# DEFAULT: <the default value(s) - may be multiple lines>
+# DEFAULT_IF_NONE: <alternative default value>
+# DEFAULT_DOC: <the text to display instead of default value(s)>
 # DOC_START
 #   documentation goes here
 # NOCOMMENT_START
@@ -225,6 +226,22 @@ ($)
 	print $index $comment;
 	print $index "</pre>\n";
 }
+sub update_defaults()
+{
+	if (defined($data->{"default_doc"})) {
+		# default text description masks out the default value display
+		if($data->{"default_doc"} ne "") {
+			print "REPLACE: default '". $data->{"default"} ."' with '" . $data->{"default_doc"} . "'\n" if $verbose;
+			$data->{"default"} = $data->{"default_doc"};
+		}
+	}
+	# when we have no predefined default use the DEFAULT_IF_NONE
+	if (defined($data->{"default_if_none"})) {
+		print "REPLACE: default '". $data->{"default"} ."' with '" . $data->{"default_if_none"} . "'\n" if $verbose && $data->{"default"} eq "";
+		$data->{"default"} = $data->{"default_if_none"} if $data->{"default"} eq "";
+	}
+}
+
 while (<>) {
 	chomp;
 	last if (/^EOF$/);
@@ -241,25 +258,32 @@ ($)
 		$option{$name} = $data;
 		$data->{'name'} = $name;
 		$data->{'aliases'} = \@aliases;
+		$data->{'default'} = "";
+		$data->{'default_doc'} = "";
+		$data->{'default_if_none'} = "";
 
 		print "DEBUG: new option: $name\n" if $verbose;
+		next;
 	} elsif ($_ =~ /^COMMENT: (.*)$/) {
 		$data->{"comment"} = $1;
 	} elsif ($_ =~ /^TYPE: (.*)$/) {
 		$data->{"type"} = $1;
 		start_option($data->{"name"}, $data->{"type"});
 	} elsif ($_ =~ /^DEFAULT: (.*)$/) {
 		if ($1 eq "none") {
-		    $data->{"default"} = "$1";
+		    $data->{"default"} = "$1\n";
 		} else {
-		    $data->{"default"} = "$name $1";
+		    $data->{"default"} .= "$name $1\n";
 		}
+	} elsif ($_ =~ /^DEFAULT_DOC: (.*)$/) {
+		$data->{"default_doc"} .= "$1\n";
 	} elsif ($_ =~ /^DEFAULT_IF_NONE: (.*)$/) {
-		$data->{"default"} = "$name $1";
+		$data->{"default_if_none"} .= "$1\n";
 	} elsif ($_ =~ /^LOC:(.*)$/) {
 		$data->{"loc"} = $1;
 		$data->{"loc"} =~ s/^[\s\t]*//;
 	} elsif ($_ =~ /^DOC_START$/) {
+		update_defaults;
 		$state = "doc";
 	} elsif ($_ =~ /^DOC_END$/) {
 		$state = "";
@@ -269,11 +293,10 @@ ($)
 		}
 		undef @chained;
 	} elsif ($_ =~ /^DOC_NONE$/) {
+		update_defaults;
 		push(@chained, $name);
 	} elsif ($_ =~ /^NOCOMMENT_START$/) {
 		$state = "nocomment";
-	} elsif ($_ =~ /^DEFAULT_IF_NONE: (.*)$/) {
-		$data->{"default_if_none"} = $1;
 	} elsif ($_ =~ /^NOCOMMENT_END$/) {
 		$state = "";
 	} elsif ($_ =~ /^IFDEF: (.*)$/) {
@@ -30,14 +30,15 @@ class ACLFilledChecklist: public ACLChecklist
     ~ACLFilledChecklist();
 
 public:
+    /// The client connection manager
     ConnStateData * conn() const;
 
-    /// uses conn() if available
+    /// The client side fd. It uses conn() if available
     int fd() const;
 
     /// set either conn
     void conn(ConnStateData *);
-    /// set FD
+    /// set the client side FD
     void fd(int aDescriptor);
 
     //int authenticated();
@@ -469,6 +469,7 @@ acl_ip_data::FactoryParse(const char *t)
     /* ignore IPv6 addresses when built with IPv4-only */
     if ( iptype == AF_INET6 && !Ip::EnableIpv6) {
         debugs(28, DBG_IMPORTANT, "aclIpParseIpData: IPv6 has not been enabled.");
+        delete q;
         return NULL;
     }
 
@@ -2519,8 +2519,6 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
 
             ACLFilledChecklist check(Config.ssl_client.cert_error, request, dash_str);
             check.sslErrors = new Ssl::Errors(SQUID_X509_V_ERR_DOMAIN_MISMATCH);
-            if (Comm::IsConnOpen(pinning.serverConnection))
-                check.fd(pinning.serverConnection->fd);
             const bool allowDomainMismatch =
                 check.fastCheck() == ACCESS_ALLOWED;
             delete check.sslErrors;
@@ -217,6 +217,12 @@ FwdState::completed()
             assert(err);
             errorAppendEntry(entry, err);
             err = NULL;
+#if USE_SSL
+            if (request->flags.sslPeek && request->clientConnectionManager.valid()) {
+                CallJobHere1(17, 4, request->clientConnectionManager, ConnStateData,
+                             ConnStateData::httpsPeeked, Comm::ConnectionPointer(NULL));
+            }
+#endif
         } else {
             EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
             entry->complete();
@@ -372,14 +378,6 @@ FwdState::startConnectionOrFail()
             ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, HTTP_INTERNAL_SERVER_ERROR, request);
             fail(anErr);
         } // else use actual error from last connection attempt
-#if USE_SSL
-        if (request->flags.sslPeek && request->clientConnectionManager.valid()) {
-            errorAppendEntry(entry, err); // will free err
-            err = NULL;
-            CallJobHere1(17, 4, request->clientConnectionManager, ConnStateData,
-                         ConnStateData::httpsPeeked, Comm::ConnectionPointer(NULL));
-        }
-#endif
         self = NULL;       // refcounted
     }
 }
@@ -825,7 +823,6 @@ FwdState::initiateSSL()
     // The list is used in ssl_verify_cb() and is freed in ssl_free().
     if (acl_access *acl = Config.ssl_client.cert_error) {
         ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
-        check->fd(fd);
         SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
     }
 
@@ -84,6 +84,15 @@ CBDATA_TYPE(helper_server);
 CBDATA_CLASS_INIT(statefulhelper);
 CBDATA_TYPE(helper_stateful_server);
 
+void
+HelperServerBase::initStats()
+{
+    stats.uses=0;
+    stats.replies=0;
+    stats.pending=0;
+    stats.releases=0;
+}
+
 void
 HelperServerBase::closePipesSafely()
 {
@@ -217,6 +226,7 @@ helperOpenServers(helper * hlp)
         srv = cbdataAlloc(helper_server);
         srv->hIpc = hIpc;
         srv->pid = pid;
+        srv->initStats();
         srv->index = k;
         srv->addr = hlp->addr;
         srv->readPipe = new Comm::Connection;
@@ -338,8 +348,7 @@ helperStatefulOpenServers(statefulhelper * hlp)
         srv->hIpc = hIpc;
         srv->pid = pid;
         srv->flags.reserved = 0;
-        srv->stats.submits = 0;
-        srv->stats.releases = 0;
+        srv->initStats();
         srv->index = k;
         srv->addr = hlp->addr;
         srv->readPipe = new Comm::Connection;
@@ -500,11 +509,12 @@ helperStats(StoreEntry * sentry, helper * hlp, const char *label)
     storeAppendPrintf(sentry, "avg service time: %d msec\n",
                       hlp->stats.avg_svc_time);
     storeAppendPrintf(sentry, "\n");
-    storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%s\t%7s\t%7s\t%7s\n",
+    storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%11s\t%s\t%7s\t%7s\t%7s\n",
                       "#",
                       "FD",
                       "PID",
                       "# Requests",
+                      "# Replies",
                       "Flags",
                       "Time",
                       "Offset",
@@ -513,11 +523,12 @@ helperStats(StoreEntry * sentry, helper * hlp, const char *label)
     for (dlink_node *link = hlp->servers.head; link; link = link->next) {
         helper_server *srv = (helper_server*)link->data;
         double tt = 0.001 * (srv->requests[0] ? tvSubMsec(srv->requests[0]->dispatch_time, current_time) : tvSubMsec(srv->dispatch_time, srv->answer_time));
-        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11d\t%c%c%c%c\t%7.3f\t%7d\t%s\n",
+        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "%c%c%c%c\t%7.3f\t%7d\t%s\n",
                           srv->index + 1,
                           srv->readPipe->fd,
                           srv->pid,
                           srv->stats.uses,
+                          srv->stats.replies,
                           srv->stats.pending ? 'B' : ' ',
                           srv->flags.writing ? 'W' : ' ',
                           srv->flags.closing ? 'C' : ' ',
@@ -553,11 +564,12 @@ helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label
     storeAppendPrintf(sentry, "avg service time: %d msec\n",
                       hlp->stats.avg_svc_time);
     storeAppendPrintf(sentry, "\n");
-    storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%6s\t%7s\t%7s\t%7s\n",
+    storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%11s\t%6s\t%7s\t%7s\t%7s\n",
                       "#",
                       "FD",
                       "PID",
                       "# Requests",
+                      "# Replies",
                       "Flags",
                       "Time",
                       "Offset",
@@ -566,11 +578,12 @@ helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label
     for (dlink_node *link = hlp->servers.head; link; link = link->next) {
         helper_stateful_server *srv = (helper_stateful_server *)link->data;
         double tt = 0.001 * tvSubMsec(srv->dispatch_time, srv->flags.busy ? current_time : srv->answer_time);
-        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11d\t%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
+        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
                           srv->index + 1,
                           srv->readPipe->fd,
                           srv->pid,
                           srv->stats.uses,
+                          srv->stats.replies,
                           srv->flags.busy ? 'B' : ' ',
                           srv->flags.closing ? 'C' : ' ',
                           srv->flags.reserved ? 'R' : ' ',
@@ -725,8 +738,12 @@ helperServerFree(helper_server *srv)
         if (hlp->childs.needNew() > 0) {
             debugs(80, DBG_IMPORTANT, "Too few " << hlp->id_name << " processes are running (need " << hlp->childs.needNew() << "/" << hlp->childs.n_max << ")");
 
-            if (hlp->childs.n_active < hlp->childs.n_startup && hlp->last_restart > squid_curtime - 30)
-                fatalf("The %s helpers are crashing too rapidly, need help!\n", hlp->id_name);
+            if (hlp->childs.n_active < hlp->childs.n_startup && hlp->last_restart > squid_curtime - 30) {
+                if (srv->stats.replies < 1)
+                    fatalf("The %s helpers are crashing too rapidly, need help!\n", hlp->id_name);
+                else
+                    debugs(80, DBG_CRITICAL, "ERROR: The " << hlp->id_name << " helpers are crashing too rapidly, need help!");
+            }
 
             debugs(80, DBG_IMPORTANT, "Starting new helpers");
             helperOpenServers(hlp);
@@ -786,8 +803,12 @@ helperStatefulServerFree(helper_stateful_server *srv)
         if (hlp->childs.needNew() > 0) {
             debugs(80, DBG_IMPORTANT, "Too few " << hlp->id_name << " processes are running (need " << hlp->childs.needNew() << "/" << hlp->childs.n_max << ")");
 
-            if (hlp->childs.n_active < hlp->childs.n_startup && hlp->last_restart > squid_curtime - 30)
-                fatalf("The %s helpers are crashing too rapidly, need help!\n", hlp->id_name);
+            if (hlp->childs.n_active < hlp->childs.n_startup && hlp->last_restart > squid_curtime - 30) {
+                if (srv->stats.replies < 1)
+                    fatalf("The %s helpers are crashing too rapidly, need help!\n", hlp->id_name);
+                else
+                    debugs(80, DBG_CRITICAL, "ERROR: The " << hlp->id_name << " helpers are crashing too rapidly, need help!");
+            }
 
             debugs(80, DBG_IMPORTANT, "Starting new helpers");
             helperStatefulOpenServers(hlp);
@@ -829,6 +850,7 @@ static void helperReturnBuffer(int request_number, helper_server * srv, helper *
             callback(cbdata, msg);
 
         -- srv->stats.pending;
+        ++ srv->stats.replies;
 
         ++ hlp->stats.replies;
 
@@ -1005,6 +1027,10 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
         srv->roffset = 0;
         helperStatefulRequestFree(r);
         srv->request = NULL;
+
+        -- srv->stats.pending;
+        ++ srv->stats.replies;
+
         ++ hlp->stats.replies;
         srv->answer_time = current_time;
         hlp->stats.avg_svc_time =
@@ -1272,7 +1298,6 @@ helperDispatch(helper_server * srv, helper_request * r)
 
     assert(ptr);
     *ptr = r;
-    srv->stats.pending += 1;
     r->dispatch_time = current_time;
 
     if (srv->wqueue->isNull())
@@ -1296,6 +1321,7 @@ helperDispatch(helper_server * srv, helper_request * r)
     debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index + 1 << ", " << strlen(r->buf) << " bytes");
 
     ++ srv->stats.uses;
+    ++ srv->stats.pending;
     ++ hlp->stats.requests;
 }
 
@@ -1348,6 +1374,7 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
            (int) strlen(r->buf) << " bytes");
 
     ++ srv->stats.uses;
+    ++ srv->stats.pending;
     ++ hlp->stats.requests;
 }
 
@@ -88,7 +88,7 @@ class statefulhelper : public helper
     CBDATA_CLASS2(statefulhelper);
 };
 
-/*
+/**
  * Fields shared between stateless and stateful helper servers.
  */
 class HelperServerBase
@@ -130,6 +130,13 @@ class HelperServerBase
         unsigned int reserved:1;
     } flags;
 
+    struct {
+        uint64_t uses;     //< requests sent to this helper
+        uint64_t replies;  //< replies received from this helper
+        uint64_t pending;  //< queued lookups waiting to be sent to this helper
+        uint64_t releases; //< times release() has been called on this helper (if stateful)
+    } stats;
+    void initStats();
 };
 
 class MemBuf;
@@ -143,11 +150,6 @@ class helper_server : public HelperServerBase
     helper *parent;
     helper_request **requests;
 
-    struct {
-        int uses;
-        unsigned int pending;
-    } stats;
-
 private:
     CBDATA_CLASS2(helper_server);
 };
@@ -163,11 +165,6 @@ class helper_stateful_server : public HelperServerBase
     statefulhelper *parent;
     helper_stateful_request *request;
 
-    struct {
-        int uses;
-        int submits;
-        int releases;
-    } stats;
     void *data;			/* State data used by the calling routines */
 
 private:
@@ -729,10 +729,6 @@ HttpStateData::processReplyHeader()
 
     processSurrogateControl (vrep);
 
-    /** \todo IF the reply is a 1.0 reply, AND it has a Connection: Header
-     * Parse the header and remove all referenced headers
-     */
-
     request->hier.peer_reply_status = newrep->sline.status;
 
     ctx_exit(ctx);