@@ -1,4 +1,20 @@
 
+Changes to squid-3.3.5 (20 May 2013):
+
+	- Bug 3851: Delay Pool class 5 tag:levels displayed incorrectly in cache manager
+	- Bug 3845: http_port tcpkeepalive= option fails parsing
+	- Bug 3840: assertion failed 'sde' in UFS cache loading
+	- Bug 3836: make check failures with automake-1.13
+	- Bug 3827: Remove AccessLogEntry::cache.authuser
+	- Bug 3816 pt2: SSL_get_certificate call inside Ssl::verifySslCertificate crashes
+	- Bug 3780: cachemgr.cgi: output problem in HTTP Header Statistics
+	- Bug 3759: OpenSSL compilation error on stock Fedora17, RHEL, CentOS 6 systems
+	- Bug 3744: squid terminated: FATAL: Bungled (null) line 3: sslproxy_cert_sign signTrusted all
+	- Port from 2.6: external acl %ACL and %DATA tags
+	- Update copyright on SN.png
+	- ... and several minor memory leaks
+	- ... and some documentation polish
+
 Changes to squid-3.3.4 (27 Apr 2013):
 
 	- Bug 3831: basic_ncsa_auth Blowfish and SHA support
@@ -94,3 +94,129 @@ AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
   ])
   SQUID_STATE_ROLLBACK(iphlpapi)
 ])
+
+dnl Checks whether the OpenSSL SSL_get_certificate crashes squid and if a
+dnl workaround can be used instead of using the SSL_get_certificate
+AC_DEFUN([SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS],[
+  AH_TEMPLATE(SQUID_SSLGETCERTIFICATE_BUGGY, "Define to 1 if the SSL_get_certificate crashes squid")
+  AH_TEMPLATE(SQUID_USE_SSLGETCERTIFICATE_HACK, "Define to 1 to use squid workaround for SSL_get_certificate")
+  SQUID_STATE_SAVE(check_SSL_get_certificate)
+  LIBS="$SSLLIB $LIBS"
+  if test "x$SSLLIBDIR" != "x"; then
+     LIBS="$LIBS -Wl,-rpath -Wl,$SSLLIBDIR"
+  fi
+
+  AC_MSG_CHECKING(whether the SSL_get_certificate is buggy)
+  AC_RUN_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+    SSLeay_add_ssl_algorithms();
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv3_method());
+    SSL *ssl = SSL_new(sslContext);
+    X509* cert = SSL_get_certificate(ssl);
+    return 0;
+    ])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [
+   AC_DEFINE(SQUID_SSLGETCERTIFICATE_BUGGY, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [])
+
+  AC_MSG_CHECKING(whether the workaround for SSL_get_certificate works)
+  AC_RUN_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+    SSLeay_add_ssl_algorithms();
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv3_method());
+    X509 ***pCert = (X509 ***)sslContext->cert;
+    X509 *sslCtxCert = pCert && *pCert ? **pCert : (X509 *)0x1;
+    if (sslCtxCert != NULL)
+        return 1;
+    return 0;
+    ])
+  ],
+  [
+   AC_MSG_RESULT([yes])
+   AC_DEFINE(SQUID_USE_SSLGETCERTIFICATE_HACK, 1)
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+[])
+
+SQUID_STATE_ROLLBACK(check_SSL_get_certificate)
+])
+
+
+dnl Try to handle TXT_DB related  problems:
+dnl 1) The type of TXT_DB::data member changed in openSSL-1.0.1 version
+dnl 2) The IMPLEMENT_LHASH_* openSSL macros in openSSL-1.0.1 and later releases is not
+dnl    implemented correctly and causes type conversion errors while compiling squid
+
+AC_DEFUN([SQUID_CHECK_OPENSSL_TXTDB],[
+  AH_TEMPLATE(SQUID_SSLTXTDB_PSTRINGDATA, "Define to 1 if the TXT_DB uses OPENSSL_PSTRING data member")
+  AH_TEMPLATE(SQUID_USE_SSLLHASH_HACK, "Define to 1 to use squid workaround for openssl IMPLEMENT_LHASH_* type conversion errors")
+
+  SQUID_STATE_SAVE(check_TXTDB)
+
+  LIBS="$LIBS $SSLLIB"
+  AC_MSG_CHECKING(whether the TXT_DB use OPENSSL_PSTRING data member)
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/txt_db.h>
+    ],
+    [
+    TXT_DB *db = NULL;
+    int i = sk_OPENSSL_PSTRING_num(db->data);
+    return 0;
+    ])
+  ],
+  [
+   AC_DEFINE(SQUID_SSLTXTDB_PSTRINGDATA, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [])
+
+  AC_MSG_CHECKING(whether the workaround for OpenSSL IMPLEMENT_LHASH_  macros should used)
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/txt_db.h>
+
+     static unsigned long index_serial_hash(const char **a){}
+     static int index_serial_cmp(const char **a, const char **b){}
+     static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
+     static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
+    ],
+    [
+    TXT_DB *db = NULL;
+    TXT_DB_create_index(db, 1, NULL, LHASH_HASH_FN(index_serial_hash), LHASH_COMP_FN(index_serial_cmp));
+    ])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [
+   AC_MSG_RESULT([yes])
+   AC_DEFINE(SQUID_USE_SSLLHASH_HACK, 1)
+  ],
+[])
+
+SQUID_STATE_ROLLBACK(check_TXTDB)
+])
@@ -461,6 +461,9 @@ index(const char *s, int c)
     return (char *)strchr(s,c);
 }
 
+// stdlib <functional> definitions are required before std API redefinitions.
+#include <functional>
+
 /** \cond AUTODOCS-IGNORE */
 namespace Squid
 {
@@ -35,9 +35,20 @@ AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
-# might be cross-compiling
+# Clang 3.2 on some CPUs requires -march-native to detect correctly
+# GCC 4.3+ can also produce faster executables when its used
+SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+
+# might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
   HOSTCXX="$CXX"
+  if test "x$squid_cv_check_marchnative" = "xyes"; then
+    CXXFLAGS="$CXXFLAGS -march=native"
+  fi
+fi
+if test "x$squid_cv_check_marchnative" = "xyes"; then
+  # always valid for the Host compiler.
+  HOSTCXX="$HOSTCXX -march=native"
 fi
 AC_SUBST(HOSTCXX)
 
@@ -60,8 +71,7 @@ fi
 
 # Check for C++0x compiler support
 AX_CXX_COMPILE_STDCXX_0X
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
-  "x$squid_host_os" != "xmingw" ; then
+if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" ; then
     #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
     # in the system libraries, which makes some c99 methods unavailable
     # (e.g. strtoll), yet configure detects them as avilable.
@@ -1265,6 +1275,10 @@ if test "x$SSLLIBDIR" != "x" ; then
 fi
 AC_SUBST(SSLLIB)
 
+if test "x$with_openssl" = "xyes"; then
+SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS
+SQUID_CHECK_OPENSSL_TXTDB
+fi
 
 AC_ARG_ENABLE(forw-via-db,
   AS_HELP_STRING([--enable-forw-via-db],[Enable Forw/Via database]), [
@@ -1776,18 +1790,13 @@ AC_SUBST(AUTH_MODULES)
 AC_SUBST(AUTH_LIBS_TO_BUILD)
 
 dnl Select logging daemon helpers to build
-squid_opt_logdaemon_helpers="auto"
 AC_ARG_ENABLE(log-daemon-helpers,
   AS_HELP_STRING([--enable-log-daemon-helpers="list of helpers"],
                  [This option selects which logging daemon helpers to 
                   build and install as part of the normal build process
                   For a list of available helpers see the helpers/log_daemon
                   directory.]),[
-case "$enableval" in
-  yes) : ;;
-  no)  squid_opt_logdaemon_helpers="" ;;
-  *)   squid_opt_logdaemon_helpers="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`" ;;
-  esac
+#nothing to do, really
 ])
 m4_include([helpers/log_daemon/modules.m4])
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.4 release notes</title>
+<title>Squid 3.3.5 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.4.
+The Squid Team are pleased to announce the release of Squid-3.3.5.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
 <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -206,6 +206,12 @@ This section gives a thorough account of those changes in three categories:
 	   <em>ssl::certUntrusted</em>,
 	   <em>ssl::certSelfSigned</em>.
 
+	<tag>external_acl_type</tag>
+	<p><em>%ACL</em> format tag ported from 2.6.
+	   Sends the name of ACL being tested to the external helper.
+	<p><em>%DATA</em> format tag ported from 2.6.
+	   Inserts the ACL arguments into a particular location of the helper input instead of at the end of the line.
+
 	<tag>logformat</tag>
 	<p>New token <em>%ssl::bump_mode</em> to log the SSL-bump mode type performed on a request.
 	  Logs values of: <em>-</em>, <em>none</em>, <em>client-first</em>, or <em>server-first</em>.
@@ -309,16 +315,9 @@ This section gives an account of those changes in three categories:
 	<tag>error_map</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>external_acl_type</tag>
-	<p><em>%ACL</em> format tag not yet ported from 2.6
-	<p><em>%DATA</em> format tag not yet ported from 2.6
-
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>http_port</tag>
-	<p><em>act-as-origin</em> not yet ported from 2.7
-
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
 
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <HTML>
 <HEAD>
- <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
  <TITLE>Squid 3.4.0.0 release notes</TITLE>
 </HEAD>
 <BODY>
@@ -26,6 +26,7 @@ <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></
 <UL>
 <LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
 <LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
@@ -55,17 +56,19 @@ <H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
 
 <P>The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.</P>
 <P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the
 <A HREF="http://www.squid-cache.org/Mirrors/http-mirrors.html">mirrors</A>.</P>
 <P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
 <P>We welcome feedback and bug reports. If you find a bug, please see 
-<A HREF="http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d">http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d</A> for how to submit a report with a stack trace.</P>
+<A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
+for how to submit a report with a stack trace.</P>
 
 <H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
 </H2>
 
 <P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://www.squid-cache.org/bugs/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.4&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">open bugs against Squid-3.4</A>.</P>
+<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4">open bugs against Squid-3.4</A>.</P>
+
 
 <H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.4</A>
 </H2>
@@ -81,6 +84,7 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></
 <UL>
 <LI>Helper protocol extensions</LI>
 <LI>SSL Server Certificate Validator</LI>
+<LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
@@ -142,6 +146,30 @@ <H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</
 <EM>ssl_crtd</EM> related options. </P>
 
 
+<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf</A>.</P>
+
+<P>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
+using several very simple methods. One of which is the <EM>divert-to</EM> rule type
+which acts as a simple routing diversion instead of performing NAT packet alterations.</P>
+
+<P>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.</P>
+
+<P>This version of Squid adds support for these features through the ./configure
+options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
+systems with the required support. No special extras are required to enable
+<EM>http_port ... tproxy</EM> configuration to work.</P>
+
+<P>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
+<EM>./configure --enable-pf-transparent</EM> has been altered and is expected to
+break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
+which do not yet support the getsockname() API.
+These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
+
+
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <P>There have been changes to Squid's configuration file since Squid-3.3.</P>
@@ -167,6 +195,9 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 <P>Use ACLs to annotate a transaction with customized annotations
 which can be logged in access.log</P>
 
+<DT><B>spoof_client_ip</B><DD>
+<P>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.</P>
+
 <DT><B>sslcrtvalidator_children</B><DD>
 <P>Specifies the settings for how many SSL server certificate
 validator helpers are run and when they are started.</P>
@@ -203,6 +234,12 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <P>Details at 
 <A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
+<DT><B>http_port</B><DD>
+<P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
+(OpenBSD 5+, FreeBSD 9+ so far).</P>
+<P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
+see <EM>--enable-pf-transparent</EM> for more details.</P>
+
 <DT><B>logformat</B><DD>
 <P>New format code <EM>%note</EM> to log a transaction annotation linked to the
 transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
@@ -231,6 +268,18 @@ <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed
 <DL>
 <P><EM>There are no removed squid.conf tags in Squid-3.4.</EM></P>
 
+<DT><B>storeurl_access</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_children</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_concurrency</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_program</B><DD>
+<P>Not yet ported from 2.7</P>
+
 </DL>
 </P>
 
@@ -256,7 +305,14 @@ <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New opti
 
 <P>
 <DL>
-<P><EM>There are no new ./configure options in Squid-3.4.</EM></P>
+<DT><B>--with-nat-pf</B><DD>
+<P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
+in squid.conf.</P>
+<P>When this option is used Squid performs the /dev/pf lookups required to
+support PF <EM>rdr-to</EM> rules. Otherwise Squid will perform perform the
+getsockname() API calls to support PF <EM>divert-to</EM> rules.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require this option.</P>
 
 </DL>
 </P>
@@ -266,7 +322,14 @@ <H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Cha
 
 <P>
 <DL>
-<P><EM>There are no changed ./configure options in Squid-3.4.</EM></P>
+<DT><B>--enable-pf-transparent</B><DD>
+<P>NAT table support updated to use the getsockname() API provided by the
+latest PF versions <EM>divert-to</EM>. This allows <EM>http_port</EM>
+in squid.conf to support both <EM>intercept</EM> and <EM>tproxy</EM> traffic
+and to silence NAT lookup failure messages on recent BSD.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require <EM>--with-nat-devpf</EM>
+to re-enable /dev/pf support when using PF firewall.</P>
 
 </DL>
 </P>
@@ -318,16 +381,9 @@ <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options availab
 <DT><B>error_map</B><DD>
 <P>Not yet ported from 2.6</P>
 
-<DT><B>external_acl_type</B><DD>
-<P><EM>%ACL</EM> format tag not yet ported from 2.6</P>
-<P><EM>%DATA</EM> format tag not yet ported from 2.6</P>
-
 <DT><B>external_refresh_check</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>http_port</B><DD>
-<P><EM>act-as-origin</EM> not yet ported from 2.7</P>
-
 <DT><B>ignore_ims_on_miss</B><DD>
 <P>Not yet ported from 2.7</P>
 
@@ -351,18 +407,6 @@ <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options availab
 <DT><B>refresh_stale_hit</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>storeurl_access</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_children</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_program</B><DD>
-<P>Not yet ported from 2.7</P>
-
 <DT><B>update_headers</B><DD>
 <P>Not yet ported from 2.7</P>
 
@@ -135,6 +135,9 @@ This section gives a thorough account of those changes in three categories:
 	<p>Use ACLs to annotate a transaction with customized annotations
 	   which can be logged in access.log
 
+	<tag>spoof_client_ip</tag>
+	<p>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.
+
 	<tag>sslcrtvalidator_children</tag>
 	<p>Specifies the settings for how many SSL server certificate
 	   validator helpers are run and when they are started.
@@ -283,16 +286,9 @@ This section gives an account of those changes in three categories:
 	<tag>error_map</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>external_acl_type</tag>
-	<p><em>%ACL</em> format tag not yet ported from 2.6
-	<p><em>%DATA</em> format tag not yet ported from 2.6
-
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>http_port</tag>
-	<p><em>act-as-origin</em> not yet ported from 2.7
-
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
 
@@ -24,6 +24,7 @@ ms	ms-my
 nl	nl-nl
 pl	pl-pl
 pt	pt-pt
+pt-br	pt-bz
 ro	ro-ro ro-md
 ru	ru-ru
 sk	sk-sk
@@ -149,8 +149,8 @@ main(int argc, char **argv)
             continue;
         }
         char *crypted = NULL;
-        size_t passwordLength = strlen(passwd);
 #if HAVE_CRYPT
+        size_t passwordLength = strlen(passwd);
         // Bug 3831: given algorithms more secure than DES crypt() does not truncate, so we can ignore the bug 3107 length checks below
         // '$1$' = MD5, '$2a$' = Blowfish, '$5$' = SHA256 (Linux), '$6$' = SHA256 (BSD) and SHA512
         if (passwordLength > 1 && u->passwd[0] == '$' &&
@@ -1,6 +1,8 @@
-#
-## TODO: make a AC_COMPILE check instead
-#
 for hdr in w32api/dsrole.h dsrole.h; do
-  AC_EGREP_HEADER(/usr/include/$hdr,[DsRoleGetPrimaryDomainInformation],[BUILD_HELPER="AD_group"])
+  AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[#include <$hdr>]], [[
+      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDSRoleInfo;
+      DWORD ret = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) & pDSRoleInfo);
+    ]])
+  ],[BUILD_HELPER="AD_group"],[])
 done
@@ -1 +1 @@
-AC_EGREP_HEADER(/usr/include/db.h,db_env_create,[BUILD_HELPER="session"])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <db.h>]],[[DB_ENV *db_env = NULL; db_env_create(&db_env, 0);]])],[BUILD_HELPER="session"],[])
@@ -1,2 +1,2 @@
 AC_CHECK_HEADERS([db_185.h],[BUILD_HELPER="time_quota"])
-AC_EGREP_HEADER(/usr/include/db.h,dbopen,[BUILD_HELPER="time_quota"])
+AC_EGREP_HEADER([dbopen],[/usr/include/db.h],[BUILD_HELPER="time_quota"])
@@ -1,18 +1,21 @@
 # This file is supposed to run all the tests required to identify which
 # configured modules are able to be built in this environment
 
-# FIXME: de-duplicate $squid_opt_logdaemon_helpers list containing double entries.
+# FIXME: de-duplicate $enable_log_daemon_helpers list containing double entries.
 
 #define list of modules to build
-if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
-  squid_opt_logdaemon_helpers=""
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[squid_opt_logdaemon_helpers])
+if test "x${enable_log_daemon_helpers:=yes}" = "xyes" ;then
+  enable_log_daemon_helpers=""
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[enable_log_daemon_helpers])
+fi
+if test "x$enable_log_daemon_helpers" = "xnone" ; then
+  enable_log_daemon_helpers=""
 fi
 
 LOG_DAEMON_HELPERS=""
-squid_opt_logdaemon_helpers="`echo $squid_opt_logdaemon_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$squid_opt_logdaemon_helpers" = "x"; then
-  for helper in $squid_opt_logdaemon_helpers ; do
+enable_log_daemon_helpers="`echo $enable_log_daemon_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_log_daemon_helpers" != "xno"; then
+  for helper in $enable_log_daemon_helpers ; do
     dir="$srcdir/helpers/log_daemon/$helper"
 
     # modules converted to autoconf macros already
@@ -230,11 +230,9 @@ class AccessLogEntry: public RefCountable
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
-    // TODO: merge configNotes and helperNotes
-    /// key:value pairs set by note.
-    NotePairs::Pointer configNotes;
+    /// key:value pairs set by squid.conf note directive and
     /// key=value pairs returned from URL rewrite/redirect helper
-    NotePairs::Pointer helperNotes;
+    NotePairs::Pointer notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
@@ -38,6 +38,8 @@
 #include "acl/MethodData.h"
 #include "acl/Method.h"
 #include "acl/MyPortName.h"
+#include "acl/Note.h"
+#include "acl/NoteData.h"
 #include "acl/PeerName.h"
 #include "acl/ProtocolData.h"
 #include "acl/Protocol.h"
@@ -188,3 +190,6 @@ Acl::AnyOf Acl::AnyOf::RegistryEntry_;
 
 ACL::Prototype Acl::AllOf::RegistryProtoype(&Acl::AllOf::RegistryEntry_, "all-of");
 Acl::AllOf Acl::AllOf::RegistryEntry_;
+
+ACL::Prototype ACLNote::RegistryProtoype(&ACLNote::RegistryEntry_, "note");
+ACLStrategised<HttpRequest *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteStrategy::Instance(), "note");
@@ -190,10 +190,10 @@ DelayTaggedBucket::~DelayTaggedBucket()
 }
 
 void
-DelayTaggedBucket::stats (StoreEntry *entry) const
+DelayTaggedBucket::stats(StoreEntry *entry) const
 {
-    storeAppendPrintf(entry, " :" SQUIDSTRINGPH , SQUIDSTRINGPRINT(tag));
-    theBucket.stats (entry);
+    storeAppendPrintf(entry, " " SQUIDSTRINGPH ":", SQUIDSTRINGPRINT(tag));
+    theBucket.stats(entry);
 }
 
 DelayTagged::Id::Id(DelayTagged::Pointer aDelayTagged, String &aTag) : theTagged(aDelayTagged)
@@ -442,16 +442,16 @@ HttpHeader::clean()
     PROF_start(HttpHeaderClean);
 
     if (owner <= hoReply) {
-    /*
-     * An unfortunate bug.  The entries array is initialized
-     * such that count is set to zero.  httpHeaderClean() seems to
-     * be called both when 'hdr' is created, and destroyed.  Thus,
-     * we accumulate a large number of zero counts for 'hdr' before
-     * it is ever used.  Can't think of a good way to fix it, except
-     * adding a state variable that indicates whether or not 'hdr'
-     * has been used.  As a hack, just never count zero-sized header
-     * arrays.
-     */
+        /*
+         * An unfortunate bug.  The entries array is initialized
+         * such that count is set to zero.  httpHeaderClean() seems to
+         * be called both when 'hdr' is created, and destroyed.  Thus,
+         * we accumulate a large number of zero counts for 'hdr' before
+         * it is ever used.  Can't think of a good way to fix it, except
+         * adding a state variable that indicates whether or not 'hdr'
+         * has been used.  As a hack, just never count zero-sized header
+         * arrays.
+         */
         if (0 != entries.count)
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
 
@@ -460,18 +460,18 @@ HttpHeader::clean()
         HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
     } // if (owner <= hoReply)
 
-        while ((e = getEntry(&pos))) {
-            /* tmp hack to try to avoid coredumps */
+    while ((e = getEntry(&pos))) {
+        /* tmp hack to try to avoid coredumps */
 
-            if (e->id < 0 || e->id >= HDR_ENUM_END) {
-                debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
-            } else {
-                if (owner <= hoReply)
+        if (e->id < 0 || e->id >= HDR_ENUM_END) {
+            debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
+        } else {
+            if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
-                /* yes, this deletion leaves us in an inconsistent state */
-                delete e;
-            }
+            /* yes, this deletion leaves us in an inconsistent state */
+            delete e;
         }
+    }
     entries.clean();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
@@ -6,6 +6,9 @@
 #include "HttpHeader.h"
 #include "typedefs.h"
 
+#if HAVE_FUNCTIONAL
+#include <functional>
+#endif
 #if HAVE_LIST
 #include <list>
 #endif
@@ -15,6 +18,9 @@
 #if HAVE_STRING
 #include <string>
 #endif
+#if HAVE_STRINGS_H
+#include <strings.h>
+#endif
 
 class HeaderWithAcl;
 class HttpHeader;
@@ -55,8 +61,18 @@ class HeaderManglers
     void dumpReplacement(StoreEntry *entry, const char *optionName) const;
 
 private:
+    /// Case-insensitive std::string "less than" comparison functor.
+    /// Fast version recommended by Meyers' "Effective STL" for ASCII c-strings.
+    class NoCaseLessThan: public std::binary_function<std::string, std::string, bool>
+    {
+    public:
+        bool operator()(const std::string &lhs, const std::string &rhs) const {
+            return strcasecmp(lhs.c_str(), rhs.c_str()) < 0;
+        }
+    };
+
     /// a name:mangler map; optimize: use unordered map or some such
-    typedef std::map<std::string, headerMangler> ManglersByName;
+    typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
     headerMangler known[HDR_ENUM_END];
@@ -58,15 +58,13 @@
 #endif
 
 HttpRequest::HttpRequest() :
-        HttpMsg(hoRequest),
-        helperNotes(NULL)
+        HttpMsg(hoRequest)
 {
     init();
 }
 
 HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
-        HttpMsg(hoRequest),
-        helperNotes(NULL)
+        HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
@@ -168,7 +166,7 @@ HttpRequest::clean()
 
     myportname.clean();
 
-    helperNotes = NULL;
+    notes = NULL;
 
     tag.clean();
 #if USE_AUTH
@@ -228,7 +226,6 @@ HttpRequest::clone() const
     // XXX: what to do with copy->peer_domain?
 
     copy->myportname = myportname;
-    copy->helperNotes = helperNotes;
     copy->tag = tag;
 #if USE_AUTH
     copy->extacl_user = extacl_user;
@@ -277,6 +274,7 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
+    notes = aReq->notes;
     return true;
 }
 
@@ -203,7 +203,7 @@ class HttpRequest: public HttpMsg
 
     String myportname; // Internal tag name= value from port this requests arrived in.
 
-    NotePairs::Pointer helperNotes;         ///< collection of meta notes associated with this request by helper lookups.
+    NotePairs::Pointer notes; ///< annotations added by the note directive and helpers
 
     String tag;			/* Internal tag for this request */
 
@@ -978,7 +978,7 @@ test_cache_digest: test_cache_digest.o CacheDigest.o debug.o globals.o store_key
 cache_cf.o: cf_parser.cci
 
 # cf_gen builds the configuration files.
-cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES)
+cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES) cf_gen_defines.cci
 	$(HOSTCXX) -o $@ $(srcdir)/cf_gen.cc -I$(srcdir) -I$(top_builddir)/include/ -I$(top_builddir)/src
 
 # squid.conf.default is built by cf_gen when making cf_parser.cci
@@ -988,7 +988,9 @@ squid.conf.default squid.conf.documented: cf_parser.cci
 cf_parser.cci: cf.data cf_gen$(EXEEXT)
 	./cf_gen$(EXEEXT) cf.data $(srcdir)/cf.data.depend
 
-cf_gen_defines.cci: $(srcdir)/cf_gen_defines $(srcdir)/cf.data.pre
+# The cf_gen_defines.cci is auto-generated and does not exist when the 
+# dependencies computed. We need to add its include files (autoconf.h) here
+cf_gen_defines.cci: $(srcdir)/cf_gen_defines $(srcdir)/cf.data.pre $(top_builddir)/include/autoconf.h
 	$(AWK) -f $(srcdir)/cf_gen_defines <$(srcdir)/cf.data.pre >$@ || ($(RM) -f $@ && exit 1)
 
 
@@ -29,6 +29,7 @@
 
 #include "squid.h"
 #include "globals.h"
+#include "AccessLogEntry.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
@@ -136,6 +137,12 @@ Notes::clean()
     notes.clean();
 }
 
+NotePairs::~NotePairs()
+{
+    while (!entries.empty())
+        delete entries.pop_back();
+}
+
 const char *
 NotePairs::find(const char *noteKey) const
 {
@@ -212,3 +219,15 @@ NotePairs::append(const NotePairs *src)
         entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
     }
 }
+
+NotePairs &
+SyncNotes(AccessLogEntry &ale, HttpRequest &request)
+{
+    if (!ale.notes) {
+        assert(!request.notes);
+        ale.notes = request.notes = new NotePairs;
+    } else {
+        assert(ale.notes == request.notes);
+    }
+    return *ale.notes;
+}
@@ -122,7 +122,7 @@ class NotePairs: public RefCountable
         MEMPROXY_CLASS(Entry);
     };
 
-    NotePairs() {}
+    ~NotePairs();
 
     /**
      * Append the entries of the src NotePairs list to our list.
@@ -175,4 +175,10 @@ class NotePairs: public RefCountable
 
 MEMPROXY_CLASS_INLINE(NotePairs::Entry);
 
+class AccessLogEntry;
+/**
+ * Keep in sync HttpRequest and the corresponding AccessLogEntry objects
+ */
+NotePairs &SyncNotes(AccessLogEntry &ale, HttpRequest &request);
+
 #endif
@@ -636,8 +636,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
 
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
-        /* XXX FIXME: allow accessing the acl name here */
-        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
+        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
         if (checklist->goAsync(DestinationIPLookup::Instance()))
             return -1;
         // else fall through to noaddr match, hiding the lookup failure (XXX)
@@ -13,22 +13,6 @@
 
 CBDATA_CLASS_INIT(ACLFilledChecklist);
 
-void *
-ACLFilledChecklist::operator new (size_t size)
-{
-    assert (size == sizeof(ACLFilledChecklist));
-    CBDATA_INIT_TYPE(ACLFilledChecklist);
-    ACLFilledChecklist *result = cbdataAlloc(ACLFilledChecklist);
-    return result;
-}
-
-void
-ACLFilledChecklist::operator delete (void *address)
-{
-    ACLFilledChecklist *t = static_cast<ACLFilledChecklist *>(address);
-    cbdataFree(t);
-}
-
 ACLFilledChecklist::ACLFilledChecklist() :
         dst_peer(NULL),
         dst_rdns(NULL),
@@ -194,4 +178,3 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
         xstrncpy(rfc931, ident, USER_IDENT_SZ);
 #endif
 }
-
@@ -23,9 +23,6 @@ class HttpReply;
 class ACLFilledChecklist: public ACLChecklist
 {
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ACLFilledChecklist();
     ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
     ~ACLFilledChecklist();
@@ -90,7 +87,7 @@ class ACLFilledChecklist: public ACLChecklist
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
 
-    CBDATA_CLASS(ACLFilledChecklist);
+    CBDATA_CLASS2(ACLFilledChecklist);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
@@ -84,6 +84,10 @@ libacls_la_SOURCES = \
 	Method.h \
 	MyPortName.cc \
 	MyPortName.h \
+	Note.h \
+	Note.cc \
+	NoteData.h \
+	NoteData.cc \
 	PeerName.cc \
 	PeerName.h \
 	Protocol.cc \
@@ -0,0 +1,24 @@
+#include "squid.h"
+#include "acl/Note.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Checklist.h"
+#include "HttpRequest.h"
+#include "Notes.h"
+
+int
+ACLNoteStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+{
+    if (checklist->request != NULL)
+        return data->match(checklist->request);
+
+    return 0;
+}
+
+ACLNoteStrategy *
+ACLNoteStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLNoteStrategy ACLNoteStrategy::Instance_;
+
@@ -0,0 +1,39 @@
+#ifndef SQUID_ACLNOTE_H
+#define SQUID_ACLNOTE_H
+
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
+
+class HttpRequest;
+
+/// \ingroup ACLAPI
+class ACLNoteStrategy : public ACLStrategy<HttpRequest *>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual bool requiresRequest() const { return true; }
+
+    static ACLNoteStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLNoteStrategy(ACLNoteStrategy const &);
+
+private:
+    static ACLNoteStrategy Instance_;
+    ACLNoteStrategy() { }
+
+    ACLNoteStrategy& operator = (ACLNoteStrategy const &);
+};
+
+/// \ingroup ACLAPI
+class ACLNote
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<HttpRequest *> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLNOTE_H */
@@ -0,0 +1,87 @@
+#include "squid.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/NoteData.h"
+#include "acl/StringData.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "HttpRequest.h"
+#include "Notes.h"
+#include "wordlist.h"
+
+ACLNoteData::ACLNoteData() : values(new ACLStringData)
+{}
+
+ACLNoteData::~ACLNoteData()
+{
+    delete values;
+}
+
+bool
+ACLNoteData::matchNotes(NotePairs *note)
+{
+    if (note == NULL)
+        return false;
+
+    debugs(28, 3, "Checking " << name);
+
+    if (values->empty())
+        return (note->findFirst(name.termedBuf()) != NULL);
+
+    for (Vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
+        if ((*i)->name.cmp(name.termedBuf()) == 0) {
+            if (values->match((*i)->value.termedBuf()))
+                return true;
+        }
+    }
+    return false;
+}
+
+bool
+ACLNoteData::match(HttpRequest *request)
+{
+    if (request->notes != NULL && matchNotes(request->notes.getRaw()))
+        return true;
+#if USE_ADAPTATION
+    const Adaptation::History::Pointer ah = request->adaptLogHistory();
+    if (ah != NULL && ah->metaHeaders != NULL && matchNotes(ah->metaHeaders.getRaw()))
+        return true;
+#endif
+    return false;
+}
+
+wordlist *
+ACLNoteData::dump()
+{
+    wordlist *W = NULL;
+    wordlistAdd(&W, name.termedBuf());
+    wordlist * dumpR = values->dump();
+    wordlistAddWl(&W, dumpR);
+    wordlistDestroy(&dumpR);
+    return W;
+}
+
+void
+ACLNoteData::parse()
+{
+    char* t = strtokFile();
+    assert (t != NULL);
+    name = t;
+    values->parse();
+}
+
+bool
+ACLNoteData::empty() const
+{
+    return name.undefined();
+}
+
+ACLData<HttpRequest *> *
+ACLNoteData::clone() const
+{
+    ACLNoteData * result = new ACLNoteData;
+    result->values = values->clone();
+    result->name = name;
+    return result;
+}
@@ -0,0 +1,33 @@
+#ifndef SQUID_ACLNOTEDATA_H
+#define SQUID_ACLNOTEDATA_H
+
+#include "acl/Data.h"
+#include "SquidString.h"
+#include "MemPool.h"
+
+class HttpRequest;
+class NotePairs;
+
+/// \ingroup ACLAPI
+class ACLNoteData : public ACLData<HttpRequest *>
+{
+public:
+    MEMPROXY_CLASS(ACLNoteData);
+
+    ACLNoteData();
+    virtual ~ACLNoteData();
+    virtual bool match(HttpRequest* request);
+    virtual wordlist *dump();
+    virtual void parse();
+    virtual bool empty() const;
+    virtual ACLData<HttpRequest *> *clone() const;
+
+private:
+    bool matchNotes(NotePairs *note);
+    String name;                   ///< Note name to check. It is always set
+    ACLData<char const *> *values; ///< if set, at least one value must match
+};
+
+MEMPROXY_CLASS_INLINE(ACLNoteData);
+
+#endif /* SQUID_ACLNOTEDATA_H */
@@ -136,7 +136,7 @@ ProxyAuthLookup::Instance()
 }
 
 void
-ProxyAuthLookup::checkForAsync(ACLChecklist *cl)const
+ProxyAuthLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
@@ -59,7 +59,7 @@ template <class EntryValue, size_t EntryCost = sizeof(EntryValue)> class LruMap
     LruMap(LruMap const &);
     LruMap & operator = (LruMap const &);
 
-    bool expired(Entry &e);
+    bool expired(const Entry &e) const;
     void trim();
     void touch(const MapIterator &i);
     bool del(const MapIterator &i);
@@ -110,12 +110,14 @@ LruMap<EntryValue, EntryCost>::findEntry(const char *key, LruMap::MapIterator &i
     index.erase(i->second);
     i->second = index.begin();
 
-    Entry *e = *i->second;
-
-    if (e && expired(*e)) {
-        del(i);
-        e = NULL;
+    if (const Entry *e = *i->second) {
+        if (!expired(*e))
+            return;
+        // else fall through to cleanup
     }
+
+    del(i);
+    i = storage.end();
 }
 
 template <class EntryValue, size_t EntryCost>
@@ -124,9 +126,9 @@ LruMap<EntryValue, EntryCost>::get(const char *key)
 {
     MapIterator i;
     findEntry(key, i);
-    Entry *e = *i->second;
     if (i != storage.end()) {
         touch(i);
+        Entry *e = *i->second;
         return e->value;
     }
     return NULL;
@@ -150,7 +152,7 @@ LruMap<EntryValue, EntryCost>::add(const char *key, EntryValue *t)
 
 template <class EntryValue, size_t EntryCost>
 bool
-LruMap<EntryValue, EntryCost>::expired(LruMap::Entry &entry)
+LruMap<EntryValue, EntryCost>::expired(const LruMap::Entry &entry) const
 {
     if (ttl < 0)
         return false;
@@ -163,9 +165,10 @@ bool
 LruMap<EntryValue, EntryCost>::del(LruMap::MapIterator const &i)
 {
     if (i != storage.end()) {
-        delete *(i->second);
+        Entry *e = *i->second;
         index.erase(i->second);
         storage.erase(i);
+        delete e;
         --entries_;
         return true;
     }
@@ -1911,8 +1911,10 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
     fs = find_fstype(type_str);
 
-    if (fs < 0)
-        self_destruct();
+    if (fs < 0) {
+        debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: This proxy does not support the '" << type_str << "' cache type. Ignoring.");
+        return;
+    }
 
     /* reconfigure existing dir */
 
@@ -2332,9 +2334,11 @@ parse_peer(CachePeer ** head)
             p->connection_auth = 1;
         } else if (strcmp(token, "connection-auth=auto") == 0) {
             p->connection_auth = 2;
+        } else if (token[0] == '#') {
+            // start of a text comment. stop reading this line.
+            break;
         } else {
-            debugs(3, DBG_CRITICAL, "parse_peer: token='" << token << "'");
-            self_destruct();
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Ignoring unknown cache_peer option '" << token << "'");
         }
     }
 
@@ -709,6 +709,13 @@ DOC_START
 	  		list separator. ; can be any non-alphanumeric
 			character.
 
+	  %ACL		The name of the ACL being tested.
+	  %DATA		The ACL arguments. If not used then any arguments
+			is automatically added at the end of the line
+			sent to the helper.
+			NOTE: this will encode the arguments as one token,
+			whereas the default will pass each separately.
+
 	  %%		The percent sign. Useful for helpers which need
 			an unchanging input format.
 
@@ -1045,6 +1052,15 @@ DOC_START
 	  # effect in rules that affect the reply data stream such as
 	  # http_reply_access.
 
+	acl aclname note name [value ...]
+	  # match transaction annotation [fast]
+	  # Without values, matches any annotation with a given name.
+	  # With value(s), matches any annotation with a given name that
+	  # also has one of the given values.
+	  # Names and values are compared using a string equality test.
+	  # Annotation sources include note and adaptation_meta directives
+	  # as well as helper and eCAP responses.
+
 IF USE_SSL
 	acl aclname ssl_error errorname
 	  # match against SSL certificate validation error [fast]
@@ -685,13 +685,15 @@ ClientHttpRequest::logRequest()
 
 #endif
 
-    /*Add meta headers*/
+    /*Add notes*/
+    // The al->notes and request->notes must point to the same object.
+    // Enable the following assertion to check for possible bugs.
+    // assert(request->notes == al->notes);
     typedef Notes::iterator ACAMLI;
     for (ACAMLI i = Config.notes.begin(); i != Config.notes.end(); ++i) {
         if (const char *value = (*i)->match(request, al->reply)) {
-            if (al->configNotes == NULL)
-                al->configNotes = new NotePairs;
-            al->configNotes->add((*i)->key.termedBuf(), value);
+            NotePairs &notes = SyncNotes(*al, *request);
+            notes.add((*i)->key.termedBuf(), value);
             debugs(33, 3, HERE << (*i)->key.termedBuf() << " " << value);
         }
     }
@@ -1258,10 +1258,8 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
     // Put helper response Notes into the transaction state record (ALE) eventually
     // do it early to ensure that no matter what the outcome the notes are present.
     if (http->al != NULL) {
-        if (!http->al->helperNotes)
-            http->al->helperNotes = new NotePairs;
-        http->al->helperNotes->append(&reply.notes);
-        old_request->helperNotes = http->al->helperNotes;
+        NotePairs &notes = SyncNotes(*http->al, *old_request);
+        notes.append(&reply.notes);
     }
 
     switch (reply.result) {
@@ -1381,10 +1379,8 @@ ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
     // Put helper response Notes into the transaction state record (ALE) eventually
     // do it early to ensure that no matter what the outcome the notes are present.
     if (http->al != NULL) {
-        if (!http->al->helperNotes)
-            http->al->helperNotes = new NotePairs;
-        http->al->helperNotes->append(&reply.notes);
-        old_request->helperNotes = http->al->helperNotes;
+        NotePairs &notes = SyncNotes(*http->al, *old_request);
+        notes.append(&reply.notes);
     }
 
     switch (reply.result) {
@@ -197,7 +197,11 @@ Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time
            ", timeout=" << timeout);
 
     if (type & COMM_SELECT_READ) {
+        if (F->flags.read_pending)
+            kq_update_events(fd, EVFILT_WRITE, handler);
+
         kq_update_events(fd, EVFILT_READ, handler);
+
         F->read_handler = handler;
         F->read_data = client_data;
     }
@@ -290,31 +294,24 @@ Comm::DoSelect(int msec)
             continue;        /* XXX! */
         }
 
-        switch (ke[i].filter) {
-
-        case EVFILT_READ:
-
+        if (ke[i].filter == EVFILT_READ || F->flags.read_pending) {
             if ((hdl = F->read_handler) != NULL) {
                 F->read_handler = NULL;
                 F->flags.read_pending = 0;
                 hdl(fd, F->read_data);
             }
+        }
 
-            break;
-
-        case EVFILT_WRITE:
-
+        if (ke[i].filter == EVFILT_WRITE) {
             if ((hdl = F->write_handler) != NULL) {
                 F->write_handler = NULL;
                 hdl(fd, F->write_data);
             }
+        }
 
-            break;
-
-        default:
+        if (ke[i].filter != EVFILT_WRITE && ke[i].filter != EVFILT_READ) {
             /* Bad! -- adrian */
             debugs(5, DBG_IMPORTANT, "comm_select: kevent returned " << ke[i].filter << "!");
-            break;
         }
     }
 
@@ -194,6 +194,8 @@ struct _external_acl_format {
 #endif
         EXT_ACL_EXT_LOG,
         EXT_ACL_TAG,
+        EXT_ACL_ACLNAME,
+        EXT_ACL_ACLDATA,
         EXT_ACL_PERCENT,
         EXT_ACL_END
     } type;
@@ -482,6 +484,10 @@ parse_externalAclHelper(external_acl ** list)
             format->type = _external_acl_format::EXT_ACL_EXT_LOG;
         else if (strcmp(token, "%TAG") == 0)
             format->type = _external_acl_format::EXT_ACL_TAG;
+        else if (strcmp(token, "%ACL") == 0)
+            format->type = _external_acl_format::EXT_ACL_ACLNAME;
+        else if (strcmp(token, "%DATA") == 0)
+            format->type = _external_acl_format::EXT_ACL_ACLDATA;
         else if (strcmp(token, "%%") == 0)
             format->type = _external_acl_format::EXT_ACL_PERCENT;
         else {
@@ -681,6 +687,7 @@ external_acl::trimCache()
 
 struct _external_acl_data {
     external_acl *def;
+    const char *name;
     wordlist *arguments;
 };
 
@@ -689,6 +696,7 @@ static void
 free_external_acl_data(void *data)
 {
     external_acl_data *p = static_cast<external_acl_data *>(data);
+    safe_free(p->name);
     wordlistDestroy(&p->arguments);
     cbdataReferenceDone(p->def);
 }
@@ -715,6 +723,10 @@ ACLExternal::parse()
     if (!data->def)
         self_destruct();
 
+    // def->name is the name of the external_acl_type.
+    // this is the name of the 'acl' directive being tested
+    data->name = xstrdup(AclMatchedName);
+
     while ((token = strtokFile())) {
         wordlistAdd(&data->arguments, token);
     }
@@ -954,6 +966,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
     HttpRequest *request = ch->request;
     HttpReply *reply = ch->reply;
     mb.reset();
+    bool data_used = false;
 
     for (format = acl_data->def->format; format; format = format->next) {
         const char *str = NULL;
@@ -1146,6 +1159,29 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
         case _external_acl_format::EXT_ACL_TAG:
             str = request->tag.termedBuf();
             break;
+        case _external_acl_format::EXT_ACL_ACLNAME:
+            str = acl_data->name;
+            break;
+        case _external_acl_format::EXT_ACL_ACLDATA:
+            data_used = true;
+            for (arg = acl_data->arguments; arg; arg = arg->next) {
+                if (!first)
+                    sb.append(" ", 1);
+
+                if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                    const char *quoted = rfc1738_escape(arg->key);
+                    sb.append(quoted, strlen(quoted));
+                } else {
+                    static MemBuf mb2;
+                    mb2.init();
+                    strwordquote(&mb2, arg->key);
+                    sb.append(mb2.buf, mb2.size);
+                    mb2.clean();
+                }
+
+                first = 0;
+            }
+            break;
         case _external_acl_format::EXT_ACL_PERCENT:
             str = "%";
             break;
@@ -1178,18 +1214,20 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
         first = 0;
     }
 
-    for (arg = acl_data->arguments; arg; arg = arg->next) {
-        if (!first)
-            mb.append(" ", 1);
+    if (!data_used) {
+        for (arg = acl_data->arguments; arg; arg = arg->next) {
+            if (!first)
+                mb.append(" ", 1);
 
-        if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-            const char *quoted = rfc1738_escape(arg->key);
-            mb.append(quoted, strlen(quoted));
-        } else {
-            strwordquote(&mb, arg->key);
-        }
+            if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                const char *quoted = rfc1738_escape(arg->key);
+                mb.append(quoted, strlen(quoted));
+            } else {
+                strwordquote(&mb, arg->key);
+            }
 
-        first = 0;
+            first = 0;
+        }
     }
 
     return mb.buf;
@@ -629,7 +629,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_ICAP_REQ_HEADER_ELEM:
-            if (al->request)
+            if (al->icap.request)
                 sb = al->icap.request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
@@ -1049,21 +1049,14 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_NOTE:
             if (fmt->data.string) {
 #if USE_ADAPTATION
-                Adaptation::History::Pointer ah = al->request->adaptHistory();
+                Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL) {
                     if (const char *meta = ah->metaHeaders->find(fmt->data.string))
                         sb.append(meta);
                 }
 #endif
-                if (al->helperNotes != NULL) {
-                    if (const char *note = al->helperNotes->find(fmt->data.string)) {
-                        if (sb.size())
-                            sb.append(", ");
-                        sb.append(note);
-                    }
-                }
-                if (al->configNotes != NULL) {
-                    if (const char *note = al->configNotes->find(fmt->data.string)) {
+                if (al->notes != NULL) {
+                    if (const char *note = al->notes->find(fmt->data.string)) {
                         if (sb.size())
                             sb.append(", ");
                         sb.append(note);
@@ -1073,14 +1066,13 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                 quote = 1;
             } else {
 #if USE_ADAPTATION
-                Adaptation::History::Pointer ah = al->request->adaptHistory();
+                Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL && !ah->metaHeaders->empty())
                     sb.append(ah->metaHeaders->toString());
 #endif
-                if (al->helperNotes != NULL && !al->helperNotes->empty())
-                    sb.append(al->helperNotes->toString());
-                if (al->configNotes != NULL && !al->configNotes->empty())
-                    sb.append(al->configNotes->toString());
+                if (al->notes != NULL && !al->notes->empty())
+                    sb.append(al->notes->toString());
+
                 out = sb.termedBuf();
                 quote = 1;
             }
@@ -301,7 +301,7 @@ Format::Token::parse(const char *def, Quoting *quoting)
     }
 
     if (*cur == '0') {
-        zero = false;
+        zero = true;
         ++cur;
     }
 
@@ -552,7 +552,7 @@ FwdState::checkRetry()
     if (!entry->isEmpty())
         return false;
 
-    if (n_tries > 10)
+    if (n_tries > Config.forward_max_tries)
         return false;
 
     if (squid_curtime - start_t > Config.Timeout.forward)
@@ -165,7 +165,7 @@ void Ssl::CertificateDb::sq_TXT_DB_delete(TXT_DB *db, const char **row)
     if (!db)
         return;
 
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
     for (int i = 0; i < sk_OPENSSL_PSTRING_num(db->data); ++i) {
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db->data, i));
 #else
@@ -183,7 +183,7 @@ void Ssl::CertificateDb::sq_TXT_DB_delete(TXT_DB *db, const char **row)
 void Ssl::CertificateDb::sq_TXT_DB_delete_row(TXT_DB *db, int idx)
 {
     char **rrow;
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
     rrow = (char **)sk_OPENSSL_PSTRING_delete(db->data, idx);
 #else
     rrow = (char **)sk_delete(db->data, idx);
@@ -197,7 +197,7 @@ void Ssl::CertificateDb::sq_TXT_DB_delete_row(TXT_DB *db, int idx)
     const Columns db_indexes[]={cnlSerial, cnlName};
     for (unsigned int i = 0; i < countof(db_indexes); ++i) {
         void *data = NULL;
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
         if (LHASH_OF(OPENSSL_STRING) *fieldIndex =  db->index[db_indexes[i]])
             data = lh_OPENSSL_STRING_delete(fieldIndex, rrow);
 #else
@@ -471,19 +471,11 @@ void Ssl::CertificateDb::load()
         corrupt = true;
 
     // Create indexes in db.
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
-    if (!corrupt && !TXT_DB_create_index(temp_db.get(), cnlSerial, NULL, LHASH_HASH_FN(index_serial), LHASH_COMP_FN(index_serial)))
-        corrupt = true;
-
-    if (!corrupt && !TXT_DB_create_index(temp_db.get(), cnlName, NULL, LHASH_HASH_FN(index_name), LHASH_COMP_FN(index_name)))
-        corrupt = true;
-#else
     if (!corrupt && !TXT_DB_create_index(temp_db.get(), cnlSerial, NULL, LHASH_HASH_FN(index_serial_hash), LHASH_COMP_FN(index_serial_cmp)))
         corrupt = true;
 
     if (!corrupt && !TXT_DB_create_index(temp_db.get(), cnlName, NULL, LHASH_HASH_FN(index_name_hash), LHASH_COMP_FN(index_name_cmp)))
         corrupt = true;
-#endif
 
     if (corrupt)
         throw std::runtime_error("The SSL certificate database " + db_path + " is corrupted. Please rebuild");
@@ -523,7 +515,7 @@ bool Ssl::CertificateDb::deleteInvalidCertificate()
         return false;
 
     bool removed_one = false;
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
     for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
 #else
@@ -548,14 +540,14 @@ bool Ssl::CertificateDb::deleteOldestCertificate()
     if (!db)
         return false;
 
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
     if (sk_OPENSSL_PSTRING_num(db.get()->data) == 0)
 #else
     if (sk_num(db.get()->data) == 0)
 #endif
         return false;
 
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
     const char **row = (const char **)sk_OPENSSL_PSTRING_value(db.get()->data, 0);
 #else
     const char **row = (const char **)sk_value(db.get()->data, 0);
@@ -571,7 +563,7 @@ bool Ssl::CertificateDb::deleteByHostname(std::string const & host)
     if (!db)
         return false;
 
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+#if SQUID_SSLTXTDB_PSTRINGDATA
     for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
 #else
@@ -136,17 +136,17 @@ class CertificateDb
 
     /// Definitions required by openSSL, to use the index_* functions defined above
     ///with TXT_DB_create_index.
-#if OPENSSL_VERSION_NUMBER > 0x10000000L
-    static unsigned long index_serial_LHASH_HASH(const void *a) {
+#if SQUID_USE_SSLLHASH_HACK
+    static unsigned long index_serial_hash_LHASH_HASH(const void *a) {
         return index_serial_hash((const char **)a);
     }
-    static int index_serial_LHASH_COMP(const void *arg1, const void *arg2) {
+    static int index_serial_cmp_LHASH_COMP(const void *arg1, const void *arg2) {
         return index_serial_cmp((const char **)arg1, (const char **)arg2);
     }
-    static unsigned long index_name_LHASH_HASH(const void *a) {
+    static unsigned long index_name_hash_LHASH_HASH(const void *a) {
         return index_name_hash((const char **)a);
     }
-    static int index_name_LHASH_COMP(const void *arg1, const void *arg2) {
+    static int index_name_cmp_LHASH_COMP(const void *arg1, const void *arg2) {
         return index_name_cmp((const char **)arg1, (const char **)arg2);
     }
 #else
@@ -1454,9 +1454,12 @@ bool Ssl::verifySslCertificate(SSL_CTX * sslContext, CertificateProperties const
 {
     // SSL_get_certificate is buggy in openssl versions 1.0.1d and 1.0.1e
     // Try to retrieve certificate directly from SSL_CTX object
-#if OPENSSL_VERSION_NUMBER == 0x1000105fL || OPENSSL_VERSION_NUMBER == 0x1000104fL
+#if SQUID_USE_SSLGETCERTIFICATE_HACK
     X509 ***pCert = (X509 ***)sslContext->cert;
     X509 * cert = pCert && *pCert ? **pCert : NULL;
+#elif SQUID_SSLGETCERTIFICATE_BUGGY
+    X509 * cert = NULL;
+    assert(0);
 #else
     // Temporary ssl for getting X509 certificate from SSL_CTX.
     Ssl::SSL_Pointer ssl(SSL_new(sslContext));
@@ -1559,7 +1562,10 @@ void Ssl::readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Poin
         chain.reset(sk_X509_new_null());
     if (!chain)
         debugs(83, DBG_IMPORTANT, "WARNING: unable to allocate memory for cert chain");
-    pkey.reset(readSslPrivateKey(keyFilename, ssl_ask_password_cb));
+    // XXX: ssl_ask_password_cb needs SSL_CTX_set_default_passwd_cb_userdata()
+    // so this may not fully work iff Config.Program.ssl_password is set.
+    pem_password_cb *cb = ::Config.Program.ssl_password ? &ssl_ask_password_cb : NULL;
+    pkey.reset(readSslPrivateKey(keyFilename, cb));
     cert.reset(readSslX509CertificatesChain(certFilename, chain.get()));
     if (!pkey || !cert || !X509_check_private_key(cert.get(), pkey.get())) {
         pkey.reset(NULL);