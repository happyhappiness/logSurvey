@@ -1,4 +1,6 @@
-/* $Id: filemap.cc,v 1.6 1996/03/27 18:15:44 wessels Exp $ */
+/* $Id: filemap.cc,v 1.7 1996/03/29 21:19:19 wessels Exp $ */
+
+/* DEBUG: Section 8             filemap: swap file bitmap functions */
 
 #include "squid.h"
 
@@ -32,8 +34,8 @@ fileMap *file_map_create(n)
 
     fm->max_n_files = n;
     fm->nwords = n >> LONG_BIT_SHIFT;
-    debug(0, 1, "file_map_create: creating space for %d files\n", n);
-    debug(0, 5, "--> %d words of %d bytes each\n",
+    debug(8, 1, "file_map_create: creating space for %d files\n", n);
+    debug(8, 5, "--> %d words of %d bytes each\n",
 	fm->nwords, sizeof(unsigned long));
     fm->file_map = (unsigned long *) xcalloc(fm->nwords, sizeof(unsigned long));
     return (fm);
@@ -46,7 +48,7 @@ int file_map_bit_set(file_number)
 
 #ifdef XTRA_DEBUG
     if (fm->file_map[file_number >> LONG_BIT_SHIFT] & bitmask)
-	debug(0, 0, "file_map_bit_set: WARNING: file number %d is already set!\n",
+	debug(8, 0, "file_map_bit_set: WARNING: file number %d is already set!\n",
 	    file_number);
 #endif
 
@@ -55,9 +57,9 @@ int file_map_bit_set(file_number)
     fm->n_files_in_map++;
     if (!fm->toggle && (fm->n_files_in_map > ((fm->max_n_files * 7) >> 3))) {
 	fm->toggle++;
-	debug(0, 0, "You should increment MAX_SWAP_FILE\n");
+	debug(8, 0, "You should increment MAX_SWAP_FILE\n");
     } else if (fm->n_files_in_map > (fm->max_n_files - 100)) {
-	debug(0, 0, "You've run out of swap file numbers. Freeing 1MB\n");
+	debug(8, 0, "You've run out of swap file numbers. Freeing 1MB\n");
 	storeGetSwapSpace(1000000);
     }
     return (file_number);
@@ -106,8 +108,8 @@ int file_map_allocate(suggestion)
 	}
     }
 
-    debug(0, 0, "file_map_allocate: All %d files are in use!\n", fm->max_n_files);
-    debug(0, 0, "You need to recompile with a larger value for MAX_SWAP_FILE\n");
+    debug(8, 0, "file_map_allocate: All %d files are in use!\n", fm->max_n_files);
+    debug(8, 0, "You need to recompile with a larger value for MAX_SWAP_FILE\n");
     fatal_dump(NULL);
     return (0);			/* NOTREACHED */
 }
@@ -1,4 +1,8 @@
-/* $Id: ftp.cc,v 1.14 1996/03/28 20:42:46 wessels Exp $ */
+/* $Id: ftp.cc,v 1.15 1996/03/29 21:19:19 wessels Exp $ */
+
+/*
+ * DEBUG: Section 9           ftp: FTP
+ */
 
 #include "squid.h"
 
@@ -111,7 +115,7 @@ void ftpLifetimeExpire(fd, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(0, 4, "ftpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(9, 4, "ftpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
     if (data->icp_page_ptr) {
 	put_free_8k_page(data->icp_page_ptr);
 	data->icp_page_ptr = NULL;
@@ -143,8 +147,8 @@ int ftpReadReply(fd, data)
 	    clen = entry->mem_obj->e_current_len;
 	    off = entry->mem_obj->e_lowest_offset;
 	    if ((clen - off) > FTP_DELETE_GAP) {
-		debug(0, 3, "ftpReadReply: Read deferred for Object: %s\n", entry->key);
-		debug(0, 3, "--> Current Gap: %d bytes\n", clen - off);
+		debug(9, 3, "ftpReadReply: Read deferred for Object: %s\n", entry->key);
+		debug(9, 3, "--> Current Gap: %d bytes\n", clen - off);
 		/* reschedule, so it will automatically be reactivated when
 		 * Gap is big enough. */
 		comm_set_select_handler(fd,
@@ -164,11 +168,11 @@ int ftpReadReply(fd, data)
     }
     errno = 0;
     len = read(fd, buf, READBUFSIZ);
-    debug(0, 5, "ftpReadReply: FD %d, Read %d bytes\n", fd, len);
+    debug(9, 5, "ftpReadReply: FD %d, Read %d bytes\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
 	if (len < 0)
-	    debug(0, 1, "ftpReadReply: read error: %s\n", xstrerror());
+	    debug(9, 1, "ftpReadReply: read error: %s\n", xstrerror());
 	if (errno == ECONNRESET) {
 	    /* Connection reset by peer */
 	    /* consider it as a EOF */
@@ -196,7 +200,7 @@ int ftpReadReply(fd, data)
 	if (!data->got_marker) {
 	    /* If we didn't see the magic marker, assume the transfer failed and arrange
 	     * so the object gets ejected and never gets to disk. */
-	    debug(0, 1, "ftpReadReply: Didn't see magic marker, purging <URL:%s>.\n", entry->url);
+	    debug(9, 1, "ftpReadReply: Didn't see magic marker, purging <URL:%s>.\n", entry->url);
 	    entry->expires = cached_curtime + getNegativeTTL();
 	    BIT_RESET(entry->flag, CACHABLE);
 	    BIT_SET(entry->flag, RELEASE_REQUEST);
@@ -254,7 +258,7 @@ void ftpSendComplete(fd, buf, size, errflag, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(0, 5, "ftpSendComplete: FD %d: size %d: errflag %d.\n",
+    debug(9, 5, "ftpSendComplete: FD %d: size %d: errflag %d.\n",
 	fd, size, errflag);
 
     if (buf) {
@@ -299,7 +303,7 @@ void ftpSendRequest(fd, data)
     int got_negttl = 0;
     int buflen;
 
-    debug(0, 5, "ftpSendRequest: FD %d\n", fd);
+    debug(9, 5, "ftpSendRequest: FD %d\n", fd);
 
     buflen = strlen(data->request) + 256;
     buf = (char *) get_free_8k_page();
@@ -362,7 +366,7 @@ void ftpSendRequest(fd, data)
     strcat(buf, space);
     strcat(buf, data->password);
     strcat(buf, space);
-    debug(0, 5, "ftpSendRequest: FD %d: buf '%s'\n", fd, buf);
+    debug(9, 5, "ftpSendRequest: FD %d: buf '%s'\n", fd, buf);
     data->icp_rwd_ptr = icpWrite(fd, buf, strlen(buf), 30, ftpSendComplete, (caddr_t) data);
 }
 
@@ -372,7 +376,7 @@ void ftpConnInProgress(fd, data)
 {
     StoreEntry *entry = data->entry;
 
-    debug(0, 5, "ftpConnInProgress: FD %d\n", fd);
+    debug(9, 5, "ftpConnInProgress: FD %d\n", fd);
 
     if (comm_connect(fd, "localhost", 3131) != COMM_OK)
 	switch (errno) {
@@ -385,7 +389,7 @@ void ftpConnInProgress(fd, data)
 		(caddr_t) data);
 	    return;
 	case EISCONN:
-	    debug(0, 5, "ftpConnInProgress: FD %d is now connected.", fd);
+	    debug(9, 5, "ftpConnInProgress: FD %d is now connected.", fd);
 	    break;		/* cool, we're connected */
 	default:
 	    comm_close(fd);
@@ -409,7 +413,7 @@ int ftpStart(unusedfd, url, entry)
     FtpData *data = NULL;
     int status;
 
-    debug(0, 3, "FtpStart: FD %d <URL:%s>\n", unusedfd, url);
+    debug(9, 3, "FtpStart: FD %d <URL:%s>\n", unusedfd, url);
 
     data = (FtpData *) xcalloc(1, sizeof(FtpData));
     data->entry = entry;
@@ -420,7 +424,7 @@ int ftpStart(unusedfd, url, entry)
 	safe_free(data);
 	return COMM_ERROR;
     }
-    debug(0, 5, "FtpStart: FD %d, host=%s, request=%s, user=%s, passwd=%s\n",
+    debug(9, 5, "FtpStart: FD %d, host=%s, request=%s, user=%s, passwd=%s\n",
 	unusedfd, data->host, data->request, data->user, data->password);
 
     data->ftp_fd = comm_open(COMM_NONBLOCKING, 0, 0, url);
@@ -439,7 +443,7 @@ int ftpStart(unusedfd, url, entry)
 	    safe_free(data);
 	    return COMM_ERROR;
 	} else {
-	    debug(0, 5, "ftpStart: FD %d: EINPROGRESS.\n", data->ftp_fd);
+	    debug(9, 5, "ftpStart: FD %d: EINPROGRESS.\n", data->ftp_fd);
 	    comm_set_select_handler(data->ftp_fd, COMM_SELECT_LIFETIME,
 		(PF) ftpLifetimeExpire, (caddr_t) data);
 	    comm_set_select_handler(data->ftp_fd, COMM_SELECT_WRITE,
@@ -476,11 +480,11 @@ int ftpInitialize()
     char *ftpget = getFtpProgram();
 
     if (pipe(p) < 0) {
-	debug(0, 0, "ftpInitialize: pipe: %s\n", xstrerror());
+	debug(9, 0, "ftpInitialize: pipe: %s\n", xstrerror());
 	return -1;
     }
     if ((pid = fork()) < 0) {
-	debug(0, 0, "ftpInitialize: fork: %s\n", xstrerror());
+	debug(9, 0, "ftpInitialize: fork: %s\n", xstrerror());
 	return -1;
     }
     if (pid != 0) {		/* parent */
@@ -500,7 +504,7 @@ int ftpInitialize()
 	(void) close(fd);
     sprintf(pbuf, "%d", 3131);
     execlp(ftpget, ftpget, "-D26,1", "-S", pbuf, NULL);
-    debug(0, 0, "ftpInitialize: %s: %s\n", ftpget, xstrerror());
+    debug(9, 0, "ftpInitialize: %s: %s\n", ftpget, xstrerror());
     _exit(1);
     return (1);			/* eliminate compiler warning */
 }
@@ -1,4 +1,8 @@
-/* $Id: gopher.cc,v 1.10 1996/03/28 20:42:47 wessels Exp $ */
+/* $Id: gopher.cc,v 1.11 1996/03/29 21:19:20 wessels Exp $ */
+
+/*
+ * DEBUG: Section 10          gopher: GOPHER
+ */
 
 #include "squid.h"
 
@@ -329,7 +333,7 @@ void gopherToHTML(data, inbuf, len)
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
 		if (data->len + len > TEMP_BUF_SIZE) {
-		    debug(0, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
+		    debug(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
 		    len = TEMP_BUF_SIZE - data->len;
 		}
@@ -355,7 +359,7 @@ void gopherToHTML(data, inbuf, len)
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
 		if ((len - (pos - inbuf)) > TEMP_BUF_SIZE) {
-		    debug(0, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
+		    debug(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
 		    len = TEMP_BUF_SIZE;
 		}
@@ -561,7 +565,7 @@ int gopherReadReplyTimeout(fd, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(0, 4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
+    debug(10, 4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
     cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     if (data->icp_page_ptr)
 	put_free_4k_page(data->icp_page_ptr);
@@ -579,7 +583,7 @@ void gopherLifetimeExpire(fd, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(0, 4, "gopherLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(10, 4, "gopherLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
     cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     if (data->icp_page_ptr)
 	put_free_4k_page(data->icp_page_ptr);
@@ -614,9 +618,9 @@ int gopherReadReply(fd, data)
 	    clen = entry->mem_obj->e_current_len;
 	    off = entry->mem_obj->e_lowest_offset;
 	    if ((clen - off) > GOPHER_DELETE_GAP) {
-		debug(0, 3, "gopherReadReply: Read deferred for Object: %s\n",
+		debug(10, 3, "gopherReadReply: Read deferred for Object: %s\n",
 		    entry->key);
-		debug(0, 3, "                Current Gap: %d bytes\n",
+		debug(10, 3, "                Current Gap: %d bytes\n",
 		    clen - off);
 
 		/* reschedule, so it will automatically reactivated when
@@ -653,10 +657,10 @@ int gopherReadReply(fd, data)
     buf = get_free_4k_page();
     errno = 0;
     len = read(fd, buf, TEMP_BUF_SIZE - 1);	/* leave one space for \0 in gopherToHTML */
-    debug(0, 5, "gopherReadReply: FD %d read len=%d\n", fd, len);
+    debug(10, 5, "gopherReadReply: FD %d read len=%d\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
-	debug(0, 1, "gopherReadReply: error reading: %s\n",
+	debug(10, 1, "gopherReadReply: error reading: %s\n",
 	    xstrerror());
 	if (errno == ECONNRESET) {
 	    /* Connection reset by peer */
@@ -743,7 +747,7 @@ void gopherSendComplete(fd, buf, size, errflag, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(0, 5, "gopherSendComplete: FD %d size: %d errflag: %d\n",
+    debug(10, 5, "gopherSendComplete: FD %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
 	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
@@ -837,7 +841,7 @@ int gopherSendRequest(fd, data)
 	sprintf(buf, "%s%c%c", data->request, CR, LF);
     }
 
-    debug(0, 5, "gopherSendRequest: FD %d\n", fd);
+    debug(10, 5, "gopherSendRequest: FD %d\n", fd);
     data->icp_rwd_ptr = icpWrite(fd,
 	buf,
 	len,
@@ -858,7 +862,7 @@ int gopherStart(unusedfd, url, entry)
 
     data->entry = entry;
 
-    debug(0, 3, "gopherStart: url: %s\n", url);
+    debug(10, 3, "gopherStart: url: %s\n", url);
 
     /* Parse url. */
     if (gopher_url_parser(url, data->host, &data->port,
@@ -870,7 +874,7 @@ int gopherStart(unusedfd, url, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(0, 4, "gopherStart: Failed because we're out of sockets.\n");
+	debug(10, 4, "gopherStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
 	freeGopherData(data);
 	return COMM_ERROR;
@@ -879,7 +883,7 @@ int gopherStart(unusedfd, url, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(0, 4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(10, 4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
 	comm_close(sock);
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	freeGopherData(data);
@@ -915,7 +919,7 @@ int gopherStart(unusedfd, url, entry)
 	    freeGopherData(data);
 	    return COMM_ERROR;
 	} else {
-	    debug(0, 5, "startGopher: conn %d EINPROGRESS\n", sock);
+	    debug(10, 5, "startGopher: conn %d EINPROGRESS\n", sock);
 	}
     }
     /* Install connection complete handler. */
@@ -1,4 +1,8 @@
-/* $Id: http.cc,v 1.14 1996/03/29 01:07:36 wessels Exp $ */
+/* $Id: http.cc,v 1.15 1996/03/29 21:19:21 wessels Exp $ */
+
+/*
+ * DEBUG: Section 11          http: HTTP
+ */
 
 #include "squid.h"
 
@@ -107,7 +111,7 @@ void httpReadReplyTimeout(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(0, 4, "httpReadReplyTimeout: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(11, 4, "httpReadReplyTimeout: FD %d: <URL:%s>\n", fd, entry->url);
     cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     if (data->icp_rwd_ptr)
 	safe_free(data->icp_rwd_ptr);
@@ -127,7 +131,7 @@ void httpLifetimeExpire(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(0, 4, "httpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(11, 4, "httpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
 
     cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     if (data->icp_page_ptr) {
@@ -166,7 +170,7 @@ void httpProcessReplyHeader(data, buf)
     }
     if (data->reply_hdr_state == 1) {
 	data->reply_hdr_state++;
-	debug(0, 9, "GOT HTTP REPLY HDR:\n---------\n%s\n----------\n",
+	debug(11, 9, "GOT HTTP REPLY HDR:\n---------\n%s\n----------\n",
 	    data->reply_hdr);
 	t = strtok(data->reply_hdr, "\r\n");
 	while (t) {
@@ -189,9 +193,9 @@ void httpProcessReplyHeader(data, buf)
 	    t = strtok(NULL, "\r\n");
 	}
 	if (data->http_code)
-	    debug(0, 0, "httpReadReply: HTTP CODE: %d\n", data->http_code);
+	    debug(11, 0, "httpReadReply: HTTP CODE: %d\n", data->http_code);
 	if (data->content_length)
-	    debug(0, 0, "httpReadReply: Content Length: %d\n", data->content_length);
+	    debug(11, 0, "httpReadReply: Content Length: %d\n", data->content_length);
 	/* If we know this is cachable we can unchange the key */
 	switch (data->http_code) {
 	case 200:		/* OK */
@@ -232,8 +236,8 @@ void httpReadReply(fd, data)
 	    clen = entry->mem_obj->e_current_len;
 	    off = entry->mem_obj->e_lowest_offset;
 	    if ((clen - off) > HTTP_DELETE_GAP) {
-		debug(0, 3, "httpReadReply: Read deferred for Object: %s\n", entry->key);
-		debug(0, 3, "                Current Gap: %d bytes\n", clen - off);
+		debug(11, 3, "httpReadReply: Read deferred for Object: %s\n", entry->key);
+		debug(11, 3, "                Current Gap: %d bytes\n", clen - off);
 		/* reschedule, so it will be automatically reactivated
 		 * when Gap is big enough. */
 		comm_set_select_handler(fd,
@@ -266,11 +270,11 @@ void httpReadReply(fd, data)
     }
     errno = 0;
     len = read(fd, buf, READBUFSIZ);
-    debug(0, 5, "httpReadReply: FD %d: len %d.\n", fd, len);
+    debug(11, 5, "httpReadReply: FD %d: len %d.\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
 	/* XXX we we should log when len==0 and current_len==0 */
-	debug(0, 2, "httpReadReply: FD %d: read failure: %s.\n",
+	debug(11, 2, "httpReadReply: FD %d: read failure: %s.\n",
 	    fd, xstrerror());
 	if (errno == ECONNRESET) {
 	    /* Connection reset by peer */
@@ -337,7 +341,7 @@ void httpSendComplete(fd, buf, size, errflag, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(0, 5, "httpSendComplete: FD %d: size %d: errflag %d.\n",
+    debug(11, 5, "httpSendComplete: FD %d: size %d: errflag %d.\n",
 	fd, size, errflag);
 
     if (buf) {
@@ -353,12 +357,16 @@ void httpSendComplete(fd, buf, size, errflag, data)
 	return;
     } else {
 	/* Schedule read reply. */
-	comm_set_select_handler(fd, COMM_SELECT_READ,
-	    (PF) httpReadReply, (caddr_t) data);
-	comm_set_select_handler_plus_timeout(fd, COMM_SELECT_TIMEOUT,
-	    (PF) httpReadReplyTimeout, (caddr_t) data, getReadTimeout());
+	comm_set_select_handler(fd,
+	    COMM_SELECT_READ,
+	    (PF) httpReadReply,
+	    (caddr_t) data);
+	comm_set_select_handler_plus_timeout(fd,
+	    COMM_SELECT_TIMEOUT,
+	    (PF) httpReadReplyTimeout,
+	    (caddr_t) data,
+	    getReadTimeout());
 	comm_set_fd_lifetime(fd, -1);	/* disable lifetime DPW */
-
     }
 }
 
@@ -377,7 +385,7 @@ void httpSendRequest(fd, data)
     int len = 0;
     int buflen;
 
-    debug(0, 5, "httpSendRequest: FD %d: data %p.\n", fd, data);
+    debug(11, 5, "httpSendRequest: FD %d: data %p.\n", fd, data);
     buflen = strlen(data->type) + strlen(data->request);
     if (data->req_hdr)
 	buflen += strlen(data->req_hdr);
@@ -394,7 +402,7 @@ void httpSendRequest(fd, data)
     buf = (char *) get_free_8k_page();
     data->icp_page_ptr = buf;
     if (buflen > DISK_PAGE_SIZE) {
-	debug(0, 0, "Mime header length %d is breaking ICP code\n", buflen);
+	debug(11, 0, "Mime header length %d is breaking ICP code\n", buflen);
     }
     memset(buf, '\0', buflen);
 
@@ -432,7 +440,7 @@ void httpSendRequest(fd, data)
 	len += strlen(post_buf);
 	xfree(post_buf);
     }
-    debug(0, 6, "httpSendRequest: FD %d: buf '%s'\n", fd, buf);
+    debug(11, 6, "httpSendRequest: FD %d: buf '%s'\n", fd, buf);
     data->icp_rwd_ptr = icpWrite(fd, buf, len, 30, httpSendComplete, (caddr_t) data);
 }
 
@@ -473,8 +481,8 @@ int proxyhttpStart(e, url, entry)
     int status;
     HttpData *data = NULL;
 
-    debug(0, 3, "proxyhttpStart: <URL:%s>\n", url);
-    debug(0, 10, "proxyhttpStart: HTTP request header:\n%s\n",
+    debug(11, 3, "proxyhttpStart: <URL:%s>\n", url);
+    debug(11, 10, "proxyhttpStart: HTTP request header:\n%s\n",
 	entry->mem_obj->mime_hdr);
 
     data = (HttpData *) xcalloc(1, sizeof(HttpData));
@@ -492,7 +500,7 @@ int proxyhttpStart(e, url, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(0, 4, "proxyhttpStart: Failed because we're out of sockets.\n");
+	debug(11, 4, "proxyhttpStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
@@ -501,7 +509,7 @@ int proxyhttpStart(e, url, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(0, 4, "proxyhttpstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(11, 4, "proxyhttpstart: Called without IP entry in ipcache. OR lookup failed.\n");
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	httpCloseAndFree(sock, data);
 	return COMM_ERROR;
@@ -515,7 +523,7 @@ int proxyhttpStart(e, url, entry)
 	    e->neighbor_up = 0;
 	    return COMM_ERROR;
 	} else {
-	    debug(0, 5, "proxyhttpStart: FD %d: EINPROGRESS.\n", sock);
+	    debug(11, 5, "proxyhttpStart: FD %d: EINPROGRESS.\n", sock);
 	    comm_set_select_handler(sock, COMM_SELECT_LIFETIME,
 		(PF) httpLifetimeExpire, (caddr_t) data);
 	    comm_set_select_handler(sock, COMM_SELECT_WRITE,
@@ -544,8 +552,8 @@ int httpStart(unusedfd, url, type, req_hdr, entry)
     int sock, status;
     HttpData *data = NULL;
 
-    debug(0, 3, "httpStart: %s <URL:%s>\n", type, url);
-    debug(0, 10, "httpStart: req_hdr '%s'\n", req_hdr);
+    debug(11, 3, "httpStart: %s <URL:%s>\n", type, url);
+    debug(11, 10, "httpStart: req_hdr '%s'\n", req_hdr);
 
     data = (HttpData *) xcalloc(1, sizeof(HttpData));
     data->entry = entry;
@@ -561,7 +569,7 @@ int httpStart(unusedfd, url, type, req_hdr, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(0, 4, "httpStart: Failed because we're out of sockets.\n");
+	debug(11, 4, "httpStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
@@ -570,7 +578,7 @@ int httpStart(unusedfd, url, type, req_hdr, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(0, 4, "httpstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(11, 4, "httpstart: Called without IP entry in ipcache. OR lookup failed.\n");
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	httpCloseAndFree(sock, data);
 	return COMM_ERROR;
@@ -582,7 +590,7 @@ int httpStart(unusedfd, url, type, req_hdr, entry)
 	    httpCloseAndFree(sock, data);
 	    return COMM_ERROR;
 	} else {
-	    debug(0, 5, "httpStart: FD %d: EINPROGRESS.\n", sock);
+	    debug(11, 5, "httpStart: FD %d: EINPROGRESS.\n", sock);
 	    comm_set_select_handler(sock, COMM_SELECT_LIFETIME,
 		(PF) httpLifetimeExpire, (caddr_t) data);
 	    comm_set_select_handler(sock, COMM_SELECT_WRITE,
@@ -1,4 +1,8 @@
-/* $Id: ipcache.cc,v 1.9 1996/03/27 18:15:48 wessels Exp $ */
+/* $Id: ipcache.cc,v 1.10 1996/03/29 21:19:22 wessels Exp $ */
+
+/*
+ * DEBUG: Section 14          ipcache: IP Cache
+ */
 
 #include "squid.h"
 
@@ -120,7 +124,7 @@ int ipcache_create_dnsserver(command)
     int fd;
 
     if ((cfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	debug(0, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
+	debug(14, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
 	return -1;
     }
     fdstat_open(cfd, Socket);
@@ -129,18 +133,18 @@ int ipcache_create_dnsserver(command)
     addr.sun_family = AF_UNIX;
     sprintf(socketname, "dns/dns%d.%d", (int) getpid(), n_dnsserver++);
     strcpy(addr.sun_path, socketname);
-    debug(0, 4, "ipcache_create_dnsserver: path is %s\n", addr.sun_path);
+    debug(14, 4, "ipcache_create_dnsserver: path is %s\n", addr.sun_path);
 
     if (bind(cfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 	close(cfd);
-	debug(0, 0, "ipcache_create_dnsserver: bind: %s\n", xstrerror());
+	debug(14, 0, "ipcache_create_dnsserver: bind: %s\n", xstrerror());
 	return -1;
     }
-    debug(0, 4, "ipcache_create_dnsserver: bind to local host.\n");
+    debug(14, 4, "ipcache_create_dnsserver: bind to local host.\n");
     listen(cfd, 1);
 
     if ((pid = fork()) < 0) {
-	debug(0, 0, "ipcache_create_dnsserver: fork: %s\n", xstrerror());
+	debug(14, 0, "ipcache_create_dnsserver: fork: %s\n", xstrerror());
 	close(cfd);
 	return -1;
     }
@@ -149,7 +153,7 @@ int ipcache_create_dnsserver(command)
 
 	/* open new socket for parent process */
 	if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	    debug(0, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
+	    debug(14, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
 	    return -1;
 	}
 	fcntl(sfd, F_SETFD, 1);	/* set close-on-exec */
@@ -158,10 +162,10 @@ int ipcache_create_dnsserver(command)
 	strcpy(addr.sun_path, socketname);
 	if (connect(sfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 	    close(sfd);
-	    debug(0, 0, "ipcache_create_dnsserver: connect: %s\n", xstrerror());
+	    debug(14, 0, "ipcache_create_dnsserver: connect: %s\n", xstrerror());
 	    return -1;
 	}
-	debug(0, 4, "ipcache_create_dnsserver: FD %d connected to %s #%d.\n",
+	debug(14, 4, "ipcache_create_dnsserver: FD %d connected to %s #%d.\n",
 	    sfd, command, n_dnsserver);
 	return sfd;
     }
@@ -186,21 +190,21 @@ int ipcache_release(e)
     ipcache_entry *result = 0;
     int i;
 
-    debug(0, 5, "ipcache_release: ipcache_count before: %d \n", meta_data.ipcache_count);
+    debug(14, 5, "ipcache_release: ipcache_count before: %d \n", meta_data.ipcache_count);
 
     if (e != NULL && ip_table) {	/* sometimes called with NULL e */
 	hash_link *table_entry = hash_lookup(ip_table, e->name);
 	if (table_entry) {
 	    result = (ipcache_entry *) table_entry;
-	    debug(0, 5, "HASH table count before delete: %d\n", ipcache_hash_entry_count());
+	    debug(14, 5, "HASH table count before delete: %d\n", ipcache_hash_entry_count());
 	    if (hash_remove_link(ip_table, table_entry)) {
-		debug(0, 3, "ipcache_release: Cannot delete '%s' from hash table %d\n", e->name, ip_table);
+		debug(14, 3, "ipcache_release: Cannot delete '%s' from hash table %d\n", e->name, ip_table);
 	    }
-	    debug(0, 5, "HASH table count after delete: %d\n", ipcache_hash_entry_count());
+	    debug(14, 5, "HASH table count after delete: %d\n", ipcache_hash_entry_count());
 	    if (result) {
 		if (result->status == PENDING) {
-		    debug(0, 1, "ipcache_release: Try to release entry with PENDING status. ignored.\n");
-		    debug(0, 5, "ipcache_release: ipcache_count: %d \n", meta_data.ipcache_count);
+		    debug(14, 1, "ipcache_release: Try to release entry with PENDING status. ignored.\n");
+		    debug(14, 5, "ipcache_release: ipcache_count: %d \n", meta_data.ipcache_count);
 		    return -1;
 		}
 		if (result->status == CACHED) {
@@ -215,19 +219,19 @@ int ipcache_release(e)
 		    if (result->entry.h_aliases)
 			safe_free(result->entry.h_aliases);
 		    safe_free(result->entry.h_name);
-		    debug(0, 5, "ipcache_release: Released IP cached record for '%s'.\n", e->name);
+		    debug(14, 5, "ipcache_release: Released IP cached record for '%s'.\n", e->name);
 		}
 		/* XXX: we're having mem mgmt problems; zero, then free */
 		safe_free(result->name);
 		memset(result, '\0', sizeof(ipcache_entry));
 		safe_free(result);
 	    }
 	    --meta_data.ipcache_count;
-	    debug(0, 5, "ipcache_release: ipcache_count when return: %d \n", meta_data.ipcache_count);
+	    debug(14, 5, "ipcache_release: ipcache_count when return: %d \n", meta_data.ipcache_count);
 	    return meta_data.ipcache_count;
 	}
     }
-    debug(0, 3, "ipcache_release: can't delete entry\n");
+    debug(14, 3, "ipcache_release: can't delete entry\n");
     return -1;			/* can't delete entry */
 }
 
@@ -315,7 +319,7 @@ int ipcache_purgelru()
 	if (LRU_list_count >= LRU_cur_size) {
 	    /* have to realloc  */
 	    LRU_cur_size += 16;
-	    debug(0, 3, "ipcache_purgelru: Have to grow LRU_list to %d. This shouldn't happen.\n",
+	    debug(14, 3, "ipcache_purgelru: Have to grow LRU_list to %d. This shouldn't happen.\n",
 		LRU_cur_size);
 	    LRU_list = (ipcache_entry **) xrealloc((char *) LRU_list,
 		LRU_cur_size * sizeof(ipcache_entry *));
@@ -326,12 +330,12 @@ int ipcache_purgelru()
 	}
     }
 
-    debug(0, 3, "ipcache_purgelru: ipcache_count: %5d\n", meta_data.ipcache_count);
-    debug(0, 3, "                  actual count : %5d\n", local_ip_count);
-    debug(0, 3, "                  high W mark  : %5d\n", ipcache_high);
-    debug(0, 3, "                  low  W mark  : %5d\n", ipcache_low);
-    debug(0, 3, "                  not pending  : %5d\n", local_ip_notpending_count);
-    debug(0, 3, "              LRU candidated   : %5d\n", LRU_list_count);
+    debug(14, 3, "ipcache_purgelru: ipcache_count: %5d\n", meta_data.ipcache_count);
+    debug(14, 3, "                  actual count : %5d\n", local_ip_count);
+    debug(14, 3, "                  high W mark  : %5d\n", ipcache_high);
+    debug(14, 3, "                  low  W mark  : %5d\n", ipcache_low);
+    debug(14, 3, "                  not pending  : %5d\n", local_ip_notpending_count);
+    debug(14, 3, "              LRU candidated   : %5d\n", LRU_list_count);
 
     /* sort LRU candidate list */
     qsort((char *) LRU_list, LRU_list_count, sizeof(e), (int (*)(const void *, const void *)) ipcache_compareLastRef);
@@ -343,7 +347,7 @@ int ipcache_purgelru()
 	removed++;
     }
 
-    debug(0, 3, "                   removed      : %5d\n", removed);
+    debug(14, 3, "                   removed      : %5d\n", removed);
     safe_free(LRU_list);
     return (removed > 0) ? 0 : -1;
 }
@@ -354,25 +358,25 @@ ipcache_entry *ipcache_create()
 {
     static ipcache_entry *ipe;
     static ipcache_entry *new;
-    debug(0, 5, "ipcache_create: when enter. ipcache_count == %d\n", meta_data.ipcache_count);
+    debug(14, 5, "ipcache_create: when enter. ipcache_count == %d\n", meta_data.ipcache_count);
 
     if (meta_data.ipcache_count > ipcache_high) {
 	if (ipcache_purgelru() < 0) {
-	    debug(0, 1, "ipcache_create: Cannot release needed IP entry via LRU: %d > %d, removing first entry...\n", meta_data.ipcache_count, MAX_IP);
+	    debug(14, 1, "ipcache_create: Cannot release needed IP entry via LRU: %d > %d, removing first entry...\n", meta_data.ipcache_count, MAX_IP);
 	    ipe = ipcache_GetFirst();
 	    if (!ipe) {
-		debug(0, 1, "ipcache_create: First entry is a null pointer ???\n");
+		debug(14, 1, "ipcache_create: First entry is a null pointer ???\n");
 		/* have to let it grow beyond limit here */
 	    } else if (ipe && ipe->status != PENDING) {
 		ipcache_release(ipe);
 	    } else {
-		debug(0, 1, "ipcache_create: First entry is also PENDING entry.\n");
+		debug(14, 1, "ipcache_create: First entry is also PENDING entry.\n");
 		/* have to let it grow beyond limit here */
 	    }
 	}
     }
     meta_data.ipcache_count++;
-    debug(0, 5, "ipcache_create: before return. ipcache_count == %d\n", meta_data.ipcache_count);
+    debug(14, 5, "ipcache_create: before return. ipcache_count == %d\n", meta_data.ipcache_count);
     new = (ipcache_entry *) xcalloc(1, sizeof(ipcache_entry));
     /* set default to 4, in case parser fail to get token $h_length from
      * dnsserver. */
@@ -387,11 +391,11 @@ void ipcache_add_to_hash(e)
     if (!ipcache_initialized)
 	ipcache_init();
     if (hash_join(ip_table, (hash_link *) e)) {
-	debug(0, 1, "ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
+	debug(14, 1, "ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
 	    e->name, e, ip_table);
     }
-    debug(0, 5, "ipcache_add_to_hash: name <%s>\n", e->name);
-    debug(0, 5, "                     ipcache_count: %d\n", meta_data.ipcache_count);
+    debug(14, 5, "ipcache_add_to_hash: name <%s>\n", e->name);
+    debug(14, 5, "                     ipcache_count: %d\n", meta_data.ipcache_count);
 }
 
 
@@ -403,7 +407,7 @@ void ipcache_add(name, e, data, cached)
 {
     int addr_count, alias_count, i;
 
-    debug(0, 10, "ipcache_add: Adding name '%s' (%s).\n", name,
+    debug(14, 10, "ipcache_add: Adding name '%s' (%s).\n", name,
 	cached ? "cached" : "not cached");
 
     e->name = xstrdup(name);
@@ -469,7 +473,7 @@ void ipcache_update_content(name, e, data, cached)
 {
     int addr_count, alias_count, i;
 
-    debug(0, 10, "ipcache_update: Updating name '%s' (%s).\n", name,
+    debug(14, 10, "ipcache_update: Updating name '%s' (%s).\n", name,
 	cached ? "cached" : "not cached");
 
     if (cached) {
@@ -540,15 +544,15 @@ void ipcache_call_pending(entry)
 	safe_free(p);
     }
     entry->pending_head = entry->pending_tail = NULL;	/* nuke list */
-    debug(0, 10, "ipcache_call_pending: Called %d handlers.\n", nhandler);
+    debug(14, 10, "ipcache_call_pending: Called %d handlers.\n", nhandler);
 }
 
 void ipcache_call_pending_badname(fd, handler, data)
      int fd;
      IPH handler;
      caddr_t data;
 {
-    debug(0, 4, "ipcache_call_pending_badname: Bad Name: Calling handler with NULL result.\n");
+    debug(14, 4, "ipcache_call_pending_badname: Bad Name: Calling handler with NULL result.\n");
     handler(fd, NULL, data);
 }
 
@@ -626,7 +630,7 @@ void globalpending_remove(p, data)
     }
 
     if (q == NULL) {		/* 'p' is not in the list? */
-	debug(0, 1, "globalpending_remove: Failure while deleting entry from global pending list.\n");
+	debug(14, 1, "globalpending_remove: Failure while deleting entry from global pending list.\n");
 	return;
     }
     /* nuke p from the list; do this carefully... */
@@ -679,7 +683,7 @@ int ipcache_parsebuffer(buf, offset, data)
 
 	/* no complete record here */
 	if ((endpos = strstr(pos, "$end\n")) == NULL) {
-	    debug(0, 2, "ipcache_parsebuffer: DNS response incomplete.\n");
+	    debug(14, 2, "ipcache_parsebuffer: DNS response incomplete.\n");
 	    break;
 	}
 	line_head = line_tail = NULL;
@@ -689,12 +693,12 @@ int ipcache_parsebuffer(buf, offset, data)
 	    line_cur = (line_entry *) xcalloc(1, sizeof(line_entry));
 
 	    if ((tpos = memchr(pos, '\n', 4096)) == NULL) {
-		debug(0, 2, "ipcache_parsebuffer: DNS response incomplete.\n");
+		debug(14, 2, "ipcache_parsebuffer: DNS response incomplete.\n");
 		return -1;
 	    }
 	    *tpos = '\0';
 	    line_cur->line = xstrdup(pos);
-	    debug(0, 7, "ipcache_parsebuffer: %s\n", line_cur->line);
+	    debug(14, 7, "ipcache_parsebuffer: %s\n", line_cur->line);
 	    *tpos = '\n';
 
 	    if (line_tail)
@@ -717,7 +721,7 @@ int ipcache_parsebuffer(buf, offset, data)
 	if (strstr(line_head->line, "$alive")) {
 	    data->answer = cached_curtime;
 	    free_lines(line_head);
-	    debug(0, 10, "ipcache_parsebuffer: $alive succeeded.\n");
+	    debug(14, 10, "ipcache_parsebuffer: $alive succeeded.\n");
 	} else if (strstr(line_head->line, "$fail")) {
 	    /*
 	     *  The $fail messages look like:
@@ -731,7 +735,7 @@ int ipcache_parsebuffer(buf, offset, data)
 		strcpy(dns_error_message, line_cur->line + 8);
 	    }
 	    if (token == NULL) {
-		debug(0, 1, "ipcache_parsebuffer: Invalid $fail for DNS table?\n");
+		debug(14, 1, "ipcache_parsebuffer: Invalid $fail for DNS table?\n");
 	    } else {
 		plist = globalpending_search(token, data->global_pending);
 		if (plist) {
@@ -740,10 +744,10 @@ int ipcache_parsebuffer(buf, offset, data)
 		    plist->entry->status = NEGATIVE_CACHED;
 		    ipcache_call_pending(plist->entry);
 		    globalpending_remove(plist, data);
-		    debug(0, 10, "ipcache_parsebuffer: $fail succeeded: %s.\n",
+		    debug(14, 10, "ipcache_parsebuffer: $fail succeeded: %s.\n",
 			dns_error_message[0] ? dns_error_message : "why?");
 		} else {
-		    debug(0, 1, "ipcache_parsebuffer: No entry in DNS table?\n");
+		    debug(14, 1, "ipcache_parsebuffer: No entry in DNS table?\n");
 		}
 	    }
 	    free_lines(line_head);
@@ -754,15 +758,15 @@ int ipcache_parsebuffer(buf, offset, data)
 	    tmp_ptr = NULL;
 	    token = strtok(tmp_ptr, w_space);
 	    if (!token) {
-		debug(0, 1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
+		debug(14, 1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
 	    } else {
 		plist = globalpending_search(token, data->global_pending);
 		if (plist) {
 		    int ipcount, aliascount;
 		    ipcache_entry *e = plist->entry;
 
 		    if (e->status != PENDING) {
-			debug(0, 4, "ipcache_parsebuffer: DNS record already resolved.\n");
+			debug(14, 4, "ipcache_parsebuffer: DNS record already resolved.\n");
 		    } else {
 			e->lastref = e->timestamp = cached_curtime;
 			e->ttl = IP_POS_TTL;
@@ -773,7 +777,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $h_name */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$h_name")) {
-			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $h_name.\n");
+			    debug(14, 1, "ipcache_parsebuffer: DNS record in invalid format? No $h_name.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -789,7 +793,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $h_length */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$h_len")) {
-			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $h_len.\n");
+			    debug(14, 1, "ipcache_parsebuffer: DNS record in invalid format? No $h_len.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -805,7 +809,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $ipcount */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$ipcount")) {
-			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount.\n");
+			    debug(14, 1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -828,7 +832,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			    line_cur = line_cur->next;
 			    while (i < ipcount) {
 				if (line_cur == NULL) {
-				    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount data.\n");
+				    debug(14, 1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount data.\n");
 				    break;
 				}
 				e->entry.h_addr_list[i] = (char *) xcalloc(1, e->entry.h_length);
@@ -841,7 +845,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $aliascount */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$aliascount")) {
-			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount.\n");
+			    debug(14, 1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -864,7 +868,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			    line_cur = line_cur->next;
 			    while (i < aliascount) {
 				if (line_cur == NULL) {
-				    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount data.\n");
+				    debug(14, 1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount data.\n");
 				    break;
 				}
 				e->entry.h_aliases[i] = xstrdup(line_cur->line);
@@ -875,16 +879,16 @@ int ipcache_parsebuffer(buf, offset, data)
 
 			ipcache_call_pending(e);
 			globalpending_remove(plist, data);
-			debug(0, 10, "ipcache_parsebuffer: $name succeeded.\n");
+			debug(14, 10, "ipcache_parsebuffer: $name succeeded.\n");
 		    }
 		} else {
-		    debug(0, 1, "ipcache_parsebuffer: No entries in DNS $name record?\n");
+		    debug(14, 1, "ipcache_parsebuffer: No entries in DNS $name record?\n");
 		}
 	    }
 	    free_lines(line_head);
 	} else {
 	    free_lines(line_head);
-	    debug(0, 1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
+	    debug(14, 1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
 	    return -1;
 	}
     }
@@ -899,11 +903,11 @@ int ipcache_dnsHandleRead(fd, data)
     int char_scanned;
     int len = read(fd, data->ip_inbuf + data->offset, data->size - data->offset);
 
-    debug(0, 5, "ipcache_dnsHandleRead: Result from DNS ID %d.\n", data->id);
+    debug(14, 5, "ipcache_dnsHandleRead: Result from DNS ID %d.\n", data->id);
 
     if (len == 0) {
-	debug(0, 1, "ipcache_dnsHandleRead: Connection from DNSSERVER is closed.\n");
-	debug(0, 1, "                       Disabling this server ID %d.\n", data->id);
+	debug(14, 1, "ipcache_dnsHandleRead: Connection from DNSSERVER is closed.\n");
+	debug(14, 1, "                       Disabling this server ID %d.\n", data->id);
 	data->alive = 0;
 	update_dns_child_alive();
 	ipcache_cleanup_pendinglist(data);
@@ -938,16 +942,16 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
     IpPending *pending;
     dnsserver_entry *dns;
 
-    debug(0, 4, "ipcache_nbgethostbyname: FD %d: Name '%s'.\n", fd, name);
+    debug(14, 4, "ipcache_nbgethostbyname: FD %d: Name '%s'.\n", fd, name);
 
     if (name == NULL || name[0] == '\0') {
-	debug(0, 4, "ipcache_nbgethostbyname: Invalid name!\n");
+	debug(14, 4, "ipcache_nbgethostbyname: Invalid name!\n");
 	ipcache_call_pending_badname(fd, handler, data);
 	return 0;
     }
     if ((e = ipcache_get(name)) != NULL && (e->status != PENDING)) {
 	/* hit here */
-	debug(0, 4, "ipcache_nbgethostbyname: Hit for name '%s'.\n", name);
+	debug(14, 4, "ipcache_nbgethostbyname: Hit for name '%s'.\n", name);
 	pending = (IpPending *) xcalloc(1, sizeof(IpPending));
 	pending->fd = fd;
 	pending->handler = handler;
@@ -962,7 +966,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
 	ipcache_call_pending(e);
 	return 0;
     }
-    debug(0, 4, "ipcache_nbgethostbyname: Name '%s': MISS or PENDING.\n", name);
+    debug(14, 4, "ipcache_nbgethostbyname: Name '%s': MISS or PENDING.\n", name);
 
     pending = (IpPending *) xcalloc(1, sizeof(IpPending));
     pending->fd = fd;
@@ -971,7 +975,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
     pending->next = NULL;
     if (e == NULL) {
 	/* No entry, create the new one */
-	debug(0, 5, "ipcache_nbgethostbyname: Creating new entry for '%s'...\n",
+	debug(14, 5, "ipcache_nbgethostbyname: Creating new entry for '%s'...\n",
 	    name);
 	e = ipcache_create();
 	e->name = xstrdup(name);
@@ -980,7 +984,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
 	ipcache_add_to_hash(e);
     } else {
 	/* There is an entry. Add handler to list */
-	debug(0, 5, "ipcache_nbgethostbyname: Adding handler to pending list for '%s'.\n", name);
+	debug(14, 5, "ipcache_nbgethostbyname: Adding handler to pending list for '%s'.\n", name);
 	if (e->pending_head == NULL) {	/* empty list */
 	    e->pending_head = e->pending_tail = pending;
 	} else {		/* add to tail of list */
@@ -1017,7 +1021,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
     }
 
     dns = dns_child_table[last_dns_dispatched];
-    debug(0, 5, "ipcache_nbgethostbyname: Dispatched DNS %d.\n",
+    debug(14, 5, "ipcache_nbgethostbyname: Dispatched DNS %d.\n",
 	last_dns_dispatched);
 
     /* add to global pending list */
@@ -1046,10 +1050,10 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
 	    0,			/* Handler */
 	    0);			/* Handler-data */
 
-	debug(0, 5, "ipcache_nbgethostbyname: Request sent DNS server ID %d.\n", last_dns_dispatched);
+	debug(14, 5, "ipcache_nbgethostbyname: Request sent DNS server ID %d.\n", last_dns_dispatched);
     } else {
 	/* do a blocking mode */
-	debug(0, 4, "ipcache_nbgethostbyname: Fall back to blocking mode.  Server's dead...\n");
+	debug(14, 4, "ipcache_nbgethostbyname: Fall back to blocking mode.  Server's dead...\n");
 	ipcache_cleanup_pendinglist(dns);
     }
     return 0;
@@ -1062,26 +1066,26 @@ void ipcache_init()
     int i, dnssocket;
     char fd_note_buf[FD_ASCII_NOTE_SZ];
 
-    debug(0, 3, "ipcache_init: Called.  ipcache_initialized=%d  getDnsChildren()=%d\n", ipcache_initialized, getDnsChildren());
+    debug(14, 3, "ipcache_init: Called.  ipcache_initialized=%d  getDnsChildren()=%d\n", ipcache_initialized, getDnsChildren());
 
     if (ipcache_initialized)
 	return;
 
     if (mkdir("dns", 0755) < 0 && errno != EEXIST) {
-	debug(0, 0, "ipcache_init: mkdir %s\n", xstrerror());
+	debug(14, 0, "ipcache_init: mkdir %s\n", xstrerror());
     }
     last_dns_dispatched = getDnsChildren() - 1;
     dns_error_message = xcalloc(1, 256);
 
     /* test naming lookup */
     if (!do_dns_test) {
-	debug(0, 4, "ipcache_init: Skipping DNS name lookup tests, -D flag given.\n");
+	debug(14, 4, "ipcache_init: Skipping DNS name lookup tests, -D flag given.\n");
     } else if (ipcache_testname() < 0) {
-	debug(0, 0, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
+	debug(14, 0, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
 	fprintf(stderr, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
 	exit(-1);
     } else {
-	debug(0, 4, "ipcache_init: Successful DNS name lookup tests...\n");
+	debug(14, 4, "ipcache_init: Successful DNS name lookup tests...\n");
     }
 
     ip_table = hash_create(urlcmp, 229);	/* small hash table */
@@ -1095,13 +1099,13 @@ void ipcache_init()
     /* start up companion process */
     dns_child_table = (dnsserver_entry **) xcalloc(getDnsChildren(), sizeof(dnsserver_entry));
     dns_child_alive = 0;
-    debug(0, 1, "ipcache_init: Starting %d 'dns_server' processes\n",
+    debug(14, 1, "ipcache_init: Starting %d 'dns_server' processes\n",
 	getDnsChildren());
     for (i = 0; i < getDnsChildren(); i++) {
 	dns_child_table[i] = (dnsserver_entry *) xcalloc(1, sizeof(dnsserver_entry));
 	if ((dnssocket = ipcache_create_dnsserver(getDnsProgram())) < 0) {
-	    debug(0, 1, "ipcache_init: WARNING: Cannot run 'dnsserver' process.\n");
-	    debug(0, 1, "              Fallling back to the blocking version.\n");
+	    debug(14, 1, "ipcache_init: WARNING: Cannot run 'dnsserver' process.\n");
+	    debug(14, 1, "              Fallling back to the blocking version.\n");
 	    dns_child_table[i]->alive = 0;
 	} else {
 	    dns_child_alive = 1;
@@ -1122,7 +1126,7 @@ void ipcache_init()
 		dns_child_table[i]->id);
 	    file_update_open(dns_child_table[i]->inpipe, fd_note_buf);
 
-	    debug(0, 5, "Calling fd_note() with FD %d and buf '%s'\n",
+	    debug(14, 5, "Calling fd_note() with FD %d and buf '%s'\n",
 		dns_child_table[i]->inpipe, fd_note_buf);
 
 	    fd_note(dns_child_table[i]->inpipe, fd_note_buf);
@@ -1143,7 +1147,7 @@ void ipcache_init()
 		COMM_SELECT_READ,
 		(PF) ipcache_dnsHandleRead,
 		(caddr_t) dns_child_table[i]);
-	    debug(0, 3, "ipcache_init: 'dns_server' %d started\n", i);
+	    debug(14, 3, "ipcache_init: 'dns_server' %d started\n", i);
 	}
     }
     ipcache_high = (long) (((float) MAX_IP *
@@ -1178,7 +1182,7 @@ int ipcache_unregister(name, fd)
 
     if (p == NULL) {
 	/* Can not find this ipcache_entry, weird */
-	debug(0, 1, "ipcache_unregister: Failed to unregister FD %d from name: %s, can't find this FD.\n",
+	debug(14, 1, "ipcache_unregister: Failed to unregister FD %d from name: %s, can't find this FD.\n",
 	    fd, name);
 	return 0;
     }
@@ -1224,13 +1228,13 @@ struct hostent *ipcache_gethostbyname(name)
 	ipcache_init();
 
     if (!name) {
-	debug(0, 5, "ipcache_gethostbyname: Invalid argument?\n");
+	debug(14, 5, "ipcache_gethostbyname: Invalid argument?\n");
 	return (NULL);
     }
     if (!(result = ipcache_get(name))) {
 	/* cache miss */
 	if (name) {
-	    debug(0, 5, "ipcache_gethostbyname: IPcache miss for '%s'.\n", name);
+	    debug(14, 5, "ipcache_gethostbyname: IPcache miss for '%s'.\n", name);
 	}
 	/* check if it's already a IP address in text form. */
 	if (sscanf(name, "%u.%u.%u.%u", &a1, &a2, &a3, &a4) == 4) {
@@ -1243,20 +1247,20 @@ struct hostent *ipcache_gethostbyname(name)
 
 	if (s_result && s_result->h_name && (s_result->h_name[0] != '\0')) {
 	    /* good address, cached */
-	    debug(0, 10, "ipcache_gethostbyname: DNS success: cache for '%s'.\n", name);
+	    debug(14, 10, "ipcache_gethostbyname: DNS success: cache for '%s'.\n", name);
 	    ipcache_add(name, ipcache_create(), s_result, 1);
 	    result = ipcache_get(name);
 	    return &(result->entry);
 	} else {
 	    /* bad address, negative cached */
-	    debug(0, 3, "ipcache_gethostbyname: DNS failure: negative cache for '%s'.\n", name);
+	    debug(14, 3, "ipcache_gethostbyname: DNS failure: negative cache for '%s'.\n", name);
 	    ipcache_add(name, ipcache_create(), s_result, 0);
 	    return NULL;
 	}
 
     }
     /* cache hit */
-    debug(0, 5, "ipcache_gethostbyname: Hit for '%s'.\n", name ? name : "NULL");
+    debug(14, 5, "ipcache_gethostbyname: Hit for '%s'.\n", name ? name : "NULL");
     result->lastref = cached_curtime;
     return (result->status == CACHED) ? &(result->entry) : NULL;
 }
@@ -1323,7 +1327,7 @@ char ipcache_status_char(e)
     case NEGATIVE_CACHED:
 	return ('N');
     default:
-	debug(0, 1, "ipcache_status_char: unexpected IP cache status.\n");
+	debug(14, 1, "ipcache_status_char: unexpected IP cache status.\n");
     }
     return ('X');
 }
@@ -1,4 +1,6 @@
-/* $Id: main.cc,v 1.15 1996/03/28 03:02:10 wessels Exp $ */
+/* $Id: main.cc,v 1.16 1996/03/29 21:19:22 wessels Exp $ */
+
+/* DEBUG: Section 1             main: startup and main loop */
 
 #include "squid.h"
 
@@ -169,7 +171,7 @@ int main(argc, argv)
     fdstat_open(fileno(debug_log), LOG);
     fd_note(fileno(debug_log), getCacheLogFile());
 
-    debug(0, 0, "Starting Harvest Cache (version %s)...\n", SQUID_VERSION);
+    debug(1, 0, "Starting Harvest Cache (version %s)...\n", SQUID_VERSION);
 
     /* init ipcache */
     ipcache_init();
@@ -198,7 +200,7 @@ int main(argc, argv)
 	COMM_SELECT_READ,
 	asciiHandleConn,
 	0);
-    debug(0, 1, "Accepting HTTP (ASCII) connections on FD %d.\n",
+    debug(1, 1, "Accepting HTTP (ASCII) connections on FD %d.\n",
 	theAsciiConnection);
 
     if (!httpd_accel_mode || getAccelWithProxy()) {
@@ -215,7 +217,7 @@ int main(argc, argv)
 		COMM_SELECT_READ,
 		icpHandleUdp,
 		0);
-	    debug(0, 1, "Accepting ICP (UDP) connections on FD %d.\n",
+	    debug(1, 1, "Accepting ICP (UDP) connections on FD %d.\n",
 		theUdpConnection);
 	}
     }
@@ -237,7 +239,7 @@ int main(argc, argv)
 
     /* after this point we want to see the mallinfo() output */
     do_mallinfo = 1;
-    debug(0, 0, "Ready to serve requests.\n");
+    debug(1, 0, "Ready to serve requests.\n");
 
     /* main loop */
     if (getCleanRate() > 0)
@@ -254,7 +256,7 @@ int main(argc, argv)
 	    break;
 	case COMM_ERROR:
 	    errcount++;
-	    debug(0, 0, "Select loop Error. Retry. %d\n", errcount);
+	    debug(1, 0, "Select loop Error. Retry. %d\n", errcount);
 	    if (errcount == 10)
 		fatal_dump("Select Loop failed.!\n");
 	    break;
@@ -263,15 +265,15 @@ int main(argc, argv)
 	     * when next_cleaning has arrived */
 	    /* garbage collection */
 	    if (getCleanRate() > 0 && cached_curtime >= next_cleaning) {
-		debug(0, 1, "Performing a garbage collection...\n");
+		debug(1, 1, "Performing a garbage collection...\n");
 		n = storePurgeOld();
-		debug(0, 1, "Garbage collection done, %d objects removed\n", n);
+		debug(1, 1, "Garbage collection done, %d objects removed\n", n);
 		next_cleaning = cached_curtime + getCleanRate();
 	    }
 	    /* house keeping */
 	    break;
 	default:
-	    debug(0, 0, "MAIN: Internal error -- this should never happen.\n");
+	    fatal_dump("MAIN: Internal error -- this should never happen.\n");
 	    break;
 	}
     }
@@ -1,5 +1,5 @@
 
-/* $Id: mime.cc,v 1.5 1996/03/29 01:07:37 wessels Exp $ */
+/* $Id: mime.cc,v 1.6 1996/03/29 21:19:23 wessels Exp $ */
 
 #include "squid.h"
 #include "mime_table.h"
@@ -16,8 +16,7 @@ int mime_refresh_request(mime)
     return 0;
 }
 
-ext_table_entry *
-                mime_ext_to_type(extension)
+ext_table_entry *mime_ext_to_type(extension)
      char *extension;
 {
     int i, low, high, comp;
@@ -1,4 +1,8 @@
-/* $Id: neighbors.cc,v 1.7 1996/03/28 05:39:36 wessels Exp $ */
+/* $Id: neighbors.cc,v 1.8 1996/03/29 21:19:24 wessels Exp $ */
+
+/*
+ * DEBUG: Section 15          neighbors:
+ */
 
 #include "squid.h"
 
@@ -42,7 +46,7 @@ edge *whichEdge(header, from)
     port = ntohs(from->sin_port);
     ip = from->sin_addr;
 
-    debug(0, 3, "whichEdge: from %s port %d\n", inet_ntoa(ip), port);
+    debug(15, 3, "whichEdge: from %s port %d\n", inet_ntoa(ip), port);
 
     for (e = friends->edges_head; e; e = e->next) {
 	for (j = 0; j < e->n_addresses; j++) {
@@ -213,7 +217,7 @@ void neighbors_install(host, type, ascii_port, udp_port, proxy_only, domains)
 {
     edge *e;
 
-    debug(0, 1, "Adding a %s: %s\n", type, host);
+    debug(15, 1, "Adding a %s: %s\n", type, host);
 
     e = (edge *) xcalloc(1, sizeof(edge));
 
@@ -263,7 +267,7 @@ void neighbors_open(fd)
 
     if (getsockname(fd, (struct sockaddr *) &our_socket_name,
 	    &sock_name_length) == -1) {
-	debug(0, 1, "getsockname(%d,%p,%p) failed.\n",
+	debug(15, 1, "getsockname(%d,%p,%p) failed.\n",
 	    fd, &our_socket_name, &sock_name_length);
     }
     friends->fd = fd;
@@ -272,16 +276,16 @@ void neighbors_open(fd)
     if ((fname = getHierarchyLogFile())) {
 	log_fd = file_open(fname, NULL, O_WRONLY | O_CREAT | O_APPEND);
 	if (log_fd < 0) {
-	    debug(0, 1, "%s: %s\n", fname, xstrerror());
-	    debug(0, 1, "Hierachical logging is disabled.\n");
+	    debug(15, 1, "%s: %s\n", fname, xstrerror());
+	    debug(15, 1, "Hierachical logging is disabled.\n");
 	} else if (!(cache_hierarchy_log = fdopen(log_fd, "a"))) {
-	    debug(0, 1, "%s: %s\n", fname, xstrerror());
-	    debug(0, 1, "Hierachical logging is disabled.\n");
+	    debug(15, 1, "%s: %s\n", fname, xstrerror());
+	    debug(15, 1, "Hierachical logging is disabled.\n");
 	}
     }
     /* Prepare neighbor connections, one at a time */
     for (e = friends->edges_head; e; e = e->next) {
-	debug(0, 2, "Finding IP addresses for '%s'\n", e->host);
+	debug(15, 2, "Finding IP addresses for '%s'\n", e->host);
 	if ((list = getAddressList(e->host)) == NULL) {
 	    sprintf(tmp_error_buf, "DNS lookup for '%s' failed! Cannot continue.\n",
 		e->host);
@@ -299,7 +303,7 @@ void neighbors_open(fd)
 	    fatal(tmp_error_buf);
 	}
 	for (j = 0; j < e->n_addresses; j++) {
-	    debug(0, 2, "--> IP address #%d: %s\n", j, inet_ntoa(e->addresses[j]));
+	    debug(15, 2, "--> IP address #%d: %s\n", j, inet_ntoa(e->addresses[j]));
 	}
 	e->rtt = 1000;
 
@@ -318,12 +322,12 @@ void neighbors_open(fd)
 	ap->sin_port = htons(e->udp_port);
 
 	if (e->type == is_a_parent) {
-	    debug(0, 3, "parent_install: host %s addr %s port %d\n",
+	    debug(15, 3, "parent_install: host %s addr %s port %d\n",
 		e->host, inet_ntoa(ap->sin_addr),
 		e->udp_port);
 	    e->neighbor_up = 1;
 	} else {
-	    debug(0, 3, "neighbor_install: host %s addr %s port %d\n",
+	    debug(15, 3, "neighbor_install: host %s addr %s port %d\n",
 		e->host, inet_ntoa(ap->sin_addr),
 		e->udp_port);
 	    e->neighbor_up = 1;
@@ -383,7 +387,7 @@ int neighborsUdpPing(proto)
     for (i = 0, e = friends->first_ping; i++ < friends->n; e = e->next) {
 	if (e == (edge *) NULL)
 	    e = friends->edges_head;
-	debug(0, 5, "neighborsUdpPing: Edge %s\n", e->host);
+	debug(15, 5, "neighborsUdpPing: Edge %s\n", e->host);
 
 	/* Don't resolve refreshes through neighbors because we don't resolve
 	 * misses through neighbors */
@@ -398,13 +402,13 @@ int neighborsUdpPing(proto)
 	if (!edgeWouldBePinged(e, host))
 	    continue;		/* next edge */
 
-	debug(0, 4, "neighborsUdpPing: pinging cache %s for <URL:%s>\n",
+	debug(15, 4, "neighborsUdpPing: pinging cache %s for <URL:%s>\n",
 	    e->host, url);
 
 	e->header.reqnum++;
 
 	if (e->udp_port == echo_port) {
-	    debug(0, 4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
+	    debug(15, 4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
 	    icpUdpSend(friends->fd, url, &echo_hdr, &e->in_addr, ICP_OP_DECHO);
 	} else {
 	    icpUdpSend(friends->fd, url, &e->header, &e->in_addr, ICP_OP_QUERY);
@@ -425,7 +429,7 @@ int neighborsUdpPing(proto)
 		/* do this to prevent wrap around but we still want it
 		 * to move a bit so we can debug it easier. */
 		e->ack_deficit = HIER_MAX_DEFICIT + 1;
-	    debug(0, 6, "cache %s is considered dead but send PING anyway, hope it comes up soon.\n",
+	    debug(15, 6, "cache %s is considered dead but send PING anyway, hope it comes up soon.\n",
 		inet_ntoa(e->in_addr.sin_addr));
 	    /* log it once at the threshold */
 	    if ((e->ack_deficit == HIER_MAX_DEFICIT)) {
@@ -446,19 +450,19 @@ int neighborsUdpPing(proto)
     /* only do source_ping if we have neighbors */
     if (echo_hdr.opcode) {
 	if (proto->source_ping && (hep = ipcache_gethostbyname(host))) {
-	    debug(0, 6, "neighborsUdpPing: Send to original host\n");
-	    debug(0, 6, "neighborsUdpPing: url=%s, host=%s, t=%d\n",
+	    debug(15, 6, "neighborsUdpPing: Send to original host\n");
+	    debug(15, 6, "neighborsUdpPing: url=%s, host=%s, t=%d\n",
 		url, host, t);
 	    to_addr.sin_family = AF_INET;
 	    memcpy(&to_addr.sin_addr, hep->h_addr, hep->h_length);
 	    to_addr.sin_port = echo_port;
 	    echo_hdr.reqnum = cached_curtime;
-	    debug(0, 6, "neighborsUdpPing - url: %s to url-host %s \n",
+	    debug(15, 6, "neighborsUdpPing - url: %s to url-host %s \n",
 		url, inet_ntoa(to_addr.sin_addr));
 	    /* send to original site */
 	    icpUdpSend(friends->fd, url, &echo_hdr, &to_addr, ICP_OP_SECHO);
 	} else {
-	    debug(0, 6, "neighborsUdpPing: Source Ping is disabled.\n");
+	    debug(15, 6, "neighborsUdpPing: Source Ping is disabled.\n");
 	}
     }
     return (entry->mem_obj->e_pings_n_pings);
@@ -480,12 +484,12 @@ void neighborsUdpAck(fd, url, header, from, entry)
 {
     edge *e = NULL;
 
-    debug(0, 6, "neighborsUdpAck: url=%s (%d chars), header=0x%x, from=0x%x, ent=0x%x\n",
+    debug(15, 6, "neighborsUdpAck: url=%s (%d chars), header=0x%x, from=0x%x, ent=0x%x\n",
 	url, strlen(url), header, from, entry);
-    debug(0, 6, "     hdr: opcode=%d, ver=%d, shostid=%x, len=%d, rn=0x%x\n",
+    debug(15, 6, "     hdr: opcode=%d, ver=%d, shostid=%x, len=%d, rn=0x%x\n",
 	header->opcode, header->version, header->shostid,
 	header->length, header->reqnum);
-    debug(0, 6, "     from: fam=%d, port=%d, addr=0x%x\n",
+    debug(15, 6, "     from: fam=%d, port=%d, addr=0x%x\n",
 	from->sin_family, from->sin_port, from->sin_addr.s_addr);
 
     /* look up for neighbor/parent entry */
@@ -510,33 +514,33 @@ void neighborsUdpAck(fd, url, header, from, entry)
     /* check if someone is already fetching it */
     if (BIT_TEST(entry->flag, REQ_DISPATCHED) || (entry->ping_status != WAITING)) {
 	if (entry->ping_status == DONE) {
-	    debug(0, 5, "There is already a cache/source dispatched for this object\n");
-	    debug(0, 5, "--> <URL:%s>\n", entry->url);
-	    debug(0, 5, "--> entry->flag & REQ_DISPATCHED = %d\n",
+	    debug(15, 5, "There is already a cache/source dispatched for this object\n");
+	    debug(15, 5, "--> <URL:%s>\n", entry->url);
+	    debug(15, 5, "--> entry->flag & REQ_DISPATCHED = %d\n",
 		BIT_TEST(entry->flag, REQ_DISPATCHED));
-	    debug(0, 5, "--> entry->ping_status = %d\n", entry->ping_status);
+	    debug(15, 5, "--> entry->ping_status = %d\n", entry->ping_status);
 	} else {
-	    debug(0, 5, "The ping already timed out.\n");
-	    debug(0, 5, "--> <URL:%s>\n", entry->url);
-	    debug(0, 5, "--> entry->flag & REQ_DISPATCHED = %lx\n",
+	    debug(15, 5, "The ping already timed out.\n");
+	    debug(15, 5, "--> <URL:%s>\n", entry->url);
+	    debug(15, 5, "--> entry->flag & REQ_DISPATCHED = %lx\n",
 		BIT_TEST(entry->flag, REQ_DISPATCHED));
-	    debug(0, 5, "--> entry->ping_status = %d\n", entry->ping_status);
+	    debug(15, 5, "--> entry->ping_status = %d\n", entry->ping_status);
 	}
 	return;
     }
-    debug(0, 6, "neighborsUdpAck - url: %s to us %s \n",
+    debug(15, 6, "neighborsUdpAck - url: %s to us %s \n",
 	url, e ? inet_ntoa(e->in_addr.sin_addr) : "url-host");
 
     if (header->opcode == ICP_OP_SECHO) {
 	/* receive ping back from source or from non-cached cache */
 	if (e) {
-	    debug(0, 6, "Got SECHO from non-cached cache:%s\n",
+	    debug(15, 6, "Got SECHO from non-cached cache:%s\n",
 		inet_ntoa(e->in_addr.sin_addr));
-	    debug(0, 6, "This is not supposed to happen.  Ignored.\n");
+	    debug(15, 6, "This is not supposed to happen.  Ignored.\n");
 	} else {
 	    /* if we reach here, source is the one has the fastest respond. */
 	    /* fetch directly from source */
-	    debug(0, 6, "Source is the first to respond.\n");
+	    debug(15, 6, "Source is the first to respond.\n");
 	    hierarchy_log_append(entry->url,
 		HIER_SOURCE_FASTEST,
 		0,
@@ -555,7 +559,7 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	    return;
 	}
 	/* GOT a HIT here */
-	debug(0, 6, "HIT: Getting %s from host: %s\n", entry->url, e->host);
+	debug(15, 6, "HIT: Getting %s from host: %s\n", entry->url, e->host);
 	if (e->type == is_a_neighbor) {
 	    hierarchy_log_append(entry->url, HIER_NEIGHBOR_HIT, 0, e->host);
 	} else {
@@ -576,24 +580,24 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	    /* receive ping back from non-cached cache */
 
 	    if (e) {
-		debug(0, 6, "Got DECHO from non-cached cache:%s\n",
+		debug(15, 6, "Got DECHO from non-cached cache:%s\n",
 		    inet_ntoa(e->in_addr.sin_addr));
-		debug(0, 6, "Good.");
+		debug(15, 6, "Good.");
 
 		if (e->type == is_a_parent) {
 		    if (entry->mem_obj->e_pings_first_miss == NULL) {
-			debug(0, 6, "OK. We got dumb-cached parent as the first miss here.\n");
+			debug(15, 6, "OK. We got dumb-cached parent as the first miss here.\n");
 			entry->mem_obj->e_pings_first_miss = e;
 		    }
 		} else {
-		    debug(0, 6, "Dumb Cached as a neighbor does not make sense.\n");
-		    debug(0, 6, "Count it anyway.\n");
+		    debug(15, 6, "Dumb Cached as a neighbor does not make sense.\n");
+		    debug(15, 6, "Count it anyway.\n");
 		}
 
 
 	    } else {
-		debug(0, 6, "Got DECHO from non-cached cache: But the host is not in the list.\n");
-		debug(0, 6, "Count it anyway.\n");
+		debug(15, 6, "Got DECHO from non-cached cache: But the host is not in the list.\n");
+		debug(15, 6, "Count it anyway.\n");
 	    }
 
 	} else {
@@ -607,14 +611,14 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	if (entry->mem_obj->e_pings_n_acks == entry->mem_obj->e_pings_n_pings) {
 	    BIT_SET(entry->flag, REQ_DISPATCHED);
 	    entry->ping_status = DONE;
-	    debug(0, 6, "Receive MISSes from all neighbors and parents\n");
+	    debug(15, 6, "Receive MISSes from all neighbors and parents\n");
 	    /* pass in fd=0 here so getFromCache() looks up the real FD
 	     * and resets the timeout handler */
 	    getFromDefaultSource(0, entry);
 	    return;
 	}
     } else {
-	debug(0, 0, "neighborsUdpAck: WHY ARE WE HERE?  header->opcode = %d\n",
+	debug(15, 0, "neighborsUdpAck: WHY ARE WE HERE?  header->opcode = %d\n",
 	    header->opcode);
     }
 }
@@ -686,9 +690,9 @@ void neighbors_init()
 		t->ascii_port, t->udp_port, t->proxy_only,
 		t->domains);
 	} else {
-	    debug(0, 0, "neighbors_init: skipping cache_host %s %s %d %d\n",
+	    debug(15, 0, "neighbors_init: skipping cache_host %s %s %d %d\n",
 		t->type, t->host, t->ascii_port, t->udp_port);
-	    debug(0, 0, "neighbors_init: because it seems to be identical to this cached\n");
+	    debug(15, 0, "neighbors_init: because it seems to be identical to this cached\n");
 	}
 	xfree(t->host);
 	xfree(t->type);
@@ -707,7 +711,7 @@ void neighbors_rotate_log()
     if ((fname = getHierarchyLogFile()) == NULL)
 	return;
 
-    debug(0, 1, "neighbors_rotate_log: Rotating.\n");
+    debug(15, 1, "neighbors_rotate_log: Rotating.\n");
 
     /* Rotate numbers 0 through N up one */
     for (i = getLogfileRotateNumber(); i > 1;) {
@@ -726,11 +730,11 @@ void neighbors_rotate_log()
     fclose(cache_hierarchy_log);
     log_fd = file_open(fname, NULL, O_WRONLY | O_CREAT | O_APPEND);
     if (log_fd < 0) {
-	debug(0, 0, "rotate_logs: %s: %s\n", fname, xstrerror());
-	debug(0, 1, "Hierachical logging is disabled.\n");
+	debug(15, 0, "rotate_logs: %s: %s\n", fname, xstrerror());
+	debug(15, 1, "Hierachical logging is disabled.\n");
     } else if ((cache_hierarchy_log = fdopen(log_fd, "a")) == NULL) {
-	debug(0, 0, "rotate_logs: %s: %s\n",
+	debug(15, 0, "rotate_logs: %s: %s\n",
 	    fname, xstrerror());
-	debug(0, 1, "Hierachical logging is disabled.\n");
+	debug(15, 1, "Hierachical logging is disabled.\n");
     }
 }
@@ -1,4 +1,8 @@
-/* $Id: stat.cc,v 1.9 1996/03/28 02:34:04 wessels Exp $ */
+/* $Id: stat.cc,v 1.10 1996/03/29 21:19:25 wessels Exp $ */
+
+/*
+ * DEBUG: Section 18          stat
+ */
 
 #include "squid.h"
 
@@ -156,7 +160,7 @@ void stat_objects_get(obj, sentry, vm_or_not)
 	    continue;
 	if ((++N & 0xFF) == 0) {
 	    cached_curtime = time(NULL);
-	    debug(0, 3, "stat_objects_get:  Processed %d objects...\n", N);
+	    debug(18, 3, "stat_objects_get:  Processed %d objects...\n", N);
 	}
 	obj_size = entry->object_len;
 	npend = storePendingNClients(entry);
@@ -784,7 +788,7 @@ void log_append(obj, url, id, size, action, method)
 
 	if (file_write(obj->logfile_fd, buf = xstrdup(tmp), strlen(tmp),
 		obj->logfile_access, NULL, NULL) != DISK_OK) {
-	    debug(0, 1, "log_append: File write failed.\n");
+	    debug(18, 1, "log_append: File write failed.\n");
 	    safe_free(buf);
 	}
     }
@@ -802,7 +806,7 @@ void log_enable(obj, sentry)
 	/* open the logfile */
 	obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
 	if (obj->logfile_fd == DISK_ERROR) {
-	    debug(0, 0, "Cannot open logfile: %s\n", obj->logfilename);
+	    debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	    obj->logfile_status = LOG_DISABLE;
 	}
 	obj->logfile_access = file_write_lock(obj->logfile_fd);
@@ -848,7 +852,7 @@ void log_clear(obj, sentry)
     /* reopen it anyway */
     obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
     if (obj->logfile_fd == DISK_ERROR) {
-	debug(0, 0, "Cannot open logfile: %s\n", obj->logfilename);
+	debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	obj->logfile_status = LOG_DISABLE;
     }
     /* at the moment, store one char to make a storage manager happy */
@@ -970,7 +974,7 @@ void stat_init(object, logfilename)
     memcpy(obj->logfilename, logfilename, (int) (strlen(logfilename) + 1) % 256);
     obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
     if (obj->logfile_fd == DISK_ERROR) {
-	debug(0, 0, "Cannot open logfile: %s\n", obj->logfilename);
+	debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	obj->logfile_status = LOG_DISABLE;
 	fatal("Cannot open logfile.\n");
     }
@@ -1195,7 +1199,7 @@ void stat_rotate_log()
     if ((fname = CacheInfo->logfilename) == NULL)
 	return;
 
-    debug(0, 1, "stat_rotate_log: Rotating\n");
+    debug(18, 1, "stat_rotate_log: Rotating\n");
 
     /* Rotate numbers 0 through N up one */
     for (i = getLogfileRotateNumber(); i > 1;) {
@@ -1214,7 +1218,7 @@ void stat_rotate_log()
     file_close(CacheInfo->logfile_fd);
     CacheInfo->logfile_fd = file_open(fname, NULL, O_RDWR | O_CREAT | O_APPEND);
     if (CacheInfo->logfile_fd == DISK_ERROR) {
-	debug(0, 0, "rotate_logs: Cannot open logfile: %s\n", fname);
+	debug(18, 0, "rotate_logs: Cannot open logfile: %s\n", fname);
 	CacheInfo->logfile_status = LOG_DISABLE;
 	fatal("Cannot open logfile.\n");
     }
@@ -1,4 +1,8 @@
-/* $Id: stmem.cc,v 1.4 1996/03/27 18:15:54 wessels Exp $ */
+/* $Id: stmem.cc,v 1.5 1996/03/29 21:19:26 wessels Exp $ */
+
+/* 
+ * DEBUG: Section 19          stmem:
+ */
 
 #include "squid.h"
 
@@ -83,8 +87,8 @@ int memFreeDataUpto(mem, target_offset)
 	return current_offset;
     }
     if (current_offset != target_offset) {
-	debug(0, 1, "memFreeDataBehind: This shouldn't happen. Some odd condition.\n");
-	debug(0, 1, "   Current offset: %d  Target offset: %d  p: %p\n",
+	debug(19, 1, "memFreeDataBehind: This shouldn't happen. Some odd condition.\n");
+	debug(19, 1, "   Current offset: %d  Target offset: %d  p: %p\n",
 	    current_offset, target_offset, p);
     }
     return current_offset;
@@ -102,7 +106,7 @@ int memAppend(mem, data, len)
     int avail_len;
     int len_to_copy;
 
-    debug(0, 6, "memAppend: len %d\n", len);
+    debug(19, 6, "memAppend: len %d\n", len);
 
     /* Does the last block still contain empty space? 
      * If so, fill out the block before dropping into the
@@ -148,14 +152,14 @@ int memGrep(mem, string, nbytes)
     char *str_i, *mem_i;
     int i = 0, blk_idx = 0, state, goal;
 
-    debug(0, 6, "memGrep: looking for %s in less than %d bytes.\n",
+    debug(19, 6, "memGrep: looking for %s in less than %d bytes.\n",
 	string, nbytes);
 
     if (!p)
 	return 0;
 
     if (mem->origin_offset != 0) {
-	debug(0, 1, "memGrep: Some lower chunk of data has been erased. Can't do memGrep!\n");
+	debug(19, 1, "memGrep: Some lower chunk of data has been erased. Can't do memGrep!\n");
 	return 0;
     }
     str_i = string;
@@ -203,7 +207,7 @@ int memCopy(mem, offset, buf, size)
     int bytes_from_this_packet = 0;
     int bytes_into_this_packet = 0;
 
-    debug(0, 6, "memCopy: offset %d: size %d\n", offset, size);
+    debug(19, 6, "memCopy: offset %d: size %d\n", offset, size);
 
     if (size <= 0)
 	return size;
@@ -214,7 +218,7 @@ int memCopy(mem, offset, buf, size)
 	if (p->next)
 	    p = p->next;
 	else {
-	    debug(0, 1, "memCopy: Offset: %d is off limit of current object of %d\n", t_off, offset);
+	    debug(19, 1, "memCopy: Offset: %d is off limit of current object of %d\n", t_off, offset);
 	    return 0;
 	}
     }
@@ -286,7 +290,7 @@ char *
     }
     sm_stats.n_pages_in_use++;
     if (page == NULL) {
-	debug(0, 0, "Null page pointer?");
+	debug(19, 0, "Null page pointer?");
 	fatal_dump(NULL);
     }
     return (page);
@@ -299,14 +303,14 @@ void put_free_4k_page(page)
 
 #if USE_MEMALIGN
     if ((int) page % SM_PAGE_SIZE) {
-	debug(0, 0, "Someone tossed a string into the 4k page pool\n");
+	debug(19, 0, "Someone tossed a string into the 4k page pool\n");
 	fatal_dump(NULL);
     }
 #endif
     if (full_stack(&sm_stats.free_page_stack)) {
 	sm_stats.total_pages_allocated--;
 	if (!stack_overflow_warning_toggle) {
-	    debug(0, 0, "Stack of free stmem pages overflowed.  Resize it?");
+	    debug(19, 0, "Stack of free stmem pages overflowed.  Resize it?");
 	    stack_overflow_warning_toggle++;
 	}
     }
@@ -334,7 +338,7 @@ char *get_free_8k_page()
     }
     disk_stats.n_pages_in_use++;
     if (page == NULL) {
-	debug(0, 0, "Null page pointer?");
+	debug(19, 0, "Null page pointer?");
 	fatal_dump(NULL);
     }
     return (page);
@@ -347,15 +351,15 @@ void put_free_8k_page(page)
 
 #if USE_MEMALIGN
     if ((int) page % DISK_PAGE_SIZE) {
-	debug(0, 0, "Someone tossed a string into the 8k page pool\n");
+	debug(19, 0, "Someone tossed a string into the 8k page pool\n");
 	fatal_dump(NULL);
     }
 #endif
 
     if (full_stack(&disk_stats.free_page_stack)) {
 	disk_stats.total_pages_allocated--;
 	if (!stack_overflow_warning_toggle) {
-	    debug(0, 0, "Stack of free disk pages overflowed.  Resize it?");
+	    debug(19, 0, "Stack of free disk pages overflowed.  Resize it?");
 	    stack_overflow_warning_toggle++;
 	}
     }
@@ -1,5 +1,9 @@
 
-/* $Id: tools.cc,v 1.17 1996/03/28 06:10:04 wessels Exp $ */
+/* $Id: tools.cc,v 1.18 1996/03/29 21:19:27 wessels Exp $ */
+
+/*
+ * DEBUG: Section 21          tools
+ */
 
 #include "squid.h"
 
@@ -24,7 +28,7 @@ static char *dead_msg()
 
 void mail_warranty()
 {
-    FILE *fp;
+    FILE *fp = NULL;
     static char filename[256];
     static char command[256];
 
@@ -131,7 +135,7 @@ void death(sig)
 void rotate_logs(sig)
      int sig;
 {
-    debug(0, 1, "rotate_logs: SIGHUP received.\n");
+    debug(21, 1, "rotate_logs: SIGHUP received.\n");
 
     storeWriteCleanLog();
     neighbors_rotate_log();
@@ -145,10 +149,10 @@ void rotate_logs(sig)
 void shut_down(sig)
      int sig;
 {
-    debug(0, 1, "Shutting down...\n");
+    debug(21, 1, "Shutting down...\n");
     storeWriteCleanLog();
     PrintRusage(NULL, stderr);
-    debug(0, 0, "Harvest Cache (Version %s): Exiting due to signal %d.\n",
+    debug(21, 0, "Harvest Cache (Version %s): Exiting due to signal %d.\n",
 	SQUID_VERSION, sig);
     exit(1);
 }
@@ -166,8 +170,8 @@ void fatal_common(message)
     fflush(stderr);
     PrintRusage(NULL, stderr);
     if (debug_log != stderr) {
-	debug(0, 0, "FATAL: %s\n", message);
-	debug(0, 0, "Harvest Cache (Version %s): Terminated abnormally.\n",
+	debug(21, 0, "FATAL: %s\n", message);
+	debug(21, 0, "Harvest Cache (Version %s): Terminated abnormally.\n",
 	    SQUID_VERSION);
     }
 }
@@ -212,7 +216,7 @@ void sig_child(sig)
     int pid;
 
     if ((pid = waitpid(-1, &status, WNOHANG)) > 0)
-	debug(0, 3, "sig_child: Ate pid %d\n", pid);
+	debug(21, 3, "sig_child: Ate pid %d\n", pid);
 
 #if defined(_SQUID_SYSV_SIGNALS_)
     signal(sig, sig_child);
@@ -240,7 +244,7 @@ int getMaxFD()
 #else
 	i = 64;			/* 64 is a safe default */
 #endif
-	debug(0, 10, "getMaxFD set MaxFD at %d\n", i);
+	debug(21, 10, "getMaxFD set MaxFD at %d\n", i);
     }
     return (i);
 }
@@ -250,12 +254,16 @@ char *getMyHostname()
     static char host[SQUIDHOSTNAMELEN + 1];
     static int present = 0;
     struct hostent *h = NULL;
+    char *t = NULL;
+
+    if ((t = getVisibleHostname()))
+	return t;
 
     /* Get the host name and store it in host to return */
     if (!present) {
 	host[0] = '\0';
 	if (gethostname(host, SQUIDHOSTNAMELEN) == -1) {
-	    debug(0, 1, "comm_hostname: gethostname failed: %s\n",
+	    debug(21, 1, "getMyHostname: gethostname failed: %s\n",
 		xstrerror());
 	    return NULL;
 	} else {
@@ -277,7 +285,7 @@ int safeunlink(s, quiet)
     int err;
     if ((err = unlink(s)) < 0)
 	if (!quiet)
-	    debug(0, 1, "safeunlink: Couldn't delete %s. %s\n", s, xstrerror());
+	    debug(21, 1, "safeunlink: Couldn't delete %s. %s\n", s, xstrerror());
     return (err);
 }
 
@@ -315,7 +323,7 @@ void check_suid()
 	return;
     /* change current directory to swap space so we can get core */
     if (chdir(swappath(0))) {
-	debug(0, 1, "Chdir Failed: Cached cannot write core file when it crash: %s\n",
+	debug(21, 1, "Chdir Failed: Cached cannot write core file when it crash: %s\n",
 	    xstrerror());
     }
     if (getEffectiveGroup() && (grp = getgrnam(getEffectiveGroup()))) {
@@ -334,8 +342,8 @@ void writePidFile()
     if ((f = getPidFilename()) == NULL)
 	return;
     if ((pid_fp = fopen(f, "w")) == NULL) {
-	debug(0, 0, "WARNING: Could not write pid file\n");
-	debug(0, 0, "         %s: %s\n", f, xstrerror());
+	debug(21, 0, "WARNING: Could not write pid file\n");
+	debug(21, 0, "         %s: %s\n", f, xstrerror());
 	return;
     }
     fprintf(pid_fp, "%d\n", (int) getpid());
@@ -368,8 +376,8 @@ void setMaxFD()
 	}
     }
 #endif
-    debug(0, 1, "setMaxFD: Using %d file descriptors\n", rl.rlim_max);
+    debug(21, 1, "setMaxFD: Using %d file descriptors\n", rl.rlim_max);
 #else /* HAVE_SETRLIMIT */
-    debug(0, 1, "setMaxFD: Cannot increase: setrlimit() not supported on this system");
+    debug(21, 1, "setMaxFD: Cannot increase: setrlimit() not supported on this system");
 #endif
 }
@@ -1,11 +1,15 @@
-/* $Id: url.cc,v 1.4 1996/03/27 18:15:57 wessels Exp $ */
+/* $Id: url.cc,v 1.5 1996/03/29 21:19:28 wessels Exp $ */
+
+/* 
+ * DEBUG: Section 23          url
+ */
 
 #include "squid.h"
 
 
-int url_acceptable[256];
-int url_acceptable_init = 0;
-char hex[17] = "0123456789abcdef";
+static int url_acceptable[256];
+static int url_acceptable_init = 0;
+static char hex[17] = "0123456789abcdef";
 
 /* convert %xx in url string to a character 
  * Allocate a new string and return a pointer to converted string */
@@ -41,7 +45,7 @@ char *url_convert_hex(org_url)
 
 /* INIT Acceptable table. 
  * Borrow from libwww2 with Mosaic2.4 Distribution   */
-void init_url_acceptable()
+static void init_url_acceptable()
 {
     unsigned int i;
     char *good =
@@ -80,6 +84,7 @@ char *url_escape(url)
 }
 
 
+#ifdef NOT_YET_USED
 /*
  * Strip the url from e->key, return a pointer to a static copy of it.
  * Planning ahead for removing e->url from meta-data
@@ -125,8 +130,9 @@ char *the_url(e)
 	/* discard "/head/" or "head/" from the key and get url */
 	return URL;
     } else {
-	debug(0, 0, "Should not be here. Unknown format of the key: %s\n",
+	debug(23, 0, "Should not be here. Unknown format of the key: %s\n",
 	    e->key);
 	return (NULL);
     }
 }
+#endif